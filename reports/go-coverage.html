
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">catalogizer/config/config.go (0.0%)</option>
				
				<option value="file1">catalogizer/database/connection.go (0.0%)</option>
				
				<option value="file2">catalogizer/database/migrations.go (0.0%)</option>
				
				<option value="file3">catalogizer/filesystem/factory.go (83.3%)</option>
				
				<option value="file4">catalogizer/filesystem/ftp_client.go (1.6%)</option>
				
				<option value="file5">catalogizer/filesystem/local_client.go (47.7%)</option>
				
				<option value="file6">catalogizer/filesystem/nfs_client.go (1.6%)</option>
				
				<option value="file7">catalogizer/filesystem/smb_client.go (8.1%)</option>
				
				<option value="file8">catalogizer/filesystem/webdav_client.go (2.3%)</option>
				
				<option value="file9">catalogizer/handlers/auth_handler.go (0.0%)</option>
				
				<option value="file10">catalogizer/handlers/browse.go (0.0%)</option>
				
				<option value="file11">catalogizer/handlers/configuration_handler.go (0.0%)</option>
				
				<option value="file12">catalogizer/handlers/conversion_handler.go (0.0%)</option>
				
				<option value="file13">catalogizer/handlers/copy.go (0.0%)</option>
				
				<option value="file14">catalogizer/handlers/download.go (0.0%)</option>
				
				<option value="file15">catalogizer/handlers/error_reporting_handler.go (0.0%)</option>
				
				<option value="file16">catalogizer/handlers/log_management_handler.go (0.0%)</option>
				
				<option value="file17">catalogizer/handlers/role_handler.go (0.0%)</option>
				
				<option value="file18">catalogizer/handlers/search.go (0.0%)</option>
				
				<option value="file19">catalogizer/handlers/stats.go (0.0%)</option>
				
				<option value="file20">catalogizer/handlers/stress_test_handler.go (0.0%)</option>
				
				<option value="file21">catalogizer/handlers/user_handler.go (0.0%)</option>
				
				<option value="file22">catalogizer/internal/auth/middleware.go (0.0%)</option>
				
				<option value="file23">catalogizer/internal/auth/models.go (0.0%)</option>
				
				<option value="file24">catalogizer/internal/auth/service.go (0.0%)</option>
				
				<option value="file25">catalogizer/internal/config/config.go (0.0%)</option>
				
				<option value="file26">catalogizer/internal/handlers/auth.go (0.0%)</option>
				
				<option value="file27">catalogizer/internal/handlers/catalog.go (59.4%)</option>
				
				<option value="file28">catalogizer/internal/handlers/copy.go (10.4%)</option>
				
				<option value="file29">catalogizer/internal/handlers/download.go (0.0%)</option>
				
				<option value="file30">catalogizer/internal/handlers/localization_handlers.go (0.0%)</option>
				
				<option value="file31">catalogizer/internal/handlers/media.go (0.0%)</option>
				
				<option value="file32">catalogizer/internal/handlers/media_player_handlers.go (0.0%)</option>
				
				<option value="file33">catalogizer/internal/handlers/recommendation_handler.go (0.0%)</option>
				
				<option value="file34">catalogizer/internal/handlers/smb.go (0.0%)</option>
				
				<option value="file35">catalogizer/internal/handlers/smb_discovery.go (0.0%)</option>
				
				<option value="file36">catalogizer/internal/media/analyzer/analyzer.go (0.0%)</option>
				
				<option value="file37">catalogizer/internal/media/database/database.go (0.0%)</option>
				
				<option value="file38">catalogizer/internal/media/detector/engine.go (0.0%)</option>
				
				<option value="file39">catalogizer/internal/media/manager.go (0.0%)</option>
				
				<option value="file40">catalogizer/internal/media/models/media.go (0.0%)</option>
				
				<option value="file41">catalogizer/internal/media/providers/providers.go (0.0%)</option>
				
				<option value="file42">catalogizer/internal/media/realtime/enhanced_watcher.go (0.0%)</option>
				
				<option value="file43">catalogizer/internal/media/realtime/watcher.go (0.0%)</option>
				
				<option value="file44">catalogizer/internal/middleware/middleware.go (0.0%)</option>
				
				<option value="file45">catalogizer/internal/recovery/circuit_breaker.go (0.0%)</option>
				
				<option value="file46">catalogizer/internal/recovery/retry.go (0.0%)</option>
				
				<option value="file47">catalogizer/internal/services/book_recognition_provider.go (0.0%)</option>
				
				<option value="file48">catalogizer/internal/services/cache_service.go (0.0%)</option>
				
				<option value="file49">catalogizer/internal/services/catalog.go (67.6%)</option>
				
				<option value="file50">catalogizer/internal/services/cover_art_service.go (0.0%)</option>
				
				<option value="file51">catalogizer/internal/services/deep_linking_service.go (0.0%)</option>
				
				<option value="file52">catalogizer/internal/services/duplicate_detection_service.go (0.0%)</option>
				
				<option value="file53">catalogizer/internal/services/game_software_recognition_provider.go (0.0%)</option>
				
				<option value="file54">catalogizer/internal/services/localization_service.go (0.0%)</option>
				
				<option value="file55">catalogizer/internal/services/lyrics_service.go (0.0%)</option>
				
				<option value="file56">catalogizer/internal/services/media_player_service.go (0.0%)</option>
				
				<option value="file57">catalogizer/internal/services/media_recognition_service.go (0.0%)</option>
				
				<option value="file58">catalogizer/internal/services/movie_recognition_provider.go (0.0%)</option>
				
				<option value="file59">catalogizer/internal/services/music_player_service.go (0.0%)</option>
				
				<option value="file60">catalogizer/internal/services/music_recognition_provider.go (0.0%)</option>
				
				<option value="file61">catalogizer/internal/services/playback_position_service.go (0.0%)</option>
				
				<option value="file62">catalogizer/internal/services/playlist_service.go (0.0%)</option>
				
				<option value="file63">catalogizer/internal/services/protocol_handlers.go (0.0%)</option>
				
				<option value="file64">catalogizer/internal/services/reader_service.go (0.0%)</option>
				
				<option value="file65">catalogizer/internal/services/recommendation_service.go (0.0%)</option>
				
				<option value="file66">catalogizer/internal/services/rename_tracker.go (84.0%)</option>
				
				<option value="file67">catalogizer/internal/services/smb.go (0.0%)</option>
				
				<option value="file68">catalogizer/internal/services/smb_discovery.go (13.7%)</option>
				
				<option value="file69">catalogizer/internal/services/subtitle_service.go (0.0%)</option>
				
				<option value="file70">catalogizer/internal/services/translation_service.go (0.0%)</option>
				
				<option value="file71">catalogizer/internal/services/universal_rename_tracker.go (0.0%)</option>
				
				<option value="file72">catalogizer/internal/services/universal_scanner.go (0.0%)</option>
				
				<option value="file73">catalogizer/internal/services/video_player_service.go (0.0%)</option>
				
				<option value="file74">catalogizer/internal/smb/resilience.go (0.0%)</option>
				
				<option value="file75">catalogizer/internal/tests/media_recognition_mock_servers.go (0.0%)</option>
				
				<option value="file76">catalogizer/internal/tests/mock_servers.go (0.0%)</option>
				
				<option value="file77">catalogizer/main.go (0.0%)</option>
				
				<option value="file78">catalogizer/middleware/auth.go (0.0%)</option>
				
				<option value="file79">catalogizer/middleware/request.go (0.0%)</option>
				
				<option value="file80">catalogizer/models/user.go (0.0%)</option>
				
				<option value="file81">catalogizer/repository/analytics_repository.go (0.0%)</option>
				
				<option value="file82">catalogizer/repository/configuration_repository.go (0.0%)</option>
				
				<option value="file83">catalogizer/repository/conversion_repository.go (0.0%)</option>
				
				<option value="file84">catalogizer/repository/crash_reporting_repository.go (0.0%)</option>
				
				<option value="file85">catalogizer/repository/error_reporting_repository.go (0.0%)</option>
				
				<option value="file86">catalogizer/repository/favorites_repository.go (0.0%)</option>
				
				<option value="file87">catalogizer/repository/file_repository.go (0.0%)</option>
				
				<option value="file88">catalogizer/repository/log_management_repository.go (0.0%)</option>
				
				<option value="file89">catalogizer/repository/stats_repository.go (0.0%)</option>
				
				<option value="file90">catalogizer/repository/stress_test_repository.go (0.0%)</option>
				
				<option value="file91">catalogizer/repository/sync_repository.go (0.0%)</option>
				
				<option value="file92">catalogizer/repository/user_repository.go (0.0%)</option>
				
				<option value="file93">catalogizer/services/analytics_service.go (0.0%)</option>
				
				<option value="file94">catalogizer/services/auth_service.go (0.0%)</option>
				
				<option value="file95">catalogizer/services/configuration_service.go (0.0%)</option>
				
				<option value="file96">catalogizer/services/configuration_wizard_service.go (0.0%)</option>
				
				<option value="file97">catalogizer/services/conversion_service.go (0.0%)</option>
				
				<option value="file98">catalogizer/services/error_reporting_service.go (0.0%)</option>
				
				<option value="file99">catalogizer/services/favorites_service.go (0.0%)</option>
				
				<option value="file100">catalogizer/services/log_management_service.go (0.0%)</option>
				
				<option value="file101">catalogizer/services/reporting_service.go (0.0%)</option>
				
				<option value="file102">catalogizer/services/stress_test_service.go (0.0%)</option>
				
				<option value="file103">catalogizer/services/sync_service.go (0.0%)</option>
				
				<option value="file104">catalogizer/services/webdav_client.go (0.0%)</option>
				
				<option value="file105">catalogizer/smb/client.go (0.0%)</option>
				
				<option value="file106">catalogizer/smb/types.go (0.0%)</option>
				
				<option value="file107">catalogizer/tests/integration/protocol_rename_tests.go (0.0%)</option>
				
				<option value="file108">catalogizer/tests/mocks/ftp_mock_server.go (0.0%)</option>
				
				<option value="file109">catalogizer/tests/mocks/nfs_mock_server.go (0.0%)</option>
				
				<option value="file110">catalogizer/tests/mocks/smb_mock_server.go (0.0%)</option>
				
				<option value="file111">catalogizer/tests/mocks/webdav_mock_server.go (0.0%)</option>
				
				<option value="file112">catalogizer/tests/test_main.go (0.0%)</option>
				
				<option value="file113">catalogizer/tests/test_utils.go (38.5%)</option>
				
				<option value="file114">catalogizer/utils/response.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
)

// Config represents the API configuration
type Config struct {
        Server   ServerConfig   `json:"server"`
        Database DatabaseConfig `json:"database"`
        Auth     AuthConfig     `json:"auth"`
        Catalog  CatalogConfig  `json:"catalog"`
        Storage  StorageConfig  `json:"storage"`
        Logging  LoggingConfig  `json:"logging"`
}

// ServerConfig contains server-related configuration
type ServerConfig struct {
        Host         string `json:"host"`
        Port         int    `json:"port"`
        ReadTimeout  int    `json:"read_timeout"`
        WriteTimeout int    `json:"write_timeout"`
        IdleTimeout  int    `json:"idle_timeout"`
        EnableCORS   bool   `json:"enable_cors"`
        EnableHTTPS  bool   `json:"enable_https"`
        CertFile     string `json:"cert_file,omitempty"`
        KeyFile      string `json:"key_file,omitempty"`
}

// DatabaseConfig contains database connection configuration
type DatabaseConfig struct {
        Path               string `json:"path"`
        MaxOpenConnections int    `json:"max_open_connections"`
        MaxIdleConnections int    `json:"max_idle_connections"`
        ConnMaxLifetime    int    `json:"conn_max_lifetime"`
        ConnMaxIdleTime    int    `json:"conn_max_idle_time"`
        EnableWAL          bool   `json:"enable_wal"`
        CacheSize          int    `json:"cache_size"`
        BusyTimeout        int    `json:"busy_timeout"`
}

// AuthConfig contains authentication configuration
type AuthConfig struct {
        JWTSecret          string `json:"jwt_secret"`
        JWTExpirationHours int    `json:"jwt_expiration_hours"`
        EnableAuth         bool   `json:"enable_auth"`
        AdminUsername      string `json:"admin_username"`
        AdminPassword      string `json:"admin_password"`
}

// CatalogConfig contains catalog-specific configuration
type CatalogConfig struct {
        DefaultPageSize      int      `json:"default_page_size"`
        MaxPageSize          int      `json:"max_page_size"`
        EnableCache          bool     `json:"enable_cache"`
        CacheTTLMinutes      int      `json:"cache_ttl_minutes"`
        MaxConcurrentScans   int      `json:"max_concurrent_scans"`
        DownloadChunkSize    int      `json:"download_chunk_size"`
        MaxArchiveSize       int64    `json:"max_archive_size"`
        AllowedDownloadTypes []string `json:"allowed_download_types"`
        TempDir              string   `json:"temp_dir"`
}

// LoggingConfig contains logging configuration
type LoggingConfig struct {
        Level      string `json:"level"`
        Format     string `json:"format"`
        Output     string `json:"output"`
        MaxSize    int    `json:"max_size"`
        MaxBackups int    `json:"max_backups"`
        MaxAge     int    `json:"max_age"`
        Compress   bool   `json:"compress"`
}

// StorageConfig contains storage configuration for multiple protocols
type StorageConfig struct {
        Roots []StorageRootConfig `json:"roots"`
}

// StorageRootConfig represents configuration for a single storage root
type StorageRootConfig struct {
        ID                       string                 `json:"id"`
        Name                     string                 `json:"name"`
        Protocol                 string                 `json:"protocol"` // smb, ftp, nfs, webdav, local
        Enabled                  bool                   `json:"enabled"`
        MaxDepth                 int                    `json:"max_depth"`
        EnableDuplicateDetection bool                   `json:"enable_duplicate_detection"`
        EnableMetadataExtraction bool                   `json:"enable_metadata_extraction"`
        IncludePatterns          []string               `json:"include_patterns,omitempty"`
        ExcludePatterns          []string               `json:"exclude_patterns,omitempty"`
        Settings                 map[string]interface{} `json:"settings"` // Protocol-specific settings
}

// LoadConfig loads configuration from file or creates default
func LoadConfig(configPath string) (*Config, error) <span class="cov0" title="0">{
        config := getDefaultConfig()

        // Check if config file exists
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Create default config file
                if err := saveConfig(config, configPath); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create default config: %w", err)
                }</span>
                <span class="cov0" title="0">return config, nil</span>
        }

        // Load existing config
        <span class="cov0" title="0">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(data, config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Validate configuration
        <span class="cov0" title="0">if err := validateConfig(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// getDefaultConfig returns default configuration
func getDefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Server: ServerConfig{
                        Host:         "localhost",
                        Port:         8080,
                        ReadTimeout:  30,
                        WriteTimeout: 30,
                        IdleTimeout:  120,
                        EnableCORS:   true,
                        EnableHTTPS:  false,
                },
                Database: DatabaseConfig{
                        Path:               "./catalog.db",
                        MaxOpenConnections: 25,
                        MaxIdleConnections: 5,
                        ConnMaxLifetime:    300,
                        ConnMaxIdleTime:    60,
                        EnableWAL:          true,
                        CacheSize:          -2000,
                        BusyTimeout:        5000,
                },
                Auth: AuthConfig{
                        JWTSecret:          "change-this-secret-in-production",
                        JWTExpirationHours: 24,
                        EnableAuth:         false,
                        AdminUsername:      "admin",
                        AdminPassword:      "admin123",
                },
                Catalog: CatalogConfig{
                        DefaultPageSize:      100,
                        MaxPageSize:          1000,
                        EnableCache:          true,
                        CacheTTLMinutes:      15,
                        MaxConcurrentScans:   3,
                        DownloadChunkSize:    1024 * 1024,            // 1MB
                        MaxArchiveSize:       1024 * 1024 * 1024 * 5, // 5GB
                        AllowedDownloadTypes: []string{"*"},
                        TempDir:              "/tmp/catalog-api",
                },
                Storage: StorageConfig{
                        Roots: []StorageRootConfig{
                                {
                                        ID:                       "local-example",
                                        Name:                     "Local Files",
                                        Protocol:                 "local",
                                        Enabled:                  true,
                                        MaxDepth:                 10,
                                        EnableDuplicateDetection: true,
                                        EnableMetadataExtraction: true,
                                        Settings: map[string]interface{}{
                                                "base_path": "/tmp/catalog-data",
                                        },
                                },
                        },
                },
                Logging: LoggingConfig{
                        Level:      "info",
                        Format:     "json",
                        Output:     "stdout",
                        MaxSize:    100,
                        MaxBackups: 3,
                        MaxAge:     28,
                        Compress:   true,
                },
        }
}</span>

// validateConfig validates the configuration
func validateConfig(config *Config) error <span class="cov0" title="0">{
        if config.Server.Port &lt;= 0 || config.Server.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid server port: %d", config.Server.Port)
        }</span>

        <span class="cov0" title="0">if config.Database.Path == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database path cannot be empty")
        }</span>

        <span class="cov0" title="0">if config.Auth.EnableAuth &amp;&amp; config.Auth.JWTSecret == "change-this-secret-in-production" </span><span class="cov0" title="0">{
                return fmt.Errorf("JWT secret must be changed in production")
        }</span>

        <span class="cov0" title="0">if config.Catalog.DefaultPageSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("default page size must be positive")
        }</span>

        <span class="cov0" title="0">if config.Catalog.MaxPageSize &lt; config.Catalog.DefaultPageSize </span><span class="cov0" title="0">{
                return fmt.Errorf("max page size must be &gt;= default page size")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// saveConfig saves configuration to file
func saveConfig(config *Config, configPath string) error <span class="cov0" title="0">{
        // Create directory if it doesn't exist
        dir := filepath.Dir(configPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        <span class="cov0" title="0">data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(configPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDatabaseURL returns the database connection URL
func (c *Config) GetDatabaseURL() string <span class="cov0" title="0">{
        params := "?_busy_timeout=5000&amp;_journal_mode=WAL&amp;_synchronous=NORMAL&amp;_foreign_keys=1"
        if c.Database.EnableWAL </span><span class="cov0" title="0">{
                params += "&amp;_wal_autocheckpoint=1000"
        }</span>
        <span class="cov0" title="0">if c.Database.CacheSize != 0 </span><span class="cov0" title="0">{
                params += fmt.Sprintf("&amp;_cache_size=%d", c.Database.CacheSize)
        }</span>
        <span class="cov0" title="0">return c.Database.Path + params</span>
}

// GetServerAddress returns the server address
func (c *Config) GetServerAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Server.Host, c.Server.Port)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "catalogizer/config"
        _ "github.com/mattn/go-sqlite3"
)

// DB represents the database connection
type DB struct {
        *sql.DB
        config *config.DatabaseConfig
}

// NewConnection creates a new database connection
func NewConnection(cfg *config.DatabaseConfig) (*DB, error) <span class="cov0" title="0">{
        // Build connection string with parameters
        connStr := cfg.Path + "?_busy_timeout=5000&amp;_journal_mode=WAL&amp;_synchronous=NORMAL&amp;_foreign_keys=1"

        if cfg.EnableWAL </span><span class="cov0" title="0">{
                connStr += "&amp;_wal_autocheckpoint=1000"
        }</span>

        <span class="cov0" title="0">if cfg.CacheSize != 0 </span><span class="cov0" title="0">{
                connStr += fmt.Sprintf("&amp;_cache_size=%d", cfg.CacheSize)
        }</span>

        // Open database connection
        <span class="cov0" title="0">sqlDB, err := sql.Open("sqlite3", connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(cfg.MaxOpenConnections)
        sqlDB.SetMaxIdleConns(cfg.MaxIdleConnections)
        sqlDB.SetConnMaxLifetime(time.Duration(cfg.ConnMaxLifetime) * time.Second)
        sqlDB.SetConnMaxIdleTime(time.Duration(cfg.ConnMaxIdleTime) * time.Second)

        // Test connection
        if err := sqlDB.Ping(); err != nil </span><span class="cov0" title="0">{
                sqlDB.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">db := &amp;DB{
                DB:     sqlDB,
                config: cfg,
        }

        return db, nil</span>
}

// HealthCheck performs a database health check
func (db *DB) HealthCheck() error <span class="cov0" title="0">{
        ctx, cancel := db.createContext()
        defer cancel()

        return db.PingContext(ctx)
}</span>

// GetStats returns database connection statistics
func (db *DB) GetStats() sql.DBStats <span class="cov0" title="0">{
        return db.Stats()
}</span>

// createContext creates a context with timeout
func (db *DB) createContext() (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        timeout := time.Duration(db.config.BusyTimeout) * time.Millisecond
        return context.WithTimeout(context.Background(), timeout)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "context"
        "fmt"
)

// RunMigrations runs database migrations
func (db *DB) RunMigrations(ctx context.Context) error <span class="cov0" title="0">{
        // Create migrations table if it doesn't exist
        if err := db.createMigrationsTable(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrations table: %w", err)
        }</span>

        // Run migrations
        <span class="cov0" title="0">migrations := []Migration{
                {
                        Version: 1,
                        Name:    "create_initial_tables",
                        Up:      db.createInitialTables,
                },
                {
                        Version: 2,
                        Name:    "migrate_smb_to_storage_roots",
                        Up:      db.migrateSMBToStorageRoots,
                },
        }

        for _, migration := range migrations </span><span class="cov0" title="0">{
                if err := db.runMigration(ctx, migration); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to run migration %s: %w", migration.Name, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Migration represents a database migration
type Migration struct {
        Version int
        Name    string
        Up      func(context.Context) error
}

// createMigrationsTable creates the migrations tracking table
func (db *DB) createMigrationsTable(ctx context.Context) error <span class="cov0" title="0">{
        query := `
                CREATE TABLE IF NOT EXISTS migrations (
                        version INTEGER PRIMARY KEY,
                        name TEXT NOT NULL,
                        applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
        `
        _, err := db.ExecContext(ctx, query)
        return err
}</span>

// runMigration runs a single migration if it hasn't been applied
func (db *DB) runMigration(ctx context.Context, migration Migration) error <span class="cov0" title="0">{
        // Check if migration has already been applied
        var count int
        err := db.QueryRowContext(ctx, "SELECT COUNT(*) FROM migrations WHERE version = ?", migration.Version).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                return nil // Migration already applied
        }</span>

        // Run migration
        <span class="cov0" title="0">if err := migration.Up(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Record migration as applied
        <span class="cov0" title="0">_, err = db.ExecContext(ctx, "INSERT INTO migrations (version, name) VALUES (?, ?)", migration.Version, migration.Name)
        return err</span>
}

// createInitialTables creates the initial database schema
func (db *DB) createInitialTables(ctx context.Context) error <span class="cov0" title="0">{
        queries := []string{
                // Storage roots table (replaces smb_roots)
                `CREATE TABLE IF NOT EXISTS storage_roots (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL UNIQUE,
                        protocol TEXT NOT NULL,
                        host TEXT,
                        port INTEGER,
                        path TEXT,
                        username TEXT,
                        password TEXT,
                        domain TEXT,
                        mount_point TEXT,
                        options TEXT,
                        url TEXT,
                        enabled BOOLEAN DEFAULT 1,
                        max_depth INTEGER DEFAULT 10,
                        enable_duplicate_detection BOOLEAN DEFAULT 1,
                        enable_metadata_extraction BOOLEAN DEFAULT 1,
                        include_patterns TEXT,
                        exclude_patterns TEXT,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        last_scan_at DATETIME
                )`,

                // Files table
                `CREATE TABLE IF NOT EXISTS files (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        storage_root_id INTEGER NOT NULL,
                        path TEXT NOT NULL,
                        name TEXT NOT NULL,
                        extension TEXT,
                        mime_type TEXT,
                        file_type TEXT,
                        size INTEGER NOT NULL,
                        is_directory BOOLEAN DEFAULT 0,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        modified_at DATETIME NOT NULL,
                        accessed_at DATETIME,
                        deleted BOOLEAN DEFAULT 0,
                        deleted_at DATETIME,
                        last_scan_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        last_verified_at DATETIME,
                        md5 TEXT,
                        sha256 TEXT,
                        sha1 TEXT,
                        blake3 TEXT,
                        quick_hash TEXT,
                        is_duplicate BOOLEAN DEFAULT 0,
                        duplicate_group_id INTEGER,
                        parent_id INTEGER,
                        FOREIGN KEY (storage_root_id) REFERENCES storage_roots(id),
                        FOREIGN KEY (parent_id) REFERENCES files(id),
                        FOREIGN KEY (duplicate_group_id) REFERENCES duplicate_groups(id)
                )`,

                // File metadata table
                `CREATE TABLE IF NOT EXISTS file_metadata (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        file_id INTEGER NOT NULL,
                        key TEXT NOT NULL,
                        value TEXT NOT NULL,
                        data_type TEXT DEFAULT 'string',
                        FOREIGN KEY (file_id) REFERENCES files(id) ON DELETE CASCADE
                )`,

                // Duplicate groups table
                `CREATE TABLE IF NOT EXISTS duplicate_groups (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        file_count INTEGER DEFAULT 0,
                        total_size INTEGER DEFAULT 0,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,

                // Virtual paths table
                `CREATE TABLE IF NOT EXISTS virtual_paths (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        path TEXT NOT NULL UNIQUE,
                        target_type TEXT NOT NULL,
                        target_id INTEGER NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,

                // Scan history table
                `CREATE TABLE IF NOT EXISTS scan_history (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        storage_root_id INTEGER NOT NULL,
                        scan_type TEXT NOT NULL,
                        status TEXT NOT NULL,
                        start_time DATETIME NOT NULL,
                        end_time DATETIME,
                        files_processed INTEGER DEFAULT 0,
                        files_added INTEGER DEFAULT 0,
                        files_updated INTEGER DEFAULT 0,
                        files_deleted INTEGER DEFAULT 0,
                        error_count INTEGER DEFAULT 0,
                        error_message TEXT,
                        FOREIGN KEY (storage_root_id) REFERENCES storage_roots(id)
                )`,

                // Indexes for performance
                `CREATE INDEX IF NOT EXISTS idx_files_storage_root_path ON files(storage_root_id, path)`,
                `CREATE INDEX IF NOT EXISTS idx_files_parent_id ON files(parent_id)`,
                `CREATE INDEX IF NOT EXISTS idx_files_duplicate_group ON files(duplicate_group_id)`,
                `CREATE INDEX IF NOT EXISTS idx_files_deleted ON files(deleted)`,
                `CREATE INDEX IF NOT EXISTS idx_file_metadata_file_id ON file_metadata(file_id)`,
                `CREATE INDEX IF NOT EXISTS idx_scan_history_storage_root ON scan_history(storage_root_id)`,
        }

        for _, query := range queries </span><span class="cov0" title="0">{
                if _, err := db.ExecContext(ctx, query); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute query: %s, error: %w", query, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// migrateSMBToStorageRoots migrates existing SMB root data to the new storage roots format
func (db *DB) migrateSMBToStorageRoots(ctx context.Context) error <span class="cov0" title="0">{
        // Check if old smb_roots table exists
        var exists int
        err := db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='smb_roots'").Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if exists == 0 </span><span class="cov0" title="0">{
                return nil // No old table to migrate
        }</span>

        // Migrate SMB roots to storage roots
        <span class="cov0" title="0">query := `
                INSERT INTO storage_roots (
                        name, protocol, host, port, path, username, password, domain,
                        enabled, max_depth, enable_duplicate_detection, enable_metadata_extraction,
                        include_patterns, exclude_patterns, created_at, updated_at, last_scan_at
                )
                SELECT
                        name, 'smb', host, port, share, username, password, domain,
                        enabled, max_depth, enable_duplicate_detection, enable_metadata_extraction,
                        include_patterns, exclude_patterns, created_at, updated_at, last_scan_at
                FROM smb_roots
                WHERE NOT EXISTS (
                        SELECT 1 FROM storage_roots WHERE name = smb_roots.name AND protocol = 'smb'
                )
        `

        if _, err := db.ExecContext(ctx, query); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to migrate SMB roots: %w", err)
        }</span>

        // Update files table to use storage_root_id instead of smb_root_id
        <span class="cov0" title="0">updateQuery := `
                UPDATE files
                SET storage_root_id = (
                        SELECT sr.id
                        FROM storage_roots sr
                        JOIN smb_roots old_sr ON sr.name = old_sr.name AND sr.protocol = 'smb'
                        WHERE files.smb_root_id = old_sr.id
                )
                WHERE storage_root_id IS NULL OR storage_root_id = 0
        `

        if _, err := db.ExecContext(ctx, updateQuery); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update files storage_root_id: %w", err)
        }</span>

        // Update scan_history table
        <span class="cov0" title="0">scanUpdateQuery := `
                UPDATE scan_history
                SET storage_root_id = (
                        SELECT sr.id
                        FROM storage_roots sr
                        JOIN smb_roots old_sr ON sr.name = old_sr.name AND sr.protocol = 'smb'
                        WHERE scan_history.smb_root_id = old_sr.id
                )
                WHERE storage_root_id IS NULL OR storage_root_id = 0
        `

        if _, err := db.ExecContext(ctx, scanUpdateQuery); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update scan_history storage_root_id: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package filesystem

import (
        "fmt"
)

// DefaultClientFactory implements ClientFactory for all supported protocols
type DefaultClientFactory struct{}

// NewDefaultClientFactory creates a new default client factory
func NewDefaultClientFactory() *DefaultClientFactory <span class="cov3" title="2">{
        return &amp;DefaultClientFactory{}
}</span>

// CreateClient creates a filesystem client based on the storage configuration
func (f *DefaultClientFactory) CreateClient(config *StorageConfig) (FileSystemClient, error) <span class="cov6" title="6">{
        switch config.Protocol </span>{
        case "smb":<span class="cov1" title="1">
                smbConfig := &amp;SmbConfig{
                        Host:     getStringSetting(config.Settings, "host", ""),
                        Port:     getIntSetting(config.Settings, "port", 445),
                        Share:    getStringSetting(config.Settings, "share", ""),
                        Username: getStringSetting(config.Settings, "username", ""),
                        Password: getStringSetting(config.Settings, "password", ""),
                        Domain:   getStringSetting(config.Settings, "domain", "WORKGROUP"),
                }
                return NewSmbClient(smbConfig), nil</span>

        case "ftp":<span class="cov1" title="1">
                ftpConfig := &amp;FTPConfig{
                        Host:     getStringSetting(config.Settings, "host", ""),
                        Port:     getIntSetting(config.Settings, "port", 21),
                        Username: getStringSetting(config.Settings, "username", ""),
                        Password: getStringSetting(config.Settings, "password", ""),
                        Path:     getStringSetting(config.Settings, "path", ""),
                }
                return NewFTPClient(ftpConfig), nil</span>

        case "nfs":<span class="cov1" title="1">
                nfsConfig := &amp;NFSConfig{
                        Host:       getStringSetting(config.Settings, "host", ""),
                        Path:       getStringSetting(config.Settings, "path", ""),
                        MountPoint: getStringSetting(config.Settings, "mount_point", ""),
                        Options:    getStringSetting(config.Settings, "options", "vers=3"),
                }
                return NewNFSClient(nfsConfig), nil</span>

        case "webdav":<span class="cov1" title="1">
                webdavConfig := &amp;WebDAVConfig{
                        URL:      getStringSetting(config.Settings, "url", ""),
                        Username: getStringSetting(config.Settings, "username", ""),
                        Password: getStringSetting(config.Settings, "password", ""),
                        Path:     getStringSetting(config.Settings, "path", ""),
                }
                return NewWebDAVClient(webdavConfig), nil</span>

        case "local":<span class="cov1" title="1">
                localConfig := &amp;LocalConfig{
                        BasePath: getStringSetting(config.Settings, "base_path", ""),
                }
                return NewLocalClient(localConfig), nil</span>

        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported protocol: %s", config.Protocol)</span>
        }
}

// SupportedProtocols returns the list of supported protocols
func (f *DefaultClientFactory) SupportedProtocols() []string <span class="cov1" title="1">{
        return []string{"smb", "ftp", "nfs", "webdav", "local"}
}</span>

// Helper functions to extract settings
func getStringSetting(settings map[string]interface{}, key, defaultValue string) string <span class="cov10" title="18">{
        if val, ok := settings[key]; ok </span><span class="cov10" title="18">{
                if str, ok := val.(string); ok </span><span class="cov10" title="18">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getIntSetting(settings map[string]interface{}, key string, defaultValue int) int <span class="cov3" title="2">{
        if val, ok := settings[key]; ok </span><span class="cov3" title="2">{
                if num, ok := val.(int); ok </span><span class="cov3" title="2">{
                        return num
                }</span>
                <span class="cov0" title="0">if floatNum, ok := val.(float64); ok </span><span class="cov0" title="0">{
                        return int(floatNum)
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package filesystem

import (
        "context"
        "fmt"
        "io"
        "path/filepath"
        "time"

        "github.com/jlaffaye/ftp"
)

// FTPConfig contains FTP connection configuration
type FTPConfig struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Username string `json:"username"`
        Password string `json:"password"`
        Path     string `json:"path"` // Base path on the FTP server
}

// FTPClient implements FileSystemClient for FTP protocol
type FTPClient struct {
        config    *FTPConfig
        client    *ftp.ServerConn
        connected bool
}

// NewFTPClient creates a new FTP client
func NewFTPClient(config *FTPConfig) *FTPClient <span class="cov8" title="1">{
        return &amp;FTPClient{
                config:    config,
                connected: false,
        }
}</span>

// Connect establishes the FTP connection
func (c *FTPClient) Connect(ctx context.Context) error <span class="cov0" title="0">{
        addr := fmt.Sprintf("%s:%d", c.config.Host, c.config.Port)

        client, err := ftp.Dial(addr, ftp.DialWithTimeout(30*time.Second))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to FTP server: %w", err)
        }</span>

        <span class="cov0" title="0">err = client.Login(c.config.Username, c.config.Password)
        if err != nil </span><span class="cov0" title="0">{
                client.Quit()
                return fmt.Errorf("failed to login to FTP server: %w", err)
        }</span>

        // Change to base directory if specified
        <span class="cov0" title="0">if c.config.Path != "" </span><span class="cov0" title="0">{
                err = client.ChangeDir(c.config.Path)
                if err != nil </span><span class="cov0" title="0">{
                        client.Quit()
                        return fmt.Errorf("failed to change to base directory %s: %w", c.config.Path, err)
                }</span>
        }

        <span class="cov0" title="0">c.client = client
        c.connected = true
        return nil</span>
}

// Disconnect closes the FTP connection
func (c *FTPClient) Disconnect(ctx context.Context) error <span class="cov0" title="0">{
        if c.client != nil </span><span class="cov0" title="0">{
                err := c.client.Quit()
                c.client = nil
                c.connected = false
                return err
        }</span>
        <span class="cov0" title="0">c.connected = false
        return nil</span>
}

// IsConnected returns true if the client is connected
func (c *FTPClient) IsConnected() bool <span class="cov0" title="0">{
        return c.connected &amp;&amp; c.client != nil
}</span>

// TestConnection tests the FTP connection
func (c *FTPClient) TestConnection(ctx context.Context) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">_, err := c.client.CurrentDir()
        return err</span>
}

// resolvePath resolves a relative path within the FTP base directory
func (c *FTPClient) resolvePath(path string) string <span class="cov0" title="0">{
        if c.config.Path != "" </span><span class="cov0" title="0">{
                return c.config.Path + "/" + path
        }</span>
        <span class="cov0" title="0">return path</span>
}

// ReadFile reads a file from the FTP server
func (c *FTPClient) ReadFile(ctx context.Context, path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        resp, err := c.client.Retr(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to retrieve FTP file %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

// WriteFile writes a file to the FTP server
func (c *FTPClient) WriteFile(ctx context.Context, path string, data io.Reader) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)

        // Ensure the directory exists
        dir := filepath.Dir(fullPath)
        if dir != "." &amp;&amp; dir != "/" </span><span class="cov0" title="0">{
                err := c.client.MakeDir(dir)
                if err != nil </span>{<span class="cov0" title="0">
                        // Ignore error if directory already exists
                        // FTP doesn't have a standard way to check if directory exists
                }</span>
        }

        <span class="cov0" title="0">err := c.client.Stor(fullPath, data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store FTP file %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetFileInfo gets information about a file
func (c *FTPClient) GetFileInfo(ctx context.Context, path string) (*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)

        // Try to get file size
        size, err := c.client.FileSize(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get FTP file info %s: %w", fullPath, err)
        }</span>

        // Get modification time - fallback since ModTime might not be available
        <span class="cov0" title="0">modTime := time.Now() // Default fallback

        // Check if it's a directory by trying to list it
        _, err = c.client.List(fullPath)
        isDir := err == nil

        return &amp;FileInfo{
                Name:    filepath.Base(path),
                Size:    size,
                ModTime: modTime,
                IsDir:   isDir,
                Mode:    0644, // Default mode, FTP doesn't provide mode info
                Path:    path,
        }, nil</span>
}

// ListDirectory lists files in a directory
func (c *FTPClient) ListDirectory(ctx context.Context, path string) ([]*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)

        entries, err := c.client.List(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list FTP directory %s: %w", fullPath, err)
        }</span>

        <span class="cov0" title="0">var files []*FileInfo
        for _, entry := range entries </span><span class="cov0" title="0">{
                files = append(files, &amp;FileInfo{
                        Name:    entry.Name,
                        Size:    int64(entry.Size),
                        ModTime: entry.Time,
                        IsDir:   entry.Type == ftp.EntryTypeFolder,
                        Mode:    0644, // Default mode
                        Path:    path + "/" + entry.Name,
                })
        }</span>

        <span class="cov0" title="0">return files, nil</span>
}

// FileExists checks if a file exists
func (c *FTPClient) FileExists(ctx context.Context, path string) (bool, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return false, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)

        // Try to get file size - if it succeeds, file exists
        _, err := c.client.FileSize(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                // Try to list the file's directory to see if it exists
                dir := filepath.Dir(fullPath)
                name := filepath.Base(fullPath)
                entries, err := c.client.List(dir)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to check FTP file existence %s: %w", fullPath, err)
                }</span>
                <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                        if entry.Name == name </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                }
                <span class="cov0" title="0">return false, nil</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// CreateDirectory creates a directory
func (c *FTPClient) CreateDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := c.client.MakeDir(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create FTP directory %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteDirectory deletes a directory
func (c *FTPClient) DeleteDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := c.client.RemoveDir(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete FTP directory %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteFile deletes a file
func (c *FTPClient) DeleteFile(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := c.client.Delete(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete FTP file %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CopyFile copies a file on the FTP server
func (c *FTPClient) CopyFile(ctx context.Context, srcPath, dstPath string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        // FTP doesn't have a native copy command, so we need to download and upload
        <span class="cov0" title="0">srcFullPath := c.resolvePath(srcPath)
        dstFullPath := c.resolvePath(dstPath)

        // Read source file
        resp, err := c.client.Retr(srcFullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retrieve source file %s: %w", srcFullPath, err)
        }</span>
        <span class="cov0" title="0">defer resp.Close()

        // Ensure destination directory exists
        dstDir := filepath.Dir(dstFullPath)
        if dstDir != "." &amp;&amp; dstDir != "/" </span><span class="cov0" title="0">{
                c.client.MakeDir(dstDir) // Ignore error if directory exists
        }</span>

        // Write to destination
        <span class="cov0" title="0">err = c.client.Stor(dstFullPath, resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store destination file %s: %w", dstFullPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetProtocol returns the protocol name
func (c *FTPClient) GetProtocol() string <span class="cov8" title="1">{
        return "ftp"
}</span>

// GetConfig returns the FTP configuration
func (c *FTPClient) GetConfig() interface{} <span class="cov0" title="0">{
        return c.config
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package filesystem

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
)

// LocalConfig contains local filesystem configuration
type LocalConfig struct {
        BasePath string `json:"base_path"` // Base directory path
}

// LocalClient implements FileSystemClient for local filesystem
type LocalClient struct {
        config    *LocalConfig
        basePath  string
        connected bool
}

// NewLocalClient creates a new local filesystem client
func NewLocalClient(config *LocalConfig) *LocalClient <span class="cov10" title="9">{
        return &amp;LocalClient{
                config:    config,
                basePath:  config.BasePath,
                connected: false,
        }
}</span>

// Connect establishes the connection (for local filesystem, this just validates the path)
func (c *LocalClient) Connect(ctx context.Context) error <span class="cov8" title="7">{
        // Validate that the base path exists and is accessible
        info, err := os.Stat(c.basePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to access base path %s: %w", c.basePath, err)
        }</span>
        <span class="cov8" title="7">if !info.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("base path %s is not a directory", c.basePath)
        }</span>
        <span class="cov8" title="7">c.connected = true
        return nil</span>
}

// Disconnect closes the connection (no-op for local filesystem)
func (c *LocalClient) Disconnect(ctx context.Context) error <span class="cov8" title="7">{
        c.connected = false
        return nil
}</span>

// IsConnected returns true if the client is connected
func (c *LocalClient) IsConnected() bool <span class="cov10" title="9">{
        return c.connected
}</span>

// TestConnection tests the connection
func (c *LocalClient) TestConnection(ctx context.Context) error <span class="cov1" title="1">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov1" title="1">_, err := os.Stat(c.basePath)
        return err</span>
}

// resolvePath resolves a relative path to an absolute path within the base directory
func (c *LocalClient) resolvePath(path string) string <span class="cov8" title="6">{
        // Clean the path and prevent directory traversal
        cleanPath := filepath.Clean(path)
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                // Prevent directory traversal attacks
                cleanPath = strings.ReplaceAll(cleanPath, "..", "")
        }</span>
        <span class="cov8" title="6">return filepath.Join(c.basePath, cleanPath)</span>
}

// ReadFile reads a file from the local filesystem
func (c *LocalClient) ReadFile(ctx context.Context, path string) (io.ReadCloser, error) <span class="cov1" title="1">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov1" title="1">fullPath := c.resolvePath(path)
        file, err := os.Open(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open local file %s: %w", fullPath, err)
        }</span>
        <span class="cov1" title="1">return file, nil</span>
}

// WriteFile writes a file to the local filesystem
func (c *LocalClient) WriteFile(ctx context.Context, path string, data io.Reader) error <span class="cov1" title="1">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov1" title="1">fullPath := c.resolvePath(path)

        // Ensure the directory exists
        dir := filepath.Dir(fullPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory %s: %w", dir, err)
        }</span>

        <span class="cov1" title="1">file, err := os.Create(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local file %s: %w", fullPath, err)
        }</span>
        <span class="cov1" title="1">defer file.Close()

        _, err = io.Copy(file, data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write local file %s: %w", fullPath, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetFileInfo gets information about a file
func (c *LocalClient) GetFileInfo(ctx context.Context, path string) (*FileInfo, error) <span class="cov1" title="1">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov1" title="1">fullPath := c.resolvePath(path)
        stat, err := os.Stat(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat local file %s: %w", fullPath, err)
        }</span>

        <span class="cov1" title="1">return &amp;FileInfo{
                Name:    stat.Name(),
                Size:    stat.Size(),
                ModTime: stat.ModTime(),
                IsDir:   stat.IsDir(),
                Mode:    stat.Mode(),
                Path:    path,
        }, nil</span>
}

// ListDirectory lists files in a directory
func (c *LocalClient) ListDirectory(ctx context.Context, path string) ([]*FileInfo, error) <span class="cov1" title="1">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov1" title="1">fullPath := c.resolvePath(path)
        entries, err := os.ReadDir(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list local directory %s: %w", fullPath, err)
        }</span>

        <span class="cov1" title="1">var files []*FileInfo
        for _, entry := range entries </span><span class="cov3" title="2">{
                info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip files we can't get info for
                }
                <span class="cov3" title="2">files = append(files, &amp;FileInfo{
                        Name:    entry.Name(),
                        Size:    info.Size(),
                        ModTime: info.ModTime(),
                        IsDir:   entry.IsDir(),
                        Mode:    info.Mode(),
                        Path:    filepath.Join(path, entry.Name()),
                })</span>
        }

        <span class="cov1" title="1">return files, nil</span>
}

// FileExists checks if a file exists
func (c *LocalClient) FileExists(ctx context.Context, path string) (bool, error) <span class="cov3" title="2">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return false, fmt.Errorf("not connected")
        }</span>
        <span class="cov3" title="2">fullPath := c.resolvePath(path)
        _, err := os.Stat(fullPath)
        if err != nil </span><span class="cov1" title="1">{
                if os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check local file existence %s: %w", fullPath, err)</span>
        }
        <span class="cov1" title="1">return true, nil</span>
}

// CreateDirectory creates a directory
func (c *LocalClient) CreateDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := os.MkdirAll(fullPath, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local directory %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteDirectory deletes a directory
func (c *LocalClient) DeleteDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := os.RemoveAll(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete local directory %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteFile deletes a file
func (c *LocalClient) DeleteFile(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := os.Remove(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete local file %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CopyFile copies a file within the local filesystem
func (c *LocalClient) CopyFile(ctx context.Context, srcPath, dstPath string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">srcFullPath := c.resolvePath(srcPath)
        dstFullPath := c.resolvePath(dstPath)

        // Ensure destination directory exists
        dstDir := filepath.Dir(dstFullPath)
        if err := os.MkdirAll(dstDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination directory %s: %w", dstDir, err)
        }</span>

        // Open source file
        <span class="cov0" title="0">srcFile, err := os.Open(srcFullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file %s: %w", srcFullPath, err)
        }</span>
        <span class="cov0" title="0">defer srcFile.Close()

        // Create destination file
        dstFile, err := os.Create(dstFullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination file %s: %w", dstFullPath, err)
        }</span>
        <span class="cov0" title="0">defer dstFile.Close()

        // Copy data
        _, err = io.Copy(dstFile, srcFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file from %s to %s: %w", srcFullPath, dstFullPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetProtocol returns the protocol name
func (c *LocalClient) GetProtocol() string <span class="cov3" title="2">{
        return "local"
}</span>

// GetConfig returns the local configuration
func (c *LocalClient) GetConfig() interface{} <span class="cov0" title="0">{
        return c.config
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package filesystem

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "syscall"
)

// NFSConfig contains NFS connection configuration
type NFSConfig struct {
        Host       string `json:"host"`
        Path       string `json:"path"`        // Export path on NFS server
        MountPoint string `json:"mount_point"` // Local mount point
        Options    string `json:"options"`     // Mount options
}

// NFSClient implements FileSystemClient for NFS protocol
type NFSClient struct {
        config     *NFSConfig
        mounted    bool
        connected  bool
        mountPoint string
}

// NewNFSClient creates a new NFS client
func NewNFSClient(config *NFSConfig) *NFSClient <span class="cov8" title="1">{
        return &amp;NFSClient{
                config:     config,
                mounted:    false,
                connected:  false,
                mountPoint: config.MountPoint,
        }
}</span>

// Connect establishes the NFS connection by mounting the filesystem
func (c *NFSClient) Connect(ctx context.Context) error <span class="cov0" title="0">{
        // Check if already mounted
        if c.isMounted() </span><span class="cov0" title="0">{
                c.connected = true
                return nil
        }</span>

        // Create mount point directory if it doesn't exist
        <span class="cov0" title="0">if err := os.MkdirAll(c.mountPoint, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create mount point %s: %w", c.mountPoint, err)
        }</span>

        // Mount the NFS share
        <span class="cov0" title="0">source := fmt.Sprintf("%s:%s", c.config.Host, c.config.Path)
        options := "vers=3"
        if c.config.Options != "" </span><span class="cov0" title="0">{
                options = c.config.Options
        }</span>

        <span class="cov0" title="0">err := syscall.Mount(source, c.mountPoint, "nfs", 0, options)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mount NFS share %s to %s: %w", source, c.mountPoint, err)
        }</span>

        <span class="cov0" title="0">c.mounted = true
        c.connected = true
        return nil</span>
}

// Disconnect unmounts the NFS filesystem
func (c *NFSClient) Disconnect(ctx context.Context) error <span class="cov0" title="0">{
        if c.mounted </span><span class="cov0" title="0">{
                err := syscall.Unmount(c.mountPoint, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmount NFS share from %s: %w", c.mountPoint, err)
                }</span>
                <span class="cov0" title="0">c.mounted = false</span>
        }
        <span class="cov0" title="0">c.connected = false
        return nil</span>
}

// IsConnected returns true if the client is connected
func (c *NFSClient) IsConnected() bool <span class="cov0" title="0">{
        return c.connected &amp;&amp; c.mounted &amp;&amp; c.isMounted()
}</span>

// TestConnection tests the NFS connection
func (c *NFSClient) TestConnection(ctx context.Context) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">_, err := os.Stat(c.mountPoint)
        return err</span>
}

// isMounted checks if the mount point is actually mounted
func (c *NFSClient) isMounted() bool <span class="cov0" title="0">{
        file, err := os.Open("/proc/mounts")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // This is a simplified check - in production you'd parse /proc/mounts properly
        return true</span> // For now, assume it's mounted if no error
}

// resolvePath resolves a relative path within the NFS mount point
func (c *NFSClient) resolvePath(path string) string <span class="cov0" title="0">{
        // Clean the path and prevent directory traversal
        cleanPath := filepath.Clean(path)
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                // Prevent directory traversal attacks
                cleanPath = strings.ReplaceAll(cleanPath, "..", "")
        }</span>
        <span class="cov0" title="0">return filepath.Join(c.mountPoint, cleanPath)</span>
}

// ReadFile reads a file from the NFS mount
func (c *NFSClient) ReadFile(ctx context.Context, path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        file, err := os.Open(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open NFS file %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return file, nil</span>
}

// WriteFile writes a file to the NFS mount
func (c *NFSClient) WriteFile(ctx context.Context, path string, data io.Reader) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)

        // Ensure the directory exists
        dir := filepath.Dir(fullPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory %s: %w", dir, err)
        }</span>

        <span class="cov0" title="0">file, err := os.Create(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create NFS file %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        _, err = io.Copy(file, data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write NFS file %s: %w", fullPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFileInfo gets information about a file
func (c *NFSClient) GetFileInfo(ctx context.Context, path string) (*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        stat, err := os.Stat(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat NFS file %s: %w", fullPath, err)
        }</span>

        <span class="cov0" title="0">return &amp;FileInfo{
                Name:    stat.Name(),
                Size:    stat.Size(),
                ModTime: stat.ModTime(),
                IsDir:   stat.IsDir(),
                Mode:    stat.Mode(),
                Path:    path,
        }, nil</span>
}

// ListDirectory lists files in a directory
func (c *NFSClient) ListDirectory(ctx context.Context, path string) ([]*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        entries, err := os.ReadDir(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list NFS directory %s: %w", fullPath, err)
        }</span>

        <span class="cov0" title="0">var files []*FileInfo
        for _, entry := range entries </span><span class="cov0" title="0">{
                info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip files we can't get info for
                }
                <span class="cov0" title="0">files = append(files, &amp;FileInfo{
                        Name:    entry.Name(),
                        Size:    info.Size(),
                        ModTime: info.ModTime(),
                        IsDir:   entry.IsDir(),
                        Mode:    info.Mode(),
                        Path:    filepath.Join(path, entry.Name()),
                })</span>
        }

        <span class="cov0" title="0">return files, nil</span>
}

// FileExists checks if a file exists
func (c *NFSClient) FileExists(ctx context.Context, path string) (bool, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return false, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        _, err := os.Stat(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check NFS file existence %s: %w", fullPath, err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// CreateDirectory creates a directory
func (c *NFSClient) CreateDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := os.MkdirAll(fullPath, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create NFS directory %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteDirectory deletes a directory
func (c *NFSClient) DeleteDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := os.RemoveAll(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete NFS directory %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteFile deletes a file
func (c *NFSClient) DeleteFile(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := os.Remove(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete NFS file %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CopyFile copies a file within the NFS mount
func (c *NFSClient) CopyFile(ctx context.Context, srcPath, dstPath string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">srcFullPath := c.resolvePath(srcPath)
        dstFullPath := c.resolvePath(dstPath)

        // Ensure destination directory exists
        dstDir := filepath.Dir(dstFullPath)
        if err := os.MkdirAll(dstDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination directory %s: %w", dstDir, err)
        }</span>

        // Open source file
        <span class="cov0" title="0">srcFile, err := os.Open(srcFullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file %s: %w", srcFullPath, err)
        }</span>
        <span class="cov0" title="0">defer srcFile.Close()

        // Create destination file
        dstFile, err := os.Create(dstFullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination file %s: %w", dstFullPath, err)
        }</span>
        <span class="cov0" title="0">defer dstFile.Close()

        // Copy data
        _, err = io.Copy(dstFile, srcFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file from %s to %s: %w", srcFullPath, dstFullPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetProtocol returns the protocol name
func (c *NFSClient) GetProtocol() string <span class="cov8" title="1">{
        return "nfs"
}</span>

// GetConfig returns the NFS configuration
func (c *NFSClient) GetConfig() interface{} <span class="cov0" title="0">{
        return c.config
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package filesystem

import (
        "context"
        "fmt"
        "io"
        "net"

        "github.com/hirochachacha/go-smb2"
)

// SmbConfig contains SMB connection configuration
type SmbConfig struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Share    string `json:"share"`
        Username string `json:"username"`
        Password string `json:"password"`
        Domain   string `json:"domain"`
}

// SmbClient implements FileSystemClient for SMB protocol
type SmbClient struct {
        conn    net.Conn
        session *smb2.Session
        share   *smb2.Share
        config  *SmbConfig
}

// NewSmbClient creates a new SMB client
func NewSmbClient(config *SmbConfig) *SmbClient <span class="cov10" title="4">{
        return &amp;SmbClient{
                config: config,
        }
}</span>

// Connect establishes the SMB connection
func (c *SmbClient) Connect(ctx context.Context) error <span class="cov1" title="1">{
        // Establish TCP connection
        addr := fmt.Sprintf("%s:%d", c.config.Host, c.config.Port)
        conn, err := net.Dial("tcp", addr)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to connect to SMB server: %w", err)
        }</span>

        // Create SMB session
        <span class="cov0" title="0">d := &amp;smb2.Dialer{
                Initiator: &amp;smb2.NTLMInitiator{
                        User:     c.config.Username,
                        Password: c.config.Password,
                        Domain:   c.config.Domain,
                },
        }

        session, err := d.Dial(conn)
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return fmt.Errorf("failed to create SMB session: %w", err)
        }</span>

        // Mount share
        <span class="cov0" title="0">share, err := session.Mount(c.config.Share)
        if err != nil </span><span class="cov0" title="0">{
                session.Logoff()
                conn.Close()
                return fmt.Errorf("failed to mount SMB share: %w", err)
        }</span>

        <span class="cov0" title="0">c.conn = conn
        c.session = session
        c.share = share
        return nil</span>
}

// Disconnect closes the SMB connection
func (c *SmbClient) Disconnect(ctx context.Context) error <span class="cov0" title="0">{
        var errs []error

        if c.share != nil </span><span class="cov0" title="0">{
                if err := c.share.Umount(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to unmount share: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if c.session != nil </span><span class="cov0" title="0">{
                if err := c.session.Logoff(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to logoff session: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if c.conn != nil </span><span class="cov0" title="0">{
                if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to close connection: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors closing SMB client: %v", errs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsConnected returns true if the client is connected
func (c *SmbClient) IsConnected() bool <span class="cov8" title="3">{
        return c.share != nil &amp;&amp; c.session != nil &amp;&amp; c.conn != nil
}</span>

// TestConnection tests the SMB connection
func (c *SmbClient) TestConnection(ctx context.Context) error <span class="cov1" title="1">{
        if !c.IsConnected() </span><span class="cov1" title="1">{
                return fmt.Errorf("not connected")
        }</span>
        // Try to list the root directory
        <span class="cov0" title="0">_, err := c.share.ReadDir(".")
        return err</span>
}

// ReadFile reads a file from the SMB share
func (c *SmbClient) ReadFile(ctx context.Context, path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">file, err := c.share.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open SMB file %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return file, nil</span>
}

// WriteFile writes a file to the SMB share
func (c *SmbClient) WriteFile(ctx context.Context, path string, data io.Reader) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">file, err := c.share.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create SMB file %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        _, err = io.Copy(file, data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write SMB file %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFileInfo gets information about a file
func (c *SmbClient) GetFileInfo(ctx context.Context, path string) (*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">stat, err := c.share.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat SMB file %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return &amp;FileInfo{
                Name:    stat.Name(),
                Size:    stat.Size(),
                ModTime: stat.ModTime(),
                IsDir:   stat.IsDir(),
                Mode:    stat.Mode(),
                Path:    path,
        }, nil</span>
}

// ListDirectory lists files in a directory
func (c *SmbClient) ListDirectory(ctx context.Context, path string) ([]*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">entries, err := c.share.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list SMB directory %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">var files []*FileInfo
        for _, entry := range entries </span><span class="cov0" title="0">{
                files = append(files, &amp;FileInfo{
                        Name:    entry.Name(),
                        Size:    entry.Size(),
                        ModTime: entry.ModTime(),
                        IsDir:   entry.IsDir(),
                        Mode:    entry.Mode(),
                        Path:    path + "/" + entry.Name(),
                })
        }</span>

        <span class="cov0" title="0">return files, nil</span>
}

// FileExists checks if a file exists
func (c *SmbClient) FileExists(ctx context.Context, path string) (bool, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return false, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">_, err := c.share.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                if isNotExistError(err) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check SMB file existence %s: %w", path, err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// CreateDirectory creates a directory
func (c *SmbClient) CreateDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">err := c.share.Mkdir(path, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create SMB directory %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteDirectory deletes a directory
func (c *SmbClient) DeleteDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">err := c.share.Remove(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete SMB directory %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteFile deletes a file
func (c *SmbClient) DeleteFile(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">err := c.share.Remove(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete SMB file %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CopyFile copies a file within the SMB share
func (c *SmbClient) CopyFile(ctx context.Context, srcPath, dstPath string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        // Read source file
        <span class="cov0" title="0">srcFile, err := c.share.Open(srcPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file %s: %w", srcPath, err)
        }</span>
        <span class="cov0" title="0">defer srcFile.Close()

        // Create destination file
        dstFile, err := c.share.Create(dstPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination file %s: %w", dstPath, err)
        }</span>
        <span class="cov0" title="0">defer dstFile.Close()

        // Copy data
        _, err = io.Copy(dstFile, srcFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file from %s to %s: %w", srcPath, dstPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetProtocol returns the protocol name
func (c *SmbClient) GetProtocol() string <span class="cov5" title="2">{
        return "smb"
}</span>

// GetConfig returns the SMB configuration
func (c *SmbClient) GetConfig() interface{} <span class="cov0" title="0">{
        return c.config
}</span>

// Helper function to check if error is "file not found"
func isNotExistError(err error) bool <span class="cov0" title="0">{
        // This is a simplified check - in practice you might want to check
        // for specific SMB error codes
        return err != nil &amp;&amp; (err.Error() == "file does not exist" || err.Error() == "no such file or directory")
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package filesystem

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "path/filepath"
        "strconv"
        "strings"
        "time"
)

// WebDAVConfig contains WebDAV connection configuration
type WebDAVConfig struct {
        URL      string `json:"url"`
        Username string `json:"username"`
        Password string `json:"password"`
        Path     string `json:"path"` // Base path on the WebDAV server
}

// WebDAVClient implements FileSystemClient for WebDAV protocol
type WebDAVClient struct {
        config    *WebDAVConfig
        client    *http.Client
        baseURL   *url.URL
        connected bool
}

// NewWebDAVClient creates a new WebDAV client
func NewWebDAVClient(config *WebDAVConfig) *WebDAVClient <span class="cov8" title="1">{
        baseURL, _ := url.Parse(config.URL)
        if config.Path != "" &amp;&amp; config.Path != "/" </span><span class="cov0" title="0">{
                baseURL.Path = config.Path
        }</span>

        <span class="cov8" title="1">return &amp;WebDAVClient{
                config:  config,
                client:  &amp;http.Client{Timeout: 30 * time.Second},
                baseURL: baseURL,
        }</span>
}

// Connect establishes the WebDAV connection
func (c *WebDAVClient) Connect(ctx context.Context) error <span class="cov0" title="0">{
        // Test the connection with a PROPFIND request
        req, err := http.NewRequestWithContext(ctx, "PROPFIND", c.baseURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create PROPFIND request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Depth", "0")

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to WebDAV server: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusMultiStatus &amp;&amp; resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV server returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">c.connected = true
        return nil</span>
}

// Disconnect closes the WebDAV connection
func (c *WebDAVClient) Disconnect(ctx context.Context) error <span class="cov0" title="0">{
        c.connected = false
        return nil
}</span>

// IsConnected returns true if the client is connected
func (c *WebDAVClient) IsConnected() bool <span class="cov0" title="0">{
        return c.connected
}</span>

// TestConnection tests the WebDAV connection
func (c *WebDAVClient) TestConnection(ctx context.Context) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">return c.Connect(ctx)</span> // Re-test connection
}

// resolveURL resolves a relative path to a full WebDAV URL
func (c *WebDAVClient) resolveURL(path string) string <span class="cov0" title="0">{
        // Clean the path and prevent directory traversal
        cleanPath := filepath.Clean(path)
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                // Prevent directory traversal attacks
                cleanPath = strings.ReplaceAll(cleanPath, "..", "")
        }</span>

        <span class="cov0" title="0">u := *c.baseURL
        u.Path = filepath.Join(u.Path, cleanPath)
        return u.String()</span>
}

// ReadFile reads a file from the WebDAV server
func (c *WebDAVClient) ReadFile(ctx context.Context, path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "GET", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GET request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to retrieve WebDAV file %s: %w", fullURL, err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                resp.Body.Close()
                return nil, fmt.Errorf("WebDAV server returned status %d for file %s", resp.StatusCode, fullURL)
        }</span>

        <span class="cov0" title="0">return resp.Body, nil</span>
}

// WriteFile writes a file to the WebDAV server
func (c *WebDAVClient) WriteFile(ctx context.Context, path string, data io.Reader) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "PUT", fullURL, data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create PUT request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload WebDAV file %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV server returned status %d for file %s", resp.StatusCode, fullURL)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFileInfo gets information about a file
func (c *WebDAVClient) GetFileInfo(ctx context.Context, path string) (*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "HEAD", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HEAD request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get WebDAV file info %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("WebDAV server returned status %d for file %s", resp.StatusCode, fullURL)
        }</span>

        // Parse content length
        <span class="cov0" title="0">size := int64(0)
        if cl := resp.Header.Get("Content-Length"); cl != "" </span><span class="cov0" title="0">{
                if s, err := strconv.ParseInt(cl, 10, 64); err == nil </span><span class="cov0" title="0">{
                        size = s
                }</span>
        }

        // Parse last modified
        <span class="cov0" title="0">modTime := time.Now()
        if lm := resp.Header.Get("Last-Modified"); lm != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse(time.RFC1123, lm); err == nil </span><span class="cov0" title="0">{
                        modTime = t
                }</span>
        }

        // Check if it's a directory (simplified check)
        <span class="cov0" title="0">isDir := strings.HasSuffix(path, "/") || resp.Header.Get("Content-Type") == "httpd/unix-directory"

        return &amp;FileInfo{
                Name:    filepath.Base(path),
                Size:    size,
                ModTime: modTime,
                IsDir:   isDir,
                Mode:    0644, // Default mode
                Path:    path,
        }, nil</span>
}

// ListDirectory lists files in a directory
func (c *WebDAVClient) ListDirectory(ctx context.Context, path string) ([]*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "PROPFIND", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create PROPFIND request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Depth", "1")

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list WebDAV directory %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusMultiStatus </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("WebDAV server returned status %d for directory %s", resp.StatusCode, fullURL)
        }</span>

        // Parse XML response (simplified - in production you'd use proper XML parsing)
        // For now, return empty list as PROPFIND parsing is complex
        <span class="cov0" title="0">return []*FileInfo{}, nil</span>
}

// FileExists checks if a file exists
func (c *WebDAVClient) FileExists(ctx context.Context, path string) (bool, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return false, fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "HEAD", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to create HEAD request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check WebDAV file existence %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        return resp.StatusCode == http.StatusOK, nil</span>
}

// CreateDirectory creates a directory
func (c *WebDAVClient) CreateDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "MKCOL", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MKCOL request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create WebDAV directory %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV server returned status %d for directory %s", resp.StatusCode, fullURL)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteDirectory deletes a directory
func (c *WebDAVClient) DeleteDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "DELETE", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create DELETE request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete WebDAV directory %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV server returned status %d for directory %s", resp.StatusCode, fullURL)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteFile deletes a file
func (c *WebDAVClient) DeleteFile(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "DELETE", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create DELETE request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete WebDAV file %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV server returned status %d for file %s", resp.StatusCode, fullURL)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CopyFile copies a file on the WebDAV server
func (c *WebDAVClient) CopyFile(ctx context.Context, srcPath, dstPath string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">srcURL := c.resolveURL(srcPath)
        dstURL := c.resolveURL(dstPath)

        req, err := http.NewRequestWithContext(ctx, "COPY", srcURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create COPY request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Destination", dstURL)

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy WebDAV file from %s to %s: %w", srcURL, dstURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV server returned status %d for copy operation", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetProtocol returns the protocol name
func (c *WebDAVClient) GetProtocol() string <span class="cov8" title="1">{
        return "webdav"
}</span>

// GetConfig returns the WebDAV configuration
func (c *WebDAVClient) GetConfig() interface{} <span class="cov0" title="0">{
        return c.config
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "strings"

        "catalogizer/models"
        "catalogizer/services"
)

type AuthHandler struct {
        authService *services.AuthService
}

func NewAuthHandler(authService *services.AuthService) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                authService: authService,
        }
}</span>

func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var req models.LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">ipAddress := getClientIP(r)
        userAgent := r.Header.Get("User-Agent")

        result, err := h.authService.Login(req, ipAddress, userAgent)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(result)</span>
}

func (h *AuthHandler) RefreshToken(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                RefreshToken string `json:"refresh_token"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">result, err := h.authService.RefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(result)</span>
}

func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">token := extractToken(r)
        if token == "" </span><span class="cov0" title="0">{
                http.Error(w, "Authorization token required", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">err := h.authService.Logout(token)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Logged out successfully"})</span>
}

func (h *AuthHandler) LogoutAll(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">user, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">err = h.authService.LogoutAll(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "All sessions terminated"})</span>
}

func (h *AuthHandler) GetCurrentUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">user, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">user.PasswordHash = ""
        user.Salt = ""

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)</span>
}

func (h *AuthHandler) ChangePassword(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">user, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                CurrentPassword string `json:"current_password"`
                NewPassword     string `json:"new_password"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.authService.ValidatePassword(req.NewPassword); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.authService.ChangePassword(user.ID, req.CurrentPassword, req.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Password changed successfully"})</span>
}

func (h *AuthHandler) GetActiveSessions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">user, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">sessions, err := h.authService.GetActiveSessions(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">for i := range sessions </span><span class="cov0" title="0">{
                sessions[i].SessionToken = ""
                sessions[i].RefreshToken = nil
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(sessions)</span>
}

func (h *AuthHandler) DeactivateSession(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">_, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">sessionIDStr := r.URL.Query().Get("session_id")
        if sessionIDStr == "" </span><span class="cov0" title="0">{
                http.Error(w, "Session ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">sessionID, err := strconv.Atoi(sessionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid session ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.authService.DeactivateSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Session deactivated"})</span>
}

func (h *AuthHandler) ValidateToken(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">token := extractToken(r)
        if token == "" </span><span class="cov0" title="0">{
                http.Error(w, "Authorization token required", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">claims, err := h.authService.ValidateToken(token)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid token", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "valid":      true,
                "user_id":    claims.UserID,
                "username":   claims.Username,
                "role_id":    claims.RoleID,
                "session_id": claims.SessionID,
                "expires_at": claims.ExpiresAt,
        })</span>
}

func (h *AuthHandler) getCurrentUser(r *http.Request) (*models.User, error) <span class="cov0" title="0">{
        token := extractToken(r)
        if token == "" </span><span class="cov0" title="0">{
                return nil, models.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return h.authService.GetCurrentUser(token)</span>
}

func extractToken(r *http.Request) string <span class="cov0" title="0">{
        bearerToken := r.Header.Get("Authorization")
        if bearerToken == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">parts := strings.Split(bearerToken, " ")
        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return parts[1]</span>
}

func getClientIP(r *http.Request) string <span class="cov0" title="0">{
        ip := r.Header.Get("X-Real-IP")
        if ip == "" </span><span class="cov0" title="0">{
                ip = r.Header.Get("X-Forwarded-For")
                if ip != "" </span><span class="cov0" title="0">{
                        parts := strings.Split(ip, ",")
                        ip = strings.TrimSpace(parts[0])
                }</span>
        }
        <span class="cov0" title="0">if ip == "" </span><span class="cov0" title="0">{
                ip = r.RemoteAddr
                if strings.Contains(ip, ":") </span><span class="cov0" title="0">{
                        parts := strings.Split(ip, ":")
                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                ip = parts[0]
                        }</span>
                }
        }
        <span class="cov0" title="0">return ip</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/utils"

        "github.com/gin-gonic/gin"
)

// BrowseHandler handles browse operations
type BrowseHandler struct {
        fileRepo *repository.FileRepository
}

// NewBrowseHandler creates a new browse handler
func NewBrowseHandler(fileRepo *repository.FileRepository) *BrowseHandler <span class="cov0" title="0">{
        return &amp;BrowseHandler{
                fileRepo: fileRepo,
        }
}</span>

// GetStorageRoots godoc
// @Summary Get all storage roots
// @Description Retrieve all configured storage roots
// @Tags browse
// @Accept json
// @Produce json
// @Success 200 {array} models.StorageRoot
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/browse/roots [get]
func (h *BrowseHandler) GetStorageRoots(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        roots, err := h.fileRepo.GetStorageRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get storage roots", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    roots,
        })</span>
}

// BrowseDirectory godoc
// @Summary Browse directory contents
// @Description Get files and directories within a specific path
// @Tags browse
// @Accept json
// @Produce json
// @Param storage_root path string true "Storage root name"
// @Param path query string false "Directory path" default("/")
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(100)
// @Param sort_by query string false "Sort field (name, size, modified_at, created_at, path, extension)" default("name")
// @Param sort_order query string false "Sort order (asc, desc)" default("asc")
// @Success 200 {object} models.SearchResult
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/browse/{storage_root} [get]
func (h *BrowseHandler) BrowseDirectory(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        storageRoot := c.Param("storage_root")
        if storageRoot == "" </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Storage root name is required", nil)
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">path := c.DefaultQuery("path", "/")
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "100"))
        sortBy := c.DefaultQuery("sort_by", "name")
        sortOrder := c.DefaultQuery("sort_order", "asc")

        // Validate pagination
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit &lt; 1 || limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        // Validate sort parameters
        <span class="cov0" title="0">validSortFields := map[string]bool{
                "name":        true,
                "size":        true,
                "modified_at": true,
                "created_at":  true,
                "path":        true,
                "extension":   true,
        }
        if !validSortFields[sortBy] </span><span class="cov0" title="0">{
                sortBy = "name"
        }</span>

        <span class="cov0" title="0">if sortOrder != "asc" &amp;&amp; sortOrder != "desc" </span><span class="cov0" title="0">{
                sortOrder = "asc"
        }</span>

        <span class="cov0" title="0">pagination := models.PaginationOptions{
                Page:  page,
                Limit: limit,
        }

        sort := models.SortOptions{
                Field: sortBy,
                Order: sortOrder,
        }

        result, err := h.fileRepo.GetDirectoryContents(ctx, storageRoot, path, pagination, sort)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to browse directory", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// GetFileInfo godoc
// @Summary Get file information
// @Description Get detailed information about a specific file
// @Tags browse
// @Accept json
// @Produce json
// @Param id path int true "File ID"
// @Success 200 {object} models.FileWithMetadata
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/browse/file/{id} [get]
func (h *BrowseHandler) GetFileInfo(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid file ID", nil)
                return
        }</span>

        <span class="cov0" title="0">file, err := h.fileRepo.GetFileByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "file not found" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusNotFound, "File not found", nil)
                        return
                }</span>
                <span class="cov0" title="0">utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get file info", err)
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    file,
        })</span>
}

// GetDirectorySizes godoc
// @Summary Get directories sorted by size
// @Description Retrieve directories sorted by their total size
// @Tags browse
// @Accept json
// @Produce json
// @Param storage_root path string true "Storage root name"
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(50)
// @Param ascending query bool false "Sort in ascending order" default(false)
// @Success 200 {array} models.DirectoryInfo
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/browse/{storage_root}/sizes [get]
func (h *BrowseHandler) GetDirectorySizes(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        storageRoot := c.Param("storage_root")
        if storageRoot == "" </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Storage root name is required", nil)
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
        ascending, _ := strconv.ParseBool(c.DefaultQuery("ascending", "false"))

        // Validate pagination
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit &lt; 1 || limit &gt; 500 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">pagination := models.PaginationOptions{
                Page:  page,
                Limit: limit,
        }

        directories, err := h.fileRepo.GetDirectoriesSortedBySize(ctx, storageRoot, pagination, ascending)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get directory sizes", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    directories,
        })</span>
}

// GetDirectoryDuplicates godoc
// @Summary Get directories sorted by duplicate count
// @Description Retrieve directories sorted by their number of duplicate files
// @Tags browse
// @Accept json
// @Produce json
// @Param storage_root path string true "Storage root name"
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(50)
// @Param ascending query bool false "Sort in ascending order" default(false)
// @Success 200 {array} models.DirectoryInfo
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/browse/{storage_root}/duplicates [get]
func (h *BrowseHandler) GetDirectoryDuplicates(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        storageRoot := c.Param("storage_root")
        if storageRoot == "" </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Storage root name is required", nil)
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
        ascending, _ := strconv.ParseBool(c.DefaultQuery("ascending", "false"))

        // Validate pagination
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit &lt; 1 || limit &gt; 500 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">pagination := models.PaginationOptions{
                Page:  page,
                Limit: limit,
        }

        directories, err := h.fileRepo.GetDirectoriesSortedByDuplicates(ctx, storageRoot, pagination, ascending)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get directory duplicates", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    directories,
        })</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"

        "catalogizer/models"
        "catalogizer/services"

        "github.com/gorilla/mux"
)

type ConfigurationHandler struct {
        configurationService *services.ConfigurationService
        authService          *services.AuthService
}

func NewConfigurationHandler(configurationService *services.ConfigurationService, authService *services.AuthService) *ConfigurationHandler <span class="cov0" title="0">{
        return &amp;ConfigurationHandler{
                configurationService: configurationService,
                authService:          authService,
        }
}</span>

// Wizard endpoints

func (h *ConfigurationHandler) GetWizardStep(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        stepID := vars["step_id"]

        step, err := h.configurationService.GetWizardStep(stepID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(step)</span>
}

func (h *ConfigurationHandler) ValidateWizardStep(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        stepID := vars["step_id"]

        var data map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;data); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">validation, err := h.configurationService.ValidateWizardStep(stepID, data)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(validation)</span>
}

func (h *ConfigurationHandler) SaveWizardProgress(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        stepID := vars["step_id"]

        var finalData map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;finalData); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.configurationService.SaveWizardProgress(userID, stepID, finalData)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "message": "Progress saved successfully",
        })</span>
}

func (h *ConfigurationHandler) GetWizardProgress(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        progress, err := h.configurationService.GetWizardProgress(userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(progress)</span>
}

func (h *ConfigurationHandler) CompleteWizard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        var finalData map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;finalData); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">config, err := h.configurationService.CompleteWizard(userID, finalData)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "message":       "Wizard completed successfully",
                "configuration": config,
        })</span>
}

// Configuration endpoints

func (h *ConfigurationHandler) GetConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemConfig)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">schema, err := h.configurationService.GetConfigurationSchema()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(schema)</span>
}

func (h *ConfigurationHandler) TestConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        //         // This would test the configuration through the service

        // This would test the configuration through the service
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "message": "Configuration tested successfully",
        })</span>
}

func (h *ConfigurationHandler) DeleteBackup(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        _, err := strconv.Atoi(vars["backup_id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid backup ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        // This would delete the backup through the service
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "message": "Backup deleted successfully",
        })</span>
}

// Health check endpoint

func (h *ConfigurationHandler) GetSystemStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemConfig)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">status := map[string]interface{}{
                "status":  "healthy",
                "version": "3.0.0",
                "uptime":  "24h 30m",
                "components": map[string]string{
                        "database":         "healthy",
                        "storage":          "healthy",
                        "authentication":   "healthy",
                        "media_conversion": "healthy",
                        "sync":             "healthy",
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(status)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/services"
)

type ConversionHandler struct {
        conversionService *services.ConversionService
        authService       *services.AuthService
}

func NewConversionHandler(conversionService *services.ConversionService, authService *services.AuthService) *ConversionHandler <span class="cov0" title="0">{
        return &amp;ConversionHandler{
                conversionService: conversionService,
                authService:       authService,
        }
}</span>

func (h *ConversionHandler) CreateJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionMediaUpload)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var req models.ConversionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">job, err := h.conversionService.CreateConversionJob(currentUser.ID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(job)</span>
}

func (h *ConversionHandler) GetJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">jobIDStr := strings.TrimPrefix(r.URL.Path, "/api/conversion/jobs/")
        jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">job, err := h.conversionService.GetJob(jobID, currentUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "unauthorized") </span><span class="cov0" title="0">{
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        http.Error(w, "Job not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to get job", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(job)</span>
}

func (h *ConversionHandler) ListUserJobs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">status := r.URL.Query().Get("status")
        var statusPtr *string
        if status != "" </span><span class="cov0" title="0">{
                statusPtr = &amp;status
        }</span>

        <span class="cov0" title="0">limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")

        limit := 50
        offset := 0

        if limitStr != "" </span><span class="cov0" title="0">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 &amp;&amp; parsedLimit &lt;= 100 </span><span class="cov0" title="0">{
                        limit = parsedLimit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if parsedOffset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; parsedOffset &gt;= 0 </span><span class="cov0" title="0">{
                        offset = parsedOffset
                }</span>
        }

        <span class="cov0" title="0">jobs, err := h.conversionService.GetUserJobs(currentUser.ID, statusPtr, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get jobs", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "jobs":   jobs,
                "limit":  limit,
                "offset": offset,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

func (h *ConversionHandler) StartJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserManage)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">jobIDStr := strings.TrimPrefix(r.URL.Path, "/api/conversion/jobs/")
        jobIDStr = strings.TrimSuffix(jobIDStr, "/start")
        jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.conversionService.StartConversion(jobID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Job started successfully"})</span>
}

func (h *ConversionHandler) CancelJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">jobIDStr := strings.TrimPrefix(r.URL.Path, "/api/conversion/jobs/")
        jobIDStr = strings.TrimSuffix(jobIDStr, "/cancel")
        jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.conversionService.CancelJob(jobID, currentUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "unauthorized") </span><span class="cov0" title="0">{
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, err.Error(), http.StatusBadRequest)
                return</span>
        }

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Job cancelled successfully"})</span>
}

func (h *ConversionHandler) RetryJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">jobIDStr := strings.TrimPrefix(r.URL.Path, "/api/conversion/jobs/")
        jobIDStr = strings.TrimSuffix(jobIDStr, "/retry")
        jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.conversionService.RetryJob(jobID, currentUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "unauthorized") </span><span class="cov0" title="0">{
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, err.Error(), http.StatusBadRequest)
                return</span>
        }

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Job restarted successfully"})</span>
}

func (h *ConversionHandler) GetSupportedFormats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">formats := h.conversionService.GetSupportedFormats()

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(formats)</span>
}

func (h *ConversionHandler) GetStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">startDateStr := r.URL.Query().Get("start_date")
        endDateStr := r.URL.Query().Get("end_date")
        userIDStr := r.URL.Query().Get("user_id")

        var startDate, endDate time.Time
        var userID *int

        if startDateStr != "" </span><span class="cov0" title="0">{
                if parsed, err := time.Parse("2006-01-02", startDateStr); err == nil </span><span class="cov0" title="0">{
                        startDate = parsed
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Invalid start_date format", http.StatusBadRequest)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                startDate = time.Now().AddDate(0, -1, 0) // Default to last month
        }</span>

        <span class="cov0" title="0">if endDateStr != "" </span><span class="cov0" title="0">{
                if parsed, err := time.Parse("2006-01-02", endDateStr); err == nil </span><span class="cov0" title="0">{
                        endDate = parsed
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Invalid end_date format", http.StatusBadRequest)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                endDate = time.Now()
        }</span>

        <span class="cov0" title="0">if userIDStr != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(userIDStr); err == nil </span><span class="cov0" title="0">{
                        if parsed != currentUser.ID </span><span class="cov0" title="0">{
                                hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionAnalyticsView)
                                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                                        http.Error(w, "Insufficient permissions", http.StatusForbidden)
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">userID = &amp;parsed</span>
                } else<span class="cov0" title="0"> {
                        http.Error(w, "Invalid user_id format", http.StatusBadRequest)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                userID = &amp;currentUser.ID
        }</span>

        <span class="cov0" title="0">stats, err := h.conversionService.GetJobStatistics(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get statistics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

func (h *ConversionHandler) ProcessQueue(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">err = h.conversionService.ProcessJobQueue()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to process queue", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Queue processing started"})</span>
}

func (h *ConversionHandler) GetQueue(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionAnalyticsView)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">jobs, err := h.conversionService.GetJobQueue()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get queue", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "queue": jobs,
                "count": len(jobs),
        })</span>
}

func (h *ConversionHandler) CleanupJobs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">daysStr := r.URL.Query().Get("days")
        days := 30 // Default to 30 days

        if daysStr != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(daysStr); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov0" title="0">{
                        days = parsed
                }</span>
        }

        <span class="cov0" title="0">olderThan := time.Now().AddDate(0, 0, -days)

        err = h.conversionService.CleanupCompletedJobs(olderThan)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to cleanup jobs", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Cleanup completed successfully"})</span>
}

func (h *ConversionHandler) getCurrentUser(r *http.Request) (*models.User, error) <span class="cov0" title="0">{
        token := extractToken(r)
        if token == "" </span><span class="cov0" title="0">{
                return nil, models.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return h.authService.GetCurrentUser(token)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/smb"
        "catalogizer/utils"

        "github.com/gin-gonic/gin"
)

// CopyHandler handles file copy operations
type CopyHandler struct {
        fileRepo *repository.FileRepository
        smbPool  *smb.SmbConnectionPool
        tempDir  string
}

// NewCopyHandler creates a new copy handler
func NewCopyHandler(fileRepo *repository.FileRepository, tempDir string) *CopyHandler <span class="cov0" title="0">{
        return &amp;CopyHandler{
                fileRepo: fileRepo,
                smbPool:  smb.NewSmbConnectionPool(10),
                tempDir:  tempDir,
        }
}</span>

// CopyToSmb godoc
// @Summary Copy file/directory to SMB location
// @Description Copy a file or directory from one SMB location to another
// @Tags copy
// @Accept json
// @Produce json
// @Param body body SmbCopyRequest true "Copy request"
// @Success 200 {object} CopyResponse
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/copy/smb [post]
func (h *CopyHandler) CopyToSmb(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        var req SmbCopyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validateSmbCopyRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid copy request", err)
                return
        }</span>

        // Get source file information
        <span class="cov0" title="0">sourceFile, err := h.fileRepo.GetFileByID(ctx, req.SourceFileID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "file not found" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusNotFound, "Source file not found", err)
                        return
                }</span>
                <span class="cov0" title="0">utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get source file info", err)
                return</span>
        }

        // Get storage roots
        <span class="cov0" title="0">storageRoots, err := h.fileRepo.GetStorageRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get storage roots", err)
                return
        }</span>

        // Find source and destination storage roots
        <span class="cov0" title="0">var sourceStorageRoot, destStorageRoot *models.StorageRoot
        for _, root := range storageRoots </span><span class="cov0" title="0">{
                if root.ID == sourceFile.StorageRootID </span><span class="cov0" title="0">{
                        sourceStorageRoot = &amp;root
                }</span>
                <span class="cov0" title="0">if root.Name == req.DestinationSmbRoot </span><span class="cov0" title="0">{
                        destStorageRoot = &amp;root
                }</span>
        }

        <span class="cov0" title="0">if sourceStorageRoot == nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "Source storage root not found", nil)
                return
        }</span>
        <span class="cov0" title="0">if destStorageRoot == nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "Destination storage root not found", nil)
                return
        }</span>

        // Create SMB connections
        <span class="cov0" title="0">sourceSmbClient, err := h.createSmbClient(sourceStorageRoot)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to connect to source SMB", err)
                return
        }</span>

        <span class="cov0" title="0">destSmbClient, err := h.createSmbClient(destStorageRoot)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to connect to destination SMB", err)
                return
        }</span>

        // Perform copy operation
        <span class="cov0" title="0">startTime := time.Now()
        var result CopyResponse

        if sourceFile.IsDirectory </span><span class="cov0" title="0">{
                result, err = h.copyDirectoryToSmb(ctx, sourceSmbClient, destSmbClient, sourceFile.Path, req.DestinationPath, req.OverwriteExisting)
        }</span> else<span class="cov0" title="0"> {
                result, err = h.copyFileToSmb(ctx, sourceSmbClient, destSmbClient, sourceFile.Path, req.DestinationPath, req.OverwriteExisting)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Copy operation failed", err)
                return
        }</span>

        <span class="cov0" title="0">result.TimeTaken = time.Since(startTime)
        result.Success = true

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// CopyToLocal godoc
// @Summary Copy file/directory to local computer
// @Description Copy a file or directory from SMB to local computer
// @Tags copy
// @Accept json
// @Produce json
// @Param body body LocalCopyRequest true "Copy request"
// @Success 200 {object} CopyResponse
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/copy/local [post]
func (h *CopyHandler) CopyToLocal(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        var req LocalCopyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validateLocalCopyRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid copy request", err)
                return
        }</span>

        // Get source file information
        <span class="cov0" title="0">sourceFile, err := h.fileRepo.GetFileByID(ctx, req.SourceFileID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "file not found" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusNotFound, "Source file not found", err)
                        return
                }</span>
                <span class="cov0" title="0">utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get source file info", err)
                return</span>
        }

        // Get SMB roots
        <span class="cov0" title="0">smbRoots, err := h.fileRepo.GetStorageRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get SMB roots", err)
                return
        }</span>

        // Find source SMB root
        <span class="cov0" title="0">var sourceSmbRoot *models.StorageRoot
        for _, root := range smbRoots </span><span class="cov0" title="0">{
                if root.ID == sourceFile.StorageRootID </span><span class="cov0" title="0">{
                        sourceSmbRoot = &amp;root
                        break</span>
                }
        }

        <span class="cov0" title="0">if sourceSmbRoot == nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "Source SMB root not found", nil)
                return
        }</span>

        // Create SMB connection
        <span class="cov0" title="0">sourceSmbClient, err := h.createSmbClient(sourceSmbRoot)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to connect to source SMB", err)
                return
        }</span>

        // Perform copy operation
        <span class="cov0" title="0">startTime := time.Now()
        var result CopyResponse

        if sourceFile.IsDirectory </span><span class="cov0" title="0">{
                result, err = h.copyDirectoryToLocal(ctx, sourceSmbClient, sourceFile.Path, req.DestinationPath, req.OverwriteExisting)
        }</span> else<span class="cov0" title="0"> {
                result, err = h.copyFileToLocal(ctx, sourceSmbClient, sourceFile.Path, req.DestinationPath, req.OverwriteExisting)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Copy operation failed", err)
                return
        }</span>

        <span class="cov0" title="0">result.TimeTaken = time.Since(startTime)
        result.Success = true

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// CopyFromLocal godoc
// @Summary Copy file/directory from local computer to SMB
// @Description Copy a file or directory from local computer to SMB location
// @Tags copy
// @Accept multipart/form-data
// @Produce json
// @Param destination_smb_root formData string true "Destination SMB root name"
// @Param destination_path formData string true "Destination path on SMB"
// @Param overwrite_existing formData bool false "Overwrite existing files" default(false)
// @Param file formData file true "File to upload"
// @Success 200 {object} CopyResponse
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/copy/upload [post]
func (h *CopyHandler) CopyFromLocal(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        // Parse form data
        destSmbRootName := c.PostForm("destination_smb_root")
        destPath := c.PostForm("destination_path")
        overwriteStr := c.DefaultPostForm("overwrite_existing", "false")
        overwrite := overwriteStr == "true"

        if destSmbRootName == "" || destPath == "" </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "destination_smb_root and destination_path are required", nil)
                return
        }</span>

        // Get uploaded file
        <span class="cov0" title="0">file, header, err := c.Request.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Failed to get uploaded file", err)
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Get SMB roots
        smbRoots, err := h.fileRepo.GetStorageRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get SMB roots", err)
                return
        }</span>

        // Find destination SMB root
        <span class="cov0" title="0">var destSmbRoot *models.StorageRoot
        for _, root := range smbRoots </span><span class="cov0" title="0">{
                if root.Name == destSmbRootName </span><span class="cov0" title="0">{
                        destSmbRoot = &amp;root
                        break</span>
                }
        }

        <span class="cov0" title="0">if destSmbRoot == nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "Destination SMB root not found", nil)
                return
        }</span>

        // Create SMB connection
        <span class="cov0" title="0">destSmbClient, err := h.createSmbClient(destSmbRoot)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to connect to destination SMB", err)
                return
        }</span>

        // Perform upload
        <span class="cov0" title="0">startTime := time.Now()
        fullDestPath := filepath.Join(destPath, header.Filename)

        // Check if file exists and overwrite policy
        if exists, err := destSmbClient.FileExists(fullDestPath); err == nil &amp;&amp; exists &amp;&amp; !overwrite </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusConflict, "File already exists and overwrite is disabled", nil)
                return
        }</span>

        // Copy file
        <span class="cov0" title="0">err = destSmbClient.WriteFile(fullDestPath, file)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to copy file to SMB", err)
                return
        }</span>

        <span class="cov0" title="0">result := CopyResponse{
                Success:     true,
                BytesCopied: header.Size,
                FilesCount:  1,
                TimeTaken:   time.Since(startTime),
                SourcePath:  header.Filename,
                DestPath:    fullDestPath,
        }

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// Helper methods

func (h *CopyHandler) createSmbClient(storageRoot *models.StorageRoot) (*smb.SmbClient, error) <span class="cov0" title="0">{
        host := ""
        if storageRoot.Host != nil </span><span class="cov0" title="0">{
                host = *storageRoot.Host
        }</span>
        <span class="cov0" title="0">port := 445
        if storageRoot.Port != nil </span><span class="cov0" title="0">{
                port = *storageRoot.Port
        }</span>
        <span class="cov0" title="0">share := ""
        if storageRoot.Path != nil </span><span class="cov0" title="0">{
                share = *storageRoot.Path
        }</span>
        <span class="cov0" title="0">username := ""
        if storageRoot.Username != nil </span><span class="cov0" title="0">{
                username = *storageRoot.Username
        }</span>
        <span class="cov0" title="0">domain := ""
        if storageRoot.Domain != nil </span><span class="cov0" title="0">{
                domain = *storageRoot.Domain
        }</span>

        <span class="cov0" title="0">smbConfig := &amp;smb.SmbConfig{
                Host:     host,
                Port:     port,
                Share:    share,
                Username: username,
                Domain:   domain,
        }

        connectionKey := fmt.Sprintf("%s:%d:%s:%s", host, port, share, username)
        return h.smbPool.GetConnection(connectionKey, smbConfig)</span>
}

func (h *CopyHandler) copyFileToSmb(ctx context.Context, sourceSmbClient, destSmbClient *smb.SmbClient, sourcePath, destPath string, overwrite bool) (CopyResponse, error) <span class="cov0" title="0">{
        // Check if destination exists
        if exists, err := destSmbClient.FileExists(destPath); err == nil &amp;&amp; exists &amp;&amp; !overwrite </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("destination file exists and overwrite is disabled")
        }</span>

        // Read source file
        <span class="cov0" title="0">sourceReader, err := sourceSmbClient.ReadFile(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to read source file: %w", err)
        }</span>
        <span class="cov0" title="0">defer sourceReader.Close()

        // Write to destination
        err = destSmbClient.WriteFile(destPath, sourceReader)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to write destination file: %w", err)
        }</span>

        // Get file info for size
        <span class="cov0" title="0">sourceInfo, err := sourceSmbClient.GetFileInfo(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to get source file info: %w", err)
        }</span>

        <span class="cov0" title="0">return CopyResponse{
                BytesCopied: sourceInfo.Size,
                FilesCount:  1,
                SourcePath:  sourcePath,
                DestPath:    destPath,
        }, nil</span>
}

func (h *CopyHandler) copyDirectoryToSmb(ctx context.Context, sourceSmbClient, destSmbClient *smb.SmbClient, sourcePath, destPath string, overwrite bool) (CopyResponse, error) <span class="cov0" title="0">{
        var totalBytes int64
        var filesCount int

        // Create destination directory
        err := destSmbClient.CreateDirectory(destPath)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Recursively copy contents
        <span class="cov0" title="0">err = h.copyDirectoryContentsToSmb(ctx, sourceSmbClient, destSmbClient, sourcePath, destPath, overwrite, &amp;totalBytes, &amp;filesCount)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, err
        }</span>

        <span class="cov0" title="0">return CopyResponse{
                BytesCopied: totalBytes,
                FilesCount:  filesCount,
                SourcePath:  sourcePath,
                DestPath:    destPath,
        }, nil</span>
}

func (h *CopyHandler) copyDirectoryContentsToSmb(ctx context.Context, sourceSmbClient, destSmbClient *smb.SmbClient, sourcePath, destPath string, overwrite bool, totalBytes *int64, filesCount *int) error <span class="cov0" title="0">{
        files, err := sourceSmbClient.ListDirectory(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list directory %s: %w", sourcePath, err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>

                <span class="cov0" title="0">sourceFilePath := filepath.Join(sourcePath, file.Name)
                destFilePath := filepath.Join(destPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        // Create subdirectory
                        err := destSmbClient.CreateDirectory(destFilePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", destFilePath, err)
                        }</span>

                        // Recursively copy subdirectory
                        <span class="cov0" title="0">err = h.copyDirectoryContentsToSmb(ctx, sourceSmbClient, destSmbClient, sourceFilePath, destFilePath, overwrite, totalBytes, filesCount)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Copy file
                        result, err := h.copyFileToSmb(ctx, sourceSmbClient, destSmbClient, sourceFilePath, destFilePath, overwrite)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">*totalBytes += result.BytesCopied
                        *filesCount += result.FilesCount</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (h *CopyHandler) copyFileToLocal(ctx context.Context, sourceSmbClient *smb.SmbClient, sourcePath, destPath string, overwrite bool) (CopyResponse, error) <span class="cov0" title="0">{
        // Check if destination exists
        if _, err := os.Stat(destPath); err == nil &amp;&amp; !overwrite </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("destination file exists and overwrite is disabled")
        }</span>

        // Ensure destination directory exists
        <span class="cov0" title="0">destDir := filepath.Dir(destPath)
        if err := os.MkdirAll(destDir, 0755); err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Read source file
        <span class="cov0" title="0">sourceReader, err := sourceSmbClient.ReadFile(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to read source file: %w", err)
        }</span>
        <span class="cov0" title="0">defer sourceReader.Close()

        // Create destination file
        destFile, err := os.Create(destPath)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to create destination file: %w", err)
        }</span>
        <span class="cov0" title="0">defer destFile.Close()

        // Copy data
        bytesCopied, err := io.Copy(destFile, sourceReader)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to copy file data: %w", err)
        }</span>

        <span class="cov0" title="0">return CopyResponse{
                BytesCopied: bytesCopied,
                FilesCount:  1,
                SourcePath:  sourcePath,
                DestPath:    destPath,
        }, nil</span>
}

func (h *CopyHandler) copyDirectoryToLocal(ctx context.Context, sourceSmbClient *smb.SmbClient, sourcePath, destPath string, overwrite bool) (CopyResponse, error) <span class="cov0" title="0">{
        var totalBytes int64
        var filesCount int

        // Create destination directory
        if err := os.MkdirAll(destPath, 0755); err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Recursively copy contents
        <span class="cov0" title="0">err := h.copyDirectoryContentsToLocal(ctx, sourceSmbClient, sourcePath, destPath, overwrite, &amp;totalBytes, &amp;filesCount)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, err
        }</span>

        <span class="cov0" title="0">return CopyResponse{
                BytesCopied: totalBytes,
                FilesCount:  filesCount,
                SourcePath:  sourcePath,
                DestPath:    destPath,
        }, nil</span>
}

func (h *CopyHandler) copyDirectoryContentsToLocal(ctx context.Context, sourceSmbClient *smb.SmbClient, sourcePath, destPath string, overwrite bool, totalBytes *int64, filesCount *int) error <span class="cov0" title="0">{
        files, err := sourceSmbClient.ListDirectory(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list directory %s: %w", sourcePath, err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>

                <span class="cov0" title="0">sourceFilePath := filepath.Join(sourcePath, file.Name)
                destFilePath := filepath.Join(destPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        // Create subdirectory
                        if err := os.MkdirAll(destFilePath, 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", destFilePath, err)
                        }</span>

                        // Recursively copy subdirectory
                        <span class="cov0" title="0">err = h.copyDirectoryContentsToLocal(ctx, sourceSmbClient, sourceFilePath, destFilePath, overwrite, totalBytes, filesCount)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Copy file
                        result, err := h.copyFileToLocal(ctx, sourceSmbClient, sourceFilePath, destFilePath, overwrite)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">*totalBytes += result.BytesCopied
                        *filesCount += result.FilesCount</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (h *CopyHandler) validateSmbCopyRequest(req *SmbCopyRequest) error <span class="cov0" title="0">{
        if req.SourceFileID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("source_file_id is required")
        }</span>
        <span class="cov0" title="0">if req.DestinationSmbRoot == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("destination_smb_root is required")
        }</span>
        <span class="cov0" title="0">if req.DestinationPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("destination_path is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *CopyHandler) validateLocalCopyRequest(req *LocalCopyRequest) error <span class="cov0" title="0">{
        if req.SourceFileID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("source_file_id is required")
        }</span>
        <span class="cov0" title="0">if req.DestinationPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("destination_path is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request/Response types

type SmbCopyRequest struct {
        SourceFileID       int64  `json:"source_file_id" binding:"required"`
        DestinationSmbRoot string `json:"destination_smb_root" binding:"required"`
        DestinationPath    string `json:"destination_path" binding:"required"`
        OverwriteExisting  bool   `json:"overwrite_existing"`
}

type LocalCopyRequest struct {
        SourceFileID      int64  `json:"source_file_id" binding:"required"`
        DestinationPath   string `json:"destination_path" binding:"required"`
        OverwriteExisting bool   `json:"overwrite_existing"`
}

type CopyResponse struct {
        Success     bool          `json:"success"`
        BytesCopied int64         `json:"bytes_copied"`
        FilesCount  int           `json:"files_count"`
        TimeTaken   time.Duration `json:"time_taken"`
        SourcePath  string        `json:"source_path"`
        DestPath    string        `json:"dest_path"`
}

// Close closes the copy handler and its resources
func (h *CopyHandler) Close() <span class="cov0" title="0">{
        h.smbPool.CloseAll()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "archive/zip"
        "context"
        "fmt"
        "io"
        "net/http"
        "path/filepath"
        "strconv"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/smb"
        "catalogizer/utils"

        "github.com/gin-gonic/gin"
)

// DownloadHandler handles file download operations
type DownloadHandler struct {
        fileRepo       *repository.FileRepository
        smbPool        *smb.SmbConnectionPool
        tempDir        string
        maxArchiveSize int64
        chunkSize      int
}

// NewDownloadHandler creates a new download handler
func NewDownloadHandler(fileRepo *repository.FileRepository, tempDir string, maxArchiveSize int64, chunkSize int) *DownloadHandler <span class="cov0" title="0">{
        return &amp;DownloadHandler{
                fileRepo:       fileRepo,
                smbPool:        smb.NewSmbConnectionPool(10), // Max 10 concurrent SMB connections
                tempDir:        tempDir,
                maxArchiveSize: maxArchiveSize,
                chunkSize:      chunkSize,
        }
}</span>

// DownloadFile godoc
// @Summary Download a file
// @Description Download a specific file by ID with streaming support
// @Tags download
// @Produce application/octet-stream
// @Param id path int true "File ID"
// @Param inline query bool false "Display inline instead of download" default(false)
// @Success 200 {file} binary
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/download/file/{id} [get]
func (h *DownloadHandler) DownloadFile(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        // Parse file ID
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid file ID", err)
                return
        }</span>

        // Get file information
        <span class="cov0" title="0">file, err := h.fileRepo.GetFileByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "file not found" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusNotFound, "File not found", err)
                        return
                }</span>
                <span class="cov0" title="0">utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get file info", err)
                return</span>
        }

        // Check if it's a directory
        <span class="cov0" title="0">if file.IsDirectory </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Cannot download directory as file. Use directory download endpoint", nil)
                return
        }</span>

        // Check if file is deleted
        <span class="cov0" title="0">if file.Deleted </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "File has been deleted", nil)
                return
        }</span>

        // Get SMB root information
        <span class="cov0" title="0">smbRoots, err := h.fileRepo.GetStorageRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get SMB root info", err)
                return
        }</span>

        <span class="cov0" title="0">var smbRoot *models.StorageRoot
        for _, root := range smbRoots </span><span class="cov0" title="0">{
                if root.ID == file.StorageRootID </span><span class="cov0" title="0">{
                        smbRoot = &amp;root
                        break</span>
                }
        }

        <span class="cov0" title="0">if smbRoot == nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "SMB root not found", nil)
                return
        }</span>

        // Create SMB connection
        <span class="cov0" title="0">host := ""
        if smbRoot.Host != nil </span><span class="cov0" title="0">{
                host = *smbRoot.Host
        }</span>
        <span class="cov0" title="0">port := 445
        if smbRoot.Port != nil </span><span class="cov0" title="0">{
                port = *smbRoot.Port
        }</span>
        <span class="cov0" title="0">share := ""
        if smbRoot.Path != nil </span><span class="cov0" title="0">{
                share = *smbRoot.Path
        }</span>
        <span class="cov0" title="0">username := ""
        if smbRoot.Username != nil </span><span class="cov0" title="0">{
                username = *smbRoot.Username
        }</span>
        <span class="cov0" title="0">domain := ""
        if smbRoot.Domain != nil </span><span class="cov0" title="0">{
                domain = *smbRoot.Domain
        }</span>

        <span class="cov0" title="0">smbConfig := &amp;smb.SmbConfig{
                Host:     host,
                Port:     port,
                Share:    share,
                Username: username,
                Domain:   domain,
        }

        connectionKey := fmt.Sprintf("%s:%d:%s:%s", host, port, share, username)
        smbClient, err := h.smbPool.GetConnection(connectionKey, smbConfig)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to connect to SMB share", err)
                return
        }</span>

        // Open file for reading
        <span class="cov0" title="0">reader, err := smbClient.ReadFile(file.Path)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to open file", err)
                return
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        // Set headers
        inline := c.Query("inline") == "true"
        disposition := "attachment"
        if inline </span><span class="cov0" title="0">{
                disposition = "inline"
        }</span>

        <span class="cov0" title="0">c.Header("Content-Disposition", fmt.Sprintf(`%s; filename="%s"`, disposition, file.Name))
        c.Header("Content-Length", strconv.FormatInt(file.Size, 10))

        // Set content type based on file extension
        if file.MimeType != nil &amp;&amp; *file.MimeType != "" </span><span class="cov0" title="0">{
                c.Header("Content-Type", *file.MimeType)
        }</span> else<span class="cov0" title="0"> {
                c.Header("Content-Type", "application/octet-stream")
        }</span>

        // Stream file content
        <span class="cov0" title="0">c.Stream(func(w io.Writer) bool </span><span class="cov0" title="0">{
                buffer := make([]byte, h.chunkSize)
                n, err := reader.Read(buffer)
                if err != nil </span><span class="cov0" title="0">{
                        if err != io.EOF </span><span class="cov0" title="0">{
                                c.Header("X-Download-Error", err.Error())
                        }</span>
                        <span class="cov0" title="0">return false</span>
                }
                <span class="cov0" title="0">_, writeErr := w.Write(buffer[:n])
                return writeErr == nil</span>
        })
}

// DownloadDirectory godoc
// @Summary Download directory as ZIP
// @Description Download a directory and its contents as a ZIP archive
// @Tags download
// @Produce application/zip
// @Param smb_root path string true "SMB root name"
// @Param path query string true "Directory path"
// @Param recursive query bool false "Include subdirectories recursively" default(true)
// @Param max_depth query int false "Maximum recursion depth" default(-1)
// @Success 200 {file} binary
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/download/directory/{smb_root} [get]
func (h *DownloadHandler) DownloadDirectory(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Param("smb_root")
        dirPath := c.Query("path")
        recursive := c.DefaultQuery("recursive", "true") == "true"
        maxDepth, _ := strconv.Atoi(c.DefaultQuery("max_depth", "-1"))

        if dirPath == "" </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Directory path is required", nil)
                return
        }</span>

        // Get SMB root information
        <span class="cov0" title="0">smbRoots, err := h.fileRepo.GetStorageRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get SMB root info", err)
                return
        }</span>

        <span class="cov0" title="0">var smbRoot *models.StorageRoot
        for _, root := range smbRoots </span><span class="cov0" title="0">{
                if root.Name == smbRootName </span><span class="cov0" title="0">{
                        smbRoot = &amp;root
                        break</span>
                }
        }

        <span class="cov0" title="0">if smbRoot == nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "SMB root not found", nil)
                return
        }</span>

        // Create SMB connection
        <span class="cov0" title="0">host := ""
        if smbRoot.Host != nil </span><span class="cov0" title="0">{
                host = *smbRoot.Host
        }</span>
        <span class="cov0" title="0">port := 445
        if smbRoot.Port != nil </span><span class="cov0" title="0">{
                port = *smbRoot.Port
        }</span>
        <span class="cov0" title="0">share := ""
        if smbRoot.Path != nil </span><span class="cov0" title="0">{
                share = *smbRoot.Path
        }</span>
        <span class="cov0" title="0">username := ""
        if smbRoot.Username != nil </span><span class="cov0" title="0">{
                username = *smbRoot.Username
        }</span>
        <span class="cov0" title="0">domain := ""
        if smbRoot.Domain != nil </span><span class="cov0" title="0">{
                domain = *smbRoot.Domain
        }</span>

        <span class="cov0" title="0">smbConfig := &amp;smb.SmbConfig{
                Host:     host,
                Port:     port,
                Share:    share,
                Username: username,
                Domain:   domain,
        }

        connectionKey := fmt.Sprintf("%s:%d:%s:%s", host, port, share, username)
        smbClient, err := h.smbPool.GetConnection(connectionKey, smbConfig)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to connect to SMB share", err)
                return
        }</span>

        // Check if directory exists
        <span class="cov0" title="0">fileInfo, err := smbClient.GetFileInfo(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "Directory not found", err)
                return
        }</span>

        <span class="cov0" title="0">if !fileInfo.IsDir </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Path is not a directory", nil)
                return
        }</span>

        // Set headers for ZIP download
        <span class="cov0" title="0">dirName := filepath.Base(dirPath)
        if dirName == "." || dirName == "/" </span><span class="cov0" title="0">{
                dirName = "root"
        }</span>
        <span class="cov0" title="0">c.Header("Content-Type", "application/zip")
        c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s.zip"`, dirName))

        // Stream ZIP creation
        c.Stream(func(w io.Writer) bool </span><span class="cov0" title="0">{
                return h.createZipStream(ctx, w, smbClient, dirPath, recursive, maxDepth, 0)
        }</span>)
}

// createZipStream creates a ZIP archive and streams it to the writer
func (h *DownloadHandler) createZipStream(ctx context.Context, w io.Writer, smbClient *smb.SmbClient, basePath string, recursive bool, maxDepth, currentDepth int) bool <span class="cov0" title="0">{
        zipWriter := zip.NewWriter(w)
        defer zipWriter.Close()

        var totalSize int64
        err := h.addDirectoryToZip(ctx, zipWriter, smbClient, basePath, "", recursive, maxDepth, currentDepth, &amp;totalSize)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// addDirectoryToZip recursively adds directory contents to ZIP
func (h *DownloadHandler) addDirectoryToZip(ctx context.Context, zipWriter *zip.Writer, smbClient *smb.SmbClient, smbPath, zipPath string, recursive bool, maxDepth, currentDepth int, totalSize *int64) error <span class="cov0" title="0">{
        // Check context cancellation
        if ctx.Err() != nil </span><span class="cov0" title="0">{
                return ctx.Err()
        }</span>

        // Check depth limit
        <span class="cov0" title="0">if maxDepth &gt;= 0 &amp;&amp; currentDepth &gt;= maxDepth </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check size limit
        <span class="cov0" title="0">if *totalSize &gt; h.maxArchiveSize </span><span class="cov0" title="0">{
                return fmt.Errorf("archive size limit exceeded")
        }</span>

        // List directory contents
        <span class="cov0" title="0">files, err := smbClient.ListDirectory(smbPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list directory %s: %w", smbPath, err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                fullSmbPath := filepath.Join(smbPath, file.Name)
                fullZipPath := filepath.Join(zipPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        // Add directory entry
                        dirHeader := &amp;zip.FileHeader{
                                Name:     fullZipPath + "/",
                                Method:   zip.Store,
                                Modified: file.ModTime,
                        }
                        _, err := zipWriter.CreateHeader(dirHeader)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory entry %s: %w", fullZipPath, err)
                        }</span>

                        // Recursively add subdirectory if enabled
                        <span class="cov0" title="0">if recursive </span><span class="cov0" title="0">{
                                err = h.addDirectoryToZip(ctx, zipWriter, smbClient, fullSmbPath, fullZipPath, recursive, maxDepth, currentDepth+1, totalSize)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Add file
                        *totalSize += file.Size
                        if *totalSize &gt; h.maxArchiveSize </span><span class="cov0" title="0">{
                                return fmt.Errorf("archive size limit exceeded")
                        }</span>

                        <span class="cov0" title="0">fileHeader := &amp;zip.FileHeader{
                                Name:     fullZipPath,
                                Method:   zip.Deflate,
                                Modified: file.ModTime,
                        }

                        fileWriter, err := zipWriter.CreateHeader(fileHeader)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create file entry %s: %w", fullZipPath, err)
                        }</span>

                        // Read and copy file content
                        <span class="cov0" title="0">fileReader, err := smbClient.ReadFile(fullSmbPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to read file %s: %w", fullSmbPath, err)
                        }</span>

                        <span class="cov0" title="0">_, err = io.Copy(fileWriter, fileReader)
                        fileReader.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to copy file %s: %w", fullSmbPath, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetDownloadInfo godoc
// @Summary Get download information
// @Description Get information about a file or directory before downloading
// @Tags download
// @Accept json
// @Produce json
// @Param id path int true "File ID"
// @Success 200 {object} DownloadInfo
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/download/info/{id} [get]
func (h *DownloadHandler) GetDownloadInfo(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        // Parse file ID
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid file ID", err)
                return
        }</span>

        // Get file information
        <span class="cov0" title="0">file, err := h.fileRepo.GetFileByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "file not found" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusNotFound, "File not found", err)
                        return
                }</span>
                <span class="cov0" title="0">utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get file info", err)
                return</span>
        }

        <span class="cov0" title="0">info := DownloadInfo{
                FileID:      file.ID,
                Name:        file.Name,
                Path:        file.Path,
                Size:        file.Size,
                IsDirectory: file.IsDirectory,
                MimeType:    file.MimeType,
                Extension:   file.Extension,
                ModifiedAt:  file.ModifiedAt,
                Deleted:     file.Deleted,
        }

        if file.IsDirectory </span><span class="cov0" title="0">{
                // For directories, we might want to calculate total size
                // This is a simplified version - in practice you might want to cache this
                info.EstimatedArchiveSize = file.Size // Placeholder
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    info,
        })</span>
}

// DownloadInfo represents download information
type DownloadInfo struct {
        FileID               int64     `json:"file_id"`
        Name                 string    `json:"name"`
        Path                 string    `json:"path"`
        Size                 int64     `json:"size"`
        IsDirectory          bool      `json:"is_directory"`
        MimeType             *string   `json:"mime_type"`
        Extension            *string   `json:"extension"`
        ModifiedAt           time.Time `json:"modified_at"`
        Deleted              bool      `json:"deleted"`
        EstimatedArchiveSize int64     `json:"estimated_archive_size,omitempty"`
}

// Close closes the download handler and its resources
func (h *DownloadHandler) Close() <span class="cov0" title="0">{
        h.smbPool.CloseAll()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "time"

        "catalogizer/models"
        "catalogizer/services"

        "github.com/gorilla/mux"
)

type ErrorReportingHandler struct {
        errorReportingService *services.ErrorReportingService
        authService           *services.AuthService
}

func NewErrorReportingHandler(errorReportingService *services.ErrorReportingService, authService *services.AuthService) *ErrorReportingHandler <span class="cov0" title="0">{
        return &amp;ErrorReportingHandler{
                errorReportingService: errorReportingService,
                authService:           authService,
        }
}</span>

func (h *ErrorReportingHandler) ReportError(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportCreate)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request models.ErrorReportRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">report, err := h.errorReportingService.ReportError(userID, &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(report)</span>
}

func (h *ErrorReportingHandler) ReportCrash(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportCreate)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request models.CrashReportRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">report, err := h.errorReportingService.ReportCrash(userID, &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(report)</span>
}

func (h *ErrorReportingHandler) GetErrorReport(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        reportID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid report ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">report, err := h.errorReportingService.GetErrorReport(reportID, userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(report)</span>
}

func (h *ErrorReportingHandler) GetCrashReport(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        reportID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid report ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">report, err := h.errorReportingService.GetCrashReport(reportID, userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(report)</span>
}

func (h *ErrorReportingHandler) ListErrorReports(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">filters := h.parseErrorReportFilters(r)
        reports, err := h.errorReportingService.GetErrorReportsByUser(userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "reports": reports,
                "filters": filters,
        })</span>
}

func (h *ErrorReportingHandler) ListCrashReports(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">filters := h.parseCrashReportFilters(r)
        reports, err := h.errorReportingService.GetCrashReportsByUser(userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "reports": reports,
                "filters": filters,
        })</span>
}

func (h *ErrorReportingHandler) UpdateErrorStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        reportID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid report ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportCreate)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request struct {
                Status string `json:"status"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.errorReportingService.UpdateErrorStatus(reportID, userID, request.Status)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *ErrorReportingHandler) UpdateCrashStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        reportID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid report ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportCreate)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request struct {
                Status string `json:"status"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.errorReportingService.UpdateCrashStatus(reportID, userID, request.Status)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *ErrorReportingHandler) GetErrorStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.errorReportingService.GetErrorStatistics(userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

func (h *ErrorReportingHandler) GetCrashStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.errorReportingService.GetCrashStatistics(userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

func (h *ErrorReportingHandler) GetSystemHealth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">health, err := h.errorReportingService.GetSystemHealth()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(health)</span>
}

func (h *ErrorReportingHandler) UpdateConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var config services.ErrorReportingConfig
        if err := json.NewDecoder(r.Body).Decode(&amp;config); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.errorReportingService.UpdateConfiguration(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "message": "Configuration updated successfully",
        })</span>
}

func (h *ErrorReportingHandler) GetConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">config := h.errorReportingService.GetConfiguration()

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(config)</span>
}

func (h *ErrorReportingHandler) CleanupOldReports(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request struct {
                DaysOld int `json:"days_old"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if request.DaysOld &lt;= 0 </span><span class="cov0" title="0">{
                request.DaysOld = 30 // Default to 30 days
        }</span>

        <span class="cov0" title="0">olderThan := time.Now().AddDate(0, 0, -request.DaysOld)
        err = h.errorReportingService.CleanupOldReports(olderThan)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "message": "Cleanup completed successfully",
        })</span>
}

func (h *ErrorReportingHandler) ExportReports(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">filters := h.parseExportFilters(r)
        data, err := h.errorReportingService.ExportReports(userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Set appropriate content type and headers
        <span class="cov0" title="0">switch filters.Format </span>{
        case "json":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "application/json")
                w.Header().Set("Content-Disposition", "attachment; filename=error_reports.json")</span>
        case "csv":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "text/csv")
                w.Header().Set("Content-Disposition", "attachment; filename=error_reports.csv")</span>
        default:<span class="cov0" title="0">
                w.Header().Set("Content-Type", "application/octet-stream")
                w.Header().Set("Content-Disposition", "attachment; filename=error_reports.txt")</span>
        }

        <span class="cov0" title="0">w.Write(data)</span>
}

// Helper methods

func (h *ErrorReportingHandler) parseErrorReportFilters(r *http.Request) *models.ErrorReportFilters <span class="cov0" title="0">{
        filters := &amp;models.ErrorReportFilters{}

        if level := r.URL.Query().Get("level"); level != "" </span><span class="cov0" title="0">{
                filters.Level = level
        }</span>

        <span class="cov0" title="0">if component := r.URL.Query().Get("component"); component != "" </span><span class="cov0" title="0">{
                filters.Component = component
        }</span>

        <span class="cov0" title="0">if status := r.URL.Query().Get("status"); status != "" </span><span class="cov0" title="0">{
                filters.Status = status
        }</span>

        <span class="cov0" title="0">if startDate := r.URL.Query().Get("start_date"); startDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", startDate); err == nil </span><span class="cov0" title="0">{
                        filters.StartDate = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if endDate := r.URL.Query().Get("end_date"); endDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", endDate); err == nil </span><span class="cov0" title="0">{
                        filters.EndDate = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limit &gt; 0 </span><span class="cov0" title="0">{
                        filters.Limit = limit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if offset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; offset &gt;= 0 </span><span class="cov0" title="0">{
                        filters.Offset = offset
                }</span>
        }

        <span class="cov0" title="0">return filters</span>
}

func (h *ErrorReportingHandler) parseCrashReportFilters(r *http.Request) *models.CrashReportFilters <span class="cov0" title="0">{
        filters := &amp;models.CrashReportFilters{}

        if signal := r.URL.Query().Get("signal"); signal != "" </span><span class="cov0" title="0">{
                filters.Signal = signal
        }</span>

        <span class="cov0" title="0">if status := r.URL.Query().Get("status"); status != "" </span><span class="cov0" title="0">{
                filters.Status = status
        }</span>

        <span class="cov0" title="0">if startDate := r.URL.Query().Get("start_date"); startDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", startDate); err == nil </span><span class="cov0" title="0">{
                        filters.StartDate = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if endDate := r.URL.Query().Get("end_date"); endDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", endDate); err == nil </span><span class="cov0" title="0">{
                        filters.EndDate = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limit &gt; 0 </span><span class="cov0" title="0">{
                        filters.Limit = limit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if offset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; offset &gt;= 0 </span><span class="cov0" title="0">{
                        filters.Offset = offset
                }</span>
        }

        <span class="cov0" title="0">return filters</span>
}

func (h *ErrorReportingHandler) parseExportFilters(r *http.Request) *models.ExportFilters <span class="cov0" title="0">{
        filters := &amp;models.ExportFilters{
                Format:         "json", // Default format
                IncludeErrors:  true,   // Default to include errors
                IncludeCrashes: true,   // Default to include crashes
        }

        if format := r.URL.Query().Get("format"); format != "" </span><span class="cov0" title="0">{
                filters.Format = format
        }</span>

        <span class="cov0" title="0">if level := r.URL.Query().Get("level"); level != "" </span><span class="cov0" title="0">{
                filters.Level = level
        }</span>

        <span class="cov0" title="0">if component := r.URL.Query().Get("component"); component != "" </span><span class="cov0" title="0">{
                filters.Component = component
        }</span>

        <span class="cov0" title="0">if signal := r.URL.Query().Get("signal"); signal != "" </span><span class="cov0" title="0">{
                filters.Signal = signal
        }</span>

        <span class="cov0" title="0">if startDate := r.URL.Query().Get("start_date"); startDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", startDate); err == nil </span><span class="cov0" title="0">{
                        filters.StartDate = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if endDate := r.URL.Query().Get("end_date"); endDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", endDate); err == nil </span><span class="cov0" title="0">{
                        filters.EndDate = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limit &gt; 0 </span><span class="cov0" title="0">{
                        filters.Limit = limit
                }</span>
        }

        <span class="cov0" title="0">if includeErrors := r.URL.Query().Get("include_errors"); includeErrors == "false" </span><span class="cov0" title="0">{
                filters.IncludeErrors = false
        }</span>

        <span class="cov0" title="0">if includeCrashes := r.URL.Query().Get("include_crashes"); includeCrashes == "false" </span><span class="cov0" title="0">{
                filters.IncludeCrashes = false
        }</span>

        <span class="cov0" title="0">return filters</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "time"

        "catalogizer/models"
        "catalogizer/services"

        "github.com/gorilla/mux"
)

type LogManagementHandler struct {
        logManagementService *services.LogManagementService
        authService          *services.AuthService
}

func NewLogManagementHandler(logManagementService *services.LogManagementService, authService *services.AuthService) *LogManagementHandler <span class="cov0" title="0">{
        return &amp;LogManagementHandler{
                logManagementService: logManagementService,
                authService:          authService,
        }
}</span>

func (h *LogManagementHandler) CreateLogCollection(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request models.LogCollectionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">collection, err := h.logManagementService.CollectLogs(userID, &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(collection)</span>
}

func (h *LogManagementHandler) GetLogCollection(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        collectionID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid collection ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">collection, err := h.logManagementService.GetLogCollection(collectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(collection)</span>
}

func (h *LogManagementHandler) ListLogCollections(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")

        limit := 20 // Default limit
        offset := 0 // Default offset

        if limitStr != "" </span><span class="cov0" title="0">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 </span><span class="cov0" title="0">{
                        limit = parsedLimit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if parsedOffset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; parsedOffset &gt;= 0 </span><span class="cov0" title="0">{
                        offset = parsedOffset
                }</span>
        }

        <span class="cov0" title="0">collections, err := h.logManagementService.GetLogCollectionsByUser(userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "collections": collections,
                "limit":       limit,
                "offset":      offset,
        })</span>
}

func (h *LogManagementHandler) GetLogEntries(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        collectionID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid collection ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">filters := h.parseLogEntryFilters(r)
        entries, err := h.logManagementService.GetLogEntries(collectionID, userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "entries": entries,
                "filters": filters,
        })</span>
}

func (h *LogManagementHandler) CreateLogShare(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request models.LogShareRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">share, err := h.logManagementService.CreateLogShare(userID, &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(share)</span>
}

func (h *LogManagementHandler) GetLogShare(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        token := vars["token"]

        share, err := h.logManagementService.GetLogShare(token)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        // Get the collection
        <span class="cov0" title="0">collection, err := h.logManagementService.GetLogCollection(share.CollectionID, share.UserID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        // Check permissions
        <span class="cov0" title="0">canRead := false
        for _, permission := range share.Permissions </span><span class="cov0" title="0">{
                if permission == "read" </span><span class="cov0" title="0">{
                        canRead = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !canRead </span><span class="cov0" title="0">{
                http.Error(w, "Access denied", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "share":      share,
                "collection": collection,
        })</span>
}

func (h *LogManagementHandler) RevokeLogShare(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        shareID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid share ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">err = h.logManagementService.RevokeLogShare(shareID, userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *LogManagementHandler) ExportLogs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        collectionID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid collection ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">format := r.URL.Query().Get("format")
        if format == "" </span><span class="cov0" title="0">{
                format = "json" // Default format
        }</span>

        <span class="cov0" title="0">data, err := h.logManagementService.ExportLogs(collectionID, userID, format)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Set appropriate content type and headers
        <span class="cov0" title="0">switch format </span>{
        case "json":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "application/json")
                w.Header().Set("Content-Disposition", "attachment; filename=logs.json")</span>
        case "csv":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "text/csv")
                w.Header().Set("Content-Disposition", "attachment; filename=logs.csv")</span>
        case "txt":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "text/plain")
                w.Header().Set("Content-Disposition", "attachment; filename=logs.txt")</span>
        case "zip":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "application/zip")
                w.Header().Set("Content-Disposition", "attachment; filename=logs.zip")</span>
        default:<span class="cov0" title="0">
                w.Header().Set("Content-Type", "application/octet-stream")
                w.Header().Set("Content-Disposition", "attachment; filename=logs.bin")</span>
        }

        <span class="cov0" title="0">w.Write(data)</span>
}

func (h *LogManagementHandler) StreamLogs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        // Parse stream filters
        <span class="cov0" title="0">filters := h.parseLogStreamFilters(r)

        // Setup Server-Sent Events
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        w.Header().Set("Access-Control-Allow-Origin", "*")

        // Get log stream
        logChannel, err := h.logManagementService.StreamLogs(userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Stream logs to client
        <span class="cov0" title="0">flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Streaming not supported", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case entry, ok := &lt;-logChannel:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">data, err := json.Marshal(entry)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">w.Write([]byte("data: "))
                        w.Write(data)
                        w.Write([]byte("\n\n"))
                        flusher.Flush()</span>

                case &lt;-r.Context().Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (h *LogManagementHandler) AnalyzeLogs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        collectionID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid collection ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">analysis, err := h.logManagementService.AnalyzeLogs(collectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(analysis)</span>
}

func (h *LogManagementHandler) GetLogStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.logManagementService.GetLogStatistics(userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

func (h *LogManagementHandler) GetConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">config := h.logManagementService.GetConfiguration()

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(config)</span>
}

func (h *LogManagementHandler) UpdateConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var config services.LogManagementConfig
        if err := json.NewDecoder(r.Body).Decode(&amp;config); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.logManagementService.UpdateConfiguration(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "message": "Configuration updated successfully",
        })</span>
}

func (h *LogManagementHandler) CleanupOldLogs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">err = h.logManagementService.CleanupOldLogs()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "message": "Cleanup completed successfully",
        })</span>
}

// Helper methods

func (h *LogManagementHandler) parseLogEntryFilters(r *http.Request) *models.LogEntryFilters <span class="cov0" title="0">{
        filters := &amp;models.LogEntryFilters{}

        if level := r.URL.Query().Get("level"); level != "" </span><span class="cov0" title="0">{
                filters.Level = level
        }</span>

        <span class="cov0" title="0">if component := r.URL.Query().Get("component"); component != "" </span><span class="cov0" title="0">{
                filters.Component = component
        }</span>

        <span class="cov0" title="0">if search := r.URL.Query().Get("search"); search != "" </span><span class="cov0" title="0">{
                filters.Search = search
        }</span>

        <span class="cov0" title="0">if startTime := r.URL.Query().Get("start_time"); startTime != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse(time.RFC3339, startTime); err == nil </span><span class="cov0" title="0">{
                        filters.StartTime = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if endTime := r.URL.Query().Get("end_time"); endTime != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse(time.RFC3339, endTime); err == nil </span><span class="cov0" title="0">{
                        filters.EndTime = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limit &gt; 0 </span><span class="cov0" title="0">{
                        filters.Limit = limit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if offset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; offset &gt;= 0 </span><span class="cov0" title="0">{
                        filters.Offset = offset
                }</span>
        }

        <span class="cov0" title="0">return filters</span>
}

func (h *LogManagementHandler) parseLogStreamFilters(r *http.Request) *models.LogStreamFilters <span class="cov0" title="0">{
        filters := &amp;models.LogStreamFilters{}

        if level := r.URL.Query().Get("level"); level != "" </span><span class="cov0" title="0">{
                filters.Level = level
        }</span>

        <span class="cov0" title="0">if component := r.URL.Query().Get("component"); component != "" </span><span class="cov0" title="0">{
                filters.Component = component
        }</span>

        <span class="cov0" title="0">if search := r.URL.Query().Get("search"); search != "" </span><span class="cov0" title="0">{
                filters.Search = search
        }</span>

        <span class="cov0" title="0">return filters</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "strings"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/services"
)

type RoleHandler struct {
        userRepo    *repository.UserRepository
        authService *services.AuthService
}

func NewRoleHandler(userRepo *repository.UserRepository, authService *services.AuthService) *RoleHandler <span class="cov0" title="0">{
        return &amp;RoleHandler{
                userRepo:    userRepo,
                authService: authService,
        }
}</span>

func (h *RoleHandler) CreateRole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateRoleRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">role := &amp;models.Role{
                Name:        req.Name,
                Description: req.Description,
                Permissions: req.Permissions,
                IsSystem:    false,
        }

        id, err := h.userRepo.CreateRole(role)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "UNIQUE constraint failed") </span><span class="cov0" title="0">{
                        http.Error(w, "Role name already exists", http.StatusConflict)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to create role", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">role.ID = id

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(role)</span>
}

func (h *RoleHandler) GetRole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">roleIDStr := strings.TrimPrefix(r.URL.Path, "/api/roles/")
        roleID, err := strconv.Atoi(roleIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid role ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">role, err := h.userRepo.GetRole(roleID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        http.Error(w, "Role not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to get role", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(role)</span>
}

func (h *RoleHandler) UpdateRole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPut </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">roleIDStr := strings.TrimPrefix(r.URL.Path, "/api/roles/")
        roleID, err := strconv.Atoi(roleIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid role ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateRoleRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">role := &amp;models.Role{
                ID:          roleID,
                Name:        *req.Name,
                Description: req.Description,
                Permissions: req.Permissions,
        }

        err = h.userRepo.UpdateRole(role)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "system role") </span><span class="cov0" title="0">{
                        http.Error(w, "Role not found or is system role", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "UNIQUE constraint failed") </span><span class="cov0" title="0">{
                        http.Error(w, "Role name already exists", http.StatusConflict)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to update role", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">updatedRole, err := h.userRepo.GetRole(roleID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get updated role", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(updatedRole)</span>
}

func (h *RoleHandler) DeleteRole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodDelete </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">roleIDStr := strings.TrimPrefix(r.URL.Path, "/api/roles/")
        roleID, err := strconv.Atoi(roleIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid role ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.userRepo.DeleteRole(roleID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "system role") </span><span class="cov0" title="0">{
                        http.Error(w, "Role not found or is system role", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "assigned to users") </span><span class="cov0" title="0">{
                        http.Error(w, "Cannot delete role that is assigned to users", http.StatusConflict)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to delete role", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *RoleHandler) ListRoles(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">roles, err := h.userRepo.ListRoles()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to list roles", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(roles)</span>
}

func (h *RoleHandler) GetPermissions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">permissions := map[string]interface{}{
                "user_management": map[string]string{
                        "create_user":  models.PermissionUserCreate,
                        "view_user":    models.PermissionUserView,
                        "edit_user":    models.PermissionUserUpdate,
                        "delete_user":  models.PermissionUserDelete,
                        "manage_users": models.PermissionUserManage,
                },
                "role_management": map[string]string{
                        "view_roles":   models.PermissionSystemAdmin,
                        "manage_roles": models.PermissionSystemAdmin,
                },
                "media_management": map[string]string{
                        "view_media":   models.PermissionMediaView,
                        "upload_media": models.PermissionMediaUpload,
                        "edit_media":   models.PermissionMediaEdit,
                        "delete_media": models.PermissionMediaDelete,
                },
                "share_management": map[string]string{
                        "view_shares":   models.PermissionShareView,
                        "create_shares": models.PermissionShareCreate,
                        "edit_shares":   models.PermissionShareEdit,
                        "delete_shares": models.PermissionShareDelete,
                },
                "system": map[string]string{
                        "system_admin":    models.PermissionSystemAdmin,
                        "view_analytics":  models.PermissionAnalyticsView,
                        "export_data":     models.PermissionAnalyticsExport,
                        "manage_settings": models.PermissionSystemConfig,
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(permissions)</span>
}

func (h *RoleHandler) getCurrentUser(r *http.Request) (*models.User, error) <span class="cov0" title="0">{
        token := extractToken(r)
        if token == "" </span><span class="cov0" title="0">{
                return nil, models.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return h.authService.GetCurrentUser(token)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handlers

import (
        "net/http"
        "strconv"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/utils"

        "github.com/gin-gonic/gin"
)

// SearchHandler handles search operations
type SearchHandler struct {
        fileRepo *repository.FileRepository
}

// NewSearchHandler creates a new search handler
func NewSearchHandler(fileRepo *repository.FileRepository) *SearchHandler <span class="cov0" title="0">{
        return &amp;SearchHandler{
                fileRepo: fileRepo,
        }
}</span>

// SearchFiles godoc
// @Summary Search files
// @Description Perform advanced file search with filters and sorting
// @Tags search
// @Accept json
// @Produce json
// @Param q query string false "Search query (searches in filename and path)"
// @Param path query string false "Path filter (partial match)"
// @Param name query string false "Name filter (partial match)"
// @Param extension query string false "File extension filter (exact match)"
// @Param file_type query string false "File type filter (exact match)"
// @Param mime_type query string false "MIME type filter (exact match)"
// @Param smb_roots query string false "SMB roots filter (comma-separated list)"
// @Param min_size query int false "Minimum file size in bytes"
// @Param max_size query int false "Maximum file size in bytes"
// @Param modified_after query string false "Modified after date (RFC3339 format)"
// @Param modified_before query string false "Modified before date (RFC3339 format)"
// @Param include_deleted query bool false "Include deleted files" default(false)
// @Param only_duplicates query bool false "Only show duplicate files" default(false)
// @Param exclude_duplicates query bool false "Exclude duplicate files" default(false)
// @Param include_directories query bool false "Include directories" default(true)
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(100)
// @Param sort_by query string false "Sort field (name, size, modified_at, created_at, path, extension)" default("name")
// @Param sort_order query string false "Sort order (asc, desc)" default("asc")
// @Success 200 {object} models.SearchResult
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/search [get]
func (h *SearchHandler) SearchFiles(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        // Parse search filters
        filter := models.SearchFilter{
                Query:              c.Query("q"),
                Path:               c.Query("path"),
                Name:               c.Query("name"),
                Extension:          c.Query("extension"),
                FileType:           c.Query("file_type"),
                MimeType:           c.Query("mime_type"),
                IncludeDeleted:     parseBool(c.Query("include_deleted"), false),
                OnlyDuplicates:     parseBool(c.Query("only_duplicates"), false),
                ExcludeDuplicates:  parseBool(c.Query("exclude_duplicates"), false),
                IncludeDirectories: parseBool(c.Query("include_directories"), true),
        }

        // Parse SMB roots filter
        if smbRootsStr := c.Query("smb_roots"); smbRootsStr != "" </span><span class="cov0" title="0">{
                filter.StorageRoots = strings.Split(smbRootsStr, ",")
                // Trim whitespace from each root name
                for i := range filter.StorageRoots </span><span class="cov0" title="0">{
                        filter.StorageRoots[i] = strings.TrimSpace(filter.StorageRoots[i])
                }</span>
        }

        // Parse size filters
        <span class="cov0" title="0">if minSizeStr := c.Query("min_size"); minSizeStr != "" </span><span class="cov0" title="0">{
                if minSize, err := strconv.ParseInt(minSizeStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        filter.MinSize = &amp;minSize
                }</span>
        }
        <span class="cov0" title="0">if maxSizeStr := c.Query("max_size"); maxSizeStr != "" </span><span class="cov0" title="0">{
                if maxSize, err := strconv.ParseInt(maxSizeStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        filter.MaxSize = &amp;maxSize
                }</span>
        }

        // Parse date filters
        <span class="cov0" title="0">if modifiedAfterStr := c.Query("modified_after"); modifiedAfterStr != "" </span><span class="cov0" title="0">{
                if modifiedAfter, err := time.Parse(time.RFC3339, modifiedAfterStr); err == nil </span><span class="cov0" title="0">{
                        filter.ModifiedAfter = &amp;modifiedAfter
                }</span> else<span class="cov0" title="0"> {
                        utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid modified_after date format. Use RFC3339 format", err)
                        return
                }</span>
        }
        <span class="cov0" title="0">if modifiedBeforeStr := c.Query("modified_before"); modifiedBeforeStr != "" </span><span class="cov0" title="0">{
                if modifiedBefore, err := time.Parse(time.RFC3339, modifiedBeforeStr); err == nil </span><span class="cov0" title="0">{
                        filter.ModifiedBefore = &amp;modifiedBefore
                }</span> else<span class="cov0" title="0"> {
                        utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid modified_before date format. Use RFC3339 format", err)
                        return
                }</span>
        }

        // Parse pagination
        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "100"))
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit &lt; 1 || limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">pagination := models.PaginationOptions{
                Page:  page,
                Limit: limit,
        }

        // Parse sorting
        sortBy := c.DefaultQuery("sort_by", "name")
        sortOrder := c.DefaultQuery("sort_order", "asc")

        validSortFields := map[string]bool{
                "name":        true,
                "size":        true,
                "modified_at": true,
                "created_at":  true,
                "path":        true,
                "extension":   true,
        }
        if !validSortFields[sortBy] </span><span class="cov0" title="0">{
                sortBy = "name"
        }</span>
        <span class="cov0" title="0">if sortOrder != "asc" &amp;&amp; sortOrder != "desc" </span><span class="cov0" title="0">{
                sortOrder = "asc"
        }</span>

        <span class="cov0" title="0">sort := models.SortOptions{
                Field: sortBy,
                Order: sortOrder,
        }

        // Perform search
        result, err := h.fileRepo.SearchFiles(ctx, filter, pagination, sort)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Search failed", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// SearchDuplicates godoc
// @Summary Search duplicate files
// @Description Find duplicate files across all SMB roots or within specific roots
// @Tags search
// @Accept json
// @Produce json
// @Param smb_roots query string false "SMB roots filter (comma-separated list)"
// @Param min_size query int false "Minimum file size in bytes"
// @Param max_size query int false "Maximum file size in bytes"
// @Param file_type query string false "File type filter"
// @Param extension query string false "File extension filter"
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(100)
// @Param sort_by query string false "Sort field (name, size, modified_at, path)" default("name")
// @Param sort_order query string false "Sort order (asc, desc)" default("asc")
// @Success 200 {object} models.SearchResult
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/search/duplicates [get]
func (h *SearchHandler) SearchDuplicates(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        // Create search filter for duplicates only
        filter := models.SearchFilter{
                OnlyDuplicates:     true,
                IncludeDirectories: false, // Duplicates only apply to files
                FileType:           c.Query("file_type"),
                Extension:          c.Query("extension"),
        }

        // Parse SMB roots filter
        if smbRootsStr := c.Query("smb_roots"); smbRootsStr != "" </span><span class="cov0" title="0">{
                filter.StorageRoots = strings.Split(smbRootsStr, ",")
                for i := range filter.StorageRoots </span><span class="cov0" title="0">{
                        filter.StorageRoots[i] = strings.TrimSpace(filter.StorageRoots[i])
                }</span>
        }

        // Parse size filters
        <span class="cov0" title="0">if minSizeStr := c.Query("min_size"); minSizeStr != "" </span><span class="cov0" title="0">{
                if minSize, err := strconv.ParseInt(minSizeStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        filter.MinSize = &amp;minSize
                }</span>
        }
        <span class="cov0" title="0">if maxSizeStr := c.Query("max_size"); maxSizeStr != "" </span><span class="cov0" title="0">{
                if maxSize, err := strconv.ParseInt(maxSizeStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        filter.MaxSize = &amp;maxSize
                }</span>
        }

        // Parse pagination
        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "100"))
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit &lt; 1 || limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">pagination := models.PaginationOptions{
                Page:  page,
                Limit: limit,
        }

        // Parse sorting
        sortBy := c.DefaultQuery("sort_by", "name")
        sortOrder := c.DefaultQuery("sort_order", "asc")

        validSortFields := map[string]bool{
                "name":        true,
                "size":        true,
                "modified_at": true,
                "path":        true,
        }
        if !validSortFields[sortBy] </span><span class="cov0" title="0">{
                sortBy = "name"
        }</span>
        <span class="cov0" title="0">if sortOrder != "asc" &amp;&amp; sortOrder != "desc" </span><span class="cov0" title="0">{
                sortOrder = "asc"
        }</span>

        <span class="cov0" title="0">sort := models.SortOptions{
                Field: sortBy,
                Order: sortOrder,
        }

        // Perform search
        result, err := h.fileRepo.SearchFiles(ctx, filter, pagination, sort)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Duplicate search failed", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// AdvancedSearch godoc
// @Summary Advanced search with POST body
// @Description Perform advanced file search using POST body for complex filters
// @Tags search
// @Accept json
// @Produce json
// @Param body body SearchRequest true "Search request"
// @Success 200 {object} models.SearchResult
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/search/advanced [post]
func (h *SearchHandler) AdvancedSearch(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        var req SearchRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        // Validate pagination
        <span class="cov0" title="0">if req.Page &lt; 1 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.Limit &lt; 1 || req.Limit &gt; 1000 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate sorting
        <span class="cov0" title="0">validSortFields := map[string]bool{
                "name":        true,
                "size":        true,
                "modified_at": true,
                "created_at":  true,
                "path":        true,
                "extension":   true,
        }
        if !validSortFields[req.SortBy] </span><span class="cov0" title="0">{
                req.SortBy = "name"
        }</span>
        <span class="cov0" title="0">if req.SortOrder != "asc" &amp;&amp; req.SortOrder != "desc" </span><span class="cov0" title="0">{
                req.SortOrder = "asc"
        }</span>

        <span class="cov0" title="0">pagination := models.PaginationOptions{
                Page:  req.Page,
                Limit: req.Limit,
        }

        sort := models.SortOptions{
                Field: req.SortBy,
                Order: req.SortOrder,
        }

        // Perform search
        result, err := h.fileRepo.SearchFiles(ctx, req.Filter, pagination, sort)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Advanced search failed", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// SearchRequest represents the request body for advanced search
type SearchRequest struct {
        Filter    models.SearchFilter `json:"filter"`
        Page      int                 `json:"page"`
        Limit     int                 `json:"limit"`
        SortBy    string              `json:"sort_by"`
        SortOrder string              `json:"sort_order"`
}

// Helper function to parse boolean query parameters
func parseBool(value string, defaultValue bool) bool <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">result, err := strconv.ParseBool(value)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "catalogizer/internal/models"
        "catalogizer/repository"
        "catalogizer/utils"

        "github.com/gin-gonic/gin"
)

// StatsHandler handles statistics and analytics operations
type StatsHandler struct {
        fileRepo  *repository.FileRepository
        statsRepo *repository.StatsRepository
}

// NewStatsHandler creates a new stats handler
func NewStatsHandler(fileRepo *repository.FileRepository, statsRepo *repository.StatsRepository) *StatsHandler <span class="cov0" title="0">{
        return &amp;StatsHandler{
                fileRepo:  fileRepo,
                statsRepo: statsRepo,
        }
}</span>

// GetOverallStats godoc
// @Summary Get overall catalog statistics
// @Description Get comprehensive statistics about the entire catalog
// @Tags stats
// @Accept json
// @Produce json
// @Success 200 {object} OverallStats
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/overall [get]
func (h *StatsHandler) GetOverallStats(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        stats, err := h.statsRepo.GetOverallStats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get overall stats", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    stats,
        })</span>
}

// GetSmbRootStats godoc
// @Summary Get SMB root statistics
// @Description Get statistics for a specific SMB root
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root path string true "SMB root name"
// @Success 200 {object} SmbRootStats
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/smb/{smb_root} [get]
func (h *StatsHandler) GetSmbRootStats(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Param("smb_root")
        if smbRootName == "" </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "SMB root name is required", nil)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.statsRepo.GetStorageRootStats(ctx, smbRootName)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "smb root not found" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusNotFound, "SMB root not found", err)
                        return
                }</span>
                <span class="cov0" title="0">utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get SMB root stats", err)
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    stats,
        })</span>
}

// GetFileTypeStats godoc
// @Summary Get file type statistics
// @Description Get statistics about different file types across all or specific SMB roots
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root query string false "SMB root name filter"
// @Param limit query int false "Maximum number of results" default(50)
// @Success 200 {array} FileTypeStats
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/filetypes [get]
func (h *StatsHandler) GetFileTypeStats(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Query("smb_root")
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))

        if limit &lt;= 0 || limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">stats, err := h.statsRepo.GetFileTypeStats(ctx, smbRootName, limit)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get file type stats", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    stats,
        })</span>
}

// GetSizeDistribution godoc
// @Summary Get file size distribution
// @Description Get statistics about file size distribution
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root query string false "SMB root name filter"
// @Success 200 {object} SizeDistribution
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/sizes [get]
func (h *StatsHandler) GetSizeDistribution(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Query("smb_root")

        distribution, err := h.statsRepo.GetSizeDistribution(ctx, smbRootName)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get size distribution", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    distribution,
        })</span>
}

// GetDuplicateStats godoc
// @Summary Get duplicate file statistics
// @Description Get statistics about duplicate files
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root query string false "SMB root name filter"
// @Success 200 {object} DuplicateStats
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/duplicates [get]
func (h *StatsHandler) GetDuplicateStats(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Query("smb_root")

        stats, err := h.statsRepo.GetDuplicateStats(ctx, smbRootName)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get duplicate stats", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    stats,
        })</span>
}

// GetTopDuplicateGroups godoc
// @Summary Get top duplicate groups
// @Description Get the largest duplicate groups by file count or total size
// @Tags stats
// @Accept json
// @Produce json
// @Param sort_by query string false "Sort by: count or size" default("count")
// @Param limit query int false "Maximum number of results" default(20)
// @Param smb_root query string false "SMB root name filter"
// @Success 200 {array} DuplicateGroupStats
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/duplicates/groups [get]
func (h *StatsHandler) GetTopDuplicateGroups(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        sortBy := c.DefaultQuery("sort_by", "count")
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        smbRootName := c.Query("smb_root")

        if sortBy != "count" &amp;&amp; sortBy != "size" </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "sort_by must be 'count' or 'size'", nil)
                return
        }</span>

        <span class="cov0" title="0">if limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">groups, err := h.statsRepo.GetTopDuplicateGroups(ctx, sortBy, limit, smbRootName)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get top duplicate groups", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    groups,
        })</span>
}

// GetAccessPatterns godoc
// @Summary Get file access patterns
// @Description Get statistics about file access patterns over time
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root query string false "SMB root name filter"
// @Param days query int false "Number of days to analyze" default(30)
// @Success 200 {object} AccessPatterns
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/access [get]
func (h *StatsHandler) GetAccessPatterns(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Query("smb_root")
        days, _ := strconv.Atoi(c.DefaultQuery("days", "30"))

        if days &lt;= 0 || days &gt; 365 </span><span class="cov0" title="0">{
                days = 30
        }</span>

        <span class="cov0" title="0">patterns, err := h.statsRepo.GetAccessPatterns(ctx, smbRootName, days)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get access patterns", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    patterns,
        })</span>
}

// GetGrowthTrends godoc
// @Summary Get storage growth trends
// @Description Get statistics about storage growth over time
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root query string false "SMB root name filter"
// @Param months query int false "Number of months to analyze" default(12)
// @Success 200 {object} GrowthTrends
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/growth [get]
func (h *StatsHandler) GetGrowthTrends(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Query("smb_root")
        months, _ := strconv.Atoi(c.DefaultQuery("months", "12"))

        if months &lt;= 0 || months &gt; 60 </span><span class="cov0" title="0">{
                months = 12
        }</span>

        <span class="cov0" title="0">trends, err := h.statsRepo.GetGrowthTrends(ctx, smbRootName, months)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get growth trends", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    trends,
        })</span>
}

// GetScanHistory godoc
// @Summary Get scan history
// @Description Get history of scan operations
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root query string false "SMB root name filter"
// @Param limit query int false "Maximum number of results" default(50)
// @Param offset query int false "Number of results to skip" default(0)
// @Success 200 {object} ScanHistoryResponse
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/scans [get]
func (h *StatsHandler) GetScanHistory(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Query("smb_root")
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        if limit &lt;= 0 || limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">history, totalCount, err := h.statsRepo.GetScanHistory(ctx, smbRootName, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get scan history", err)
                return
        }</span>

        <span class="cov0" title="0">response := ScanHistoryResponse{
                Scans:      history,
                TotalCount: totalCount,
                Limit:      limit,
                Offset:     offset,
        }

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    response,
        })</span>
}

// Response types for statistics endpoints
type ScanHistoryResponse struct {
        Scans      []models.ScanHistoryItem `json:"scans"`
        TotalCount int64                    `json:"total_count"`
        Limit      int                      `json:"limit"`
        Offset     int                      `json:"offset"`
}

// These types would typically be defined in a separate stats models package
type OverallStats struct {
        TotalFiles         int64 `json:"total_files"`
        TotalDirectories   int64 `json:"total_directories"`
        TotalSize          int64 `json:"total_size"`
        TotalDuplicates    int64 `json:"total_duplicates"`
        DuplicateGroups    int64 `json:"duplicate_groups"`
        StorageRootsCount  int64 `json:"storage_roots_count"`
        ActiveStorageRoots int64 `json:"active_storage_roots"`
        LastScanTime       int64 `json:"last_scan_time"`
}

type StorageRootStats struct {
        Name             string `json:"name"`
        TotalFiles       int64  `json:"total_files"`
        TotalDirectories int64  `json:"total_directories"`
        TotalSize        int64  `json:"total_size"`
        DuplicateFiles   int64  `json:"duplicate_files"`
        DuplicateGroups  int64  `json:"duplicate_groups"`
        LastScanTime     int64  `json:"last_scan_time"`
        IsOnline         bool   `json:"is_online"`
}

type FileTypeStats struct {
        FileType    string `json:"file_type"`
        Extension   string `json:"extension"`
        Count       int64  `json:"count"`
        TotalSize   int64  `json:"total_size"`
        AverageSize int64  `json:"average_size"`
}

type SizeDistribution struct {
        Tiny    int64 `json:"tiny"`    // &lt; 1KB
        Small   int64 `json:"small"`   // 1KB - 1MB
        Medium  int64 `json:"medium"`  // 1MB - 10MB
        Large   int64 `json:"large"`   // 10MB - 100MB
        Huge    int64 `json:"huge"`    // 100MB - 1GB
        Massive int64 `json:"massive"` // &gt; 1GB
}

type DuplicateStats struct {
        TotalDuplicates       int64   `json:"total_duplicates"`
        DuplicateGroups       int64   `json:"duplicate_groups"`
        WastedSpace           int64   `json:"wasted_space"`
        LargestDuplicateGroup int     `json:"largest_duplicate_group"`
        AverageGroupSize      float64 `json:"average_group_size"`
}

type DuplicateGroupStats struct {
        GroupID     int64  `json:"group_id"`
        FileCount   int    `json:"file_count"`
        TotalSize   int64  `json:"total_size"`
        WastedSpace int64  `json:"wasted_space"`
        SamplePath  string `json:"sample_path"`
}

type AccessPatterns struct {
        RecentlyAccessed   int64    `json:"recently_accessed"`
        NeverAccessed      int64    `json:"never_accessed"`
        AccessFrequency    []int64  `json:"access_frequency"` // Daily access counts
        PopularExtensions  []string `json:"popular_extensions"`
        PopularDirectories []string `json:"popular_directories"`
}

type GrowthTrends struct {
        MonthlyGrowth   []MonthlyGrowth `json:"monthly_growth"`
        TotalGrowthRate float64         `json:"total_growth_rate"`
        FileGrowthRate  float64         `json:"file_growth_rate"`
        SizeGrowthRate  float64         `json:"size_growth_rate"`
}

type MonthlyGrowth struct {
        Month      string `json:"month"`
        FilesAdded int64  `json:"files_added"`
        SizeAdded  int64  `json:"size_added"`
        TotalFiles int64  `json:"total_files"`
        TotalSize  int64  `json:"total_size"`
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "catalogizer/models"
        "catalogizer/services"
)

type StressTestHandler struct {
        stressTestService *services.StressTestService
        authService       *services.AuthService
}

func NewStressTestHandler(stressTestService *services.StressTestService, authService *services.AuthService) *StressTestHandler <span class="cov0" title="0">{
        return &amp;StressTestHandler{
                stressTestService: stressTestService,
                authService:       authService,
        }
}</span>

// CreateStressTest creates a new stress test
func (h *StressTestHandler) CreateStressTest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Stress test creation not implemented"})</span>
}

// GetStressTest gets a stress test by ID
func (h *StressTestHandler) GetStressTest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get stress test not implemented"})</span>
}

// UpdateStressTest updates a stress test
func (h *StressTestHandler) UpdateStressTest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Update stress test not implemented"})</span>
}

// DeleteStressTest deletes a stress test
func (h *StressTestHandler) DeleteStressTest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Delete stress test not implemented"})</span>
}

// ListStressTests lists stress tests for a user
func (h *StressTestHandler) ListStressTests(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "List stress tests not implemented"})</span>
}

// StartStressTest starts a stress test
func (h *StressTestHandler) StartStressTest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Start stress test not implemented"})</span>
}

// StopStressTest stops a stress test
func (h *StressTestHandler) StopStressTest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Stop stress test not implemented"})</span>
}

// GetStressTestStatus gets the status of a stress test
func (h *StressTestHandler) GetStressTestStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get stress test status not implemented"})</span>
}

// GetStressTestResults gets the results of a stress test
func (h *StressTestHandler) GetStressTestResults(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get stress test results not implemented"})</span>
}

// GetStressTestExecution gets a specific execution
func (h *StressTestHandler) GetStressTestExecution(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get stress test execution not implemented"})</span>
}

// GetStressTestExecutions gets executions for a test
func (h *StressTestHandler) GetStressTestExecutions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get stress test executions not implemented"})</span>
}

// GetStressTestStatistics gets statistics for a test
func (h *StressTestHandler) GetStressTestStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get stress test statistics not implemented"})</span>
}

// GetSystemMetrics gets system metrics
func (h *StressTestHandler) GetSystemMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get system metrics not implemented"})</span>
}

// CleanupOldExecutions cleans up old executions
func (h *StressTestHandler) CleanupOldExecutions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Cleanup old executions not implemented"})</span>
}

// GetTestPresets gets test presets
func (h *StressTestHandler) GetTestPresets(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get test presets not implemented"})</span>
}

// ValidateScenario validates a test scenario
func (h *StressTestHandler) ValidateScenario(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Validate scenario not implemented"})</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/services"
)

type UserHandler struct {
        userRepo    *repository.UserRepository
        authService *services.AuthService
}

func NewUserHandler(userRepo *repository.UserRepository, authService *services.AuthService) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userRepo:    userRepo,
                authService: authService,
        }
}</span>

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserCreate)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.authService.ValidatePassword(req.Password); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">salt, err := h.authService.GenerateSecureToken(16)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate salt", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">passwordHash, err := h.hashPassword(req.Password, salt)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to hash password", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">isActive := true
        if req.IsActive != nil </span><span class="cov0" title="0">{
                isActive = *req.IsActive
        }</span>

        <span class="cov0" title="0">user := &amp;models.User{
                Username:     req.Username,
                Email:        req.Email,
                PasswordHash: passwordHash,
                Salt:         salt,
                RoleID:       req.RoleID,
                FirstName:    req.FirstName,
                LastName:     req.LastName,
                DisplayName:  req.DisplayName,
                TimeZone:     req.TimeZone,
                Language:     req.Language,
                IsActive:     isActive,
        }

        id, err := h.userRepo.Create(user)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "UNIQUE constraint failed") </span><span class="cov0" title="0">{
                        http.Error(w, "Username or email already exists", http.StatusConflict)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to create user", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">user.ID = id
        user.PasswordHash = ""
        user.Salt = ""

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(user)</span>
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strings.TrimPrefix(r.URL.Path, "/api/users/")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if currentUser.ID != userID </span><span class="cov0" title="0">{
                hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserView)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                        http.Error(w, "Insufficient permissions", http.StatusForbidden)
                        return
                }</span>
        }

        <span class="cov0" title="0">user, err := h.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        http.Error(w, "User not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to get user", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">role, err := h.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get user role", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">user.Role = role

        user.PasswordHash = ""
        user.Salt = ""

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)</span>
}

func (h *UserHandler) UpdateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPut </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strings.TrimPrefix(r.URL.Path, "/api/users/")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if currentUser.ID != userID </span><span class="cov0" title="0">{
                hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserUpdate)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                        http.Error(w, "Insufficient permissions", http.StatusForbidden)
                        return
                }</span>
        }

        <span class="cov0" title="0">var req models.UpdateUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        http.Error(w, "User not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to get user", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">if req.Username != nil </span><span class="cov0" title="0">{
                user.Username = *req.Username
        }</span>
        <span class="cov0" title="0">if req.Email != nil </span><span class="cov0" title="0">{
                user.Email = *req.Email
        }</span>
        <span class="cov0" title="0">if req.FirstName != nil </span><span class="cov0" title="0">{
                user.FirstName = req.FirstName
        }</span>
        <span class="cov0" title="0">if req.LastName != nil </span><span class="cov0" title="0">{
                user.LastName = req.LastName
        }</span>
        <span class="cov0" title="0">if req.DisplayName != nil </span><span class="cov0" title="0">{
                user.DisplayName = req.DisplayName
        }</span>
        <span class="cov0" title="0">if req.AvatarURL != nil </span><span class="cov0" title="0">{
                user.AvatarURL = req.AvatarURL
        }</span>
        <span class="cov0" title="0">if req.TimeZone != nil </span><span class="cov0" title="0">{
                user.TimeZone = req.TimeZone
        }</span>
        <span class="cov0" title="0">if req.Language != nil </span><span class="cov0" title="0">{
                user.Language = req.Language
        }</span>

        <span class="cov0" title="0">if currentUser.ID != userID </span><span class="cov0" title="0">{
                hasAdminPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserManage)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">if hasAdminPermission </span><span class="cov0" title="0">{
                        if req.RoleID != nil </span><span class="cov0" title="0">{
                                user.RoleID = *req.RoleID
                        }</span>
                        <span class="cov0" title="0">if req.IsActive != nil </span><span class="cov0" title="0">{
                                user.IsActive = *req.IsActive
                        }</span>
                }
        }

        // TODO: handle Settings update
        // if req.Settings != nil {
        //         // marshal to string
        //         user.Settings = req.Settings
        // }

        <span class="cov0" title="0">err = h.userRepo.Update(user)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "UNIQUE constraint failed") </span><span class="cov0" title="0">{
                        http.Error(w, "Username or email already exists", http.StatusConflict)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to update user", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">role, err := h.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get user role", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">user.Role = role

        user.PasswordHash = ""
        user.Salt = ""

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)</span>
}

func (h *UserHandler) DeleteUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodDelete </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserDelete)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strings.TrimPrefix(r.URL.Path, "/api/users/")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if currentUser.ID == userID </span><span class="cov0" title="0">{
                http.Error(w, "Cannot delete your own account", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.userRepo.Delete(userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to delete user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *UserHandler) ListUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserView)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")

        limit := 50
        offset := 0

        if limitStr != "" </span><span class="cov0" title="0">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 &amp;&amp; parsedLimit &lt;= 100 </span><span class="cov0" title="0">{
                        limit = parsedLimit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if parsedOffset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; parsedOffset &gt;= 0 </span><span class="cov0" title="0">{
                        offset = parsedOffset
                }</span>
        }

        <span class="cov0" title="0">users, err := h.userRepo.List(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to list users", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">for i := range users </span><span class="cov0" title="0">{
                users[i].PasswordHash = ""
                users[i].Salt = ""

                role, err := h.userRepo.GetRole(users[i].RoleID)
                if err == nil </span><span class="cov0" title="0">{
                        users[i].Role = role
                }</span>
        }

        <span class="cov0" title="0">totalCount, err := h.userRepo.Count()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get user count", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "users":       users,
                "total_count": totalCount,
                "limit":       limit,
                "offset":      offset,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

func (h *UserHandler) ResetPassword(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserManage)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strings.TrimPrefix(r.URL.Path, "/api/users/")
        userIDStr = strings.TrimSuffix(userIDStr, "/reset-password")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                NewPassword string `json:"new_password"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.authService.ValidatePassword(req.NewPassword); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.authService.ResetPassword(userID, req.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Password reset successfully"})</span>
}

func (h *UserHandler) LockAccount(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserManage)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strings.TrimPrefix(r.URL.Path, "/api/users/")
        userIDStr = strings.TrimSuffix(userIDStr, "/lock")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if currentUser.ID == userID </span><span class="cov0" title="0">{
                http.Error(w, "Cannot lock your own account", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                LockUntil string `json:"lock_until"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">lockUntil, err := parseTime(req.LockUntil)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid lock_until format", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.authService.LockAccount(userID, lockUntil)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Account locked successfully"})</span>
}

func (h *UserHandler) UnlockAccount(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserManage)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strings.TrimPrefix(r.URL.Path, "/api/users/")
        userIDStr = strings.TrimSuffix(userIDStr, "/unlock")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.authService.UnlockAccount(userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Account unlocked successfully"})</span>
}

func (h *UserHandler) getCurrentUser(r *http.Request) (*models.User, error) <span class="cov0" title="0">{
        token := extractToken(r)
        if token == "" </span><span class="cov0" title="0">{
                return nil, models.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return h.authService.GetCurrentUser(token)</span>
}

func (h *UserHandler) hashPassword(password, salt string) (string, error) <span class="cov0" title="0">{
        combined := password + salt
        hash := h.authService.HashData(combined)
        return hash, nil
}</span>

func parseTime(timeStr string) (time.Time, error) <span class="cov0" title="0">{
        return time.Parse(time.RFC3339, timeStr)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package auth

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// AuthMiddleware handles JWT authentication
type AuthMiddleware struct {
        authService *AuthService
        logger      *zap.Logger
}

// NewAuthMiddleware creates a new auth middleware
func NewAuthMiddleware(authService *AuthService, logger *zap.Logger) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                authService: authService,
                logger:      logger,
        }
}</span>

// RequireAuth middleware that requires authentication
func (m *AuthMiddleware) RequireAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                token := m.extractToken(c)
                if token == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing or invalid authorization header"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">user, err := m.authService.ValidateToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.Debug("Token validation failed", zap.Error(err))
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
                        c.Abort()
                        return
                }</span>

                // Set user in context
                <span class="cov0" title="0">c.Set("user", user)
                c.Set("user_id", user.ID)
                c.Set("username", user.Username)
                c.Set("role", user.Role)
                c.Set("permissions", user.Permissions)

                c.Next()</span>
        }
}

// RequirePermission middleware that requires specific permission
func (m *AuthMiddleware) RequirePermission(permission string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                user, exists := c.Get("user")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">userObj, ok := user.(*User)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid user context"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if !userObj.HasPermission(permission) &amp;&amp; !userObj.IsAdmin() </span><span class="cov0" title="0">{
                        m.logger.Debug("Permission denied",
                                zap.String("username", userObj.Username),
                                zap.String("required_permission", permission))
                        c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireRole middleware that requires specific role
func (m *AuthMiddleware) RequireRole(roles ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                user, exists := c.Get("user")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">userObj, ok := user.(*User)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid user context"})
                        c.Abort()
                        return
                }</span>

                // Check if user has any of the required roles
                <span class="cov0" title="0">hasRole := false
                for _, role := range roles </span><span class="cov0" title="0">{
                        if userObj.Role == role </span><span class="cov0" title="0">{
                                hasRole = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !hasRole &amp;&amp; !userObj.IsAdmin() </span><span class="cov0" title="0">{
                        m.logger.Debug("Role access denied",
                                zap.String("username", userObj.Username),
                                zap.String("user_role", userObj.Role),
                                zap.Strings("required_roles", roles))
                        c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient role privileges"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireResourceAccess middleware for resource-action based permissions
func (m *AuthMiddleware) RequireResourceAccess(resource, action string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                user, exists := c.Get("user")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">userObj, ok := user.(*User)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid user context"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if !userObj.CanAccess(resource, action) </span><span class="cov0" title="0">{
                        m.logger.Debug("Resource access denied",
                                zap.String("username", userObj.Username),
                                zap.String("resource", resource),
                                zap.String("action", action))
                        c.JSON(http.StatusForbidden, gin.H{
                                "error":    "Access denied to resource",
                                "resource": resource,
                                "action":   action,
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// OptionalAuth middleware that extracts user if token is present but doesn't require it
func (m *AuthMiddleware) OptionalAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                token := m.extractToken(c)
                if token != "" </span><span class="cov0" title="0">{
                        user, err := m.authService.ValidateToken(token)
                        if err == nil </span><span class="cov0" title="0">{
                                // Set user in context if token is valid
                                c.Set("user", user)
                                c.Set("user_id", user.ID)
                                c.Set("username", user.Username)
                                c.Set("role", user.Role)
                                c.Set("permissions", user.Permissions)
                        }</span>
                }
                <span class="cov0" title="0">c.Next()</span>
        }
}

// AdminOnly middleware that requires admin role
func (m *AuthMiddleware) AdminOnly() gin.HandlerFunc <span class="cov0" title="0">{
        return m.RequireRole(RoleAdmin)
}</span>

// ModeratorOrAdmin middleware that requires moderator or admin role
func (m *AuthMiddleware) ModeratorOrAdmin() gin.HandlerFunc <span class="cov0" title="0">{
        return m.RequireRole(RoleModerator, RoleAdmin)
}</span>

// extractToken extracts JWT token from Authorization header
func (m *AuthMiddleware) extractToken(c *gin.Context) string <span class="cov0" title="0">{
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Check for Bearer token
        <span class="cov0" title="0">if strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                return strings.TrimPrefix(authHeader, "Bearer ")
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// GetCurrentUser helper function to get current user from context
func GetCurrentUser(c *gin.Context) (*User, bool) <span class="cov0" title="0">{
        user, exists := c.Get("user")
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">userObj, ok := user.(*User)
        return userObj, ok</span>
}

// GetCurrentUserID helper function to get current user ID from context
func GetCurrentUserID(c *gin.Context) (int64, bool) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov0" title="0">id, ok := userID.(int64)
        return id, ok</span>
}

// HasPermission helper function to check if current user has permission
func HasPermission(c *gin.Context, permission string) bool <span class="cov0" title="0">{
        user, exists := GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return user.HasPermission(permission) || user.IsAdmin()</span>
}

// IsAdmin helper function to check if current user is admin
func IsAdmin(c *gin.Context) bool <span class="cov0" title="0">{
        user, exists := GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return user.IsAdmin()</span>
}

// CanAccessResource helper function to check resource access
func CanAccessResource(c *gin.Context, resource, action string) bool <span class="cov0" title="0">{
        user, exists := GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return user.CanAccess(resource, action)</span>
}

// LogUserActivity logs user activity for audit purposes
func (m *AuthMiddleware) LogUserActivity() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                // Log after request completion
                user, exists := GetCurrentUser(c)
                if exists </span><span class="cov0" title="0">{
                        m.logger.Info("User activity",
                                zap.String("username", user.Username),
                                zap.String("method", c.Request.Method),
                                zap.String("path", c.Request.URL.Path),
                                zap.Int("status", c.Writer.Status()),
                                zap.String("ip", c.ClientIP()),
                                zap.String("user_agent", c.Request.UserAgent()),
                        )
                }</span>
        }
}

// RateLimitByUser implements per-user rate limiting
func (m *AuthMiddleware) RateLimitByUser(requests int, window string) gin.HandlerFunc <span class="cov0" title="0">{
        // This is a placeholder - implement with Redis or in-memory store
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                user, exists := GetCurrentUser(c)
                if !exists </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // TODO: Implement rate limiting logic
                // For now, just pass through
                <span class="cov0" title="0">_ = user
                _ = requests
                _ = window

                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package auth

import (
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// User represents a system user
type User struct {
        ID           int64      `json:"id" db:"id"`
        Username     string     `json:"username" db:"username"`
        Email        string     `json:"email" db:"email"`
        PasswordHash string     `json:"-" db:"password_hash"`
        FirstName    string     `json:"first_name" db:"first_name"`
        LastName     string     `json:"last_name" db:"last_name"`
        Role         string     `json:"role" db:"role"`
        IsActive     bool       `json:"is_active" db:"is_active"`
        LastLogin    *time.Time `json:"last_login,omitempty" db:"last_login"`
        CreatedAt    time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt    time.Time  `json:"updated_at" db:"updated_at"`
        Permissions  []string   `json:"permissions,omitempty"`
}

// Role represents user roles
type Role struct {
        ID          int64     `json:"id" db:"id"`
        Name        string    `json:"name" db:"name"`
        Description string    `json:"description" db:"description"`
        Permissions []string  `json:"permissions" db:"permissions"`
        CreatedAt   time.Time `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time `json:"updated_at" db:"updated_at"`
}

// Session represents user sessions
type Session struct {
        ID        string    `json:"id" db:"id"`
        UserID    int64     `json:"user_id" db:"user_id"`
        Token     string    `json:"token" db:"token"`
        ExpiresAt time.Time `json:"expires_at" db:"expires_at"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
        IPAddress string    `json:"ip_address" db:"ip_address"`
        UserAgent string    `json:"user_agent" db:"user_agent"`
}

// LoginRequest represents login request payload
type LoginRequest struct {
        Username string `json:"username" binding:"required"`
        Password string `json:"password" binding:"required"`
}

// LoginResponse represents login response
type LoginResponse struct {
        User         User   `json:"user"`
        Token        string `json:"token"`
        RefreshToken string `json:"refresh_token"`
        ExpiresIn    int64  `json:"expires_in"`
}

// RegisterRequest represents registration request
type RegisterRequest struct {
        Username  string `json:"username" binding:"required,min=3,max=50"`
        Email     string `json:"email" binding:"required,email"`
        Password  string `json:"password" binding:"required,min=8"`
        FirstName string `json:"first_name" binding:"required"`
        LastName  string `json:"last_name" binding:"required"`
}

// UpdateUserRequest represents user update request
type UpdateUserRequest struct {
        FirstName *string `json:"first_name,omitempty"`
        LastName  *string `json:"last_name,omitempty"`
        Email     *string `json:"email,omitempty"`
        Role      *string `json:"role,omitempty"`
        IsActive  *bool   `json:"is_active,omitempty"`
}

// ChangePasswordRequest represents password change request
type ChangePasswordRequest struct {
        CurrentPassword string `json:"current_password" binding:"required"`
        NewPassword     string `json:"new_password" binding:"required,min=8"`
}

// Permission represents system permissions
type Permission struct {
        ID          int64  `json:"id" db:"id"`
        Name        string `json:"name" db:"name"`
        Resource    string `json:"resource" db:"resource"`
        Action      string `json:"action" db:"action"`
        Description string `json:"description" db:"description"`
}

// Claims represents JWT claims
type Claims struct {
        UserID      int64    `json:"user_id"`
        Username    string   `json:"username"`
        Role        string   `json:"role"`
        Permissions []string `json:"permissions"`
        Type        string   `json:"type"` // access or refresh
        IssuedAt    int64    `json:"iat"`
        ExpiresAt   int64    `json:"exp"`
}

// JWT Claims interface implementation
func (c Claims) Valid() error <span class="cov0" title="0">{
        if time.Now().Unix() &gt; c.ExpiresAt </span><span class="cov0" title="0">{
                return fmt.Errorf("token expired")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c Claims) GetExpirationTime() (*jwt.NumericDate, error) <span class="cov0" title="0">{
        return jwt.NewNumericDate(time.Unix(c.ExpiresAt, 0)), nil
}</span>

func (c Claims) GetIssuedAt() (*jwt.NumericDate, error) <span class="cov0" title="0">{
        return jwt.NewNumericDate(time.Unix(c.IssuedAt, 0)), nil
}</span>

func (c Claims) GetNotBefore() (*jwt.NumericDate, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (c Claims) GetIssuer() (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (c Claims) GetSubject() (string, error) <span class="cov0" title="0">{
        return c.Username, nil
}</span>

func (c Claims) GetAudience() (jwt.ClaimStrings, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

// Standard permissions
const (
        // Media permissions
        PermissionReadMedia   = "read:media"
        PermissionWriteMedia  = "write:media"
        PermissionDeleteMedia = "delete:media"
        PermissionViewMedia   = "view:media"

        // Catalog permissions
        PermissionReadCatalog   = "read:catalog"
        PermissionWriteCatalog  = "write:catalog"
        PermissionDeleteCatalog = "delete:catalog"

        // Analysis permissions
        PermissionTriggerAnalysis = "trigger:analysis"
        PermissionViewAnalysis    = "view:analysis"

        // Admin permissions
        PermissionManageUsers = "manage:users"
        PermissionManageRoles = "manage:roles"
        PermissionViewLogs    = "view:logs"
        PermissionSystemAdmin = "admin:system"

        // API permissions
        PermissionAPIAccess = "access:api"
        PermissionAPIWrite  = "write:api"
)

// Standard roles
const (
        RoleAdmin     = "admin"
        RoleModerator = "moderator"
        RoleUser      = "user"
        RoleViewer    = "viewer"
)

// GetRolePermissions returns default permissions for each role
func GetRolePermissions(role string) []string <span class="cov0" title="0">{
        switch role </span>{
        case RoleAdmin:<span class="cov0" title="0">
                return []string{
                        PermissionReadMedia, PermissionWriteMedia, PermissionDeleteMedia,
                        PermissionReadCatalog, PermissionWriteCatalog, PermissionDeleteCatalog,
                        PermissionTriggerAnalysis, PermissionViewAnalysis,
                        PermissionManageUsers, PermissionManageRoles, PermissionViewLogs,
                        PermissionSystemAdmin, PermissionAPIAccess, PermissionAPIWrite,
                }</span>
        case RoleModerator:<span class="cov0" title="0">
                return []string{
                        PermissionReadMedia, PermissionWriteMedia,
                        PermissionReadCatalog, PermissionWriteCatalog,
                        PermissionTriggerAnalysis, PermissionViewAnalysis,
                        PermissionAPIAccess, PermissionAPIWrite,
                }</span>
        case RoleUser:<span class="cov0" title="0">
                return []string{
                        PermissionReadMedia, PermissionWriteMedia,
                        PermissionReadCatalog, PermissionWriteCatalog,
                        PermissionViewAnalysis, PermissionAPIAccess,
                }</span>
        case RoleViewer:<span class="cov0" title="0">
                return []string{
                        PermissionReadMedia, PermissionReadCatalog,
                        PermissionViewAnalysis, PermissionAPIAccess,
                }</span>
        default:<span class="cov0" title="0">
                return []string{PermissionAPIAccess}</span>
        }
}

// HasPermission checks if user has specific permission
func (u *User) HasPermission(permission string) bool <span class="cov0" title="0">{
        for _, p := range u.Permissions </span><span class="cov0" title="0">{
                if p == permission </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsAdmin checks if user is admin
func (u *User) IsAdmin() bool <span class="cov0" title="0">{
        return u.Role == RoleAdmin
}</span>

// CanAccess checks if user can access a resource with specific action
func (u *User) CanAccess(resource, action string) bool <span class="cov0" title="0">{
        permission := action + ":" + resource
        return u.HasPermission(permission) || u.HasPermission(PermissionSystemAdmin)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package auth

import (
        "crypto/rand"
        "database/sql"
        "encoding/hex"
        "fmt"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "go.uber.org/zap"
        "golang.org/x/crypto/bcrypt"
)

// AuthService handles authentication operations
type AuthService struct {
        db        *sql.DB
        jwtSecret []byte
        logger    *zap.Logger
        tokenTTL  time.Duration
}

// NewAuthService creates a new authentication service
func NewAuthService(db *sql.DB, jwtSecret string, logger *zap.Logger) *AuthService <span class="cov0" title="0">{
        return &amp;AuthService{
                db:        db,
                jwtSecret: []byte(jwtSecret),
                logger:    logger,
                tokenTTL:  24 * time.Hour, // 24 hours
        }
}</span>

// Initialize creates the authentication tables and default admin user
func (s *AuthService) Initialize() error <span class="cov0" title="0">{
        // Create tables
        if err := s.createTables(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create auth tables: %w", err)
        }</span>

        // Create default admin user if none exists
        <span class="cov0" title="0">if err := s.createDefaultAdmin(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create default admin: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Authentication system initialized")
        return nil</span>
}

// createTables creates authentication-related tables
func (s *AuthService) createTables() error <span class="cov0" title="0">{
        schema := `
        -- Users table
        CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT NOT NULL UNIQUE,
                email TEXT NOT NULL UNIQUE,
                password_hash TEXT NOT NULL,
                first_name TEXT NOT NULL,
                last_name TEXT NOT NULL,
                role TEXT NOT NULL DEFAULT 'user',
                is_active BOOLEAN NOT NULL DEFAULT true,
                last_login DATETIME,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        -- Roles table
        CREATE TABLE IF NOT EXISTS roles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                description TEXT,
                permissions TEXT, -- JSON array
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        -- Sessions table
        CREATE TABLE IF NOT EXISTS sessions (
                id TEXT PRIMARY KEY,
                user_id INTEGER NOT NULL,
                token TEXT NOT NULL UNIQUE,
                expires_at DATETIME NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                ip_address TEXT,
                user_agent TEXT,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        );

        -- Permissions table
        CREATE TABLE IF NOT EXISTS permissions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                resource TEXT NOT NULL,
                action TEXT NOT NULL,
                description TEXT
        );

        -- User permissions (for custom permissions beyond role)
        CREATE TABLE IF NOT EXISTS user_permissions (
                user_id INTEGER NOT NULL,
                permission_id INTEGER NOT NULL,
                granted_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                granted_by INTEGER,
                PRIMARY KEY (user_id, permission_id),
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE,
                FOREIGN KEY (granted_by) REFERENCES users(id)
        );

        -- Audit log for authentication events
        CREATE TABLE IF NOT EXISTS auth_audit_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                event_type TEXT NOT NULL, -- login, logout, failed_login, password_change, etc.
                ip_address TEXT,
                user_agent TEXT,
                details TEXT, -- JSON
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id)
        );

        -- Indexes
        CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
        CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
        CREATE INDEX IF NOT EXISTS idx_users_role ON users(role);
        CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON sessions(user_id);
        CREATE INDEX IF NOT EXISTS idx_sessions_token ON sessions(token);
        CREATE INDEX IF NOT EXISTS idx_sessions_expires_at ON sessions(expires_at);
        CREATE INDEX IF NOT EXISTS idx_auth_audit_user_id ON auth_audit_log(user_id);
        CREATE INDEX IF NOT EXISTS idx_auth_audit_event_type ON auth_audit_log(event_type);
        CREATE INDEX IF NOT EXISTS idx_auth_audit_created_at ON auth_audit_log(created_at);

        -- Insert default roles
        INSERT OR IGNORE INTO roles (name, description, permissions) VALUES
        ('admin', 'System Administrator', '["admin:system", "manage:users", "manage:roles", "read:media", "write:media", "delete:media", "read:catalog", "write:catalog", "delete:catalog", "trigger:analysis", "view:analysis", "view:logs", "access:api", "write:api"]'),
        ('moderator', 'Content Moderator', '["read:media", "write:media", "read:catalog", "write:catalog", "trigger:analysis", "view:analysis", "access:api", "write:api"]'),
        ('user', 'Regular User', '["read:media", "write:media", "read:catalog", "write:catalog", "view:analysis", "access:api"]'),
        ('viewer', 'Read-only Viewer', '["read:media", "read:catalog", "view:analysis", "access:api"]');

        -- Insert default permissions
        INSERT OR IGNORE INTO permissions (name, resource, action, description) VALUES
        ('read:media', 'media', 'read', 'View media items and metadata'),
        ('write:media', 'media', 'write', 'Create and update media items'),
        ('delete:media', 'media', 'delete', 'Delete media items'),
        ('read:catalog', 'catalog', 'read', 'Browse file catalog'),
        ('write:catalog', 'catalog', 'write', 'Modify file catalog'),
        ('delete:catalog', 'catalog', 'delete', 'Delete from catalog'),
        ('trigger:analysis', 'analysis', 'trigger', 'Start media analysis'),
        ('view:analysis', 'analysis', 'view', 'View analysis results'),
        ('manage:users', 'users', 'manage', 'Create, update, delete users'),
        ('manage:roles', 'roles', 'manage', 'Create, update, delete roles'),
        ('view:logs', 'logs', 'view', 'View system logs'),
        ('admin:system', 'system', 'admin', 'Full system administration'),
        ('access:api', 'api', 'access', 'Access API endpoints'),
        ('write:api', 'api', 'write', 'Modify data via API');
        `

        _, err := s.db.Exec(schema)
        return err
}</span>

// createDefaultAdmin creates a default admin user if none exists
func (s *AuthService) createDefaultAdmin() error <span class="cov0" title="0">{
        // Check if any admin users exist
        var count int
        err := s.db.QueryRow("SELECT COUNT(*) FROM users WHERE role = 'admin'").Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                s.logger.Info("Admin user already exists")
                return nil
        }</span>

        // Create default admin user
        <span class="cov0" title="0">passwordHash, err := bcrypt.GenerateFromPassword([]byte("admin123"), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO users (username, email, password_hash, first_name, last_name, role, is_active)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err = s.db.Exec(query, "admin", "admin@catalogizer.local", string(passwordHash), "System", "Administrator", "admin", true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info("Default admin user created",
                zap.String("username", "admin"),
                zap.String("password", "admin123"))

        return nil</span>
}

// Login authenticates a user and returns a token
func (s *AuthService) Login(username, password, ipAddress, userAgent string) (*LoginResponse, error) <span class="cov0" title="0">{
        // Get user by username or email
        user, err := s.getUserByUsernameOrEmail(username)
        if err != nil </span><span class="cov0" title="0">{
                s.logAuthEvent(0, "failed_login", ipAddress, userAgent, fmt.Sprintf("user not found: %s", username))
                return nil, fmt.Errorf("invalid credentials")
        }</span>

        // Check if user is active
        <span class="cov0" title="0">if !user.IsActive </span><span class="cov0" title="0">{
                s.logAuthEvent(user.ID, "failed_login_inactive", ipAddress, userAgent, "account disabled")
                return nil, fmt.Errorf("account is disabled")
        }</span>

        // Verify password
        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password)); err != nil </span><span class="cov0" title="0">{
                s.logAuthEvent(user.ID, "failed_login", ipAddress, userAgent, "invalid password")
                return nil, fmt.Errorf("invalid credentials")
        }</span>

        // Load user permissions
        <span class="cov0" title="0">user.Permissions = GetRolePermissions(user.Role)

        // Generate tokens
        accessToken, err := s.generateToken(user, "access")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate access token: %w", err)
        }</span>

        <span class="cov0" title="0">refreshToken, err := s.generateToken(user, "refresh")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        // Create session
        <span class="cov0" title="0">sessionID, err := s.createSession(user.ID, accessToken, ipAddress, userAgent)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create session", zap.Error(err))
        }</span>

        // Update last login
        <span class="cov0" title="0">_, err = s.db.Exec("UPDATE users SET last_login = ? WHERE id = ?", time.Now(), user.ID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update last login", zap.Error(err))
        }</span>

        <span class="cov0" title="0">s.logAuthEvent(user.ID, "login_success", ipAddress, userAgent, fmt.Sprintf("session: %s", sessionID))

        return &amp;LoginResponse{
                User:         *user,
                Token:        accessToken,
                RefreshToken: refreshToken,
                ExpiresIn:    int64(s.tokenTTL.Seconds()),
        }, nil</span>
}

// Logout invalidates a user session
func (s *AuthService) Logout(token string) error <span class="cov0" title="0">{
        // Delete session
        _, err := s.db.Exec("DELETE FROM sessions WHERE token = ?", token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete session: %w", err)
        }</span>

        // Parse token to get user ID for logging
        <span class="cov0" title="0">claims, err := s.validateToken(token)
        if err == nil </span><span class="cov0" title="0">{
                s.logAuthEvent(claims.UserID, "logout", "", "", "")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateToken validates a JWT token and returns user information
func (s *AuthService) ValidateToken(tokenString string) (*User, error) <span class="cov0" title="0">{
        claims, err := s.validateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if session exists and is valid
        <span class="cov0" title="0">var sessionExists bool
        err = s.db.QueryRow("SELECT EXISTS(SELECT 1 FROM sessions WHERE token = ? AND expires_at &gt; ?)",
                tokenString, time.Now()).Scan(&amp;sessionExists)
        if err != nil || !sessionExists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session expired or invalid")
        }</span>

        // Get current user data
        <span class="cov0" title="0">user, err := s.GetUserByID(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// GetUserByID retrieves a user by ID
func (s *AuthService) GetUserByID(userID int64) (*User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, first_name, last_name, role, is_active, last_login, created_at, updated_at
                FROM users WHERE id = ?
        `

        user := &amp;User{}
        err := s.db.QueryRow(query, userID).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash,
                &amp;user.FirstName, &amp;user.LastName, &amp;user.Role, &amp;user.IsActive,
                &amp;user.LastLogin, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Load permissions
        <span class="cov0" title="0">user.Permissions = GetRolePermissions(user.Role)

        return user, nil</span>
}

// CreateUser creates a new user
func (s *AuthService) CreateUser(req *RegisterRequest) (*User, error) <span class="cov0" title="0">{
        // Check if username or email already exists
        var exists bool
        err := s.db.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE username = ? OR email = ?)",
                req.Username, req.Email).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("username or email already exists")
        }</span>

        // Hash password
        <span class="cov0" title="0">passwordHash, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Insert user
        <span class="cov0" title="0">query := `
                INSERT INTO users (username, email, password_hash, first_name, last_name, role, is_active)
                VALUES (?, ?, ?, ?, ?, 'user', true)
        `

        result, err := s.db.Exec(query, req.Username, req.Email, string(passwordHash), req.FirstName, req.LastName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">userID, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GetUserByID(userID)</span>
}

// Helper methods

func (s *AuthService) getUserByUsernameOrEmail(identifier string) (*User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, first_name, last_name, role, is_active, last_login, created_at, updated_at
                FROM users WHERE username = ? OR email = ?
        `

        user := &amp;User{}
        err := s.db.QueryRow(query, identifier, identifier).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash,
                &amp;user.FirstName, &amp;user.LastName, &amp;user.Role, &amp;user.IsActive,
                &amp;user.LastLogin, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        return user, err
}</span>

func (s *AuthService) generateToken(user *User, tokenType string) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        var expiresAt time.Time

        if tokenType == "refresh" </span><span class="cov0" title="0">{
                expiresAt = now.Add(7 * 24 * time.Hour) // 7 days for refresh tokens
        }</span> else<span class="cov0" title="0"> {
                expiresAt = now.Add(s.tokenTTL)
        }</span>

        <span class="cov0" title="0">claims := Claims{
                UserID:      user.ID,
                Username:    user.Username,
                Role:        user.Role,
                Permissions: user.Permissions,
                Type:        tokenType,
                IssuedAt:    now.Unix(),
                ExpiresAt:   expiresAt.Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(s.jwtSecret)</span>
}

func (s *AuthService) validateToken(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return s.jwtSecret, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid token")</span>
}

func (s *AuthService) createSession(userID int64, token, ipAddress, userAgent string) (string, error) <span class="cov0" title="0">{
        sessionID, err := generateRandomString(32)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">expiresAt := time.Now().Add(s.tokenTTL)

        query := `
                INSERT INTO sessions (id, user_id, token, expires_at, ip_address, user_agent)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = s.db.Exec(query, sessionID, userID, token, expiresAt, ipAddress, userAgent)
        return sessionID, err</span>
}

func (s *AuthService) logAuthEvent(userID int64, eventType, ipAddress, userAgent, details string) <span class="cov0" title="0">{
        query := `
                INSERT INTO auth_audit_log (user_id, event_type, ip_address, user_agent, details)
                VALUES (?, ?, ?, ?, ?)
        `

        _, err := s.db.Exec(query, userID, eventType, ipAddress, userAgent, details)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to log auth event", zap.Error(err))
        }</span>
}

func generateRandomString(length int) (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, length)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

// Additional methods for user management...

// UpdateUser updates user information
func (s *AuthService) UpdateUser(userID int64, req *UpdateUserRequest) (*User, error) <span class="cov0" title="0">{
        var setParts []string
        var args []interface{}

        if req.FirstName != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "first_name = ?")
                args = append(args, *req.FirstName)
        }</span>
        <span class="cov0" title="0">if req.LastName != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "last_name = ?")
                args = append(args, *req.LastName)
        }</span>
        <span class="cov0" title="0">if req.Email != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "email = ?")
                args = append(args, *req.Email)
        }</span>
        <span class="cov0" title="0">if req.Role != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "role = ?")
                args = append(args, *req.Role)
        }</span>
        <span class="cov0" title="0">if req.IsActive != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "is_active = ?")
                args = append(args, *req.IsActive)
        }</span>

        <span class="cov0" title="0">if len(setParts) == 0 </span><span class="cov0" title="0">{
                return s.GetUserByID(userID)
        }</span>

        <span class="cov0" title="0">setParts = append(setParts, "updated_at = ?")
        args = append(args, time.Now())
        args = append(args, userID)

        query := fmt.Sprintf("UPDATE users SET %s WHERE id = ?", strings.Join(setParts, ", "))
        _, err := s.db.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">return s.GetUserByID(userID)</span>
}

// ChangePassword changes user password
func (s *AuthService) ChangePassword(userID int64, currentPassword, newPassword string) error <span class="cov0" title="0">{
        user, err := s.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Verify current password
        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(currentPassword)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("current password is incorrect")
        }</span>

        // Hash new password
        <span class="cov0" title="0">newPasswordHash, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash new password: %w", err)
        }</span>

        // Update password
        <span class="cov0" title="0">_, err = s.db.Exec("UPDATE users SET password_hash = ?, updated_at = ? WHERE id = ?",
                string(newPasswordHash), time.Now(), userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        <span class="cov0" title="0">s.logAuthEvent(userID, "password_changed", "", "", "")
        return nil</span>
}

// ListUsers returns paginated list of users
func (s *AuthService) ListUsers(limit, offset int) ([]User, int64, error) <span class="cov0" title="0">{
        // Get total count
        var total int64
        err := s.db.QueryRow("SELECT COUNT(*) FROM users").Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get users
        <span class="cov0" title="0">query := `
                SELECT id, username, email, first_name, last_name, role, is_active, last_login, created_at, updated_at
                FROM users
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []User
        for rows.Next() </span><span class="cov0" title="0">{
                var user User
                err := rows.Scan(
                        &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.FirstName, &amp;user.LastName,
                        &amp;user.Role, &amp;user.IsActive, &amp;user.LastLogin, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">user.Permissions = GetRolePermissions(user.Role)
                users = append(users, user)</span>
        }

        <span class="cov0" title="0">return users, total, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
)

type Config struct {
        Server   ServerConfig   `json:"server"`
        Database DatabaseConfig `json:"database"`
        SMB      SMBConfig      `json:"smb"`
        Auth     AuthConfig     `json:"auth"`
        Logging  LoggingConfig  `json:"logging"`
        Catalog  CatalogConfig  `json:"catalog"`
}

type ServerConfig struct {
        Host         string `json:"host"`
        Port         string `json:"port"`
        ReadTimeout  int    `json:"read_timeout"`
        WriteTimeout int    `json:"write_timeout"`
        IdleTimeout  int    `json:"idle_timeout"`
        EnableCORS   bool   `json:"enable_cors"`
        EnableHTTPS  bool   `json:"enable_https"`
        CertFile     string `json:"cert_file"`
        KeyFile      string `json:"key_file"`
}

type DatabaseConfig struct {
        Driver   string `json:"driver"`
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Database string `json:"database"`
        Username string `json:"username"`
        Password string `json:"password"`
        SSLMode  string `json:"ssl_mode"`
}

type SMBConfig struct {
        Hosts     []SMBHost `json:"hosts"`
        Timeout   int       `json:"timeout"`
        ChunkSize int       `json:"chunk_size"`
}

type SMBHost struct {
        Name     string `json:"name"`
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Share    string `json:"share"`
        Username string `json:"username"`
        Password string `json:"password"`
        Domain   string `json:"domain"`
}

type AuthConfig struct {
        EnableAuth bool   `json:"enable_auth"`
        JWTSecret  string `json:"jwt_secret"`
}

type LoggingConfig struct {
        Level  string `json:"level"`
        Format string `json:"format"`
}

type CatalogConfig struct {
        TempDir           string `json:"temp_dir"`
        MaxArchiveSize    int64  `json:"max_archive_size"`
        DownloadChunkSize int    `json:"download_chunk_size"`
}

func Load() (*Config, error) <span class="cov0" title="0">{
        configPath := os.Getenv("CATALOG_CONFIG_PATH")
        if configPath == "" </span><span class="cov0" title="0">{
                configPath = "config.json"
        }</span>

        <span class="cov0" title="0">return LoadFromFile(configPath)</span>
}

func LoadFromFile(path string) (*Config, error) <span class="cov0" title="0">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open config file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var config Config
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := config.validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (c *Config) validate() error <span class="cov0" title="0">{
        if c.Server.Port == "" </span><span class="cov0" title="0">{
                c.Server.Port = "8080"
        }</span>
        <span class="cov0" title="0">if c.Server.Host == "" </span><span class="cov0" title="0">{
                c.Server.Host = "localhost"
        }</span>
        <span class="cov0" title="0">if c.Server.ReadTimeout == 0 </span><span class="cov0" title="0">{
                c.Server.ReadTimeout = 30
        }</span>
        <span class="cov0" title="0">if c.Server.WriteTimeout == 0 </span><span class="cov0" title="0">{
                c.Server.WriteTimeout = 30
        }</span>
        <span class="cov0" title="0">if c.Server.IdleTimeout == 0 </span><span class="cov0" title="0">{
                c.Server.IdleTimeout = 60
        }</span>

        <span class="cov0" title="0">if c.Catalog.TempDir == "" </span><span class="cov0" title="0">{
                c.Catalog.TempDir = "/tmp"
        }</span>
        <span class="cov0" title="0">if c.Catalog.MaxArchiveSize == 0 </span><span class="cov0" title="0">{
                c.Catalog.MaxArchiveSize = 1024 * 1024 * 1024 // 1GB
        }</span>
        <span class="cov0" title="0">if c.Catalog.DownloadChunkSize == 0 </span><span class="cov0" title="0">{
                c.Catalog.DownloadChunkSize = 1024 * 1024 // 1MB
        }</span>

        <span class="cov0" title="0">if c.SMB.Timeout == 0 </span><span class="cov0" title="0">{
                c.SMB.Timeout = 30
        }</span>
        <span class="cov0" title="0">if c.SMB.ChunkSize == 0 </span><span class="cov0" title="0">{
                c.SMB.ChunkSize = 1024 * 1024 // 1MB
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Config) GetServerAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", c.Server.Host, c.Server.Port)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package handlers

import (
        "catalogizer/internal/auth"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// AuthHandler handles authentication endpoints
type AuthHandler struct {
        authService *auth.AuthService
        logger      *zap.Logger
}

// NewAuthHandler creates a new auth handler
func NewAuthHandler(authService *auth.AuthService, logger *zap.Logger) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                authService: authService,
                logger:      logger,
        }
}</span>

// @Summary User login
// @Description Authenticate user and return JWT token
// @Tags auth
// @Accept json
// @Produce json
// @Param request body auth.LoginRequest true "Login credentials"
// @Success 200 {object} auth.LoginResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/login [post]
func (h *AuthHandler) Login(c *gin.Context) <span class="cov0" title="0">{
        var req auth.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">response, err := h.authService.Login(
                req.Username,
                req.Password,
                c.ClientIP(),
                c.Request.UserAgent(),
        )
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Debug("Login failed",
                        zap.String("username", req.Username),
                        zap.String("ip", c.ClientIP()),
                        zap.Error(err))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("User logged in successfully",
                zap.String("username", response.User.Username),
                zap.String("ip", c.ClientIP()))

        c.JSON(http.StatusOK, response)</span>
}

// @Summary User logout
// @Description Invalidate user session
// @Tags auth
// @Security BearerAuth
// @Success 200 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/logout [post]
func (h *AuthHandler) Logout(c *gin.Context) <span class="cov0" title="0">{
        // Extract token from header
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing authorization header"})
                return
        }</span>

        <span class="cov0" title="0">token := authHeader[7:] // Remove "Bearer " prefix
        if err := h.authService.Logout(token); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Logout failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Logout failed"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Logged out successfully"})</span>
}

// @Summary User registration
// @Description Register a new user account
// @Tags auth
// @Accept json
// @Produce json
// @Param request body auth.RegisterRequest true "Registration details"
// @Success 201 {object} auth.User
// @Failure 400 {object} map[string]string
// @Failure 409 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/register [post]
func (h *AuthHandler) Register(c *gin.Context) <span class="cov0" title="0">{
        var req auth.RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.authService.CreateUser(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Debug("Registration failed",
                        zap.String("username", req.Username),
                        zap.String("email", req.Email),
                        zap.Error(err))

                if err.Error() == "username or email already exists" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Username or email already exists"})
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Registration failed"})
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">h.logger.Info("User registered successfully",
                zap.String("username", user.Username),
                zap.String("email", user.Email))

        c.JSON(http.StatusCreated, user)</span>
}

// @Summary Get current user profile
// @Description Get authenticated user's profile information
// @Tags auth
// @Security BearerAuth
// @Produce json
// @Success 200 {object} auth.User
// @Failure 401 {object} map[string]string
// @Router /api/v1/auth/profile [get]
func (h *AuthHandler) GetProfile(c *gin.Context) <span class="cov0" title="0">{
        user, exists := auth.GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}

// @Summary Update user profile
// @Description Update authenticated user's profile information
// @Tags auth
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param request body auth.UpdateUserRequest true "Profile updates"
// @Success 200 {object} auth.User
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/profile [put]
func (h *AuthHandler) UpdateProfile(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := auth.GetCurrentUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">var req auth.UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        // Users can only update their own non-privileged fields
        <span class="cov0" title="0">safeReq := &amp;auth.UpdateUserRequest{
                FirstName: req.FirstName,
                LastName:  req.LastName,
                Email:     req.Email,
        }

        user, err := h.authService.UpdateUser(userID, safeReq)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Profile update failed",
                        zap.Int64("user_id", userID),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Profile update failed"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}

// @Summary Change password
// @Description Change user's password
// @Tags auth
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param request body auth.ChangePasswordRequest true "Password change request"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/change-password [post]
func (h *AuthHandler) ChangePassword(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := auth.GetCurrentUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">var req auth.ChangePasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">err := h.authService.ChangePassword(userID, req.CurrentPassword, req.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Debug("Password change failed",
                        zap.Int64("user_id", userID),
                        zap.Error(err))

                if err.Error() == "current password is incorrect" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Current password is incorrect"})
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Password change failed"})
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Password changed successfully"})</span>
}

// Admin endpoints

// @Summary List all users
// @Description Get paginated list of all users (admin only)
// @Tags auth
// @Security BearerAuth
// @Param limit query int false "Number of users per page" default(20)
// @Param offset query int false "Offset for pagination" default(0)
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/admin/users [get]
func (h *AuthHandler) ListUsers(c *gin.Context) <span class="cov0" title="0">{
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100 // Cap at 100
        }</span>

        <span class="cov0" title="0">users, total, err := h.authService.ListUsers(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to list users", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve users"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "users":  users,
                "total":  total,
                "limit":  limit,
                "offset": offset,
        })</span>
}

// @Summary Get user by ID
// @Description Get specific user information (admin only)
// @Tags auth
// @Security BearerAuth
// @Param id path int true "User ID"
// @Produce json
// @Success 200 {object} auth.User
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/auth/admin/users/{id} [get]
func (h *AuthHandler) GetUser(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        userID, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.authService.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Debug("User not found", zap.Int64("user_id", userID))
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}

// @Summary Update user
// @Description Update user information (admin only)
// @Tags auth
// @Security BearerAuth
// @Accept json
// @Param id path int true "User ID"
// @Param request body auth.UpdateUserRequest true "User updates"
// @Produce json
// @Success 200 {object} auth.User
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/auth/admin/users/{id} [put]
func (h *AuthHandler) UpdateUser(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        userID, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">var req auth.UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.authService.UpdateUser(userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update user",
                        zap.Int64("user_id", userID),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user"})
                return
        }</span>

        // Log the admin action
        <span class="cov0" title="0">currentUser, _ := auth.GetCurrentUser(c)
        h.logger.Info("User updated by admin",
                zap.Int64("target_user_id", userID),
                zap.String("admin_username", currentUser.Username))

        c.JSON(http.StatusOK, user)</span>
}

// @Summary Get authentication status
// @Description Check if user is authenticated and return user info
// @Tags auth
// @Security BearerAuth
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Router /api/v1/auth/status [get]
func (h *AuthHandler) GetAuthStatus(c *gin.Context) <span class="cov0" title="0">{
        user, exists := auth.GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "authenticated": false,
                        "error":         "Not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "authenticated": true,
                "user":          user,
                "permissions":   user.Permissions,
        })</span>
}

// @Summary Get user permissions
// @Description Get current user's permissions
// @Tags auth
// @Security BearerAuth
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Router /api/v1/auth/permissions [get]
func (h *AuthHandler) GetPermissions(c *gin.Context) <span class="cov0" title="0">{
        user, exists := auth.GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "role":        user.Role,
                "permissions": user.Permissions,
                "is_admin":    user.IsAdmin(),
        })</span>
}

// @Summary Get system initialization status
// @Description Check if system has been initialized with admin user
// @Tags auth
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Router /api/v1/auth/init-status [get]
func (h *AuthHandler) GetInitStatus(c *gin.Context) <span class="cov0" title="0">{
        // Check if any admin users exist
        users, _, err := h.authService.ListUsers(1, 0)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check initialization status"})
                return
        }</span>

        <span class="cov0" title="0">hasAdmin := false
        for _, user := range users </span><span class="cov0" title="0">{
                if user.Role == auth.RoleAdmin </span><span class="cov0" title="0">{
                        hasAdmin = true
                        break</span>
                }
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "initialized": hasAdmin,
                "has_admin":   hasAdmin,
                "user_count":  len(users),
        })</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package handlers

import (
        "catalogizer/internal/models"
        "catalogizer/internal/services"
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type CatalogHandler struct {
        catalogService services.CatalogServiceInterface
        smbService     services.SMBServiceInterface
        logger         *zap.Logger
}

func NewCatalogHandler(catalogService services.CatalogServiceInterface, smbService services.SMBServiceInterface, logger *zap.Logger) *CatalogHandler <span class="cov10" title="11">{
        return &amp;CatalogHandler{
                catalogService: catalogService,
                smbService:     smbService,
                logger:         logger,
        }
}</span>

// @Summary List root directories
// @Description Get list of available SMB root directories
// @Tags catalog
// @Produce json
// @Success 200 {array} string
// @Failure 500 {object} map[string]string
// @Router /api/v1/catalog [get]
func (h *CatalogHandler) ListRoot(c *gin.Context) <span class="cov1" title="1">{
        roots, err := h.catalogService.GetSMBRoots()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get SMB roots", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get SMB roots"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"roots": roots})</span>
}

// @Summary List files in path
// @Description Get list of files and directories in the specified path
// @Tags catalog
// @Param path path string true "Path to browse"
// @Param sort_by query string false "Sort by field (name, size, modified)" default(name)
// @Param sort_order query string false "Sort order (asc, desc)" default(asc)
// @Param limit query int false "Limit number of results" default(100)
// @Param offset query int false "Offset for pagination" default(0)
// @Produce json
// @Success 200 {array} models.FileInfo
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/catalog/{path} [get]
func (h *CatalogHandler) ListPath(c *gin.Context) <span class="cov3" title="2">{
        path := c.Param("path")
        if path == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Path is required"})
                return
        }</span>

        // Clean the path (remove leading slash if present)
        <span class="cov3" title="2">if strings.HasPrefix(path, "/") </span><span class="cov3" title="2">{
                path = path[1:]
        }</span>

        <span class="cov3" title="2">sortBy := c.DefaultQuery("sort_by", "name")
        sortOrder := c.DefaultQuery("sort_order", "asc")
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "100"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        files, err := h.catalogService.ListPath(path, sortBy, sortOrder, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to list path", zap.String("path", path), zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list directory"})
                return
        }</span>

        <span class="cov3" title="2">c.JSON(http.StatusOK, gin.H{
                "files":  files,
                "count":  len(files),
                "limit":  limit,
                "offset": offset,
        })</span>
}

// @Summary Get file information
// @Description Get detailed information about a specific file or directory
// @Tags catalog
// @Param path path string true "Path to file/directory"
// @Produce json
// @Success 200 {object} models.FileInfo
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/catalog-info/{path} [get]
func (h *CatalogHandler) GetFileInfo(c *gin.Context) <span class="cov3" title="2">{
        path := c.Param("path")
        if path == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Path is required"})
                return
        }</span>

        // Clean the path
        <span class="cov3" title="2">if strings.HasPrefix(path, "/") </span><span class="cov3" title="2">{
                path = path[1:]
        }</span>

        // Try to get file info by path or ID
        <span class="cov3" title="2">fileInfo, err := h.catalogService.GetFileInfo(path)
        if err != nil </span><span class="cov1" title="1">{
                if err.Error() == "sql: no rows in result set" </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "File not found"})
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("Failed to get file info", zap.String("path", path), zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get file information"})
                return</span>
        }

        <span class="cov1" title="1">if fileInfo == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "File not found"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, fileInfo)</span>
}

// @Summary Search files
// @Description Search for files and directories based on various criteria
// @Tags search
// @Param query query string false "Search query (filename)"
// @Param path query string false "Path filter"
// @Param extension query string false "File extension filter"
// @Param mime_type query string false "MIME type filter"
// @Param min_size query int false "Minimum file size"
// @Param max_size query int false "Maximum file size"
// @Param smb_roots query string false "Comma-separated list of SMB roots"
// @Param is_directory query bool false "Filter by directory status"
// @Param sort_by query string false "Sort by field" default(name)
// @Param sort_order query string false "Sort order" default(asc)
// @Param limit query int false "Limit results" default(100)
// @Param offset query int false "Offset for pagination" default(0)
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/search [get]
func (h *CatalogHandler) Search(c *gin.Context) <span class="cov5" title="3">{
        var req models.SearchRequest

        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid search parameters"})
                return
        }</span>

        <span class="cov5" title="3">if req.Query == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Search query is required"})
                return
        }</span>

        // Set defaults
        <span class="cov3" title="2">if req.Limit == 0 </span><span class="cov1" title="1">{
                req.Limit = 100
        }</span>
        <span class="cov3" title="2">if req.SortBy == "" </span><span class="cov3" title="2">{
                req.SortBy = "name"
        }</span>
        <span class="cov3" title="2">if req.SortOrder == "" </span><span class="cov3" title="2">{
                req.SortOrder = "asc"
        }</span>

        // Parse SMB roots if provided as comma-separated string
        <span class="cov3" title="2">smbRootsStr := c.Query("smb_roots")
        if smbRootsStr != "" </span><span class="cov0" title="0">{
                req.SmbRoots = strings.Split(smbRootsStr, ",")
        }</span>

        <span class="cov3" title="2">files, total, err := h.catalogService.SearchFiles(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to search files", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Search failed"})
                return
        }</span>

        <span class="cov3" title="2">c.JSON(http.StatusOK, gin.H{
                "files":  files,
                "total":  total,
                "count":  len(files),
                "limit":  req.Limit,
                "offset": req.Offset,
        })</span>
}

// @Summary Search duplicate files
// @Description Find groups of duplicate files
// @Tags search
// @Param smb_root query string false "SMB root to search in"
// @Param min_count query int false "Minimum number of duplicates" default(2)
// @Param limit query int false "Limit number of groups" default(50)
// @Produce json
// @Success 200 {array} models.DuplicateGroup
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/search/duplicates [get]
func (h *CatalogHandler) SearchDuplicates(c *gin.Context) <span class="cov1" title="1">{
        smbRoot := c.DefaultQuery("smb_root", "")
        minCount, _ := strconv.Atoi(c.DefaultQuery("min_count", "2"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))

        if smbRoot == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "SMB root is required"})
                return
        }</span>

        <span class="cov1" title="1">groups, err := h.catalogService.GetDuplicateGroups(smbRoot, minCount, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get duplicate groups", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to find duplicates"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{
                "groups": groups,
                "count":  len(groups),
        })</span>
}

// @Summary Get directories sorted by size
// @Description Get directories sorted by their total size
// @Tags stats
// @Param smb_root query string true "SMB root to analyze"
// @Param limit query int false "Limit number of results" default(50)
// @Produce json
// @Success 200 {array} models.DirectoryStats
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/stats/directories/by-size [get]
func (h *CatalogHandler) GetDirectoriesBySize(c *gin.Context) <span class="cov1" title="1">{
        smbRoot := c.Query("smb_root")
        if smbRoot == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "SMB root is required"})
                return
        }</span>

        <span class="cov1" title="1">limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))

        stats, err := h.catalogService.GetDirectoriesBySize(smbRoot, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get directories by size", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get directory statistics"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{
                "directories": stats,
                "count":       len(stats),
        })</span>
}

// @Summary Get duplicate count statistics
// @Description Get statistics about duplicate files
// @Tags stats
// @Param smb_root query string false "SMB root to analyze"
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 500 {object} map[string]string
// @Router /api/v1/stats/duplicates/count [get]
func (h *CatalogHandler) GetDuplicatesCount(c *gin.Context) <span class="cov1" title="1">{
        smbRoot := c.DefaultQuery("smb_root", "")

        groups, err := h.catalogService.GetDuplicateGroups(smbRoot, 2, 1000)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get duplicate statistics", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get duplicate statistics"})
                return
        }</span>

        <span class="cov1" title="1">var totalDuplicates int64
        var totalWastedSpace int64
        var groupCount int

        for _, group := range groups </span><span class="cov0" title="0">{
                if group.Count &gt; 1 </span><span class="cov0" title="0">{
                        groupCount++
                        totalDuplicates += int64(group.Count - 1) // Don't count the original
                        totalWastedSpace += int64(group.Count-1) * group.Size
                }</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{
                "duplicate_groups":   groupCount,
                "total_duplicates":   totalDuplicates,
                "total_wasted_space": totalWastedSpace,
                "smb_root":           smbRoot,
        })</span>
}

// Placeholder implementations for other endpoints
// Delegated to specialized handlers
func (h *CatalogHandler) DownloadFile(c *gin.Context) <span class="cov0" title="0">{
        // Delegate to DownloadHandler
        c.JSON(http.StatusSeeOther, gin.H{"redirect": "/api/v1/download/file/" + c.Param("path")})
}</span>

func (h *CatalogHandler) DownloadArchive(c *gin.Context) <span class="cov0" title="0">{
        // Delegate to DownloadHandler
        c.JSON(http.StatusSeeOther, gin.H{"redirect": "/api/v1/download/archive"})
}</span>

func (h *CatalogHandler) CopyToSMB(c *gin.Context) <span class="cov0" title="0">{
        // Delegate to CopyHandler
        c.JSON(http.StatusSeeOther, gin.H{"redirect": "/api/v1/copy/smb"})
}</span>

func (h *CatalogHandler) CopyFromSMB(c *gin.Context) <span class="cov0" title="0">{
        // Delegate to CopyHandler
        c.JSON(http.StatusSeeOther, gin.H{"redirect": "/api/v1/copy/local"})
}</span>

func (h *CatalogHandler) ListSMBPath(c *gin.Context) <span class="cov0" title="0">{
        // Delegate to CopyHandler
        c.JSON(http.StatusSeeOther, gin.H{"redirect": "/api/v1/smb/list/" + c.Param("path")})
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package handlers

import (
        "catalogizer/internal/models"
        "catalogizer/internal/services"
        "net/http"
        "os"
        "path/filepath"
        "strings"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type CopyHandler struct {
        catalogService *services.CatalogService
        smbService     *services.SMBService
        tempDir        string
        logger         *zap.Logger
}

func NewCopyHandler(catalogService *services.CatalogService, smbService *services.SMBService, tempDir string, logger *zap.Logger) *CopyHandler <span class="cov1" title="1">{
        return &amp;CopyHandler{
                catalogService: catalogService,
                smbService:     smbService,
                tempDir:        tempDir,
                logger:         logger,
        }
}</span>

// @Summary Copy file between SMB shares
// @Description Copy a file from one SMB location to another
// @Tags copy
// @Accept json
// @Param request body models.CopyRequest true "Copy request"
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/copy/smb [post]
func (h *CopyHandler) CopyToSMB(c *gin.Context) <span class="cov0" title="0">{
        var req models.CopyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">if req.SourcePath == "" || req.DestinationPath == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Source and destination paths are required"})
                return
        }</span>

        // Parse source and destination
        <span class="cov0" title="0">sourceHost, sourcePath := h.parseHostPath(req.SourcePath)
        destHost, destPath := h.parseHostPath(req.DestinationPath)

        if sourceHost == "" || destHost == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid host:path format. Use 'host:path'"})
                return
        }</span>

        // Check if destination exists and handle overwrite
        <span class="cov0" title="0">if !req.Overwrite </span><span class="cov0" title="0">{
                exists, err := h.smbService.FileExists(destHost, destPath)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to check destination file", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check destination"})
                        return
                }</span>
                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Destination file already exists"})
                        return
                }</span>
        }

        // Perform copy
        <span class="cov0" title="0">err := h.smbService.CopyFile(sourceHost, sourcePath, destHost, destPath)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to copy file via SMB",
                        zap.String("source", req.SourcePath),
                        zap.String("destination", req.DestinationPath),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Copy operation failed"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("File copied successfully via SMB",
                zap.String("source", req.SourcePath),
                zap.String("destination", req.DestinationPath))

        c.JSON(http.StatusOK, gin.H{
                "message":     "File copied successfully",
                "source":      req.SourcePath,
                "destination": req.DestinationPath,
        })</span>
}

// @Summary Copy file from SMB to local filesystem
// @Description Copy a file from SMB share to local filesystem
// @Tags copy
// @Accept json
// @Param request body models.CopyRequest true "Copy request"
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/copy/local [post]
func (h *CopyHandler) CopyToLocal(c *gin.Context) <span class="cov0" title="0">{
        var req models.CopyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">if req.SourcePath == "" || req.DestinationPath == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Source and destination paths are required"})
                return
        }</span>

        // Parse source
        <span class="cov0" title="0">sourceHost, sourcePath := h.parseHostPath(req.SourcePath)
        if sourceHost == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid source format. Use 'host:path'"})
                return
        }</span>

        // Destination is local path
        <span class="cov0" title="0">destPath := req.DestinationPath

        // Check if destination exists and handle overwrite
        if !req.Overwrite </span><span class="cov0" title="0">{
                if _, err := os.Stat(destPath); err == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Destination file already exists"})
                        return
                }</span>
        }

        // Create destination directory if needed
        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(destPath), 0755); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create destination directory", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create destination directory"})
                return
        }</span>

        // Download from SMB to local
        <span class="cov0" title="0">err := h.smbService.DownloadFile(sourceHost, sourcePath, destPath)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to copy file from SMB to local",
                        zap.String("source", req.SourcePath),
                        zap.String("destination", destPath),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Copy operation failed"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("File copied successfully from SMB to local",
                zap.String("source", req.SourcePath),
                zap.String("destination", destPath))

        c.JSON(http.StatusOK, gin.H{
                "message":     "File copied successfully to local filesystem",
                "source":      req.SourcePath,
                "destination": destPath,
        })</span>
}

// @Summary Upload file from local to SMB
// @Description Upload a file from local filesystem to SMB share
// @Tags copy
// @Accept multipart/form-data
// @Param file formData file true "File to upload"
// @Param destination formData string true "Destination path (host:path)"
// @Param overwrite formData bool false "Overwrite existing file"
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/copy/upload [post]
func (h *CopyHandler) CopyFromLocal(c *gin.Context) <span class="cov0" title="0">{
        // Get uploaded file
        file, header, err := c.Request.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "No file uploaded"})
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        destination := c.PostForm("destination")
        if destination == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Destination path is required"})
                return
        }</span>

        <span class="cov0" title="0">overwrite := c.PostForm("overwrite") == "true"

        // Parse destination
        destHost, destPath := h.parseHostPath(destination)
        if destHost == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid destination format. Use 'host:path'"})
                return
        }</span>

        // Check if destination exists and handle overwrite
        <span class="cov0" title="0">if !overwrite </span><span class="cov0" title="0">{
                exists, err := h.smbService.FileExists(destHost, destPath)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to check destination file", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check destination"})
                        return
                }</span>
                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Destination file already exists"})
                        return
                }</span>
        }

        // Save uploaded file to temp location
        <span class="cov0" title="0">tempFile, err := os.CreateTemp(h.tempDir, "upload_*")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create temp file", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process upload"})
                return
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempFile.Name())
        defer tempFile.Close()

        // Copy uploaded data to temp file
        _, err = tempFile.ReadFrom(file)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to save uploaded file", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save upload"})
                return
        }</span>

        // Upload to SMB
        <span class="cov0" title="0">err = h.smbService.UploadFile(destHost, tempFile.Name(), destPath)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to upload file to SMB",
                        zap.String("filename", header.Filename),
                        zap.String("destination", destination),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Upload to SMB failed"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("File uploaded successfully to SMB",
                zap.String("filename", header.Filename),
                zap.String("destination", destination),
                zap.Int64("size", header.Size))

        c.JSON(http.StatusOK, gin.H{
                "message":     "File uploaded successfully",
                "filename":    header.Filename,
                "destination": destination,
                "size":        header.Size,
        })</span>
}

// @Summary List files in SMB directory
// @Description List files and directories in an SMB share
// @Tags smb
// @Param host query string true "SMB host name"
// @Param path path string false "Directory path"
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/smb/list/{path} [get]
func (h *CopyHandler) ListSMBPath(c *gin.Context) <span class="cov0" title="0">{
        hostName := c.Query("host")
        if hostName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Host name is required"})
                return
        }</span>

        <span class="cov0" title="0">path := c.Param("path")
        if path == "" </span><span class="cov0" title="0">{
                path = "/"
        }</span>

        // Remove leading slash if present
        <span class="cov0" title="0">if path[0] == '/' </span><span class="cov0" title="0">{
                path = path[1:]
        }</span>

        <span class="cov0" title="0">files, err := h.smbService.ListFiles(hostName, path)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to list SMB directory",
                        zap.String("host", hostName),
                        zap.String("path", path),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list directory"})
                return
        }</span>

        // Convert os.FileInfo to a more JSON-friendly format
        <span class="cov0" title="0">var fileList []map[string]interface{}
        for _, file := range files </span><span class="cov0" title="0">{
                fileList = append(fileList, map[string]interface{}{
                        "name":          file.Name(),
                        "size":          file.Size(),
                        "is_directory":  file.IsDir(),
                        "last_modified": file.ModTime(),
                        "mode":          file.Mode().String(),
                })
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "host":  hostName,
                "path":  path,
                "files": fileList,
                "count": len(fileList),
        })</span>
}

// Helper function to parse host:path format
func (h *CopyHandler) parseHostPath(hostPath string) (string, string) <span class="cov0" title="0">{
        parts := strings.SplitN(hostPath, ":", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return "", ""
        }</span>
        <span class="cov0" title="0">return parts[0], parts[1]</span>
}

// @Summary Get available SMB hosts
// @Description Get list of configured SMB hosts
// @Tags smb
// @Produce json
// @Success 200 {array} string
// @Router /api/v1/smb/hosts [get]
func (h *CopyHandler) GetSMBHosts(c *gin.Context) <span class="cov0" title="0">{
        hosts := h.smbService.GetHosts()
        c.JSON(http.StatusOK, gin.H{
                "hosts": hosts,
                "count": len(hosts),
        })
}</span>

// @Summary Copy file to storage
// @Description Copy a file to a storage location
// @Tags copy
// @Accept json
// @Produce json
// @Param request body object true "Copy to storage request"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/copy/storage [post]
func (h *CopyHandler) CopyToStorage(c *gin.Context) <span class="cov10" title="7">{
        var req struct {
                SourcePath string `json:"source_path" binding:"required"`
                DestPath   string `json:"dest_path" binding:"required"`
                StorageID  string `json:"storage_id" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="5">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Implement storage copy logic
        <span class="cov4" title="2">c.JSON(http.StatusOK, gin.H{
                "message":     "File copied to storage successfully",
                "source":      req.SourcePath,
                "destination": req.DestPath,
                "storage_id":  req.StorageID,
        })</span>
}

// @Summary List files in storage path
// @Description List files in a storage path
// @Tags storage
// @Param path path string true "Storage path"
// @Param storage_id query string true "Storage ID"
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Router /api/v1/storage/list/{path} [get]
func (h *CopyHandler) ListStoragePath(c *gin.Context) <span class="cov8" title="5">{
        path := c.Param("path")
        storageID := c.Query("storage_id")

        if storageID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "storage_id is required"})
                return
        }</span>

        // Return mock data for now
        <span class="cov7" title="4">c.JSON(http.StatusOK, gin.H{
                "path":       path,
                "storage_id": storageID,
                "files":      []gin.H{},
        })</span>
}

// @Summary Get storage roots
// @Description Get available storage roots
// @Tags storage
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Router /api/v1/storage/roots [get]
func (h *CopyHandler) GetStorageRoots(c *gin.Context) <span class="cov6" title="3">{
        roots := []gin.H{
                {"id": "local", "name": "Local Storage", "path": "/data/storage"},
                {"id": "smb", "name": "SMB Storage", "path": "smb://server/share"},
        }

        c.JSON(http.StatusOK, gin.H{"roots": roots})
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package handlers

import (
        "archive/tar"
        "archive/zip"
        "catalogizer/internal/models"
        "catalogizer/internal/services"
        "compress/gzip"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type DownloadHandler struct {
        catalogService *services.CatalogService
        smbService     *services.SMBService
        tempDir        string
        maxArchiveSize int64
        chunkSize      int
        logger         *zap.Logger
}

func NewDownloadHandler(catalogService *services.CatalogService, smbService *services.SMBService, tempDir string, maxArchiveSize int64, chunkSize int, logger *zap.Logger) *DownloadHandler <span class="cov0" title="0">{
        return &amp;DownloadHandler{
                catalogService: catalogService,
                smbService:     smbService,
                tempDir:        tempDir,
                maxArchiveSize: maxArchiveSize,
                chunkSize:      chunkSize,
                logger:         logger,
        }
}</span>

// @Summary Download a single file
// @Description Download a file from the catalog
// @Tags download
// @Param id path int true "File ID"
// @Produce application/octet-stream
// @Success 200 {file} binary
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/download/file/{id} [get]
func (h *DownloadHandler) DownloadFile(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid file ID"})
                return
        }</span>

        <span class="cov0" title="0">fileInfo, err := h.catalogService.GetFileInfo(strconv.FormatInt(id, 10))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get file info", zap.Int64("id", id), zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get file information"})
                return
        }</span>

        <span class="cov0" title="0">if fileInfo == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "File not found"})
                return
        }</span>

        <span class="cov0" title="0">if fileInfo.IsDirectory </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Cannot download directory as single file"})
                return
        }</span>

        // Create temporary file for download
        <span class="cov0" title="0">tempFile, err := os.CreateTemp(h.tempDir, "download_*")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create temp file", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to prepare download"})
                return
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempFile.Name())
        defer tempFile.Close()

        // Download from SMB to temp file
        err = h.smbService.DownloadFile(fileInfo.SmbRoot, fileInfo.Path, tempFile.Name())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to download from SMB", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to download file"})
                return
        }</span>

        // Stream file to client
        <span class="cov0" title="0">c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", fileInfo.Name))
        c.Header("Content-Type", "application/octet-stream")
        c.Header("Content-Length", strconv.FormatInt(fileInfo.Size, 10))

        tempFile.Seek(0, 0)
        _, err = io.CopyBuffer(c.Writer, tempFile, make([]byte, h.chunkSize))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to stream file", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("File downloaded successfully", zap.String("file", fileInfo.Name), zap.Int64("id", id))</span>
}

// @Summary Download directory as archive
// @Description Download a directory and its contents as a compressed archive
// @Tags download
// @Param path path string true "Directory path"
// @Param format query string false "Archive format (zip, tar, tar.gz)" default(zip)
// @Produce application/octet-stream
// @Success 200 {file} binary
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/download/directory/{path} [get]
func (h *DownloadHandler) DownloadDirectory(c *gin.Context) <span class="cov0" title="0">{
        path := c.Param("path")
        if path == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Path is required"})
                return
        }</span>

        <span class="cov0" title="0">format := c.DefaultQuery("format", "zip")
        if format != "zip" &amp;&amp; format != "tar" &amp;&amp; format != "tar.gz" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid format. Supported: zip, tar, tar.gz"})
                return
        }</span>

        // Clean the path
        <span class="cov0" title="0">if strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                path = path[1:]
        }</span>

        // Get directory listing recursively
        <span class="cov0" title="0">files, err := h.getDirectoryContentsRecursive(path)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get directory contents", zap.String("path", path), zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to read directory"})
                return
        }</span>

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Directory not found or empty"})
                return
        }</span>

        // Check total size
        <span class="cov0" title="0">var totalSize int64
        for _, file := range files </span><span class="cov0" title="0">{
                totalSize += file.Size
        }</span>

        <span class="cov0" title="0">if totalSize &gt; h.maxArchiveSize </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":      "Directory too large for download",
                        "total_size": totalSize,
                        "max_size":   h.maxArchiveSize,
                })
                return
        }</span>

        // Create archive
        <span class="cov0" title="0">filename := filepath.Base(path) + "." + format
        c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))

        switch format </span>{
        case "zip":<span class="cov0" title="0">
                c.Header("Content-Type", "application/zip")
                h.createZipArchive(c.Writer, files)</span>
        case "tar":<span class="cov0" title="0">
                c.Header("Content-Type", "application/x-tar")
                h.createTarArchive(c.Writer, files, false)</span>
        case "tar.gz":<span class="cov0" title="0">
                c.Header("Content-Type", "application/gzip")
                h.createTarArchive(c.Writer, files, true)</span>
        }

        <span class="cov0" title="0">h.logger.Info("Directory downloaded successfully", zap.String("path", path), zap.String("format", format))</span>
}

// @Summary Create archive from multiple files
// @Description Create and download an archive containing specified files
// @Tags download
// @Accept json
// @Param request body models.DownloadRequest true "Download request"
// @Produce application/octet-stream
// @Success 200 {file} binary
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/download/archive [post]
func (h *DownloadHandler) DownloadArchive(c *gin.Context) <span class="cov0" title="0">{
        var req models.DownloadRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">if len(req.Paths) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "No paths specified"})
                return
        }</span>

        <span class="cov0" title="0">if req.Format == "" </span><span class="cov0" title="0">{
                req.Format = "zip"
        }</span>

        <span class="cov0" title="0">if req.Format != "zip" &amp;&amp; req.Format != "tar" &amp;&amp; req.Format != "tar.gz" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid format. Supported: zip, tar, tar.gz"})
                return
        }</span>

        // Get file information for all paths
        <span class="cov0" title="0">var files []models.FileInfo
        var totalSize int64

        for _, path := range req.Paths </span><span class="cov0" title="0">{
                // This is a simplified implementation - you'd need to implement path-to-ID conversion
                // or modify the catalog service to search by path
                fileList, err := h.getFilesByPath(path, req.SmbRoot)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to get files for path", zap.String("path", path), zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">for _, file := range fileList </span><span class="cov0" title="0">{
                        totalSize += file.Size
                        files = append(files, file)
                }</span>
        }

        <span class="cov0" title="0">if totalSize &gt; h.maxArchiveSize </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":      "Total size too large for download",
                        "total_size": totalSize,
                        "max_size":   h.maxArchiveSize,
                })
                return
        }</span>

        // Create archive
        <span class="cov0" title="0">filename := fmt.Sprintf("archive_%d.%s", time.Now().Unix(), req.Format)
        c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))

        switch req.Format </span>{
        case "zip":<span class="cov0" title="0">
                c.Header("Content-Type", "application/zip")
                h.createZipArchive(c.Writer, files)</span>
        case "tar":<span class="cov0" title="0">
                c.Header("Content-Type", "application/x-tar")
                h.createTarArchive(c.Writer, files, false)</span>
        case "tar.gz":<span class="cov0" title="0">
                c.Header("Content-Type", "application/gzip")
                h.createTarArchive(c.Writer, files, true)</span>
        }

        <span class="cov0" title="0">h.logger.Info("Archive downloaded successfully", zap.Int("file_count", len(files)), zap.String("format", req.Format))</span>
}

func (h *DownloadHandler) createZipArchive(w io.Writer, files []models.FileInfo) error <span class="cov0" title="0">{
        zipWriter := zip.NewWriter(w)
        defer zipWriter.Close()

        for _, file := range files </span><span class="cov0" title="0">{
                if file.IsDirectory </span><span class="cov0" title="0">{
                        continue</span> // Skip directories for now
                }

                // Download file to temp location
                <span class="cov0" title="0">tempFile, err := os.CreateTemp(h.tempDir, "zip_*")
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to create temp file for zip", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">err = h.smbService.DownloadFile(file.SmbRoot, file.Path, tempFile.Name())
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to download file for zip", zap.String("path", file.Path), zap.Error(err))
                        tempFile.Close()
                        os.Remove(tempFile.Name())
                        continue</span>
                }

                // Add to zip
                <span class="cov0" title="0">zipFile, err := zipWriter.Create(file.Path)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to create zip entry", zap.String("path", file.Path), zap.Error(err))
                        tempFile.Close()
                        os.Remove(tempFile.Name())
                        continue</span>
                }

                <span class="cov0" title="0">tempFile.Seek(0, 0)
                _, err = io.Copy(zipFile, tempFile)
                tempFile.Close()
                os.Remove(tempFile.Name())

                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to write zip entry", zap.String("path", file.Path), zap.Error(err))
                        continue</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (h *DownloadHandler) createTarArchive(w io.Writer, files []models.FileInfo, compress bool) error <span class="cov0" title="0">{
        var tarWriter *tar.Writer

        if compress </span><span class="cov0" title="0">{
                gzWriter := gzip.NewWriter(w)
                defer gzWriter.Close()
                tarWriter = tar.NewWriter(gzWriter)
        }</span> else<span class="cov0" title="0"> {
                tarWriter = tar.NewWriter(w)
        }</span>
        <span class="cov0" title="0">defer tarWriter.Close()

        for _, file := range files </span><span class="cov0" title="0">{
                if file.IsDirectory </span><span class="cov0" title="0">{
                        continue</span> // Skip directories for now
                }

                // Download file to temp location
                <span class="cov0" title="0">tempFile, err := os.CreateTemp(h.tempDir, "tar_*")
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to create temp file for tar", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">err = h.smbService.DownloadFile(file.SmbRoot, file.Path, tempFile.Name())
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to download file for tar", zap.String("path", file.Path), zap.Error(err))
                        tempFile.Close()
                        os.Remove(tempFile.Name())
                        continue</span>
                }

                // Create tar header
                <span class="cov0" title="0">header := &amp;tar.Header{
                        Name:    file.Path,
                        Size:    file.Size,
                        Mode:    0644,
                        ModTime: file.LastModified,
                }

                err = tarWriter.WriteHeader(header)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to write tar header", zap.String("path", file.Path), zap.Error(err))
                        tempFile.Close()
                        os.Remove(tempFile.Name())
                        continue</span>
                }

                <span class="cov0" title="0">tempFile.Seek(0, 0)
                _, err = io.Copy(tarWriter, tempFile)
                tempFile.Close()
                os.Remove(tempFile.Name())

                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to write tar entry", zap.String("path", file.Path), zap.Error(err))
                        continue</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper functions
func (h *DownloadHandler) getDirectoryContentsRecursive(path string) ([]models.FileInfo, error) <span class="cov0" title="0">{
        // This is a placeholder implementation
        // You would need to implement recursive directory traversal
        // using your catalog service
        return []models.FileInfo{}, nil
}</span>

func (h *DownloadHandler) getFilesByPath(path, smbRoot string) ([]models.FileInfo, error) <span class="cov0" title="0">{
        // This is a placeholder implementation
        // You would need to implement path-based file lookup
        return []models.FileInfo{}, nil
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gorilla/mux"
        "go.uber.org/zap"

        "catalogizer/internal/services"
)

type LocalizationHandlers struct {
        logger              *zap.Logger
        localizationService *services.LocalizationService
}

func NewLocalizationHandlers(
        logger *zap.Logger,
        localizationService *services.LocalizationService,
) *LocalizationHandlers <span class="cov0" title="0">{
        return &amp;LocalizationHandlers{
                logger:              logger,
                localizationService: localizationService,
        }
}</span>

func (h *LocalizationHandlers) RegisterRoutes(router *mux.Router) <span class="cov0" title="0">{
        api := router.PathPrefix("/api/v1").Subrouter()

        // Installation Wizard Routes
        api.HandleFunc("/wizard/localization/defaults", h.GetWizardDefaults).Methods("GET", "OPTIONS")
        api.HandleFunc("/wizard/localization/setup", h.SetupWizardLocalization).Methods("POST", "OPTIONS")

        // JSON Configuration Routes
        api.HandleFunc("/wizard/configuration/export", h.ExportConfiguration).Methods("POST", "OPTIONS")
        api.HandleFunc("/wizard/configuration/import", h.ImportConfiguration).Methods("POST", "OPTIONS")
        api.HandleFunc("/wizard/configuration/validate", h.ValidateConfiguration).Methods("POST", "OPTIONS")
        api.HandleFunc("/wizard/configuration/edit", h.EditConfiguration).Methods("POST", "OPTIONS")
        api.HandleFunc("/wizard/configuration/templates", h.GetConfigurationTemplates).Methods("GET", "OPTIONS")

        // Localization Management Routes
        api.HandleFunc("/localization", h.GetUserLocalization).Methods("GET", "OPTIONS")
        api.HandleFunc("/localization", h.UpdateUserLocalization).Methods("PUT", "OPTIONS")
        api.HandleFunc("/localization/languages", h.GetSupportedLanguages).Methods("GET", "OPTIONS")
        api.HandleFunc("/localization/languages/{languageCode}", h.GetLanguageProfile).Methods("GET", "OPTIONS")
        api.HandleFunc("/localization/preferences/{contentType}", h.GetContentLanguagePreferences).Methods("GET", "OPTIONS")
        api.HandleFunc("/localization/stats", h.GetLocalizationStats).Methods("GET", "OPTIONS")

        // Content-specific Routes
        api.HandleFunc("/localization/detect", h.DetectLanguage).Methods("POST", "OPTIONS")
        api.HandleFunc("/localization/check-support", h.CheckLanguageSupport).Methods("POST", "OPTIONS")
        api.HandleFunc("/localization/format-datetime", h.FormatDateTime).Methods("POST", "OPTIONS")

        // Add CORS middleware
        api.Use(h.corsMiddleware)
}</span>

// Installation Wizard Handlers

func (h *LocalizationHandlers) GetWizardDefaults(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Debug("Getting wizard localization defaults")

        userAgent := r.Header.Get("User-Agent")
        acceptLanguage := r.Header.Get("Accept-Language")

        detectedLanguage := h.localizationService.DetectUserLanguage(r.Context(), userAgent, acceptLanguage)
        defaults := h.localizationService.GetWizardDefaults(r.Context(), detectedLanguage)

        h.sendSuccess(w, map[string]interface{}{
                "detected_language": detectedLanguage,
                "defaults":          defaults,
        })
}</span>

func (h *LocalizationHandlers) SetupWizardLocalization(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Info("Setting up wizard localization")

        var req services.WizardLocalizationStep
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.UserID == 0 </span><span class="cov0" title="0">{
                userID := h.getUserID(r)
                if userID == 0 </span><span class="cov0" title="0">{
                        h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">req.UserID = userID</span>
        }

        <span class="cov0" title="0">if req.PrimaryLanguage == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Primary language is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">localization, err := h.localizationService.SetupUserLocalization(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to setup user localization", zap.Error(err))
                h.sendError(w, "Failed to setup localization preferences", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]interface{}{
                "localization": localization,
                "message":      "Localization preferences configured successfully",
        })</span>
}

// Localization Management Handlers

func (h *LocalizationHandlers) GetUserLocalization(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">localization, err := h.localizationService.GetUserLocalization(r.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get user localization", zap.Error(err))
                h.sendError(w, "Failed to get localization preferences", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, localization)</span>
}

func (h *LocalizationHandlers) UpdateUserLocalization(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var updates map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;updates); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.localizationService.UpdateUserLocalization(r.Context(), userID, updates)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update user localization", zap.Error(err))
                h.sendError(w, "Failed to update localization preferences", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Localization preferences updated successfully"})</span>
}

func (h *LocalizationHandlers) GetSupportedLanguages(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Debug("Getting supported languages")

        languages, err := h.localizationService.GetSupportedLanguages(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get supported languages", zap.Error(err))
                h.sendError(w, "Failed to get supported languages", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, languages)</span>
}

func (h *LocalizationHandlers) GetLanguageProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        languageCode := mux.Vars(r)["languageCode"]

        profile, err := h.localizationService.GetLanguageProfile(r.Context(), languageCode)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get language profile",
                        zap.String("language", languageCode),
                        zap.Error(err))
                h.sendError(w, "Language not supported", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, profile)</span>
}

func (h *LocalizationHandlers) GetContentLanguagePreferences(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">contentType := mux.Vars(r)["contentType"]

        languages, err := h.localizationService.GetPreferredLanguagesForContent(r.Context(), userID, contentType)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get content language preferences",
                        zap.Int64("user_id", userID),
                        zap.String("content_type", contentType),
                        zap.Error(err))
                h.sendError(w, "Failed to get language preferences", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">autoTranslate, _ := h.localizationService.ShouldAutoTranslate(r.Context(), userID, contentType)
        autoDownload, _ := h.localizationService.ShouldAutoDownload(r.Context(), userID, contentType)

        h.sendSuccess(w, map[string]interface{}{
                "languages":      languages,
                "auto_translate": autoTranslate,
                "auto_download":  autoDownload,
        })</span>
}

func (h *LocalizationHandlers) GetLocalizationStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Debug("Getting localization statistics")

        stats, err := h.localizationService.GetLocalizationStats(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get localization stats", zap.Error(err))
                h.sendError(w, "Failed to get localization statistics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, stats)</span>
}

// JSON Configuration Handlers

func (h *LocalizationHandlers) ExportConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ConfigType  string   `json:"config_type"`
                Description string   `json:"description"`
                Tags        []string `json:"tags"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ConfigType == "" </span><span class="cov0" title="0">{
                req.ConfigType = "full"
        }</span>

        <span class="cov0" title="0">config, err := h.localizationService.ExportConfiguration(r.Context(), userID, req.ConfigType, req.Description, req.Tags)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to export configuration",
                        zap.Int64("user_id", userID),
                        zap.String("config_type", req.ConfigType),
                        zap.Error(err))
                h.sendError(w, "Failed to export configuration", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, config)</span>
}

func (h *LocalizationHandlers) ImportConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ConfigJSON string          `json:"config_json"`
                Options    map[string]bool `json:"options"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ConfigJSON == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Configuration JSON is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Options == nil </span><span class="cov0" title="0">{
                req.Options = map[string]bool{
                        "overwrite_existing": false,
                        "backup_current":     true,
                        "validate_only":      false,
                }
        }</span>

        <span class="cov0" title="0">result, err := h.localizationService.ImportConfiguration(r.Context(), userID, req.ConfigJSON, req.Options)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to import configuration",
                        zap.Int64("user_id", userID),
                        zap.Error(err))
                h.sendError(w, fmt.Sprintf("Failed to import configuration: %v", err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, result)</span>
}

func (h *LocalizationHandlers) ValidateConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                ConfigJSON string `json:"config_json"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ConfigJSON == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Configuration JSON is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">validation, err := h.localizationService.ValidateConfigurationJSON(r.Context(), req.ConfigJSON)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to validate configuration", zap.Error(err))
                h.sendError(w, "Failed to validate configuration", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, validation)</span>
}

func (h *LocalizationHandlers) EditConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ConfigJSON string                 `json:"config_json"`
                Edits      map[string]interface{} `json:"edits"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ConfigJSON == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Configuration JSON is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Edits == nil </span><span class="cov0" title="0">{
                h.sendError(w, "Edits are required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">editedConfig, err := h.localizationService.EditConfiguration(r.Context(), userID, req.ConfigJSON, req.Edits)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to edit configuration",
                        zap.Int64("user_id", userID),
                        zap.Error(err))
                h.sendError(w, fmt.Sprintf("Failed to edit configuration: %v", err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]interface{}{
                "edited_config": editedConfig,
                "message":       "Configuration edited successfully",
        })</span>
}

func (h *LocalizationHandlers) GetConfigurationTemplates(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Debug("Getting configuration templates")

        // Get all template types
        templateTypes := []string{"localization", "media", "playlists", "full"}
        templates := make(map[string]interface{})

        for _, templateType := range templateTypes </span><span class="cov0" title="0">{
                template, err := h.localizationService.GetConfigurationTemplate(r.Context(), templateType)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Warn("Failed to get template",
                                zap.String("type", templateType),
                                zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">templates[templateType] = template</span>
        }

        <span class="cov0" title="0">h.sendSuccess(w, map[string]interface{}{
                "templates": templates,
                "count":     len(templates),
        })</span>
}

// Content-specific Handlers

func (h *LocalizationHandlers) DetectLanguage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                UserAgent      string `json:"user_agent"`
                AcceptLanguage string `json:"accept_language"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.UserAgent == "" </span><span class="cov0" title="0">{
                req.UserAgent = r.Header.Get("User-Agent")
        }</span>
        <span class="cov0" title="0">if req.AcceptLanguage == "" </span><span class="cov0" title="0">{
                req.AcceptLanguage = r.Header.Get("Accept-Language")
        }</span>

        <span class="cov0" title="0">detectedLanguage := h.localizationService.DetectUserLanguage(r.Context(), req.UserAgent, req.AcceptLanguage)

        h.sendSuccess(w, map[string]interface{}{
                "detected_language": detectedLanguage,
                "confidence":        1.0,
        })</span>
}

func (h *LocalizationHandlers) CheckLanguageSupport(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                LanguageCode string `json:"language_code"`
                ContentType  string `json:"content_type"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.LanguageCode == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Language code is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ContentType == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Content type is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">supported := h.localizationService.IsLanguageSupported(r.Context(), req.LanguageCode, req.ContentType)

        profile, err := h.localizationService.GetLanguageProfile(r.Context(), req.LanguageCode)
        var qualityRating float64
        var providers []string

        if err == nil </span><span class="cov0" title="0">{
                qualityRating = profile.QualityRating
                providers = profile.SupportedBy
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]interface{}{
                "supported":      supported,
                "language_code":  req.LanguageCode,
                "content_type":   req.ContentType,
                "quality_rating": qualityRating,
                "providers":      providers,
        })</span>
}

func (h *LocalizationHandlers) FormatDateTime(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Timestamp string `json:"timestamp"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Timestamp == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Timestamp is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">timestamp, err := parseTimestamp(req.Timestamp)
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid timestamp format", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">formatted, err := h.localizationService.FormatDateTimeForUser(r.Context(), userID, timestamp)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to format datetime", zap.Error(err))
                h.sendError(w, "Failed to format datetime", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]interface{}{
                "original":  req.Timestamp,
                "formatted": formatted,
                "timezone":  timestamp.Location().String(),
        })</span>
}

// Helper Methods

func (h *LocalizationHandlers) sendSuccess(w http.ResponseWriter, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(APIResponse{
                Success: true,
                Data:    data,
        })
}</span>

func (h *LocalizationHandlers) sendError(w http.ResponseWriter, message string, statusCode int) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(APIResponse{
                Success: false,
                Error:   message,
        })
}</span>

func (h *LocalizationHandlers) getUserID(r *http.Request) int64 <span class="cov0" title="0">{
        userIDStr := r.Header.Get("X-User-ID")
        if userIDStr == "" </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">userID, err := strconv.ParseInt(userIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return userID</span>
}

func (h *LocalizationHandlers) corsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-User-ID, Accept-Language")
                w.Header().Set("Access-Control-Max-Age", "86400")

                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

func parseTimestamp(timestampStr string) (time.Time, error) <span class="cov0" title="0">{
        formats := []string{
                "2006-01-02T15:04:05Z",
                "2006-01-02T15:04:05.000Z",
                "2006-01-02T15:04:05-07:00",
                "2006-01-02 15:04:05",
                "2006-01-02",
                "1136239445", // Unix timestamp
        }

        for _, format := range formats </span><span class="cov0" title="0">{
                if timestamp, err := time.Parse(format, timestampStr); err == nil </span><span class="cov0" title="0">{
                        return timestamp, nil
                }</span>
        }

        // Try parsing as Unix timestamp
        <span class="cov0" title="0">if unix, err := strconv.ParseInt(timestampStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                return time.Unix(unix, 0), nil
        }</span>

        <span class="cov0" title="0">return time.Time{}, fmt.Errorf("unable to parse timestamp: %s", timestampStr)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package handlers

import (
        "catalogizer/internal/media/analyzer"
        "catalogizer/internal/media/database"
        "catalogizer/internal/media/models"
        "database/sql"
        "encoding/json"
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// MediaHandler handles media metadata endpoints
type MediaHandler struct {
        mediaDB  *database.MediaDatabase
        analyzer *analyzer.MediaAnalyzer
        logger   *zap.Logger
}

// NewMediaHandler creates a new media handler
func NewMediaHandler(mediaDB *database.MediaDatabase, analyzer *analyzer.MediaAnalyzer, logger *zap.Logger) *MediaHandler <span class="cov0" title="0">{
        return &amp;MediaHandler{
                mediaDB:  mediaDB,
                analyzer: analyzer,
                logger:   logger,
        }
}</span>

// @Summary Get all media types
// @Description Get list of all supported media types
// @Tags media
// @Produce json
// @Success 200 {array} models.MediaType
// @Failure 500 {object} map[string]string
// @Router /api/v1/media/types [get]
func (h *MediaHandler) GetMediaTypes(c *gin.Context) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, detection_patterns, metadata_providers, created_at, updated_at
                FROM media_types
                ORDER BY name
        `

        rows, err := h.mediaDB.GetDB().Query(query)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get media types", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve media types"})
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var mediaTypes []models.MediaType
        for rows.Next() </span><span class="cov0" title="0">{
                var mt models.MediaType
                var patternsJSON, providersJSON string

                err := rows.Scan(
                        &amp;mt.ID, &amp;mt.Name, &amp;mt.Description, &amp;patternsJSON, &amp;providersJSON,
                        &amp;mt.CreatedAt, &amp;mt.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to scan media type", zap.Error(err))
                        continue</span>
                }

                // Parse JSON fields
                <span class="cov0" title="0">json.Unmarshal([]byte(patternsJSON), &amp;mt.DetectionPatterns)
                json.Unmarshal([]byte(providersJSON), &amp;mt.MetadataProviders)

                mediaTypes = append(mediaTypes, mt)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "media_types": mediaTypes,
                "count":       len(mediaTypes),
        })</span>
}

// @Summary Search media items
// @Description Search for media items with various filters
// @Tags media
// @Param query query string false "Search query"
// @Param media_types query string false "Comma-separated media type names"
// @Param year query int false "Specific year"
// @Param year_from query int false "Year range from"
// @Param year_to query int false "Year range to"
// @Param genre query string false "Comma-separated genres"
// @Param min_rating query number false "Minimum rating"
// @Param has_externals query bool false "Has external metadata"
// @Param quality query string false "Comma-separated quality levels"
// @Param smb_roots query string false "Comma-separated SMB roots"
// @Param watched_status query string false "Watched status"
// @Param sort_by query string false "Sort field" default(title)
// @Param sort_order query string false "Sort order" default(asc)
// @Param limit query int false "Limit results" default(50)
// @Param offset query int false "Offset for pagination" default(0)
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/media/search [get]
func (h *MediaHandler) SearchMedia(c *gin.Context) <span class="cov0" title="0">{
        var req models.MediaSearchRequest

        // Parse query parameters
        req.Query = c.Query("query")
        req.SortBy = c.DefaultQuery("sort_by", "title")
        req.SortOrder = c.DefaultQuery("sort_order", "asc")
        req.Limit, _ = strconv.Atoi(c.DefaultQuery("limit", "50"))
        req.Offset, _ = strconv.Atoi(c.DefaultQuery("offset", "0"))

        // Parse media types
        if mediaTypesStr := c.Query("media_types"); mediaTypesStr != "" </span><span class="cov0" title="0">{
                req.MediaTypes = strings.Split(mediaTypesStr, ",")
        }</span>

        // Parse year
        <span class="cov0" title="0">if yearStr := c.Query("year"); yearStr != "" </span><span class="cov0" title="0">{
                if year, err := strconv.Atoi(yearStr); err == nil </span><span class="cov0" title="0">{
                        req.Year = &amp;year
                }</span>
        }

        // Parse year range
        <span class="cov0" title="0">if yearFromStr := c.Query("year_from"); yearFromStr != "" </span><span class="cov0" title="0">{
                if yearFrom, err := strconv.Atoi(yearFromStr); err == nil </span><span class="cov0" title="0">{
                        if req.YearRange == nil </span><span class="cov0" title="0">{
                                req.YearRange = &amp;models.YearRange{}
                        }</span>
                        <span class="cov0" title="0">req.YearRange.From = yearFrom</span>
                }
        }
        <span class="cov0" title="0">if yearToStr := c.Query("year_to"); yearToStr != "" </span><span class="cov0" title="0">{
                if yearTo, err := strconv.Atoi(yearToStr); err == nil </span><span class="cov0" title="0">{
                        if req.YearRange == nil </span><span class="cov0" title="0">{
                                req.YearRange = &amp;models.YearRange{}
                        }</span>
                        <span class="cov0" title="0">req.YearRange.To = yearTo</span>
                }
        }

        // Parse other filters
        <span class="cov0" title="0">if genreStr := c.Query("genre"); genreStr != "" </span><span class="cov0" title="0">{
                req.Genre = strings.Split(genreStr, ",")
        }</span>
        <span class="cov0" title="0">if qualityStr := c.Query("quality"); qualityStr != "" </span><span class="cov0" title="0">{
                req.Quality = strings.Split(qualityStr, ",")
        }</span>
        <span class="cov0" title="0">if smbRootsStr := c.Query("smb_roots"); smbRootsStr != "" </span><span class="cov0" title="0">{
                req.SmbRoots = strings.Split(smbRootsStr, ",")
        }</span>

        <span class="cov0" title="0">if minRatingStr := c.Query("min_rating"); minRatingStr != "" </span><span class="cov0" title="0">{
                if minRating, err := strconv.ParseFloat(minRatingStr, 64); err == nil </span><span class="cov0" title="0">{
                        req.MinRating = &amp;minRating
                }</span>
        }

        <span class="cov0" title="0">if hasExternalsStr := c.Query("has_externals"); hasExternalsStr != "" </span><span class="cov0" title="0">{
                hasExternals := hasExternalsStr == "true"
                req.HasExternals = &amp;hasExternals
        }</span>

        <span class="cov0" title="0">req.WatchedStatus = &amp;[]string{c.Query("watched_status")}[0]

        // Build query
        baseQuery := `
                SELECT mi.id, mi.media_type_id, mi.title, mi.original_title, mi.year, mi.description,
                       mi.genre, mi.director, mi.cast_crew, mi.rating, mi.runtime, mi.language, mi.country,
                       mi.status, mi.first_detected, mi.last_updated,
                       mt.name as media_type_name, mt.description as media_type_description
                FROM media_items mi
                JOIN media_types mt ON mi.media_type_id = mt.id
                WHERE 1=1
        `

        countQuery := `
                SELECT COUNT(*)
                FROM media_items mi
                JOIN media_types mt ON mi.media_type_id = mt.id
                WHERE 1=1
        `

        var conditions []string
        var args []interface{}

        // Add search conditions
        if req.Query != "" </span><span class="cov0" title="0">{
                conditions = append(conditions, "(mi.title LIKE ? OR mi.original_title LIKE ?)")
                searchTerm := "%" + req.Query + "%"
                args = append(args, searchTerm, searchTerm)
        }</span>

        <span class="cov0" title="0">if len(req.MediaTypes) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := strings.Repeat("?,", len(req.MediaTypes))
                placeholders = placeholders[:len(placeholders)-1]
                conditions = append(conditions, "mt.name IN ("+placeholders+")")
                for _, mt := range req.MediaTypes </span><span class="cov0" title="0">{
                        args = append(args, mt)
                }</span>
        }

        <span class="cov0" title="0">if req.Year != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "mi.year = ?")
                args = append(args, *req.Year)
        }</span>

        <span class="cov0" title="0">if req.YearRange != nil </span><span class="cov0" title="0">{
                if req.YearRange.From &gt; 0 </span><span class="cov0" title="0">{
                        conditions = append(conditions, "mi.year &gt;= ?")
                        args = append(args, req.YearRange.From)
                }</span>
                <span class="cov0" title="0">if req.YearRange.To &gt; 0 </span><span class="cov0" title="0">{
                        conditions = append(conditions, "mi.year &lt;= ?")
                        args = append(args, req.YearRange.To)
                }</span>
        }

        <span class="cov0" title="0">if req.MinRating != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "mi.rating &gt;= ?")
                args = append(args, *req.MinRating)
        }</span>

        <span class="cov0" title="0">if req.HasExternals != nil &amp;&amp; *req.HasExternals </span><span class="cov0" title="0">{
                conditions = append(conditions, "EXISTS (SELECT 1 FROM external_metadata em WHERE em.media_item_id = mi.id)")
        }</span>

        // Build final queries
        <span class="cov0" title="0">whereClause := ""
        if len(conditions) &gt; 0 </span><span class="cov0" title="0">{
                whereClause = " AND " + strings.Join(conditions, " AND ")
        }</span>

        // Get total count
        <span class="cov0" title="0">var total int64
        err := h.mediaDB.GetDB().QueryRow(countQuery+whereClause, args...).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to count search results", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Search failed"})
                return
        }</span>

        // Add sorting and pagination
        <span class="cov0" title="0">finalQuery := baseQuery + whereClause
        switch req.SortBy </span>{
        case "title":<span class="cov0" title="0">
                finalQuery += " ORDER BY mi.title"</span>
        case "year":<span class="cov0" title="0">
                finalQuery += " ORDER BY mi.year"</span>
        case "rating":<span class="cov0" title="0">
                finalQuery += " ORDER BY mi.rating"</span>
        case "created":<span class="cov0" title="0">
                finalQuery += " ORDER BY mi.first_detected"</span>
        default:<span class="cov0" title="0">
                finalQuery += " ORDER BY mi.title"</span>
        }

        <span class="cov0" title="0">if req.SortOrder == "desc" </span><span class="cov0" title="0">{
                finalQuery += " DESC"
        }</span> else<span class="cov0" title="0"> {
                finalQuery += " ASC"
        }</span>

        <span class="cov0" title="0">finalQuery += " LIMIT ? OFFSET ?"
        args = append(args, req.Limit, req.Offset)

        // Execute search
        rows, err := h.mediaDB.GetDB().Query(finalQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to execute search", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Search failed"})
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var mediaItems []models.MediaItem
        for rows.Next() </span><span class="cov0" title="0">{
                var item models.MediaItem
                var mediaType models.MediaType
                var genreJSON, castCrewJSON string

                err := rows.Scan(
                        &amp;item.ID, &amp;item.MediaTypeID, &amp;item.Title, &amp;item.OriginalTitle, &amp;item.Year,
                        &amp;item.Description, &amp;genreJSON, &amp;item.Director, &amp;castCrewJSON, &amp;item.Rating,
                        &amp;item.Runtime, &amp;item.Language, &amp;item.Country, &amp;item.Status,
                        &amp;item.FirstDetected, &amp;item.LastUpdated,
                        &amp;mediaType.Name, &amp;mediaType.Description,
                )
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to scan media item", zap.Error(err))
                        continue</span>
                }

                // Parse JSON fields
                <span class="cov0" title="0">json.Unmarshal([]byte(genreJSON), &amp;item.Genre)
                json.Unmarshal([]byte(castCrewJSON), &amp;item.CastCrew)

                item.MediaType = &amp;mediaType
                mediaItems = append(mediaItems, item)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "media_items": mediaItems,
                "total":       total,
                "count":       len(mediaItems),
                "limit":       req.Limit,
                "offset":      req.Offset,
                "has_more":    int64(req.Offset+req.Limit) &lt; total,
        })</span>
}

// @Summary Get media item details
// @Description Get detailed information about a specific media item
// @Tags media
// @Param id path int true "Media Item ID"
// @Produce json
// @Success 200 {object} models.MediaItem
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/media/{id} [get]
func (h *MediaHandler) GetMediaItem(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid media item ID"})
                return
        }</span>

        <span class="cov0" title="0">mediaItem, err := h.getMediaItemWithDetails(id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "Media item not found"})
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("Failed to get media item", zap.Int64("id", id), zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve media item"})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, mediaItem)</span>
}

// @Summary Analyze directory
// @Description Trigger analysis of a specific directory
// @Tags media
// @Accept json
// @Param request body object true "Analysis request"
// @Produce json
// @Success 202 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/media/analyze [post]
func (h *MediaHandler) AnalyzeDirectory(c *gin.Context) <span class="cov0" title="0">{
        var request struct {
                DirectoryPath string `json:"directory_path" binding:"required"`
                SmbRoot       string `json:"smb_root" binding:"required"`
                Priority      int    `json:"priority"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">if request.Priority == 0 </span><span class="cov0" title="0">{
                request.Priority = 5 // Default priority
        }</span>

        <span class="cov0" title="0">err := h.analyzer.AnalyzeDirectory(c.Request.Context(), request.DirectoryPath, request.SmbRoot, request.Priority)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to queue directory analysis",
                        zap.String("directory", request.DirectoryPath),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to queue analysis"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusAccepted, gin.H{
                "message":        "Directory analysis queued",
                "directory_path": request.DirectoryPath,
                "smb_root":       request.SmbRoot,
                "priority":       request.Priority,
        })</span>
}

// @Summary Get media statistics
// @Description Get statistics about media items and analysis
// @Tags media
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 500 {object} map[string]string
// @Router /api/v1/media/stats [get]
func (h *MediaHandler) GetMediaStats(c *gin.Context) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Database stats
        dbStats, err := h.mediaDB.GetStats()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get database stats", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["database"] = dbStats
        }</span>

        // Media type distribution
        <span class="cov0" title="0">typeDistribution, err := h.getMediaTypeDistribution()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get media type distribution", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["media_type_distribution"] = typeDistribution
        }</span>

        // Quality distribution
        <span class="cov0" title="0">qualityDistribution, err := h.getQualityDistribution()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get quality distribution", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["quality_distribution"] = qualityDistribution
        }</span>

        // Recent activity
        <span class="cov0" title="0">recentActivity, err := h.getRecentActivity()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get recent activity", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["recent_activity"] = recentActivity
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, stats)</span>
}

// Helper methods

func (h *MediaHandler) getMediaItemWithDetails(id int64) (*models.MediaItem, error) <span class="cov0" title="0">{
        // Get basic media item
        query := `
                SELECT mi.id, mi.media_type_id, mi.title, mi.original_title, mi.year, mi.description,
                       mi.genre, mi.director, mi.cast_crew, mi.rating, mi.runtime, mi.language, mi.country,
                       mi.status, mi.first_detected, mi.last_updated,
                       mt.name, mt.description
                FROM media_items mi
                JOIN media_types mt ON mi.media_type_id = mt.id
                WHERE mi.id = ?
        `

        var item models.MediaItem
        var mediaType models.MediaType
        var genreJSON, castCrewJSON string

        err := h.mediaDB.GetDB().QueryRow(query, id).Scan(
                &amp;item.ID, &amp;item.MediaTypeID, &amp;item.Title, &amp;item.OriginalTitle, &amp;item.Year,
                &amp;item.Description, &amp;genreJSON, &amp;item.Director, &amp;castCrewJSON, &amp;item.Rating,
                &amp;item.Runtime, &amp;item.Language, &amp;item.Country, &amp;item.Status,
                &amp;item.FirstDetected, &amp;item.LastUpdated,
                &amp;mediaType.Name, &amp;mediaType.Description,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse JSON fields
        <span class="cov0" title="0">json.Unmarshal([]byte(genreJSON), &amp;item.Genre)
        json.Unmarshal([]byte(castCrewJSON), &amp;item.CastCrew)
        item.MediaType = &amp;mediaType

        // Get external metadata
        item.ExternalMetadata, _ = h.getExternalMetadata(id)

        // Get files
        item.Files, _ = h.getMediaFiles(id)

        // Get user metadata
        item.UserMetadata, _ = h.getUserMetadata(id)

        return &amp;item, nil</span>
}

func (h *MediaHandler) getExternalMetadata(mediaItemID int64) ([]models.ExternalMetadata, error) <span class="cov0" title="0">{
        query := `
                SELECT id, media_item_id, provider, external_id, data, rating, review_url, cover_url, trailer_url, last_fetched
                FROM external_metadata
                WHERE media_item_id = ?
                ORDER BY provider
        `

        rows, err := h.mediaDB.GetDB().Query(query, mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var metadata []models.ExternalMetadata
        for rows.Next() </span><span class="cov0" title="0">{
                var em models.ExternalMetadata
                err := rows.Scan(
                        &amp;em.ID, &amp;em.MediaItemID, &amp;em.Provider, &amp;em.ExternalID, &amp;em.Data,
                        &amp;em.Rating, &amp;em.ReviewURL, &amp;em.CoverURL, &amp;em.TrailerURL, &amp;em.LastFetched,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">metadata = append(metadata, em)</span>
        }

        <span class="cov0" title="0">return metadata, nil</span>
}

func (h *MediaHandler) getMediaFiles(mediaItemID int64) ([]models.MediaFile, error) <span class="cov0" title="0">{
        query := `
                SELECT id, media_item_id, file_path, smb_root, filename, file_size, file_extension,
                       quality_info, language, subtitle_tracks, audio_tracks, duration, checksum,
                       virtual_smb_link, direct_smb_link, last_verified, created_at
                FROM media_files
                WHERE media_item_id = ?
                ORDER BY filename
        `

        rows, err := h.mediaDB.GetDB().Query(query, mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var files []models.MediaFile
        for rows.Next() </span><span class="cov0" title="0">{
                var mf models.MediaFile
                var qualityInfoJSON, subtitleTracksJSON, audioTracksJSON string

                err := rows.Scan(
                        &amp;mf.ID, &amp;mf.MediaItemID, &amp;mf.FilePath, &amp;mf.SmbRoot, &amp;mf.Filename,
                        &amp;mf.FileSize, &amp;mf.FileExtension, &amp;qualityInfoJSON, &amp;mf.Language,
                        &amp;subtitleTracksJSON, &amp;audioTracksJSON, &amp;mf.Duration, &amp;mf.Checksum,
                        &amp;mf.VirtualSmbLink, &amp;mf.DirectSmbLink, &amp;mf.LastVerified, &amp;mf.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse JSON fields
                <span class="cov0" title="0">json.Unmarshal([]byte(qualityInfoJSON), &amp;mf.QualityInfo)
                json.Unmarshal([]byte(subtitleTracksJSON), &amp;mf.SubtitleTracks)
                json.Unmarshal([]byte(audioTracksJSON), &amp;mf.AudioTracks)

                files = append(files, mf)</span>
        }

        <span class="cov0" title="0">return files, nil</span>
}

func (h *MediaHandler) getUserMetadata(mediaItemID int64) (*models.UserMetadata, error) <span class="cov0" title="0">{
        query := `
                SELECT id, media_item_id, user_rating, watched_status, watched_date, personal_notes, tags, favorite, created_at, updated_at
                FROM user_metadata
                WHERE media_item_id = ?
        `

        var um models.UserMetadata
        var tagsJSON string

        err := h.mediaDB.GetDB().QueryRow(query, mediaItemID).Scan(
                &amp;um.ID, &amp;um.MediaItemID, &amp;um.UserRating, &amp;um.WatchedStatus, &amp;um.WatchedDate,
                &amp;um.PersonalNotes, &amp;tagsJSON, &amp;um.Favorite, &amp;um.CreatedAt, &amp;um.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">json.Unmarshal([]byte(tagsJSON), &amp;um.Tags)
        return &amp;um, nil</span>
}

func (h *MediaHandler) getMediaTypeDistribution() (map[string]int, error) <span class="cov0" title="0">{
        query := `
                SELECT mt.name, COUNT(mi.id) as count
                FROM media_types mt
                LEFT JOIN media_items mi ON mt.id = mi.media_type_id
                GROUP BY mt.id, mt.name
                ORDER BY count DESC
        `

        rows, err := h.mediaDB.GetDB().Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        distribution := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var mediaType string
                var count int
                if err := rows.Scan(&amp;mediaType, &amp;count); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">distribution[mediaType] = count</span>
        }

        <span class="cov0" title="0">return distribution, nil</span>
}

func (h *MediaHandler) getQualityDistribution() (map[string]int, error) <span class="cov0" title="0">{
        // This would analyze the quality_info JSON fields
        // Simplified implementation for now
        return map[string]int{
                "4K/UHD": 0,
                "1080p":  0,
                "720p":   0,
                "Other":  0,
        }, nil
}</span>

func (h *MediaHandler) getRecentActivity() (map[string]interface{}, error) <span class="cov0" title="0">{
        activity := make(map[string]interface{})

        // Recent analyses
        var recentAnalyses int
        err := h.mediaDB.GetDB().QueryRow(
                "SELECT COUNT(*) FROM directory_analysis WHERE last_analyzed &gt; datetime('now', '-24 hours')",
        ).Scan(&amp;recentAnalyses)
        if err == nil </span><span class="cov0" title="0">{
                activity["analyses_24h"] = recentAnalyses
        }</span>

        // Recent media items
        <span class="cov0" title="0">var recentItems int
        err = h.mediaDB.GetDB().QueryRow(
                "SELECT COUNT(*) FROM media_items WHERE first_detected &gt; datetime('now', '-24 hours')",
        ).Scan(&amp;recentItems)
        if err == nil </span><span class="cov0" title="0">{
                activity["new_items_24h"] = recentItems
        }</span>

        // Recent metadata updates
        <span class="cov0" title="0">var recentMetadata int
        err = h.mediaDB.GetDB().QueryRow(
                "SELECT COUNT(*) FROM external_metadata WHERE last_fetched &gt; datetime('now', '-24 hours')",
        ).Scan(&amp;recentMetadata)
        if err == nil </span><span class="cov0" title="0">{
                activity["metadata_updates_24h"] = recentMetadata
        }</span>

        <span class="cov0" title="0">return activity, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "time"

        "github.com/gorilla/mux"
        "go.uber.org/zap"

        "catalogizer/internal/services"
)

type MediaPlayerHandlers struct {
        logger             *zap.Logger
        musicPlayerService *services.MusicPlayerService
        videoPlayerService *services.VideoPlayerService
        playlistService    *services.PlaylistService
        positionService    *services.PlaybackPositionService
        subtitleService    *services.SubtitleService
        lyricsService      *services.LyricsService
        coverArtService    *services.CoverArtService
        translationService *services.TranslationService
}

type APIResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Message string      `json:"message,omitempty"`
}

type PlaybackSessionResponse struct {
        SessionID      string                   `json:"session_id"`
        CurrentTrack   *services.MusicTrack     `json:"current_track,omitempty"`
        CurrentVideo   *services.VideoContent   `json:"current_video,omitempty"`
        PlaybackState  services.PlaybackState   `json:"playback_state"`
        Position       int64                    `json:"position"`
        Duration       int64                    `json:"duration"`
        Volume         float64                  `json:"volume"`
        IsMuted        bool                     `json:"is_muted"`
        PlaybackSpeed  float64                  `json:"playback_speed,omitempty"`
        Queue          interface{}              `json:"queue,omitempty"`
        QueueIndex     int                      `json:"queue_index,omitempty"`
        RepeatMode     string                   `json:"repeat_mode,omitempty"`
        ShuffleEnabled bool                     `json:"shuffle_enabled,omitempty"`
        Subtitles      []services.SubtitleTrack `json:"subtitles,omitempty"`
        AudioTracks    []services.AudioTrack    `json:"audio_tracks,omitempty"`
        Chapters       []services.Chapter       `json:"chapters,omitempty"`
        Lyrics         *services.LyricsData     `json:"lyrics,omitempty"`
        CoverArt       *services.CoverArt       `json:"cover_art,omitempty"`
        LastActivity   time.Time                `json:"last_activity"`
}

func NewMediaPlayerHandlers(
        logger *zap.Logger,
        musicPlayerService *services.MusicPlayerService,
        videoPlayerService *services.VideoPlayerService,
        playlistService *services.PlaylistService,
        positionService *services.PlaybackPositionService,
        subtitleService *services.SubtitleService,
        lyricsService *services.LyricsService,
        coverArtService *services.CoverArtService,
        translationService *services.TranslationService,
) *MediaPlayerHandlers <span class="cov0" title="0">{
        return &amp;MediaPlayerHandlers{
                logger:             logger,
                musicPlayerService: musicPlayerService,
                videoPlayerService: videoPlayerService,
                playlistService:    playlistService,
                positionService:    positionService,
                subtitleService:    subtitleService,
                lyricsService:      lyricsService,
                coverArtService:    coverArtService,
                translationService: translationService,
        }
}</span>

func (h *MediaPlayerHandlers) RegisterRoutes(router *mux.Router) <span class="cov0" title="0">{
        api := router.PathPrefix("/api/v1").Subrouter()

        // Music Player Routes
        api.HandleFunc("/music/play", h.PlayMusic).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/play/album", h.PlayAlbum).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/play/artist", h.PlayArtist).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}", h.GetMusicSession).Methods("GET", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}/update", h.UpdateMusicPlayback).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}/next", h.NextTrack).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}/previous", h.PreviousTrack).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}/seek", h.SeekMusic).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}/queue", h.AddToMusicQueue).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}/equalizer", h.SetEqualizer).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/library/stats", h.GetMusicLibraryStats).Methods("GET", "OPTIONS")

        // Video Player Routes
        api.HandleFunc("/video/play", h.PlayVideo).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/play/series", h.PlaySeries).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/session/{sessionId}", h.GetVideoSession).Methods("GET", "OPTIONS")
        api.HandleFunc("/video/session/{sessionId}/update", h.UpdateVideoPlayback).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/session/{sessionId}/next", h.NextVideo).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/session/{sessionId}/previous", h.PreviousVideo).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/session/{sessionId}/seek", h.SeekVideo).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/session/{sessionId}/bookmark", h.CreateVideoBookmark).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/continue-watching", h.GetContinueWatching).Methods("GET", "OPTIONS")
        api.HandleFunc("/video/watch-history", h.GetWatchHistory).Methods("GET", "OPTIONS")

        // Playlist Routes
        api.HandleFunc("/playlists", h.CreatePlaylist).Methods("POST", "OPTIONS")
        api.HandleFunc("/playlists", h.GetUserPlaylists).Methods("GET", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}", h.GetPlaylist).Methods("GET", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}", h.UpdatePlaylist).Methods("PUT", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}/items", h.GetPlaylistItems).Methods("GET", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}/items", h.AddToPlaylist).Methods("POST", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}/items/{itemId}", h.RemoveFromPlaylist).Methods("DELETE", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}/items/{itemId}/reorder", h.ReorderPlaylist).Methods("POST", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}/refresh", h.RefreshSmartPlaylist).Methods("POST", "OPTIONS")

        // Subtitle Routes
        api.HandleFunc("/subtitles/search", h.SearchSubtitles).Methods("POST", "OPTIONS")
        api.HandleFunc("/subtitles/download", h.DownloadSubtitle).Methods("POST", "OPTIONS")
        api.HandleFunc("/subtitles/translate", h.TranslateSubtitle).Methods("POST", "OPTIONS")

        // Lyrics Routes
        api.HandleFunc("/lyrics/search", h.SearchLyrics).Methods("POST", "OPTIONS")
        api.HandleFunc("/lyrics/sync", h.SynchronizeLyrics).Methods("POST", "OPTIONS")
        api.HandleFunc("/lyrics/concert", h.GetConcertLyrics).Methods("POST", "OPTIONS")

        // Cover Art Routes
        api.HandleFunc("/cover-art/search", h.SearchCoverArt).Methods("POST", "OPTIONS")
        api.HandleFunc("/cover-art/scan", h.ScanLocalCoverArt).Methods("POST", "OPTIONS")

        // Translation Routes
        api.HandleFunc("/translate", h.TranslateText).Methods("POST", "OPTIONS")
        api.HandleFunc("/translate/detect", h.DetectLanguage).Methods("POST", "OPTIONS")

        // Position Tracking Routes
        api.HandleFunc("/playback/position", h.UpdatePlaybackPosition).Methods("POST", "OPTIONS")
        api.HandleFunc("/playback/position/{mediaId}", h.GetPlaybackPosition).Methods("GET", "OPTIONS")
        api.HandleFunc("/playback/continue-watching", h.GetContinueWatchingList).Methods("GET", "OPTIONS")
        api.HandleFunc("/playback/bookmarks", h.CreateBookmark).Methods("POST", "OPTIONS")
        api.HandleFunc("/playback/bookmarks/{mediaId}", h.GetBookmarks).Methods("GET", "OPTIONS")
        api.HandleFunc("/playback/stats", h.GetPlaybackStats).Methods("GET", "OPTIONS")

        // Add CORS middleware
        api.Use(h.corsMiddleware)
}</span>

// Music Player Handlers

func (h *MediaPlayerHandlers) PlayMusic(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.PlayTrackRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">session, err := h.musicPlayerService.PlayTrack(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to play music", zap.Error(err))
                h.sendError(w, "Failed to start playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) PlayAlbum(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.PlayAlbumRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">session, err := h.musicPlayerService.PlayAlbum(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to play album", zap.Error(err))
                h.sendError(w, "Failed to start album playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) PlayArtist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.PlayArtistRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">session, err := h.musicPlayerService.PlayArtist(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to play artist", zap.Error(err))
                h.sendError(w, "Failed to start artist playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) GetMusicSession(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        session, err := h.musicPlayerService.GetSession(r.Context(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get music session", zap.Error(err))
                h.sendError(w, "Session not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) UpdateMusicPlayback(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req services.UpdatePlaybackRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.SessionID = sessionID

        session, err := h.musicPlayerService.UpdatePlayback(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update music playback", zap.Error(err))
                h.sendError(w, "Failed to update playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) NextTrack(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        session, err := h.musicPlayerService.NextTrack(r.Context(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to skip to next track", zap.Error(err))
                h.sendError(w, "Failed to skip track", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) PreviousTrack(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        session, err := h.musicPlayerService.PreviousTrack(r.Context(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to skip to previous track", zap.Error(err))
                h.sendError(w, "Failed to skip track", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) SeekMusic(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req services.SeekRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.SessionID = sessionID

        session, err := h.musicPlayerService.Seek(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to seek in track", zap.Error(err))
                h.sendError(w, "Failed to seek", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) AddToMusicQueue(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req services.QueueRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.SessionID = sessionID

        session, err := h.musicPlayerService.AddToQueue(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to add to queue", zap.Error(err))
                h.sendError(w, "Failed to add to queue", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) SetEqualizer(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req struct {
                Preset string             `json:"preset"`
                Bands  map[string]float64 `json:"bands"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.musicPlayerService.SetEqualizer(r.Context(), sessionID, req.Preset, req.Bands)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to set equalizer", zap.Error(err))
                h.sendError(w, "Failed to set equalizer", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Equalizer updated successfully"})</span>
}

func (h *MediaPlayerHandlers) GetMusicLibraryStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.musicPlayerService.GetLibraryStats(r.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get library stats", zap.Error(err))
                h.sendError(w, "Failed to get library statistics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, stats)</span>
}

// Video Player Handlers

func (h *MediaPlayerHandlers) PlayVideo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.PlayVideoRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">session, err := h.videoPlayerService.PlayVideo(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to play video", zap.Error(err))
                h.sendError(w, "Failed to start video playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) PlaySeries(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.PlaySeriesRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">session, err := h.videoPlayerService.PlaySeries(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to play series", zap.Error(err))
                h.sendError(w, "Failed to start series playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) GetVideoSession(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        session, err := h.videoPlayerService.GetVideoSession(r.Context(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get video session", zap.Error(err))
                h.sendError(w, "Session not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) UpdateVideoPlayback(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req services.UpdateVideoPlaybackRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.SessionID = sessionID

        session, err := h.videoPlayerService.UpdateVideoPlayback(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update video playback", zap.Error(err))
                h.sendError(w, "Failed to update playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) NextVideo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        session, err := h.videoPlayerService.NextVideo(r.Context(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to skip to next video", zap.Error(err))
                h.sendError(w, "Failed to skip video", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) PreviousVideo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        session, err := h.videoPlayerService.PreviousVideo(r.Context(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to skip to previous video", zap.Error(err))
                h.sendError(w, "Failed to skip video", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) SeekVideo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req services.VideoSeekRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.SessionID = sessionID

        session, err := h.videoPlayerService.SeekVideo(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to seek in video", zap.Error(err))
                h.sendError(w, "Failed to seek", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) CreateVideoBookmark(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req services.CreateVideoBookmarkRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.SessionID = sessionID

        bookmark, err := h.videoPlayerService.CreateVideoBookmark(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create bookmark", zap.Error(err))
                h.sendError(w, "Failed to create bookmark", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, bookmark)</span>
}

func (h *MediaPlayerHandlers) GetContinueWatching(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">limit := 20
        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">videos, err := h.videoPlayerService.GetContinueWatching(r.Context(), userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get continue watching", zap.Error(err))
                h.sendError(w, "Failed to get continue watching", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, videos)</span>
}

func (h *MediaPlayerHandlers) GetWatchHistory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">req := services.WatchHistoryRequest{
                UserID: userID,
                Limit:  50,
                Offset: 0,
        }

        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        req.Limit = l
                }</span>
        }

        <span class="cov0" title="0">if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov0" title="0">{
                        req.Offset = o
                }</span>
        }

        <span class="cov0" title="0">if videoType := r.URL.Query().Get("type"); videoType != "" </span><span class="cov0" title="0">{
                vt := services.VideoType(videoType)
                req.VideoType = &amp;vt
        }</span>

        <span class="cov0" title="0">history, err := h.videoPlayerService.GetWatchHistory(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get watch history", zap.Error(err))
                h.sendError(w, "Failed to get watch history", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, history)</span>
}

// Playlist Handlers

func (h *MediaPlayerHandlers) CreatePlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.CreatePlaylistRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">playlist, err := h.playlistService.CreatePlaylist(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create playlist", zap.Error(err))
                h.sendError(w, "Failed to create playlist", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, playlist)</span>
}

func (h *MediaPlayerHandlers) GetUserPlaylists(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">includePublic := r.URL.Query().Get("include_public") == "true"

        playlists, err := h.playlistService.GetUserPlaylists(r.Context(), userID, includePublic)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get user playlists", zap.Error(err))
                h.sendError(w, "Failed to get playlists", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, playlists)</span>
}

func (h *MediaPlayerHandlers) GetPlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userID := h.getUserID(r)

        playlist, err := h.playlistService.GetPlaylist(r.Context(), playlistID, userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get playlist", zap.Error(err))
                h.sendError(w, "Playlist not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, playlist)</span>
}

func (h *MediaPlayerHandlers) UpdatePlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req services.UpdatePlaylistRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.ID = playlistID

        h.sendSuccess(w, map[string]string{"message": "Playlist updated successfully"})</span>
}

func (h *MediaPlayerHandlers) GetPlaylistItems(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userID := h.getUserID(r)
        limit := 100
        offset := 0

        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov0" title="0">{
                        offset = o
                }</span>
        }

        <span class="cov0" title="0">items, err := h.playlistService.GetPlaylistItems(r.Context(), playlistID, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get playlist items", zap.Error(err))
                h.sendError(w, "Failed to get playlist items", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, items)</span>
}

func (h *MediaPlayerHandlers) AddToPlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req services.AddToPlaylistRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.PlaylistID = playlistID

        err = h.playlistService.AddToPlaylist(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to add to playlist", zap.Error(err))
                h.sendError(w, "Failed to add items to playlist", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Items added to playlist successfully"})</span>
}

func (h *MediaPlayerHandlers) RemoveFromPlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">itemID, err := h.getIDFromPath(r, "itemId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid item ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userID := h.getUserID(r)

        err = h.playlistService.RemoveFromPlaylist(r.Context(), playlistID, itemID, userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to remove from playlist", zap.Error(err))
                h.sendError(w, "Failed to remove item from playlist", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Item removed from playlist successfully"})</span>
}

func (h *MediaPlayerHandlers) ReorderPlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">itemID, err := h.getIDFromPath(r, "itemId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid item ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req services.ReorderPlaylistRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.PlaylistID = playlistID
        req.ItemID = itemID

        err = h.playlistService.ReorderPlaylist(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to reorder playlist", zap.Error(err))
                h.sendError(w, "Failed to reorder playlist", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Playlist reordered successfully"})</span>
}

func (h *MediaPlayerHandlers) RefreshSmartPlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.playlistService.RefreshSmartPlaylist(r.Context(), playlistID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to refresh smart playlist", zap.Error(err))
                h.sendError(w, "Failed to refresh smart playlist", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Smart playlist refreshed successfully"})</span>
}

// Subtitle Handlers

func (h *MediaPlayerHandlers) SearchSubtitles(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.SubtitleSearchRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">results, err := h.subtitleService.SearchSubtitles(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to search subtitles", zap.Error(err))
                h.sendError(w, "Failed to search subtitles", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, results)</span>
}

func (h *MediaPlayerHandlers) DownloadSubtitle(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.SubtitleDownloadRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">subtitle, err := h.subtitleService.DownloadSubtitle(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to download subtitle", zap.Error(err))
                h.sendError(w, "Failed to download subtitle", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, subtitle)</span>
}

func (h *MediaPlayerHandlers) TranslateSubtitle(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.SubtitleTranslationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">subtitle, err := h.subtitleService.TranslateSubtitle(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to translate subtitle", zap.Error(err))
                h.sendError(w, "Failed to translate subtitle", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, subtitle)</span>
}

// Lyrics Handlers

func (h *MediaPlayerHandlers) SearchLyrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.LyricsSearchRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">results, err := h.lyricsService.SearchLyrics(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to search lyrics", zap.Error(err))
                h.sendError(w, "Failed to search lyrics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, results)</span>
}

func (h *MediaPlayerHandlers) SynchronizeLyrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.LyricsSyncRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">lyrics, err := h.lyricsService.SynchronizeLyrics(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to synchronize lyrics", zap.Error(err))
                h.sendError(w, "Failed to synchronize lyrics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, lyrics)</span>
}

func (h *MediaPlayerHandlers) GetConcertLyrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.ConcertLyricsRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">lyrics, err := h.lyricsService.GetConcertLyrics(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get concert lyrics", zap.Error(err))
                h.sendError(w, "Failed to get concert lyrics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, lyrics)</span>
}

// Cover Art Handlers

func (h *MediaPlayerHandlers) SearchCoverArt(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.CoverArtSearchRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">results, err := h.coverArtService.SearchCoverArt(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to search cover art", zap.Error(err))
                h.sendError(w, "Failed to search cover art", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, results)</span>
}

func (h *MediaPlayerHandlers) ScanLocalCoverArt(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.LocalCoverArtScanRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">results, err := h.coverArtService.ScanLocalCoverArt(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to scan local cover art", zap.Error(err))
                h.sendError(w, "Failed to scan local cover art", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, results)</span>
}

// Translation Handlers

func (h *MediaPlayerHandlers) TranslateText(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.TranslationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">result, err := h.translationService.TranslateText(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to translate text", zap.Error(err))
                h.sendError(w, "Failed to translate text", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, result)</span>
}

func (h *MediaPlayerHandlers) DetectLanguage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.LanguageDetectionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">result, err := h.translationService.DetectLanguage(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to detect language", zap.Error(err))
                h.sendError(w, "Failed to detect language", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, result)</span>
}

// Position Tracking Handlers

func (h *MediaPlayerHandlers) UpdatePlaybackPosition(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.UpdatePositionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.positionService.UpdatePosition(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update position", zap.Error(err))
                h.sendError(w, "Failed to update playback position", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Position updated successfully"})</span>
}

func (h *MediaPlayerHandlers) GetPlaybackPosition(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        mediaID, err := h.getIDFromPath(r, "mediaId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid media ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">position, err := h.positionService.GetPosition(r.Context(), userID, mediaID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get position", zap.Error(err))
                h.sendError(w, "Failed to get playback position", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, position)</span>
}

func (h *MediaPlayerHandlers) GetContinueWatchingList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">limit := 20
        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">positions, err := h.positionService.GetContinueWatching(r.Context(), userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get continue watching", zap.Error(err))
                h.sendError(w, "Failed to get continue watching list", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, positions)</span>
}

func (h *MediaPlayerHandlers) CreateBookmark(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.BookmarkRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">bookmark, err := h.positionService.CreateBookmark(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create bookmark", zap.Error(err))
                h.sendError(w, "Failed to create bookmark", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, bookmark)</span>
}

func (h *MediaPlayerHandlers) GetBookmarks(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        mediaID, err := h.getIDFromPath(r, "mediaId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid media ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">bookmarks, err := h.positionService.GetBookmarks(r.Context(), userID, mediaID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get bookmarks", zap.Error(err))
                h.sendError(w, "Failed to get bookmarks", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, bookmarks)</span>
}

func (h *MediaPlayerHandlers) GetPlaybackStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">req := services.PlaybackStatsRequest{
                UserID: userID,
                Limit:  20,
        }

        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        req.Limit = l
                }</span>
        }

        <span class="cov0" title="0">if mediaType := r.URL.Query().Get("media_type"); mediaType != "" </span><span class="cov0" title="0">{
                req.MediaType = mediaType
        }</span>

        <span class="cov0" title="0">stats, err := h.positionService.GetPlaybackStats(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get playback stats", zap.Error(err))
                h.sendError(w, "Failed to get playback statistics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, stats)</span>
}

// Helper Methods

func (h *MediaPlayerHandlers) buildMusicSessionResponse(session *services.MusicPlaybackSession) *PlaybackSessionResponse <span class="cov0" title="0">{
        return &amp;PlaybackSessionResponse{
                SessionID:      session.ID,
                CurrentTrack:   session.CurrentTrack,
                PlaybackState:  session.PlaybackState,
                Position:       session.Position,
                Duration:       session.Duration,
                Volume:         session.Volume,
                IsMuted:        session.IsMuted,
                Queue:          session.Queue,
                QueueIndex:     session.QueueIndex,
                RepeatMode:     string(session.RepeatMode),
                ShuffleEnabled: session.ShuffleEnabled,
                LastActivity:   session.LastActivity,
        }
}</span>

func (h *MediaPlayerHandlers) buildVideoSessionResponse(session *services.VideoPlaybackSession) *PlaybackSessionResponse <span class="cov0" title="0">{
        return &amp;PlaybackSessionResponse{
                SessionID:     session.ID,
                CurrentVideo:  session.CurrentVideo,
                PlaybackState: session.PlaybackState,
                Position:      session.Position,
                Duration:      session.Duration,
                Volume:        session.Volume,
                IsMuted:       session.IsMuted,
                PlaybackSpeed: session.PlaybackSpeed,
                Queue:         session.Playlist,
                QueueIndex:    session.PlaylistIndex,
                Subtitles:     session.SubtitleTracks,
                AudioTracks:   session.AudioTracks,
                Chapters:      session.Chapters,
                LastActivity:  session.LastActivity,
        }
}</span>

func (h *MediaPlayerHandlers) sendSuccess(w http.ResponseWriter, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(APIResponse{
                Success: true,
                Data:    data,
        })
}</span>

func (h *MediaPlayerHandlers) sendError(w http.ResponseWriter, message string, statusCode int) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(APIResponse{
                Success: false,
                Error:   message,
        })
}</span>

func (h *MediaPlayerHandlers) getUserID(r *http.Request) int64 <span class="cov0" title="0">{
        userIDStr := r.Header.Get("X-User-ID")
        if userIDStr == "" </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">userID, err := strconv.ParseInt(userIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return userID</span>
}

func (h *MediaPlayerHandlers) getIDFromPath(r *http.Request, key string) (int64, error) <span class="cov0" title="0">{
        idStr := mux.Vars(r)[key]
        return strconv.ParseInt(idStr, 10, 64)
}</span>

func (h *MediaPlayerHandlers) corsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-User-ID")
                w.Header().Set("Access-Control-Max-Age", "86400")

                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/gorilla/mux"

        "catalogizer/internal/services"
)

type RecommendationHandler struct {
        recommendationService *services.RecommendationService
        deepLinkingService    *services.DeepLinkingService
}

func NewRecommendationHandler(
        recommendationService *services.RecommendationService,
        deepLinkingService *services.DeepLinkingService,
) *RecommendationHandler <span class="cov0" title="0">{
        return &amp;RecommendationHandler{
                recommendationService: recommendationService,
                deepLinkingService:    deepLinkingService,
        }
}</span>

// GetSimilarItems handles GET /api/v1/media/{id}/similar
func (rh *RecommendationHandler) GetSimilarItems(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        mediaID := vars["id"]

        if mediaID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Media ID is required", http.StatusBadRequest)
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">maxLocal := 10
        if maxLocalStr := r.URL.Query().Get("max_local"); maxLocalStr != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(maxLocalStr); err == nil &amp;&amp; val &gt; 0 </span><span class="cov0" title="0">{
                        maxLocal = val
                }</span>
        }

        <span class="cov0" title="0">maxExternal := 5
        if maxExternalStr := r.URL.Query().Get("max_external"); maxExternalStr != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(maxExternalStr); err == nil &amp;&amp; val &gt; 0 </span><span class="cov0" title="0">{
                        maxExternal = val
                }</span>
        }

        <span class="cov0" title="0">includeExternal := r.URL.Query().Get("include_external") == "true"

        similarityThreshold := 0.3
        if thresholdStr := r.URL.Query().Get("similarity_threshold"); thresholdStr != "" </span><span class="cov0" title="0">{
                if val, err := strconv.ParseFloat(thresholdStr, 64); err == nil &amp;&amp; val &gt;= 0 &amp;&amp; val &lt;= 1 </span><span class="cov0" title="0">{
                        similarityThreshold = val
                }</span>
        }

        // Parse filters
        <span class="cov0" title="0">filters := &amp;services.RecommendationFilters{}

        if genreFilter := r.URL.Query().Get("genre"); genreFilter != "" </span><span class="cov0" title="0">{
                filters.GenreFilter = []string{genreFilter}
        }</span>

        <span class="cov0" title="0">if yearStart := r.URL.Query().Get("year_start"); yearStart != "" </span><span class="cov0" title="0">{
                if yearEnd := r.URL.Query().Get("year_end"); yearEnd != "" </span><span class="cov0" title="0">{
                        if start, err1 := strconv.Atoi(yearStart); err1 == nil </span><span class="cov0" title="0">{
                                if end, err2 := strconv.Atoi(yearEnd); err2 == nil </span><span class="cov0" title="0">{
                                        filters.YearRange = &amp;services.YearRange{
                                                StartYear: start,
                                                EndYear:   end,
                                        }
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if minRating := r.URL.Query().Get("min_rating"); minRating != "" </span><span class="cov0" title="0">{
                if maxRating := r.URL.Query().Get("max_rating"); maxRating != "" </span><span class="cov0" title="0">{
                        if min, err1 := strconv.ParseFloat(minRating, 64); err1 == nil </span><span class="cov0" title="0">{
                                if max, err2 := strconv.ParseFloat(maxRating, 64); err2 == nil </span><span class="cov0" title="0">{
                                        filters.RatingRange = &amp;services.RatingRange{
                                                MinRating: min,
                                                MaxRating: max,
                                        }
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if language := r.URL.Query().Get("language"); language != "" </span><span class="cov0" title="0">{
                filters.LanguageFilter = []string{language}
        }</span>

        <span class="cov0" title="0">filters.ExcludeWatched = r.URL.Query().Get("exclude_watched") == "true"
        filters.ExcludeOwned = r.URL.Query().Get("exclude_owned") == "true"

        if minConfidence := r.URL.Query().Get("min_confidence"); minConfidence != "" </span><span class="cov0" title="0">{
                if val, err := strconv.ParseFloat(minConfidence, 64); err == nil &amp;&amp; val &gt;= 0 &amp;&amp; val &lt;= 1 </span><span class="cov0" title="0">{
                        filters.MinConfidence = val
                }</span>
        }

        // TODO: Get actual media metadata from database/service
        // For now, we'll create a mock request
        <span class="cov0" title="0">req := &amp;services.SimilarItemsRequest{
                MediaID:             mediaID,
                MaxLocalItems:       maxLocal,
                MaxExternalItems:    maxExternal,
                IncludeExternal:     includeExternal,
                SimilarityThreshold: similarityThreshold,
                Filters:             filters,
        }

        response, err := rh.recommendationService.GetSimilarItems(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get similar items: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// PostSimilarItems handles POST /api/v1/media/similar
func (rh *RecommendationHandler) PostSimilarItems(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.SimilarItemsRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.MediaID == "" &amp;&amp; req.MediaMetadata == nil </span><span class="cov0" title="0">{
                http.Error(w, "Either media_id or media_metadata is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">response, err := rh.recommendationService.GetSimilarItems(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get similar items: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// GenerateDeepLinks handles POST /api/v1/links/generate
func (rh *RecommendationHandler) GenerateDeepLinks(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.DeepLinkRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.MediaID == "" &amp;&amp; req.MediaMetadata == nil </span><span class="cov0" title="0">{
                http.Error(w, "Either media_id or media_metadata is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Action == "" </span><span class="cov0" title="0">{
                req.Action = "detail"
        }</span>

        <span class="cov0" title="0">response, err := rh.deepLinkingService.GenerateDeepLinks(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate deep links: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// GetMediaWithSimilarItems handles GET /api/v1/media/{id}/detail-with-similar
func (rh *RecommendationHandler) GetMediaWithSimilarItems(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        mediaID := vars["id"]

        if mediaID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Media ID is required", http.StatusBadRequest)
                return
        }</span>

        // Parse parameters for similar items
        <span class="cov0" title="0">maxLocal := 10
        if maxLocalStr := r.URL.Query().Get("max_similar"); maxLocalStr != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(maxLocalStr); err == nil &amp;&amp; val &gt; 0 </span><span class="cov0" title="0">{
                        maxLocal = val
                }</span>
        }

        <span class="cov0" title="0">includeExternal := r.URL.Query().Get("include_external") == "true"

        // TODO: Get actual media metadata from database/service
        // For now, we'll create a mock response
        response := &amp;MediaDetailWithSimilarResponse{
                MediaID:       mediaID,
                MediaMetadata: nil, // Would be populated from database
                SimilarItems:  nil, // Will be populated below
                Links:         nil, // Will be populated below
        }

        // Get similar items
        similarReq := &amp;services.SimilarItemsRequest{
                MediaID:             mediaID,
                MaxLocalItems:       maxLocal,
                MaxExternalItems:    5,
                IncludeExternal:     includeExternal,
                SimilarityThreshold: 0.3,
        }

        similarItems, err := rh.recommendationService.GetSimilarItems(r.Context(), similarReq)
        if err == nil </span><span class="cov0" title="0">{
                response.SimilarItems = similarItems
        }</span>

        // Generate deep links
        <span class="cov0" title="0">linkReq := &amp;services.DeepLinkRequest{
                MediaID: mediaID,
                Action:  "detail",
                Context: extractLinkContext(r),
        }

        links, err := rh.deepLinkingService.GenerateDeepLinks(r.Context(), linkReq)
        if err == nil </span><span class="cov0" title="0">{
                response.Links = links
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// TrackLinkClick handles POST /api/v1/links/track
func (rh *RecommendationHandler) TrackLinkClick(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var event services.LinkTrackingEvent
        if err := json.NewDecoder(r.Body).Decode(&amp;event); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if event.TrackingID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Tracking ID is required", http.StatusBadRequest)
                return
        }</span>

        // Set additional fields from request
        <span class="cov0" title="0">event.UserAgent = r.Header.Get("User-Agent")
        event.IPAddress = getClientIP(r)

        err := rh.deepLinkingService.TrackLinkEvent(r.Context(), &amp;event)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to track link event: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"status": "success"})</span>
}

// GetLinkAnalytics handles GET /api/v1/links/{tracking_id}/analytics
func (rh *RecommendationHandler) GetLinkAnalytics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        trackingID := vars["tracking_id"]

        if trackingID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Tracking ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">analytics, err := rh.deepLinkingService.GetLinkAnalytics(r.Context(), trackingID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get analytics: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(analytics)</span>
}

// BatchGenerateLinks handles POST /api/v1/links/batch
func (rh *RecommendationHandler) BatchGenerateLinks(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var requests []*services.DeepLinkRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;requests); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if len(requests) == 0 </span><span class="cov0" title="0">{
                http.Error(w, "At least one request is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if len(requests) &gt; 50 </span><span class="cov0" title="0">{ // Limit batch size
                http.Error(w, "Too many requests (max 50)", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">responses, err := rh.deepLinkingService.GenerateBatchLinks(r.Context(), requests)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate batch links: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "links":     responses,
                "processed": len(responses),
                "requested": len(requests),
        })</span>
}

// GenerateSmartLink handles POST /api/v1/links/smart
func (rh *RecommendationHandler) GenerateSmartLink(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.DeepLinkRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.MediaID == "" &amp;&amp; req.MediaMetadata == nil </span><span class="cov0" title="0">{
                http.Error(w, "Either media_id or media_metadata is required", http.StatusBadRequest)
                return
        }</span>

        // Set context from request if not provided
        <span class="cov0" title="0">if req.Context == nil </span><span class="cov0" title="0">{
                req.Context = extractLinkContext(r)
        }</span>

        <span class="cov0" title="0">response, err := rh.deepLinkingService.GenerateSmartLink(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate smart link: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// GetRecommendationTrends handles GET /api/v1/recommendations/trends
func (rh *RecommendationHandler) GetRecommendationTrends(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        mediaType := r.URL.Query().Get("media_type")
        period := r.URL.Query().Get("period")
        if period == "" </span><span class="cov0" title="0">{
                period = "week"
        }</span>

        <span class="cov0" title="0">limit := 20
        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(limitStr); err == nil &amp;&amp; val &gt; 0 &amp;&amp; val &lt;= 100 </span><span class="cov0" title="0">{
                        limit = val
                }</span>
        }

        // Mock trending recommendations
        <span class="cov0" title="0">trends := &amp;RecommendationTrends{
                Period:    period,
                MediaType: mediaType,
                Items:     generateMockTrendingItems(mediaType, limit),
                UpdatedAt: time.Now(),
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(trends)</span>
}

// Helper types
type MediaDetailWithSimilarResponse struct {
        MediaID       string                         `json:"media_id"`
        MediaMetadata interface{}                    `json:"media_metadata"` // Would be proper type
        SimilarItems  *services.SimilarItemsResponse `json:"similar_items"`
        Links         *services.DeepLinkResponse     `json:"links"`
}

type RecommendationTrends struct {
        Period    string      `json:"period"`
        MediaType string      `json:"media_type,omitempty"`
        Items     []TrendItem `json:"items"`
        UpdatedAt time.Time   `json:"updated_at"`
}

type TrendItem struct {
        MediaID             string  `json:"media_id"`
        Title               string  `json:"title"`
        Subtitle            string  `json:"subtitle,omitempty"`
        CoverArt            string  `json:"cover_art,omitempty"`
        TrendScore          float64 `json:"trend_score"`
        RecommendationCount int     `json:"recommendation_count"`
        ViewCount           int     `json:"view_count"`
        Rating              float64 `json:"rating,omitempty"`
}

// Helper functions
func extractLinkContext(r *http.Request) *services.LinkContext <span class="cov0" title="0">{
        context := &amp;services.LinkContext{
                ReferrerPage: r.Header.Get("Referer"),
        }

        // Extract user context from headers or query params
        if userID := r.Header.Get("X-User-ID"); userID != "" </span><span class="cov0" title="0">{
                context.UserID = userID
        }</span>
        <span class="cov0" title="0">if deviceID := r.Header.Get("X-Device-ID"); deviceID != "" </span><span class="cov0" title="0">{
                context.DeviceID = deviceID
        }</span>
        <span class="cov0" title="0">if sessionID := r.Header.Get("X-Session-ID"); sessionID != "" </span><span class="cov0" title="0">{
                context.SessionID = sessionID
        }</span>

        // Determine platform from User-Agent
        <span class="cov0" title="0">userAgent := strings.ToLower(r.Header.Get("User-Agent"))
        switch </span>{
        case strings.Contains(userAgent, "android"):<span class="cov0" title="0">
                context.Platform = "android"</span>
        case strings.Contains(userAgent, "iphone") || strings.Contains(userAgent, "ipad"):<span class="cov0" title="0">
                context.Platform = "ios"</span>
        case strings.Contains(userAgent, "catalogizer-desktop"):<span class="cov0" title="0">
                context.Platform = "desktop"</span>
        default:<span class="cov0" title="0">
                context.Platform = "web"</span>
        }

        // Extract UTM parameters
        <span class="cov0" title="0">query := r.URL.Query()
        if query.Get("utm_source") != "" </span><span class="cov0" title="0">{
                context.UTMParams = &amp;services.UTMParameters{
                        Source:   query.Get("utm_source"),
                        Medium:   query.Get("utm_medium"),
                        Campaign: query.Get("utm_campaign"),
                        Term:     query.Get("utm_term"),
                        Content:  query.Get("utm_content"),
                }
        }</span>

        <span class="cov0" title="0">return context</span>
}

func getClientIP(r *http.Request) string <span class="cov0" title="0">{
        // Check X-Forwarded-For header
        forwarded := r.Header.Get("X-Forwarded-For")
        if forwarded != "" </span><span class="cov0" title="0">{
                return strings.Split(forwarded, ",")[0]
        }</span>

        // Check X-Real-IP header
        <span class="cov0" title="0">realIP := r.Header.Get("X-Real-IP")
        if realIP != "" </span><span class="cov0" title="0">{
                return realIP
        }</span>

        // Fallback to RemoteAddr
        <span class="cov0" title="0">return r.RemoteAddr</span>
}

func generateMockTrendingItems(mediaType string, limit int) []TrendItem <span class="cov0" title="0">{
        items := make([]TrendItem, 0, limit)

        for i := 0; i &lt; limit; i++ </span><span class="cov0" title="0">{
                item := TrendItem{
                        MediaID:             fmt.Sprintf("trending_%s_%d", mediaType, i),
                        TrendScore:          0.9 - float64(i)*0.02,
                        RecommendationCount: 100 - i*5,
                        ViewCount:           1000 - i*50,
                        Rating:              8.5 - float64(i)*0.1,
                }

                switch mediaType </span>{
                case "video":<span class="cov0" title="0">
                        item.Title = fmt.Sprintf("Trending Movie %d", i+1)
                        item.Subtitle = "Action/Adventure"</span>
                case "audio":<span class="cov0" title="0">
                        item.Title = fmt.Sprintf("Trending Song %d", i+1)
                        item.Subtitle = "Popular Artist"</span>
                case "book":<span class="cov0" title="0">
                        item.Title = fmt.Sprintf("Trending Book %d", i+1)
                        item.Subtitle = "Bestselling Author"</span>
                default:<span class="cov0" title="0">
                        item.Title = fmt.Sprintf("Trending Item %d", i+1)</span>
                }

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package handlers

import (
        "catalogizer/internal/smb"
        "errors"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// SMBHandler handles SMB-related endpoints
type SMBHandler struct {
        smbManager *smb.ResilientSMBManager
        logger     *zap.Logger
}

// NewSMBHandler creates a new SMB handler
func NewSMBHandler(smbManager *smb.ResilientSMBManager, logger *zap.Logger) *SMBHandler <span class="cov0" title="0">{
        return &amp;SMBHandler{
                smbManager: smbManager,
                logger:     logger,
        }
}</span>

// AddSourceRequest represents a request to add an SMB source
type AddSourceRequest struct {
        Name              string `json:"name" binding:"required"`
        Path              string `json:"path" binding:"required"`
        Username          string `json:"username"`
        Password          string `json:"password"`
        Domain            string `json:"domain"`
        MaxRetryAttempts  int    `json:"max_retry_attempts"`
        RetryDelaySeconds int    `json:"retry_delay_seconds"`
        ConnectionTimeout int    `json:"connection_timeout_seconds"`
}

// @Summary Add SMB source
// @Description Add a new SMB source for monitoring
// @Tags smb
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param request body AddSourceRequest true "SMB source details"
// @Success 201 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/smb/sources [post]
func (h *SMBHandler) AddSource(c *gin.Context) <span class="cov0" title="0">{
        var req AddSourceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">source := &amp;smb.SMBSource{
                Name:     req.Name,
                Path:     req.Path,
                Username: req.Username,
                Password: req.Password,
                Domain:   req.Domain,
        }

        // Set optional parameters
        if req.MaxRetryAttempts &gt; 0 </span><span class="cov0" title="0">{
                source.MaxRetryAttempts = req.MaxRetryAttempts
        }</span>
        <span class="cov0" title="0">if req.RetryDelaySeconds &gt; 0 </span><span class="cov0" title="0">{
                source.RetryDelay = time.Duration(req.RetryDelaySeconds) * time.Second
        }</span>
        <span class="cov0" title="0">if req.ConnectionTimeout &gt; 0 </span><span class="cov0" title="0">{
                source.ConnectionTimeout = time.Duration(req.ConnectionTimeout) * time.Second
        }</span>

        <span class="cov0" title="0">err := h.smbManager.AddSource(source)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to add SMB source", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to add SMB source"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("SMB source added successfully",
                zap.String("name", req.Name),
                zap.String("path", req.Path))

        c.JSON(http.StatusCreated, gin.H{
                "message":   "SMB source added successfully",
                "source_id": source.ID,
        })</span>
}

// @Summary Remove SMB source
// @Description Remove an existing SMB source
// @Tags smb
// @Security BearerAuth
// @Param id path string true "Source ID"
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/smb/sources/{id} [delete]
func (h *SMBHandler) RemoveSource(c *gin.Context) <span class="cov0" title="0">{
        sourceID := c.Param("id")
        if sourceID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Source ID is required"})
                return
        }</span>

        <span class="cov0" title="0">err := h.smbManager.RemoveSource(sourceID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to remove SMB source",
                        zap.String("source_id", sourceID),
                        zap.Error(err))
                c.JSON(http.StatusNotFound, gin.H{"error": "SMB source not found"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("SMB source removed successfully", zap.String("source_id", sourceID))

        c.JSON(http.StatusOK, gin.H{
                "message": "SMB source removed successfully",
        })</span>
}

// @Summary Get SMB sources status
// @Description Get the status of all configured SMB sources
// @Tags smb
// @Security BearerAuth
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Router /api/v1/smb/sources/status [get]
func (h *SMBHandler) GetSourcesStatus(c *gin.Context) <span class="cov0" title="0">{
        status := h.smbManager.GetSourceStatus()

        c.JSON(http.StatusOK, gin.H{
                "sources": status,
                "summary": h.generateStatusSummary(status),
        })
}</span>

// @Summary Get SMB source details
// @Description Get detailed information about a specific SMB source
// @Tags smb
// @Security BearerAuth
// @Param id path string true "Source ID"
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/smb/sources/{id} [get]
func (h *SMBHandler) GetSourceDetails(c *gin.Context) <span class="cov0" title="0">{
        sourceID := c.Param("id")
        if sourceID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Source ID is required"})
                return
        }</span>

        <span class="cov0" title="0">status := h.smbManager.GetSourceStatus()
        sourceStatus, exists := status[sourceID]
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "SMB source not found"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "source": sourceStatus,
        })</span>
}

// @Summary Test SMB connection
// @Description Test connection to an SMB source
// @Tags smb
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param request body AddSourceRequest true "SMB connection details"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/smb/test-connection [post]
func (h *SMBHandler) TestConnection(c *gin.Context) <span class="cov0" title="0">{
        var req AddSourceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        // Create temporary source for testing
        <span class="cov0" title="0">source := &amp;smb.SMBSource{
                Name:              "test",
                Path:              req.Path,
                Username:          req.Username,
                Password:          req.Password,
                Domain:            req.Domain,
                ConnectionTimeout: 10 * time.Second,
        }

        // Test connection (this would use actual SMB connection logic)
        start := time.Now()
        err := h.testSMBConnection(source)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("SMB connection test failed",
                        zap.String("path", req.Path),
                        zap.Error(err))

                c.JSON(http.StatusInternalServerError, gin.H{
                        "success":       false,
                        "error":         err.Error(),
                        "test_duration": duration.Milliseconds(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success":       true,
                "message":       "Connection successful",
                "test_duration": duration.Milliseconds(),
        })</span>
}

// @Summary Force reconnect SMB source
// @Description Force a reconnection attempt for an SMB source
// @Tags smb
// @Security BearerAuth
// @Param id path string true "Source ID"
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/smb/sources/{id}/reconnect [post]
func (h *SMBHandler) ForceReconnect(c *gin.Context) <span class="cov0" title="0">{
        sourceID := c.Param("id")
        if sourceID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Source ID is required"})
                return
        }</span>

        // This would trigger a reconnection attempt
        <span class="cov0" title="0">err := h.smbManager.ForceReconnect(sourceID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to force reconnect",
                        zap.String("source_id", sourceID),
                        zap.Error(err))
                c.JSON(http.StatusNotFound, gin.H{"error": "SMB source not found or reconnect failed"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Forced reconnect initiated", zap.String("source_id", sourceID))

        c.JSON(http.StatusOK, gin.H{
                "message": "Reconnection initiated",
        })</span>
}

// @Summary Get SMB statistics
// @Description Get statistics about SMB sources and their performance
// @Tags smb
// @Security BearerAuth
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Router /api/v1/smb/statistics [get]
func (h *SMBHandler) GetStatistics(c *gin.Context) <span class="cov0" title="0">{
        status := h.smbManager.GetSourceStatus()
        stats := h.generateStatistics(status)

        c.JSON(http.StatusOK, stats)
}</span>

// Helper methods

func (h *SMBHandler) generateStatusSummary(status map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        summary := map[string]interface{}{
                "total":        len(status),
                "connected":    0,
                "disconnected": 0,
                "reconnecting": 0,
                "offline":      0,
        }

        for _, sourceStatus := range status </span><span class="cov0" title="0">{
                if sourceMap, ok := sourceStatus.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if state, exists := sourceMap["state"]; exists </span><span class="cov0" title="0">{
                                switch state </span>{
                                case "connected":<span class="cov0" title="0">
                                        summary["connected"] = summary["connected"].(int) + 1</span>
                                case "disconnected":<span class="cov0" title="0">
                                        summary["disconnected"] = summary["disconnected"].(int) + 1</span>
                                case "reconnecting":<span class="cov0" title="0">
                                        summary["reconnecting"] = summary["reconnecting"].(int) + 1</span>
                                case "offline":<span class="cov0" title="0">
                                        summary["offline"] = summary["offline"].(int) + 1</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return summary</span>
}

func (h *SMBHandler) generateStatistics(status map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        stats := map[string]interface{}{
                "total_sources":     len(status),
                "health_summary":    h.generateStatusSummary(status),
                "uptime_stats":      h.calculateUptimeStats(status),
                "performance_stats": h.calculatePerformanceStats(status),
                "error_stats":       h.calculateErrorStats(status),
        }

        return stats
}</span>

func (h *SMBHandler) calculateUptimeStats(status map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        now := time.Now()
        totalUptime := time.Duration(0)
        connectedSources := 0

        for _, sourceStatus := range status </span><span class="cov0" title="0">{
                if sourceMap, ok := sourceStatus.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if state, exists := sourceMap["state"]; exists &amp;&amp; state == "connected" </span><span class="cov0" title="0">{
                                if lastConnectedStr, exists := sourceMap["last_connected"]; exists </span><span class="cov0" title="0">{
                                        if lastConnected, ok := lastConnectedStr.(time.Time); ok </span><span class="cov0" title="0">{
                                                uptime := now.Sub(lastConnected)
                                                totalUptime += uptime
                                                connectedSources++
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">averageUptime := time.Duration(0)
        if connectedSources &gt; 0 </span><span class="cov0" title="0">{
                averageUptime = totalUptime / time.Duration(connectedSources)
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "total_uptime_hours":   totalUptime.Hours(),
                "average_uptime_hours": averageUptime.Hours(),
                "connected_sources":    connectedSources,
        }</span>
}

func (h *SMBHandler) calculatePerformanceStats(status map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        // This would include metrics like:
        // - Average response time
        // - Throughput
        // - Connection success rate
        // For now, return placeholder data

        return map[string]interface{}{
                "avg_response_time_ms":    150,
                "connection_success_rate": 0.95,
                "total_operations":        1000,
        }
}</span>

func (h *SMBHandler) calculateErrorStats(status map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        totalErrors := 0
        sourcesWithErrors := 0

        for _, sourceStatus := range status </span><span class="cov0" title="0">{
                if sourceMap, ok := sourceStatus.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if retryAttempts, exists := sourceMap["retry_attempts"]; exists </span><span class="cov0" title="0">{
                                if attempts, ok := retryAttempts.(int); ok &amp;&amp; attempts &gt; 0 </span><span class="cov0" title="0">{
                                        totalErrors += attempts
                                        sourcesWithErrors++
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "total_errors":        totalErrors,
                "sources_with_errors": sourcesWithErrors,
                "error_rate":          float64(sourcesWithErrors) / float64(len(status)),
        }</span>
}

func (h *SMBHandler) testSMBConnection(source *smb.SMBSource) error <span class="cov0" title="0">{
        // Placeholder for actual SMB connection testing
        // In a real implementation, this would:
        // 1. Create SMB connection with provided credentials
        // 2. Attempt to list directory contents
        // 3. Test read permissions
        // 4. Return any connection errors

        time.Sleep(100 * time.Millisecond) // Simulate connection time

        // Simulate occasional failures for testing
        if time.Now().Unix()%10 == 0 </span><span class="cov0" title="0">{
                return errors.New("Connection timeout")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateSourceRequest represents a request to update SMB source settings
type UpdateSourceRequest struct {
        Name              *string `json:"name,omitempty"`
        Username          *string `json:"username,omitempty"`
        Password          *string `json:"password,omitempty"`
        Domain            *string `json:"domain,omitempty"`
        MaxRetryAttempts  *int    `json:"max_retry_attempts,omitempty"`
        RetryDelaySeconds *int    `json:"retry_delay_seconds,omitempty"`
        ConnectionTimeout *int    `json:"connection_timeout_seconds,omitempty"`
        IsEnabled         *bool   `json:"is_enabled,omitempty"`
}

// @Summary Update SMB source
// @Description Update settings for an existing SMB source
// @Tags smb
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param id path string true "Source ID"
// @Param request body UpdateSourceRequest true "Update data"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/smb/sources/{id} [put]
func (h *SMBHandler) UpdateSource(c *gin.Context) <span class="cov0" title="0">{
        sourceID := c.Param("id")
        if sourceID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Source ID is required"})
                return
        }</span>

        <span class="cov0" title="0">var req UpdateSourceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">err := h.smbManager.UpdateSource(sourceID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update SMB source",
                        zap.String("source_id", sourceID),
                        zap.Error(err))
                c.JSON(http.StatusNotFound, gin.H{"error": "SMB source not found"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("SMB source updated successfully", zap.String("source_id", sourceID))

        c.JSON(http.StatusOK, gin.H{
                "message": "SMB source updated successfully",
        })</span>
}

// @Summary Get SMB health
// @Description Get overall health status of SMB monitoring system
// @Tags smb
// @Security BearerAuth
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Router /api/v1/smb/health [get]
func (h *SMBHandler) GetHealth(c *gin.Context) <span class="cov0" title="0">{
        status := h.smbManager.GetSourceStatus()
        summary := h.generateStatusSummary(status)

        isHealthy := summary["offline"].(int) == 0 &amp;&amp; summary["disconnected"].(int) &lt; len(status)/2

        health := map[string]interface{}{
                "healthy":         isHealthy,
                "sources_summary": summary,
                "total_sources":   len(status),
                "system_uptime":   time.Since(h.smbManager.GetStartTime()).Hours(),
                "last_check":      time.Now(),
        }

        statusCode := http.StatusOK
        if !isHealthy </span><span class="cov0" title="0">{
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, health)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package handlers

import (
        "catalogizer/internal/services"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// SMBDiscoveryHandler handles SMB discovery API requests
type SMBDiscoveryHandler struct {
        service *services.SMBDiscoveryService
        logger  *zap.Logger
}

// NewSMBDiscoveryHandler creates a new SMB discovery handler
func NewSMBDiscoveryHandler(service *services.SMBDiscoveryService, logger *zap.Logger) *SMBDiscoveryHandler <span class="cov0" title="0">{
        return &amp;SMBDiscoveryHandler{
                service: service,
                logger:  logger,
        }
}</span>

// DiscoverSharesRequest represents the request to discover SMB shares
type DiscoverSharesRequest struct {
        Host     string  `json:"host" binding:"required"`
        Username string  `json:"username" binding:"required"`
        Password string  `json:"password" binding:"required"`
        Domain   *string `json:"domain"`
}

// TestConnectionRequest represents the request to test SMB connection
type TestConnectionRequest struct {
        Host     string  `json:"host" binding:"required"`
        Port     int     `json:"port"`
        Share    string  `json:"share" binding:"required"`
        Username string  `json:"username" binding:"required"`
        Password string  `json:"password" binding:"required"`
        Domain   *string `json:"domain"`
}

// BrowseShareRequest represents the request to browse SMB share
type BrowseShareRequest struct {
        Host     string  `json:"host" binding:"required"`
        Port     int     `json:"port"`
        Share    string  `json:"share" binding:"required"`
        Username string  `json:"username" binding:"required"`
        Password string  `json:"password" binding:"required"`
        Domain   *string `json:"domain"`
        Path     string  `json:"path"`
}

// DiscoverShares discovers available SMB shares on a host
// @Summary Discover SMB shares
// @Description Discovers available SMB shares on the specified host
// @Tags SMB
// @Accept json
// @Produce json
// @Param request body DiscoverSharesRequest true "Discovery request"
// @Success 200 {array} services.SMBShareInfo
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /api/v1/smb/discover [post]
func (h *SMBDiscoveryHandler) DiscoverShares(c *gin.Context) <span class="cov0" title="0">{
        var req DiscoverSharesRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid request", zap.Error(err))
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Discovering SMB shares", zap.String("host", req.Host), zap.String("username", req.Username))

        shares, err := h.service.DiscoverShares(c.Request.Context(), req.Host, req.Username, req.Password, req.Domain)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to discover SMB shares", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to discover shares: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, shares)</span>
}

// TestConnection tests an SMB connection
// @Summary Test SMB connection
// @Description Tests connectivity to an SMB share with the provided credentials
// @Tags SMB
// @Accept json
// @Produce json
// @Param request body TestConnectionRequest true "Connection test request"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /api/v1/smb/test [post]
func (h *SMBDiscoveryHandler) TestConnection(c *gin.Context) <span class="cov0" title="0">{
        var req TestConnectionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid request", zap.Error(err))
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
                return
        }</span>

        // Set default port if not provided
        <span class="cov0" title="0">if req.Port == 0 </span><span class="cov0" title="0">{
                req.Port = 445
        }</span>

        <span class="cov0" title="0">h.logger.Info("Testing SMB connection", zap.String("host", req.Host), zap.String("share", req.Share))

        config := services.SMBConnectionConfig{
                Host:     req.Host,
                Port:     req.Port,
                Share:    req.Share,
                Username: req.Username,
                Password: req.Password,
                Domain:   req.Domain,
        }

        success := h.service.TestConnection(c.Request.Context(), config)

        c.JSON(http.StatusOK, gin.H{
                "success":    success,
                "host":       req.Host,
                "share":      req.Share,
                "username":   req.Username,
                "connection": success,
        })</span>
}

// BrowseShare browses files and directories in an SMB share
// @Summary Browse SMB share
// @Description Lists files and directories in the specified SMB share path
// @Tags SMB
// @Accept json
// @Produce json
// @Param request body BrowseShareRequest true "Browse request"
// @Success 200 {array} services.SMBFileEntry
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /api/v1/smb/browse [post]
func (h *SMBDiscoveryHandler) BrowseShare(c *gin.Context) <span class="cov0" title="0">{
        var req BrowseShareRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid request", zap.Error(err))
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
                return
        }</span>

        // Set default port if not provided
        <span class="cov0" title="0">if req.Port == 0 </span><span class="cov0" title="0">{
                req.Port = 445
        }</span>

        // Set default path if not provided
        <span class="cov0" title="0">if req.Path == "" </span><span class="cov0" title="0">{
                req.Path = "."
        }</span>

        <span class="cov0" title="0">h.logger.Info("Browsing SMB share", zap.String("host", req.Host), zap.String("share", req.Share), zap.String("path", req.Path))

        config := services.SMBConnectionConfig{
                Host:     req.Host,
                Port:     req.Port,
                Share:    req.Share,
                Username: req.Username,
                Password: req.Password,
                Domain:   req.Domain,
        }

        entries, err := h.service.BrowseShare(c.Request.Context(), config, req.Path)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to browse SMB share", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to browse share: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, entries)</span>
}

// DiscoverSharesGET discovers SMB shares using GET parameters (for simple testing)
// @Summary Discover SMB shares (GET)
// @Description Discovers available SMB shares using GET parameters
// @Tags SMB
// @Produce json
// @Param host query string true "SMB host"
// @Param username query string true "Username"
// @Param password query string true "Password"
// @Param domain query string false "Domain"
// @Success 200 {array} services.SMBShareInfo
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /api/v1/smb/discover [get]
func (h *SMBDiscoveryHandler) DiscoverSharesGET(c *gin.Context) <span class="cov0" title="0">{
        host := c.Query("host")
        username := c.Query("username")
        password := c.Query("password")
        domain := c.Query("domain")

        if host == "" || username == "" || password == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "host, username, and password are required"})
                return
        }</span>

        <span class="cov0" title="0">var domainPtr *string
        if domain != "" </span><span class="cov0" title="0">{
                domainPtr = &amp;domain
        }</span>

        <span class="cov0" title="0">shares, err := h.service.DiscoverShares(c.Request.Context(), host, username, password, domainPtr)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to discover SMB shares", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to discover shares: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, shares)</span>
}

// TestConnectionGET tests SMB connection using GET parameters (for simple testing)
// @Summary Test SMB connection (GET)
// @Description Tests SMB connection using GET parameters
// @Tags SMB
// @Produce json
// @Param host query string true "SMB host"
// @Param share query string true "Share name"
// @Param username query string true "Username"
// @Param password query string true "Password"
// @Param domain query string false "Domain"
// @Param port query int false "Port (default 445)"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]interface{}
// @Router /api/v1/smb/test [get]
func (h *SMBDiscoveryHandler) TestConnectionGET(c *gin.Context) <span class="cov0" title="0">{
        host := c.Query("host")
        share := c.Query("share")
        username := c.Query("username")
        password := c.Query("password")
        domain := c.Query("domain")
        portStr := c.Query("port")

        if host == "" || share == "" || username == "" || password == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "host, share, username, and password are required"})
                return
        }</span>

        <span class="cov0" title="0">port := 445
        if portStr != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(portStr); err == nil </span><span class="cov0" title="0">{
                        port = p
                }</span>
        }

        <span class="cov0" title="0">var domainPtr *string
        if domain != "" </span><span class="cov0" title="0">{
                domainPtr = &amp;domain
        }</span>

        <span class="cov0" title="0">config := services.SMBConnectionConfig{
                Host:     host,
                Port:     port,
                Share:    share,
                Username: username,
                Password: password,
                Domain:   domainPtr,
        }

        success := h.service.TestConnection(c.Request.Context(), config)

        c.JSON(http.StatusOK, gin.H{
                "success":    success,
                "host":       host,
                "share":      share,
                "username":   username,
                "connection": success,
        })</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package analyzer

import (
        "catalogizer/internal/media/detector"
        mediamodels "catalogizer/internal/media/models"
        "catalogizer/internal/media/providers"
        "catalogizer/internal/models"
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"
)

// MediaAnalyzer handles real-time analysis of directory content
type MediaAnalyzer struct {
        db              *sql.DB
        detector        *detector.DetectionEngine
        providerManager *providers.ProviderManager
        logger          *zap.Logger
        analysisQueue   chan AnalysisRequest
        workers         int
        stopCh          chan struct{}
        wg              sync.WaitGroup
        mu              sync.RWMutex
        pendingAnalysis map[string]*AnalysisRequest
}

// AnalysisRequest represents a request to analyze a directory
type AnalysisRequest struct {
        DirectoryPath string
        SmbRoot       string
        Priority      int // Higher number = higher priority
        Timestamp     time.Time
        Callback      func(*AnalysisResult, error)
}

// AnalysisResult represents the result of directory analysis
type AnalysisResult struct {
        DirectoryAnalysis *mediamodels.DirectoryAnalysis
        MediaItem         *mediamodels.MediaItem
        ExternalMetadata  []mediamodels.ExternalMetadata
        QualityAnalysis   *QualityAnalysis
        UpdatedFiles      []mediamodels.MediaFile
}

// QualityAnalysis represents quality analysis of media files
type QualityAnalysis struct {
        BestQuality        *mediamodels.QualityInfo
        AvailableQualities []string
        TotalFiles         int
        TotalSize          int64
        DuplicateCount     int
        MissingQualities   []string
}

// NewMediaAnalyzer creates a new media analyzer
func NewMediaAnalyzer(db *sql.DB, detector *detector.DetectionEngine, providerManager *providers.ProviderManager, logger *zap.Logger) *MediaAnalyzer <span class="cov0" title="0">{
        return &amp;MediaAnalyzer{
                db:              db,
                detector:        detector,
                providerManager: providerManager,
                logger:          logger,
                analysisQueue:   make(chan AnalysisRequest, 1000),
                workers:         4, // Number of concurrent workers
                stopCh:          make(chan struct{}),
                pendingAnalysis: make(map[string]*AnalysisRequest),
        }
}</span>

// Start starts the analyzer workers
func (ma *MediaAnalyzer) Start() <span class="cov0" title="0">{
        ma.logger.Info("Starting media analyzer", zap.Int("workers", ma.workers))

        for i := 0; i &lt; ma.workers; i++ </span><span class="cov0" title="0">{
                ma.wg.Add(1)
                go ma.worker(i)
        }</span>
}

// Stop stops the analyzer workers
func (ma *MediaAnalyzer) Stop() <span class="cov0" title="0">{
        ma.logger.Info("Stopping media analyzer")
        close(ma.stopCh)
        ma.wg.Wait()
}</span>

// AnalyzeDirectory queues a directory for analysis
func (ma *MediaAnalyzer) AnalyzeDirectory(ctx context.Context, directoryPath, smbRoot string, priority int) error <span class="cov0" title="0">{
        request := AnalysisRequest{
                DirectoryPath: directoryPath,
                SmbRoot:       smbRoot,
                Priority:      priority,
                Timestamp:     time.Now(),
        }

        // Check if already pending
        ma.mu.Lock()
        if existing, exists := ma.pendingAnalysis[directoryPath]; exists </span><span class="cov0" title="0">{
                // Update priority if higher
                if priority &gt; existing.Priority </span><span class="cov0" title="0">{
                        existing.Priority = priority
                }</span>
                <span class="cov0" title="0">ma.mu.Unlock()
                return nil</span>
        }
        <span class="cov0" title="0">ma.pendingAnalysis[directoryPath] = &amp;request
        ma.mu.Unlock()

        select </span>{
        case ma.analysisQueue &lt;- request:<span class="cov0" title="0">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                ma.mu.Lock()
                delete(ma.pendingAnalysis, directoryPath)
                ma.mu.Unlock()
                return ctx.Err()</span>
        }
}

// AnalyzeDirectorySync performs synchronous directory analysis
func (ma *MediaAnalyzer) AnalyzeDirectorySync(ctx context.Context, directoryPath, smbRoot string) (*AnalysisResult, error) <span class="cov0" title="0">{
        // Get directory files
        files, err := ma.getDirectoryFiles(directoryPath, smbRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get directory files: %w", err)
        }</span>

        // Convert to detector.FileInfo
        <span class="cov0" title="0">detectorFiles := make([]detector.FileInfo, len(files))
        for i, file := range files </span><span class="cov0" title="0">{
                extension := ""
                if file.Extension != nil </span><span class="cov0" title="0">{
                        extension = *file.Extension
                }</span>
                <span class="cov0" title="0">detectorFiles[i] = detector.FileInfo{
                        Name:      file.Name,
                        Path:      file.Path,
                        Size:      file.Size,
                        Extension: extension,
                        IsDir:     file.IsDirectory,
                }</span>
        }

        // Run detection
        <span class="cov0" title="0">detectionResult, err := ma.detector.AnalyzeDirectory(directoryPath, detectorFiles)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("detection failed: %w", err)
        }</span>

        <span class="cov0" title="0">if detectionResult == nil </span><span class="cov0" title="0">{
                return &amp;AnalysisResult{}, nil // No detection
        }</span>

        // Create or update directory analysis record
        <span class="cov0" title="0">dirAnalysis, err := ma.createDirectoryAnalysis(directoryPath, smbRoot, detectionResult)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create directory analysis: %w", err)
        }</span>

        // Create or get media item
        <span class="cov0" title="0">mediaItem, err := ma.createOrUpdateMediaItem(ctx, detectionResult, dirAnalysis)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create media item: %w", err)
        }</span>

        // Fetch external metadata
        <span class="cov0" title="0">externalMetadata, err := ma.fetchExternalMetadata(ctx, mediaItem)
        if err != nil </span><span class="cov0" title="0">{
                ma.logger.Error("Failed to fetch external metadata", zap.Error(err))
                // Don't fail the whole analysis for metadata errors
        }</span>

        // Analyze quality
        <span class="cov0" title="0">qualityAnalysis, err := ma.analyzeQuality(files, mediaItem)
        if err != nil </span><span class="cov0" title="0">{
                ma.logger.Error("Failed to analyze quality", zap.Error(err))
        }</span>

        // Update media files
        <span class="cov0" title="0">updatedFiles, err := ma.updateMediaFiles(mediaItem.ID, files, directoryPath, smbRoot)
        if err != nil </span><span class="cov0" title="0">{
                ma.logger.Error("Failed to update media files", zap.Error(err))
        }</span>

        <span class="cov0" title="0">result := &amp;AnalysisResult{
                DirectoryAnalysis: dirAnalysis,
                MediaItem:         mediaItem,
                ExternalMetadata:  externalMetadata,
                QualityAnalysis:   qualityAnalysis,
                UpdatedFiles:      updatedFiles,
        }

        return result, nil</span>
}

// worker processes analysis requests
func (ma *MediaAnalyzer) worker(workerID int) <span class="cov0" title="0">{
        defer ma.wg.Done()

        ma.logger.Info("Media analyzer worker started", zap.Int("worker_id", workerID))

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ma.stopCh:<span class="cov0" title="0">
                        return</span>

                case request := &lt;-ma.analysisQueue:<span class="cov0" title="0">
                        ma.mu.Lock()
                        delete(ma.pendingAnalysis, request.DirectoryPath)
                        ma.mu.Unlock()

                        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
                        result, err := ma.AnalyzeDirectorySync(ctx, request.DirectoryPath, request.SmbRoot)
                        cancel()

                        if request.Callback != nil </span><span class="cov0" title="0">{
                                request.Callback(result, err)
                        }</span>

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                ma.logger.Error("Directory analysis failed",
                                        zap.String("directory", request.DirectoryPath),
                                        zap.String("smb_root", request.SmbRoot),
                                        zap.Error(err))
                        }</span> else<span class="cov0" title="0"> {
                                ma.logger.Info("Directory analysis completed",
                                        zap.String("directory", request.DirectoryPath),
                                        zap.String("media_type", result.MediaItem.MediaType.Name))
                        }</span>
                }
        }
}

// getDirectoryFiles retrieves files in a directory from the catalog database
func (ma *MediaAnalyzer) getDirectoryFiles(directoryPath, smbRoot string) ([]models.FileInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, path, is_directory, size, last_modified, extension, mime_type
                FROM files
                WHERE path LIKE ? AND smb_root = ?
                ORDER BY is_directory DESC, name ASC
        `

        rows, err := ma.db.Query(query, directoryPath+"%", smbRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var files []models.FileInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var file models.FileInfo
                err := rows.Scan(
                        &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory,
                        &amp;file.Size, &amp;file.LastModified, &amp;file.Extension, &amp;file.MimeType,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">files = append(files, file)</span>
        }

        <span class="cov0" title="0">return files, nil</span>
}

// createDirectoryAnalysis creates or updates directory analysis record
func (ma *MediaAnalyzer) createDirectoryAnalysis(directoryPath, smbRoot string, detection *detector.DetectionResult) (*mediamodels.DirectoryAnalysis, error) <span class="cov0" title="0">{
        analysisDataJSON, _ := json.Marshal(detection.AnalysisData)

        query := `
                INSERT OR REPLACE INTO directory_analysis
                (directory_path, smb_root, media_item_id, confidence_score, detection_method, analysis_data, last_analyzed, files_count, total_size)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        // Calculate files count and total size from analysis data
        filesCount := 0
        totalSize := int64(0)
        if detection.AnalysisData != nil </span><span class="cov0" title="0">{
                for _, count := range detection.AnalysisData.FileTypes </span><span class="cov0" title="0">{
                        filesCount += count
                }</span>
                <span class="cov0" title="0">for _, size := range detection.AnalysisData.SizeDistribution </span><span class="cov0" title="0">{
                        totalSize += size
                }</span>
        }

        <span class="cov0" title="0">_, err := ma.db.Exec(query,
                directoryPath, smbRoot, nil, // media_item_id will be set later
                detection.Confidence, detection.Method, string(analysisDataJSON),
                time.Now(), filesCount, totalSize,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the created record
        <span class="cov0" title="0">return &amp;mediamodels.DirectoryAnalysis{
                DirectoryPath:   directoryPath,
                SmbRoot:         smbRoot,
                ConfidenceScore: detection.Confidence,
                DetectionMethod: detection.Method,
                AnalysisData:    detection.AnalysisData,
                LastAnalyzed:    time.Now(),
                FilesCount:      filesCount,
                TotalSize:       totalSize,
        }, nil</span>
}

// createOrUpdateMediaItem creates or updates media item
func (ma *MediaAnalyzer) createOrUpdateMediaItem(ctx context.Context, detection *detector.DetectionResult, dirAnalysis *mediamodels.DirectoryAnalysis) (*mediamodels.MediaItem, error) <span class="cov0" title="0">{
        // Check if media item already exists
        var existingID *int64
        err := ma.db.QueryRow(
                "SELECT media_item_id FROM directory_analysis WHERE directory_path = ?",
                dirAnalysis.DirectoryPath,
        ).Scan(&amp;existingID)

        if err == nil &amp;&amp; existingID != nil </span><span class="cov0" title="0">{
                // Update existing media item
                return ma.updateExistingMediaItem(*existingID, detection)
        }</span>

        // Create new media item
        <span class="cov0" title="0">genreJSON, _ := json.Marshal([]string{}) // Empty for now
        castCrewJSON, _ := json.Marshal(&amp;mediamodels.CastCrew{})

        query := `
                INSERT INTO media_items
                (media_type_id, title, year, description, genre, cast_crew, status, first_detected, last_updated)
                VALUES (?, ?, ?, ?, ?, ?, 'active', ?, ?)
        `

        result, err := ma.db.Exec(query,
                detection.MediaTypeID, detection.SuggestedTitle, detection.SuggestedYear,
                nil, string(genreJSON), string(castCrewJSON),
                time.Now(), time.Now(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mediaItemID, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update directory analysis with media item ID
        <span class="cov0" title="0">_, err = ma.db.Exec(
                "UPDATE directory_analysis SET media_item_id = ? WHERE directory_path = ?",
                mediaItemID, dirAnalysis.DirectoryPath,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the created media item
        <span class="cov0" title="0">mediaItem := &amp;mediamodels.MediaItem{
                ID:            mediaItemID,
                MediaTypeID:   detection.MediaTypeID,
                MediaType:     detection.MediaType,
                Title:         detection.SuggestedTitle,
                Year:          detection.SuggestedYear,
                Status:        "active",
                FirstDetected: time.Now(),
                LastUpdated:   time.Now(),
        }

        return mediaItem, nil</span>
}

// updateExistingMediaItem updates an existing media item
func (ma *MediaAnalyzer) updateExistingMediaItem(mediaItemID int64, detection *detector.DetectionResult) (*mediamodels.MediaItem, error) <span class="cov0" title="0">{
        // Get existing media item
        query := `
                SELECT id, media_type_id, title, year, description, genre, director, cast_crew, rating, runtime, language, country, status, first_detected, last_updated
                FROM media_items WHERE id = ?
        `

        var item mediamodels.MediaItem
        var genreJSON, castCrewJSON string

        err := ma.db.QueryRow(query, mediaItemID).Scan(
                &amp;item.ID, &amp;item.MediaTypeID, &amp;item.Title, &amp;item.Year, &amp;item.Description,
                &amp;genreJSON, &amp;item.Director, &amp;castCrewJSON, &amp;item.Rating, &amp;item.Runtime,
                &amp;item.Language, &amp;item.Country, &amp;item.Status, &amp;item.FirstDetected, &amp;item.LastUpdated,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unmarshal JSON fields
        <span class="cov0" title="0">json.Unmarshal([]byte(genreJSON), &amp;item.Genre)
        json.Unmarshal([]byte(castCrewJSON), &amp;item.CastCrew)

        // Update last_updated timestamp
        _, err = ma.db.Exec("UPDATE media_items SET last_updated = ? WHERE id = ?", time.Now(), mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">item.LastUpdated = time.Now()
        return &amp;item, nil</span>
}

// fetchExternalMetadata fetches metadata from external providers
func (ma *MediaAnalyzer) fetchExternalMetadata(ctx context.Context, mediaItem *mediamodels.MediaItem) ([]mediamodels.ExternalMetadata, error) <span class="cov0" title="0">{
        if mediaItem.MediaType == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("media type not available")
        }</span>

        // Get the best match from providers
        <span class="cov0" title="0">bestResult, providerName, err := ma.providerManager.GetBestMatch(
                ctx, mediaItem.Title, mediaItem.MediaType.Name, mediaItem.Year,
        )
        if err != nil || bestResult == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get detailed metadata
        <span class="cov0" title="0">metadata, err := ma.providerManager.GetDetails(ctx, providerName, bestResult.ExternalID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">metadata.MediaItemID = mediaItem.ID

        // Save to database
        query := `
                INSERT OR REPLACE INTO external_metadata
                (media_item_id, provider, external_id, data, rating, review_url, cover_url, trailer_url, last_fetched)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = ma.db.Exec(query,
                metadata.MediaItemID, metadata.Provider, metadata.ExternalID, metadata.Data,
                metadata.Rating, metadata.ReviewURL, metadata.CoverURL, metadata.TrailerURL, metadata.LastFetched,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return []mediamodels.ExternalMetadata{*metadata}, nil</span>
}

// analyzeQuality analyzes the quality of media files
func (ma *MediaAnalyzer) analyzeQuality(files []models.FileInfo, mediaItem *mediamodels.MediaItem) (*QualityAnalysis, error) <span class="cov0" title="0">{
        if mediaItem.MediaType == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("media type not available")
        }</span>

        <span class="cov0" title="0">analysis := &amp;QualityAnalysis{
                AvailableQualities: make([]string, 0),
                TotalFiles:         len(files),
        }

        // Analyze video/audio files
        mediaFiles := ma.filterMediaFiles(files, mediaItem.MediaType.Name)
        analysis.TotalFiles = len(mediaFiles)

        for _, file := range mediaFiles </span><span class="cov0" title="0">{
                analysis.TotalSize += file.Size

                // Extract quality information from filename
                qualityInfo := ma.extractQualityFromFilename(file.Name, file.Extension)
                if qualityInfo != nil </span><span class="cov0" title="0">{
                        qualityName := qualityInfo.GetDisplayName()
                        if !contains(analysis.AvailableQualities, qualityName) </span><span class="cov0" title="0">{
                                analysis.AvailableQualities = append(analysis.AvailableQualities, qualityName)
                        }</span>

                        // Track best quality
                        <span class="cov0" title="0">if analysis.BestQuality == nil || qualityInfo.IsBetterThan(analysis.BestQuality) </span><span class="cov0" title="0">{
                                analysis.BestQuality = qualityInfo
                        }</span>
                }
        }

        <span class="cov0" title="0">return analysis, nil</span>
}

// filterMediaFiles filters files relevant to the media type
func (ma *MediaAnalyzer) filterMediaFiles(files []models.FileInfo, mediaType string) []models.FileInfo <span class="cov0" title="0">{
        mediaExtensions := map[string][]string{
                "movie":     {".mp4", ".mkv", ".avi", ".mov", ".wmv", ".flv", ".m4v"},
                "tv_show":   {".mp4", ".mkv", ".avi", ".mov", ".wmv", ".flv", ".m4v"},
                "anime":     {".mp4", ".mkv", ".avi", ".mov", ".wmv", ".flv", ".m4v"},
                "music":     {".mp3", ".flac", ".wav", ".m4a", ".aac", ".ogg", ".wma"},
                "audiobook": {".mp3", ".m4a", ".m4b", ".aac", ".ogg"},
                "podcast":   {".mp3", ".m4a", ".aac", ".ogg"},
        }

        extensions, exists := mediaExtensions[mediaType]
        if !exists </span><span class="cov0" title="0">{
                return files // Return all files if media type not recognized
        }</span>

        <span class="cov0" title="0">var filtered []models.FileInfo
        for _, file := range files </span><span class="cov0" title="0">{
                if file.IsDirectory </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if file.Extension != nil </span><span class="cov0" title="0">{
                        for _, ext := range extensions </span><span class="cov0" title="0">{
                                if strings.EqualFold(*file.Extension, ext) </span><span class="cov0" title="0">{
                                        filtered = append(filtered, file)
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return filtered</span>
}

// extractQualityFromFilename extracts quality information from filename
func (ma *MediaAnalyzer) extractQualityFromFilename(filename string, extension *string) *mediamodels.QualityInfo <span class="cov0" title="0">{
        lower := strings.ToLower(filename)
        quality := &amp;mediamodels.QualityInfo{}

        // Resolution detection
        if strings.Contains(lower, "2160p") || strings.Contains(lower, "4k") || strings.Contains(lower, "uhd") </span><span class="cov0" title="0">{
                quality.Resolution = &amp;mediamodels.Resolution{Width: 3840, Height: 2160}
                quality.QualityScore = 100
                profile := "4K/UHD"
                quality.QualityProfile = &amp;profile
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "1080p") || strings.Contains(lower, "fhd") </span><span class="cov0" title="0">{
                quality.Resolution = &amp;mediamodels.Resolution{Width: 1920, Height: 1080}
                quality.QualityScore = 80
                profile := "1080p"
                quality.QualityProfile = &amp;profile
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "720p") || strings.Contains(lower, "hd") </span><span class="cov0" title="0">{
                quality.Resolution = &amp;mediamodels.Resolution{Width: 1280, Height: 720}
                quality.QualityScore = 60
                profile := "720p"
                quality.QualityProfile = &amp;profile
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "480p") || strings.Contains(lower, "dvd") </span><span class="cov0" title="0">{
                quality.Resolution = &amp;mediamodels.Resolution{Width: 720, Height: 480}
                quality.QualityScore = 40
                profile := "480p/DVD"
                quality.QualityProfile = &amp;profile
        }</span>

        // Source detection
        <span class="cov0" title="0">if strings.Contains(lower, "bluray") || strings.Contains(lower, "brrip") </span><span class="cov0" title="0">{
                source := "BluRay"
                quality.Source = &amp;source
                quality.QualityScore += 10
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "webdl") || strings.Contains(lower, "web-dl") </span><span class="cov0" title="0">{
                source := "WEB-DL"
                quality.Source = &amp;source
                quality.QualityScore += 5
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "webrip") </span><span class="cov0" title="0">{
                source := "WEB-RIP"
                quality.Source = &amp;source
        }</span>

        // Codec detection
        <span class="cov0" title="0">if strings.Contains(lower, "x265") || strings.Contains(lower, "h265") || strings.Contains(lower, "hevc") </span><span class="cov0" title="0">{
                codec := "H.265/HEVC"
                quality.VideoCodec = &amp;codec
                quality.QualityScore += 5
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "x264") || strings.Contains(lower, "h264") || strings.Contains(lower, "avc") </span><span class="cov0" title="0">{
                codec := "H.264/AVC"
                quality.VideoCodec = &amp;codec
        }</span>

        // Audio codec detection
        <span class="cov0" title="0">if strings.Contains(lower, "dts") </span><span class="cov0" title="0">{
                audioCodec := "DTS"
                quality.AudioCodec = &amp;audioCodec
                quality.QualityScore += 5
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "aac") </span><span class="cov0" title="0">{
                audioCodec := "AAC"
                quality.AudioCodec = &amp;audioCodec
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "ac3") </span><span class="cov0" title="0">{
                audioCodec := "AC3"
                quality.AudioCodec = &amp;audioCodec
        }</span>

        // HDR detection
        <span class="cov0" title="0">if strings.Contains(lower, "hdr") || strings.Contains(lower, "dolby.vision") </span><span class="cov0" title="0">{
                quality.HDR = true
                quality.QualityScore += 10
        }</span>

        // For audio files
        <span class="cov0" title="0">if extension != nil </span><span class="cov0" title="0">{
                ext := strings.ToLower(*extension)
                if ext == ".flac" || ext == ".wav" </span><span class="cov0" title="0">{
                        quality.QualityScore = 90
                        profile := "Audio_Lossless"
                        quality.QualityProfile = &amp;profile
                }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "320") || strings.Contains(lower, "320k") </span><span class="cov0" title="0">{
                        quality.QualityScore = 70
                        profile := "Audio_320k"
                        quality.QualityProfile = &amp;profile
                }</span> else<span class="cov0" title="0"> if ext == ".mp3" </span><span class="cov0" title="0">{
                        quality.QualityScore = 50
                        profile := "Audio_128k"
                        quality.QualityProfile = &amp;profile
                }</span>
        }

        <span class="cov0" title="0">return quality</span>
}

// updateMediaFiles creates or updates media file records
func (ma *MediaAnalyzer) updateMediaFiles(mediaItemID int64, files []models.FileInfo, directoryPath, smbRoot string) ([]mediamodels.MediaFile, error) <span class="cov0" title="0">{
        var updatedFiles []mediamodels.MediaFile

        for _, file := range files </span><span class="cov0" title="0">{
                if file.IsDirectory </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract quality info
                <span class="cov0" title="0">qualityInfo := ma.extractQualityFromFilename(file.Name, file.Extension)
                qualityJSON, _ := json.Marshal(qualityInfo)

                // Generate SMB links
                directSmbLink := fmt.Sprintf("smb://%s/%s", smbRoot, file.Path)
                virtualSmbLink := fmt.Sprintf("virtual://%s/%d", smbRoot, file.ID)

                query := `
                        INSERT OR REPLACE INTO media_files
                        (media_item_id, file_path, smb_root, filename, file_size, file_extension, quality_info,
                         direct_smb_link, virtual_smb_link, last_verified, created_at)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                `

                _, err := ma.db.Exec(query,
                        mediaItemID, file.Path, smbRoot, file.Name, file.Size, file.Extension,
                        string(qualityJSON), directSmbLink, virtualSmbLink, time.Now(), time.Now(),
                )
                if err != nil </span><span class="cov0" title="0">{
                        ma.logger.Error("Failed to update media file", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">mediaFile := mediamodels.MediaFile{
                        MediaItemID:    mediaItemID,
                        FilePath:       file.Path,
                        SmbRoot:        smbRoot,
                        Filename:       file.Name,
                        FileSize:       file.Size,
                        FileExtension:  file.Extension,
                        QualityInfo:    qualityInfo,
                        DirectSmbLink:  directSmbLink,
                        VirtualSmbLink: &amp;virtualSmbLink,
                        LastVerified:   time.Now(),
                        CreatedAt:      time.Now(),
                }

                updatedFiles = append(updatedFiles, mediaFile)</span>
        }

        <span class="cov0" title="0">return updatedFiles, nil</span>
}

// Helper function
func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "io/ioutil"
        "path/filepath"

        _ "github.com/mattn/go-sqlite3"
        "go.uber.org/zap"
)

// MediaDatabase handles SQLite database with SQLCipher encryption
type MediaDatabase struct {
        db       *sql.DB
        dbPath   string
        password string
        logger   *zap.Logger
}

// DatabaseConfig represents database configuration
type DatabaseConfig struct {
        Path     string `json:"path"`
        Password string `json:"password"`
}

// NewMediaDatabase creates a new encrypted media database
func NewMediaDatabase(config DatabaseConfig, logger *zap.Logger) (*MediaDatabase, error) <span class="cov0" title="0">{
        if config.Path == "" </span><span class="cov0" title="0">{
                config.Path = "media_catalog.db"
        }</span>

        <span class="cov0" title="0">if config.Password == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database password is required for encryption")
        }</span>

        <span class="cov0" title="0">mdb := &amp;MediaDatabase{
                dbPath:   config.Path,
                password: config.Password,
                logger:   logger,
        }

        if err := mdb.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">if err := mdb.initialize(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize database: %w", err)
        }</span>

        <span class="cov0" title="0">return mdb, nil</span>
}

// connect establishes connection to the encrypted database
func (mdb *MediaDatabase) connect() error <span class="cov0" title="0">{
        // Connection string for SQLCipher
        dsn := fmt.Sprintf("file:%s?_pragma_key=%s&amp;_pragma_cipher_page_size=4096", mdb.dbPath, mdb.password)

        db, err := sql.Open("sqlcipher", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Test the connection and encryption
        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return fmt.Errorf("failed to ping database: %w", err)
        }</span>

        // Verify encryption is working
        <span class="cov0" title="0">var result string
        err = db.QueryRow("PRAGMA cipher_version").Scan(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                db.Close()
                return fmt.Errorf("failed to verify encryption: %w", err)
        }</span>

        <span class="cov0" title="0">mdb.db = db
        mdb.logger.Info("Connected to encrypted media database",
                zap.String("path", mdb.dbPath),
                zap.String("cipher_version", result))

        return nil</span>
}

// initialize creates database schema
func (mdb *MediaDatabase) initialize() error <span class="cov0" title="0">{
        // Read schema from file
        schemaPath := filepath.Join(filepath.Dir(mdb.dbPath), "schema.sql")
        schemaContent, err := ioutil.ReadFile(schemaPath)
        if err != nil </span><span class="cov0" title="0">{
                // If schema file doesn't exist, use embedded schema
                return mdb.createSchemaFromString(getEmbeddedSchema())
        }</span>

        <span class="cov0" title="0">return mdb.createSchemaFromString(string(schemaContent))</span>
}

// createSchemaFromString executes schema SQL
func (mdb *MediaDatabase) createSchemaFromString(schema string) error <span class="cov0" title="0">{
        // Execute schema in a transaction
        tx, err := mdb.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        if _, err := tx.Exec(schema); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute schema: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit schema: %w", err)
        }</span>

        <span class="cov0" title="0">mdb.logger.Info("Database schema initialized successfully")
        return nil</span>
}

// GetDB returns the database connection
func (mdb *MediaDatabase) GetDB() *sql.DB <span class="cov0" title="0">{
        return mdb.db
}</span>

// Close closes the database connection
func (mdb *MediaDatabase) Close() error <span class="cov0" title="0">{
        if mdb.db != nil </span><span class="cov0" title="0">{
                return mdb.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Backup creates an encrypted backup of the database
func (mdb *MediaDatabase) Backup(backupPath string) error <span class="cov0" title="0">{
        _, err := mdb.db.Exec(fmt.Sprintf(`
                ATTACH DATABASE '%s' AS backup KEY '%s';
                INSERT INTO backup.sqlite_master SELECT * FROM main.sqlite_master WHERE type='table';
        `, backupPath, mdb.password))

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("backup failed: %w", err)
        }</span>

        // Copy all tables
        <span class="cov0" title="0">tables, err := mdb.getTables()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get tables: %w", err)
        }</span>

        <span class="cov0" title="0">tx, err := mdb.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin backup transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Attach backup database
        if _, err := tx.Exec(fmt.Sprintf("ATTACH DATABASE '%s' AS backup KEY '%s'", backupPath, mdb.password)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to attach backup database: %w", err)
        }</span>

        // Copy each table
        <span class="cov0" title="0">for _, table := range tables </span><span class="cov0" title="0">{
                copyQuery := fmt.Sprintf("CREATE TABLE backup.%s AS SELECT * FROM main.%s", table, table)
                if _, err := tx.Exec(copyQuery); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to copy table %s: %w", table, err)
                }</span>
        }

        // Detach backup database
        <span class="cov0" title="0">if _, err := tx.Exec("DETACH DATABASE backup"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to detach backup database: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit backup: %w", err)
        }</span>

        <span class="cov0" title="0">mdb.logger.Info("Database backup created", zap.String("backup_path", backupPath))
        return nil</span>
}

// HealthCheck verifies database health
func (mdb *MediaDatabase) HealthCheck() error <span class="cov0" title="0">{
        // Check database integrity
        var result string
        if err := mdb.db.QueryRow("PRAGMA integrity_check").Scan(&amp;result); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integrity check failed: %w", err)
        }</span>

        <span class="cov0" title="0">if result != "ok" </span><span class="cov0" title="0">{
                return fmt.Errorf("database integrity check failed: %s", result)
        }</span>

        // Check if we can read from a table
        <span class="cov0" title="0">var count int
        if err := mdb.db.QueryRow("SELECT COUNT(*) FROM media_types").Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query media_types: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetStats returns database statistics
func (mdb *MediaDatabase) GetStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Database size
        var pageCount, pageSize int64
        if err := mdb.db.QueryRow("PRAGMA page_count").Scan(&amp;pageCount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := mdb.db.QueryRow("PRAGMA page_size").Scan(&amp;pageSize); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">stats["size_bytes"] = pageCount * pageSize

        // Table counts
        tableCounts := map[string]int64{
                "media_types":        0,
                "media_items":        0,
                "external_metadata":  0,
                "directory_analysis": 0,
                "media_files":        0,
                "media_collections":  0,
                "user_metadata":      0,
        }

        for table := range tableCounts </span><span class="cov0" title="0">{
                var count int64
                query := fmt.Sprintf("SELECT COUNT(*) FROM %s", table)
                if err := mdb.db.QueryRow(query).Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                        mdb.logger.Error("Failed to count table", zap.String("table", table), zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">tableCounts[table] = count</span>
        }
        <span class="cov0" title="0">stats["table_counts"] = tableCounts

        // Recent activity
        var recentAnalysis int64
        if err := mdb.db.QueryRow("SELECT COUNT(*) FROM directory_analysis WHERE last_analyzed &gt; datetime('now', '-24 hours')").Scan(&amp;recentAnalysis); err == nil </span><span class="cov0" title="0">{
                stats["recent_analysis_24h"] = recentAnalysis
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// getTables returns list of all tables
func (mdb *MediaDatabase) getTables() ([]string, error) <span class="cov0" title="0">{
        rows, err := mdb.db.Query("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tables []string
        for rows.Next() </span><span class="cov0" title="0">{
                var table string
                if err := rows.Scan(&amp;table); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">tables = append(tables, table)</span>
        }

        <span class="cov0" title="0">return tables, nil</span>
}

// getEmbeddedSchema returns the embedded schema as fallback
func getEmbeddedSchema() string <span class="cov0" title="0">{
        return `
-- Simplified embedded schema for fallback
CREATE TABLE IF NOT EXISTS media_types (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    detection_patterns TEXT,
    metadata_providers TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS media_items (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    media_type_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    original_title TEXT,
    year INTEGER,
    description TEXT,
    genre TEXT,
    director TEXT,
    cast_crew TEXT,
    rating REAL,
    runtime INTEGER,
    language TEXT,
    country TEXT,
    status TEXT DEFAULT 'active',
    first_detected DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (media_type_id) REFERENCES media_types(id)
);

CREATE TABLE IF NOT EXISTS external_metadata (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    media_item_id INTEGER NOT NULL,
    provider TEXT NOT NULL,
    external_id TEXT NOT NULL,
    data TEXT NOT NULL,
    rating REAL,
    review_url TEXT,
    cover_url TEXT,
    trailer_url TEXT,
    last_fetched DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (media_item_id) REFERENCES media_items(id),
    UNIQUE(media_item_id, provider)
);

CREATE TABLE IF NOT EXISTS directory_analysis (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    directory_path TEXT NOT NULL UNIQUE,
    smb_root TEXT NOT NULL,
    media_item_id INTEGER,
    confidence_score REAL NOT NULL,
    detection_method TEXT NOT NULL,
    analysis_data TEXT,
    last_analyzed DATETIME DEFAULT CURRENT_TIMESTAMP,
    files_count INTEGER DEFAULT 0,
    total_size INTEGER DEFAULT 0,
    FOREIGN KEY (media_item_id) REFERENCES media_items(id)
);

CREATE TABLE IF NOT EXISTS media_files (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    media_item_id INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    smb_root TEXT NOT NULL,
    filename TEXT NOT NULL,
    file_size INTEGER NOT NULL,
    file_extension TEXT,
    quality_info TEXT,
    language TEXT,
    subtitle_tracks TEXT,
    audio_tracks TEXT,
    duration INTEGER,
    checksum TEXT,
    virtual_smb_link TEXT,
    direct_smb_link TEXT,
    last_verified DATETIME DEFAULT CURRENT_TIMESTAMP,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (media_item_id) REFERENCES media_items(id)
);

-- Insert basic media types
INSERT OR IGNORE INTO media_types (name, description) VALUES
('movie', 'Feature films and movies'),
('tv_show', 'Television series and episodes'),
('music', 'Music albums and tracks'),
('game', 'Video games and software'),
('software', 'Applications and utilities'),
('training', 'Educational and training content'),
('other', 'Unclassified content');
`
}</span>

// Vacuum optimizes the database
func (mdb *MediaDatabase) Vacuum() error <span class="cov0" title="0">{
        mdb.logger.Info("Starting database vacuum")
        if _, err := mdb.db.Exec("VACUUM"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("vacuum failed: %w", err)
        }</span>
        <span class="cov0" title="0">mdb.logger.Info("Database vacuum completed")
        return nil</span>
}

// ChangePassword changes the database encryption password
func (mdb *MediaDatabase) ChangePassword(newPassword string) error <span class="cov0" title="0">{
        if newPassword == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("new password cannot be empty")
        }</span>

        <span class="cov0" title="0">pragma := fmt.Sprintf("PRAGMA rekey = '%s'", newPassword)
        if _, err := mdb.db.Exec(pragma); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to change password: %w", err)
        }</span>

        <span class="cov0" title="0">mdb.password = newPassword
        mdb.logger.Info("Database password changed successfully")
        return nil</span>
}

// ExecuteInTransaction executes multiple statements in a transaction
func (mdb *MediaDatabase) ExecuteInTransaction(fn func(*sql.Tx) error) error <span class="cov0" title="0">{
        tx, err := mdb.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        if err := fn(tx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package detector

import (
        "catalogizer/internal/media/models"
        "encoding/json"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "time"

        "go.uber.org/zap"
)

// DetectionEngine handles automatic content type detection
type DetectionEngine struct {
        logger     *zap.Logger
        rules      []models.DetectionRule
        mediaTypes map[int64]*models.MediaType
}

// NewDetectionEngine creates a new detection engine
func NewDetectionEngine(logger *zap.Logger) *DetectionEngine <span class="cov0" title="0">{
        return &amp;DetectionEngine{
                logger:     logger,
                rules:      []models.DetectionRule{},
                mediaTypes: make(map[int64]*models.MediaType),
        }
}</span>

// LoadRules loads detection rules from database or configuration
func (e *DetectionEngine) LoadRules(rules []models.DetectionRule, mediaTypes []models.MediaType) <span class="cov0" title="0">{
        e.rules = rules

        // Sort rules by priority (higher first)
        sort.Slice(e.rules, func(i, j int) bool </span><span class="cov0" title="0">{
                return e.rules[i].Priority &gt; e.rules[j].Priority
        }</span>)

        // Index media types
        <span class="cov0" title="0">for _, mt := range mediaTypes </span><span class="cov0" title="0">{
                e.mediaTypes[mt.ID] = &amp;mt
        }</span>

        <span class="cov0" title="0">e.logger.Info("Detection rules loaded",
                zap.Int("rules_count", len(e.rules)),
                zap.Int("media_types", len(e.mediaTypes)))</span>
}

// DetectionResult represents the result of content detection
type DetectionResult struct {
        MediaTypeID     int64                `json:"media_type_id"`
        MediaType       *models.MediaType    `json:"media_type"`
        Confidence      float64              `json:"confidence"`
        Method          string               `json:"method"`
        MatchedPatterns []string             `json:"matched_patterns"`
        AnalysisData    *models.AnalysisData `json:"analysis_data"`
        SuggestedTitle  string               `json:"suggested_title"`
        SuggestedYear   *int                 `json:"suggested_year"`
        QualityHints    []string             `json:"quality_hints"`
}

// AnalyzeDirectory analyzes a directory to determine its content type
func (e *DetectionEngine) AnalyzeDirectory(directoryPath string, files []FileInfo) (*DetectionResult, error) <span class="cov0" title="0">{
        results := make([]*DetectionResult, 0)

        // Run all enabled rules
        for _, rule := range e.rules </span><span class="cov0" title="0">{
                if !rule.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">mediaType := e.mediaTypes[rule.MediaTypeID]
                if mediaType == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var confidence float64
                var matchedPatterns []string
                var method string

                switch rule.RuleType </span>{
                case "filename_pattern":<span class="cov0" title="0">
                        confidence, matchedPatterns = e.analyzeFilenamePatterns(rule.Pattern, files)
                        method = "filename_pattern"</span>

                case "directory_structure":<span class="cov0" title="0">
                        confidence, matchedPatterns = e.analyzeDirectoryStructure(rule.Pattern, directoryPath, files)
                        method = "directory_structure"</span>

                case "file_analysis":<span class="cov0" title="0">
                        confidence, matchedPatterns = e.analyzeFileContent(rule.Pattern, files)
                        method = "file_analysis"</span>

                case "hybrid":<span class="cov0" title="0">
                        confidence, matchedPatterns = e.analyzeHybrid(rule.Pattern, directoryPath, files)
                        method = "hybrid"</span>
                }

                <span class="cov0" title="0">if confidence &gt; 0 </span><span class="cov0" title="0">{
                        // Apply rule weight
                        confidence *= rule.ConfidenceWeight

                        // Extract additional metadata
                        title, year := e.extractTitleAndYear(directoryPath, files, mediaType.Name)
                        qualityHints := e.extractQualityHints(directoryPath, files)

                        result := &amp;DetectionResult{
                                MediaTypeID:     rule.MediaTypeID,
                                MediaType:       mediaType,
                                Confidence:      confidence,
                                Method:          method,
                                MatchedPatterns: matchedPatterns,
                                SuggestedTitle:  title,
                                SuggestedYear:   year,
                                QualityHints:    qualityHints,
                                AnalysisData:    e.buildAnalysisData(directoryPath, files, matchedPatterns, confidence),
                        }

                        results = append(results, result)
                }</span>
        }

        // Return the highest confidence result
        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Sort by confidence
        <span class="cov0" title="0">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                return results[i].Confidence &gt; results[j].Confidence
        }</span>)

        <span class="cov0" title="0">return results[0], nil</span>
}

// FileInfo represents basic file information for analysis
type FileInfo struct {
        Name      string
        Path      string
        Size      int64
        Extension string
        IsDir     bool
}

// analyzeFilenamePatterns checks files against filename patterns
func (e *DetectionEngine) analyzeFilenamePatterns(pattern string, files []FileInfo) (float64, []string) <span class="cov0" title="0">{
        var patterns []string
        if err := json.Unmarshal([]byte(pattern), &amp;patterns); err != nil </span><span class="cov0" title="0">{
                // Single pattern
                patterns = []string{pattern}
        }</span>

        <span class="cov0" title="0">totalFiles := len(files)
        if totalFiles == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">matchedFiles := 0
        matchedPatterns := make([]string, 0)

        for _, p := range patterns </span><span class="cov0" title="0">{
                regex, err := e.globToRegex(p)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                        if regex.MatchString(strings.ToLower(file.Name)) </span><span class="cov0" title="0">{
                                matchedFiles++
                                matchedPatterns = append(matchedPatterns, p)
                                break</span> // Don't count same pattern multiple times
                        }
                }
        }

        <span class="cov0" title="0">confidence := float64(matchedFiles) / float64(len(patterns))
        if confidence &gt; 1.0 </span><span class="cov0" title="0">{
                confidence = 1.0
        }</span>

        <span class="cov0" title="0">return confidence, matchedPatterns</span>
}

// analyzeDirectoryStructure analyzes directory structure patterns
func (e *DetectionEngine) analyzeDirectoryStructure(pattern string, dirPath string, files []FileInfo) (float64, []string) <span class="cov0" title="0">{
        var structureRules map[string]interface{}
        if err := json.Unmarshal([]byte(pattern), &amp;structureRules); err != nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">confidence := 0.0
        matchedPatterns := make([]string, 0)

        // Check for required directories
        if requiredDirs, ok := structureRules["required_dirs"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, reqDir := range requiredDirs </span><span class="cov0" title="0">{
                        dirName := reqDir.(string)
                        found := false
                        for _, file := range files </span><span class="cov0" title="0">{
                                if file.IsDir &amp;&amp; strings.Contains(strings.ToLower(file.Name), strings.ToLower(dirName)) </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                                confidence += 0.3
                                matchedPatterns = append(matchedPatterns, "dir:"+dirName)
                        }</span>
                }
        }

        // Check for file type distribution
        <span class="cov0" title="0">if fileTypes, ok := structureRules["file_types"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for ext, minCount := range fileTypes </span><span class="cov0" title="0">{
                        count := 0
                        for _, file := range files </span><span class="cov0" title="0">{
                                if strings.EqualFold(file.Extension, ext) </span><span class="cov0" title="0">{
                                        count++
                                }</span>
                        }
                        <span class="cov0" title="0">if count &gt;= int(minCount.(float64)) </span><span class="cov0" title="0">{
                                confidence += 0.2
                                matchedPatterns = append(matchedPatterns, "filetype:"+ext)
                        }</span>
                }
        }

        // Normalize confidence
        <span class="cov0" title="0">if confidence &gt; 1.0 </span><span class="cov0" title="0">{
                confidence = 1.0
        }</span>

        <span class="cov0" title="0">return confidence, matchedPatterns</span>
}

// analyzeFileContent analyzes actual file content (basic implementation)
func (e *DetectionEngine) analyzeFileContent(pattern string, files []FileInfo) (float64, []string) <span class="cov0" title="0">{
        // This would implement more sophisticated content analysis
        // For now, it's a placeholder that analyzes file extensions and sizes

        var contentRules map[string]interface{}
        if err := json.Unmarshal([]byte(pattern), &amp;contentRules); err != nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">confidence := 0.0
        matchedPatterns := make([]string, 0)

        // Analyze file size patterns
        if sizeRules, ok := contentRules["size_patterns"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for sizeType, conditions := range sizeRules </span><span class="cov0" title="0">{
                        condMap := conditions.(map[string]interface{})
                        minSize := int64(condMap["min_size"].(float64))
                        maxSize := int64(condMap["max_size"].(float64))

                        matchCount := 0
                        for _, file := range files </span><span class="cov0" title="0">{
                                if file.Size &gt;= minSize &amp;&amp; file.Size &lt;= maxSize </span><span class="cov0" title="0">{
                                        matchCount++
                                }</span>
                        }

                        <span class="cov0" title="0">if matchCount &gt; 0 </span><span class="cov0" title="0">{
                                confidence += 0.2
                                matchedPatterns = append(matchedPatterns, "size:"+sizeType)
                        }</span>
                }
        }

        <span class="cov0" title="0">return confidence, matchedPatterns</span>
}

// analyzeHybrid combines multiple analysis methods
func (e *DetectionEngine) analyzeHybrid(pattern string, dirPath string, files []FileInfo) (float64, []string) <span class="cov0" title="0">{
        var hybridRules map[string]interface{}
        if err := json.Unmarshal([]byte(pattern), &amp;hybridRules); err != nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">totalConfidence := 0.0
        allPatterns := make([]string, 0)

        // Run filename analysis
        if filenamePattern, ok := hybridRules["filename"].(string); ok </span><span class="cov0" title="0">{
                conf, patterns := e.analyzeFilenamePatterns(filenamePattern, files)
                totalConfidence += conf * 0.4
                allPatterns = append(allPatterns, patterns...)
        }</span>

        // Run structure analysis
        <span class="cov0" title="0">if structurePattern, ok := hybridRules["structure"].(string); ok </span><span class="cov0" title="0">{
                conf, patterns := e.analyzeDirectoryStructure(structurePattern, dirPath, files)
                totalConfidence += conf * 0.3
                allPatterns = append(allPatterns, patterns...)
        }</span>

        // Run content analysis
        <span class="cov0" title="0">if contentPattern, ok := hybridRules["content"].(string); ok </span><span class="cov0" title="0">{
                conf, patterns := e.analyzeFileContent(contentPattern, files)
                totalConfidence += conf * 0.3
                allPatterns = append(allPatterns, patterns...)
        }</span>

        <span class="cov0" title="0">return totalConfidence, allPatterns</span>
}

// extractTitleAndYear extracts title and year from directory/file names
func (e *DetectionEngine) extractTitleAndYear(dirPath string, files []FileInfo, mediaType string) (string, *int) <span class="cov0" title="0">{
        dirName := filepath.Base(dirPath)

        // Extract year using regex
        yearRegex := regexp.MustCompile(`\((\d{4})\)|\[(\d{4})\]|(\d{4})`)
        yearMatches := yearRegex.FindStringSubmatch(dirName)

        var year *int
        if len(yearMatches) &gt; 0 </span><span class="cov0" title="0">{
                for i := 1; i &lt; len(yearMatches); i++ </span><span class="cov0" title="0">{
                        if yearMatches[i] != "" </span><span class="cov0" title="0">{
                                if y := parseInt(yearMatches[i]); y &gt; 1900 &amp;&amp; y &lt;= time.Now().Year()+5 </span><span class="cov0" title="0">{
                                        year = &amp;y
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        // Clean title
        <span class="cov0" title="0">title := dirName

        // Remove year from title
        if year != nil </span><span class="cov0" title="0">{
                title = yearRegex.ReplaceAllString(title, "")
        }</span>

        // Remove common release info
        <span class="cov0" title="0">cleanupRegex := regexp.MustCompile(`(?i)\b(bluray|brrip|dvdrip|webrip|hdtv|720p|1080p|4k|x264|x265|h264|h265|aac|dts|ac3|complete|season|series)\b`)
        title = cleanupRegex.ReplaceAllString(title, "")

        // Clean up extra spaces and dots
        title = regexp.MustCompile(`[._\-\s]+`).ReplaceAllString(title, " ")
        title = strings.TrimSpace(title)

        return title, year</span>
}

// extractQualityHints extracts quality indicators from filenames
func (e *DetectionEngine) extractQualityHints(dirPath string, files []FileInfo) []string <span class="cov0" title="0">{
        hints := make([]string, 0)
        text := strings.ToLower(dirPath)

        // Add file names to analysis
        for _, file := range files </span><span class="cov0" title="0">{
                text += " " + strings.ToLower(file.Name)
        }</span>

        <span class="cov0" title="0">qualityPatterns := map[string][]string{
                "4K":       {"4k", "uhd", "2160p"},
                "1080p":    {"1080p", "fullhd", "fhd"},
                "720p":     {"720p", "hd"},
                "BluRay":   {"bluray", "brrip", "bd"},
                "WEB-DL":   {"webdl", "web-dl", "webrip"},
                "HDR":      {"hdr", "hdr10", "dolby.vision"},
                "Lossless": {"flac", "lossless", "dts-hd"},
                "Remux":    {"remux"},
        }

        for quality, patterns := range qualityPatterns </span><span class="cov0" title="0">{
                for _, pattern := range patterns </span><span class="cov0" title="0">{
                        if strings.Contains(text, pattern) </span><span class="cov0" title="0">{
                                hints = append(hints, quality)
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return hints</span>
}

// buildAnalysisData creates detailed analysis information
func (e *DetectionEngine) buildAnalysisData(dirPath string, files []FileInfo, patterns []string, confidence float64) *models.AnalysisData <span class="cov0" title="0">{
        fileTypes := make(map[string]int)
        sizeDistribution := make(map[string]int64)

        for _, file := range files </span><span class="cov0" title="0">{
                if file.Extension != "" </span><span class="cov0" title="0">{
                        fileTypes[file.Extension]++
                }</span>

                // Categorize by size
                <span class="cov0" title="0">var sizeCategory string
                switch </span>{
                case file.Size &gt; 10*1024*1024*1024:<span class="cov0" title="0"> // &gt; 10GB
                        sizeCategory = "very_large"</span>
                case file.Size &gt; 1024*1024*1024:<span class="cov0" title="0"> // &gt; 1GB
                        sizeCategory = "large"</span>
                case file.Size &gt; 100*1024*1024:<span class="cov0" title="0"> // &gt; 100MB
                        sizeCategory = "medium"</span>
                case file.Size &gt; 10*1024*1024:<span class="cov0" title="0"> // &gt; 10MB
                        sizeCategory = "small"</span>
                default:<span class="cov0" title="0">
                        sizeCategory = "tiny"</span>
                }
                <span class="cov0" title="0">sizeDistribution[sizeCategory] += file.Size</span>
        }

        <span class="cov0" title="0">return &amp;models.AnalysisData{
                MatchedPatterns:   patterns,
                FileTypes:         fileTypes,
                SizeDistribution:  sizeDistribution,
                QualityIndicators: e.extractQualityHints(dirPath, files),
                FilenameScore:     confidence * 0.4,
                StructureScore:    confidence * 0.3,
                MetadataScore:     confidence * 0.3,
        }</span>
}

// Helper functions
func (e *DetectionEngine) globToRegex(glob string) (*regexp.Regexp, error) <span class="cov0" title="0">{
        // Convert glob pattern to regex
        pattern := strings.ReplaceAll(glob, "*", ".*")
        pattern = strings.ReplaceAll(pattern, "?", ".")
        pattern = "^" + pattern + "$"
        return regexp.Compile("(?i)" + pattern)
}</span>

func parseInt(s string) int <span class="cov0" title="0">{
        var result int
        for _, char := range s </span><span class="cov0" title="0">{
                if char &gt;= '0' &amp;&amp; char &lt;= '9' </span><span class="cov0" title="0">{
                        result = result*10 + int(char-'0')
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// GetSupportedMediaTypes returns all supported media types
func (e *DetectionEngine) GetSupportedMediaTypes() []models.MediaType <span class="cov0" title="0">{
        types := make([]models.MediaType, 0, len(e.mediaTypes))
        for _, mt := range e.mediaTypes </span><span class="cov0" title="0">{
                types = append(types, *mt)
        }</span>
        <span class="cov0" title="0">return types</span>
}

// ValidateDetection validates a detection result
func (e *DetectionEngine) ValidateDetection(result *DetectionResult) bool <span class="cov0" title="0">{
        if result == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Minimum confidence threshold
        <span class="cov0" title="0">if result.Confidence &lt; 0.1 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Must have at least one matched pattern
        <span class="cov0" title="0">if len(result.MatchedPatterns) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package media

import (
        "catalogizer/internal/config"
        "catalogizer/internal/media/analyzer"
        "catalogizer/internal/media/database"
        "catalogizer/internal/media/detector"
        "catalogizer/internal/media/models"
        "catalogizer/internal/media/providers"
        "catalogizer/internal/media/realtime"
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "path/filepath"
        "time"

        "go.uber.org/zap"
)

// MediaManager orchestrates all media-related functionality
type MediaManager struct {
        config          *config.Config
        logger          *zap.Logger
        mediaDB         *database.MediaDatabase
        detector        *detector.DetectionEngine
        providerManager *providers.ProviderManager
        analyzer        *analyzer.MediaAnalyzer
        changeWatcher   *realtime.SMBChangeWatcher
        started         bool
}

// MediaConfig represents media-specific configuration
type MediaConfig struct {
        DatabasePath     string            `json:"database_path"`
        DatabasePassword string            `json:"database_password"`
        APIKeys          map[string]string `json:"api_keys"`
        WatchPaths       []WatchPath       `json:"watch_paths"`
        AnalysisWorkers  int               `json:"analysis_workers"`
        EnableRealtime   bool              `json:"enable_realtime"`
}

// WatchPath represents a path to monitor for changes
type WatchPath struct {
        SmbRoot   string `json:"smb_root"`
        LocalPath string `json:"local_path"`
        Enabled   bool   `json:"enabled"`
}

// NewMediaManager creates a new media manager
func NewMediaManager(cfg *config.Config, logger *zap.Logger) (*MediaManager, error) <span class="cov0" title="0">{
        // Initialize encrypted database
        dbConfig := database.DatabaseConfig{
                Path:     "media_catalog.db",
                Password: "secure_password_123", // This should come from config
        }

        mediaDB, err := database.NewMediaDatabase(dbConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize media database: %w", err)
        }</span>

        // Initialize detection engine
        <span class="cov0" title="0">detectionEngine := detector.NewDetectionEngine(logger)

        // Load detection rules and media types from database
        if err := loadDetectionRules(mediaDB, detectionEngine); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to load detection rules", zap.Error(err))
        }</span>

        // Initialize provider manager
        <span class="cov0" title="0">providerManager := providers.NewProviderManager(logger)

        // Initialize analyzer
        mediaAnalyzer := analyzer.NewMediaAnalyzer(mediaDB.GetDB(), detectionEngine, providerManager, logger)

        // Initialize change watcher
        changeWatcher := realtime.NewSMBChangeWatcher(mediaDB, mediaAnalyzer, logger)

        mm := &amp;MediaManager{
                config:          cfg,
                logger:          logger,
                mediaDB:         mediaDB,
                detector:        detectionEngine,
                providerManager: providerManager,
                analyzer:        mediaAnalyzer,
                changeWatcher:   changeWatcher,
        }

        return mm, nil</span>
}

// Start starts all media services
func (mm *MediaManager) Start() error <span class="cov0" title="0">{
        if mm.started </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">mm.logger.Info("Starting Media Manager")

        // Start analyzer
        mm.analyzer.Start()

        // Start change watcher
        if err := mm.changeWatcher.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start change watcher: %w", err)
        }</span>

        // Add watch paths (this would normally come from config)
        <span class="cov0" title="0">watchPaths := []WatchPath{
                {SmbRoot: "nas1", LocalPath: "/mnt/smb/nas1", Enabled: true},
                {SmbRoot: "nas2", LocalPath: "/mnt/smb/nas2", Enabled: true},
        }

        for _, path := range watchPaths </span><span class="cov0" title="0">{
                if path.Enabled </span><span class="cov0" title="0">{
                        if err := mm.changeWatcher.WatchSMBPath(path.SmbRoot, path.LocalPath); err != nil </span><span class="cov0" title="0">{
                                mm.logger.Error("Failed to watch SMB path",
                                        zap.String("smb_root", path.SmbRoot),
                                        zap.String("local_path", path.LocalPath),
                                        zap.Error(err))
                        }</span>
                }
        }

        <span class="cov0" title="0">mm.started = true
        mm.logger.Info("Media Manager started successfully")

        return nil</span>
}

// Stop stops all media services
func (mm *MediaManager) Stop() <span class="cov0" title="0">{
        if !mm.started </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">mm.logger.Info("Stopping Media Manager")

        // Stop services in reverse order
        mm.changeWatcher.Stop()
        mm.analyzer.Stop()

        // Close database
        if err := mm.mediaDB.Close(); err != nil </span><span class="cov0" title="0">{
                mm.logger.Error("Failed to close media database", zap.Error(err))
        }</span>

        <span class="cov0" title="0">mm.started = false
        mm.logger.Info("Media Manager stopped")</span>
}

// GetDatabase returns the media database
func (mm *MediaManager) GetDatabase() *database.MediaDatabase <span class="cov0" title="0">{
        return mm.mediaDB
}</span>

// GetAnalyzer returns the media analyzer
func (mm *MediaManager) GetAnalyzer() *analyzer.MediaAnalyzer <span class="cov0" title="0">{
        return mm.analyzer
}</span>

// GetChangeWatcher returns the change watcher
func (mm *MediaManager) GetChangeWatcher() *realtime.SMBChangeWatcher <span class="cov0" title="0">{
        return mm.changeWatcher
}</span>

// AnalyzeAllDirectories triggers analysis of all directories in the catalog
func (mm *MediaManager) AnalyzeAllDirectories(ctx context.Context) error <span class="cov0" title="0">{
        mm.logger.Info("Starting full directory analysis")

        // Get all unique directory paths from the catalog
        query := `
                SELECT DISTINCT
                        CASE
                                WHEN is_directory = 1 THEN path
                                ELSE substr(path, 1, length(path) - length(name) - 1)
                        END as directory_path,
                        smb_root
                FROM files
                WHERE directory_path != ''
                ORDER BY smb_root, directory_path
        `

        rows, err := mm.mediaDB.GetDB().Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get directories: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var directories []struct {
                Path    string
                SmbRoot string
        }

        for rows.Next() </span><span class="cov0" title="0">{
                var dir struct {
                        Path    string
                        SmbRoot string
                }
                if err := rows.Scan(&amp;dir.Path, &amp;dir.SmbRoot); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">directories = append(directories, dir)</span>
        }

        <span class="cov0" title="0">mm.logger.Info("Found directories to analyze", zap.Int("count", len(directories)))

        // Queue all directories for analysis
        for i, dir := range directories </span><span class="cov0" title="0">{
                priority := 10 - (i / 100) // Decrease priority for later items
                if priority &lt; 1 </span><span class="cov0" title="0">{
                        priority = 1
                }</span>

                <span class="cov0" title="0">if err := mm.analyzer.AnalyzeDirectory(ctx, dir.Path, dir.SmbRoot, priority); err != nil </span><span class="cov0" title="0">{
                        mm.logger.Error("Failed to queue directory analysis",
                                zap.String("path", dir.Path),
                                zap.String("smb_root", dir.SmbRoot),
                                zap.Error(err))
                }</span>

                // Check for context cancellation
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }
        }

        <span class="cov0" title="0">mm.logger.Info("All directories queued for analysis")
        return nil</span>
}

// RefreshExternalMetadata refreshes metadata for all media items
func (mm *MediaManager) RefreshExternalMetadata(ctx context.Context, olderThan time.Duration) error <span class="cov0" title="0">{
        mm.logger.Info("Refreshing external metadata", zap.Duration("older_than", olderThan))

        cutoff := time.Now().Add(-olderThan)

        query := `
                SELECT mi.id, mi.title, mi.year, mt.name as media_type
                FROM media_items mi
                JOIN media_types mt ON mi.media_type_id = mt.id
                WHERE mi.id NOT IN (
                        SELECT media_item_id FROM external_metadata
                        WHERE last_fetched &gt; ?
                )
                OR mi.id IN (
                        SELECT media_item_id FROM external_metadata
                        WHERE last_fetched &lt; ?
                )
                ORDER BY mi.last_updated DESC
                LIMIT 100
        `

        rows, err := mm.mediaDB.GetDB().Query(query, cutoff, cutoff)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get media items for metadata refresh: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var mediaItems []struct {
                ID        int64
                Title     string
                Year      *int
                MediaType string
        }

        for rows.Next() </span><span class="cov0" title="0">{
                var item struct {
                        ID        int64
                        Title     string
                        Year      *int
                        MediaType string
                }
                if err := rows.Scan(&amp;item.ID, &amp;item.Title, &amp;item.Year, &amp;item.MediaType); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">mediaItems = append(mediaItems, item)</span>
        }

        <span class="cov0" title="0">mm.logger.Info("Found media items for metadata refresh", zap.Int("count", len(mediaItems)))

        // Refresh metadata for each item
        for _, item := range mediaItems </span><span class="cov0" title="0">{
                // Get best match from providers
                bestResult, providerName, err := mm.providerManager.GetBestMatch(
                        ctx, item.Title, item.MediaType, item.Year,
                )
                if err != nil || bestResult == nil </span><span class="cov0" title="0">{
                        mm.logger.Debug("No metadata found",
                                zap.String("title", item.Title),
                                zap.String("media_type", item.MediaType))
                        continue</span>
                }

                // Get detailed metadata
                <span class="cov0" title="0">metadata, err := mm.providerManager.GetDetails(ctx, providerName, bestResult.ExternalID)
                if err != nil </span><span class="cov0" title="0">{
                        mm.logger.Error("Failed to get metadata details",
                                zap.String("title", item.Title),
                                zap.String("provider", providerName),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">metadata.MediaItemID = item.ID

                // Save to database
                saveQuery := `
                        INSERT OR REPLACE INTO external_metadata
                        (media_item_id, provider, external_id, data, rating, review_url, cover_url, trailer_url, last_fetched)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                `

                _, err = mm.mediaDB.GetDB().Exec(saveQuery,
                        metadata.MediaItemID, metadata.Provider, metadata.ExternalID, metadata.Data,
                        metadata.Rating, metadata.ReviewURL, metadata.CoverURL, metadata.TrailerURL, metadata.LastFetched,
                )
                if err != nil </span><span class="cov0" title="0">{
                        mm.logger.Error("Failed to save metadata",
                                zap.String("title", item.Title),
                                zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        mm.logger.Debug("Metadata refreshed",
                                zap.String("title", item.Title),
                                zap.String("provider", providerName))
                }</span>

                // Check for context cancellation
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                // Rate limiting - don't overwhelm APIs
                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">mm.logger.Info("External metadata refresh completed")
        return nil</span>
}

// GetStatistics returns comprehensive media statistics
func (mm *MediaManager) GetStatistics() (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Database statistics
        dbStats, err := mm.mediaDB.GetStats()
        if err != nil </span><span class="cov0" title="0">{
                mm.logger.Error("Failed to get database stats", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["database"] = dbStats
        }</span>

        // Change statistics (last 24 hours)
        <span class="cov0" title="0">since := time.Now().Add(-24 * time.Hour)
        changeStats, err := mm.changeWatcher.GetChangeStatistics(since)
        if err != nil </span><span class="cov0" title="0">{
                mm.logger.Error("Failed to get change stats", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["changes_24h"] = changeStats
        }</span>

        // Media type distribution
        <span class="cov0" title="0">typeDistribution, err := mm.getMediaTypeDistribution()
        if err != nil </span><span class="cov0" title="0">{
                mm.logger.Error("Failed to get media type distribution", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["media_types"] = typeDistribution
        }</span>

        // Quality distribution
        <span class="cov0" title="0">qualityDistribution, err := mm.getQualityDistribution()
        if err != nil </span><span class="cov0" title="0">{
                mm.logger.Error("Failed to get quality distribution", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["quality"] = qualityDistribution
        }</span>

        // External metadata coverage
        <span class="cov0" title="0">metadataCoverage, err := mm.getMetadataCoverage()
        if err != nil </span><span class="cov0" title="0">{
                mm.logger.Error("Failed to get metadata coverage", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["metadata_coverage"] = metadataCoverage
        }</span>

        <span class="cov0" title="0">stats["timestamp"] = time.Now()
        stats["uptime"] = mm.started

        return stats, nil</span>
}

// Helper methods

func loadDetectionRules(mediaDB *database.MediaDatabase, engine *detector.DetectionEngine) error <span class="cov0" title="0">{
        // Load media types
        mediaTypesQuery := `
                SELECT id, name, description, detection_patterns, metadata_providers, created_at, updated_at
                FROM media_types
                ORDER BY id
        `

        rows, err := mediaDB.GetDB().Query(mediaTypesQuery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var mediaTypes []models.MediaType
        for rows.Next() </span><span class="cov0" title="0">{
                var mt models.MediaType
                var patternsJSON, providersJSON string

                err := rows.Scan(&amp;mt.ID, &amp;mt.Name, &amp;mt.Description, &amp;patternsJSON, &amp;providersJSON, &amp;mt.CreatedAt, &amp;mt.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse JSON (simplified - would use proper JSON parsing)
                <span class="cov0" title="0">mt.DetectionPatterns = []string{patternsJSON}
                mt.MetadataProviders = []string{providersJSON}

                mediaTypes = append(mediaTypes, mt)</span>
        }

        // Load detection rules
        <span class="cov0" title="0">rulesQuery := `
                SELECT id, media_type_id, rule_name, rule_type, pattern, confidence_weight, enabled, priority, created_at
                FROM detection_rules
                WHERE enabled = true
                ORDER BY priority DESC
        `

        ruleRows, err := mediaDB.GetDB().Query(rulesQuery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer ruleRows.Close()

        var rules []models.DetectionRule
        for ruleRows.Next() </span><span class="cov0" title="0">{
                var rule models.DetectionRule
                err := ruleRows.Scan(
                        &amp;rule.ID, &amp;rule.MediaTypeID, &amp;rule.RuleName, &amp;rule.RuleType,
                        &amp;rule.Pattern, &amp;rule.ConfidenceWeight, &amp;rule.Enabled, &amp;rule.Priority, &amp;rule.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">rules = append(rules, rule)</span>
        }

        // Load rules into engine
        <span class="cov0" title="0">engine.LoadRules(rules, mediaTypes)

        return nil</span>
}

func (mm *MediaManager) getMediaTypeDistribution() (map[string]int, error) <span class="cov0" title="0">{
        query := `
                SELECT mt.name, COUNT(mi.id) as count
                FROM media_types mt
                LEFT JOIN media_items mi ON mt.id = mi.media_type_id
                GROUP BY mt.id, mt.name
                ORDER BY count DESC
        `

        rows, err := mm.mediaDB.GetDB().Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        distribution := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var mediaType string
                var count int
                if err := rows.Scan(&amp;mediaType, &amp;count); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">distribution[mediaType] = count</span>
        }

        <span class="cov0" title="0">return distribution, nil</span>
}

func (mm *MediaManager) getQualityDistribution() (map[string]int, error) <span class="cov0" title="0">{
        // This would analyze quality_info JSON fields in media_files
        // Simplified implementation for now
        return map[string]int{
                "4K/UHD": 0,
                "1080p":  0,
                "720p":   0,
                "DVD":    0,
                "Other":  0,
        }, nil
}</span>

func (mm *MediaManager) getMetadataCoverage() (map[string]interface{}, error) <span class="cov0" title="0">{
        coverage := make(map[string]interface{})

        // Total media items
        var totalItems int
        err := mm.mediaDB.GetDB().QueryRow("SELECT COUNT(*) FROM media_items").Scan(&amp;totalItems)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">coverage["total_items"] = totalItems

        // Items with external metadata
        var itemsWithMetadata int
        err = mm.mediaDB.GetDB().QueryRow(
                "SELECT COUNT(DISTINCT media_item_id) FROM external_metadata",
        ).Scan(&amp;itemsWithMetadata)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">coverage["items_with_metadata"] = itemsWithMetadata

        // Coverage percentage
        if totalItems &gt; 0 </span><span class="cov0" title="0">{
                coverage["coverage_percentage"] = float64(itemsWithMetadata) / float64(totalItems) * 100
        }</span> else<span class="cov0" title="0"> {
                coverage["coverage_percentage"] = 0.0
        }</span>

        // Coverage by provider
        <span class="cov0" title="0">providerQuery := `
                SELECT provider, COUNT(*) as count
                FROM external_metadata
                GROUP BY provider
                ORDER BY count DESC
        `

        rows, err := mm.mediaDB.GetDB().Query(providerQuery)
        if err != nil </span><span class="cov0" title="0">{
                return coverage, nil // Return partial results
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        providerCoverage := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var provider string
                var count int
                if err := rows.Scan(&amp;provider, &amp;count); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">providerCoverage[provider] = count</span>
        }
        <span class="cov0" title="0">coverage["by_provider"] = providerCoverage

        return coverage, nil</span>
}

// ExportData exports media data for backup or migration
func (mm *MediaManager) ExportData(exportPath string) error <span class="cov0" title="0">{
        mm.logger.Info("Exporting media data", zap.String("path", exportPath))

        // Create backup of the encrypted database
        backupPath := filepath.Join(exportPath, fmt.Sprintf("media_backup_%d.db", time.Now().Unix()))
        if err := mm.mediaDB.Backup(backupPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to backup database: %w", err)
        }</span>

        // Export statistics
        <span class="cov0" title="0">stats, err := mm.GetStatistics()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get statistics: %w", err)
        }</span>

        <span class="cov0" title="0">statsPath := filepath.Join(exportPath, "media_stats.json")
        statsJSON, _ := json.Marshal(stats)
        if err := ioutil.WriteFile(statsPath, statsJSON, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to export statistics: %w", err)
        }</span>

        <span class="cov0" title="0">mm.logger.Info("Media data exported successfully",
                zap.String("backup_path", backupPath),
                zap.String("stats_path", statsPath))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package models

import (
        "encoding/json"
        "time"
)

// MediaType represents different types of media content
type MediaType struct {
        ID                int64     `json:"id" db:"id"`
        Name              string    `json:"name" db:"name"`
        Description       string    `json:"description" db:"description"`
        DetectionPatterns []string  `json:"detection_patterns" db:"detection_patterns"`
        MetadataProviders []string  `json:"metadata_providers" db:"metadata_providers"`
        CreatedAt         time.Time `json:"created_at" db:"created_at"`
        UpdatedAt         time.Time `json:"updated_at" db:"updated_at"`
}

// MediaItem represents a detected media item with aggregated metadata
type MediaItem struct {
        ID            int64      `json:"id" db:"id"`
        MediaTypeID   int64      `json:"media_type_id" db:"media_type_id"`
        MediaType     *MediaType `json:"media_type,omitempty"`
        Title         string     `json:"title" db:"title"`
        OriginalTitle *string    `json:"original_title,omitempty" db:"original_title"`
        Year          *int       `json:"year,omitempty" db:"year"`
        Description   *string    `json:"description,omitempty" db:"description"`
        Genre         []string   `json:"genre,omitempty" db:"genre"`
        Director      *string    `json:"director,omitempty" db:"director"`
        CastCrew      *CastCrew  `json:"cast_crew,omitempty" db:"cast_crew"`
        Rating        *float64   `json:"rating,omitempty" db:"rating"`
        Runtime       *int       `json:"runtime,omitempty" db:"runtime"`
        Language      *string    `json:"language,omitempty" db:"language"`
        Country       *string    `json:"country,omitempty" db:"country"`
        Status        string     `json:"status" db:"status"`
        FirstDetected time.Time  `json:"first_detected" db:"first_detected"`
        LastUpdated   time.Time  `json:"last_updated" db:"last_updated"`

        // Aggregated data
        ExternalMetadata []ExternalMetadata `json:"external_metadata,omitempty"`
        Files            []MediaFile        `json:"files,omitempty"`
        Collections      []MediaCollection  `json:"collections,omitempty"`
        UserMetadata     *UserMetadata      `json:"user_metadata,omitempty"`
}

// CastCrew represents cast and crew information
type CastCrew struct {
        Director   *string  `json:"director,omitempty"`
        Writers    []string `json:"writers,omitempty"`
        Actors     []Actor  `json:"actors,omitempty"`
        Producers  []string `json:"producers,omitempty"`
        Musicians  []string `json:"musicians,omitempty"`
        Developers []string `json:"developers,omitempty"`
}

// Actor represents an actor with their character
type Actor struct {
        Name      string `json:"name"`
        Character string `json:"character,omitempty"`
        Order     int    `json:"order,omitempty"`
}

// ExternalMetadata represents metadata from external sources
type ExternalMetadata struct {
        ID          int64     `json:"id" db:"id"`
        MediaItemID int64     `json:"media_item_id" db:"media_item_id"`
        Provider    string    `json:"provider" db:"provider"`
        ExternalID  string    `json:"external_id" db:"external_id"`
        Data        string    `json:"data" db:"data"`
        Rating      *float64  `json:"rating,omitempty" db:"rating"`
        ReviewURL   *string   `json:"review_url,omitempty" db:"review_url"`
        CoverURL    *string   `json:"cover_url,omitempty" db:"cover_url"`
        TrailerURL  *string   `json:"trailer_url,omitempty" db:"trailer_url"`
        LastFetched time.Time `json:"last_fetched" db:"last_fetched"`
}

// DirectoryAnalysis represents analysis of a directory's content
type DirectoryAnalysis struct {
        ID              int64         `json:"id" db:"id"`
        DirectoryPath   string        `json:"directory_path" db:"directory_path"`
        SmbRoot         string        `json:"smb_root" db:"smb_root"`
        MediaItemID     *int64        `json:"media_item_id,omitempty" db:"media_item_id"`
        MediaItem       *MediaItem    `json:"media_item,omitempty"`
        ConfidenceScore float64       `json:"confidence_score" db:"confidence_score"`
        DetectionMethod string        `json:"detection_method" db:"detection_method"`
        AnalysisData    *AnalysisData `json:"analysis_data,omitempty" db:"analysis_data"`
        LastAnalyzed    time.Time     `json:"last_analyzed" db:"last_analyzed"`
        FilesCount      int           `json:"files_count" db:"files_count"`
        TotalSize       int64         `json:"total_size" db:"total_size"`
}

// AnalysisData contains detailed analysis information
type AnalysisData struct {
        MatchedPatterns   []string         `json:"matched_patterns"`
        FileTypes         map[string]int   `json:"file_types"`
        SizeDistribution  map[string]int64 `json:"size_distribution"`
        DetectedLanguages []string         `json:"detected_languages"`
        QualityIndicators []string         `json:"quality_indicators"`
        StructureScore    float64          `json:"structure_score"`
        FilenameScore     float64          `json:"filename_score"`
        MetadataScore     float64          `json:"metadata_score"`
        AlternativeTitles []string         `json:"alternative_titles"`
}

// MediaFile represents individual file versions
type MediaFile struct {
        ID             int64           `json:"id" db:"id"`
        MediaItemID    int64           `json:"media_item_id" db:"media_item_id"`
        FilePath       string          `json:"file_path" db:"file_path"`
        SmbRoot        string          `json:"smb_root" db:"smb_root"`
        Filename       string          `json:"filename" db:"filename"`
        FileSize       int64           `json:"file_size" db:"file_size"`
        FileExtension  *string         `json:"file_extension,omitempty" db:"file_extension"`
        QualityInfo    *QualityInfo    `json:"quality_info,omitempty" db:"quality_info"`
        Language       *string         `json:"language,omitempty" db:"language"`
        SubtitleTracks []SubtitleTrack `json:"subtitle_tracks,omitempty" db:"subtitle_tracks"`
        AudioTracks    []AudioTrack    `json:"audio_tracks,omitempty" db:"audio_tracks"`
        Duration       *int            `json:"duration,omitempty" db:"duration"`
        Checksum       *string         `json:"checksum,omitempty" db:"checksum"`
        VirtualSmbLink *string         `json:"virtual_smb_link,omitempty" db:"virtual_smb_link"`
        DirectSmbLink  string          `json:"direct_smb_link" db:"direct_smb_link"`
        LastVerified   time.Time       `json:"last_verified" db:"last_verified"`
        CreatedAt      time.Time       `json:"created_at" db:"created_at"`
}

// QualityInfo represents file quality information
type QualityInfo struct {
        Resolution     *Resolution `json:"resolution,omitempty"`
        Bitrate        *int        `json:"bitrate,omitempty"`
        VideoCodec     *string     `json:"video_codec,omitempty"`
        AudioCodec     *string     `json:"audio_codec,omitempty"`
        FrameRate      *float64    `json:"frame_rate,omitempty"`
        AspectRatio    *string     `json:"aspect_ratio,omitempty"`
        ColorDepth     *int        `json:"color_depth,omitempty"`
        HDR            bool        `json:"hdr,omitempty"`
        QualityProfile *string     `json:"quality_profile,omitempty"`
        Source         *string     `json:"source,omitempty"` // BluRay, DVD, WEB-DL, etc.
        QualityScore   int         `json:"quality_score"`
}

// Resolution represents video resolution
type Resolution struct {
        Width  int `json:"width"`
        Height int `json:"height"`
}

// SubtitleTrack represents subtitle information
type SubtitleTrack struct {
        Language string `json:"language"`
        Format   string `json:"format"`
        Forced   bool   `json:"forced,omitempty"`
        Default  bool   `json:"default,omitempty"`
}

// AudioTrack represents audio track information
type AudioTrack struct {
        Language   string `json:"language"`
        Codec      string `json:"codec"`
        Channels   string `json:"channels"`
        Bitrate    *int   `json:"bitrate,omitempty"`
        SampleRate *int   `json:"sample_rate,omitempty"`
        Default    bool   `json:"default,omitempty"`
        Commentary bool   `json:"commentary,omitempty"`
}

// QualityProfile represents quality comparison profiles
type QualityProfile struct {
        ID               int64     `json:"id" db:"id"`
        Name             string    `json:"name" db:"name"`
        ResolutionWidth  *int      `json:"resolution_width,omitempty" db:"resolution_width"`
        ResolutionHeight *int      `json:"resolution_height,omitempty" db:"resolution_height"`
        MinBitrate       *int      `json:"min_bitrate,omitempty" db:"min_bitrate"`
        MaxBitrate       *int      `json:"max_bitrate,omitempty" db:"max_bitrate"`
        PreferredCodecs  []string  `json:"preferred_codecs,omitempty" db:"preferred_codecs"`
        QualityScore     int       `json:"quality_score" db:"quality_score"`
        CreatedAt        time.Time `json:"created_at" db:"created_at"`
}

// MediaCollection represents collections of related media
type MediaCollection struct {
        ID             int64                 `json:"id" db:"id"`
        Name           string                `json:"name" db:"name"`
        CollectionType string                `json:"collection_type" db:"collection_type"`
        Description    *string               `json:"description,omitempty" db:"description"`
        TotalItems     int                   `json:"total_items" db:"total_items"`
        ExternalIDs    map[string]string     `json:"external_ids,omitempty" db:"external_ids"`
        CoverURL       *string               `json:"cover_url,omitempty" db:"cover_url"`
        CreatedAt      time.Time             `json:"created_at" db:"created_at"`
        UpdatedAt      time.Time             `json:"updated_at" db:"updated_at"`
        Items          []MediaCollectionItem `json:"items,omitempty"`
}

// MediaCollectionItem represents an item within a collection
type MediaCollectionItem struct {
        ID             int64      `json:"id" db:"id"`
        CollectionID   int64      `json:"collection_id" db:"collection_id"`
        MediaItemID    int64      `json:"media_item_id" db:"media_item_id"`
        MediaItem      *MediaItem `json:"media_item,omitempty"`
        SequenceNumber *int       `json:"sequence_number,omitempty" db:"sequence_number"`
        SeasonNumber   *int       `json:"season_number,omitempty" db:"season_number"`
        ReleaseOrder   *int       `json:"release_order,omitempty" db:"release_order"`
}

// UserMetadata represents user-specific metadata
type UserMetadata struct {
        ID            int64      `json:"id" db:"id"`
        MediaItemID   int64      `json:"media_item_id" db:"media_item_id"`
        UserRating    *float64   `json:"user_rating,omitempty" db:"user_rating"`
        WatchedStatus *string    `json:"watched_status,omitempty" db:"watched_status"`
        WatchedDate   *time.Time `json:"watched_date,omitempty" db:"watched_date"`
        PersonalNotes *string    `json:"personal_notes,omitempty" db:"personal_notes"`
        Tags          []string   `json:"tags,omitempty" db:"tags"`
        Favorite      bool       `json:"favorite" db:"favorite"`
        CreatedAt     time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt     time.Time  `json:"updated_at" db:"updated_at"`
}

// DetectionRule represents rules for media detection
type DetectionRule struct {
        ID               int64     `json:"id" db:"id"`
        MediaTypeID      int64     `json:"media_type_id" db:"media_type_id"`
        RuleName         string    `json:"rule_name" db:"rule_name"`
        RuleType         string    `json:"rule_type" db:"rule_type"`
        Pattern          string    `json:"pattern" db:"pattern"`
        ConfidenceWeight float64   `json:"confidence_weight" db:"confidence_weight"`
        Enabled          bool      `json:"enabled" db:"enabled"`
        Priority         int       `json:"priority" db:"priority"`
        CreatedAt        time.Time `json:"created_at" db:"created_at"`
}

// ChangeLog represents tracked changes for real-time updates
type ChangeLog struct {
        ID         int64     `json:"id" db:"id"`
        EntityType string    `json:"entity_type" db:"entity_type"`
        EntityID   string    `json:"entity_id" db:"entity_id"`
        ChangeType string    `json:"change_type" db:"change_type"`
        OldData    *string   `json:"old_data,omitempty" db:"old_data"`
        NewData    *string   `json:"new_data,omitempty" db:"new_data"`
        DetectedAt time.Time `json:"detected_at" db:"detected_at"`
        Processed  bool      `json:"processed" db:"processed"`
}

// MediaSearchRequest represents search parameters for media
type MediaSearchRequest struct {
        Query         string     `json:"query" form:"query"`
        MediaTypes    []string   `json:"media_types" form:"media_types"`
        Year          *int       `json:"year" form:"year"`
        YearRange     *YearRange `json:"year_range"`
        Genre         []string   `json:"genre" form:"genre"`
        Quality       []string   `json:"quality" form:"quality"`
        Language      []string   `json:"language" form:"language"`
        MinRating     *float64   `json:"min_rating" form:"min_rating"`
        HasExternals  *bool      `json:"has_externals" form:"has_externals"`
        SmbRoots      []string   `json:"smb_roots" form:"smb_roots"`
        WatchedStatus *string    `json:"watched_status" form:"watched_status"`
        SortBy        string     `json:"sort_by" form:"sort_by"`
        SortOrder     string     `json:"sort_order" form:"sort_order"`
        Limit         int        `json:"limit" form:"limit"`
        Offset        int        `json:"offset" form:"offset"`
}

// YearRange represents a range of years
type YearRange struct {
        From int `json:"from"`
        To   int `json:"to"`
}

// MediaOverview represents aggregated media statistics
type MediaOverview struct {
        ID                 int64      `json:"id" db:"id"`
        Title              string     `json:"title" db:"title"`
        Year               *int       `json:"year" db:"year"`
        MediaType          string     `json:"media_type" db:"media_type"`
        FileCount          int        `json:"file_count" db:"file_count"`
        TotalSize          int64      `json:"total_size" db:"total_size"`
        LastVerified       *time.Time `json:"last_verified" db:"last_verified"`
        AvailableQualities []string   `json:"available_qualities" db:"available_qualities"`
}

// Custom JSON marshaling for database storage
func (mt *MediaType) MarshalDetectionPatterns() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(mt.DetectionPatterns)
}</span>

func (mt *MediaType) UnmarshalDetectionPatterns(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, &amp;mt.DetectionPatterns)
}</span>

func (mi *MediaItem) MarshalGenre() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(mi.Genre)
}</span>

func (mi *MediaItem) UnmarshalGenre(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, &amp;mi.Genre)
}</span>

func (mi *MediaItem) MarshalCastCrew() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(mi.CastCrew)
}</span>

func (mi *MediaItem) UnmarshalCastCrew(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, &amp;mi.CastCrew)
}</span>

// Helper methods for quality comparison
func (qi *QualityInfo) IsBetterThan(other *QualityInfo) bool <span class="cov0" title="0">{
        if qi == nil || other == nil </span><span class="cov0" title="0">{
                return qi != nil
        }</span>
        <span class="cov0" title="0">return qi.QualityScore &gt; other.QualityScore</span>
}

func (qi *QualityInfo) GetDisplayName() string <span class="cov0" title="0">{
        if qi.QualityProfile != nil </span><span class="cov0" title="0">{
                return *qi.QualityProfile
        }</span>
        <span class="cov0" title="0">if qi.Resolution != nil </span><span class="cov0" title="0">{
                return qi.Resolution.GetDisplayName()
        }</span>
        <span class="cov0" title="0">return "Unknown"</span>
}

func (r *Resolution) GetDisplayName() string <span class="cov0" title="0">{
        switch </span>{
        case r.Width &gt;= 3840:<span class="cov0" title="0">
                return "4K/UHD"</span>
        case r.Width &gt;= 1920:<span class="cov0" title="0">
                return "1080p"</span>
        case r.Width &gt;= 1280:<span class="cov0" title="0">
                return "720p"</span>
        case r.Width &gt;= 720:<span class="cov0" title="0">
                return "480p/DVD"</span>
        default:<span class="cov0" title="0">
                return "Low Quality"</span>
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package providers

import (
        "catalogizer/internal/media/models"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "time"

        "go.uber.org/zap"
)

// MetadataProvider interface for external metadata sources
type MetadataProvider interface {
        GetName() string
        Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error)
        GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error)
        IsEnabled() bool
}

// SearchResult represents search results from providers
type SearchResult struct {
        ExternalID  string   `json:"external_id"`
        Title       string   `json:"title"`
        Year        *int     `json:"year,omitempty"`
        Rating      *float64 `json:"rating,omitempty"`
        Description *string  `json:"description,omitempty"`
        CoverURL    *string  `json:"cover_url,omitempty"`
        Relevance   float64  `json:"relevance"`
}

// ProviderManager manages all metadata providers
type ProviderManager struct {
        providers map[string]MetadataProvider
        logger    *zap.Logger
        client    *http.Client
}

// NewProviderManager creates a new provider manager
func NewProviderManager(logger *zap.Logger) *ProviderManager <span class="cov0" title="0">{
        client := &amp;http.Client{
                Timeout: 30 * time.Second,
        }

        pm := &amp;ProviderManager{
                providers: make(map[string]MetadataProvider),
                logger:    logger,
                client:    client,
        }

        // Initialize all providers
        pm.registerProviders()

        return pm
}</span>

// registerProviders registers all available providers
func (pm *ProviderManager) registerProviders() <span class="cov0" title="0">{
        // Movie/TV providers
        pm.providers["tmdb"] = NewTMDBProvider(pm.client, pm.logger)
        pm.providers["imdb"] = NewIMDBProvider(pm.client, pm.logger)
        pm.providers["tvdb"] = NewTVDBProvider(pm.client, pm.logger)

        // Music providers
        pm.providers["musicbrainz"] = NewMusicBrainzProvider(pm.client, pm.logger)
        pm.providers["spotify"] = NewSpotifyProvider(pm.client, pm.logger)
        pm.providers["lastfm"] = NewLastFMProvider(pm.client, pm.logger)

        // Gaming providers
        pm.providers["igdb"] = NewIGDBProvider(pm.client, pm.logger)
        pm.providers["steam"] = NewSteamProvider(pm.client, pm.logger)

        // Books providers
        pm.providers["goodreads"] = NewGoodreadsProvider(pm.client, pm.logger)
        pm.providers["openlibrary"] = NewOpenLibraryProvider(pm.client, pm.logger)

        // Anime providers
        pm.providers["anidb"] = NewAniDBProvider(pm.client, pm.logger)
        pm.providers["myanimelist"] = NewMyAnimeListProvider(pm.client, pm.logger)

        // YouTube/Social providers
        pm.providers["youtube"] = NewYouTubeProvider(pm.client, pm.logger)

        // Software providers
        pm.providers["github"] = NewGitHubProvider(pm.client, pm.logger)

        pm.logger.Info("Metadata providers registered", zap.Int("count", len(pm.providers)))
}</span>

// SearchAll searches across all relevant providers
func (pm *ProviderManager) SearchAll(ctx context.Context, query string, mediaType string, year *int, providers []string) (map[string][]SearchResult, error) <span class="cov0" title="0">{
        results := make(map[string][]SearchResult)

        // If no specific providers requested, use all relevant ones
        if len(providers) == 0 </span><span class="cov0" title="0">{
                providers = pm.getProvidersForMediaType(mediaType)
        }</span>

        <span class="cov0" title="0">for _, providerName := range providers </span><span class="cov0" title="0">{
                provider, exists := pm.providers[providerName]
                if !exists || !provider.IsEnabled() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">providerResults, err := provider.Search(ctx, query, mediaType, year)
                if err != nil </span><span class="cov0" title="0">{
                        pm.logger.Error("Provider search failed",
                                zap.String("provider", providerName),
                                zap.String("query", query),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if len(providerResults) &gt; 0 </span><span class="cov0" title="0">{
                        results[providerName] = providerResults
                }</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// GetBestMatch finds the best matching result across all providers
func (pm *ProviderManager) GetBestMatch(ctx context.Context, query string, mediaType string, year *int) (*SearchResult, string, error) <span class="cov0" title="0">{
        allResults, err := pm.SearchAll(ctx, query, mediaType, year, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">var bestResult *SearchResult
        var bestProvider string
        var bestScore float64

        for providerName, results := range allResults </span><span class="cov0" title="0">{
                for _, result := range results </span><span class="cov0" title="0">{
                        score := pm.calculateRelevanceScore(result, query, year)
                        if score &gt; bestScore </span><span class="cov0" title="0">{
                                bestScore = score
                                bestResult = &amp;result
                                bestProvider = providerName
                        }</span>
                }
        }

        <span class="cov0" title="0">return bestResult, bestProvider, nil</span>
}

// GetDetails gets detailed metadata from a specific provider
func (pm *ProviderManager) GetDetails(ctx context.Context, providerName, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        provider, exists := pm.providers[providerName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider not found: %s", providerName)
        }</span>

        <span class="cov0" title="0">if !provider.IsEnabled() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider disabled: %s", providerName)
        }</span>

        <span class="cov0" title="0">return provider.GetDetails(ctx, externalID)</span>
}

// calculateRelevanceScore calculates how relevant a search result is
func (pm *ProviderManager) calculateRelevanceScore(result SearchResult, query string, year *int) float64 <span class="cov0" title="0">{
        score := result.Relevance

        // Bonus for exact title match
        if strings.EqualFold(result.Title, query) </span><span class="cov0" title="0">{
                score += 0.3
        }</span> else<span class="cov0" title="0"> if strings.Contains(strings.ToLower(result.Title), strings.ToLower(query)) </span><span class="cov0" title="0">{
                score += 0.2
        }</span>

        // Bonus for year match
        <span class="cov0" title="0">if year != nil &amp;&amp; result.Year != nil &amp;&amp; *result.Year == *year </span><span class="cov0" title="0">{
                score += 0.2
        }</span>

        // Bonus for having rating
        <span class="cov0" title="0">if result.Rating != nil &amp;&amp; *result.Rating &gt; 0 </span><span class="cov0" title="0">{
                score += 0.1
        }</span>

        <span class="cov0" title="0">return score</span>
}

// getProvidersForMediaType returns relevant providers for a media type
func (pm *ProviderManager) getProvidersForMediaType(mediaType string) []string <span class="cov0" title="0">{
        providerMap := map[string][]string{
                "movie":         {"tmdb", "imdb"},
                "tv_show":       {"tmdb", "imdb", "tvdb"},
                "anime":         {"anidb", "myanimelist", "tmdb"},
                "music":         {"musicbrainz", "spotify", "lastfm"},
                "pc_game":       {"igdb", "steam"},
                "console_game":  {"igdb"},
                "mobile_game":   {"igdb"},
                "ebook":         {"goodreads", "openlibrary"},
                "audiobook":     {"goodreads"},
                "documentary":   {"tmdb", "imdb"},
                "youtube_video": {"youtube"},
                "software":      {"github"},
                "podcast":       {"spotify"},
        }

        if providers, exists := providerMap[mediaType]; exists </span><span class="cov0" title="0">{
                return providers
        }</span>

        // Default providers for unknown types
        <span class="cov0" title="0">return []string{"tmdb", "imdb"}</span>
}

// Base provider struct with common functionality
type BaseProvider struct {
        name    string
        client  *http.Client
        logger  *zap.Logger
        enabled bool
        apiKey  string
        baseURL string
}

func NewBaseProvider(name, baseURL, apiKey string, client *http.Client, logger *zap.Logger) *BaseProvider <span class="cov0" title="0">{
        return &amp;BaseProvider{
                name:    name,
                client:  client,
                logger:  logger,
                enabled: apiKey != "",
                apiKey:  apiKey,
                baseURL: baseURL,
        }
}</span>

func (bp *BaseProvider) GetName() string <span class="cov0" title="0">{
        return bp.name
}</span>

func (bp *BaseProvider) IsEnabled() bool <span class="cov0" title="0">{
        return bp.enabled
}</span>

// makeRequest makes an HTTP request with error handling
func (bp *BaseProvider) makeRequest(ctx context.Context, url string, headers map[string]string) ([]byte, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Add headers
        <span class="cov0" title="0">for key, value := range headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        // Add API key if available
        <span class="cov0" title="0">if bp.apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+bp.apiKey)
        }</span>

        <span class="cov0" title="0">resp, err := bp.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP %d: %s", resp.StatusCode, resp.Status)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">return body, nil</span>
}

// TMDB Provider Implementation
type TMDBProvider struct {
        *BaseProvider
}

func NewTMDBProvider(client *http.Client, logger *zap.Logger) *TMDBProvider <span class="cov0" title="0">{
        // API key should be loaded from config
        apiKey := "" // Load from environment or config
        return &amp;TMDBProvider{
                BaseProvider: NewBaseProvider("tmdb", "https://api.themoviedb.org/3", apiKey, client, logger),
        }
}</span>

func (t *TMDBProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        endpoint := "/search/multi"
        if mediaType == "movie" </span><span class="cov0" title="0">{
                endpoint = "/search/movie"
        }</span> else<span class="cov0" title="0"> if mediaType == "tv_show" </span><span class="cov0" title="0">{
                endpoint = "/search/tv"
        }</span>

        <span class="cov0" title="0">params := url.Values{}
        params.Add("api_key", t.apiKey)
        params.Add("query", query)
        if year != nil </span><span class="cov0" title="0">{
                params.Add("year", fmt.Sprintf("%d", *year))
        }</span>

        <span class="cov0" title="0">requestURL := t.baseURL + endpoint + "?" + params.Encode()

        body, err := t.makeRequest(ctx, requestURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var response struct {
                Results []struct {
                        ID           int     `json:"id"`
                        Title        string  `json:"title"`
                        Name         string  `json:"name"`
                        ReleaseDate  string  `json:"release_date"`
                        FirstAirDate string  `json:"first_air_date"`
                        Overview     string  `json:"overview"`
                        PosterPath   string  `json:"poster_path"`
                        VoteAverage  float64 `json:"vote_average"`
                        MediaType    string  `json:"media_type"`
                } `json:"results"`
        }

        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">results := make([]SearchResult, 0, len(response.Results))
        for _, item := range response.Results </span><span class="cov0" title="0">{
                title := item.Title
                if title == "" </span><span class="cov0" title="0">{
                        title = item.Name
                }</span>

                <span class="cov0" title="0">var year *int
                dateStr := item.ReleaseDate
                if dateStr == "" </span><span class="cov0" title="0">{
                        dateStr = item.FirstAirDate
                }</span>
                <span class="cov0" title="0">if len(dateStr) &gt;= 4 </span><span class="cov0" title="0">{
                        if y := parseInt(dateStr[:4]); y &gt; 1900 </span><span class="cov0" title="0">{
                                year = &amp;y
                        }</span>
                }

                <span class="cov0" title="0">var coverURL *string
                if item.PosterPath != "" </span><span class="cov0" title="0">{
                        url := fmt.Sprintf("https://image.tmdb.org/t/p/w500%s", item.PosterPath)
                        coverURL = &amp;url
                }</span>

                <span class="cov0" title="0">var rating *float64
                if item.VoteAverage &gt; 0 </span><span class="cov0" title="0">{
                        rating = &amp;item.VoteAverage
                }</span>

                <span class="cov0" title="0">result := SearchResult{
                        ExternalID:  fmt.Sprintf("%d", item.ID),
                        Title:       title,
                        Year:        year,
                        Rating:      rating,
                        Description: &amp;item.Overview,
                        CoverURL:    coverURL,
                        Relevance:   0.8, // Base relevance for TMDB
                }

                results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

func (t *TMDBProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        // Implementation for getting detailed TMDB data
        endpoint := fmt.Sprintf("/movie/%s", externalID)
        params := url.Values{}
        params.Add("api_key", t.apiKey)
        params.Add("append_to_response", "credits,videos,external_ids")

        requestURL := t.baseURL + endpoint + "?" + params.Encode()

        body, err := t.makeRequest(ctx, requestURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">metadata := &amp;models.ExternalMetadata{
                Provider:    t.name,
                ExternalID:  externalID,
                Data:        string(body),
                LastFetched: time.Now(),
        }

        // Parse specific fields
        var details struct {
                Title       string  `json:"title"`
                VoteAverage float64 `json:"vote_average"`
                PosterPath  string  `json:"poster_path"`
                Homepage    string  `json:"homepage"`
                Videos      struct {
                        Results []struct {
                                Site string `json:"site"`
                                Key  string `json:"key"`
                                Type string `json:"type"`
                        } `json:"results"`
                } `json:"videos"`
        }

        if err := json.Unmarshal(body, &amp;details); err == nil </span><span class="cov0" title="0">{
                if details.VoteAverage &gt; 0 </span><span class="cov0" title="0">{
                        metadata.Rating = &amp;details.VoteAverage
                }</span>
                <span class="cov0" title="0">if details.PosterPath != "" </span><span class="cov0" title="0">{
                        url := fmt.Sprintf("https://image.tmdb.org/t/p/w500%s", details.PosterPath)
                        metadata.CoverURL = &amp;url
                }</span>
                <span class="cov0" title="0">if details.Homepage != "" </span><span class="cov0" title="0">{
                        metadata.ReviewURL = &amp;details.Homepage
                }</span>

                // Find trailer
                <span class="cov0" title="0">for _, video := range details.Videos.Results </span><span class="cov0" title="0">{
                        if video.Site == "YouTube" &amp;&amp; video.Type == "Trailer" </span><span class="cov0" title="0">{
                                trailerURL := fmt.Sprintf("https://www.youtube.com/watch?v=%s", video.Key)
                                metadata.TrailerURL = &amp;trailerURL
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return metadata, nil</span>
}

// Helper function (duplicate from detector package)
func parseInt(s string) int <span class="cov0" title="0">{
        var result int
        for _, char := range s </span><span class="cov0" title="0">{
                if char &gt;= '0' &amp;&amp; char &lt;= '9' </span><span class="cov0" title="0">{
                        result = result*10 + int(char-'0')
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// Placeholder implementations for other providers
// These would be implemented similarly to TMDBProvider

type IMDBProvider struct{ *BaseProvider }
type TVDBProvider struct{ *BaseProvider }
type MusicBrainzProvider struct{ *BaseProvider }
type SpotifyProvider struct{ *BaseProvider }
type LastFMProvider struct{ *BaseProvider }
type IGDBProvider struct{ *BaseProvider }
type SteamProvider struct{ *BaseProvider }
type GoodreadsProvider struct{ *BaseProvider }
type OpenLibraryProvider struct{ *BaseProvider }
type AniDBProvider struct{ *BaseProvider }
type MyAnimeListProvider struct{ *BaseProvider }
type YouTubeProvider struct{ *BaseProvider }
type GitHubProvider struct{ *BaseProvider }

// Placeholder constructor functions
func NewIMDBProvider(client *http.Client, logger *zap.Logger) *IMDBProvider <span class="cov0" title="0">{
        return &amp;IMDBProvider{NewBaseProvider("imdb", "https://imdb-api.com", "", client, logger)}
}</span>

func NewTVDBProvider(client *http.Client, logger *zap.Logger) *TVDBProvider <span class="cov0" title="0">{
        return &amp;TVDBProvider{NewBaseProvider("tvdb", "https://api.thetvdb.com", "", client, logger)}
}</span>

func NewMusicBrainzProvider(client *http.Client, logger *zap.Logger) *MusicBrainzProvider <span class="cov0" title="0">{
        return &amp;MusicBrainzProvider{NewBaseProvider("musicbrainz", "https://musicbrainz.org/ws/2", "", client, logger)}
}</span>

func NewSpotifyProvider(client *http.Client, logger *zap.Logger) *SpotifyProvider <span class="cov0" title="0">{
        return &amp;SpotifyProvider{NewBaseProvider("spotify", "https://api.spotify.com/v1", "", client, logger)}
}</span>

func NewLastFMProvider(client *http.Client, logger *zap.Logger) *LastFMProvider <span class="cov0" title="0">{
        return &amp;LastFMProvider{NewBaseProvider("lastfm", "https://ws.audioscrobbler.com/2.0", "", client, logger)}
}</span>

func NewIGDBProvider(client *http.Client, logger *zap.Logger) *IGDBProvider <span class="cov0" title="0">{
        return &amp;IGDBProvider{NewBaseProvider("igdb", "https://api.igdb.com/v4", "", client, logger)}
}</span>

func NewSteamProvider(client *http.Client, logger *zap.Logger) *SteamProvider <span class="cov0" title="0">{
        return &amp;SteamProvider{NewBaseProvider("steam", "https://store.steampowered.com/api", "", client, logger)}
}</span>

func NewGoodreadsProvider(client *http.Client, logger *zap.Logger) *GoodreadsProvider <span class="cov0" title="0">{
        return &amp;GoodreadsProvider{NewBaseProvider("goodreads", "https://www.goodreads.com/book", "", client, logger)}
}</span>

func NewOpenLibraryProvider(client *http.Client, logger *zap.Logger) *OpenLibraryProvider <span class="cov0" title="0">{
        return &amp;OpenLibraryProvider{NewBaseProvider("openlibrary", "https://openlibrary.org", "", client, logger)}
}</span>

func NewAniDBProvider(client *http.Client, logger *zap.Logger) *AniDBProvider <span class="cov0" title="0">{
        return &amp;AniDBProvider{NewBaseProvider("anidb", "https://anidb.net/perl-bin/animedb.pl", "", client, logger)}
}</span>

func NewMyAnimeListProvider(client *http.Client, logger *zap.Logger) *MyAnimeListProvider <span class="cov0" title="0">{
        return &amp;MyAnimeListProvider{NewBaseProvider("myanimelist", "https://api.myanimelist.net/v2", "", client, logger)}
}</span>

func NewYouTubeProvider(client *http.Client, logger *zap.Logger) *YouTubeProvider <span class="cov0" title="0">{
        return &amp;YouTubeProvider{NewBaseProvider("youtube", "https://www.googleapis.com/youtube/v3", "", client, logger)}
}</span>

func NewGitHubProvider(client *http.Client, logger *zap.Logger) *GitHubProvider <span class="cov0" title="0">{
        return &amp;GitHubProvider{NewBaseProvider("github", "https://api.github.com", "", client, logger)}
}</span>

// Implement Search and GetDetails methods for each provider
// (Similar pattern to TMDBProvider, customized for each API)

func (p *IMDBProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        // IMDB API implementation
        return []SearchResult{}, nil
}</span>

func (p *IMDBProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        // IMDB details implementation
        return &amp;models.ExternalMetadata{}, nil
}</span>

// TVDBProvider GetDetails implementation
func (p *TVDBProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// MusicBrainzProvider GetDetails implementation
func (p *MusicBrainzProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// SpotifyProvider GetDetails implementation
func (p *SpotifyProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// LastFMProvider GetDetails implementation
func (p *LastFMProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// IGDBProvider GetDetails implementation
func (p *IGDBProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// SteamProvider GetDetails implementation
func (p *SteamProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// GoodreadsProvider GetDetails implementation
func (p *GoodreadsProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// OpenLibraryProvider GetDetails implementation
func (p *OpenLibraryProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// AniDBProvider GetDetails implementation
func (p *AniDBProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// MyAnimeListProvider GetDetails implementation
func (p *MyAnimeListProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// YouTubeProvider GetDetails implementation
func (p *YouTubeProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// GitHubProvider GetDetails implementation
func (p *GitHubProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// Search method implementations for all providers
func (p *TVDBProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *MusicBrainzProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *SpotifyProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *LastFMProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *IGDBProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *SteamProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *GoodreadsProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *OpenLibraryProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *AniDBProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *MyAnimeListProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *YouTubeProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *GitHubProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package realtime

import (
        "catalogizer/internal/media/analyzer"
        "catalogizer/internal/media/database"
        "catalogizer/internal/models"
        "catalogizer/internal/services"
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "io"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/fsnotify/fsnotify"
        "go.uber.org/zap"
)

// EnhancedChangeWatcher monitors file system changes with intelligent rename detection
type EnhancedChangeWatcher struct {
        mediaDB       *database.MediaDatabase
        analyzer      *analyzer.MediaAnalyzer
        renameTracker *services.RenameTracker
        logger        *zap.Logger
        watchers      map[string]*fsnotify.Watcher
        watcherMu     sync.RWMutex
        changeQueue   chan EnhancedChangeEvent
        workers       int
        stopCh        chan struct{}
        wg            sync.WaitGroup
        debounceMap   map[string]*time.Timer
        debounceMu    sync.Mutex
        debounceDelay time.Duration
}

// EnhancedChangeEvent represents a file system change with additional metadata
type EnhancedChangeEvent struct {
        Path         string
        SmbRoot      string
        Operation    string // created, modified, deleted, moved
        Timestamp    time.Time
        Size         int64
        IsDir        bool
        FileHash     *string
        FileID       *int64
        PreviousPath *string // for move operations
}

// NewEnhancedChangeWatcher creates a new enhanced change watcher
func NewEnhancedChangeWatcher(mediaDB *database.MediaDatabase, analyzer *analyzer.MediaAnalyzer, renameTracker *services.RenameTracker, logger *zap.Logger) *EnhancedChangeWatcher <span class="cov0" title="0">{
        return &amp;EnhancedChangeWatcher{
                mediaDB:       mediaDB,
                analyzer:      analyzer,
                renameTracker: renameTracker,
                logger:        logger,
                watchers:      make(map[string]*fsnotify.Watcher),
                changeQueue:   make(chan EnhancedChangeEvent, 10000),
                workers:       4, // Increased workers for better performance
                debounceMap:   make(map[string]*time.Timer),
                debounceDelay: 2 * time.Second,
                stopCh:        make(chan struct{}),
        }
}</span>

// Start starts the enhanced change watcher
func (w *EnhancedChangeWatcher) Start() error <span class="cov0" title="0">{
        w.logger.Info("Starting enhanced change watcher", zap.Int("workers", w.workers))

        // Start worker goroutines
        for i := 0; i &lt; w.workers; i++ </span><span class="cov0" title="0">{
                w.wg.Add(1)
                go w.changeWorker(i)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the enhanced change watcher
func (w *EnhancedChangeWatcher) Stop() <span class="cov0" title="0">{
        w.logger.Info("Stopping enhanced change watcher")

        // Stop all file watchers
        w.watcherMu.Lock()
        for path, watcher := range w.watchers </span><span class="cov0" title="0">{
                watcher.Close()
                w.logger.Debug("Closed watcher", zap.String("path", path))
        }</span>
        <span class="cov0" title="0">w.watchers = make(map[string]*fsnotify.Watcher)
        w.watcherMu.Unlock()

        // Stop workers
        close(w.stopCh)
        w.wg.Wait()

        w.logger.Info("Enhanced change watcher stopped")</span>
}

// WatchPath adds a new path to watch
func (w *EnhancedChangeWatcher) WatchPath(smbRoot, localMountPath string) error <span class="cov0" title="0">{
        w.watcherMu.Lock()
        defer w.watcherMu.Unlock()

        // Check if already watching
        if _, exists := w.watchers[smbRoot]; exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create new watcher
        <span class="cov0" title="0">watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add path to watcher recursively
        <span class="cov0" title="0">err = w.addPathRecursively(watcher, localMountPath)
        if err != nil </span><span class="cov0" title="0">{
                watcher.Close()
                return err
        }</span>

        <span class="cov0" title="0">w.watchers[smbRoot] = watcher

        // Start monitoring goroutine
        w.wg.Add(1)
        go w.monitorPath(smbRoot, localMountPath, watcher)

        w.logger.Info("Started watching path",
                zap.String("smb_root", smbRoot),
                zap.String("local_path", localMountPath))

        return nil</span>
}

// UnwatchPath removes a path from watching
func (w *EnhancedChangeWatcher) UnwatchPath(smbRoot string) <span class="cov0" title="0">{
        w.watcherMu.Lock()
        defer w.watcherMu.Unlock()

        if watcher, exists := w.watchers[smbRoot]; exists </span><span class="cov0" title="0">{
                watcher.Close()
                delete(w.watchers, smbRoot)
                w.logger.Info("Stopped watching path", zap.String("smb_root", smbRoot))
        }</span>
}

// addPathRecursively adds a path and all its subdirectories to the watcher
func (w *EnhancedChangeWatcher) addPathRecursively(watcher *fsnotify.Watcher, rootPath string) error <span class="cov0" title="0">{
        return filepath.Walk(rootPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Skip problematic paths
                }</span>

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return watcher.Add(path)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
}

// monitorPath monitors a specific path for changes
func (w *EnhancedChangeWatcher) monitorPath(smbRoot, localPath string, watcher *fsnotify.Watcher) <span class="cov0" title="0">{
        defer w.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>

                case event, ok := &lt;-watcher.Events:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">w.handleFileSystemEvent(smbRoot, localPath, event)</span>

                case err, ok := &lt;-watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">w.logger.Error("File watcher error",
                                zap.String("smb_root", smbRoot),
                                zap.Error(err))</span>
                }
        }
}

// handleFileSystemEvent processes a file system event with enhanced logic
func (w *EnhancedChangeWatcher) handleFileSystemEvent(smbRoot, localPath string, event fsnotify.Event) <span class="cov0" title="0">{
        // Convert local path to relative path within the storage root
        relativePath, err := w.getRelativePath(localPath, event.Name)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Warn("Failed to get relative path", zap.Error(err))
                return
        }</span>

        // Determine operation type
        <span class="cov0" title="0">var operation string
        switch </span>{
        case event.Op&amp;fsnotify.Create == fsnotify.Create:<span class="cov0" title="0">
                operation = "created"</span>
        case event.Op&amp;fsnotify.Write == fsnotify.Write:<span class="cov0" title="0">
                operation = "modified"</span>
        case event.Op&amp;fsnotify.Remove == fsnotify.Remove:<span class="cov0" title="0">
                operation = "deleted"</span>
        case event.Op&amp;fsnotify.Rename == fsnotify.Rename:<span class="cov0" title="0">
                operation = "moved"</span>
        default:<span class="cov0" title="0">
                return</span> // Ignore other events
        }

        // Get file info and metadata
        <span class="cov0" title="0">var size int64
        var isDir bool
        var fileHash *string
        var fileID *int64

        if operation != "deleted" </span><span class="cov0" title="0">{
                // Get file stats
                info, err := os.Stat(event.Name)
                if err == nil </span><span class="cov0" title="0">{
                        size = info.Size()
                        isDir = info.IsDir()

                        // Calculate hash for files (not directories)
                        if !isDir &amp;&amp; size &gt; 0 &amp;&amp; size &lt; 100*1024*1024 </span><span class="cov0" title="0">{ // Only hash files &lt; 100MB
                                if hash := w.calculateFileHash(event.Name); hash != "" </span><span class="cov0" title="0">{
                                        fileHash = &amp;hash
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // For deleted files, try to get info from database
                fileInfo := w.getFileInfoFromDB(relativePath, smbRoot)
                if fileInfo != nil </span><span class="cov0" title="0">{
                        size = fileInfo.Size
                        isDir = fileInfo.IsDirectory
                        if fileInfo.Hash != nil </span><span class="cov0" title="0">{
                                fileHash = fileInfo.Hash
                        }</span>
                        <span class="cov0" title="0">fileID = &amp;fileInfo.ID</span>
                }
        }

        // Handle directory creation by adding to watcher
        <span class="cov0" title="0">if operation == "created" &amp;&amp; isDir </span><span class="cov0" title="0">{
                w.watcherMu.Lock()
                if watcher, exists := w.watchers[smbRoot]; exists </span><span class="cov0" title="0">{
                        watcher.Add(event.Name)
                }</span>
                <span class="cov0" title="0">w.watcherMu.Unlock()</span>
        }

        <span class="cov0" title="0">changeEvent := EnhancedChangeEvent{
                Path:      relativePath,
                SmbRoot:   smbRoot,
                Operation: operation,
                Timestamp: time.Now(),
                Size:      size,
                IsDir:     isDir,
                FileHash:  fileHash,
                FileID:    fileID,
        }

        // Debounce changes to avoid processing rapid consecutive changes
        w.debounceChange(changeEvent)</span>
}

// getRelativePath converts absolute path to relative path within storage root
func (w *EnhancedChangeWatcher) getRelativePath(basePath, fullPath string) (string, error) <span class="cov0" title="0">{
        relPath, err := filepath.Rel(basePath, fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Normalize path separators for cross-platform compatibility
        <span class="cov0" title="0">relPath = filepath.ToSlash(relPath)

        // Ensure path starts with /
        if !strings.HasPrefix(relPath, "/") </span><span class="cov0" title="0">{
                relPath = "/" + relPath
        }</span>

        <span class="cov0" title="0">return relPath, nil</span>
}

// getFileInfoFromDB retrieves file information from database
func (w *EnhancedChangeWatcher) getFileInfoFromDB(path, smbRoot string) *models.FileInfo <span class="cov0" title="0">{
        query := `
                SELECT f.id, f.name, f.path, f.is_directory, f.size, f.last_modified, f.hash, f.extension, f.mime_type, f.parent_id, f.smb_root, f.created_at, f.updated_at
                FROM files f
                JOIN storage_roots sr ON f.storage_root_id = sr.id
                WHERE f.path = ? AND sr.name = ?`

        var file models.FileInfo
        err := w.mediaDB.GetDB().QueryRow(query, path, smbRoot).Scan(
                &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory, &amp;file.Size,
                &amp;file.LastModified, &amp;file.Hash, &amp;file.Extension, &amp;file.MimeType,
                &amp;file.ParentID, &amp;file.SmbRoot, &amp;file.CreatedAt, &amp;file.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if file.IsDirectory </span><span class="cov0" title="0">{
                file.Type = "directory"
        }</span> else<span class="cov0" title="0"> {
                file.Type = "file"
        }</span>

        <span class="cov0" title="0">return &amp;file</span>
}

// calculateFileHash calculates MD5 hash of a file
func (w *EnhancedChangeWatcher) calculateFileHash(filePath string) string <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">defer file.Close()

        hash := md5.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return hex.EncodeToString(hash.Sum(nil))</span>
}

// debounceChange debounces file changes to avoid excessive processing
func (w *EnhancedChangeWatcher) debounceChange(event EnhancedChangeEvent) <span class="cov0" title="0">{
        w.debounceMu.Lock()
        defer w.debounceMu.Unlock()

        key := event.SmbRoot + ":" + event.Path

        // Cancel existing timer
        if timer, exists := w.debounceMap[key]; exists </span><span class="cov0" title="0">{
                timer.Stop()
        }</span>

        // Create new timer
        <span class="cov0" title="0">w.debounceMap[key] = time.AfterFunc(w.debounceDelay, func() </span><span class="cov0" title="0">{
                w.debounceMu.Lock()
                delete(w.debounceMap, key)
                w.debounceMu.Unlock()

                // Send to processing queue
                select </span>{
                case w.changeQueue &lt;- event:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        w.logger.Warn("Change queue full, dropping event",
                                zap.String("path", event.Path),
                                zap.String("operation", event.Operation))</span>
                }
        })
}

// changeWorker processes change events
func (w *EnhancedChangeWatcher) changeWorker(workerID int) <span class="cov0" title="0">{
        defer w.wg.Done()

        w.logger.Info("Enhanced change worker started", zap.Int("worker_id", workerID))

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>

                case event := &lt;-w.changeQueue:<span class="cov0" title="0">
                        w.processChange(event, workerID)</span>
                }
        }
}

// processChange processes a single change event with rename detection
func (w *EnhancedChangeWatcher) processChange(event EnhancedChangeEvent, workerID int) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        w.logger.Debug("Processing enhanced change event",
                zap.Int("worker_id", workerID),
                zap.String("path", event.Path),
                zap.String("operation", event.Operation),
                zap.String("smb_root", event.SmbRoot))

        // Log the change
        if err := w.logChange(event); err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to log change", zap.Error(err))
        }</span>

        <span class="cov0" title="0">switch event.Operation </span>{
        case "created":<span class="cov0" title="0">
                w.handleCreate(ctx, event)</span>
        case "modified":<span class="cov0" title="0">
                w.handleModify(ctx, event)</span>
        case "deleted":<span class="cov0" title="0">
                w.handleDelete(ctx, event)</span>
        case "moved":<span class="cov0" title="0">
                w.handleMove(ctx, event)</span>
        }
}

// handleCreate handles file/directory creation with rename detection
func (w *EnhancedChangeWatcher) handleCreate(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        // Check if this creation is actually part of a move operation
        if pendingMove, isMove := w.renameTracker.DetectCreate(ctx, event.Path, event.SmbRoot, event.Size, event.FileHash, event.IsDir); isMove </span><span class="cov0" title="0">{
                // This is a move operation, not a new file
                err := w.renameTracker.ProcessMove(ctx, pendingMove, event.Path)
                if err != nil </span><span class="cov0" title="0">{
                        w.logger.Error("Failed to process move operation",
                                zap.String("old_path", pendingMove.Path),
                                zap.String("new_path", event.Path),
                                zap.Error(err))

                        // Fall back to treating as delete + create
                        w.handleDeleteFallback(ctx, pendingMove)
                        w.handleCreateNew(ctx, event)
                }</span> else<span class="cov0" title="0"> {
                        w.logger.Info("Successfully processed rename operation",
                                zap.String("old_path", pendingMove.Path),
                                zap.String("new_path", event.Path),
                                zap.Bool("is_directory", event.IsDir))

                        // No need for rescanning - just metadata update
                        w.updateFileMetadata(ctx, event)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // This is a genuinely new file/directory
        <span class="cov0" title="0">w.handleCreateNew(ctx, event)</span>
}

// handleCreateNew handles creation of a genuinely new file/directory
func (w *EnhancedChangeWatcher) handleCreateNew(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        if event.IsDir </span><span class="cov0" title="0">{
                // Directory creation - trigger directory analysis
                err := w.analyzer.AnalyzeDirectory(ctx, event.Path, event.SmbRoot, 7) // High priority
                if err != nil </span><span class="cov0" title="0">{
                        w.logger.Error("Failed to queue directory analysis",
                                zap.String("path", event.Path),
                                zap.Error(err))
                }</span>
        } else<span class="cov0" title="0"> {
                // File creation - analyze parent directory
                parentDir := filepath.Dir(event.Path)
                err := w.analyzer.AnalyzeDirectory(ctx, parentDir, event.SmbRoot, 6) // Medium-high priority
                if err != nil </span><span class="cov0" title="0">{
                        w.logger.Error("Failed to queue directory analysis for new file",
                                zap.String("file", event.Path),
                                zap.String("parent_dir", parentDir),
                                zap.Error(err))
                }</span>
        }
}

// handleModify handles file modification
func (w *EnhancedChangeWatcher) handleModify(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        if event.IsDir </span><span class="cov0" title="0">{
                // Directory modification - usually metadata changes
                w.updateDirectoryMetadata(ctx, event)
        }</span> else<span class="cov0" title="0"> {
                // File modification - update file metadata and check for changes
                w.updateFileMetadata(ctx, event)

                // If this is a media file, might need re-analysis
                if w.isMediaFile(event.Path) </span><span class="cov0" title="0">{
                        parentDir := filepath.Dir(event.Path)
                        w.analyzer.AnalyzeDirectory(ctx, parentDir, event.SmbRoot, 5) // Medium priority
                }</span>
        }
}

// handleDelete handles file/directory deletion with move tracking
func (w *EnhancedChangeWatcher) handleDelete(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        // Track this deletion for potential move detection
        if event.FileID != nil </span><span class="cov0" title="0">{
                w.renameTracker.TrackDelete(ctx, *event.FileID, event.Path, event.SmbRoot, event.Size, event.FileHash, event.IsDir)
        }</span>

        // Don't immediately delete from database - wait for move window to expire
        // The rename tracker's cleanup will handle actual deletions
}

// handleDeleteFallback handles deletion when move processing fails
func (w *EnhancedChangeWatcher) handleDeleteFallback(ctx context.Context, pendingMove *services.PendingMove) <span class="cov0" title="0">{
        // Mark files as deleted in database
        query := `
                UPDATE files
                SET deleted = true, deleted_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := w.mediaDB.GetDB().ExecContext(ctx, query, pendingMove.FileID)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to mark file as deleted",
                        zap.String("path", pendingMove.Path),
                        zap.Error(err))
        }</span>
}

// handleMove handles explicit move operations (rare with fsnotify)
func (w *EnhancedChangeWatcher) handleMove(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        // This is handled by the create/delete pair in most file systems
        w.logger.Debug("Explicit move event received", zap.String("path", event.Path))
}</span>

// updateFileMetadata updates file metadata without rescanning
func (w *EnhancedChangeWatcher) updateFileMetadata(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        query := `
                UPDATE files
                SET last_scan_at = CURRENT_TIMESTAMP, modified_at = ?, size = ?, quick_hash = ?
                WHERE path = ? AND storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)`

        _, err := w.mediaDB.GetDB().ExecContext(ctx, query, event.Timestamp, event.Size, event.FileHash, event.Path, event.SmbRoot)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to update file metadata",
                        zap.String("path", event.Path),
                        zap.Error(err))
        }</span>
}

// updateDirectoryMetadata updates directory metadata
func (w *EnhancedChangeWatcher) updateDirectoryMetadata(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        query := `
                UPDATE files
                SET last_scan_at = CURRENT_TIMESTAMP, modified_at = ?
                WHERE path = ? AND storage_root_id = (SELECT id FROM storage_roots WHERE name = ?) AND is_directory = true`

        _, err := w.mediaDB.GetDB().ExecContext(ctx, query, event.Timestamp, event.Path, event.SmbRoot)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to update directory metadata",
                        zap.String("path", event.Path),
                        zap.Error(err))
        }</span>
}

// isMediaFile checks if a file is a media file based on extension
func (w *EnhancedChangeWatcher) isMediaFile(path string) bool <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(path))
        mediaExtensions := map[string]bool{
                ".mp4": true, ".avi": true, ".mkv": true, ".mov": true, ".wmv": true,
                ".mp3": true, ".flac": true, ".wav": true, ".aac": true, ".ogg": true,
                ".jpg": true, ".jpeg": true, ".png": true, ".gif": true, ".bmp": true,
                ".pdf": true, ".epub": true, ".mobi": true,
        }
        return mediaExtensions[ext]
}</span>

// logChange logs the change to the database
func (w *EnhancedChangeWatcher) logChange(event EnhancedChangeEvent) error <span class="cov0" title="0">{
        eventDataJSON, _ := json.Marshal(map[string]interface{}{
                "path":      event.Path,
                "operation": event.Operation,
                "timestamp": event.Timestamp,
                "size":      event.Size,
                "is_dir":    event.IsDir,
                "file_hash": event.FileHash,
                "file_id":   event.FileID,
        })

        query := `
                INSERT INTO change_log (entity_type, entity_id, change_type, new_data, detected_at, processed)
                VALUES (?, ?, ?, ?, ?, ?)`

        _, err := w.mediaDB.GetDB().Exec(query,
                "file", event.Path, event.Operation, string(eventDataJSON), event.Timestamp, false)

        return err
}</span>

// GetStatistics returns statistics about the enhanced watcher
func (w *EnhancedChangeWatcher) GetStatistics(since time.Time) (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Get change statistics
        query := `
                SELECT change_type, COUNT(*) as count
                FROM change_log
                WHERE detected_at &gt;= ?
                GROUP BY change_type`

        rows, err := w.mediaDB.GetDB().Query(query, since)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        changeTypes := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var changeType string
                var count int
                if err := rows.Scan(&amp;changeType, &amp;count); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">changeTypes[changeType] = count</span>
        }
        <span class="cov0" title="0">stats["changes_by_type"] = changeTypes

        // Get rename tracker statistics
        renameStats := w.renameTracker.GetStatistics()
        stats["rename_tracking"] = renameStats

        // Count currently watched paths
        w.watcherMu.RLock()
        stats["watched_paths"] = len(w.watchers)
        w.watcherMu.RUnlock()

        // Queue statistics
        stats["queue_length"] = len(w.changeQueue)
        stats["workers"] = w.workers

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package realtime

import (
        "catalogizer/internal/media/analyzer"
        "catalogizer/internal/media/database"
        "context"
        "encoding/json"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/fsnotify/fsnotify"
        "go.uber.org/zap"
)

// SMBChangeWatcher monitors SMB shares for changes and triggers real-time analysis
type SMBChangeWatcher struct {
        mediaDB       *database.MediaDatabase
        analyzer      *analyzer.MediaAnalyzer
        logger        *zap.Logger
        watchers      map[string]*fsnotify.Watcher
        watcherMu     sync.RWMutex
        changeQueue   chan ChangeEvent
        workers       int
        stopCh        chan struct{}
        wg            sync.WaitGroup
        debounceMap   map[string]*time.Timer
        debounceMu    sync.Mutex
        debounceDelay time.Duration
}

// ChangeEvent represents a file system change
type ChangeEvent struct {
        Path      string
        SmbRoot   string
        Operation string // created, modified, deleted, moved
        Timestamp time.Time
        Size      int64
        IsDir     bool
}

// NewSMBChangeWatcher creates a new change watcher
func NewSMBChangeWatcher(mediaDB *database.MediaDatabase, analyzer *analyzer.MediaAnalyzer, logger *zap.Logger) *SMBChangeWatcher <span class="cov0" title="0">{
        return &amp;SMBChangeWatcher{
                mediaDB:       mediaDB,
                analyzer:      analyzer,
                logger:        logger,
                watchers:      make(map[string]*fsnotify.Watcher),
                changeQueue:   make(chan ChangeEvent, 10000),
                workers:       2,
                debounceMap:   make(map[string]*time.Timer),
                debounceDelay: 2 * time.Second, // Wait 2 seconds before processing changes
                stopCh:        make(chan struct{}),
        }
}</span>

// Start starts the change watcher
func (w *SMBChangeWatcher) Start() error <span class="cov0" title="0">{
        w.logger.Info("Starting SMB change watcher", zap.Int("workers", w.workers))

        // Start worker goroutines
        for i := 0; i &lt; w.workers; i++ </span><span class="cov0" title="0">{
                w.wg.Add(1)
                go w.changeWorker(i)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the change watcher
func (w *SMBChangeWatcher) Stop() <span class="cov0" title="0">{
        w.logger.Info("Stopping SMB change watcher")

        // Stop all file watchers
        w.watcherMu.Lock()
        for path, watcher := range w.watchers </span><span class="cov0" title="0">{
                watcher.Close()
                w.logger.Debug("Closed watcher", zap.String("path", path))
        }</span>
        <span class="cov0" title="0">w.watchers = make(map[string]*fsnotify.Watcher)
        w.watcherMu.Unlock()

        // Stop workers
        close(w.stopCh)
        w.wg.Wait()

        w.logger.Info("SMB change watcher stopped")</span>
}

// WatchSMBPath adds a new SMB path to watch
func (w *SMBChangeWatcher) WatchSMBPath(smbRoot, localMountPath string) error <span class="cov0" title="0">{
        w.watcherMu.Lock()
        defer w.watcherMu.Unlock()

        // Check if already watching
        if _, exists := w.watchers[smbRoot]; exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create new watcher
        <span class="cov0" title="0">watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add path to watcher
        <span class="cov0" title="0">err = watcher.Add(localMountPath)
        if err != nil </span><span class="cov0" title="0">{
                watcher.Close()
                return err
        }</span>

        <span class="cov0" title="0">w.watchers[smbRoot] = watcher

        // Start monitoring goroutine
        w.wg.Add(1)
        go w.monitorPath(smbRoot, localMountPath, watcher)

        w.logger.Info("Started watching SMB path",
                zap.String("smb_root", smbRoot),
                zap.String("local_path", localMountPath))

        return nil</span>
}

// UnwatchSMBPath removes an SMB path from watching
func (w *SMBChangeWatcher) UnwatchSMBPath(smbRoot string) <span class="cov0" title="0">{
        w.watcherMu.Lock()
        defer w.watcherMu.Unlock()

        if watcher, exists := w.watchers[smbRoot]; exists </span><span class="cov0" title="0">{
                watcher.Close()
                delete(w.watchers, smbRoot)
                w.logger.Info("Stopped watching SMB path", zap.String("smb_root", smbRoot))
        }</span>
}

// monitorPath monitors a specific path for changes
func (w *SMBChangeWatcher) monitorPath(smbRoot, localPath string, watcher *fsnotify.Watcher) <span class="cov0" title="0">{
        defer w.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>

                case event, ok := &lt;-watcher.Events:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">w.handleFileSystemEvent(smbRoot, event)</span>

                case err, ok := &lt;-watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">w.logger.Error("File watcher error",
                                zap.String("smb_root", smbRoot),
                                zap.Error(err))</span>
                }
        }
}

// handleFileSystemEvent processes a file system event
func (w *SMBChangeWatcher) handleFileSystemEvent(smbRoot string, event fsnotify.Event) <span class="cov0" title="0">{
        // Determine operation type
        var operation string
        switch </span>{
        case event.Op&amp;fsnotify.Create == fsnotify.Create:<span class="cov0" title="0">
                operation = "created"</span>
        case event.Op&amp;fsnotify.Write == fsnotify.Write:<span class="cov0" title="0">
                operation = "modified"</span>
        case event.Op&amp;fsnotify.Remove == fsnotify.Remove:<span class="cov0" title="0">
                operation = "deleted"</span>
        case event.Op&amp;fsnotify.Rename == fsnotify.Rename:<span class="cov0" title="0">
                operation = "moved"</span>
        default:<span class="cov0" title="0">
                return</span> // Ignore other events
        }

        // Get file info
        <span class="cov0" title="0">var size int64
        var isDir bool
        if operation != "deleted" </span><span class="cov0" title="0">{
                if info, err := filepath.Glob(event.Name); err == nil &amp;&amp; len(info) &gt; 0 </span><span class="cov0" title="0">{
                        // This is a simplified check - in real implementation,
                        // you'd use proper file stat
                        isDir = filepath.Ext(event.Name) == ""
                }</span>
        }

        <span class="cov0" title="0">changeEvent := ChangeEvent{
                Path:      event.Name,
                SmbRoot:   smbRoot,
                Operation: operation,
                Timestamp: time.Now(),
                Size:      size,
                IsDir:     isDir,
        }

        // Debounce changes to avoid processing rapid consecutive changes
        w.debounceChange(changeEvent)</span>
}

// debounceChange debounces file changes to avoid excessive processing
func (w *SMBChangeWatcher) debounceChange(event ChangeEvent) <span class="cov0" title="0">{
        w.debounceMu.Lock()
        defer w.debounceMu.Unlock()

        key := event.SmbRoot + ":" + event.Path

        // Cancel existing timer
        if timer, exists := w.debounceMap[key]; exists </span><span class="cov0" title="0">{
                timer.Stop()
        }</span>

        // Create new timer
        <span class="cov0" title="0">w.debounceMap[key] = time.AfterFunc(w.debounceDelay, func() </span><span class="cov0" title="0">{
                w.debounceMu.Lock()
                delete(w.debounceMap, key)
                w.debounceMu.Unlock()

                // Send to processing queue
                select </span>{
                case w.changeQueue &lt;- event:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        w.logger.Warn("Change queue full, dropping event",
                                zap.String("path", event.Path),
                                zap.String("operation", event.Operation))</span>
                }
        })
}

// changeWorker processes change events
func (w *SMBChangeWatcher) changeWorker(workerID int) <span class="cov0" title="0">{
        defer w.wg.Done()

        w.logger.Info("Change worker started", zap.Int("worker_id", workerID))

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>

                case event := &lt;-w.changeQueue:<span class="cov0" title="0">
                        w.processChange(event, workerID)</span>
                }
        }
}

// processChange processes a single change event
func (w *SMBChangeWatcher) processChange(event ChangeEvent, workerID int) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        w.logger.Debug("Processing change event",
                zap.Int("worker_id", workerID),
                zap.String("path", event.Path),
                zap.String("operation", event.Operation),
                zap.String("smb_root", event.SmbRoot))

        // Log the change
        if err := w.logChange(event); err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to log change", zap.Error(err))
        }</span>

        <span class="cov0" title="0">switch event.Operation </span>{
        case "created", "modified":<span class="cov0" title="0">
                w.handleCreateOrModify(ctx, event)</span>
        case "deleted":<span class="cov0" title="0">
                w.handleDelete(ctx, event)</span>
        case "moved":<span class="cov0" title="0">
                w.handleMove(ctx, event)</span>
        }
}

// logChange logs the change to the database
func (w *SMBChangeWatcher) logChange(event ChangeEvent) error <span class="cov0" title="0">{
        oldDataJSON, _ := json.Marshal(map[string]interface{}{
                "path":      event.Path,
                "operation": event.Operation,
                "timestamp": event.Timestamp,
                "size":      event.Size,
                "is_dir":    event.IsDir,
        })

        query := `
                INSERT INTO change_log (entity_type, entity_id, change_type, new_data, detected_at, processed)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err := w.mediaDB.GetDB().Exec(query,
                "file", event.Path, event.Operation, string(oldDataJSON), event.Timestamp, false)

        return err
}</span>

// handleCreateOrModify handles file creation or modification
func (w *SMBChangeWatcher) handleCreateOrModify(ctx context.Context, event ChangeEvent) <span class="cov0" title="0">{
        if event.IsDir </span><span class="cov0" title="0">{
                // Directory change - trigger directory analysis
                err := w.analyzer.AnalyzeDirectory(ctx, event.Path, event.SmbRoot, 7) // High priority
                if err != nil </span><span class="cov0" title="0">{
                        w.logger.Error("Failed to queue directory analysis",
                                zap.String("path", event.Path),
                                zap.Error(err))
                }</span>
        } else<span class="cov0" title="0"> {
                // File change - check if it belongs to existing media item
                w.handleFileChange(ctx, event)
        }</span>
}

// handleDelete handles file or directory deletion
func (w *SMBChangeWatcher) handleDelete(ctx context.Context, event ChangeEvent) <span class="cov0" title="0">{
        // Mark files as missing in database
        query := `
                UPDATE media_files
                SET last_verified = ?, virtual_smb_link = NULL
                WHERE file_path = ? AND smb_root = ?
        `

        _, err := w.mediaDB.GetDB().Exec(query, time.Now(), event.Path, event.SmbRoot)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to mark file as deleted",
                        zap.String("path", event.Path),
                        zap.Error(err))
        }</span>

        // Check if this affects any media items
        <span class="cov0" title="0">w.checkMediaItemIntegrity(ctx, event.Path, event.SmbRoot)</span>
}

// handleMove handles file or directory moves
func (w *SMBChangeWatcher) handleMove(ctx context.Context, event ChangeEvent) <span class="cov0" title="0">{
        // This is complex to implement properly as we need both old and new paths
        // For now, treat as delete + create
        w.handleDelete(ctx, event)
}</span>

// handleFileChange handles individual file changes
func (w *SMBChangeWatcher) handleFileChange(ctx context.Context, event ChangeEvent) <span class="cov0" title="0">{
        // Check if file belongs to existing media item
        query := `
                SELECT mf.media_item_id, mi.title, mi.media_type_id
                FROM media_files mf
                JOIN media_items mi ON mf.media_item_id = mi.id
                WHERE mf.file_path = ? AND mf.smb_root = ?
        `

        var mediaItemID, mediaTypeID int64
        var title string
        err := w.mediaDB.GetDB().QueryRow(query, event.Path, event.SmbRoot).Scan(&amp;mediaItemID, &amp;title, &amp;mediaTypeID)

        if err == nil </span><span class="cov0" title="0">{
                // File belongs to existing media item - update verification timestamp
                updateQuery := `UPDATE media_files SET last_verified = ? WHERE file_path = ? AND smb_root = ?`
                w.mediaDB.GetDB().Exec(updateQuery, time.Now(), event.Path, event.SmbRoot)

                w.logger.Debug("Updated existing media file",
                        zap.String("path", event.Path),
                        zap.String("title", title),
                        zap.Int64("media_item_id", mediaItemID))
        }</span> else<span class="cov0" title="0"> {
                // New file - analyze parent directory
                parentDir := filepath.Dir(event.Path)
                err := w.analyzer.AnalyzeDirectory(ctx, parentDir, event.SmbRoot, 6) // Medium-high priority
                if err != nil </span><span class="cov0" title="0">{
                        w.logger.Error("Failed to queue directory analysis for new file",
                                zap.String("file", event.Path),
                                zap.String("parent_dir", parentDir),
                                zap.Error(err))
                }</span>
        }
}

// checkMediaItemIntegrity checks if a media item is still valid after file changes
func (w *SMBChangeWatcher) checkMediaItemIntegrity(ctx context.Context, filePath, smbRoot string) <span class="cov0" title="0">{
        // Find media items that might be affected
        query := `
                SELECT DISTINCT mi.id, mi.title, COUNT(mf.id) as file_count
                FROM media_items mi
                JOIN media_files mf ON mi.id = mf.media_item_id
                WHERE mf.smb_root = ? AND mf.file_path LIKE ?
                GROUP BY mi.id, mi.title
        `

        dirPattern := filepath.Dir(filePath) + "%"
        rows, err := w.mediaDB.GetDB().Query(query, smbRoot, dirPattern)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to check media item integrity", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var mediaItemID int64
                var title string
                var fileCount int

                if err := rows.Scan(&amp;mediaItemID, &amp;title, &amp;fileCount); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // If media item has very few files remaining, mark for review
                <span class="cov0" title="0">if fileCount &lt;= 1 </span><span class="cov0" title="0">{
                        w.logger.Warn("Media item may be incomplete after file deletion",
                                zap.Int64("media_item_id", mediaItemID),
                                zap.String("title", title),
                                zap.Int("remaining_files", fileCount))

                        // Update media item status
                        updateQuery := `UPDATE media_items SET status = 'missing', last_updated = ? WHERE id = ?`
                        w.mediaDB.GetDB().Exec(updateQuery, time.Now(), mediaItemID)
                }</span>
        }
}

// GetChangeStatistics returns statistics about recent changes
func (w *SMBChangeWatcher) GetChangeStatistics(since time.Time) (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Count changes by type
        query := `
                SELECT change_type, COUNT(*) as count
                FROM change_log
                WHERE detected_at &gt;= ?
                GROUP BY change_type
        `

        rows, err := w.mediaDB.GetDB().Query(query, since)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        changeTypes := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var changeType string
                var count int
                if err := rows.Scan(&amp;changeType, &amp;count); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">changeTypes[changeType] = count</span>
        }
        <span class="cov0" title="0">stats["changes_by_type"] = changeTypes

        // Count total changes
        var totalChanges int
        err = w.mediaDB.GetDB().QueryRow(
                "SELECT COUNT(*) FROM change_log WHERE detected_at &gt;= ?", since).Scan(&amp;totalChanges)
        if err == nil </span><span class="cov0" title="0">{
                stats["total_changes"] = totalChanges
        }</span>

        // Count unprocessed changes
        <span class="cov0" title="0">var unprocessed int
        err = w.mediaDB.GetDB().QueryRow(
                "SELECT COUNT(*) FROM change_log WHERE processed = false").Scan(&amp;unprocessed)
        if err == nil </span><span class="cov0" title="0">{
                stats["unprocessed_changes"] = unprocessed
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// ProcessPendingChanges processes any unprocessed changes
func (w *SMBChangeWatcher) ProcessPendingChanges(ctx context.Context) error <span class="cov0" title="0">{
        query := `
                SELECT id, entity_id, change_type, new_data, detected_at
                FROM change_log
                WHERE processed = false
                ORDER BY detected_at ASC
                LIMIT 100
        `

        rows, err := w.mediaDB.GetDB().Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var processedIDs []int64

        for rows.Next() </span><span class="cov0" title="0">{
                var id int64
                var entityID, changeType, newDataJSON string
                var detectedAt time.Time

                if err := rows.Scan(&amp;id, &amp;entityID, &amp;changeType, &amp;newDataJSON, &amp;detectedAt); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse change data
                <span class="cov0" title="0">var changeData map[string]interface{}
                if err := json.Unmarshal([]byte(newDataJSON), &amp;changeData); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create change event
                <span class="cov0" title="0">event := ChangeEvent{
                        Path:      entityID,
                        Operation: changeType,
                        Timestamp: detectedAt,
                }

                if smbRoot, ok := changeData["smb_root"].(string); ok </span><span class="cov0" title="0">{
                        event.SmbRoot = smbRoot
                }</span>
                <span class="cov0" title="0">if size, ok := changeData["size"].(float64); ok </span><span class="cov0" title="0">{
                        event.Size = int64(size)
                }</span>
                <span class="cov0" title="0">if isDir, ok := changeData["is_dir"].(bool); ok </span><span class="cov0" title="0">{
                        event.IsDir = isDir
                }</span>

                // Process the change
                <span class="cov0" title="0">w.processChange(event, 0)
                processedIDs = append(processedIDs, id)</span>
        }

        // Mark changes as processed
        <span class="cov0" title="0">if len(processedIDs) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := strings.Repeat("?,", len(processedIDs))
                placeholders = placeholders[:len(placeholders)-1]

                updateQuery := "UPDATE change_log SET processed = true WHERE id IN (" + placeholders + ")"
                args := make([]interface{}, len(processedIDs))
                for i, id := range processedIDs </span><span class="cov0" title="0">{
                        args[i] = id
                }</span>

                <span class="cov0" title="0">_, err = w.mediaDB.GetDB().Exec(updateQuery, args...)
                if err != nil </span><span class="cov0" title="0">{
                        w.logger.Error("Failed to mark changes as processed", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        w.logger.Info("Processed pending changes", zap.Int("count", len(processedIDs)))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package middleware

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
)

func CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Credentials", "true")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Header("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE, PATCH")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func Logger(logger *zap.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                path := c.Request.URL.Path
                raw := c.Request.URL.RawQuery

                c.Next()

                latency := time.Since(start)
                clientIP := c.ClientIP()
                method := c.Request.Method
                statusCode := c.Writer.Status()

                if raw != "" </span><span class="cov0" title="0">{
                        path = path + "?" + raw
                }</span>

                <span class="cov0" title="0">logger.Info("HTTP Request",
                        zap.String("method", method),
                        zap.String("path", path),
                        zap.Int("status", statusCode),
                        zap.String("ip", clientIP),
                        zap.Duration("latency", latency),
                        zap.String("user_agent", c.Request.UserAgent()),
                )</span>
        }
}

func ErrorHandler() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        err := c.Errors.Last()
                        switch err.Type </span>{
                        case gin.ErrorTypeBind:<span class="cov0" title="0">
                                c.JSON(http.StatusBadRequest, gin.H{
                                        "error":   "Invalid request format",
                                        "details": err.Error(),
                                })</span>
                        case gin.ErrorTypePublic:<span class="cov0" title="0">
                                c.JSON(http.StatusInternalServerError, gin.H{
                                        "error": err.Error(),
                                })</span>
                        default:<span class="cov0" title="0">
                                c.JSON(http.StatusInternalServerError, gin.H{
                                        "error": "Internal server error",
                                })</span>
                        }
                }
        }
}

func RequestID() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = uuid.New().String()
                }</span>
                <span class="cov0" title="0">c.Header("X-Request-ID", requestID)
                c.Set("RequestID", requestID)
                c.Next()</span>
        }
}

type RateLimiter struct {
        requests map[string][]time.Time
        limit    int
        window   time.Duration
}

func NewRateLimiter(limit int, window time.Duration) *RateLimiter <span class="cov0" title="0">{
        return &amp;RateLimiter{
                requests: make(map[string][]time.Time),
                limit:    limit,
                window:   window,
        }
}</span>

func (rl *RateLimiter) Middleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                clientIP := c.ClientIP()
                now := time.Now()

                // Clean old requests
                if requests, exists := rl.requests[clientIP]; exists </span><span class="cov0" title="0">{
                        var validRequests []time.Time
                        for _, req := range requests </span><span class="cov0" title="0">{
                                if now.Sub(req) &lt; rl.window </span><span class="cov0" title="0">{
                                        validRequests = append(validRequests, req)
                                }</span>
                        }
                        <span class="cov0" title="0">rl.requests[clientIP] = validRequests</span>
                }

                // Check if limit exceeded
                <span class="cov0" title="0">if len(rl.requests[clientIP]) &gt;= rl.limit </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": "Rate limit exceeded",
                        })
                        c.Abort()
                        return
                }</span>

                // Add current request
                <span class="cov0" title="0">rl.requests[clientIP] = append(rl.requests[clientIP], now)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package recovery

import (
        "errors"
        "sync"
        "time"

        "go.uber.org/zap"
)

// CircuitState represents the state of a circuit breaker
type CircuitState int

const (
        StateClosed CircuitState = iota
        StateHalfOpen
        StateOpen
)

func (s CircuitState) String() string <span class="cov0" title="0">{
        switch s </span>{
        case StateClosed:<span class="cov0" title="0">
                return "closed"</span>
        case StateHalfOpen:<span class="cov0" title="0">
                return "half-open"</span>
        case StateOpen:<span class="cov0" title="0">
                return "open"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// CircuitBreaker implements the circuit breaker pattern for fault tolerance
type CircuitBreaker struct {
        name            string
        maxFailures     int
        resetTimeout    time.Duration
        state           CircuitState
        failures        int
        lastFailureTime time.Time
        nextAttempt     time.Time
        mutex           sync.RWMutex
        logger          *zap.Logger
        onStateChange   func(string, CircuitState, CircuitState)
}

// CircuitBreakerConfig contains configuration for a circuit breaker
type CircuitBreakerConfig struct {
        Name         string
        MaxFailures  int
        ResetTimeout time.Duration
        Logger       *zap.Logger
}

// NewCircuitBreaker creates a new circuit breaker
func NewCircuitBreaker(config CircuitBreakerConfig) *CircuitBreaker <span class="cov0" title="0">{
        if config.MaxFailures &lt;= 0 </span><span class="cov0" title="0">{
                config.MaxFailures = 5
        }</span>
        <span class="cov0" title="0">if config.ResetTimeout &lt;= 0 </span><span class="cov0" title="0">{
                config.ResetTimeout = 60 * time.Second
        }</span>

        <span class="cov0" title="0">return &amp;CircuitBreaker{
                name:         config.Name,
                maxFailures:  config.MaxFailures,
                resetTimeout: config.ResetTimeout,
                state:        StateClosed,
                logger:       config.Logger,
        }</span>
}

// SetStateChangeCallback sets a callback for state changes
func (cb *CircuitBreaker) SetStateChangeCallback(callback func(string, CircuitState, CircuitState)) <span class="cov0" title="0">{
        cb.onStateChange = callback
}</span>

// Execute executes a function with circuit breaker protection
func (cb *CircuitBreaker) Execute(fn func() error) error <span class="cov0" title="0">{
        if !cb.allowRequest() </span><span class="cov0" title="0">{
                return errors.New("circuit breaker is open")
        }</span>

        <span class="cov0" title="0">err := fn()
        cb.recordResult(err)
        return err</span>
}

// allowRequest determines if a request should be allowed
func (cb *CircuitBreaker) allowRequest() bool <span class="cov0" title="0">{
        cb.mutex.RLock()
        defer cb.mutex.RUnlock()

        switch cb.state </span>{
        case StateClosed:<span class="cov0" title="0">
                return true</span>
        case StateOpen:<span class="cov0" title="0">
                return time.Now().After(cb.nextAttempt)</span>
        case StateHalfOpen:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// recordResult records the result of an operation
func (cb *CircuitBreaker) recordResult(err error) <span class="cov0" title="0">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        if err != nil </span><span class="cov0" title="0">{
                cb.recordFailure()
        }</span> else<span class="cov0" title="0"> {
                cb.recordSuccess()
        }</span>
}

// recordFailure records a failure
func (cb *CircuitBreaker) recordFailure() <span class="cov0" title="0">{
        cb.failures++
        cb.lastFailureTime = time.Now()

        switch cb.state </span>{
        case StateClosed:<span class="cov0" title="0">
                if cb.failures &gt;= cb.maxFailures </span><span class="cov0" title="0">{
                        cb.setState(StateOpen)
                        cb.nextAttempt = time.Now().Add(cb.resetTimeout)
                }</span>
        case StateHalfOpen:<span class="cov0" title="0">
                cb.setState(StateOpen)
                cb.nextAttempt = time.Now().Add(cb.resetTimeout)</span>
        }

        <span class="cov0" title="0">cb.logger.Warn("Circuit breaker recorded failure",
                zap.String("name", cb.name),
                zap.Int("failures", cb.failures),
                zap.String("state", cb.state.String()))</span>
}

// recordSuccess records a success
func (cb *CircuitBreaker) recordSuccess() <span class="cov0" title="0">{
        switch cb.state </span>{
        case StateHalfOpen:<span class="cov0" title="0">
                cb.failures = 0
                cb.setState(StateClosed)</span>
        case StateClosed:<span class="cov0" title="0">
                cb.failures = 0</span>
        }

        <span class="cov0" title="0">cb.logger.Debug("Circuit breaker recorded success",
                zap.String("name", cb.name),
                zap.String("state", cb.state.String()))</span>
}

// setState changes the circuit breaker state
func (cb *CircuitBreaker) setState(newState CircuitState) <span class="cov0" title="0">{
        if cb.state == newState </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">oldState := cb.state
        cb.state = newState

        cb.logger.Info("Circuit breaker state changed",
                zap.String("name", cb.name),
                zap.String("old_state", oldState.String()),
                zap.String("new_state", newState.String()))

        if cb.onStateChange != nil </span><span class="cov0" title="0">{
                cb.onStateChange(cb.name, oldState, newState)
        }</span>
}

// GetState returns the current state
func (cb *CircuitBreaker) GetState() CircuitState <span class="cov0" title="0">{
        cb.mutex.RLock()
        defer cb.mutex.RUnlock()
        return cb.state
}</span>

// GetFailures returns the current failure count
func (cb *CircuitBreaker) GetFailures() int <span class="cov0" title="0">{
        cb.mutex.RLock()
        defer cb.mutex.RUnlock()
        return cb.failures
}</span>

// GetStats returns circuit breaker statistics
func (cb *CircuitBreaker) GetStats() map[string]interface{} <span class="cov0" title="0">{
        cb.mutex.RLock()
        defer cb.mutex.RUnlock()

        return map[string]interface{}{
                "name":              cb.name,
                "state":             cb.state.String(),
                "failures":          cb.failures,
                "max_failures":      cb.maxFailures,
                "last_failure_time": cb.lastFailureTime,
                "next_attempt":      cb.nextAttempt,
                "reset_timeout":     cb.resetTimeout,
        }
}</span>

// Reset manually resets the circuit breaker
func (cb *CircuitBreaker) Reset() <span class="cov0" title="0">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        cb.failures = 0
        cb.setState(StateClosed)

        cb.logger.Info("Circuit breaker manually reset", zap.String("name", cb.name))
}</span>

// CircuitBreakerManager manages multiple circuit breakers
type CircuitBreakerManager struct {
        breakers map[string]*CircuitBreaker
        mutex    sync.RWMutex
        logger   *zap.Logger
}

// NewCircuitBreakerManager creates a new circuit breaker manager
func NewCircuitBreakerManager(logger *zap.Logger) *CircuitBreakerManager <span class="cov0" title="0">{
        return &amp;CircuitBreakerManager{
                breakers: make(map[string]*CircuitBreaker),
                logger:   logger,
        }
}</span>

// GetOrCreate gets an existing circuit breaker or creates a new one
func (m *CircuitBreakerManager) GetOrCreate(name string, config CircuitBreakerConfig) *CircuitBreaker <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if breaker, exists := m.breakers[name]; exists </span><span class="cov0" title="0">{
                return breaker
        }</span>

        <span class="cov0" title="0">config.Name = name
        if config.Logger == nil </span><span class="cov0" title="0">{
                config.Logger = m.logger
        }</span>

        <span class="cov0" title="0">breaker := NewCircuitBreaker(config)
        m.breakers[name] = breaker

        m.logger.Info("Created new circuit breaker", zap.String("name", name))
        return breaker</span>
}

// Get retrieves a circuit breaker by name
func (m *CircuitBreakerManager) Get(name string) *CircuitBreaker <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        return m.breakers[name]
}</span>

// GetAll returns all circuit breakers
func (m *CircuitBreakerManager) GetAll() map[string]*CircuitBreaker <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        result := make(map[string]*CircuitBreaker)
        for name, breaker := range m.breakers </span><span class="cov0" title="0">{
                result[name] = breaker
        }</span>
        <span class="cov0" title="0">return result</span>
}

// GetStats returns statistics for all circuit breakers
func (m *CircuitBreakerManager) GetStats() map[string]interface{} <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        stats := make(map[string]interface{})
        for name, breaker := range m.breakers </span><span class="cov0" title="0">{
                stats[name] = breaker.GetStats()
        }</span>
        <span class="cov0" title="0">return stats</span>
}

// Reset resets all circuit breakers
func (m *CircuitBreakerManager) Reset() <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        for _, breaker := range m.breakers </span><span class="cov0" title="0">{
                breaker.Reset()
        }</span>

        <span class="cov0" title="0">m.logger.Info("All circuit breakers reset")</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package recovery

import (
        "context"
        "math"
        "math/rand"
        "sync"
        "time"

        "go.uber.org/zap"
)

// RetryConfig contains configuration for retry logic
type RetryConfig struct {
        MaxAttempts   int
        InitialDelay  time.Duration
        MaxDelay      time.Duration
        BackoffFactor float64
        Jitter        bool
        Logger        *zap.Logger
}

// DefaultRetryConfig returns a default retry configuration
func DefaultRetryConfig() RetryConfig <span class="cov0" title="0">{
        return RetryConfig{
                MaxAttempts:   3,
                InitialDelay:  1 * time.Second,
                MaxDelay:      30 * time.Second,
                BackoffFactor: 2.0,
                Jitter:        true,
        }
}</span>

// RetryableError represents an error that can be retried
type RetryableError struct {
        Err       error
        Retryable bool
}

func (e RetryableError) Error() string <span class="cov0" title="0">{
        return e.Err.Error()
}</span>

// IsRetryable returns true if the error is retryable
func (e RetryableError) IsRetryable() bool <span class="cov0" title="0">{
        return e.Retryable
}</span>

// NewRetryableError creates a new retryable error
func NewRetryableError(err error, retryable bool) RetryableError <span class="cov0" title="0">{
        return RetryableError{
                Err:       err,
                Retryable: retryable,
        }
}</span>

// RetryFunc is a function that can be retried
type RetryFunc func() error

// RetryWithCallback is a function that can be retried with callbacks
type RetryWithCallback func(attempt int) error

// Retry executes a function with retry logic
func Retry(ctx context.Context, config RetryConfig, fn RetryFunc) error <span class="cov0" title="0">{
        return RetryWithCallbacks(ctx, config, func(attempt int) error </span><span class="cov0" title="0">{
                return fn()
        }</span>, nil, nil)
}

// RetryWithCallbacks executes a function with retry logic and callbacks
func RetryWithCallbacks(
        ctx context.Context,
        config RetryConfig,
        fn RetryWithCallback,
        onRetry func(attempt int, err error, delay time.Duration),
        onFinalError func(attempt int, err error),
) error <span class="cov0" title="0">{
        var lastErr error

        for attempt := 0; attempt &lt; config.MaxAttempts; attempt++ </span><span class="cov0" title="0">{
                if config.Logger != nil </span><span class="cov0" title="0">{
                        config.Logger.Debug("Retry attempt",
                                zap.Int("attempt", attempt+1),
                                zap.Int("max_attempts", config.MaxAttempts))
                }</span>

                <span class="cov0" title="0">err := fn(attempt)
                if err == nil </span><span class="cov0" title="0">{
                        if config.Logger != nil &amp;&amp; attempt &gt; 0 </span><span class="cov0" title="0">{
                                config.Logger.Info("Operation succeeded after retry",
                                        zap.Int("attempts", attempt+1))
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">lastErr = err

                // Check if the error is retryable
                if retryableErr, ok := err.(RetryableError); ok &amp;&amp; !retryableErr.IsRetryable() </span><span class="cov0" title="0">{
                        if config.Logger != nil </span><span class="cov0" title="0">{
                                config.Logger.Debug("Error is not retryable", zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                // Don't wait after the last attempt
                <span class="cov0" title="0">if attempt == config.MaxAttempts-1 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Calculate delay
                <span class="cov0" title="0">delay := calculateDelay(config, attempt)

                if onRetry != nil </span><span class="cov0" title="0">{
                        onRetry(attempt+1, err, delay)
                }</span>

                <span class="cov0" title="0">if config.Logger != nil </span><span class="cov0" title="0">{
                        config.Logger.Warn("Operation failed, retrying",
                                zap.Error(err),
                                zap.Int("attempt", attempt+1),
                                zap.Duration("delay", delay))
                }</span>

                // Wait for the delay or context cancellation
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                        // Continue to next attempt
                }
        }

        <span class="cov0" title="0">if onFinalError != nil </span><span class="cov0" title="0">{
                onFinalError(config.MaxAttempts, lastErr)
        }</span>

        <span class="cov0" title="0">if config.Logger != nil </span><span class="cov0" title="0">{
                config.Logger.Error("All retry attempts failed",
                        zap.Int("attempts", config.MaxAttempts),
                        zap.Error(lastErr))
        }</span>

        <span class="cov0" title="0">return lastErr</span>
}

// calculateDelay calculates the delay for the next retry attempt
func calculateDelay(config RetryConfig, attempt int) time.Duration <span class="cov0" title="0">{
        delay := float64(config.InitialDelay) * math.Pow(config.BackoffFactor, float64(attempt))

        // Apply maximum delay limit
        if delay &gt; float64(config.MaxDelay) </span><span class="cov0" title="0">{
                delay = float64(config.MaxDelay)
        }</span>

        // Apply jitter if enabled
        <span class="cov0" title="0">if config.Jitter </span><span class="cov0" title="0">{
                jitter := rand.Float64() * 0.1 * delay // 10% jitter
                delay += jitter
        }</span>

        <span class="cov0" title="0">return time.Duration(delay)</span>
}

// ExponentialBackoff implements exponential backoff retry strategy
type ExponentialBackoff struct {
        config RetryConfig
        logger *zap.Logger
}

// NewExponentialBackoff creates a new exponential backoff strategy
func NewExponentialBackoff(config RetryConfig) *ExponentialBackoff <span class="cov0" title="0">{
        if config.MaxAttempts &lt;= 0 </span><span class="cov0" title="0">{
                config.MaxAttempts = 3
        }</span>
        <span class="cov0" title="0">if config.InitialDelay &lt;= 0 </span><span class="cov0" title="0">{
                config.InitialDelay = 1 * time.Second
        }</span>
        <span class="cov0" title="0">if config.MaxDelay &lt;= 0 </span><span class="cov0" title="0">{
                config.MaxDelay = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if config.BackoffFactor &lt;= 0 </span><span class="cov0" title="0">{
                config.BackoffFactor = 2.0
        }</span>

        <span class="cov0" title="0">return &amp;ExponentialBackoff{
                config: config,
                logger: config.Logger,
        }</span>
}

// Execute executes a function with exponential backoff
func (eb *ExponentialBackoff) Execute(ctx context.Context, fn RetryFunc) error <span class="cov0" title="0">{
        return Retry(ctx, eb.config, fn)
}</span>

// ExecuteWithCallbacks executes a function with exponential backoff and callbacks
func (eb *ExponentialBackoff) ExecuteWithCallbacks(
        ctx context.Context,
        fn RetryWithCallback,
        onRetry func(attempt int, err error, delay time.Duration),
        onFinalError func(attempt int, err error),
) error <span class="cov0" title="0">{
        return RetryWithCallbacks(ctx, eb.config, fn, onRetry, onFinalError)
}</span>

// BulkheadConfig contains configuration for bulkhead pattern
type BulkheadConfig struct {
        MaxConcurrent int
        QueueSize     int
        Timeout       time.Duration
        Logger        *zap.Logger
}

// Bulkhead implements the bulkhead pattern for resource isolation
type Bulkhead struct {
        semaphore chan struct{}
        queue     chan func()
        config    BulkheadConfig
        logger    *zap.Logger
}

// NewBulkhead creates a new bulkhead
func NewBulkhead(config BulkheadConfig) *Bulkhead <span class="cov0" title="0">{
        if config.MaxConcurrent &lt;= 0 </span><span class="cov0" title="0">{
                config.MaxConcurrent = 10
        }</span>
        <span class="cov0" title="0">if config.QueueSize &lt;= 0 </span><span class="cov0" title="0">{
                config.QueueSize = 100
        }</span>
        <span class="cov0" title="0">if config.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                config.Timeout = 30 * time.Second
        }</span>

        <span class="cov0" title="0">bulkhead := &amp;Bulkhead{
                semaphore: make(chan struct{}, config.MaxConcurrent),
                queue:     make(chan func(), config.QueueSize),
                config:    config,
                logger:    config.Logger,
        }

        // Pre-fill semaphore
        for i := 0; i &lt; config.MaxConcurrent; i++ </span><span class="cov0" title="0">{
                bulkhead.semaphore &lt;- struct{}{}
        }</span>

        <span class="cov0" title="0">return bulkhead</span>
}

// Execute executes a function with bulkhead protection
func (b *Bulkhead) Execute(ctx context.Context, fn func() error) error <span class="cov0" title="0">{
        // Try to acquire a permit
        select </span>{
        case &lt;-b.semaphore:<span class="cov0" title="0">
                defer func() </span><span class="cov0" title="0">{
                        b.semaphore &lt;- struct{}{} // Return permit
                }</span>()
                <span class="cov0" title="0">return fn()</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case &lt;-time.After(b.config.Timeout):<span class="cov0" title="0">
                if b.logger != nil </span><span class="cov0" title="0">{
                        b.logger.Warn("Bulkhead timeout", zap.Duration("timeout", b.config.Timeout))
                }</span>
                <span class="cov0" title="0">return NewRetryableError(context.DeadlineExceeded, true)</span>
        }
}

// GetStats returns bulkhead statistics
func (b *Bulkhead) GetStats() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "max_concurrent":    b.config.MaxConcurrent,
                "available_permits": len(b.semaphore),
                "queue_size":        b.config.QueueSize,
                "queue_length":      len(b.queue),
                "timeout":           b.config.Timeout,
        }
}</span>

// HealthChecker provides health checking capabilities
type HealthChecker struct {
        checks   map[string]HealthCheck
        mutex    sync.RWMutex
        logger   *zap.Logger
        interval time.Duration
        timeout  time.Duration
}

// HealthCheck represents a health check function
type HealthCheck struct {
        Name     string
        Check    func(ctx context.Context) error
        Interval time.Duration
        Timeout  time.Duration
        Critical bool
}

// HealthStatus represents the health status
type HealthStatus struct {
        Healthy bool                   `json:"healthy"`
        Checks  map[string]CheckResult `json:"checks"`
}

// CheckResult represents the result of a health check
type CheckResult struct {
        Healthy   bool      `json:"healthy"`
        Error     string    `json:"error,omitempty"`
        Duration  int64     `json:"duration_ms"`
        Timestamp time.Time `json:"timestamp"`
        Critical  bool      `json:"critical"`
}

// NewHealthChecker creates a new health checker
func NewHealthChecker(interval, timeout time.Duration, logger *zap.Logger) *HealthChecker <span class="cov0" title="0">{
        return &amp;HealthChecker{
                checks:   make(map[string]HealthCheck),
                logger:   logger,
                interval: interval,
                timeout:  timeout,
        }
}</span>

// AddCheck adds a health check
func (hc *HealthChecker) AddCheck(check HealthCheck) <span class="cov0" title="0">{
        hc.mutex.Lock()
        defer hc.mutex.Unlock()

        if check.Timeout == 0 </span><span class="cov0" title="0">{
                check.Timeout = hc.timeout
        }</span>

        <span class="cov0" title="0">hc.checks[check.Name] = check

        if hc.logger != nil </span><span class="cov0" title="0">{
                hc.logger.Info("Health check added",
                        zap.String("name", check.Name),
                        zap.Bool("critical", check.Critical))
        }</span>
}

// RemoveCheck removes a health check
func (hc *HealthChecker) RemoveCheck(name string) <span class="cov0" title="0">{
        hc.mutex.Lock()
        defer hc.mutex.Unlock()

        delete(hc.checks, name)

        if hc.logger != nil </span><span class="cov0" title="0">{
                hc.logger.Info("Health check removed", zap.String("name", name))
        }</span>
}

// CheckHealth performs all health checks
func (hc *HealthChecker) CheckHealth(ctx context.Context) HealthStatus <span class="cov0" title="0">{
        hc.mutex.RLock()
        checks := make(map[string]HealthCheck)
        for name, check := range hc.checks </span><span class="cov0" title="0">{
                checks[name] = check
        }</span>
        <span class="cov0" title="0">hc.mutex.RUnlock()

        results := make(map[string]CheckResult)
        overall := true

        for name, check := range checks </span><span class="cov0" title="0">{
                result := hc.runCheck(ctx, check)
                results[name] = result

                if !result.Healthy &amp;&amp; check.Critical </span><span class="cov0" title="0">{
                        overall = false
                }</span>
        }

        <span class="cov0" title="0">return HealthStatus{
                Healthy: overall,
                Checks:  results,
        }</span>
}

// runCheck runs a single health check
func (hc *HealthChecker) runCheck(ctx context.Context, check HealthCheck) CheckResult <span class="cov0" title="0">{
        start := time.Now()

        checkCtx, cancel := context.WithTimeout(ctx, check.Timeout)
        defer cancel()

        err := check.Check(checkCtx)
        duration := time.Since(start)

        result := CheckResult{
                Healthy:   err == nil,
                Duration:  duration.Milliseconds(),
                Timestamp: time.Now(),
                Critical:  check.Critical,
        }

        if err != nil </span><span class="cov0" title="0">{
                result.Error = err.Error()
        }</span>

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "regexp"
        "strconv"
        "strings"
        "time"

        "catalogizer/internal/models"

        "go.uber.org/zap"
)

// Book and publication recognition provider with OCR and metadata APIs
type BookRecognitionProvider struct {
        logger      *zap.Logger
        httpClient  *http.Client
        baseURLs    map[string]string
        apiKeys     map[string]string
        rateLimiter map[string]*time.Ticker
}

// Google Books API structures
type GoogleBooksResponse struct {
        Kind       string           `json:"kind"`
        TotalItems int              `json:"totalItems"`
        Items      []GoogleBookItem `json:"items"`
}

type GoogleBookItem struct {
        Kind       string               `json:"kind"`
        ID         string               `json:"id"`
        ETag       string               `json:"etag"`
        SelfLink   string               `json:"selfLink"`
        VolumeInfo GoogleBookVolumeInfo `json:"volumeInfo"`
        SaleInfo   GoogleBookSaleInfo   `json:"saleInfo"`
        AccessInfo GoogleBookAccessInfo `json:"accessInfo"`
        SearchInfo GoogleBookSearchInfo `json:"searchInfo,omitempty"`
}

type GoogleBookVolumeInfo struct {
        Title               string                 `json:"title"`
        Subtitle            string                 `json:"subtitle,omitempty"`
        Authors             []string               `json:"authors,omitempty"`
        Publisher           string                 `json:"publisher,omitempty"`
        PublishedDate       string                 `json:"publishedDate,omitempty"`
        Description         string                 `json:"description,omitempty"`
        IndustryIdentifiers []GoogleBookIdentifier `json:"industryIdentifiers,omitempty"`
        ReadingModes        GoogleBookReadingModes `json:"readingModes"`
        PageCount           int                    `json:"pageCount,omitempty"`
        PrintType           string                 `json:"printType"`
        Categories          []string               `json:"categories,omitempty"`
        AverageRating       float64                `json:"averageRating,omitempty"`
        RatingsCount        int                    `json:"ratingsCount,omitempty"`
        MaturityRating      string                 `json:"maturityRating"`
        AllowAnonLogging    bool                   `json:"allowAnonLogging"`
        ContentVersion      string                 `json:"contentVersion"`
        PanelizationSummary GoogleBookPanelization `json:"panelizationSummary,omitempty"`
        ImageLinks          GoogleBookImageLinks   `json:"imageLinks,omitempty"`
        Language            string                 `json:"language"`
        PreviewLink         string                 `json:"previewLink"`
        InfoLink            string                 `json:"infoLink"`
        CanonicalVolumeLink string                 `json:"canonicalVolumeLink"`
        SeriesInfo          GoogleBookSeriesInfo   `json:"seriesInfo,omitempty"`
}

type GoogleBookIdentifier struct {
        Type       string `json:"type"`
        Identifier string `json:"identifier"`
}

type GoogleBookReadingModes struct {
        Text  bool `json:"text"`
        Image bool `json:"image"`
}

type GoogleBookPanelization struct {
        ContainsEpubBubbles  bool `json:"containsEpubBubbles"`
        ContainsImageBubbles bool `json:"containsImageBubbles"`
}

type GoogleBookImageLinks struct {
        SmallThumbnail string `json:"smallThumbnail,omitempty"`
        Thumbnail      string `json:"thumbnail,omitempty"`
        Small          string `json:"small,omitempty"`
        Medium         string `json:"medium,omitempty"`
        Large          string `json:"large,omitempty"`
        ExtraLarge     string `json:"extraLarge,omitempty"`
}

type GoogleBookSaleInfo struct {
        Country     string            `json:"country"`
        Saleability string            `json:"saleability"`
        IsEbook     bool              `json:"isEbook"`
        ListPrice   GoogleBookPrice   `json:"listPrice,omitempty"`
        RetailPrice GoogleBookPrice   `json:"retailPrice,omitempty"`
        BuyLink     string            `json:"buyLink,omitempty"`
        Offers      []GoogleBookOffer `json:"offers,omitempty"`
}

type GoogleBookPrice struct {
        Amount       float64 `json:"amount"`
        CurrencyCode string  `json:"currencyCode"`
}

type GoogleBookOffer struct {
        FinskyOfferType int             `json:"finskyOfferType"`
        ListPrice       GoogleBookPrice `json:"listPrice"`
        RetailPrice     GoogleBookPrice `json:"retailPrice"`
        GiftablePrice   GoogleBookPrice `json:"giftablePrice,omitempty"`
}

type GoogleBookAccessInfo struct {
        Country                string                       `json:"country"`
        Viewability            string                       `json:"viewability"`
        Embeddable             bool                         `json:"embeddable"`
        PublicDomain           bool                         `json:"publicDomain"`
        TextToSpeechPermission string                       `json:"textToSpeechPermission"`
        Epub                   GoogleBookFormatAvailability `json:"epub"`
        PDF                    GoogleBookFormatAvailability `json:"pdf"`
        WebReaderLink          string                       `json:"webReaderLink,omitempty"`
        AccessViewStatus       string                       `json:"accessViewStatus"`
        QuoteSharingAllowed    bool                         `json:"quoteSharingAllowed"`
}

type GoogleBookFormatAvailability struct {
        IsAvailable  bool   `json:"isAvailable"`
        AcsTokenLink string `json:"acsTokenLink,omitempty"`
}

type GoogleBookSearchInfo struct {
        TextSnippet string `json:"textSnippet"`
}

type GoogleBookSeriesInfo struct {
        Kind                 string `json:"kind"`
        BookDisplayNumber    string `json:"bookDisplayNumber"`
        VolumeDisplayNumber  string `json:"volumeDisplayNumber"`
        ShortSeriesBookTitle string `json:"shortSeriesBookTitle"`
}

// Open Library API structures
type OpenLibrarySearchResponse struct {
        NumFound      int                   `json:"numFound"`
        Start         int                   `json:"start"`
        NumFoundExact bool                  `json:"numFoundExact"`
        Docs          []OpenLibraryDocument `json:"docs"`
}

type OpenLibraryDocument struct {
        Key                   string    `json:"key"`
        Type                  string    `json:"type"`
        Seed                  []string  `json:"seed,omitempty"`
        Title                 string    `json:"title"`
        TitleSuggest          string    `json:"title_suggest,omitempty"`
        TitleSort             string    `json:"title_sort,omitempty"`
        Subtitle              string    `json:"subtitle,omitempty"`
        AlternativeTitle      []string  `json:"alternative_title,omitempty"`
        AlternativeSubtitle   []string  `json:"alternative_subtitle,omitempty"`
        Edition               []string  `json:"edition_name,omitempty"`
        FullTitle             string    `json:"full_title,omitempty"`
        AuthorKey             []string  `json:"author_key,omitempty"`
        AuthorName            []string  `json:"author_name,omitempty"`
        AuthorAlternativeName []string  `json:"author_alternative_name,omitempty"`
        AuthorFacet           []string  `json:"author_facet,omitempty"`
        ContributorName       []string  `json:"contributor,omitempty"`
        Subject               []string  `json:"subject,omitempty"`
        SubjectKey            []string  `json:"subject_key,omitempty"`
        SubjectFacet          []string  `json:"subject_facet,omitempty"`
        Place                 []string  `json:"place,omitempty"`
        PlaceKey              []string  `json:"place_key,omitempty"`
        PlaceFacet            []string  `json:"place_facet,omitempty"`
        Person                []string  `json:"person,omitempty"`
        PersonKey             []string  `json:"person_key,omitempty"`
        PersonFacet           []string  `json:"person_facet,omitempty"`
        Language              []string  `json:"language,omitempty"`
        PublisherName         []string  `json:"publisher,omitempty"`
        PublisherFacet        []string  `json:"publisher_facet,omitempty"`
        PublishDate           []string  `json:"publish_date,omitempty"`
        PublishYear           []int     `json:"publish_year,omitempty"`
        PublishPlace          []string  `json:"publish_place,omitempty"`
        FirstPublishYear      int       `json:"first_publish_year,omitempty"`
        NumberOfPagesMedian   int       `json:"number_of_pages_median,omitempty"`
        LccnSort              string    `json:"lccn_sort,omitempty"`
        EditionCount          int       `json:"edition_count"`
        EditionKey            []string  `json:"edition_key,omitempty"`
        PrintDisabled         []string  `json:"printdisabled,omitempty"`
        LendingEdition        string    `json:"lending_edition,omitempty"`
        LendingIdentifier     string    `json:"lending_identifier,omitempty"`
        ISBN                  []string  `json:"isbn,omitempty"`
        LastModified          time.Time `json:"last_modified_i"`
        EbookCount            int       `json:"ebook_count_i"`
        EbookAccess           string    `json:"ebook_access,omitempty"`
        HasFulltext           bool      `json:"has_fulltext"`
        PublicScan            bool      `json:"public_scan_b,omitempty"`
        CoverID               int       `json:"cover_i,omitempty"`
        CoverEditionKey       string    `json:"cover_edition_key,omitempty"`
        FirstSentence         []string  `json:"first_sentence,omitempty"`
        LCCN                  []string  `json:"lccn,omitempty"`
        OCLC                  []string  `json:"oclc,omitempty"`
        ContributorKey        []string  `json:"contributor_key,omitempty"`
        ID_Amazon             []string  `json:"id_amazon,omitempty"`
        ID_LibraryThing       []string  `json:"id_librarything,omitempty"`
        ID_Goodreads          []string  `json:"id_goodreads,omitempty"`
        ID_DepositoLegal      []string  `json:"id_dnb,omitempty"`
        ID_Wikisource         []string  `json:"id_wikisource,omitempty"`
}

// Crossref API structures (for academic publications)
type CrossrefResponse struct {
        Status  string          `json:"status"`
        Message CrossrefMessage `json:"message"`
}

type CrossrefMessage struct {
        Facets       map[string]interface{} `json:"facets,omitempty"`
        TotalResults int                    `json:"total-results"`
        Items        []CrossrefWork         `json:"items"`
        ItemsPerPage int                    `json:"items-per-page"`
        Query        map[string]interface{} `json:"query,omitempty"`
}

type CrossrefWork struct {
        Indexed             CrossrefDate           `json:"indexed"`
        ReferenceCount      int                    `json:"reference-count"`
        Publisher           string                 `json:"publisher"`
        Issue               string                 `json:"issue,omitempty"`
        License             []CrossrefLicense      `json:"license,omitempty"`
        Funder              []CrossrefFunder       `json:"funder,omitempty"`
        ContentDomain       CrossrefContentDomain  `json:"content-domain"`
        ShortContainerTitle []string               `json:"short-container-title,omitempty"`
        Published           CrossrefPartialDate    `json:"published,omitempty"`
        Abstract            string                 `json:"abstract,omitempty"`
        DOI                 string                 `json:"DOI"`
        Type                string                 `json:"type"`
        Created             CrossrefDate           `json:"created"`
        Page                string                 `json:"page,omitempty"`
        UpdatePolicy        string                 `json:"update-policy,omitempty"`
        Source              string                 `json:"source"`
        IsReferencedByCount int                    `json:"is-referenced-by-count"`
        Title               []string               `json:"title"`
        Prefix              string                 `json:"prefix"`
        Volume              string                 `json:"volume,omitempty"`
        Author              []CrossrefAuthor       `json:"author,omitempty"`
        Member              string                 `json:"member"`
        ContainerTitle      []string               `json:"container-title,omitempty"`
        OriginalTitle       []string               `json:"original-title,omitempty"`
        Language            string                 `json:"language,omitempty"`
        Link                []CrossrefLink         `json:"link,omitempty"`
        Deposited           CrossrefDate           `json:"deposited"`
        Score               float64                `json:"score"`
        Subtitle            []string               `json:"subtitle,omitempty"`
        ShortTitle          []string               `json:"short-title,omitempty"`
        Issued              CrossrefPartialDate    `json:"issued,omitempty"`
        ReferencesCount     int                    `json:"references-count"`
        JournalIssue        CrossrefJournalIssue   `json:"journal-issue,omitempty"`
        AlternativeID       []string               `json:"alternative-id,omitempty"`
        URL                 string                 `json:"URL,omitempty"`
        Relation            map[string]interface{} `json:"relation,omitempty"`
        ISSN                []string               `json:"ISSN,omitempty"`
        IssnType            []CrossrefIssnType     `json:"issn-type,omitempty"`
        Subject             []string               `json:"subject,omitempty"`
        PublishedOnline     CrossrefPartialDate    `json:"published-online,omitempty"`
        PublishedPrint      CrossrefPartialDate    `json:"published-print,omitempty"`
}

type CrossrefDate struct {
        DateParts [][]int   `json:"date-parts"`
        DateTime  time.Time `json:"date-time"`
        Timestamp int64     `json:"timestamp"`
}

type CrossrefPartialDate struct {
        DateParts [][]int `json:"date-parts"`
}

type CrossrefLicense struct {
        Start          CrossrefDate `json:"start"`
        ContentVersion string       `json:"content-version"`
        DelayInDays    int          `json:"delay-in-days"`
        URL            string       `json:"URL"`
}

type CrossrefFunder struct {
        DOI   string   `json:"DOI,omitempty"`
        Name  string   `json:"name"`
        Award []string `json:"award,omitempty"`
}

type CrossrefContentDomain struct {
        Domain               []string `json:"domain"`
        CrossmarkRestriction bool     `json:"crossmark-restriction"`
}

type CrossrefAuthor struct {
        ORCID       string                `json:"ORCID,omitempty"`
        Given       string                `json:"given,omitempty"`
        Family      string                `json:"family,omitempty"`
        Sequence    string                `json:"sequence"`
        Affiliation []CrossrefAffiliation `json:"affiliation,omitempty"`
}

type CrossrefAffiliation struct {
        Name string `json:"name"`
}

type CrossrefLink struct {
        URL                 string `json:"URL"`
        ContentType         string `json:"content-type"`
        ContentVersion      string `json:"content-version"`
        IntendedApplication string `json:"intended-application"`
}

type CrossrefJournalIssue struct {
        Issue           string              `json:"issue,omitempty"`
        PublishedOnline CrossrefPartialDate `json:"published-online,omitempty"`
        PublishedPrint  CrossrefPartialDate `json:"published-print,omitempty"`
}

type CrossrefIssnType struct {
        Value string `json:"value"`
        Type  string `json:"type"`
}

// OCR Service structures
type OCRRequest struct {
        ImageData []byte            `json:"image_data"`
        ImageURL  string            `json:"image_url,omitempty"`
        Language  string            `json:"language,omitempty"`
        Options   map[string]string `json:"options,omitempty"`
}

type OCRResponse struct {
        Text       string            `json:"text"`
        Confidence float64           `json:"confidence"`
        Language   string            `json:"language"`
        Blocks     []OCRTextBlock    `json:"blocks"`
        Words      []OCRWord         `json:"words"`
        Lines      []OCRLine         `json:"lines"`
        Metadata   map[string]string `json:"metadata"`
}

type OCRTextBlock struct {
        Text        string         `json:"text"`
        Confidence  float64        `json:"confidence"`
        BoundingBox OCRBoundingBox `json:"bounding_box"`
        Lines       []OCRLine      `json:"lines"`
}

type OCRLine struct {
        Text        string         `json:"text"`
        Confidence  float64        `json:"confidence"`
        BoundingBox OCRBoundingBox `json:"bounding_box"`
        Words       []OCRWord      `json:"words"`
}

type OCRWord struct {
        Text        string         `json:"text"`
        Confidence  float64        `json:"confidence"`
        BoundingBox OCRBoundingBox `json:"bounding_box"`
}

type OCRBoundingBox struct {
        X      int `json:"x"`
        Y      int `json:"y"`
        Width  int `json:"width"`
        Height int `json:"height"`
}

// Text analysis for book content
type BookContentAnalysis struct {
        Language         string        `json:"language"`
        WordCount        int           `json:"word_count"`
        CharacterCount   int           `json:"character_count"`
        ParagraphCount   int           `json:"paragraph_count"`
        SentenceCount    int           `json:"sentence_count"`
        ReadabilityScore float64       `json:"readability_score"`
        Topics           []string      `json:"topics"`
        Keywords         []string      `json:"keywords"`
        Entities         []NamedEntity `json:"entities"`
        Metadata         BookMetadata  `json:"metadata"`
}

type NamedEntity struct {
        Text       string  `json:"text"`
        Label      string  `json:"label"`
        Confidence float64 `json:"confidence"`
        StartPos   int     `json:"start_pos"`
        EndPos     int     `json:"end_pos"`
}

type BookMetadata struct {
        Title           string              `json:"title"`
        Author          string              `json:"author"`
        Publisher       string              `json:"publisher"`
        PublicationDate string              `json:"publication_date"`
        ISBN            string              `json:"isbn"`
        Edition         string              `json:"edition"`
        ChapterTitles   []string            `json:"chapter_titles"`
        TableOfContents []TOCEntry          `json:"table_of_contents"`
        Bibliography    []BibliographyEntry `json:"bibliography"`
        Index           []IndexEntry        `json:"index"`
}

type TOCEntry struct {
        Title      string     `json:"title"`
        PageNumber int        `json:"page_number"`
        Level      int        `json:"level"`
        Children   []TOCEntry `json:"children,omitempty"`
}

type BibliographyEntry struct {
        Citation string   `json:"citation"`
        Type     string   `json:"type"`
        Authors  []string `json:"authors"`
        Title    string   `json:"title"`
        Year     int      `json:"year"`
}

type IndexEntry struct {
        Term       string       `json:"term"`
        Pages      []int        `json:"pages"`
        SubEntries []IndexEntry `json:"sub_entries,omitempty"`
}

func NewBookRecognitionProvider(logger *zap.Logger) *BookRecognitionProvider <span class="cov0" title="0">{
        return &amp;BookRecognitionProvider{
                logger:     logger,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                baseURLs: map[string]string{
                        "google_books":  "https://www.googleapis.com/books/v1",
                        "open_library":  "https://openlibrary.org",
                        "crossref":      "https://api.crossref.org",
                        "worldcat":      "https://www.worldcat.org/webservices",
                        "libgen":        "https://libgen.is/json.php",
                        "archive_org":   "https://archive.org",
                        "tesseract":     "https://api.ocr.space/parse",
                        "google_vision": "https://vision.googleapis.com/v1",
                },
                apiKeys: map[string]string{
                        "google_books":  "free_api_key",
                        "google_vision": "free_api_key",
                        "ocr_space":     "free_api_key",
                },
                rateLimiter: make(map[string]*time.Ticker),
        }
}</span>

func (p *BookRecognitionProvider) RecognizeMedia(ctx context.Context, req *MediaRecognitionRequest) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        p.logger.Info("Starting book/publication recognition",
                zap.String("file_path", req.FilePath),
                zap.String("media_type", string(req.MediaType)))

        // Extract metadata from filename
        title, author, isbn := p.extractBookMetadataFromFilename(req.FileName)

        p.logger.Debug("Extracted metadata from filename",
                zap.String("title", title),
                zap.String("author", author),
                zap.String("isbn", isbn))

        // Try OCR if image sample provided
        if len(req.ImageSample) &gt; 0 </span><span class="cov0" title="0">{
                if ocrResult, err := p.performOCR(ctx, req.ImageSample); err == nil </span><span class="cov0" title="0">{
                        if bookInfo := p.extractBookInfoFromOCR(ocrResult); bookInfo != nil </span><span class="cov0" title="0">{
                                title = bookInfo.Title
                                author = bookInfo.Author
                                isbn = bookInfo.ISBN
                        }</span>
                }
        }

        // Try text analysis if text sample provided
        <span class="cov0" title="0">if req.TextSample != "" </span><span class="cov0" title="0">{
                if analysis, err := p.analyzeBookContent(ctx, req.TextSample); err == nil </span><span class="cov0" title="0">{
                        if analysis.Metadata.Title != "" </span><span class="cov0" title="0">{
                                title = analysis.Metadata.Title
                        }</span>
                        <span class="cov0" title="0">if analysis.Metadata.Author != "" </span><span class="cov0" title="0">{
                                author = analysis.Metadata.Author
                        }</span>
                        <span class="cov0" title="0">if analysis.Metadata.ISBN != "" </span><span class="cov0" title="0">{
                                isbn = analysis.Metadata.ISBN
                        }</span>
                }
        }

        // Try different recognition methods based on available metadata
        <span class="cov0" title="0">if isbn != "" </span><span class="cov0" title="0">{
                if result, err := p.recognizeByISBN(ctx, isbn); err == nil </span><span class="cov0" title="0">{
                        p.logger.Info("Successfully recognized by ISBN",
                                zap.String("title", result.Title),
                                zap.Float64("confidence", result.Confidence))
                        return result, nil
                }</span>
        }

        <span class="cov0" title="0">if title != "" || author != "" </span><span class="cov0" title="0">{
                if result, err := p.recognizeByMetadata(ctx, title, author); err == nil </span><span class="cov0" title="0">{
                        p.logger.Info("Successfully recognized by metadata",
                                zap.String("title", result.Title),
                                zap.Float64("confidence", result.Confidence))
                        return result, nil
                }</span>
        }

        // Determine publication type
        <span class="cov0" title="0">mediaType := p.determinePublicationType(title, req.FileName, req.MimeType)

        // Fallback to basic recognition
        return p.basicBookRecognition(req, title, author, isbn, mediaType), nil</span>
}

func (p *BookRecognitionProvider) performOCR(ctx context.Context, imageData []byte) (*OCRResponse, error) <span class="cov0" title="0">{
        // Try OCR.space API first (free tier)
        if result, err := p.performOCRSpace(ctx, imageData); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try Tesseract via local processing
        <span class="cov0" title="0">if result, err := p.performTesseract(ctx, imageData); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("OCR processing failed")</span>
}

func (p *BookRecognitionProvider) performOCRSpace(ctx context.Context, imageData []byte) (*OCRResponse, error) <span class="cov0" title="0">{
        // OCR.space API implementation
        // This would encode the image and send it to OCR.space

        // Mock OCR result for demonstration
        return &amp;OCRResponse{
                Text:       "Sample OCR text from book cover or page",
                Confidence: 0.85,
                Language:   "en",
                Blocks: []OCRTextBlock{
                        {
                                Text:        "Book Title",
                                Confidence:  0.9,
                                BoundingBox: OCRBoundingBox{X: 50, Y: 100, Width: 200, Height: 30},
                        },
                        {
                                Text:        "Author Name",
                                Confidence:  0.8,
                                BoundingBox: OCRBoundingBox{X: 50, Y: 150, Width: 150, Height: 25},
                        },
                },
        }, nil
}</span>

func (p *BookRecognitionProvider) performTesseract(ctx context.Context, imageData []byte) (*OCRResponse, error) <span class="cov0" title="0">{
        // Local Tesseract processing would go here
        // For now, return a mock result
        return &amp;OCRResponse{
                Text:       "Tesseract OCR result",
                Confidence: 0.75,
                Language:   "en",
        }, nil
}</span>

func (p *BookRecognitionProvider) extractBookInfoFromOCR(ocrResult *OCRResponse) *BookMetadata <span class="cov0" title="0">{
        text := ocrResult.Text

        // Extract title (usually the largest/most prominent text)
        title := p.extractTitleFromOCR(text, ocrResult.Blocks)

        // Extract author (often appears below title)
        author := p.extractAuthorFromOCR(text, ocrResult.Blocks)

        // Extract ISBN (if visible)
        isbn := p.extractISBNFromText(text)

        if title == "" &amp;&amp; author == "" &amp;&amp; isbn == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;BookMetadata{
                Title:  title,
                Author: author,
                ISBN:   isbn,
        }</span>
}

func (p *BookRecognitionProvider) analyzeBookContent(ctx context.Context, text string) (*BookContentAnalysis, error) <span class="cov0" title="0">{
        analysis := &amp;BookContentAnalysis{
                Language:       p.detectLanguage(text),
                WordCount:      len(strings.Fields(text)),
                CharacterCount: len(text),
                ParagraphCount: len(strings.Split(text, "\n\n")),
                SentenceCount:  len(regexp.MustCompile(`[.!?]+`).FindAllString(text, -1)),
        }

        // Extract metadata from content
        analysis.Metadata = p.extractMetadataFromContent(text)

        // Extract topics and keywords
        analysis.Topics = p.extractTopics(text)
        analysis.Keywords = p.extractKeywords(text)

        // Calculate readability score
        analysis.ReadabilityScore = p.calculateReadabilityScore(text)

        return analysis, nil
}</span>

func (p *BookRecognitionProvider) recognizeByISBN(ctx context.Context, isbn string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Clean ISBN
        cleanISBN := p.cleanISBN(isbn)

        // Try Google Books API first
        if result, err := p.searchGoogleBooksByISBN(ctx, cleanISBN); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try Open Library as fallback
        <span class="cov0" title="0">if result, err := p.searchOpenLibraryByISBN(ctx, cleanISBN); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no results found for ISBN: %s", cleanISBN)</span>
}

func (p *BookRecognitionProvider) recognizeByMetadata(ctx context.Context, title, author string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Try Google Books API first
        if result, err := p.searchGoogleBooks(ctx, title, author); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try Open Library as fallback
        <span class="cov0" title="0">if result, err := p.searchOpenLibrary(ctx, title, author); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try Crossref for academic publications
        <span class="cov0" title="0">if result, err := p.searchCrossref(ctx, title, author); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no results found for title/author: %s / %s", title, author)</span>
}

func (p *BookRecognitionProvider) searchGoogleBooks(ctx context.Context, title, author string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}

        // Build search query
        query := ""
        if title != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf("intitle:%s", title)
        }</span>
        <span class="cov0" title="0">if author != "" </span><span class="cov0" title="0">{
                if query != "" </span><span class="cov0" title="0">{
                        query += "+"
                }</span>
                <span class="cov0" title="0">query += fmt.Sprintf("inauthor:%s", author)</span>
        }

        <span class="cov0" title="0">params.Set("q", query)
        params.Set("maxResults", "10")
        params.Set("printType", "books")
        params.Set("key", p.apiKeys["google_books"])

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/volumes?%s", p.baseURLs["google_books"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var booksResp GoogleBooksResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;booksResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(booksResp.Items) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no books found in Google Books")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := booksResp.Items[0]
        return p.convertGoogleBook(bestMatch), nil</span>
}

func (p *BookRecognitionProvider) searchGoogleBooksByISBN(ctx context.Context, isbn string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}
        params.Set("q", "isbn:"+isbn)
        params.Set("key", p.apiKeys["google_books"])

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/volumes?%s", p.baseURLs["google_books"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var booksResp GoogleBooksResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;booksResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(booksResp.Items) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no books found for ISBN in Google Books")
        }</span>

        <span class="cov0" title="0">return p.convertGoogleBook(booksResp.Items[0]), nil</span>
}

func (p *BookRecognitionProvider) convertGoogleBook(book GoogleBookItem) *MediaRecognitionResult <span class="cov0" title="0">{
        volumeInfo := book.VolumeInfo

        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("google_books_%s", book.ID),
                MediaType:         p.determineBookType(volumeInfo),
                Title:             volumeInfo.Title,
                Description:       volumeInfo.Description,
                PageCount:         volumeInfo.PageCount,
                Language:          volumeInfo.Language,
                Rating:            volumeInfo.AverageRating,
                Confidence:        p.calculateGoogleBooksConfidence(volumeInfo.AverageRating, volumeInfo.RatingsCount),
                RecognitionMethod: "google_books_api",
                APIProvider:       "Google Books",
        }

        // Set subtitle if available
        if volumeInfo.Subtitle != "" </span><span class="cov0" title="0">{
                result.Title = fmt.Sprintf("%s: %s", volumeInfo.Title, volumeInfo.Subtitle)
        }</span>

        // Set authors
        <span class="cov0" title="0">if len(volumeInfo.Authors) &gt; 0 </span><span class="cov0" title="0">{
                result.Author = volumeInfo.Authors[0]
                for _, author := range volumeInfo.Authors </span><span class="cov0" title="0">{
                        result.Authors = append(result.Authors, Person{
                                Name: author,
                                Role: "Author",
                        })
                }</span>
        }

        // Set publisher
        <span class="cov0" title="0">result.Publisher = volumeInfo.Publisher

        // Parse publication date
        if volumeInfo.PublishedDate != "" </span><span class="cov0" title="0">{
                result.Year = p.parseYear(volumeInfo.PublishedDate)
                if pubDate, err := p.parseDate(volumeInfo.PublishedDate); err == nil </span><span class="cov0" title="0">{
                        result.ReleaseDate = &amp;pubDate
                }</span>
        }

        // Extract ISBN
        <span class="cov0" title="0">for _, identifier := range volumeInfo.IndustryIdentifiers </span><span class="cov0" title="0">{
                if identifier.Type == "ISBN_13" </span><span class="cov0" title="0">{
                        result.ISBN13 = identifier.Identifier
                        result.ISBN = identifier.Identifier
                }</span> else<span class="cov0" title="0"> if identifier.Type == "ISBN_10" </span><span class="cov0" title="0">{
                        result.ISBN10 = identifier.Identifier
                        if result.ISBN == "" </span><span class="cov0" title="0">{
                                result.ISBN = identifier.Identifier
                        }</span>
                }
        }

        // Set categories as genres
        <span class="cov0" title="0">result.Genres = volumeInfo.Categories

        // Get cover images
        if volumeInfo.ImageLinks.Thumbnail != "" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        ID:      "google_books_thumbnail",
                        URL:     volumeInfo.ImageLinks.Thumbnail,
                        Quality: "medium",
                        Source:  "Google Books",
                })
        }</span>
        <span class="cov0" title="0">if volumeInfo.ImageLinks.SmallThumbnail != "" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        ID:      "google_books_small",
                        URL:     volumeInfo.ImageLinks.SmallThumbnail,
                        Quality: "small",
                        Source:  "Google Books",
                })
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "google_books_id": book.ID,
                "preview_link":    volumeInfo.PreviewLink,
                "info_link":       volumeInfo.InfoLink,
        }

        return result</span>
}

func (p *BookRecognitionProvider) searchOpenLibrary(ctx context.Context, title, author string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}

        // Build search query
        query := ""
        if title != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf("title:%s", title)
        }</span>
        <span class="cov0" title="0">if author != "" </span><span class="cov0" title="0">{
                if query != "" </span><span class="cov0" title="0">{
                        query += " AND "
                }</span>
                <span class="cov0" title="0">query += fmt.Sprintf("author:%s", author)</span>
        }

        <span class="cov0" title="0">params.Set("q", query)
        params.Set("limit", "10")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/search.json?%s", p.baseURLs["open_library"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResp OpenLibrarySearchResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResp.Docs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no books found in Open Library")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := searchResp.Docs[0]
        return p.convertOpenLibraryBook(bestMatch), nil</span>
}

func (p *BookRecognitionProvider) searchOpenLibraryByISBN(ctx context.Context, isbn string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}
        params.Set("q", "isbn:"+isbn)
        params.Set("limit", "1")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/search.json?%s", p.baseURLs["open_library"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResp OpenLibrarySearchResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResp.Docs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no books found for ISBN in Open Library")
        }</span>

        <span class="cov0" title="0">return p.convertOpenLibraryBook(searchResp.Docs[0]), nil</span>
}

func (p *BookRecognitionProvider) convertOpenLibraryBook(doc OpenLibraryDocument) *MediaRecognitionResult <span class="cov0" title="0">{
        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("open_library_%s", strings.TrimPrefix(doc.Key, "/works/")),
                MediaType:         MediaTypeBook,
                Title:             doc.Title,
                PageCount:         doc.NumberOfPagesMedian,
                Confidence:        p.calculateOpenLibraryConfidence(doc.EditionCount, doc.EbookCount),
                RecognitionMethod: "open_library_api",
                APIProvider:       "Open Library",
        }

        // Set subtitle
        if doc.Subtitle != "" </span><span class="cov0" title="0">{
                result.Title = fmt.Sprintf("%s: %s", doc.Title, doc.Subtitle)
        }</span>

        // Set authors
        <span class="cov0" title="0">if len(doc.AuthorName) &gt; 0 </span><span class="cov0" title="0">{
                result.Author = doc.AuthorName[0]
                for _, author := range doc.AuthorName </span><span class="cov0" title="0">{
                        result.Authors = append(result.Authors, Person{
                                Name: author,
                                Role: "Author",
                        })
                }</span>
        }

        // Set publisher
        <span class="cov0" title="0">if len(doc.PublisherName) &gt; 0 </span><span class="cov0" title="0">{
                result.Publisher = doc.PublisherName[0]
        }</span>

        // Set publication year
        <span class="cov0" title="0">if doc.FirstPublishYear &gt; 0 </span><span class="cov0" title="0">{
                result.Year = doc.FirstPublishYear
        }</span>

        // Set ISBN
        <span class="cov0" title="0">if len(doc.ISBN) &gt; 0 </span><span class="cov0" title="0">{
                result.ISBN = doc.ISBN[0]
                // Determine ISBN-10 vs ISBN-13
                for _, isbn := range doc.ISBN </span><span class="cov0" title="0">{
                        if len(isbn) == 10 </span><span class="cov0" title="0">{
                                result.ISBN10 = isbn
                        }</span> else<span class="cov0" title="0"> if len(isbn) == 13 </span><span class="cov0" title="0">{
                                result.ISBN13 = isbn
                        }</span>
                }
        }

        // Set subjects as genres
        <span class="cov0" title="0">result.Genres = doc.Subject

        // Get cover image
        if doc.CoverID &gt; 0 </span><span class="cov0" title="0">{
                coverURL := fmt.Sprintf("https://covers.openlibrary.org/b/id/%d-L.jpg", doc.CoverID)
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        ID:      fmt.Sprintf("open_library_%d", doc.CoverID),
                        URL:     coverURL,
                        Quality: "large",
                        Source:  "Open Library",
                })
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "open_library_key": doc.Key,
        }
        if len(doc.ID_Goodreads) &gt; 0 </span><span class="cov0" title="0">{
                result.ExternalIDs["goodreads_id"] = doc.ID_Goodreads[0]
        }</span>

        <span class="cov0" title="0">return result</span>
}

func (p *BookRecognitionProvider) searchCrossref(ctx context.Context, title, author string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}

        // Build search query for academic publications
        query := ""
        if title != "" </span><span class="cov0" title="0">{
                query += title
        }</span>
        <span class="cov0" title="0">if author != "" </span><span class="cov0" title="0">{
                if query != "" </span><span class="cov0" title="0">{
                        query += " "
                }</span>
                <span class="cov0" title="0">query += author</span>
        }

        <span class="cov0" title="0">params.Set("query", query)
        params.Set("rows", "10")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/works?%s", p.baseURLs["crossref"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var crossrefResp CrossrefResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;crossrefResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(crossrefResp.Message.Items) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no publications found in Crossref")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := crossrefResp.Message.Items[0]
        return p.convertCrossrefWork(bestMatch), nil</span>
}

func (p *BookRecognitionProvider) convertCrossrefWork(work CrossrefWork) *MediaRecognitionResult <span class="cov0" title="0">{
        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("crossref_%s", work.DOI),
                MediaType:         p.mapCrossrefType(work.Type),
                DOI:               work.DOI,
                Publisher:         work.Publisher,
                Confidence:        work.Score,
                RecognitionMethod: "crossref_api",
                APIProvider:       "Crossref",
        }

        // Set title
        if len(work.Title) &gt; 0 </span><span class="cov0" title="0">{
                result.Title = work.Title[0]
        }</span>

        // Set authors
        <span class="cov0" title="0">if len(work.Author) &gt; 0 </span><span class="cov0" title="0">{
                result.Author = fmt.Sprintf("%s %s", work.Author[0].Given, work.Author[0].Family)
                for _, author := range work.Author </span><span class="cov0" title="0">{
                        fullName := fmt.Sprintf("%s %s", author.Given, author.Family)
                        result.Authors = append(result.Authors, Person{
                                Name: fullName,
                                Role: "Author",
                        })
                }</span>
        }

        // Set publication date
        <span class="cov0" title="0">if len(work.Issued.DateParts) &gt; 0 &amp;&amp; len(work.Issued.DateParts[0]) &gt; 0 </span><span class="cov0" title="0">{
                result.Year = work.Issued.DateParts[0][0]
        }</span>

        // Set journal/container title
        <span class="cov0" title="0">if len(work.ContainerTitle) &gt; 0 </span><span class="cov0" title="0">{
                result.Series = work.ContainerTitle[0]
        }</span>

        // Set volume and issue
        <span class="cov0" title="0">if work.Volume != "" </span><span class="cov0" title="0">{
                if vol, err := strconv.Atoi(work.Volume); err == nil </span><span class="cov0" title="0">{
                        result.Volume = vol
                }</span>
        }
        <span class="cov0" title="0">if work.Issue != "" </span><span class="cov0" title="0">{
                if issue, err := strconv.Atoi(work.Issue); err == nil </span><span class="cov0" title="0">{
                        result.Issue = issue
                }</span>
        }

        // Set ISSN
        <span class="cov0" title="0">if len(work.ISSN) &gt; 0 </span><span class="cov0" title="0">{
                result.ISSN = work.ISSN[0]
        }</span>

        // Set subjects as genres
        <span class="cov0" title="0">result.Genres = work.Subject

        // Set external IDs
        result.ExternalIDs = map[string]string{
                "doi": work.DOI,
        }
        if work.URL != "" </span><span class="cov0" title="0">{
                result.ExternalIDs["url"] = work.URL
        }</span>

        <span class="cov0" title="0">return result</span>
}

func (p *BookRecognitionProvider) basicBookRecognition(req *MediaRecognitionRequest, title, author, isbn string, mediaType MediaType) *MediaRecognitionResult <span class="cov0" title="0">{
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("basic_book_%s_%d", strings.ReplaceAll(title, " ", "_"), time.Now().Unix()),
                MediaType:         mediaType,
                Title:             title,
                Author:            author,
                ISBN:              isbn,
                Confidence:        0.3,
                RecognitionMethod: "filename_parsing",
                APIProvider:       "basic",
                ExternalIDs:       make(map[string]string),
        }
}</span>

// Helper methods
func (p *BookRecognitionProvider) extractBookMetadataFromFilename(filename string) (title, author, isbn string) <span class="cov0" title="0">{
        // Remove file extension
        baseName := strings.TrimSuffix(filename, "."+p.getFileExtension(filename))

        // Extract ISBN pattern
        isbnPattern := regexp.MustCompile(`\b(?:ISBN[-\s]*(?:10|13)?[-\s]*[:\s]?)?(?:97[89][-\s]?)?(?:\d[-\s]?){9}[\dXx]\b`)
        if matches := isbnPattern.FindString(baseName); matches != "" </span><span class="cov0" title="0">{
                isbn = p.cleanISBN(matches)
                // Remove ISBN from filename
                baseName = isbnPattern.ReplaceAllString(baseName, "")
        }</span>

        // Common patterns for books:
        // Author - Title
        // Title - Author
        // Author (Year) Title
        // Title by Author

        // Pattern: "by Author"
        <span class="cov0" title="0">byPattern := regexp.MustCompile(`\s+by\s+(.+)$`)
        if matches := byPattern.FindStringSubmatch(baseName); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                author = strings.TrimSpace(matches[1])
                title = strings.TrimSpace(byPattern.ReplaceAllString(baseName, ""))
                return title, author, isbn
        }</span>

        // Pattern: Author - Title or Title - Author
        <span class="cov0" title="0">if parts := strings.Split(baseName, " - "); len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                // Try to determine which is author and which is title
                if p.looksLikeAuthorName(parts[0]) </span><span class="cov0" title="0">{
                        author = strings.TrimSpace(parts[0])
                        title = strings.TrimSpace(parts[1])
                }</span> else<span class="cov0" title="0"> {
                        title = strings.TrimSpace(parts[0])
                        author = strings.TrimSpace(parts[1])
                }</span>
                <span class="cov0" title="0">return title, author, isbn</span>
        }

        // Pattern: Author (Year) Title
        <span class="cov0" title="0">yearPattern := regexp.MustCompile(`^(.+?)\s*\((\d{4})\)\s*(.+)$`)
        if matches := yearPattern.FindStringSubmatch(baseName); len(matches) == 4 </span><span class="cov0" title="0">{
                author = strings.TrimSpace(matches[1])
                title = strings.TrimSpace(matches[3])
                return title, author, isbn
        }</span>

        // Fallback: use entire filename as title
        <span class="cov0" title="0">title = baseName
        return title, author, isbn</span>
}

func (p *BookRecognitionProvider) looksLikeAuthorName(str string) bool <span class="cov0" title="0">{
        // Simple heuristic: author names often have 2-3 words and proper capitalization
        words := strings.Fields(str)
        if len(words) &lt; 2 || len(words) &gt; 4 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if words look like names (capitalized)
        <span class="cov0" title="0">for _, word := range words </span><span class="cov0" title="0">{
                if len(word) &gt; 0 &amp;&amp; strings.ToUpper(word[:1]) != word[:1] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (p *BookRecognitionProvider) extractTitleFromOCR(text string, blocks []OCRTextBlock) string <span class="cov0" title="0">{
        // Find the largest text block (usually the title)
        var largestBlock OCRTextBlock
        maxArea := 0

        for _, block := range blocks </span><span class="cov0" title="0">{
                area := block.BoundingBox.Width * block.BoundingBox.Height
                if area &gt; maxArea &amp;&amp; block.Confidence &gt; 0.8 </span><span class="cov0" title="0">{
                        maxArea = area
                        largestBlock = block
                }</span>
        }

        <span class="cov0" title="0">if largestBlock.Text != "" </span><span class="cov0" title="0">{
                return strings.TrimSpace(largestBlock.Text)
        }</span>

        // Fallback: extract first line that looks like a title
        <span class="cov0" title="0">lines := strings.Split(text, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if len(line) &gt; 5 &amp;&amp; len(line) &lt; 100 &amp;&amp; !strings.Contains(line, "ISBN") </span><span class="cov0" title="0">{
                        return line
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func (p *BookRecognitionProvider) extractAuthorFromOCR(text string, blocks []OCRTextBlock) string <span class="cov0" title="0">{
        // Look for "by" pattern
        byPattern := regexp.MustCompile(`(?i)by\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)`)
        if matches := byPattern.FindStringSubmatch(text); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                return strings.TrimSpace(matches[1])
        }</span>

        // Look for author-like text blocks (smaller than title, proper case)
        <span class="cov0" title="0">for _, block := range blocks </span><span class="cov0" title="0">{
                if block.Confidence &gt; 0.7 &amp;&amp; p.looksLikeAuthorName(block.Text) </span><span class="cov0" title="0">{
                        return strings.TrimSpace(block.Text)
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func (p *BookRecognitionProvider) extractISBNFromText(text string) string <span class="cov0" title="0">{
        isbnPattern := regexp.MustCompile(`\b(?:ISBN[-\s]*(?:10|13)?[-\s]*[:\s]?)?(?:97[89][-\s]?)?(?:\d[-\s]?){9}[\dXx]\b`)
        if match := isbnPattern.FindString(text); match != "" </span><span class="cov0" title="0">{
                return p.cleanISBN(match)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (p *BookRecognitionProvider) cleanISBN(isbn string) string <span class="cov0" title="0">{
        // Remove all non-digit characters except X
        cleaned := regexp.MustCompile(`[^\dXx]`).ReplaceAllString(isbn, "")
        return strings.ToUpper(cleaned)
}</span>

func (p *BookRecognitionProvider) extractMetadataFromContent(text string) BookMetadata <span class="cov0" title="0">{
        metadata := BookMetadata{}

        // Extract title from first significant line
        lines := strings.Split(text, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if len(line) &gt; 10 &amp;&amp; len(line) &lt; 100 </span><span class="cov0" title="0">{
                        metadata.Title = line
                        break</span>
                }
        }

        // Extract chapter titles
        <span class="cov0" title="0">chapterPattern := regexp.MustCompile(`(?i)^(?:chapter|ch\.?)\s+\d+[\.\:\s]+(.+)$`)
        for _, line := range lines </span><span class="cov0" title="0">{
                if matches := chapterPattern.FindStringSubmatch(strings.TrimSpace(line)); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        metadata.ChapterTitles = append(metadata.ChapterTitles, matches[1])
                }</span>
        }

        <span class="cov0" title="0">return metadata</span>
}

func (p *BookRecognitionProvider) detectLanguage(text string) string <span class="cov0" title="0">{
        // Simple language detection based on common words
        // This would be replaced with a proper language detection library

        englishWords := []string{"the", "and", "of", "to", "a", "in", "is", "it", "you", "that"}
        spanishWords := []string{"el", "la", "de", "que", "y", "en", "un", "es", "se", "no"}
        frenchWords := []string{"le", "de", "et", "à", "un", "il", "être", "et", "en", "avoir"}

        lowerText := strings.ToLower(text)

        englishCount := 0
        for _, word := range englishWords </span><span class="cov0" title="0">{
                englishCount += strings.Count(lowerText, " "+word+" ")
        }</span>

        <span class="cov0" title="0">spanishCount := 0
        for _, word := range spanishWords </span><span class="cov0" title="0">{
                spanishCount += strings.Count(lowerText, " "+word+" ")
        }</span>

        <span class="cov0" title="0">frenchCount := 0
        for _, word := range frenchWords </span><span class="cov0" title="0">{
                frenchCount += strings.Count(lowerText, " "+word+" ")
        }</span>

        <span class="cov0" title="0">if englishCount &gt;= spanishCount &amp;&amp; englishCount &gt;= frenchCount </span><span class="cov0" title="0">{
                return "en"
        }</span> else<span class="cov0" title="0"> if spanishCount &gt;= frenchCount </span><span class="cov0" title="0">{
                return "es"
        }</span> else<span class="cov0" title="0"> {
                return "fr"
        }</span>
}

func (p *BookRecognitionProvider) extractTopics(text string) []string <span class="cov0" title="0">{
        // Simple topic extraction - would be replaced with NLP library
        topics := []string{}

        // Look for capitalized phrases that might be topics
        topicPattern := regexp.MustCompile(`\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b`)
        matches := topicPattern.FindAllString(text, -1)

        topicCount := make(map[string]int)
        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt; 3 </span><span class="cov0" title="0">{ // Filter out short matches
                        topicCount[match]++
                }</span>
        }

        // Return most frequent topics
        <span class="cov0" title="0">for topic, count := range topicCount </span><span class="cov0" title="0">{
                if count &gt; 1 </span><span class="cov0" title="0">{ // Topic appears multiple times
                        topics = append(topics, topic)
                }</span>
        }

        <span class="cov0" title="0">return topics</span>
}

func (p *BookRecognitionProvider) extractKeywords(text string) []string <span class="cov0" title="0">{
        // Simple keyword extraction
        words := strings.Fields(strings.ToLower(text))
        wordCount := make(map[string]int)

        // Count word frequency, excluding common words
        stopWords := map[string]bool{
                "the": true, "and": true, "of": true, "to": true, "a": true,
                "in": true, "is": true, "it": true, "you": true, "that": true,
                "he": true, "was": true, "for": true, "on": true, "are": true,
        }

        for _, word := range words </span><span class="cov0" title="0">{
                word = regexp.MustCompile(`[^\w]`).ReplaceAllString(word, "")
                if len(word) &gt; 3 &amp;&amp; !stopWords[word] </span><span class="cov0" title="0">{
                        wordCount[word]++
                }</span>
        }

        // Return most frequent keywords
        <span class="cov0" title="0">var keywords []string
        for word, count := range wordCount </span><span class="cov0" title="0">{
                if count &gt; 2 </span><span class="cov0" title="0">{ // Word appears multiple times
                        keywords = append(keywords, word)
                }</span>
        }

        <span class="cov0" title="0">return keywords</span>
}

func (p *BookRecognitionProvider) calculateReadabilityScore(text string) float64 <span class="cov0" title="0">{
        // Simple Flesch Reading Ease approximation
        sentences := len(regexp.MustCompile(`[.!?]+`).FindAllString(text, -1))
        words := len(strings.Fields(text))
        syllables := p.countSyllables(text)

        if sentences == 0 || words == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">avgSentenceLength := float64(words) / float64(sentences)
        avgSyllablesPerWord := float64(syllables) / float64(words)

        score := 206.835 - 1.015*avgSentenceLength - 84.6*avgSyllablesPerWord

        // Normalize to 0-1 scale
        if score &lt; 0 </span><span class="cov0" title="0">{
                score = 0
        }</span> else<span class="cov0" title="0"> if score &gt; 100 </span><span class="cov0" title="0">{
                score = 100
        }</span>

        <span class="cov0" title="0">return score / 100.0</span>
}

func (p *BookRecognitionProvider) countSyllables(text string) int <span class="cov0" title="0">{
        // Simple syllable counting approximation
        words := strings.Fields(strings.ToLower(text))
        syllables := 0

        for _, word := range words </span><span class="cov0" title="0">{
                wordSyllables := 0
                vowels := "aeiouy"
                lastWasVowel := false

                for _, char := range word </span><span class="cov0" title="0">{
                        isVowel := strings.ContainsRune(vowels, char)
                        if isVowel &amp;&amp; !lastWasVowel </span><span class="cov0" title="0">{
                                wordSyllables++
                        }</span>
                        <span class="cov0" title="0">lastWasVowel = isVowel</span>
                }

                // At least one syllable per word
                <span class="cov0" title="0">if wordSyllables == 0 </span><span class="cov0" title="0">{
                        wordSyllables = 1
                }</span>

                <span class="cov0" title="0">syllables += wordSyllables</span>
        }

        <span class="cov0" title="0">return syllables</span>
}

func (p *BookRecognitionProvider) determinePublicationType(title, filename, mimeType string) MediaType <span class="cov0" title="0">{
        filename = strings.ToLower(filename)
        title = strings.ToLower(title)

        // Check for comic book patterns
        comicPatterns := []string{"comic", "manga", "graphic novel", "superhero", "marvel", "dc comics"}
        for _, pattern := range comicPatterns </span><span class="cov0" title="0">{
                if strings.Contains(filename, pattern) || strings.Contains(title, pattern) </span><span class="cov0" title="0">{
                        return MediaTypeComicBook
                }</span>
        }

        // Check for magazine patterns
        <span class="cov0" title="0">magazinePatterns := []string{"magazine", "issue", "vol.", "monthly", "weekly", "quarterly"}
        for _, pattern := range magazinePatterns </span><span class="cov0" title="0">{
                if strings.Contains(filename, pattern) || strings.Contains(title, pattern) </span><span class="cov0" title="0">{
                        return MediaTypeMagazine
                }</span>
        }

        // Check for academic journal patterns
        <span class="cov0" title="0">journalPatterns := []string{"journal", "proceedings", "conference", "symposium", "research"}
        for _, pattern := range journalPatterns </span><span class="cov0" title="0">{
                if strings.Contains(filename, pattern) || strings.Contains(title, pattern) </span><span class="cov0" title="0">{
                        return MediaTypeJournal
                }</span>
        }

        // Check for manual patterns
        <span class="cov0" title="0">manualPatterns := []string{"manual", "guide", "handbook", "reference", "documentation"}
        for _, pattern := range manualPatterns </span><span class="cov0" title="0">{
                if strings.Contains(filename, pattern) || strings.Contains(title, pattern) </span><span class="cov0" title="0">{
                        return MediaTypeManual
                }</span>
        }

        // Default to book
        <span class="cov0" title="0">return MediaTypeBook</span>
}

func (p *BookRecognitionProvider) determineBookType(volumeInfo GoogleBookVolumeInfo) MediaType <span class="cov0" title="0">{
        // Check print type
        if volumeInfo.PrintType == "MAGAZINE" </span><span class="cov0" title="0">{
                return MediaTypeMagazine
        }</span>

        // Check categories
        <span class="cov0" title="0">for _, category := range volumeInfo.Categories </span><span class="cov0" title="0">{
                category = strings.ToLower(category)
                if strings.Contains(category, "comic") || strings.Contains(category, "graphic") </span><span class="cov0" title="0">{
                        return MediaTypeComicBook
                }</span>
                <span class="cov0" title="0">if strings.Contains(category, "magazine") || strings.Contains(category, "periodical") </span><span class="cov0" title="0">{
                        return MediaTypeMagazine
                }</span>
                <span class="cov0" title="0">if strings.Contains(category, "reference") || strings.Contains(category, "manual") </span><span class="cov0" title="0">{
                        return MediaTypeManual
                }</span>
        }

        <span class="cov0" title="0">return MediaTypeBook</span>
}

func (p *BookRecognitionProvider) mapCrossrefType(crossrefType string) MediaType <span class="cov0" title="0">{
        switch strings.ToLower(crossrefType) </span>{
        case "journal-article":<span class="cov0" title="0">
                return MediaTypeJournal</span>
        case "book-chapter", "book":<span class="cov0" title="0">
                return MediaTypeBook</span>
        case "proceedings-article":<span class="cov0" title="0">
                return MediaTypeJournal</span>
        case "reference-entry":<span class="cov0" title="0">
                return MediaTypeManual</span>
        default:<span class="cov0" title="0">
                return MediaTypeBook</span>
        }
}

func (p *BookRecognitionProvider) getFileExtension(filename string) string <span class="cov0" title="0">{
        parts := strings.Split(filename, ".")
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                return parts[len(parts)-1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (p *BookRecognitionProvider) parseYear(dateStr string) int <span class="cov0" title="0">{
        yearPattern := regexp.MustCompile(`(\d{4})`)
        if matches := yearPattern.FindStringSubmatch(dateStr); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                if year, err := strconv.Atoi(matches[1]); err == nil </span><span class="cov0" title="0">{
                        return year
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func (p *BookRecognitionProvider) parseDate(dateStr string) (time.Time, error) <span class="cov0" title="0">{
        formats := []string{
                "2006-01-02",
                "2006-01",
                "2006",
                "January 2, 2006",
                "Jan 2, 2006",
                "2006-01-02T15:04:05Z",
        }

        for _, format := range formats </span><span class="cov0" title="0">{
                if date, err := time.Parse(format, dateStr); err == nil </span><span class="cov0" title="0">{
                        return date, nil
                }</span>
        }

        <span class="cov0" title="0">return time.Time{}, fmt.Errorf("unable to parse date: %s", dateStr)</span>
}

func (p *BookRecognitionProvider) calculateGoogleBooksConfidence(rating float64, ratingCount int) float64 <span class="cov0" title="0">{
        confidence := 0.5

        if rating &gt; 4.0 &amp;&amp; ratingCount &gt; 100 </span><span class="cov0" title="0">{
                confidence += 0.3
        }</span> else<span class="cov0" title="0"> if rating &gt; 3.5 &amp;&amp; ratingCount &gt; 50 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *BookRecognitionProvider) calculateOpenLibraryConfidence(editionCount, ebookCount int) float64 <span class="cov0" title="0">{
        confidence := 0.5

        if editionCount &gt; 5 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">if ebookCount &gt; 0 </span><span class="cov0" title="0">{
                confidence += 0.1
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *BookRecognitionProvider) generateID(input string) string <span class="cov0" title="0">{
        hash := md5.Sum([]byte(input))
        return hex.EncodeToString(hash[:])[:12]
}</span>

// RecognitionProvider interface implementation
func (p *BookRecognitionProvider) GetProviderName() string <span class="cov0" title="0">{
        return "book_recognition"
}</span>

func (p *BookRecognitionProvider) SupportsMediaType(mediaType MediaType) bool <span class="cov0" title="0">{
        supportedTypes := []MediaType{
                MediaTypeBook,
                MediaTypeComicBook,
                MediaTypeMagazine,
                MediaTypeNewspaper,
                MediaTypeJournal,
                MediaTypeManual,
                MediaTypeEbook,
        }

        for _, supported := range supportedTypes </span><span class="cov0" title="0">{
                if mediaType == supported </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (p *BookRecognitionProvider) GetConfidenceThreshold() float64 <span class="cov0" title="0">{
        return 0.4
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "database/sql"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "time"

        "go.uber.org/zap"
)

type CacheService struct {
        db     *sql.DB
        logger *zap.Logger
}

type CacheEntry struct {
        ID        int64     `json:"id" db:"id"`
        CacheKey  string    `json:"cache_key" db:"cache_key"`
        Value     string    `json:"value" db:"value"`
        ExpiresAt time.Time `json:"expires_at" db:"expires_at"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
        UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

type MediaMetadataCache struct {
        ID           int64     `json:"id"`
        MediaItemID  int64     `json:"media_item_id"`
        MetadataType string    `json:"metadata_type"`
        Provider     string    `json:"provider"`
        Data         string    `json:"data"`
        Quality      float64   `json:"quality"`
        ExpiresAt    time.Time `json:"expires_at"`
        CreatedAt    time.Time `json:"created_at"`
        UpdatedAt    time.Time `json:"updated_at"`
}

type APICache struct {
        ID          int64     `json:"id"`
        Provider    string    `json:"provider"`
        Endpoint    string    `json:"endpoint"`
        RequestHash string    `json:"request_hash"`
        Response    string    `json:"response"`
        StatusCode  int       `json:"status_code"`
        ExpiresAt   time.Time `json:"expires_at"`
        CreatedAt   time.Time `json:"created_at"`
}

type ThumbnailCache struct {
        ID        int64     `json:"id"`
        VideoID   int64     `json:"video_id"`
        Position  int64     `json:"position"`
        URL       string    `json:"url"`
        Width     int       `json:"width"`
        Height    int       `json:"height"`
        FileSize  int64     `json:"file_size"`
        CreatedAt time.Time `json:"created_at"`
}

type CacheStats struct {
        TotalEntries     int64            `json:"total_entries"`
        TotalSize        int64            `json:"total_size"`
        HitRate          float64          `json:"hit_rate"`
        MissRate         float64          `json:"miss_rate"`
        ExpiredEntries   int64            `json:"expired_entries"`
        CachesByType     map[string]int64 `json:"caches_by_type"`
        CachesByProvider map[string]int64 `json:"caches_by_provider"`
        RecentActivity   []CacheActivity  `json:"recent_activity"`
}

type CacheActivity struct {
        Type      string    `json:"type"`
        Key       string    `json:"key"`
        Provider  string    `json:"provider"`
        Hit       bool      `json:"hit"`
        Timestamp time.Time `json:"timestamp"`
}

const (
        DefaultCacheTTL     = 24 * time.Hour
        MetadataCacheTTL    = 7 * 24 * time.Hour
        ThumbnailCacheTTL   = 30 * 24 * time.Hour
        APICacheTTL         = 1 * time.Hour
        TranslationCacheTTL = 30 * 24 * time.Hour
        SubtitleCacheTTL    = 7 * 24 * time.Hour
        LyricsCacheTTL      = 14 * 24 * time.Hour
        CoverArtCacheTTL    = 30 * 24 * time.Hour
)

func NewCacheService(db *sql.DB, logger *zap.Logger) *CacheService <span class="cov0" title="0">{
        return &amp;CacheService{
                db:     db,
                logger: logger,
        }
}</span>

func (s *CacheService) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov0" title="0">{
        s.logger.Debug("Setting cache entry",
                zap.String("key", key),
                zap.Duration("ttl", ttl))

        valueJSON, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal value: %w", err)
        }</span>

        <span class="cov0" title="0">expiresAt := time.Now().Add(ttl)

        query := `
                INSERT INTO cache_entries (cache_key, value, expires_at, created_at, updated_at)
                VALUES ($1, $2, $3, NOW(), NOW())
                ON CONFLICT (cache_key)
                DO UPDATE SET
                        value = EXCLUDED.value,
                        expires_at = EXCLUDED.expires_at,
                        updated_at = NOW()
        `

        _, err = s.db.ExecContext(ctx, query, key, string(valueJSON), expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to set cache entry", zap.Error(err))
                return fmt.Errorf("failed to set cache entry: %w", err)
        }</span>

        <span class="cov0" title="0">s.recordCacheActivity(ctx, "SET", key, "", true)
        return nil</span>
}

func (s *CacheService) Get(ctx context.Context, key string, dest interface{}) (bool, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting cache entry", zap.String("key", key))

        query := `
                SELECT value, expires_at
                FROM cache_entries
                WHERE cache_key = $1 AND expires_at &gt; NOW()
        `

        var valueJSON string
        var expiresAt time.Time

        err := s.db.QueryRowContext(ctx, query, key).Scan(&amp;valueJSON, &amp;expiresAt)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                s.recordCacheActivity(ctx, "GET", key, "", false)
                return false, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get cache entry", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", key, "", false)
                return false, fmt.Errorf("failed to get cache entry: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(valueJSON), dest); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to unmarshal cache value", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", key, "", false)
                return false, fmt.Errorf("failed to unmarshal cache value: %w", err)
        }</span>

        <span class="cov0" title="0">s.recordCacheActivity(ctx, "GET", key, "", true)
        return true, nil</span>
}

func (s *CacheService) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        s.logger.Debug("Deleting cache entry", zap.String("key", key))

        query := `DELETE FROM cache_entries WHERE cache_key = $1`

        result, err := s.db.ExecContext(ctx, query, key)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to delete cache entry", zap.Error(err))
                return fmt.Errorf("failed to delete cache entry: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        s.recordCacheActivity(ctx, "DELETE", key, "", rowsAffected &gt; 0)

        return nil</span>
}

func (s *CacheService) Clear(ctx context.Context, pattern string) error <span class="cov0" title="0">{
        s.logger.Info("Clearing cache entries", zap.String("pattern", pattern))

        var query string
        var args []interface{}

        if pattern == "" </span><span class="cov0" title="0">{
                query = `DELETE FROM cache_entries`
        }</span> else<span class="cov0" title="0"> {
                query = `DELETE FROM cache_entries WHERE cache_key LIKE $1`
                args = append(args, pattern)
        }</span>

        <span class="cov0" title="0">result, err := s.db.ExecContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to clear cache entries", zap.Error(err))
                return fmt.Errorf("failed to clear cache entries: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        s.logger.Info("Cleared cache entries", zap.Int64("count", rowsAffected))

        return nil</span>
}

func (s *CacheService) SetMediaMetadata(ctx context.Context, mediaItemID int64, metadataType, provider string, data interface{}, quality float64) error <span class="cov0" title="0">{
        s.logger.Debug("Setting media metadata cache",
                zap.Int64("media_item_id", mediaItemID),
                zap.String("type", metadataType),
                zap.String("provider", provider))

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">expiresAt := time.Now().Add(MetadataCacheTTL)

        query := `
                INSERT INTO media_metadata_cache (
                        media_item_id, metadata_type, provider, data, quality, expires_at, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
                ON CONFLICT (media_item_id, metadata_type, provider)
                DO UPDATE SET
                        data = EXCLUDED.data,
                        quality = EXCLUDED.quality,
                        expires_at = EXCLUDED.expires_at,
                        updated_at = NOW()
        `

        _, err = s.db.ExecContext(ctx, query, mediaItemID, metadataType, provider, string(dataJSON), quality, expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to set media metadata cache", zap.Error(err))
                return fmt.Errorf("failed to set media metadata: %w", err)
        }</span>

        <span class="cov0" title="0">cacheKey := fmt.Sprintf("metadata:%d:%s:%s", mediaItemID, metadataType, provider)
        s.recordCacheActivity(ctx, "SET", cacheKey, provider, true)

        return nil</span>
}

func (s *CacheService) GetMediaMetadata(ctx context.Context, mediaItemID int64, metadataType, provider string, dest interface{}) (bool, float64, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting media metadata cache",
                zap.Int64("media_item_id", mediaItemID),
                zap.String("type", metadataType),
                zap.String("provider", provider))

        query := `
                SELECT data, quality, expires_at
                FROM media_metadata_cache
                WHERE media_item_id = $1 AND metadata_type = $2 AND provider = $3 AND expires_at &gt; NOW()
                ORDER BY quality DESC, updated_at DESC
                LIMIT 1
        `

        var dataJSON string
        var quality float64
        var expiresAt time.Time

        err := s.db.QueryRowContext(ctx, query, mediaItemID, metadataType, provider).Scan(&amp;dataJSON, &amp;quality, &amp;expiresAt)
        cacheKey := fmt.Sprintf("metadata:%d:%s:%s", mediaItemID, metadataType, provider)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                s.recordCacheActivity(ctx, "GET", cacheKey, provider, false)
                return false, 0, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get media metadata cache", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", cacheKey, provider, false)
                return false, 0, fmt.Errorf("failed to get media metadata: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(dataJSON), dest); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to unmarshal metadata", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", cacheKey, provider, false)
                return false, 0, fmt.Errorf("failed to unmarshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">s.recordCacheActivity(ctx, "GET", cacheKey, provider, true)
        return true, quality, nil</span>
}

func (s *CacheService) SetAPIResponse(ctx context.Context, provider, endpoint string, requestData interface{}, response interface{}, statusCode int, ttl time.Duration) error <span class="cov0" title="0">{
        s.logger.Debug("Setting API response cache",
                zap.String("provider", provider),
                zap.String("endpoint", endpoint))

        requestHash, err := s.hashRequest(requestData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash request: %w", err)
        }</span>

        <span class="cov0" title="0">responseJSON, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal response: %w", err)
        }</span>

        <span class="cov0" title="0">expiresAt := time.Now().Add(ttl)

        query := `
                INSERT INTO api_cache (provider, endpoint, request_hash, response, status_code, expires_at, created_at)
                VALUES ($1, $2, $3, $4, $5, $6, NOW())
                ON CONFLICT (provider, endpoint, request_hash)
                DO UPDATE SET
                        response = EXCLUDED.response,
                        status_code = EXCLUDED.status_code,
                        expires_at = EXCLUDED.expires_at,
                        created_at = NOW()
        `

        _, err = s.db.ExecContext(ctx, query, provider, endpoint, requestHash, string(responseJSON), statusCode, expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to set API response cache", zap.Error(err))
                return fmt.Errorf("failed to set API response: %w", err)
        }</span>

        <span class="cov0" title="0">cacheKey := fmt.Sprintf("api:%s:%s:%s", provider, endpoint, requestHash)
        s.recordCacheActivity(ctx, "SET", cacheKey, provider, true)

        return nil</span>
}

func (s *CacheService) GetAPIResponse(ctx context.Context, provider, endpoint string, requestData interface{}, dest interface{}) (bool, int, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting API response cache",
                zap.String("provider", provider),
                zap.String("endpoint", endpoint))

        requestHash, err := s.hashRequest(requestData)
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, fmt.Errorf("failed to hash request: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                SELECT response, status_code, expires_at
                FROM api_cache
                WHERE provider = $1 AND endpoint = $2 AND request_hash = $3 AND expires_at &gt; NOW()
        `

        var responseJSON string
        var statusCode int
        var expiresAt time.Time

        err = s.db.QueryRowContext(ctx, query, provider, endpoint, requestHash).Scan(&amp;responseJSON, &amp;statusCode, &amp;expiresAt)
        cacheKey := fmt.Sprintf("api:%s:%s:%s", provider, endpoint, requestHash)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                s.recordCacheActivity(ctx, "GET", cacheKey, provider, false)
                return false, 0, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get API response cache", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", cacheKey, provider, false)
                return false, 0, fmt.Errorf("failed to get API response: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(responseJSON), dest); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to unmarshal API response", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", cacheKey, provider, false)
                return false, statusCode, fmt.Errorf("failed to unmarshal API response: %w", err)
        }</span>

        <span class="cov0" title="0">s.recordCacheActivity(ctx, "GET", cacheKey, provider, true)
        return true, statusCode, nil</span>
}

func (s *CacheService) SetThumbnail(ctx context.Context, videoID, position int64, url string, width, height int, fileSize int64) error <span class="cov0" title="0">{
        s.logger.Debug("Setting thumbnail cache",
                zap.Int64("video_id", videoID),
                zap.Int64("position", position))

        query := `
                INSERT INTO thumbnail_cache (video_id, position, url, width, height, file_size, created_at)
                VALUES ($1, $2, $3, $4, $5, $6, NOW())
                ON CONFLICT (video_id, position, width, height)
                DO UPDATE SET
                        url = EXCLUDED.url,
                        file_size = EXCLUDED.file_size,
                        created_at = NOW()
        `

        _, err := s.db.ExecContext(ctx, query, videoID, position, url, width, height, fileSize)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to set thumbnail cache", zap.Error(err))
                return fmt.Errorf("failed to set thumbnail: %w", err)
        }</span>

        <span class="cov0" title="0">cacheKey := fmt.Sprintf("thumbnail:%d:%d:%dx%d", videoID, position, width, height)
        s.recordCacheActivity(ctx, "SET", cacheKey, "thumbnail", true)

        return nil</span>
}

func (s *CacheService) GetThumbnail(ctx context.Context, videoID, position int64, width, height int) (*ThumbnailCache, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting thumbnail cache",
                zap.Int64("video_id", videoID),
                zap.Int64("position", position))

        query := `
                SELECT id, video_id, position, url, width, height, file_size, created_at
                FROM thumbnail_cache
                WHERE video_id = $1 AND position = $2 AND width = $3 AND height = $4
                ORDER BY created_at DESC
                LIMIT 1
        `

        var thumbnail ThumbnailCache
        err := s.db.QueryRowContext(ctx, query, videoID, position, width, height).Scan(
                &amp;thumbnail.ID, &amp;thumbnail.VideoID, &amp;thumbnail.Position, &amp;thumbnail.URL,
                &amp;thumbnail.Width, &amp;thumbnail.Height, &amp;thumbnail.FileSize, &amp;thumbnail.CreatedAt,
        )

        cacheKey := fmt.Sprintf("thumbnail:%d:%d:%dx%d", videoID, position, width, height)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                s.recordCacheActivity(ctx, "GET", cacheKey, "thumbnail", false)
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get thumbnail cache", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", cacheKey, "thumbnail", false)
                return nil, fmt.Errorf("failed to get thumbnail: %w", err)
        }</span>

        <span class="cov0" title="0">s.recordCacheActivity(ctx, "GET", cacheKey, "thumbnail", true)
        return &amp;thumbnail, nil</span>
}

func (s *CacheService) SetTranslation(ctx context.Context, sourceText, sourceLang, targetLang, provider string, translation string) error <span class="cov0" title="0">{
        s.logger.Debug("Setting translation cache",
                zap.String("source_lang", sourceLang),
                zap.String("target_lang", targetLang),
                zap.String("provider", provider))

        key := fmt.Sprintf("translation:%s:%s:%s:%s", provider, sourceLang, targetLang, s.hashString(sourceText))

        translationData := map[string]interface{}{
                "source_text": sourceText,
                "source_lang": sourceLang,
                "target_lang": targetLang,
                "translation": translation,
                "provider":    provider,
                "cached_at":   time.Now(),
        }

        return s.Set(ctx, key, translationData, TranslationCacheTTL)
}</span>

func (s *CacheService) GetTranslation(ctx context.Context, sourceText, sourceLang, targetLang, provider string) (string, bool, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting translation cache",
                zap.String("source_lang", sourceLang),
                zap.String("target_lang", targetLang),
                zap.String("provider", provider))

        key := fmt.Sprintf("translation:%s:%s:%s:%s", provider, sourceLang, targetLang, s.hashString(sourceText))

        var translationData map[string]interface{}
        found, err := s.Get(ctx, key, &amp;translationData)
        if err != nil || !found </span><span class="cov0" title="0">{
                return "", false, err
        }</span>

        <span class="cov0" title="0">if translation, ok := translationData["translation"].(string); ok </span><span class="cov0" title="0">{
                return translation, true, nil
        }</span>

        <span class="cov0" title="0">return "", false, fmt.Errorf("invalid translation data in cache")</span>
}

func (s *CacheService) SetSubtitle(ctx context.Context, videoID int64, language, provider string, subtitle *SubtitleTrack) error <span class="cov0" title="0">{
        s.logger.Debug("Setting subtitle cache",
                zap.Int64("video_id", videoID),
                zap.String("language", language),
                zap.String("provider", provider))

        key := fmt.Sprintf("subtitle:%d:%s:%s", videoID, language, provider)
        return s.Set(ctx, key, subtitle, SubtitleCacheTTL)
}</span>

func (s *CacheService) GetSubtitle(ctx context.Context, videoID int64, language, provider string) (*SubtitleTrack, bool, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting subtitle cache",
                zap.Int64("video_id", videoID),
                zap.String("language", language),
                zap.String("provider", provider))

        key := fmt.Sprintf("subtitle:%d:%s:%s", videoID, language, provider)

        var subtitle SubtitleTrack
        found, err := s.Get(ctx, key, &amp;subtitle)
        if err != nil || !found </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov0" title="0">return &amp;subtitle, true, nil</span>
}

func (s *CacheService) SetLyrics(ctx context.Context, artist, title, provider string, lyrics *LyricsData) error <span class="cov0" title="0">{
        s.logger.Debug("Setting lyrics cache",
                zap.String("artist", artist),
                zap.String("title", title),
                zap.String("provider", provider))

        key := fmt.Sprintf("lyrics:%s:%s:%s", provider, s.hashString(artist), s.hashString(title))
        return s.Set(ctx, key, lyrics, LyricsCacheTTL)
}</span>

func (s *CacheService) GetLyrics(ctx context.Context, artist, title, provider string) (*LyricsData, bool, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting lyrics cache",
                zap.String("artist", artist),
                zap.String("title", title),
                zap.String("provider", provider))

        key := fmt.Sprintf("lyrics:%s:%s:%s", provider, s.hashString(artist), s.hashString(title))

        var lyrics LyricsData
        found, err := s.Get(ctx, key, &amp;lyrics)
        if err != nil || !found </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov0" title="0">return &amp;lyrics, true, nil</span>
}

func (s *CacheService) SetCoverArt(ctx context.Context, artist, album, provider string, coverArt *CoverArt) error <span class="cov0" title="0">{
        s.logger.Debug("Setting cover art cache",
                zap.String("artist", artist),
                zap.String("album", album),
                zap.String("provider", provider))

        key := fmt.Sprintf("coverart:%s:%s:%s", provider, s.hashString(artist), s.hashString(album))
        return s.Set(ctx, key, coverArt, CoverArtCacheTTL)
}</span>

func (s *CacheService) GetCoverArt(ctx context.Context, artist, album, provider string) (*CoverArt, bool, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting cover art cache",
                zap.String("artist", artist),
                zap.String("album", album),
                zap.String("provider", provider))

        key := fmt.Sprintf("coverart:%s:%s:%s", provider, s.hashString(artist), s.hashString(album))

        var coverArt CoverArt
        found, err := s.Get(ctx, key, &amp;coverArt)
        if err != nil || !found </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov0" title="0">return &amp;coverArt, true, nil</span>
}

func (s *CacheService) GetStats(ctx context.Context) (*CacheStats, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting cache statistics")

        stats := &amp;CacheStats{
                CachesByType:     make(map[string]int64),
                CachesByProvider: make(map[string]int64),
        }

        if err := s.getBasicStats(ctx, stats); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.getCachesByType(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get caches by type", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getCachesByProvider(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get caches by provider", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getRecentActivity(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get recent activity", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.calculateHitRate(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to calculate hit rate", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (s *CacheService) CleanupExpired(ctx context.Context) error <span class="cov0" title="0">{
        s.logger.Info("Cleaning up expired cache entries")

        tables := []string{
                "cache_entries",
                "media_metadata_cache",
                "api_cache",
        }

        totalCleaned := int64(0)

        for _, table := range tables </span><span class="cov0" title="0">{
                query := fmt.Sprintf("DELETE FROM %s WHERE expires_at &lt;= NOW()", table)
                result, err := s.db.ExecContext(ctx, query)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to cleanup expired entries",
                                zap.String("table", table),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
                totalCleaned += rowsAffected

                s.logger.Debug("Cleaned expired entries",
                        zap.String("table", table),
                        zap.Int64("count", rowsAffected))</span>
        }

        <span class="cov0" title="0">s.logger.Info("Completed cache cleanup", zap.Int64("total_cleaned", totalCleaned))
        return nil</span>
}

func (s *CacheService) hashRequest(data interface{}) (string, error) <span class="cov0" title="0">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return s.hashString(string(jsonData)), nil</span>
}

func (s *CacheService) hashString(text string) string <span class="cov0" title="0">{
        hash := md5.Sum([]byte(text))
        return hex.EncodeToString(hash[:])
}</span>

func (s *CacheService) recordCacheActivity(ctx context.Context, activityType, key, provider string, hit bool) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                query := `
                        INSERT INTO cache_activity (type, cache_key, provider, hit, timestamp)
                        VALUES ($1, $2, $3, $4, NOW())
                `
                _, err := s.db.ExecContext(context.Background(), query, activityType, key, provider, hit)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Debug("Failed to record cache activity", zap.Error(err))
                }</span>
        }()
}

func (s *CacheService) getBasicStats(ctx context.Context, stats *CacheStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        COUNT(*) as total_entries,
                        COALESCE(SUM(LENGTH(value)), 0) as total_size,
                        COUNT(CASE WHEN expires_at &lt;= NOW() THEN 1 END) as expired_entries
                FROM cache_entries
        `

        return s.db.QueryRowContext(ctx, query).Scan(
                &amp;stats.TotalEntries, &amp;stats.TotalSize, &amp;stats.ExpiredEntries)
}</span>

func (s *CacheService) getCachesByType(ctx context.Context, stats *CacheStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        CASE
                                WHEN cache_key LIKE 'translation:%' THEN 'translation'
                                WHEN cache_key LIKE 'subtitle:%' THEN 'subtitle'
                                WHEN cache_key LIKE 'lyrics:%' THEN 'lyrics'
                                WHEN cache_key LIKE 'coverart:%' THEN 'coverart'
                                WHEN cache_key LIKE 'api:%' THEN 'api'
                                WHEN cache_key LIKE 'metadata:%' THEN 'metadata'
                                WHEN cache_key LIKE 'thumbnail:%' THEN 'thumbnail'
                                ELSE 'other'
                        END as cache_type,
                        COUNT(*) as count
                FROM cache_entries
                WHERE expires_at &gt; NOW()
                GROUP BY cache_type
                ORDER BY count DESC
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var cacheType string
                var count int64
                if err := rows.Scan(&amp;cacheType, &amp;count); err == nil </span><span class="cov0" title="0">{
                        stats.CachesByType[cacheType] = count
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *CacheService) getCachesByProvider(ctx context.Context, stats *CacheStats) error <span class="cov0" title="0">{
        query := `
                SELECT provider, COUNT(*) as count
                FROM api_cache
                WHERE expires_at &gt; NOW()
                GROUP BY provider
                ORDER BY count DESC
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var provider string
                var count int64
                if err := rows.Scan(&amp;provider, &amp;count); err == nil </span><span class="cov0" title="0">{
                        stats.CachesByProvider[provider] = count
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *CacheService) getRecentActivity(ctx context.Context, stats *CacheStats) error <span class="cov0" title="0">{
        query := `
                SELECT type, cache_key, provider, hit, timestamp
                FROM cache_activity
                WHERE timestamp &gt; NOW() - INTERVAL '1 hour'
                ORDER BY timestamp DESC
                LIMIT 100
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var activity CacheActivity
                if err := rows.Scan(&amp;activity.Type, &amp;activity.Key, &amp;activity.Provider, &amp;activity.Hit, &amp;activity.Timestamp); err == nil </span><span class="cov0" title="0">{
                        stats.RecentActivity = append(stats.RecentActivity, activity)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *CacheService) calculateHitRate(ctx context.Context, stats *CacheStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        COUNT(CASE WHEN hit = true THEN 1 END) as hits,
                        COUNT(CASE WHEN hit = false THEN 1 END) as misses,
                        COUNT(*) as total
                FROM cache_activity
                WHERE timestamp &gt; NOW() - INTERVAL '24 hours'
        `

        var hits, misses, total int64
        err := s.db.QueryRowContext(ctx, query).Scan(&amp;hits, &amp;misses, &amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if total &gt; 0 </span><span class="cov0" title="0">{
                stats.HitRate = float64(hits) / float64(total) * 100
                stats.MissRate = float64(misses) / float64(total) * 100
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *CacheService) Warmup(ctx context.Context) error <span class="cov0" title="0">{
        s.logger.Info("Starting cache warmup")

        return nil
}</span>

func (s *CacheService) InvalidateByPattern(ctx context.Context, pattern string) error <span class="cov0" title="0">{
        s.logger.Info("Invalidating cache entries by pattern", zap.String("pattern", pattern))

        query := `DELETE FROM cache_entries WHERE cache_key LIKE $1`
        result, err := s.db.ExecContext(ctx, query, pattern)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to invalidate cache entries: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        s.logger.Info("Invalidated cache entries", zap.Int64("count", rowsAffected))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package services

import (
        "catalogizer/internal/config"
        "catalogizer/internal/models"
        "database/sql"
        "fmt"
        "strconv"
        "strings"

        "go.uber.org/zap"
)

// CatalogServiceInterface defines the interface for catalog operations
type CatalogServiceInterface interface {
        SetDB(db *sql.DB)
        ListPath(path string, sortBy string, sortOrder string, limit, offset int) ([]models.FileInfo, error)
        GetFileInfo(pathOrID string) (*models.FileInfo, error)
        SearchFiles(req *models.SearchRequest) ([]models.FileInfo, int64, error)
        GetDirectoriesBySize(smbRoot string, limit int) ([]models.DirectoryStats, error)
        GetDuplicateGroups(smbRoot string, minCount int, limit int) ([]models.DuplicateGroup, error)
        GetSMBRoots() ([]string, error)
        ListDirectory(path string) ([]models.FileInfo, error)
        Search(query string, fileType string, limit int, offset int) ([]models.FileInfo, error)
        SearchDuplicates() ([]models.DuplicateGroup, error)
        GetFileInfoByPath(path string) (*models.FileInfo, error)
        GetDuplicatesCount() (int64, error)
        GetDirectoriesBySizeLimited(limit int) ([]models.DirectoryStats, error)
}

type CatalogService struct {
        db     *sql.DB
        config *config.Config
        logger *zap.Logger
}

func NewCatalogService(cfg *config.Config, logger *zap.Logger) *CatalogService <span class="cov8" title="12">{
        return &amp;CatalogService{
                config: cfg,
                logger: logger,
        }
}</span>

func (s *CatalogService) SetDB(db *sql.DB) <span class="cov8" title="12">{
        s.db = db
}</span>

func (s *CatalogService) ListPath(path string, sortBy string, sortOrder string, limit, offset int) ([]models.FileInfo, error) <span class="cov5" title="4">{
        var query string
        var args []interface{}

        // Check if path exists in database
        var parentID sql.NullInt64
        err := s.db.QueryRow(`SELECT id FROM files WHERE path = ? LIMIT 1`, path).Scan(&amp;parentID)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to check path: %w", err)
        }</span>

        <span class="cov4" title="3">if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                // Path not in database
                if path == "/" </span><span class="cov1" title="1">{
                        // Root, return top-level directories
                        query = `
                                SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, media_type, parent_id, smb_root, created_at, updated_at
                                FROM files
                                WHERE parent_id IS NULL
                        `
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("path not found: %s", path)
                }</span>
        } else<span class="cov3" title="2"> {
                // Path exists, list its children
                query = `
                        SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, media_type, parent_id, smb_root, created_at, updated_at
                        FROM files
                        WHERE parent_id = ?
                `
                args = []interface{}{parentID.Int64}
        }</span>

        // Add sorting
        <span class="cov4" title="3">switch sortBy </span>{
        case "name":<span class="cov4" title="3">
                query += " ORDER BY name"</span>
        case "size":<span class="cov0" title="0">
                query += " ORDER BY size"</span>
        case "modified":<span class="cov0" title="0">
                query += " ORDER BY last_modified"</span>
        default:<span class="cov0" title="0">
                query += " ORDER BY is_directory DESC, name"</span>
        }

        <span class="cov4" title="3">if sortOrder == "desc" </span><span class="cov0" title="0">{
                query += " DESC"
        }</span> else<span class="cov4" title="3"> {
                query += " ASC"
        }</span>

        // Add pagination
        <span class="cov4" title="3">if limit &gt; 0 </span><span class="cov0" title="0">{
                query += " LIMIT ?"
                args = append(args, limit)
        }</span>
        <span class="cov4" title="3">if offset &gt; 0 </span><span class="cov0" title="0">{
                query += " OFFSET ?"
                args = append(args, offset)
        }</span>

        <span class="cov4" title="3">rows, err := s.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query files: %w", err)
        }</span>
        <span class="cov4" title="3">defer rows.Close()

        var files []models.FileInfo
        for rows.Next() </span><span class="cov6" title="6">{
                var file models.FileInfo
                var mediaType *string
                var lastModified sql.NullTime
                var createdAt sql.NullTime
                var updatedAt sql.NullTime
                err := rows.Scan(
                        &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory, &amp;file.Size,
                        &amp;lastModified, &amp;file.Hash, &amp;file.Extension, &amp;file.MimeType,
                        &amp;mediaType, &amp;file.ParentID, &amp;file.SmbRoot, &amp;createdAt, &amp;updatedAt,
                )
                if mediaType != nil </span><span class="cov3" title="2">{
                        file.MediaType = mediaType
                }</span>
                <span class="cov6" title="6">if lastModified.Valid </span><span class="cov0" title="0">{
                        file.LastModified = lastModified.Time
                }</span>
                <span class="cov6" title="6">if createdAt.Valid </span><span class="cov6" title="6">{
                        file.CreatedAt = createdAt.Time
                }</span>
                <span class="cov6" title="6">if updatedAt.Valid </span><span class="cov6" title="6">{
                        file.UpdatedAt = updatedAt.Time
                }</span>
                <span class="cov6" title="6">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan file: %w", err)
                }</span>
                <span class="cov6" title="6">if file.IsDirectory </span><span class="cov5" title="4">{
                        file.Type = "directory"
                }</span> else<span class="cov3" title="2"> {
                        file.Type = "file"
                }</span>
                <span class="cov6" title="6">files = append(files, file)</span>
        }

        <span class="cov4" title="3">return files, nil</span>
}

func (s *CatalogService) GetFileInfo(pathOrID string) (*models.FileInfo, error) <span class="cov4" title="3">{
        var query string
        var arg interface{}

        // Try to parse as ID first
        if id, err := strconv.ParseInt(pathOrID, 10, 64); err == nil </span><span class="cov0" title="0">{
                query = `
                        SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, media_type, parent_id, smb_root, created_at, updated_at
                        FROM files
                        WHERE id = ?
                `
                arg = id
        }</span> else<span class="cov4" title="3"> {
                // Treat as path
                query = `
                        SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, media_type, parent_id, smb_root, created_at, updated_at
                        FROM files
                        WHERE path = ?
                `
                arg = pathOrID
        }</span>

        <span class="cov4" title="3">var file models.FileInfo
        var mediaType *string
        var lastModified sql.NullTime
        var createdAt sql.NullTime
        var updatedAt sql.NullTime
        err := s.db.QueryRow(query, arg).Scan(
                &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory, &amp;file.Size,
                &amp;lastModified, &amp;file.Hash, &amp;file.Extension, &amp;file.MimeType,
                &amp;mediaType, &amp;file.ParentID, &amp;file.SmbRoot, &amp;createdAt, &amp;updatedAt,
        )
        if mediaType != nil </span><span class="cov1" title="1">{
                file.MediaType = mediaType
        }</span>
        <span class="cov4" title="3">if lastModified.Valid </span><span class="cov0" title="0">{
                file.LastModified = lastModified.Time
        }</span>
        <span class="cov4" title="3">if createdAt.Valid </span><span class="cov1" title="1">{
                file.CreatedAt = createdAt.Time
        }</span>
        <span class="cov4" title="3">if updatedAt.Valid </span><span class="cov1" title="1">{
                file.UpdatedAt = updatedAt.Time
        }</span>

        <span class="cov4" title="3">if err != nil </span><span class="cov3" title="2">{
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        return nil, nil
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("failed to get file info: %w", err)</span>
        }

        <span class="cov1" title="1">if file.IsDirectory </span><span class="cov0" title="0">{
                file.Type = "directory"
        }</span> else<span class="cov1" title="1"> {
                file.Type = "file"
        }</span>

        <span class="cov1" title="1">return &amp;file, nil</span>
}

func (s *CatalogService) SearchFiles(req *models.SearchRequest) ([]models.FileInfo, int64, error) <span class="cov7" title="8">{
        baseQuery := `
                SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, media_type, parent_id, smb_root, created_at, updated_at
                FROM files
                WHERE 1=1
        `

        countQuery := `
                SELECT COUNT(*)
                FROM files
                WHERE 1=1
        `

        var conditions []string
        var args []interface{}

        // Add search conditions
        if req.Query != "" </span><span class="cov7" title="8">{
                conditions = append(conditions, "name LIKE ?")
                args = append(args, "%"+req.Query+"%")
        }</span>

        <span class="cov7" title="8">if req.Path != "" </span><span class="cov0" title="0">{
                conditions = append(conditions, "path LIKE ?")
                args = append(args, req.Path+"%")
        }</span>

        <span class="cov7" title="8">if req.Extension != "" </span><span class="cov0" title="0">{
                conditions = append(conditions, "extension = ?")
                args = append(args, req.Extension)
        }</span>

        <span class="cov7" title="8">if req.MimeType != "" </span><span class="cov1" title="1">{
                conditions = append(conditions, "media_type = ?")
                args = append(args, req.MimeType)
        }</span>

        <span class="cov7" title="8">if req.MinSize != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "size &gt;= ?")
                args = append(args, *req.MinSize)
        }</span>

        <span class="cov7" title="8">if req.MaxSize != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "size &lt;= ?")
                args = append(args, *req.MaxSize)
        }</span>

        <span class="cov7" title="8">if len(req.SmbRoots) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := strings.Repeat("?,", len(req.SmbRoots))
                placeholders = placeholders[:len(placeholders)-1]
                conditions = append(conditions, fmt.Sprintf("smb_root IN (%s)", placeholders))
                for _, root := range req.SmbRoots </span><span class="cov0" title="0">{
                        args = append(args, root)
                }</span>
        }

        <span class="cov7" title="8">if req.IsDirectory != nil </span><span class="cov7" title="8">{
                conditions = append(conditions, "is_directory = ?")
                args = append(args, *req.IsDirectory)
        }</span>

        // Build final queries
        <span class="cov7" title="8">whereClause := ""
        if len(conditions) &gt; 0 </span><span class="cov7" title="8">{
                whereClause = " AND " + strings.Join(conditions, " AND ")
        }</span>

        // Get total count
        <span class="cov7" title="8">var total int64
        err := s.db.QueryRow(countQuery+whereClause, args...).Scan(&amp;total)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("failed to count results: %w", err)
        }</span>

        // Add sorting and pagination to main query
        <span class="cov7" title="7">query := baseQuery + whereClause

        // Add sorting
        switch req.SortBy </span>{
        case "name":<span class="cov0" title="0">
                query += " ORDER BY name"</span>
        case "size":<span class="cov0" title="0">
                query += " ORDER BY size"</span>
        case "modified":<span class="cov0" title="0">
                query += " ORDER BY last_modified"</span>
        default:<span class="cov7" title="7">
                query += " ORDER BY is_directory DESC, name"</span>
        }

        <span class="cov7" title="7">if req.SortOrder == "desc" </span><span class="cov0" title="0">{
                query += " DESC"
        }</span> else<span class="cov7" title="7"> {
                query += " ASC"
        }</span>

        // Add pagination
        <span class="cov7" title="7">if req.Limit &gt; 0 </span><span class="cov7" title="7">{
                query += " LIMIT ?"
                args = append(args, req.Limit)
        }</span>
        <span class="cov7" title="7">if req.Offset &gt; 0 </span><span class="cov3" title="2">{
                query += " OFFSET ?"
                args = append(args, req.Offset)
        }</span>

        // Execute main query
        <span class="cov7" title="7">rows, err := s.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to search files: %w", err)
        }</span>
        <span class="cov7" title="7">defer rows.Close()

        var files []models.FileInfo
        for rows.Next() </span><span class="cov10" title="17">{
                var file models.FileInfo
                var mediaType *string
                var lastModified sql.NullTime
                var createdAt sql.NullTime
                var updatedAt sql.NullTime
                err := rows.Scan(
                        &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory, &amp;file.Size,
                        &amp;lastModified, &amp;file.Hash, &amp;file.Extension, &amp;file.MimeType,
                        &amp;mediaType, &amp;file.ParentID, &amp;file.SmbRoot, &amp;createdAt, &amp;updatedAt,
                )
                if mediaType != nil </span><span class="cov10" title="17">{
                        file.MediaType = mediaType
                }</span>
                <span class="cov10" title="17">if lastModified.Valid </span><span class="cov0" title="0">{
                        file.LastModified = lastModified.Time
                }</span>
                <span class="cov10" title="17">if createdAt.Valid </span><span class="cov10" title="17">{
                        file.CreatedAt = createdAt.Time
                }</span>
                <span class="cov10" title="17">if updatedAt.Valid </span><span class="cov10" title="17">{
                        file.UpdatedAt = updatedAt.Time
                }</span>
                <span class="cov10" title="17">if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to scan file: %w", err)
                }</span>
                <span class="cov10" title="17">if file.IsDirectory </span><span class="cov0" title="0">{
                        file.Type = "directory"
                }</span> else<span class="cov10" title="17"> {
                        file.Type = "file"
                }</span>
                <span class="cov10" title="17">files = append(files, file)</span>
        }

        <span class="cov7" title="7">return files, total, nil</span>
}

func (s *CatalogService) GetDirectoriesBySize(smbRoot string, limit int) ([]models.DirectoryStats, error) <span class="cov1" title="1">{
        query := `
                WITH RECURSIVE dir_sizes AS (
                        SELECT
                                id, path, name, is_directory,
                                CASE WHEN is_directory THEN 0 ELSE size END as file_size,
                                CASE WHEN is_directory THEN 0 ELSE 1 END as file_count
                        FROM files
                        WHERE smb_root = ? AND is_directory = true

                        UNION ALL

                        SELECT
                                f.id, f.path, f.name, f.is_directory,
                                CASE WHEN f.is_directory THEN 0 ELSE f.size END,
                                CASE WHEN f.is_directory THEN 0 ELSE 1 END
                        FROM files f
                        JOIN dir_sizes ds ON f.parent_id = ds.id
                        WHERE f.smb_root = ?
                )
                SELECT
                        path,
                        SUM(file_size) as total_size,
                        SUM(file_count) as file_count,
                        COUNT(CASE WHEN is_directory THEN 1 END) as directory_count
                FROM dir_sizes
                WHERE is_directory = true
                GROUP BY path
                ORDER BY total_size DESC
                LIMIT ?
        `

        rows, err := s.db.Query(query, smbRoot, smbRoot, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get directories by size: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        var stats []models.DirectoryStats
        for rows.Next() </span><span class="cov5" title="4">{
                var stat models.DirectoryStats
                err := rows.Scan(&amp;stat.Path, &amp;stat.TotalSize, &amp;stat.FileCount, &amp;stat.DirectoryCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan directory stats: %w", err)
                }</span>
                <span class="cov5" title="4">stats = append(stats, stat)</span>
        }

        <span class="cov1" title="1">return stats, nil</span>
}

func (s *CatalogService) GetDuplicateGroups(smbRoot string, minCount int, limit int) ([]models.DuplicateGroup, error) <span class="cov1" title="1">{
        query := `
                SELECT
                        hash, size, COUNT(*) as count
                FROM files
                WHERE hash IS NOT NULL
                        AND is_directory = false
        `
        args := []interface{}{}

        if smbRoot != "" </span><span class="cov0" title="0">{
                query += " AND smb_root = ?"
                args = append(args, smbRoot)
        }</span>

        <span class="cov1" title="1">query += `
                GROUP BY hash, size
                HAVING COUNT(*) &gt;= ?
                ORDER BY COUNT(*) DESC, size DESC
        `
        args = append(args, minCount)

        if limit &gt; 0 </span><span class="cov0" title="0">{
                query += " LIMIT ?"
                args = append(args, limit)
        }</span>

        <span class="cov1" title="1">rows, err := s.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get duplicate groups: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        var groups []models.DuplicateGroup
        for rows.Next() </span><span class="cov1" title="1">{
                var group models.DuplicateGroup
                err := rows.Scan(&amp;group.Hash, &amp;group.Size, &amp;group.Count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan duplicate group: %w", err)
                }</span>

                // Get files in this duplicate group
                <span class="cov1" title="1">filesQuery := `
                        SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, parent_id, smb_root, created_at, updated_at
                        FROM files
                        WHERE hash = ? AND size = ?
                `
                args2 := []interface{}{group.Hash, group.Size}

                if smbRoot != "" </span><span class="cov0" title="0">{
                        filesQuery += " AND smb_root = ?"
                        args2 = append(args2, smbRoot)
                }</span>

                <span class="cov1" title="1">filesQuery += " ORDER BY path"

                fileRows, err := s.db.Query(filesQuery, args2...)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to get files for duplicate group", zap.Error(err))
                        continue</span>
                }

                <span class="cov1" title="1">for fileRows.Next() </span><span class="cov3" title="2">{
                        var file models.FileInfo
                        var lastModified sql.NullTime
                        var createdAt sql.NullTime
                        var updatedAt sql.NullTime
                        err := fileRows.Scan(
                                &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory, &amp;file.Size,
                                &amp;lastModified, &amp;file.Hash, &amp;file.Extension, &amp;file.MimeType,
                                &amp;file.ParentID, &amp;file.SmbRoot, &amp;createdAt, &amp;updatedAt,
                        )
                        if lastModified.Valid </span><span class="cov0" title="0">{
                                file.LastModified = lastModified.Time
                        }</span>
                        <span class="cov3" title="2">if createdAt.Valid </span><span class="cov3" title="2">{
                                file.CreatedAt = createdAt.Time
                        }</span>
                        <span class="cov3" title="2">if updatedAt.Valid </span><span class="cov3" title="2">{
                                file.UpdatedAt = updatedAt.Time
                        }</span>
                        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to scan duplicate file", zap.Error(err))
                                continue</span>
                        }
                        <span class="cov3" title="2">group.Files = append(group.Files, file)</span>
                }
                <span class="cov1" title="1">fileRows.Close()

                group.TotalSize = group.Size * int64(group.Count)
                groups = append(groups, group)</span>
        }

        <span class="cov1" title="1">return groups, nil</span>
}

func (s *CatalogService) GetSMBRoots() ([]string, error) <span class="cov0" title="0">{
        query := `SELECT DISTINCT smb_root FROM files ORDER BY smb_root`

        rows, err := s.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get SMB roots: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var roots []string
        for rows.Next() </span><span class="cov0" title="0">{
                var root string
                if err := rows.Scan(&amp;root); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan SMB root: %w", err)
                }</span>
                <span class="cov0" title="0">roots = append(roots, root)</span>
        }

        <span class="cov0" title="0">return roots, nil</span>
}

// ListDirectory lists files in a directory (alias for ListPath)
func (s *CatalogService) ListDirectory(path string) ([]models.FileInfo, error) <span class="cov5" title="4">{
        return s.ListPath(path, "name", "asc", 0, 0)
}</span>

// Search searches files by query (simplified version)
func (s *CatalogService) Search(query string, fileType string, limit int, offset int) ([]models.FileInfo, error) <span class="cov7" title="8">{
        isDirectory := false
        req := &amp;models.SearchRequest{
                Query:       query,
                MimeType:    fileType,
                IsDirectory: &amp;isDirectory,
                Limit:       limit,
                Offset:      offset,
        }
        files, _, err := s.SearchFiles(req)
        return files, err
}</span>

// SearchDuplicates searches for duplicate files
func (s *CatalogService) SearchDuplicates() ([]models.DuplicateGroup, error) <span class="cov1" title="1">{
        return s.GetDuplicateGroups("", 2, 0)
}</span>

// GetFileInfoByPath gets file info by path (for test compatibility)
func (s *CatalogService) GetFileInfoByPath(path string) (*models.FileInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, media_type, parent_id, smb_root, created_at, updated_at
                FROM files
                WHERE path = ?
        `

        var file models.FileInfo
        var mediaType *string
        var lastModified sql.NullTime
        var createdAt sql.NullTime
        var updatedAt sql.NullTime
        err := s.db.QueryRow(query, path).Scan(
                &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory, &amp;file.Size,
                &amp;lastModified, &amp;file.Hash, &amp;file.Extension, &amp;file.MimeType,
                &amp;mediaType, &amp;file.ParentID, &amp;file.SmbRoot, &amp;createdAt, &amp;updatedAt,
        )
        if mediaType != nil </span><span class="cov0" title="0">{
                file.MediaType = mediaType
        }</span>
        <span class="cov0" title="0">if lastModified.Valid </span><span class="cov0" title="0">{
                file.LastModified = lastModified.Time
        }</span>
        <span class="cov0" title="0">if createdAt.Valid </span><span class="cov0" title="0">{
                file.CreatedAt = createdAt.Time
        }</span>
        <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                file.UpdatedAt = updatedAt.Time
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get file info by path: %w", err)</span>
        }

        <span class="cov0" title="0">if file.IsDirectory </span><span class="cov0" title="0">{
                file.Type = "directory"
        }</span> else<span class="cov0" title="0"> {
                file.Type = "file"
        }</span>

        <span class="cov0" title="0">return &amp;file, nil</span>
}

// GetDuplicatesCount gets the count of duplicate files
func (s *CatalogService) GetDuplicatesCount() (int64, error) <span class="cov3" title="2">{
        query := `
                SELECT COUNT(*) FROM (
                        SELECT hash, COUNT(*) as count
                        FROM files
                        WHERE hash IS NOT NULL AND hash != '' AND is_directory = false
                        GROUP BY hash
                        HAVING COUNT(*) &gt; 1
                )
        `

        var count int64
        err := s.db.QueryRow(query).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get duplicates count: %w", err)
        }</span>

        <span class="cov3" title="2">return count, nil</span>
}

// GetDirectoriesBySizeLimited gets directories by size with default limit
func (s *CatalogService) GetDirectoriesBySizeLimited(limit int) ([]models.DirectoryStats, error) <span class="cov0" title="0">{
        return s.GetDirectoriesBySize("", limit)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "database/sql"
        "encoding/hex"
        "fmt"
        "image"
        "image/jpeg"
        "image/png"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "time"

        "go.uber.org/zap"
        "golang.org/x/image/draw"
)

// CoverArtService handles cover art retrieval, processing, and caching
type CoverArtService struct {
        db         *sql.DB
        logger     *zap.Logger
        httpClient *http.Client
        apiKeys    map[string]string
        cacheDir   string
}

// CoverArtProvider represents different cover art providers
type CoverArtProvider string

const (
        CoverArtProviderMusicBrainz CoverArtProvider = "musicbrainz"
        CoverArtProviderLastFM      CoverArtProvider = "lastfm"
        CoverArtProviderSpotify     CoverArtProvider = "spotify"
        CoverArtProviderDeezer      CoverArtProvider = "deezer"
        CoverArtProviderITunes      CoverArtProvider = "itunes"
        CoverArtProviderDiscogs     CoverArtProvider = "discogs"
        CoverArtProviderEmbedded    CoverArtProvider = "embedded"
        CoverArtProviderLocal       CoverArtProvider = "local"
)

// CoverArtQuality represents different quality levels
type CoverArtQuality string

const (
        QualityThumbnail CoverArtQuality = "thumbnail" // 150x150
        QualityMedium    CoverArtQuality = "medium"    // 300x300
        QualityHigh      CoverArtQuality = "high"      // 600x600
        QualityOriginal  CoverArtQuality = "original"  // Original size
)

// CoverArtSearchRequest represents a cover art search request
type CoverArtSearchRequest struct {
        Title         string             `json:"title"`
        Artist        string             `json:"artist"`
        Album         *string            `json:"album,omitempty"`
        Year          *int               `json:"year,omitempty"`
        MusicBrainzID *string            `json:"musicbrainz_id,omitempty"`
        SpotifyID     *string            `json:"spotify_id,omitempty"`
        Quality       CoverArtQuality    `json:"quality"`
        Providers     []CoverArtProvider `json:"providers,omitempty"`
        UseCache      bool               `json:"use_cache"`
}

// CoverArtSearchResult represents a cover art search result
type CoverArtSearchResult struct {
        ID           string           `json:"id"`
        Provider     CoverArtProvider `json:"provider"`
        Title        string           `json:"title"`
        Artist       string           `json:"artist"`
        Album        *string          `json:"album,omitempty"`
        URL          string           `json:"url"`
        ThumbnailURL *string          `json:"thumbnail_url,omitempty"`
        Width        int              `json:"width"`
        Height       int              `json:"height"`
        Format       string           `json:"format"`
        Quality      CoverArtQuality  `json:"quality"`
        Size         *int64           `json:"size,omitempty"`
        MatchScore   float64          `json:"match_score"`
        Copyright    *string          `json:"copyright,omitempty"`
        Source       string           `json:"source"`
}

// CoverArtDownloadRequest represents a cover art download request
type CoverArtDownloadRequest struct {
        MediaItemID   int64             `json:"media_item_id"`
        ResultID      string            `json:"result_id"`
        Quality       CoverArtQuality   `json:"quality"`
        GenerateSizes []CoverArtQuality `json:"generate_sizes,omitempty"`
        SetAsDefault  bool              `json:"set_as_default"`
}

// VideoThumbnailRequest represents a video thumbnail generation request
type VideoThumbnailRequest struct {
        MediaItemID   int64             `json:"media_item_id"`
        VideoPath     string            `json:"video_path"`
        Timestamps    []float64         `json:"timestamps,omitempty"` // Seconds
        Quality       CoverArtQuality   `json:"quality"`
        GenerateSizes []CoverArtQuality `json:"generate_sizes,omitempty"`
        Count         int               `json:"count"` // Number of thumbnails to generate
}

// LocalCoverArtScanRequest represents a request to scan for local cover art
type LocalCoverArtScanRequest struct {
        MediaItemID int64  `json:"media_item_id"`
        Directory   string `json:"directory"`
        Recursive   bool   `json:"recursive"`
}

// CoverArtProcessingOptions represents image processing options
type CoverArtProcessingOptions struct {
        Width           int     `json:"width"`
        Height          int     `json:"height"`
        Quality         int     `json:"quality"`                    // JPEG quality 1-100
        Format          string  `json:"format"`                     // "jpeg", "png", "webp"
        Crop            bool    `json:"crop"`                       // Crop to exact dimensions
        PreserveAspect  bool    `json:"preserve_aspect"`            // Preserve aspect ratio
        BackgroundColor *string `json:"background_color,omitempty"` // Hex color for padding
}

// NewCoverArtService creates a new cover art service
func NewCoverArtService(db *sql.DB, logger *zap.Logger) *CoverArtService <span class="cov0" title="0">{
        return &amp;CoverArtService{
                db:         db,
                logger:     logger,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                apiKeys:    make(map[string]string),
                cacheDir:   "./cache/cover_art",
        }
}</span>

// SearchCoverArt searches for cover art across multiple providers
func (s *CoverArtService) SearchCoverArt(ctx context.Context, request *CoverArtSearchRequest) ([]CoverArtSearchResult, error) <span class="cov0" title="0">{
        s.logger.Info("Searching cover art",
                zap.String("title", request.Title),
                zap.String("artist", request.Artist),
                zap.String("album", getStringValue(request.Album)))

        // Check cache first if requested
        if request.UseCache </span><span class="cov0" title="0">{
                if cached := s.getCachedCoverArt(ctx, request); cached != nil </span><span class="cov0" title="0">{
                        return []CoverArtSearchResult{*cached}, nil
                }</span>
        }

        <span class="cov0" title="0">var allResults []CoverArtSearchResult

        // Default providers if none specified
        providers := request.Providers
        if len(providers) == 0 </span><span class="cov0" title="0">{
                providers = []CoverArtProvider{
                        CoverArtProviderMusicBrainz,
                        CoverArtProviderLastFM,
                        CoverArtProviderITunes,
                }
        }</span>

        // Search each provider
        <span class="cov0" title="0">for _, provider := range providers </span><span class="cov0" title="0">{
                results, err := s.searchProvider(ctx, provider, request)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Provider search failed",
                                zap.String("provider", string(provider)),
                                zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">allResults = append(allResults, results...)</span>
        }

        // Sort by match score and quality
        <span class="cov0" title="0">s.sortCoverArtResults(allResults)

        s.logger.Info("Cover art search completed",
                zap.Int("total_results", len(allResults)))

        return allResults, nil</span>
}

// DownloadCoverArt downloads and processes cover art
func (s *CoverArtService) DownloadCoverArt(ctx context.Context, request *CoverArtDownloadRequest) (*CoverArt, error) <span class="cov0" title="0">{
        s.logger.Info("Downloading cover art",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("result_id", request.ResultID))

        // Get download info
        result, err := s.getCoverArtDownloadInfo(ctx, request.ResultID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get download info: %w", err)
        }</span>

        // Download image
        <span class="cov0" title="0">imageData, err := s.downloadImage(ctx, result.URL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to download image: %w", err)
        }</span>

        // Process and save image
        <span class="cov0" title="0">coverArt, err := s.processAndSaveCoverArt(ctx, request.MediaItemID, imageData, result, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to process cover art: %w", err)
        }</span>

        // Generate additional sizes if requested
        <span class="cov0" title="0">if len(request.GenerateSizes) &gt; 0 </span><span class="cov0" title="0">{
                go s.generateAdditionalSizes(ctx, coverArt, request.GenerateSizes)
        }</span>

        // Set as default if requested
        <span class="cov0" title="0">if request.SetAsDefault </span><span class="cov0" title="0">{
                if err := s.setDefaultCoverArt(ctx, request.MediaItemID, coverArt.ID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to set as default cover art", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return coverArt, nil</span>
}

// GenerateVideoThumbnails generates thumbnails for video files
func (s *CoverArtService) GenerateVideoThumbnails(ctx context.Context, request *VideoThumbnailRequest) ([]*CoverArt, error) <span class="cov0" title="0">{
        s.logger.Info("Generating video thumbnails",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("video_path", request.VideoPath))

        // Get video duration
        duration, err := s.getVideoDuration(request.VideoPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get video duration: %w", err)
        }</span>

        // Generate timestamps if not provided
        <span class="cov0" title="0">timestamps := request.Timestamps
        if len(timestamps) == 0 </span><span class="cov0" title="0">{
                timestamps = s.generateTimestamps(duration, request.Count)
        }</span>

        <span class="cov0" title="0">var thumbnails []*CoverArt

        // Generate thumbnail for each timestamp
        for i, timestamp := range timestamps </span><span class="cov0" title="0">{
                thumbnail, err := s.generateVideoThumbnail(ctx, request, timestamp, i)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to generate thumbnail",
                                zap.Float64("timestamp", timestamp),
                                zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">thumbnails = append(thumbnails, thumbnail)</span>
        }

        <span class="cov0" title="0">return thumbnails, nil</span>
}

// ScanLocalCoverArt scans directory for local cover art files
func (s *CoverArtService) ScanLocalCoverArt(ctx context.Context, request *LocalCoverArtScanRequest) ([]*CoverArt, error) <span class="cov0" title="0">{
        s.logger.Info("Scanning local cover art",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("directory", request.Directory))

        var coverArts []*CoverArt

        // Common cover art filenames
        coverFilenames := []string{
                "cover.jpg", "cover.jpeg", "cover.png",
                "folder.jpg", "folder.jpeg", "folder.png",
                "album.jpg", "album.jpeg", "album.png",
                "front.jpg", "front.jpeg", "front.png",
                "albumart.jpg", "albumart.jpeg", "albumart.png",
        }

        // Scan directory
        files, err := os.ReadDir(request.Directory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                if file.IsDir() &amp;&amp; request.Recursive </span><span class="cov0" title="0">{
                        // Recursively scan subdirectories
                        subRequest := *request
                        subRequest.Directory = filepath.Join(request.Directory, file.Name())
                        subCoverArts, err := s.ScanLocalCoverArt(ctx, &amp;subRequest)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to scan subdirectory", zap.Error(err))
                                continue</span>
                        }
                        <span class="cov0" title="0">coverArts = append(coverArts, subCoverArts...)
                        continue</span>
                }

                // Check if file is a potential cover art
                <span class="cov0" title="0">filename := strings.ToLower(file.Name())
                for _, coverFilename := range coverFilenames </span><span class="cov0" title="0">{
                        if filename == coverFilename || strings.HasPrefix(filename, strings.TrimSuffix(coverFilename, filepath.Ext(coverFilename))) </span><span class="cov0" title="0">{
                                filePath := filepath.Join(request.Directory, file.Name())
                                coverArt, err := s.processLocalCoverArt(ctx, request.MediaItemID, filePath)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Warn("Failed to process local cover art",
                                                zap.String("file", filePath),
                                                zap.Error(err))
                                        continue</span>
                                }
                                <span class="cov0" title="0">coverArts = append(coverArts, coverArt)
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return coverArts, nil</span>
}

// GetCoverArt returns cover art for a media item
func (s *CoverArtService) GetCoverArt(ctx context.Context, mediaItemID int64) (*CoverArt, error) <span class="cov0" title="0">{
        query := `
                SELECT id, media_item_id, source, url, local_path, width, height,
                       format, size, quality, created_at, cached_at
                FROM cover_art WHERE media_item_id = ? AND is_default = 1
                ORDER BY created_at DESC LIMIT 1`

        var coverArt CoverArt
        var url, localPath sql.NullString
        var size sql.NullInt64
        var cachedAt sql.NullTime

        err := s.db.QueryRowContext(ctx, query, mediaItemID).Scan(
                &amp;coverArt.ID, &amp;coverArt.MediaItemID, &amp;coverArt.Source,
                &amp;url, &amp;localPath, &amp;coverArt.Width, &amp;coverArt.Height,
                &amp;coverArt.Format, &amp;size, &amp;coverArt.Quality,
                &amp;coverArt.CreatedAt, &amp;cachedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil // No cover art found
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get cover art: %w", err)</span>
        }

        <span class="cov0" title="0">if url.Valid </span><span class="cov0" title="0">{
                coverArt.URL = &amp;url.String
        }</span>
        <span class="cov0" title="0">if localPath.Valid </span><span class="cov0" title="0">{
                coverArt.LocalPath = &amp;localPath.String
        }</span>
        <span class="cov0" title="0">if size.Valid </span><span class="cov0" title="0">{
                coverArt.Size = &amp;size.Int64
        }</span>
        <span class="cov0" title="0">if cachedAt.Valid </span><span class="cov0" title="0">{
                coverArt.CachedAt = &amp;cachedAt.Time
        }</span>

        <span class="cov0" title="0">return &amp;coverArt, nil</span>
}

// ProcessImage processes an image with specified options
func (s *CoverArtService) ProcessImage(inputPath string, outputPath string, options *CoverArtProcessingOptions) error <span class="cov0" title="0">{
        s.logger.Debug("Processing image",
                zap.String("input", inputPath),
                zap.String("output", outputPath))

        // Open input image
        inputFile, err := os.Open(inputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open input file: %w", err)
        }</span>
        <span class="cov0" title="0">defer inputFile.Close()

        // Decode image
        img, format, err := image.Decode(inputFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode image: %w", err)
        }</span>

        // Resize image
        <span class="cov0" title="0">resizedImg := s.resizeImage(img, options)

        // Create output file
        outputFile, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output file: %w", err)
        }</span>
        <span class="cov0" title="0">defer outputFile.Close()

        // Encode image
        switch strings.ToLower(options.Format) </span>{
        case "jpeg", "jpg":<span class="cov0" title="0">
                return jpeg.Encode(outputFile, resizedImg, &amp;jpeg.Options{Quality: options.Quality})</span>
        case "png":<span class="cov0" title="0">
                return png.Encode(outputFile, resizedImg)</span>
        default:<span class="cov0" title="0">
                // Default to original format
                switch format </span>{
                case "jpeg":<span class="cov0" title="0">
                        return jpeg.Encode(outputFile, resizedImg, &amp;jpeg.Options{Quality: options.Quality})</span>
                case "png":<span class="cov0" title="0">
                        return png.Encode(outputFile, resizedImg)</span>
                default:<span class="cov0" title="0">
                        return jpeg.Encode(outputFile, resizedImg, &amp;jpeg.Options{Quality: options.Quality})</span>
                }
        }
}

// Provider-specific implementations
func (s *CoverArtService) searchProvider(ctx context.Context, provider CoverArtProvider, request *CoverArtSearchRequest) ([]CoverArtSearchResult, error) <span class="cov0" title="0">{
        switch provider </span>{
        case CoverArtProviderMusicBrainz:<span class="cov0" title="0">
                return s.searchMusicBrainz(ctx, request)</span>
        case CoverArtProviderLastFM:<span class="cov0" title="0">
                return s.searchLastFM(ctx, request)</span>
        case CoverArtProviderITunes:<span class="cov0" title="0">
                return s.searchITunes(ctx, request)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported provider: %s", provider)</span>
        }
}

func (s *CoverArtService) searchMusicBrainz(ctx context.Context, request *CoverArtSearchRequest) ([]CoverArtSearchResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Searching MusicBrainz",
                zap.String("artist", request.Artist),
                zap.String("album", getStringValue(request.Album)))

        // Mock implementation for demonstration
        result := CoverArtSearchResult{
                ID:         "mb_1",
                Provider:   CoverArtProviderMusicBrainz,
                Title:      request.Title,
                Artist:     request.Artist,
                Album:      request.Album,
                URL:        "https://coverartarchive.org/sample/front.jpg",
                Width:      500,
                Height:     500,
                Format:     "jpeg",
                Quality:    QualityHigh,
                MatchScore: 0.9,
                Source:     "coverartarchive.org",
        }

        return []CoverArtSearchResult{result}, nil
}</span>

func (s *CoverArtService) searchLastFM(ctx context.Context, request *CoverArtSearchRequest) ([]CoverArtSearchResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Searching Last.FM")

        result := CoverArtSearchResult{
                ID:         "lastfm_1",
                Provider:   CoverArtProviderLastFM,
                Title:      request.Title,
                Artist:     request.Artist,
                Album:      request.Album,
                URL:        "https://lastfm-img2.akamaized.net/sample.jpg",
                Width:      300,
                Height:     300,
                Format:     "jpeg",
                Quality:    QualityMedium,
                MatchScore: 0.85,
                Source:     "last.fm",
        }

        return []CoverArtSearchResult{result}, nil
}</span>

func (s *CoverArtService) searchITunes(ctx context.Context, request *CoverArtSearchRequest) ([]CoverArtSearchResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Searching iTunes")

        result := CoverArtSearchResult{
                ID:         "itunes_1",
                Provider:   CoverArtProviderITunes,
                Title:      request.Title,
                Artist:     request.Artist,
                Album:      request.Album,
                URL:        "https://is1-ssl.mzstatic.com/sample.jpg",
                Width:      600,
                Height:     600,
                Format:     "jpeg",
                Quality:    QualityHigh,
                MatchScore: 0.92,
                Source:     "itunes.apple.com",
        }

        return []CoverArtSearchResult{result}, nil
}</span>

// Helper functions
func (s *CoverArtService) downloadImage(ctx context.Context, url string) ([]byte, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP %d: %s", resp.StatusCode, resp.Status)
        }</span>

        <span class="cov0" title="0">return io.ReadAll(resp.Body)</span>
}

func (s *CoverArtService) resizeImage(img image.Image, options *CoverArtProcessingOptions) image.Image <span class="cov0" title="0">{
        bounds := img.Bounds()
        srcWidth := bounds.Dx()
        srcHeight := bounds.Dy()

        dstWidth := options.Width
        dstHeight := options.Height

        if options.PreserveAspect </span><span class="cov0" title="0">{
                // Calculate dimensions preserving aspect ratio
                aspectRatio := float64(srcWidth) / float64(srcHeight)
                if float64(dstWidth)/float64(dstHeight) &gt; aspectRatio </span><span class="cov0" title="0">{
                        dstWidth = int(float64(dstHeight) * aspectRatio)
                }</span> else<span class="cov0" title="0"> {
                        dstHeight = int(float64(dstWidth) / aspectRatio)
                }</span>
        }

        // Create destination image
        <span class="cov0" title="0">dst := image.NewRGBA(image.Rect(0, 0, dstWidth, dstHeight))

        // Resize image
        draw.BiLinear.Scale(dst, dst.Bounds(), img, bounds, draw.Over, nil)

        return dst</span>
}

func (s *CoverArtService) generateTimestamps(duration float64, count int) []float64 <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                count = 3 // Default to 3 thumbnails
        }</span>

        <span class="cov0" title="0">var timestamps []float64
        interval := duration / float64(count+1)

        for i := 1; i &lt;= count; i++ </span><span class="cov0" title="0">{
                timestamps = append(timestamps, interval*float64(i))
        }</span>

        <span class="cov0" title="0">return timestamps</span>
}

func (s *CoverArtService) generateCoverArtID() string <span class="cov0" title="0">{
        return fmt.Sprintf("cover_%d", time.Now().UnixNano())
}</span>

func (s *CoverArtService) generateCacheKey(request *CoverArtSearchRequest) string <span class="cov0" title="0">{
        data := fmt.Sprintf("%s_%s_%s_%s", request.Artist, request.Title,
                getStringValue(request.Album), request.Quality)
        hash := md5.Sum([]byte(data))
        return hex.EncodeToString(hash[:])
}</span>

func (s *CoverArtService) sortCoverArtResults(results []CoverArtSearchResult) <span class="cov0" title="0">{
        // Sort by match score descending, then by quality/size
        for i := 0; i &lt; len(results)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(results); j++ </span><span class="cov0" title="0">{
                        if results[i].MatchScore &lt; results[j].MatchScore ||
                                (results[i].MatchScore == results[j].MatchScore &amp;&amp; results[i].Width &lt; results[j].Width) </span><span class="cov0" title="0">{
                                results[i], results[j] = results[j], results[i]
                        }</span>
                }
        }
}

// getCachedCoverArt retrieves cached cover art from the database
func (s *CoverArtService) getCachedCoverArt(ctx context.Context, request *CoverArtSearchRequest) *CoverArtSearchResult <span class="cov0" title="0">{
        // Generate cache key based on request parameters
        cacheKey := s.generateCacheKey(request)

        query := `
                SELECT id, provider, title, artist, album, url, thumbnail_url, width, height,
                       format, quality, size, match_score, source, created_at
                FROM cover_art_cache
                WHERE cache_key = ? AND created_at &gt; ?
                ORDER BY match_score DESC
                LIMIT 1
        `

        // Cache valid for 30 days
        cacheExpiry := time.Now().Add(-30 * 24 * time.Hour)

        var result CoverArtSearchResult
        var album sql.NullString
        var thumbnailURL sql.NullString
        var size sql.NullInt64
        var createdAt time.Time

        err := s.db.QueryRowContext(ctx, query, cacheKey, cacheExpiry).Scan(
                &amp;result.ID, &amp;result.Provider, &amp;result.Title, &amp;result.Artist,
                &amp;album, &amp;result.URL, &amp;thumbnailURL, &amp;result.Width, &amp;result.Height,
                &amp;result.Format, &amp;result.Quality, &amp;size, &amp;result.MatchScore,
                &amp;result.Source, &amp;createdAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to get cached cover art", zap.Error(err))
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">if album.Valid </span><span class="cov0" title="0">{
                result.Album = &amp;album.String
        }</span>
        <span class="cov0" title="0">if thumbnailURL.Valid </span><span class="cov0" title="0">{
                result.ThumbnailURL = &amp;thumbnailURL.String
        }</span>
        <span class="cov0" title="0">if size.Valid </span><span class="cov0" title="0">{
                result.Size = &amp;size.Int64
        }</span>

        <span class="cov0" title="0">return &amp;result</span>
}

// getCoverArtDownloadInfo retrieves cover art download information
func (s *CoverArtService) getCoverArtDownloadInfo(ctx context.Context, resultID string) (*CoverArtSearchResult, error) <span class="cov0" title="0">{
        // For now, return a placeholder - in a real implementation, this would query the database
        // or search results cache for the specific result ID
        return &amp;CoverArtSearchResult{
                ID:       resultID,
                Provider: CoverArtProviderLocal,
                URL:      "",
                Quality:  QualityHigh,
                Source:   "cache",
        }, nil
}</span>

// processAndSaveCoverArt processes and saves cover art
func (s *CoverArtService) processAndSaveCoverArt(ctx context.Context, mediaItemID int64, imageData []byte, result *CoverArtSearchResult, request *CoverArtDownloadRequest) (*CoverArt, error) <span class="cov0" title="0">{
        // Decode image
        img, format, err := image.Decode(strings.NewReader(string(imageData)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode image: %w", err)
        }</span>

        // Get image dimensions
        <span class="cov0" title="0">bounds := img.Bounds()
        width := bounds.Dx()
        height := bounds.Dy()

        // Generate local path
        coverID := s.generateCoverArtID()
        filename := fmt.Sprintf("%s.%s", coverID, format)
        localPath := filepath.Join(s.cacheDir, filename)

        // Ensure cache directory exists
        if err := os.MkdirAll(s.cacheDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cache directory: %w", err)
        }</span>

        // Save image
        <span class="cov0" title="0">outFile, err := os.Create(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov0" title="0">defer outFile.Close()

        switch format </span>{
        case "jpeg", "jpg":<span class="cov0" title="0">
                err = jpeg.Encode(outFile, img, &amp;jpeg.Options{Quality: 90})</span>
        case "png":<span class="cov0" title="0">
                err = png.Encode(outFile, img)</span>
        default:<span class="cov0" title="0">
                err = jpeg.Encode(outFile, img, &amp;jpeg.Options{Quality: 90})</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save image: %w", err)
        }</span>

        // Get file size
        <span class="cov0" title="0">fileInfo, err := os.Stat(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file info: %w", err)
        }</span>
        <span class="cov0" title="0">size := fileInfo.Size()

        // Create CoverArt record
        now := time.Now()
        coverArt := &amp;CoverArt{
                ID:          coverID,
                MediaItemID: mediaItemID,
                Source:      string(result.Provider),
                LocalPath:   &amp;localPath,
                Width:       &amp;width,
                Height:      &amp;height,
                Format:      format,
                Size:        &amp;size,
                Quality:     string(request.Quality),
                CreatedAt:   now,
                CachedAt:    &amp;now,
        }

        return coverArt, nil</span>
}

// generateAdditionalSizes generates additional sizes of cover art
func (s *CoverArtService) generateAdditionalSizes(ctx context.Context, coverArt *CoverArt, sizes []CoverArtQuality) <span class="cov0" title="0">{
        if coverArt.LocalPath == nil </span><span class="cov0" title="0">{
                s.logger.Warn("Cannot generate additional sizes: no local path")
                return
        }</span>

        // Open source image
        <span class="cov0" title="0">srcFile, err := os.Open(*coverArt.LocalPath)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to open source image", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer srcFile.Close()

        srcImg, _, err := image.Decode(srcFile)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to decode source image", zap.Error(err))
                return
        }</span>

        // Generate each size
        <span class="cov0" title="0">for _, quality := range sizes </span><span class="cov0" title="0">{
                targetSize := 0
                switch quality </span>{
                case QualityThumbnail:<span class="cov0" title="0">
                        targetSize = 150</span>
                case QualityMedium:<span class="cov0" title="0">
                        targetSize = 300</span>
                case QualityHigh:<span class="cov0" title="0">
                        targetSize = 600</span>
                default:<span class="cov0" title="0">
                        continue</span>
                }

                // Resize image
                <span class="cov0" title="0">newImg := image.NewRGBA(image.Rect(0, 0, targetSize, targetSize))
                draw.ApproxBiLinear.Scale(newImg, newImg.Bounds(), srcImg, srcImg.Bounds(), draw.Over, nil)

                // Save resized image
                resizedFilename := fmt.Sprintf("%s_%s.%s", coverArt.ID, quality, coverArt.Format)
                resizedPath := filepath.Join(s.cacheDir, resizedFilename)

                outFile, err := os.Create(resizedPath)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to create resized file",
                                zap.String("quality", string(quality)),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if coverArt.Format == "png" </span><span class="cov0" title="0">{
                        err = png.Encode(outFile, newImg)
                }</span> else<span class="cov0" title="0"> {
                        err = jpeg.Encode(outFile, newImg, &amp;jpeg.Options{Quality: 85})
                }</span>
                <span class="cov0" title="0">outFile.Close()

                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to encode resized image",
                                zap.String("quality", string(quality)),
                                zap.Error(err))
                }</span>
        }
}

// setDefaultCoverArt sets cover art as default for a media item
func (s *CoverArtService) setDefaultCoverArt(ctx context.Context, mediaItemID int64, coverArtID string) error <span class="cov0" title="0">{
        // In a real implementation, this would update the database to mark the cover art as default
        query := `UPDATE cover_art SET is_default = 0 WHERE media_item_id = ?`
        _, err := s.db.ExecContext(ctx, query, mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query = `UPDATE cover_art SET is_default = 1 WHERE id = ? AND media_item_id = ?`
        _, err = s.db.ExecContext(ctx, query, coverArtID, mediaItemID)
        return err</span>
}

// getVideoDuration gets the duration of a video file
func (s *CoverArtService) getVideoDuration(videoPath string) (float64, error) <span class="cov0" title="0">{
        // In a real implementation, this would use ffprobe or similar tool to get video duration
        // For now, return a placeholder duration
        return 120.0, nil
}</span>

// generateVideoThumbnail generates a thumbnail for a video at a specific timestamp
func (s *CoverArtService) generateVideoThumbnail(ctx context.Context, request *VideoThumbnailRequest, timestamp float64, index int) (*CoverArt, error) <span class="cov0" title="0">{
        // In a real implementation, this would use ffmpeg to extract a frame from the video
        // For now, return a placeholder
        coverID := fmt.Sprintf("video_thumb_%d_%d", request.MediaItemID, index)
        now := time.Now()

        return &amp;CoverArt{
                ID:          coverID,
                MediaItemID: request.MediaItemID,
                Source:      "video_thumbnail",
                Quality:     string(request.Quality),
                CreatedAt:   now,
        }, nil
}</span>

// processLocalCoverArt processes local cover art file
func (s *CoverArtService) processLocalCoverArt(ctx context.Context, mediaItemID int64, filePath string) (*CoverArt, error) <span class="cov0" title="0">{
        // Open and decode image
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        img, format, err := image.Decode(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get image dimensions
        <span class="cov0" title="0">bounds := img.Bounds()
        width := bounds.Dx()
        height := bounds.Dy()

        // Get file size
        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">size := fileInfo.Size()

        // Create CoverArt record
        coverID := s.generateCoverArtID()
        now := time.Now()

        coverArt := &amp;CoverArt{
                ID:          coverID,
                MediaItemID: mediaItemID,
                Source:      "local",
                LocalPath:   &amp;filePath,
                Width:       &amp;width,
                Height:      &amp;height,
                Format:      format,
                Size:        &amp;size,
                Quality:     "original",
                CreatedAt:   now,
        }

        return coverArt, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package services

import (
        "context"
        "fmt"
        neturl "net/url"
        "strings"
        "time"

        "catalogizer/internal/models"
)

type DeepLinkingService struct {
        baseURL    string
        apiVersion string
}

type DeepLinkRequest struct {
        MediaID       string                `json:"media_id"`
        MediaMetadata *models.MediaMetadata `json:"media_metadata"`
        TargetApp     string                `json:"target_app,omitempty"`
        Action        string                `json:"action"` // detail, play, download, edit
        Context       *LinkContext          `json:"context,omitempty"`
}

type LinkContext struct {
        UserID       string            `json:"user_id,omitempty"`
        DeviceID     string            `json:"device_id,omitempty"`
        SessionID    string            `json:"session_id,omitempty"`
        ReferrerPage string            `json:"referrer_page,omitempty"`
        Platform     string            `json:"platform,omitempty"` // web, android, ios, desktop
        AppVersion   string            `json:"app_version,omitempty"`
        Preferences  map[string]string `json:"preferences,omitempty"`
        UTMParams    *UTMParameters    `json:"utm_params,omitempty"`
}

type UTMParameters struct {
        Source   string `json:"utm_source,omitempty"`
        Medium   string `json:"utm_medium,omitempty"`
        Campaign string `json:"utm_campaign,omitempty"`
        Term     string `json:"utm_term,omitempty"`
        Content  string `json:"utm_content,omitempty"`
}

type DeepLinkResponse struct {
        Links         map[string]*DeepLink `json:"links"` // Platform -&gt; DeepLink
        UniversalLink string               `json:"universal_link"`
        QRCode        string               `json:"qr_code,omitempty"`
        ShareableLink string               `json:"shareable_link"`
        ExpiresAt     *time.Time           `json:"expires_at,omitempty"`
        TrackingID    string               `json:"tracking_id"`
        SupportedApps []string             `json:"supported_apps"`
        FallbackURL   string               `json:"fallback_url"`
}

type DeepLink struct {
        URL          string                 `json:"url"`
        Scheme       string                 `json:"scheme"`
        Package      string                 `json:"package,omitempty"`   // Android package name
        BundleID     string                 `json:"bundle_id,omitempty"` // iOS bundle ID
        StoreURL     string                 `json:"store_url,omitempty"` // App store download link
        Parameters   map[string]string      `json:"parameters"`
        Headers      map[string]string      `json:"headers,omitempty"`
        PostData     map[string]interface{} `json:"post_data,omitempty"`
        RequiresAuth bool                   `json:"requires_auth"`
        AppVersion   string                 `json:"min_app_version,omitempty"`
        Features     []string               `json:"required_features,omitempty"`
}

type LinkTrackingEvent struct {
        TrackingID   string                 `json:"tracking_id"`
        EventType    string                 `json:"event_type"` // click, open, fallback, error
        Platform     string                 `json:"platform"`
        UserAgent    string                 `json:"user_agent,omitempty"`
        IPAddress    string                 `json:"ip_address,omitempty"`
        Timestamp    time.Time              `json:"timestamp"`
        Success      bool                   `json:"success"`
        ErrorMessage string                 `json:"error_message,omitempty"`
        AppOpened    bool                   `json:"app_opened"`
        FallbackUsed bool                   `json:"fallback_used"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

type AppConfiguration struct {
        AppID         string            `json:"app_id"`
        Name          string            `json:"name"`
        Platforms     []string          `json:"platforms"`
        Schemes       map[string]string `json:"schemes"`      // Platform -&gt; URL scheme
        Packages      map[string]string `json:"packages"`     // Platform -&gt; package/bundle ID
        StoreURLs     map[string]string `json:"store_urls"`   // Platform -&gt; store download URL
        MinVersions   map[string]string `json:"min_versions"` // Platform -&gt; minimum version
        Features      []string          `json:"supported_features"`
        PreferredApps bool              `json:"is_preferred"`
        Active        bool              `json:"is_active"`
}

func NewDeepLinkingService(baseURL, apiVersion string) *DeepLinkingService <span class="cov0" title="0">{
        return &amp;DeepLinkingService{
                baseURL:    baseURL,
                apiVersion: apiVersion,
        }
}</span>

func (dls *DeepLinkingService) GenerateDeepLinks(ctx context.Context, req *DeepLinkRequest) (*DeepLinkResponse, error) <span class="cov0" title="0">{
        // Validate request
        if req.MediaID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("media ID is required")
        }</span>

        <span class="cov0" title="0">trackingID := dls.generateTrackingID()

        response := &amp;DeepLinkResponse{
                Links:         make(map[string]*DeepLink),
                TrackingID:    trackingID,
                SupportedApps: dls.getSupportedApps(),
                FallbackURL:   dls.generateFallbackURL(req),
        }

        // Generate universal link
        response.UniversalLink = dls.generateUniversalLink(req, trackingID)
        response.ShareableLink = response.UniversalLink

        // Generate platform-specific links
        platforms := []string{"web", "android", "ios", "desktop"}

        for _, platform := range platforms </span><span class="cov0" title="0">{
                link, err := dls.generatePlatformLink(ctx, req, platform, trackingID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip platforms that fail
                }
                <span class="cov0" title="0">response.Links[platform] = link</span>
        }

        // Generate QR code for easy sharing
        <span class="cov0" title="0">response.QRCode = dls.generateQRCodeURL(response.UniversalLink)

        // Set expiration for temporary links
        if req.Action == "play" || req.Action == "download" </span><span class="cov0" title="0">{
                expiresAt := time.Now().Add(24 * time.Hour)
                response.ExpiresAt = &amp;expiresAt
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}

func (dls *DeepLinkingService) generatePlatformLink(ctx context.Context, req *DeepLinkRequest, platform, trackingID string) (*DeepLink, error) <span class="cov0" title="0">{
        switch platform </span>{
        case "web":<span class="cov0" title="0">
                return dls.generateWebLink(req, trackingID)</span>
        case "android":<span class="cov0" title="0">
                return dls.generateAndroidLink(req, trackingID)</span>
        case "ios":<span class="cov0" title="0">
                return dls.generateIOSLink(req, trackingID)</span>
        case "desktop":<span class="cov0" title="0">
                return dls.generateDesktopLink(req, trackingID)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported platform: %s", platform)</span>
        }
}

func (dls *DeepLinkingService) generateWebLink(req *DeepLinkRequest, trackingID string) (*DeepLink, error) <span class="cov0" title="0">{
        baseURL := dls.baseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "https://catalogizer.app"
        }</span>

        <span class="cov0" title="0">var path string
        parameters := make(map[string]string)

        switch req.Action </span>{
        case "detail":<span class="cov0" title="0">
                path = fmt.Sprintf("/detail/%s", req.MediaID)</span>
        case "play":<span class="cov0" title="0">
                path = fmt.Sprintf("/play/%s", req.MediaID)
                parameters["autoplay"] = "true"</span>
        case "download":<span class="cov0" title="0">
                path = fmt.Sprintf("/download/%s", req.MediaID)</span>
        case "edit":<span class="cov0" title="0">
                path = fmt.Sprintf("/edit/%s", req.MediaID)</span>
        default:<span class="cov0" title="0">
                path = fmt.Sprintf("/detail/%s", req.MediaID)</span>
        }

        // Add context parameters
        <span class="cov0" title="0">if req.Context != nil </span><span class="cov0" title="0">{
                if req.Context.UserID != "" </span><span class="cov0" title="0">{
                        parameters["user_id"] = req.Context.UserID
                }</span>
                <span class="cov0" title="0">if req.Context.SessionID != "" </span><span class="cov0" title="0">{
                        parameters["session_id"] = req.Context.SessionID
                }</span>
                <span class="cov0" title="0">if req.Context.ReferrerPage != "" </span><span class="cov0" title="0">{
                        parameters["ref"] = req.Context.ReferrerPage
                }</span>

                // Add UTM parameters
                <span class="cov0" title="0">if req.Context.UTMParams != nil </span><span class="cov0" title="0">{
                        if req.Context.UTMParams.Source != "" </span><span class="cov0" title="0">{
                                parameters["utm_source"] = req.Context.UTMParams.Source
                        }</span>
                        <span class="cov0" title="0">if req.Context.UTMParams.Medium != "" </span><span class="cov0" title="0">{
                                parameters["utm_medium"] = req.Context.UTMParams.Medium
                        }</span>
                        <span class="cov0" title="0">if req.Context.UTMParams.Campaign != "" </span><span class="cov0" title="0">{
                                parameters["utm_campaign"] = req.Context.UTMParams.Campaign
                        }</span>
                        <span class="cov0" title="0">if req.Context.UTMParams.Term != "" </span><span class="cov0" title="0">{
                                parameters["utm_term"] = req.Context.UTMParams.Term
                        }</span>
                        <span class="cov0" title="0">if req.Context.UTMParams.Content != "" </span><span class="cov0" title="0">{
                                parameters["utm_content"] = req.Context.UTMParams.Content
                        }</span>
                }
        }

        // Add tracking
        <span class="cov0" title="0">parameters["track"] = trackingID

        // Build URL with parameters
        u, err := neturl.Parse(baseURL + path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">query := u.Query()
        for key, value := range parameters </span><span class="cov0" title="0">{
                query.Set(key, value)
        }</span>
        <span class="cov0" title="0">u.RawQuery = query.Encode()

        return &amp;DeepLink{
                URL:          u.String(),
                Scheme:       "https",
                Parameters:   parameters,
                RequiresAuth: req.Action == "edit" || req.Action == "download",
        }, nil</span>
}

func (dls *DeepLinkingService) generateAndroidLink(req *DeepLinkRequest, trackingID string) (*DeepLink, error) <span class="cov0" title="0">{
        scheme := "catalogizer"
        packageName := "com.catalogizer.app"

        var path string
        parameters := make(map[string]string)

        switch req.Action </span>{
        case "detail":<span class="cov0" title="0">
                path = fmt.Sprintf("detail/%s", req.MediaID)</span>
        case "play":<span class="cov0" title="0">
                path = fmt.Sprintf("play/%s", req.MediaID)
                parameters["autoplay"] = "true"</span>
        case "download":<span class="cov0" title="0">
                path = fmt.Sprintf("download/%s", req.MediaID)</span>
        case "edit":<span class="cov0" title="0">
                path = fmt.Sprintf("edit/%s", req.MediaID)</span>
        default:<span class="cov0" title="0">
                path = fmt.Sprintf("detail/%s", req.MediaID)</span>
        }

        // Add context
        <span class="cov0" title="0">if req.Context != nil </span><span class="cov0" title="0">{
                if req.Context.UserID != "" </span><span class="cov0" title="0">{
                        parameters["user_id"] = req.Context.UserID
                }</span>
                <span class="cov0" title="0">if req.Context.SessionID != "" </span><span class="cov0" title="0">{
                        parameters["session_id"] = req.Context.SessionID
                }</span>
        }

        // Add tracking
        <span class="cov0" title="0">parameters["track"] = trackingID

        // Build Android deep link
        url := fmt.Sprintf("%s://%s", scheme, path)
        if len(parameters) &gt; 0 </span><span class="cov0" title="0">{
                query := make([]string, 0, len(parameters))
                for key, value := range parameters </span><span class="cov0" title="0">{
                        query = append(query, fmt.Sprintf("%s=%s", key, neturl.QueryEscape(value)))
                }</span>
                <span class="cov0" title="0">url += "?" + strings.Join(query, "&amp;")</span>
        }

        <span class="cov0" title="0">return &amp;DeepLink{
                URL:          url,
                Scheme:       scheme,
                Package:      packageName,
                StoreURL:     "https://play.google.com/store/apps/details?id=" + packageName,
                Parameters:   parameters,
                RequiresAuth: req.Action == "edit" || req.Action == "download",
                AppVersion:   "1.0.0",
                Features:     dls.getRequiredFeatures(req),
        }, nil</span>
}

func (dls *DeepLinkingService) generateIOSLink(req *DeepLinkRequest, trackingID string) (*DeepLink, error) <span class="cov0" title="0">{
        scheme := "catalogizer"
        bundleID := "com.catalogizer.app"

        var path string
        parameters := make(map[string]string)

        switch req.Action </span>{
        case "detail":<span class="cov0" title="0">
                path = fmt.Sprintf("detail/%s", req.MediaID)</span>
        case "play":<span class="cov0" title="0">
                path = fmt.Sprintf("play/%s", req.MediaID)
                parameters["autoplay"] = "true"</span>
        case "download":<span class="cov0" title="0">
                path = fmt.Sprintf("download/%s", req.MediaID)</span>
        case "edit":<span class="cov0" title="0">
                path = fmt.Sprintf("edit/%s", req.MediaID)</span>
        default:<span class="cov0" title="0">
                path = fmt.Sprintf("detail/%s", req.MediaID)</span>
        }

        // Add context
        <span class="cov0" title="0">if req.Context != nil </span><span class="cov0" title="0">{
                if req.Context.UserID != "" </span><span class="cov0" title="0">{
                        parameters["user_id"] = req.Context.UserID
                }</span>
                <span class="cov0" title="0">if req.Context.SessionID != "" </span><span class="cov0" title="0">{
                        parameters["session_id"] = req.Context.SessionID
                }</span>
        }

        // Add tracking
        <span class="cov0" title="0">parameters["track"] = trackingID

        // Build iOS deep link
        url := fmt.Sprintf("%s://%s", scheme, path)
        if len(parameters) &gt; 0 </span><span class="cov0" title="0">{
                query := make([]string, 0, len(parameters))
                for key, value := range parameters </span><span class="cov0" title="0">{
                        query = append(query, fmt.Sprintf("%s=%s", key, neturl.QueryEscape(value)))
                }</span>
                <span class="cov0" title="0">url += "?" + strings.Join(query, "&amp;")</span>
        }

        <span class="cov0" title="0">return &amp;DeepLink{
                URL:          url,
                Scheme:       scheme,
                BundleID:     bundleID,
                StoreURL:     "https://apps.apple.com/app/id123456789", // Would be actual App Store ID
                Parameters:   parameters,
                RequiresAuth: req.Action == "edit" || req.Action == "download",
                AppVersion:   "1.0.0",
                Features:     dls.getRequiredFeatures(req),
        }, nil</span>
}

func (dls *DeepLinkingService) generateDesktopLink(req *DeepLinkRequest, trackingID string) (*DeepLink, error) <span class="cov0" title="0">{
        scheme := "catalogizer-desktop"

        var path string
        parameters := make(map[string]string)

        switch req.Action </span>{
        case "detail":<span class="cov0" title="0">
                path = fmt.Sprintf("detail/%s", req.MediaID)</span>
        case "play":<span class="cov0" title="0">
                path = fmt.Sprintf("play/%s", req.MediaID)
                parameters["autoplay"] = "true"</span>
        case "download":<span class="cov0" title="0">
                path = fmt.Sprintf("download/%s", req.MediaID)</span>
        case "edit":<span class="cov0" title="0">
                path = fmt.Sprintf("edit/%s", req.MediaID)</span>
        default:<span class="cov0" title="0">
                path = fmt.Sprintf("detail/%s", req.MediaID)</span>
        }

        // Add context
        <span class="cov0" title="0">if req.Context != nil </span><span class="cov0" title="0">{
                if req.Context.UserID != "" </span><span class="cov0" title="0">{
                        parameters["user_id"] = req.Context.UserID
                }</span>
                <span class="cov0" title="0">if req.Context.SessionID != "" </span><span class="cov0" title="0">{
                        parameters["session_id"] = req.Context.SessionID
                }</span>
        }

        // Add tracking
        <span class="cov0" title="0">parameters["track"] = trackingID

        // Build desktop deep link
        url := fmt.Sprintf("%s://%s", scheme, path)
        if len(parameters) &gt; 0 </span><span class="cov0" title="0">{
                query := make([]string, 0, len(parameters))
                for key, value := range parameters </span><span class="cov0" title="0">{
                        query = append(query, fmt.Sprintf("%s=%s", key, neturl.QueryEscape(value)))
                }</span>
                <span class="cov0" title="0">url += "?" + strings.Join(query, "&amp;")</span>
        }

        <span class="cov0" title="0">return &amp;DeepLink{
                URL:          url,
                Scheme:       scheme,
                StoreURL:     "https://github.com/catalogizer/desktop/releases", // GitHub releases
                Parameters:   parameters,
                RequiresAuth: req.Action == "edit" || req.Action == "download",
                AppVersion:   "1.0.0",
                Features:     dls.getRequiredFeatures(req),
        }, nil</span>
}

func (dls *DeepLinkingService) generateUniversalLink(req *DeepLinkRequest, trackingID string) string <span class="cov0" title="0">{
        baseURL := dls.baseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "https://catalogizer.app"
        }</span>

        <span class="cov0" title="0">switch req.Action </span>{
        case "detail":<span class="cov0" title="0">
                return fmt.Sprintf("%s/link/detail/%s?track=%s", baseURL, req.MediaID, trackingID)</span>
        case "play":<span class="cov0" title="0">
                return fmt.Sprintf("%s/link/play/%s?track=%s", baseURL, req.MediaID, trackingID)</span>
        case "download":<span class="cov0" title="0">
                return fmt.Sprintf("%s/link/download/%s?track=%s", baseURL, req.MediaID, trackingID)</span>
        case "edit":<span class="cov0" title="0">
                return fmt.Sprintf("%s/link/edit/%s?track=%s", baseURL, req.MediaID, trackingID)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%s/link/detail/%s?track=%s", baseURL, req.MediaID, trackingID)</span>
        }
}

func (dls *DeepLinkingService) generateFallbackURL(req *DeepLinkRequest) string <span class="cov0" title="0">{
        baseURL := dls.baseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "https://catalogizer.app"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s/detail/%s", baseURL, req.MediaID)</span>
}

func (dls *DeepLinkingService) generateQRCodeURL(link string) string <span class="cov0" title="0">{
        // Use a QR code generation service
        return fmt.Sprintf("https://api.qrserver.com/v1/create-qr-code/?size=200x200&amp;data=%s", neturl.QueryEscape(link))
}</span>

func (dls *DeepLinkingService) generateTrackingID() string <span class="cov0" title="0">{
        // Generate unique tracking ID
        return fmt.Sprintf("track_%d", time.Now().UnixNano())
}</span>

func (dls *DeepLinkingService) getSupportedApps() []string <span class="cov0" title="0">{
        return []string{
                "catalogizer-web",
                "catalogizer-android",
                "catalogizer-ios",
                "catalogizer-desktop",
                "catalogizer-tv",
        }
}</span>

func (dls *DeepLinkingService) getRequiredFeatures(req *DeepLinkRequest) []string <span class="cov0" title="0">{
        var features []string

        // Base features based on action
        if req.Action == "play" </span><span class="cov0" title="0">{
                features = append(features, "media_playback")
        }</span>

        <span class="cov0" title="0">if req.Action == "download" </span><span class="cov0" title="0">{
                features = append(features, "file_download")
        }</span>

        <span class="cov0" title="0">if req.Action == "edit" </span><span class="cov0" title="0">{
                features = append(features, "file_edit", "user_authentication")
        }</span>

        // Media type specific features
        <span class="cov0" title="0">if req.MediaMetadata != nil &amp;&amp; req.MediaMetadata.MediaType != "" </span><span class="cov0" title="0">{
                switch req.MediaMetadata.MediaType </span>{
                case "video":<span class="cov0" title="0">
                        if req.Action == "play" </span><span class="cov0" title="0">{
                                features = append(features, "video_playback", "fullscreen_video")
                        }</span>
                case "audio":<span class="cov0" title="0">
                        if req.Action == "play" </span><span class="cov0" title="0">{
                                features = append(features, "audio_playback", "background_audio")
                        }</span>
                case "book":<span class="cov0" title="0">
                        features = append(features, "pdf_reader", "epub_reader")</span>
                case "game":<span class="cov0" title="0">
                        features = append(features, "external_app_launch")</span>
                }
        }

        <span class="cov0" title="0">return features</span>
}

// Link tracking methods
func (dls *DeepLinkingService) TrackLinkEvent(ctx context.Context, event *LinkTrackingEvent) error <span class="cov0" title="0">{
        // This would normally store the event in a database or analytics service
        // For now, we'll just log it
        fmt.Printf("Link tracking event: %+v\n", event)
        return nil
}</span>

func (dls *DeepLinkingService) GetLinkAnalytics(ctx context.Context, trackingID string) (*LinkAnalytics, error) <span class="cov0" title="0">{
        // This would normally retrieve analytics from storage
        // Mock implementation
        return &amp;LinkAnalytics{
                TrackingID:   trackingID,
                TotalClicks:  45,
                UniqueClicks: 32,
                PlatformBreakdown: map[string]int{
                        "web":     20,
                        "android": 15,
                        "ios":     8,
                        "desktop": 2,
                },
                ConversionRate: 0.71, // 71% opened the app
                FirstClickAt:   time.Now().Add(-24 * time.Hour),
                LastClickAt:    time.Now().Add(-1 * time.Hour),
        }, nil
}</span>

type LinkAnalytics struct {
        TrackingID        string         `json:"tracking_id"`
        TotalClicks       int            `json:"total_clicks"`
        UniqueClicks      int            `json:"unique_clicks"`
        PlatformBreakdown map[string]int `json:"platform_breakdown"`
        ConversionRate    float64        `json:"conversion_rate"`
        FirstClickAt      time.Time      `json:"first_click_at"`
        LastClickAt       time.Time      `json:"last_click_at"`
}

// App registration and configuration
func (dls *DeepLinkingService) RegisterApp(ctx context.Context, config *AppConfiguration) error <span class="cov0" title="0">{
        // This would normally store the app configuration
        // For now, we'll just validate it
        if config.AppID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app_id is required")
        }</span>
        <span class="cov0" title="0">if config.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app name is required")
        }</span>
        <span class="cov0" title="0">if len(config.Platforms) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one platform is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (dls *DeepLinkingService) GetAppConfiguration(ctx context.Context, appID string) (*AppConfiguration, error) <span class="cov0" title="0">{
        // Mock implementation - would normally retrieve from storage
        return &amp;AppConfiguration{
                AppID:     appID,
                Name:      "Catalogizer",
                Platforms: []string{"web", "android", "ios", "desktop"},
                Schemes: map[string]string{
                        "web":     "https",
                        "android": "catalogizer",
                        "ios":     "catalogizer",
                        "desktop": "catalogizer-desktop",
                },
                Packages: map[string]string{
                        "android": "com.catalogizer.app",
                        "ios":     "com.catalogizer.app",
                },
                StoreURLs: map[string]string{
                        "android": "https://play.google.com/store/apps/details?id=com.catalogizer.app",
                        "ios":     "https://apps.apple.com/app/id123456789",
                        "desktop": "https://github.com/catalogizer/desktop/releases",
                },
                MinVersions: map[string]string{
                        "android": "1.0.0",
                        "ios":     "1.0.0",
                        "desktop": "1.0.0",
                },
                Features:      []string{"video_playback", "audio_playback", "pdf_reader", "file_download"},
                PreferredApps: true,
                Active:        true,
        }, nil
}</span>

// Smart link routing based on user context
func (dls *DeepLinkingService) GenerateSmartLink(ctx context.Context, req *DeepLinkRequest) (*SmartLinkResponse, error) <span class="cov0" title="0">{
        // Analyze user context to determine best link strategy
        strategy := dls.determineRoutingStrategy(req.Context)

        response := &amp;SmartLinkResponse{
                Strategy:      strategy,
                PrimaryLink:   "",
                FallbackLinks: make([]string, 0),
                Instructions:  make(map[string]string),
        }

        switch strategy </span>{
        case "native_preferred":<span class="cov0" title="0">
                // Try native app first, fallback to web
                if req.Context.Platform == "android" </span><span class="cov0" title="0">{
                        androidLink, _ := dls.generateAndroidLink(req, dls.generateTrackingID())
                        response.PrimaryLink = androidLink.URL
                        webLink, _ := dls.generateWebLink(req, dls.generateTrackingID())
                        response.FallbackLinks = append(response.FallbackLinks, webLink.URL)
                }</span> else<span class="cov0" title="0"> if req.Context.Platform == "ios" </span><span class="cov0" title="0">{
                        iosLink, _ := dls.generateIOSLink(req, dls.generateTrackingID())
                        response.PrimaryLink = iosLink.URL
                        webLink, _ := dls.generateWebLink(req, dls.generateTrackingID())
                        response.FallbackLinks = append(response.FallbackLinks, webLink.URL)
                }</span>

        case "web_only":<span class="cov0" title="0">
                // Web-only strategy
                webLink, _ := dls.generateWebLink(req, dls.generateTrackingID())
                response.PrimaryLink = webLink.URL</span>

        case "universal":<span class="cov0" title="0">
                // Universal link that detects platform
                response.PrimaryLink = dls.generateUniversalLink(req, dls.generateTrackingID())</span>
        }

        // Add usage instructions
        <span class="cov0" title="0">response.Instructions["primary"] = "Tap to open in your preferred app"
        response.Instructions["fallback"] = "If the app doesn't open, use the web version"

        return response, nil</span>
}

type SmartLinkResponse struct {
        Strategy      string            `json:"strategy"`
        PrimaryLink   string            `json:"primary_link"`
        FallbackLinks []string          `json:"fallback_links"`
        Instructions  map[string]string `json:"instructions"`
}

func (dls *DeepLinkingService) determineRoutingStrategy(context *LinkContext) string <span class="cov0" title="0">{
        if context == nil </span><span class="cov0" title="0">{
                return "universal"
        }</span>

        // Determine strategy based on context
        <span class="cov0" title="0">switch context.Platform </span>{
        case "android", "ios":<span class="cov0" title="0">
                return "native_preferred"</span>
        case "web":<span class="cov0" title="0">
                return "web_only"</span>
        default:<span class="cov0" title="0">
                return "universal"</span>
        }
}

// Batch link generation for multiple items
func (dls *DeepLinkingService) GenerateBatchLinks(ctx context.Context, requests []*DeepLinkRequest) ([]*DeepLinkResponse, error) <span class="cov0" title="0">{
        responses := make([]*DeepLinkResponse, 0, len(requests))

        for _, req := range requests </span><span class="cov0" title="0">{
                response, err := dls.GenerateDeepLinks(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        // Continue with others even if one fails
                        continue</span>
                }
                <span class="cov0" title="0">responses = append(responses, response)</span>
        }

        <span class="cov0" title="0">return responses, nil</span>
}

// Link validation and testing
func (dls *DeepLinkingService) ValidateLinks(ctx context.Context, links []*DeepLink) (*ValidationResult, error) <span class="cov0" title="0">{
        result := &amp;ValidationResult{
                TotalLinks:   len(links),
                ValidLinks:   0,
                InvalidLinks: 0,
                Warnings:     make([]string, 0),
                Errors:       make([]string, 0),
        }

        for _, link := range links </span><span class="cov0" title="0">{
                if dls.validateLink(link) </span><span class="cov0" title="0">{
                        result.ValidLinks++
                }</span> else<span class="cov0" title="0"> {
                        result.InvalidLinks++
                        result.Errors = append(result.Errors, fmt.Sprintf("Invalid link: %s", link.URL))
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

type ValidationResult struct {
        TotalLinks   int      `json:"total_links"`
        ValidLinks   int      `json:"valid_links"`
        InvalidLinks int      `json:"invalid_links"`
        Warnings     []string `json:"warnings"`
        Errors       []string `json:"errors"`
}

func (dls *DeepLinkingService) validateLink(link *DeepLink) bool <span class="cov0" title="0">{
        if link.URL == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if link.Scheme == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        // Add more validation logic as needed
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package services

import (
        "context"
        "database/sql"
        "math"
        "regexp"
        "strings"
        "time"

        "go.uber.org/zap"
)

// Duplicate detection and deduplication service
type DuplicateDetectionService struct {
        db           *sql.DB
        logger       *zap.Logger
        cacheService *CacheService
}

// Duplicate detection result
type DuplicateGroup struct {
        ID              string          `json:"id"`
        MediaType       MediaType       `json:"media_type"`
        PrimaryItem     DuplicateItem   `json:"primary_item"`
        DuplicateItems  []DuplicateItem `json:"duplicate_items"`
        Confidence      float64         `json:"confidence"`
        DetectionMethod string          `json:"detection_method"`
        MatchTypes      []string        `json:"match_types"`
        CreatedAt       time.Time       `json:"created_at"`
        UpdatedAt       time.Time       `json:"updated_at"`
        Status          string          `json:"status"` // pending, confirmed, dismissed
        AutoResolved    bool            `json:"auto_resolved"`
}

type DuplicateItem struct {
        MediaID      string                 `json:"media_id"`
        FilePath     string                 `json:"file_path"`
        FileName     string                 `json:"file_name"`
        FileSize     int64                  `json:"file_size"`
        FileHash     string                 `json:"file_hash"`
        Title        string                 `json:"title"`
        Artist       string                 `json:"artist,omitempty"`
        Album        string                 `json:"album,omitempty"`
        Director     string                 `json:"director,omitempty"`
        Author       string                 `json:"author,omitempty"`
        Year         int                    `json:"year,omitempty"`
        Duration     int64                  `json:"duration,omitempty"`
        Quality      string                 `json:"quality,omitempty"`
        Format       string                 `json:"format,omitempty"`
        Bitrate      int                    `json:"bitrate,omitempty"`
        Resolution   string                 `json:"resolution,omitempty"`
        ExternalIDs  map[string]string      `json:"external_ids"`
        Fingerprints map[string]string      `json:"fingerprints"`
        Similarity   float64                `json:"similarity"`
        MatchReasons []string               `json:"match_reasons"`
        Metadata     map[string]interface{} `json:"metadata"`
        AddedAt      time.Time              `json:"added_at"`
        LastSeen     time.Time              `json:"last_seen"`
}

// Similarity calculation components
type SimilarityAnalysis struct {
        OverallScore          float64            `json:"overall_score"`
        TitleSimilarity       float64            `json:"title_similarity"`
        MetadataSimilarity    float64            `json:"metadata_similarity"`
        FingerprintSimilarity float64            `json:"fingerprint_similarity"`
        FileSimilarity        float64            `json:"file_similarity"`
        ExternalIDMatch       bool               `json:"external_id_match"`
        HashMatch             bool               `json:"hash_match"`
        Components            map[string]float64 `json:"components"`
        MatchingFields        []string           `json:"matching_fields"`
        DifferencesFound      []string           `json:"differences_found"`
}

// Text similarity algorithms
type TextSimilarityMetrics struct {
        LevenshteinDistance int     `json:"levenshtein_distance"`
        JaroWinklerScore    float64 `json:"jaro_winkler_score"`
        CosineSimilarity    float64 `json:"cosine_similarity"`
        JaccardIndex        float64 `json:"jaccard_index"`
        LCSRatio            float64 `json:"lcs_ratio"`
        SoundexMatch        bool    `json:"soundex_match"`
        MetaphoneMatch      bool    `json:"metaphone_match"`
}

// Deduplication action
type DeduplicationAction struct {
        GroupID       string                 `json:"group_id"`
        Action        string                 `json:"action"` // keep_primary, keep_best_quality, merge, custom
        PrimaryItemID string                 `json:"primary_item_id"`
        ItemsToRemove []string               `json:"items_to_remove"`
        ItemsToKeep   []string               `json:"items_to_keep"`
        MergeStrategy string                 `json:"merge_strategy,omitempty"`
        UserID        int64                  `json:"user_id"`
        Reason        string                 `json:"reason"`
        ExecutedAt    time.Time              `json:"executed_at"`
        RollbackData  map[string]interface{} `json:"rollback_data,omitempty"`
}

// Duplicate detection request
type DuplicateDetectionRequest struct {
        MediaTypes       []MediaType `json:"media_types,omitempty"`
        IncludePaths     []string    `json:"include_paths,omitempty"`
        ExcludePaths     []string    `json:"exclude_paths,omitempty"`
        MinSimilarity    float64     `json:"min_similarity"`
        DetectionMethods []string    `json:"detection_methods"`
        IncludeExisting  bool        `json:"include_existing"`
        BatchSize        int         `json:"batch_size"`
        UserID           int64       `json:"user_id"`
}

func NewDuplicateDetectionService(
        db *sql.DB,
        logger *zap.Logger,
        cacheService *CacheService,
) *DuplicateDetectionService <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = zap.NewNop()
        }</span>
        <span class="cov0" title="0">return &amp;DuplicateDetectionService{
                db:           db,
                logger:       logger,
                cacheService: cacheService,
        }</span>
}

// Main duplicate detection method
func (s *DuplicateDetectionService) DetectDuplicates(ctx context.Context, req *DuplicateDetectionRequest) ([]DuplicateGroup, error) <span class="cov0" title="0">{
        s.logger.Info("Starting duplicate detection",
                zap.Int("media_types", len(req.MediaTypes)),
                zap.Float64("min_similarity", req.MinSimilarity),
                zap.Int64("user_id", req.UserID))

        var duplicateGroups []DuplicateGroup

        // Process each media type
        mediaTypes := req.MediaTypes
        if len(mediaTypes) == 0 </span><span class="cov0" title="0">{
                // Default to all types
                mediaTypes = []MediaType{
                        MediaTypeMovie, MediaTypeTVSeries, MediaTypeTVEpisode,
                        MediaTypeMusic, MediaTypeAlbum, MediaTypeAudiobook,
                        MediaTypeBook, MediaTypeComicBook, MediaTypeMagazine,
                        MediaTypeGame, MediaTypeSoftware,
                }
        }</span>

        <span class="cov0" title="0">for _, mediaType := range mediaTypes </span><span class="cov0" title="0">{
                groups, err := s.detectDuplicatesForMediaType(ctx, mediaType, req)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to detect duplicates for media type",
                                zap.String("media_type", string(mediaType)),
                                zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">duplicateGroups = append(duplicateGroups, groups...)</span>
        }

        // Store detected duplicates
        <span class="cov0" title="0">for _, group := range duplicateGroups </span><span class="cov0" title="0">{
                if err := s.storeDuplicateGroup(ctx, &amp;group); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to store duplicate group",
                                zap.String("group_id", group.ID),
                                zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">s.logger.Info("Duplicate detection completed",
                zap.Int("groups_found", len(duplicateGroups)))

        return duplicateGroups, nil</span>
}

// Detect duplicates for a specific media type
func (s *DuplicateDetectionService) detectDuplicatesForMediaType(ctx context.Context, mediaType MediaType, req *DuplicateDetectionRequest) ([]DuplicateGroup, error) <span class="cov0" title="0">{
        // Get all items of this media type
        items, err := s.getMediaItems(ctx, mediaType, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(items) &lt; 2 </span><span class="cov0" title="0">{
                return []DuplicateGroup{}, nil
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Processing media items for duplicates",
                zap.String("media_type", string(mediaType)),
                zap.Int("item_count", len(items)))

        var duplicateGroups []DuplicateGroup

        // Compare each item with every other item
        for i := 0; i &lt; len(items); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(items); j++ </span><span class="cov0" title="0">{
                        similarity := s.calculateSimilarity(ctx, &amp;items[i], &amp;items[j], mediaType)

                        if similarity.OverallScore &gt;= req.MinSimilarity </span><span class="cov0" title="0">{
                                // Create or add to duplicate group
                                group := s.createOrAddToDuplicateGroup(duplicateGroups, items[i], items[j], similarity, mediaType)
                                if group != nil </span><span class="cov0" title="0">{
                                        duplicateGroups = s.mergeDuplicateGroup(duplicateGroups, *group)
                                }</span>
                        }
                }
        }

        // Post-process groups to determine primary items
        <span class="cov0" title="0">for i := range duplicateGroups </span><span class="cov0" title="0">{
                s.determinePrimaryItem(&amp;duplicateGroups[i])
        }</span>

        <span class="cov0" title="0">return duplicateGroups, nil</span>
}

// Calculate similarity between two media items
func (s *DuplicateDetectionService) calculateSimilarity(ctx context.Context, item1, item2 *DuplicateItem, mediaType MediaType) *SimilarityAnalysis <span class="cov0" title="0">{
        analysis := &amp;SimilarityAnalysis{
                Components:       make(map[string]float64),
                MatchingFields:   []string{},
                DifferencesFound: []string{},
        }

        // 1. Exact hash match (highest priority)
        if item1.FileHash != "" &amp;&amp; item2.FileHash != "" &amp;&amp; item1.FileHash == item2.FileHash </span><span class="cov0" title="0">{
                analysis.HashMatch = true
                analysis.OverallScore = 1.0
                analysis.MatchingFields = append(analysis.MatchingFields, "file_hash")
                return analysis
        }</span>

        // 2. External ID match
        <span class="cov0" title="0">for key, id1 := range item1.ExternalIDs </span><span class="cov0" title="0">{
                if id2, exists := item2.ExternalIDs[key]; exists &amp;&amp; id1 == id2 &amp;&amp; id1 != "" </span><span class="cov0" title="0">{
                        analysis.ExternalIDMatch = true
                        analysis.OverallScore = 0.95
                        analysis.MatchingFields = append(analysis.MatchingFields, "external_id_"+key)
                        return analysis
                }</span>
        }

        // 3. Comprehensive similarity calculation
        <span class="cov0" title="0">weights := s.getSimilarityWeights(mediaType)

        // Title similarity
        analysis.TitleSimilarity = s.calculateTextSimilarity(item1.Title, item2.Title)
        analysis.Components["title"] = analysis.TitleSimilarity * weights["title"]

        // Metadata similarity based on media type
        switch mediaType </span>{
        case MediaTypeMovie, MediaTypeTVSeries, MediaTypeTVEpisode:<span class="cov0" title="0">
                analysis.MetadataSimilarity = s.calculateVideoMetadataSimilarity(item1, item2)</span>
        case MediaTypeMusic, MediaTypeAlbum, MediaTypeAudiobook:<span class="cov0" title="0">
                analysis.MetadataSimilarity = s.calculateAudioMetadataSimilarity(item1, item2)</span>
        case MediaTypeBook, MediaTypeComicBook, MediaTypeMagazine:<span class="cov0" title="0">
                analysis.MetadataSimilarity = s.calculateBookMetadataSimilarity(item1, item2)</span>
        case MediaTypeGame, MediaTypeSoftware:<span class="cov0" title="0">
                analysis.MetadataSimilarity = s.calculateSoftwareMetadataSimilarity(item1, item2)</span>
        default:<span class="cov0" title="0">
                analysis.MetadataSimilarity = s.calculateGenericMetadataSimilarity(item1, item2)</span>
        }
        <span class="cov0" title="0">analysis.Components["metadata"] = analysis.MetadataSimilarity * weights["metadata"]

        // Fingerprint similarity
        if len(item1.Fingerprints) &gt; 0 &amp;&amp; len(item2.Fingerprints) &gt; 0 </span><span class="cov0" title="0">{
                analysis.FingerprintSimilarity = s.calculateFingerprintSimilarity(item1.Fingerprints, item2.Fingerprints)
                analysis.Components["fingerprint"] = analysis.FingerprintSimilarity * weights["fingerprint"]
        }</span>

        // File similarity (size, format, quality)
        <span class="cov0" title="0">analysis.FileSimilarity = s.calculateFileSimilarity(item1, item2)
        analysis.Components["file"] = analysis.FileSimilarity * weights["file"]

        // Calculate overall score
        totalWeight := 0.0
        for _, weight := range weights </span><span class="cov0" title="0">{
                totalWeight += weight
        }</span>

        <span class="cov0" title="0">analysis.OverallScore = 0.0
        for _, score := range analysis.Components </span><span class="cov0" title="0">{
                analysis.OverallScore += score
        }</span>
        <span class="cov0" title="0">if totalWeight &gt; 0 </span><span class="cov0" title="0">{
                analysis.OverallScore /= totalWeight
        }</span>

        // Determine matching fields and differences
        <span class="cov0" title="0">s.analyzeFieldMatches(item1, item2, analysis)

        return analysis</span>
}

// Calculate text similarity using multiple algorithms
func (s *DuplicateDetectionService) calculateTextSimilarity(text1, text2 string) float64 <span class="cov0" title="0">{
        if text1 == "" || text2 == "" </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Normalize texts
        <span class="cov0" title="0">norm1 := s.normalizeText(text1)
        norm2 := s.normalizeText(text2)

        if norm1 == norm2 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        // Calculate multiple similarity metrics
        <span class="cov0" title="0">metrics := s.calculateTextMetrics(norm1, norm2)

        // Weighted combination of metrics
        score := 0.0
        score += metrics.JaroWinklerScore * 0.4
        score += metrics.CosineSimilarity * 0.3
        score += metrics.JaccardIndex * 0.2
        score += metrics.LCSRatio * 0.1

        // Bonus for exact phonetic matches
        if metrics.SoundexMatch </span><span class="cov0" title="0">{
                score += 0.1
        }</span>
        <span class="cov0" title="0">if metrics.MetaphoneMatch </span><span class="cov0" title="0">{
                score += 0.1
        }</span>

        <span class="cov0" title="0">if score &gt; 1.0 </span><span class="cov0" title="0">{
                score = 1.0
        }</span>

        <span class="cov0" title="0">return score</span>
}

// Calculate video metadata similarity
func (s *DuplicateDetectionService) calculateVideoMetadataSimilarity(item1, item2 *DuplicateItem) float64 <span class="cov0" title="0">{
        score := 0.0
        components := 0

        // Director similarity
        if item1.Director != "" &amp;&amp; item2.Director != "" </span><span class="cov0" title="0">{
                score += s.calculateTextSimilarity(item1.Director, item2.Director)
                components++
        }</span>

        // Year similarity
        <span class="cov0" title="0">if item1.Year &gt; 0 &amp;&amp; item2.Year &gt; 0 </span><span class="cov0" title="0">{
                yearDiff := math.Abs(float64(item1.Year - item2.Year))
                yearScore := math.Max(0, 1.0-yearDiff/5.0) // Penalty for year differences
                score += yearScore
                components++
        }</span>

        // Duration similarity
        <span class="cov0" title="0">if item1.Duration &gt; 0 &amp;&amp; item2.Duration &gt; 0 </span><span class="cov0" title="0">{
                durationDiff := math.Abs(float64(item1.Duration - item2.Duration))
                durationScore := math.Max(0, 1.0-durationDiff/600000) // 10 minute tolerance
                score += durationScore
                components++
        }</span>

        // Quality/Resolution similarity
        <span class="cov0" title="0">if item1.Quality != "" &amp;&amp; item2.Quality != "" </span><span class="cov0" title="0">{
                qualityScore := 0.0
                if item1.Quality == item2.Quality </span><span class="cov0" title="0">{
                        qualityScore = 1.0
                }</span> else<span class="cov0" title="0"> if s.areQualitiesSimilar(item1.Quality, item2.Quality) </span><span class="cov0" title="0">{
                        qualityScore = 0.7
                }</span>
                <span class="cov0" title="0">score += qualityScore
                components++</span>
        }

        <span class="cov0" title="0">if components &gt; 0 </span><span class="cov0" title="0">{
                return score / float64(components)
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// Calculate audio metadata similarity
func (s *DuplicateDetectionService) calculateAudioMetadataSimilarity(item1, item2 *DuplicateItem) float64 <span class="cov0" title="0">{
        score := 0.0
        components := 0

        // Artist similarity
        if item1.Artist != "" &amp;&amp; item2.Artist != "" </span><span class="cov0" title="0">{
                score += s.calculateTextSimilarity(item1.Artist, item2.Artist)
                components++
        }</span>

        // Album similarity
        <span class="cov0" title="0">if item1.Album != "" &amp;&amp; item2.Album != "" </span><span class="cov0" title="0">{
                score += s.calculateTextSimilarity(item1.Album, item2.Album)
                components++
        }</span>

        // Year similarity
        <span class="cov0" title="0">if item1.Year &gt; 0 &amp;&amp; item2.Year &gt; 0 </span><span class="cov0" title="0">{
                yearDiff := math.Abs(float64(item1.Year - item2.Year))
                yearScore := math.Max(0, 1.0-yearDiff/2.0) // Smaller tolerance for music
                score += yearScore
                components++
        }</span>

        // Duration similarity
        <span class="cov0" title="0">if item1.Duration &gt; 0 &amp;&amp; item2.Duration &gt; 0 </span><span class="cov0" title="0">{
                durationDiff := math.Abs(float64(item1.Duration - item2.Duration))
                durationScore := math.Max(0, 1.0-durationDiff/30000) // 30 second tolerance
                score += durationScore
                components++
        }</span>

        // Bitrate similarity
        <span class="cov0" title="0">if item1.Bitrate &gt; 0 &amp;&amp; item2.Bitrate &gt; 0 </span><span class="cov0" title="0">{
                bitrateDiff := math.Abs(float64(item1.Bitrate - item2.Bitrate))
                bitrateScore := math.Max(0, 1.0-bitrateDiff/320) // Normalize by 320kbps
                score += bitrateScore
                components++
        }</span>

        <span class="cov0" title="0">if components &gt; 0 </span><span class="cov0" title="0">{
                return score / float64(components)
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// Calculate book metadata similarity
func (s *DuplicateDetectionService) calculateBookMetadataSimilarity(item1, item2 *DuplicateItem) float64 <span class="cov0" title="0">{
        score := 0.0
        components := 0

        // Author similarity
        if item1.Author != "" &amp;&amp; item2.Author != "" </span><span class="cov0" title="0">{
                score += s.calculateTextSimilarity(item1.Author, item2.Author)
                components++
        }</span>

        // Year similarity
        <span class="cov0" title="0">if item1.Year &gt; 0 &amp;&amp; item2.Year &gt; 0 </span><span class="cov0" title="0">{
                yearDiff := math.Abs(float64(item1.Year - item2.Year))
                yearScore := math.Max(0, 1.0-yearDiff/5.0)
                score += yearScore
                components++
        }</span>

        // Check for ISBN matches in external IDs
        <span class="cov0" title="0">isbn1 := s.extractISBN(item1.ExternalIDs)
        isbn2 := s.extractISBN(item2.ExternalIDs)
        if isbn1 != "" &amp;&amp; isbn2 != "" </span><span class="cov0" title="0">{
                if isbn1 == isbn2 </span><span class="cov0" title="0">{
                        score += 1.0
                }</span> else<span class="cov0" title="0"> if s.areISBNsRelated(isbn1, isbn2) </span><span class="cov0" title="0">{
                        score += 0.8
                }</span>
                <span class="cov0" title="0">components++</span>
        }

        <span class="cov0" title="0">if components &gt; 0 </span><span class="cov0" title="0">{
                return score / float64(components)
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// Calculate software metadata similarity
func (s *DuplicateDetectionService) calculateSoftwareMetadataSimilarity(item1, item2 *DuplicateItem) float64 <span class="cov0" title="0">{
        score := 0.0
        components := 0

        // Version similarity
        version1 := s.extractVersion(item1.Metadata)
        version2 := s.extractVersion(item2.Metadata)
        if version1 != "" &amp;&amp; version2 != "" </span><span class="cov0" title="0">{
                score += s.calculateVersionSimilarity(version1, version2)
                components++
        }</span>

        // Platform similarity
        <span class="cov0" title="0">platform1 := s.extractPlatform(item1.Metadata)
        platform2 := s.extractPlatform(item2.Metadata)
        if platform1 != "" &amp;&amp; platform2 != "" </span><span class="cov0" title="0">{
                if platform1 == platform2 </span><span class="cov0" title="0">{
                        score += 1.0
                }</span> else<span class="cov0" title="0"> if s.arePlatformsSimilar(platform1, platform2) </span><span class="cov0" title="0">{
                        score += 0.5
                }</span>
                <span class="cov0" title="0">components++</span>
        }

        // File size similarity (important for software)
        <span class="cov0" title="0">if item1.FileSize &gt; 0 &amp;&amp; item2.FileSize &gt; 0 </span><span class="cov0" title="0">{
                sizeDiff := math.Abs(float64(item1.FileSize - item2.FileSize))
                sizeScore := math.Max(0, 1.0-sizeDiff/float64(math.Max(float64(item1.FileSize), float64(item2.FileSize))))
                score += sizeScore
                components++
        }</span>

        <span class="cov0" title="0">if components &gt; 0 </span><span class="cov0" title="0">{
                return score / float64(components)
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// Calculate generic metadata similarity
func (s *DuplicateDetectionService) calculateGenericMetadataSimilarity(item1, item2 *DuplicateItem) float64 <span class="cov0" title="0">{
        score := 0.0
        components := 0

        // File name similarity
        score += s.calculateTextSimilarity(item1.FileName, item2.FileName)
        components++

        // Format similarity
        if item1.Format != "" &amp;&amp; item2.Format != "" </span><span class="cov0" title="0">{
                if item1.Format == item2.Format </span><span class="cov0" title="0">{
                        score += 1.0
                }</span> else<span class="cov0" title="0"> if s.areFormatsSimilar(item1.Format, item2.Format) </span><span class="cov0" title="0">{
                        score += 0.5
                }</span>
                <span class="cov0" title="0">components++</span>
        }

        // File size similarity
        <span class="cov0" title="0">if item1.FileSize &gt; 0 &amp;&amp; item2.FileSize &gt; 0 </span><span class="cov0" title="0">{
                sizeDiff := math.Abs(float64(item1.FileSize - item2.FileSize))
                maxSize := math.Max(float64(item1.FileSize), float64(item2.FileSize))
                if maxSize &gt; 0 </span><span class="cov0" title="0">{
                        sizeScore := math.Max(0, 1.0-sizeDiff/maxSize)
                        score += sizeScore
                        components++
                }</span>
        }

        <span class="cov0" title="0">if components &gt; 0 </span><span class="cov0" title="0">{
                return score / float64(components)
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// Calculate fingerprint similarity
func (s *DuplicateDetectionService) calculateFingerprintSimilarity(fp1, fp2 map[string]string) float64 <span class="cov0" title="0">{
        if len(fp1) == 0 || len(fp2) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">maxScore := 0.0

        // Compare each fingerprint type
        for fpType, hash1 := range fp1 </span><span class="cov0" title="0">{
                if hash2, exists := fp2[fpType]; exists </span><span class="cov0" title="0">{
                        similarity := s.calculateHashSimilarity(hash1, hash2, fpType)
                        if similarity &gt; maxScore </span><span class="cov0" title="0">{
                                maxScore = similarity
                        }</span>
                }
        }

        <span class="cov0" title="0">return maxScore</span>
}

// Calculate file similarity
func (s *DuplicateDetectionService) calculateFileSimilarity(item1, item2 *DuplicateItem) float64 <span class="cov0" title="0">{
        score := 0.0
        components := 0

        // File name similarity
        score += s.calculateTextSimilarity(item1.FileName, item2.FileName)
        components++

        // File size similarity
        if item1.FileSize &gt; 0 &amp;&amp; item2.FileSize &gt; 0 </span><span class="cov0" title="0">{
                sizeDiff := math.Abs(float64(item1.FileSize - item2.FileSize))
                maxSize := math.Max(float64(item1.FileSize), float64(item2.FileSize))
                if maxSize &gt; 0 </span><span class="cov0" title="0">{
                        sizeScore := 1.0 - sizeDiff/maxSize
                        if sizeScore &lt; 0 </span><span class="cov0" title="0">{
                                sizeScore = 0
                        }</span>
                        <span class="cov0" title="0">score += sizeScore
                        components++</span>
                }
        }

        // Format similarity
        <span class="cov0" title="0">if item1.Format != "" &amp;&amp; item2.Format != "" </span><span class="cov0" title="0">{
                if strings.EqualFold(item1.Format, item2.Format) </span><span class="cov0" title="0">{
                        score += 1.0
                }</span> else<span class="cov0" title="0"> if s.areFormatsSimilar(item1.Format, item2.Format) </span><span class="cov0" title="0">{
                        score += 0.7
                }</span>
                <span class="cov0" title="0">components++</span>
        }

        <span class="cov0" title="0">if components &gt; 0 </span><span class="cov0" title="0">{
                return score / float64(components)
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// Helper methods for text analysis
func (s *DuplicateDetectionService) normalizeText(text string) string <span class="cov0" title="0">{
        // Convert to lowercase
        text = strings.ToLower(text)

        // Remove common articles and prepositions
        stopWords := []string{"the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for", "of", "with", "by"}
        words := strings.Fields(text)
        var filtered []string

        for _, word := range words </span><span class="cov0" title="0">{
                isStopWord := false
                for _, stopWord := range stopWords </span><span class="cov0" title="0">{
                        if word == stopWord </span><span class="cov0" title="0">{
                                isStopWord = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isStopWord </span><span class="cov0" title="0">{
                        filtered = append(filtered, word)
                }</span>
        }

        // Remove special characters and normalize spaces
        <span class="cov0" title="0">normalized := strings.Join(filtered, " ")
        normalized = regexp.MustCompile(`[^\p{L}\p{N}\s]`).ReplaceAllString(normalized, "")
        normalized = regexp.MustCompile(`\s+`).ReplaceAllString(normalized, " ")
        normalized = strings.TrimSpace(normalized)

        return normalized</span>
}

func (s *DuplicateDetectionService) calculateTextMetrics(text1, text2 string) *TextSimilarityMetrics <span class="cov0" title="0">{
        metrics := &amp;TextSimilarityMetrics{}

        // Levenshtein distance
        metrics.LevenshteinDistance = s.levenshteinDistance(text1, text2)

        // Jaro-Winkler similarity
        metrics.JaroWinklerScore = s.jaroWinklerSimilarity(text1, text2)

        // Cosine similarity
        metrics.CosineSimilarity = s.cosineSimilarity(text1, text2)

        // Jaccard index
        metrics.JaccardIndex = s.jaccardIndex(text1, text2)

        // LCS ratio
        metrics.LCSRatio = s.lcsRatio(text1, text2)

        // Soundex match
        metrics.SoundexMatch = s.soundexMatch(text1, text2)

        // Metaphone match
        metrics.MetaphoneMatch = s.metaphoneMatch(text1, text2)

        return metrics
}</span>

// Levenshtein distance algorithm
func (s *DuplicateDetectionService) levenshteinDistance(s1, s2 string) int <span class="cov0" title="0">{
        if len(s1) == 0 </span><span class="cov0" title="0">{
                return len(s2)
        }</span>
        <span class="cov0" title="0">if len(s2) == 0 </span><span class="cov0" title="0">{
                return len(s1)
        }</span>

        <span class="cov0" title="0">matrix := make([][]int, len(s1)+1)
        for i := range matrix </span><span class="cov0" title="0">{
                matrix[i] = make([]int, len(s2)+1)
                matrix[i][0] = i
        }</span>

        <span class="cov0" title="0">for j := 0; j &lt;= len(s2); j++ </span><span class="cov0" title="0">{
                matrix[0][j] = j
        }</span>

        <span class="cov0" title="0">for i := 1; i &lt;= len(s1); i++ </span><span class="cov0" title="0">{
                for j := 1; j &lt;= len(s2); j++ </span><span class="cov0" title="0">{
                        cost := 0
                        if s1[i-1] != s2[j-1] </span><span class="cov0" title="0">{
                                cost = 1
                        }</span>

                        <span class="cov0" title="0">matrix[i][j] = min3(
                                matrix[i-1][j]+1,      // deletion
                                matrix[i][j-1]+1,      // insertion
                                matrix[i-1][j-1]+cost, // substitution
                        )</span>
                }
        }

        <span class="cov0" title="0">return matrix[len(s1)][len(s2)]</span>
}

// Jaro-Winkler similarity
func (s *DuplicateDetectionService) jaroWinklerSimilarity(s1, s2 string) float64 <span class="cov0" title="0">{
        if s1 == s2 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov0" title="0">len1, len2 := len(s1), len(s2)
        if len1 == 0 || len2 == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">matchWindow := max(len1, len2)/2 - 1
        if matchWindow &lt; 0 </span><span class="cov0" title="0">{
                matchWindow = 0
        }</span>

        <span class="cov0" title="0">s1Matches := make([]bool, len1)
        s2Matches := make([]bool, len2)

        matches := 0
        transpositions := 0

        // Find matches
        for i := 0; i &lt; len1; i++ </span><span class="cov0" title="0">{
                start := max(0, i-matchWindow)
                end := min(i+matchWindow+1, len2)

                for j := start; j &lt; end; j++ </span><span class="cov0" title="0">{
                        if s2Matches[j] || s1[i] != s2[j] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">s1Matches[i] = true
                        s2Matches[j] = true
                        matches++
                        break</span>
                }
        }

        <span class="cov0" title="0">if matches == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Find transpositions
        <span class="cov0" title="0">k := 0
        for i := 0; i &lt; len1; i++ </span><span class="cov0" title="0">{
                if !s1Matches[i] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for !s2Matches[k] </span><span class="cov0" title="0">{
                        k++
                }</span>
                <span class="cov0" title="0">if s1[i] != s2[k] </span><span class="cov0" title="0">{
                        transpositions++
                }</span>
                <span class="cov0" title="0">k++</span>
        }

        <span class="cov0" title="0">jaro := (float64(matches)/float64(len1) + float64(matches)/float64(len2) + float64(matches-transpositions/2)/float64(matches)) / 3.0

        // Jaro-Winkler adjustment
        prefix := 0
        for i := 0; i &lt; min(len1, len2) &amp;&amp; i &lt; 4; i++ </span><span class="cov0" title="0">{
                if s1[i] == s2[i] </span><span class="cov0" title="0">{
                        prefix++
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">return jaro + 0.1*float64(prefix)*(1.0-jaro)</span>
}

// Cosine similarity
func (s *DuplicateDetectionService) cosineSimilarity(text1, text2 string) float64 <span class="cov0" title="0">{
        words1 := strings.Fields(text1)
        words2 := strings.Fields(text2)

        if len(words1) == 0 || len(words2) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Create word frequency maps
        <span class="cov0" title="0">freq1 := make(map[string]int)
        freq2 := make(map[string]int)

        for _, word := range words1 </span><span class="cov0" title="0">{
                freq1[word]++
        }</span>
        <span class="cov0" title="0">for _, word := range words2 </span><span class="cov0" title="0">{
                freq2[word]++
        }</span>

        // Calculate dot product and magnitudes
        <span class="cov0" title="0">dotProduct := 0.0
        magnitude1 := 0.0
        magnitude2 := 0.0

        allWords := make(map[string]bool)
        for word := range freq1 </span><span class="cov0" title="0">{
                allWords[word] = true
        }</span>
        <span class="cov0" title="0">for word := range freq2 </span><span class="cov0" title="0">{
                allWords[word] = true
        }</span>

        <span class="cov0" title="0">for word := range allWords </span><span class="cov0" title="0">{
                f1 := float64(freq1[word])
                f2 := float64(freq2[word])

                dotProduct += f1 * f2
                magnitude1 += f1 * f1
                magnitude2 += f2 * f2
        }</span>

        <span class="cov0" title="0">if magnitude1 == 0 || magnitude2 == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return dotProduct / (math.Sqrt(magnitude1) * math.Sqrt(magnitude2))</span>
}

// Jaccard index
func (s *DuplicateDetectionService) jaccardIndex(text1, text2 string) float64 <span class="cov0" title="0">{
        words1 := make(map[string]bool)
        words2 := make(map[string]bool)

        for _, word := range strings.Fields(text1) </span><span class="cov0" title="0">{
                words1[word] = true
        }</span>
        <span class="cov0" title="0">for _, word := range strings.Fields(text2) </span><span class="cov0" title="0">{
                words2[word] = true
        }</span>

        <span class="cov0" title="0">intersection := 0
        union := 0

        allWords := make(map[string]bool)
        for word := range words1 </span><span class="cov0" title="0">{
                allWords[word] = true
        }</span>
        <span class="cov0" title="0">for word := range words2 </span><span class="cov0" title="0">{
                allWords[word] = true
        }</span>

        <span class="cov0" title="0">for word := range allWords </span><span class="cov0" title="0">{
                inFirst := words1[word]
                inSecond := words2[word]

                if inFirst &amp;&amp; inSecond </span><span class="cov0" title="0">{
                        intersection++
                }</span>
                <span class="cov0" title="0">union++</span>
        }

        <span class="cov0" title="0">if union == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return float64(intersection) / float64(union)</span>
}

// Longest Common Subsequence ratio
func (s *DuplicateDetectionService) lcsRatio(s1, s2 string) float64 <span class="cov0" title="0">{
        lcsLength := s.lcsLength(s1, s2)
        maxLength := max(len(s1), len(s2))

        if maxLength == 0 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov0" title="0">return float64(lcsLength) / float64(maxLength)</span>
}

func (s *DuplicateDetectionService) lcsLength(s1, s2 string) int <span class="cov0" title="0">{
        m, n := len(s1), len(s2)
        dp := make([][]int, m+1)
        for i := range dp </span><span class="cov0" title="0">{
                dp[i] = make([]int, n+1)
        }</span>

        <span class="cov0" title="0">for i := 1; i &lt;= m; i++ </span><span class="cov0" title="0">{
                for j := 1; j &lt;= n; j++ </span><span class="cov0" title="0">{
                        if s1[i-1] == s2[j-1] </span><span class="cov0" title="0">{
                                dp[i][j] = dp[i-1][j-1] + 1
                        }</span> else<span class="cov0" title="0"> {
                                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                        }</span>
                }
        }

        <span class="cov0" title="0">return dp[m][n]</span>
}

// Soundex matching (simplified)
func (s *DuplicateDetectionService) soundexMatch(s1, s2 string) bool <span class="cov0" title="0">{
        return s.soundex(s1) == s.soundex(s2)
}</span>

func (s *DuplicateDetectionService) soundex(str string) string <span class="cov0" title="0">{
        if len(str) == 0 </span><span class="cov0" title="0">{
                return "0000"
        }</span>

        <span class="cov0" title="0">str = strings.ToUpper(str)
        result := string(str[0])

        // Mapping table
        mapping := map[rune]string{
                'B': "1", 'F': "1", 'P': "1", 'V': "1",
                'C': "2", 'G': "2", 'J': "2", 'K': "2", 'Q': "2", 'S': "2", 'X': "2", 'Z': "2",
                'D': "3", 'T': "3",
                'L': "4",
                'M': "5", 'N': "5",
                'R': "6",
        }

        prev := ""
        for _, char := range str[1:] </span><span class="cov0" title="0">{
                if code, exists := mapping[char]; exists </span><span class="cov0" title="0">{
                        if code != prev </span><span class="cov0" title="0">{
                                result += code
                                prev = code
                        }</span>
                } else<span class="cov0" title="0"> {
                        prev = ""
                }</span>

                <span class="cov0" title="0">if len(result) &gt;= 4 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // Pad with zeros
        <span class="cov0" title="0">for len(result) &lt; 4 </span><span class="cov0" title="0">{
                result += "0"
        }</span>

        <span class="cov0" title="0">return result[:4]</span>
}

// Metaphone matching (simplified)
func (s *DuplicateDetectionService) metaphoneMatch(s1, s2 string) bool <span class="cov0" title="0">{
        return s.metaphone(s1) == s.metaphone(s2)
}</span>

func (s *DuplicateDetectionService) metaphone(str string) string <span class="cov0" title="0">{
        if len(str) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">str = strings.ToUpper(str)
        result := ""

        // Simplified metaphone algorithm
        for i, char := range str </span><span class="cov0" title="0">{
                switch char </span>{
                case 'A', 'E', 'I', 'O', 'U':<span class="cov0" title="0">
                        if i == 0 </span><span class="cov0" title="0">{
                                result += string(char)
                        }</span>
                case 'B':<span class="cov0" title="0">
                        if i == len(str)-1 &amp;&amp; str[i-1] == 'M' </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">result += "B"</span>
                case 'C':<span class="cov0" title="0">
                        if i &lt; len(str)-1 &amp;&amp; str[i+1] == 'H' </span><span class="cov0" title="0">{
                                result += "X"
                        }</span> else<span class="cov0" title="0"> {
                                result += "K"
                        }</span>
                case 'D':<span class="cov0" title="0">
                        result += "T"</span>
                case 'F', 'J', 'L', 'M', 'N', 'R':<span class="cov0" title="0">
                        result += string(char)</span>
                case 'G':<span class="cov0" title="0">
                        result += "K"</span>
                case 'H':<span class="cov0" title="0">
                        if i == 0 || isVowel(rune(str[i-1])) </span><span class="cov0" title="0">{
                                result += "H"
                        }</span>
                case 'K':<span class="cov0" title="0">
                        if i == 0 || str[i-1] != 'C' </span><span class="cov0" title="0">{
                                result += "K"
                        }</span>
                case 'P':<span class="cov0" title="0">
                        if i &lt; len(str)-1 &amp;&amp; str[i+1] == 'H' </span><span class="cov0" title="0">{
                                result += "F"
                        }</span> else<span class="cov0" title="0"> {
                                result += "P"
                        }</span>
                case 'Q':<span class="cov0" title="0">
                        result += "K"</span>
                case 'S':<span class="cov0" title="0">
                        result += "S"</span>
                case 'T':<span class="cov0" title="0">
                        if i &lt; len(str)-1 &amp;&amp; str[i+1] == 'H' </span><span class="cov0" title="0">{
                                result += "0"
                        }</span> else<span class="cov0" title="0"> {
                                result += "T"
                        }</span>
                case 'V':<span class="cov0" title="0">
                        result += "F"</span>
                case 'W', 'Y':<span class="cov0" title="0">
                        if i == 0 || isVowel(rune(str[i-1])) </span><span class="cov0" title="0">{
                                result += string(char)
                        }</span>
                case 'X':<span class="cov0" title="0">
                        result += "KS"</span>
                case 'Z':<span class="cov0" title="0">
                        result += "S"</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

func isVowel(r rune) bool <span class="cov0" title="0">{
        return r == 'A' || r == 'E' || r == 'I' || r == 'O' || r == 'U'
}</span>

// Utility functions
func min3(a, b, c int) int <span class="cov0" title="0">{
        if a &lt;= b &amp;&amp; a &lt;= c </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">if b &lt;= c </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov0" title="0">return c</span>
}

func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// Additional helper methods would continue here...
// (Implementation continues with remaining methods for duplicate group management,
// deduplication actions, storage methods, etc.)

// Placeholder implementations for some methods
func (s *DuplicateDetectionService) getSimilarityWeights(mediaType MediaType) map[string]float64 <span class="cov0" title="0">{
        switch mediaType </span>{
        case MediaTypeMusic:<span class="cov0" title="0">
                return map[string]float64{
                        "title":       0.4,
                        "metadata":    0.4,
                        "fingerprint": 0.15,
                        "file":        0.05,
                }</span>
        case MediaTypeMovie:<span class="cov0" title="0">
                return map[string]float64{
                        "title":       0.5,
                        "metadata":    0.3,
                        "fingerprint": 0.1,
                        "file":        0.1,
                }</span>
        default:<span class="cov0" title="0">
                return map[string]float64{
                        "title":       0.4,
                        "metadata":    0.3,
                        "fingerprint": 0.2,
                        "file":        0.1,
                }</span>
        }
}

func (s *DuplicateDetectionService) getMediaItems(ctx context.Context, mediaType MediaType, req *DuplicateDetectionRequest) ([]DuplicateItem, error) <span class="cov0" title="0">{
        // Implementation would query database for media items
        return []DuplicateItem{}, nil
}</span>

func (s *DuplicateDetectionService) createOrAddToDuplicateGroup(groups []DuplicateGroup, item1, item2 DuplicateItem, similarity *SimilarityAnalysis, mediaType MediaType) *DuplicateGroup <span class="cov0" title="0">{
        // Implementation would create new group or add to existing
        return nil
}</span>

func (s *DuplicateDetectionService) mergeDuplicateGroup(groups []DuplicateGroup, newGroup DuplicateGroup) []DuplicateGroup <span class="cov0" title="0">{
        // Implementation would merge groups if needed
        return groups
}</span>

func (s *DuplicateDetectionService) determinePrimaryItem(group *DuplicateGroup) {<span class="cov0" title="0">
        // Implementation would determine the best quality/primary item
}</span>

func (s *DuplicateDetectionService) storeDuplicateGroup(ctx context.Context, group *DuplicateGroup) error <span class="cov0" title="0">{
        // Implementation would store duplicate group in database
        return nil
}</span>

func (s *DuplicateDetectionService) analyzeFieldMatches(item1, item2 *DuplicateItem, analysis *SimilarityAnalysis) {<span class="cov0" title="0">
        // Implementation would analyze which fields match and which differ
}</span>

func (s *DuplicateDetectionService) calculateHashSimilarity(hash1, hash2, fpType string) float64 <span class="cov0" title="0">{
        // Implementation would calculate hash similarity based on type
        return 0.0
}</span>

func (s *DuplicateDetectionService) areQualitiesSimilar(q1, q2 string) bool <span class="cov0" title="0">{
        // Implementation would check if qualities are similar
        return false
}</span>

func (s *DuplicateDetectionService) extractISBN(externalIDs map[string]string) string <span class="cov0" title="0">{
        // Implementation would extract ISBN from external IDs
        return ""
}</span>

func (s *DuplicateDetectionService) areISBNsRelated(isbn1, isbn2 string) bool <span class="cov0" title="0">{
        // Implementation would check if ISBNs are related (ISBN-10 vs ISBN-13)
        return false
}</span>

func (s *DuplicateDetectionService) extractVersion(metadata map[string]interface{}) string <span class="cov0" title="0">{
        // Implementation would extract version from metadata
        return ""
}</span>

func (s *DuplicateDetectionService) extractPlatform(metadata map[string]interface{}) string <span class="cov0" title="0">{
        // Implementation would extract platform from metadata
        return ""
}</span>

func (s *DuplicateDetectionService) calculateVersionSimilarity(v1, v2 string) float64 <span class="cov0" title="0">{
        // Implementation would calculate version similarity
        return 0.0
}</span>

func (s *DuplicateDetectionService) arePlatformsSimilar(p1, p2 string) bool <span class="cov0" title="0">{
        // Implementation would check if platforms are similar
        return false
}</span>

func (s *DuplicateDetectionService) areFormatsSimilar(f1, f2 string) bool <span class="cov0" title="0">{
        // Implementation would check if formats are similar
        return false
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "regexp"
        "strconv"
        "strings"
        "time"

        "catalogizer/internal/models"

        "go.uber.org/zap"
)

// Game and software recognition provider
type GameSoftwareRecognitionProvider struct {
        logger      *zap.Logger
        httpClient  *http.Client
        baseURLs    map[string]string
        apiKeys     map[string]string
        rateLimiter map[string]*time.Ticker
}

// IGDB (Internet Game Database) API structures
type IGDBGame struct {
        ID                    int                     `json:"id"`
        Name                  string                  `json:"name"`
        Summary               string                  `json:"summary"`
        Storyline             string                  `json:"storyline"`
        FirstReleaseDate      int64                   `json:"first_release_date"`
        Category              int                     `json:"category"`
        Status                int                     `json:"status"`
        Rating                float64                 `json:"rating"`
        RatingCount           int                     `json:"rating_count"`
        AggregatedRating      float64                 `json:"aggregated_rating"`
        AggregatedRatingCount int                     `json:"aggregated_rating_count"`
        TotalRating           float64                 `json:"total_rating"`
        TotalRatingCount      int                     `json:"total_rating_count"`
        Popularity            float64                 `json:"popularity"`
        Cover                 IGDBCover               `json:"cover"`
        Screenshots           []IGDBScreenshot        `json:"screenshots"`
        Artworks              []IGDBArtwork           `json:"artworks"`
        Videos                []IGDBVideo             `json:"videos"`
        Genres                []IGDBGenre             `json:"genres"`
        Themes                []IGDBTheme             `json:"themes"`
        Platforms             []IGDBPlatform          `json:"platforms"`
        GameModes             []IGDBGameMode          `json:"game_modes"`
        PlayerPerspectives    []IGDBPlayerPerspective `json:"player_perspectives"`
        InvolvedCompanies     []IGDBInvolvedCompany   `json:"involved_companies"`
        Franchises            []IGDBFranchise         `json:"franchises"`
        Collection            IGDBCollection          `json:"collection"`
        DLC                   []IGDBGame              `json:"dlcs"`
        Expansions            []IGDBGame              `json:"expansions"`
        StandaloneExpansions  []IGDBGame              `json:"standalone_expansions"`
        Remakes               []IGDBGame              `json:"remakes"`
        Remasters             []IGDBGame              `json:"remasters"`
        ExternalGames         []IGDBExternalGame      `json:"external_games"`
        Websites              []IGDBWebsite           `json:"websites"`
        LanguageSupports      []IGDBLanguageSupport   `json:"language_supports"`
        MultiplayerModes      []IGDBMultiplayerMode   `json:"multiplayer_modes"`
        AlternativeNames      []IGDBAlternativeName   `json:"alternative_names"`
        Keywords              []IGDBKeyword           `json:"keywords"`
        Tags                  []int                   `json:"tags"`
}

type IGDBCover struct {
        ID      int    `json:"id"`
        URL     string `json:"url"`
        ImageID string `json:"image_id"`
        Width   int    `json:"width"`
        Height  int    `json:"height"`
}

type IGDBScreenshot struct {
        ID      int    `json:"id"`
        URL     string `json:"url"`
        ImageID string `json:"image_id"`
        Width   int    `json:"width"`
        Height  int    `json:"height"`
}

type IGDBArtwork struct {
        ID      int    `json:"id"`
        URL     string `json:"url"`
        ImageID string `json:"image_id"`
        Width   int    `json:"width"`
        Height  int    `json:"height"`
}

type IGDBVideo struct {
        ID       int    `json:"id"`
        Name     string `json:"name"`
        VideoID  string `json:"video_id"`
        Checksum string `json:"checksum"`
}

type IGDBGenre struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

type IGDBTheme struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

type IGDBPlatform struct {
        ID           int              `json:"id"`
        Name         string           `json:"name"`
        Abbreviation string           `json:"abbreviation"`
        Category     int              `json:"category"`
        Generation   int              `json:"generation"`
        PlatformLogo IGDBPlatformLogo `json:"platform_logo"`
        Websites     []IGDBWebsite    `json:"websites"`
}

type IGDBPlatformLogo struct {
        ID      int    `json:"id"`
        URL     string `json:"url"`
        ImageID string `json:"image_id"`
}

type IGDBGameMode struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

type IGDBPlayerPerspective struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

type IGDBInvolvedCompany struct {
        ID         int         `json:"id"`
        Company    IGDBCompany `json:"company"`
        Developer  bool        `json:"developer"`
        Publisher  bool        `json:"publisher"`
        Porting    bool        `json:"porting"`
        Supporting bool        `json:"supporting"`
}

type IGDBCompany struct {
        ID          int             `json:"id"`
        Name        string          `json:"name"`
        Slug        string          `json:"slug"`
        Country     int             `json:"country"`
        Description string          `json:"description"`
        StartDate   int64           `json:"start_date"`
        Logo        IGDBCompanyLogo `json:"logo"`
        Websites    []IGDBWebsite   `json:"websites"`
}

type IGDBCompanyLogo struct {
        ID      int    `json:"id"`
        URL     string `json:"url"`
        ImageID string `json:"image_id"`
}

type IGDBFranchise struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

type IGDBCollection struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

type IGDBExternalGame struct {
        ID        int    `json:"id"`
        Category  int    `json:"category"`
        UID       string `json:"uid"`
        URL       string `json:"url"`
        Year      int    `json:"year"`
        Media     int    `json:"media"`
        Platform  int    `json:"platform"`
        Countries []int  `json:"countries"`
}

type IGDBWebsite struct {
        ID       int    `json:"id"`
        Category int    `json:"category"`
        Trusted  bool   `json:"trusted"`
        URL      string `json:"url"`
}

type IGDBLanguageSupport struct {
        ID                  int                     `json:"id"`
        Language            IGDBLanguage            `json:"language"`
        LanguageSupportType IGDBLanguageSupportType `json:"language_support_type"`
}

type IGDBLanguage struct {
        ID         int    `json:"id"`
        Name       string `json:"name"`
        NativeName string `json:"native_name"`
        Locale     string `json:"locale"`
}

type IGDBLanguageSupportType struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
}

type IGDBMultiplayerMode struct {
        ID                int  `json:"id"`
        CampaignCoop      bool `json:"campaigncoop"`
        LancCoop          bool `json:"lancoop"`
        OfflineCoop       bool `json:"offlinecoop"`
        OfflineCoopMax    int  `json:"offlinecoopmax"`
        OfflineMax        int  `json:"offlinemax"`
        OnlineCoop        bool `json:"onlinecoop"`
        OnlineCoopMax     int  `json:"onlinecoopmax"`
        OnlineMax         int  `json:"onlinemax"`
        Platform          int  `json:"platform"`
        SplitScreen       bool `json:"splitscreen"`
        SplitScreenOnline bool `json:"splitscreenonline"`
}

type IGDBAlternativeName struct {
        ID      int    `json:"id"`
        Name    string `json:"name"`
        Comment string `json:"comment"`
}

type IGDBKeyword struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

// Steam API structures
type SteamAppDetails struct {
        Success bool         `json:"success"`
        Data    SteamAppData `json:"data"`
}

type SteamAppData struct {
        Type                string                  `json:"type"`
        Name                string                  `json:"name"`
        SteamAppID          int                     `json:"steam_appid"`
        RequiredAge         int                     `json:"required_age"`
        IsFree              bool                    `json:"is_free"`
        ControllerSupport   string                  `json:"controller_support"`
        DLCs                []int                   `json:"dlc"`
        DetailedDescription string                  `json:"detailed_description"`
        AboutTheGame        string                  `json:"about_the_game"`
        ShortDescription    string                  `json:"short_description"`
        SupportedLanguages  string                  `json:"supported_languages"`
        Reviews             string                  `json:"reviews"`
        HeaderImage         string                  `json:"header_image"`
        Website             string                  `json:"website"`
        PCRequirements      SteamRequirements       `json:"pc_requirements"`
        MacRequirements     SteamRequirements       `json:"mac_requirements"`
        LinuxRequirements   SteamRequirements       `json:"linux_requirements"`
        LegalNotice         string                  `json:"legal_notice"`
        Developers          []string                `json:"developers"`
        Publishers          []string                `json:"publishers"`
        PriceOverview       SteamPriceOverview      `json:"price_overview"`
        Packages            []int                   `json:"packages"`
        PackageGroups       []SteamPackageGroup     `json:"package_groups"`
        Platforms           SteamPlatforms          `json:"platforms"`
        Metacritic          SteamMetacritic         `json:"metacritic"`
        Categories          []SteamCategory         `json:"categories"`
        Genres              []SteamGenre            `json:"genres"`
        Screenshots         []SteamScreenshot       `json:"screenshots"`
        Movies              []SteamMovie            `json:"movies"`
        Recommendations     SteamRecommendations    `json:"recommendations"`
        Achievements        SteamAchievements       `json:"achievements"`
        ReleaseDate         SteamReleaseDate        `json:"release_date"`
        SupportInfo         SteamSupportInfo        `json:"support_info"`
        Background          string                  `json:"background"`
        ContentDescriptors  SteamContentDescriptors `json:"content_descriptors"`
}

type SteamRequirements struct {
        Minimum     string `json:"minimum"`
        Recommended string `json:"recommended"`
}

type SteamPriceOverview struct {
        Currency         string `json:"currency"`
        Initial          int    `json:"initial"`
        Final            int    `json:"final"`
        DiscountPercent  int    `json:"discount_percent"`
        InitialFormatted string `json:"initial_formatted"`
        FinalFormatted   string `json:"final_formatted"`
}

type SteamPackageGroup struct {
        Name                    string     `json:"name"`
        Title                   string     `json:"title"`
        Description             string     `json:"description"`
        SelectionText           string     `json:"selection_text"`
        SaveText                string     `json:"save_text"`
        DisplayType             int        `json:"display_type"`
        IsRecurringSubscription string     `json:"is_recurring_subscription"`
        Subs                    []SteamSub `json:"subs"`
}

type SteamSub struct {
        PackageID                int    `json:"packageid"`
        PercentSavingsText       string `json:"percent_savings_text"`
        PercentSavings           int    `json:"percent_savings"`
        OptionText               string `json:"option_text"`
        OptionDescription        string `json:"option_description"`
        CanGetFreeLicense        string `json:"can_get_free_license"`
        IsFreeLicense            bool   `json:"is_free_license"`
        PriceInCentsWithDiscount int    `json:"price_in_cents_with_discount"`
}

type SteamPlatforms struct {
        Windows bool `json:"windows"`
        Mac     bool `json:"mac"`
        Linux   bool `json:"linux"`
}

type SteamMetacritic struct {
        Score int    `json:"score"`
        URL   string `json:"url"`
}

type SteamCategory struct {
        ID          int    `json:"id"`
        Description string `json:"description"`
}

type SteamGenre struct {
        ID          string `json:"id"`
        Description string `json:"description"`
}

type SteamScreenshot struct {
        ID            int    `json:"id"`
        PathThumbnail string `json:"path_thumbnail"`
        PathFull      string `json:"path_full"`
}

type SteamMovie struct {
        ID        int               `json:"id"`
        Name      string            `json:"name"`
        Thumbnail string            `json:"thumbnail"`
        Webm      map[string]string `json:"webm"`
        Mp4       map[string]string `json:"mp4"`
        Highlight bool              `json:"highlight"`
}

type SteamRecommendations struct {
        Total int `json:"total"`
}

type SteamAchievements struct {
        Total       int                `json:"total"`
        Highlighted []SteamAchievement `json:"highlighted"`
}

type SteamAchievement struct {
        Name string `json:"name"`
        Path string `json:"path"`
}

type SteamReleaseDate struct {
        ComingSoon bool   `json:"coming_soon"`
        Date       string `json:"date"`
}

type SteamSupportInfo struct {
        URL   string `json:"url"`
        Email string `json:"email"`
}

type SteamContentDescriptors struct {
        IDs   []int  `json:"ids"`
        Notes string `json:"notes"`
}

// Software identification structures
type SoftwareInfo struct {
        Name            string            `json:"name"`
        Version         string            `json:"version"`
        Architecture    string            `json:"architecture"`
        Platform        string            `json:"platform"`
        FileSize        int64             `json:"file_size"`
        FileHash        string            `json:"file_hash"`
        Publisher       string            `json:"publisher"`
        InstallLocation string            `json:"install_location"`
        Registry        map[string]string `json:"registry"`
        Dependencies    []string          `json:"dependencies"`
        PEInfo          *PEInfo           `json:"pe_info,omitempty"`
        ELFInfo         *ELFInfo          `json:"elf_info,omitempty"`
        MachoInfo       *MachoInfo        `json:"macho_info,omitempty"`
}

type PEInfo struct {
        Machine           string            `json:"machine"`
        Timestamp         int64             `json:"timestamp"`
        VersionInfo       map[string]string `json:"version_info"`
        ImportedLibraries []string          `json:"imported_libraries"`
        ExportedFunctions []string          `json:"exported_functions"`
        Sections          []PESection       `json:"sections"`
        Subsystem         string            `json:"subsystem"`
        EntryPoint        string            `json:"entry_point"`
}

type PESection struct {
        Name            string `json:"name"`
        VirtualAddress  string `json:"virtual_address"`
        VirtualSize     int    `json:"virtual_size"`
        RawSize         int    `json:"raw_size"`
        Characteristics string `json:"characteristics"`
}

type ELFInfo struct {
        Class            string       `json:"class"`
        Data             string       `json:"data"`
        Version          string       `json:"version"`
        OSABI            string       `json:"osabi"`
        Machine          string       `json:"machine"`
        Type             string       `json:"type"`
        EntryPoint       string       `json:"entry_point"`
        DynamicLibraries []string     `json:"dynamic_libraries"`
        Symbols          []string     `json:"symbols"`
        Sections         []ELFSection `json:"sections"`
}

type ELFSection struct {
        Name    string `json:"name"`
        Type    string `json:"type"`
        Address string `json:"address"`
        Size    int    `json:"size"`
        Flags   string `json:"flags"`
}

type MachoInfo struct {
        Architecture     string             `json:"architecture"`
        FileType         string             `json:"file_type"`
        LoadCommands     []MachoLoadCommand `json:"load_commands"`
        DynamicLibraries []string           `json:"dynamic_libraries"`
        Symbols          []string           `json:"symbols"`
}

type MachoLoadCommand struct {
        Command string `json:"command"`
        Size    int    `json:"size"`
        Data    string `json:"data"`
}

func NewGameSoftwareRecognitionProvider(logger *zap.Logger) *GameSoftwareRecognitionProvider <span class="cov0" title="0">{
        return &amp;GameSoftwareRecognitionProvider{
                logger:     logger,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                baseURLs: map[string]string{
                        "igdb":        "https://api.igdb.com/v4",
                        "steam":       "https://store.steampowered.com/api",
                        "github":      "https://api.github.com",
                        "sourceforge": "https://sourceforge.net/rest",
                        "winget":      "https://api.winget.run",
                        "flatpak":     "https://flathub.org/api",
                        "snapcraft":   "https://api.snapcraft.io",
                        "homebrew":    "https://formulae.brew.sh/api",
                },
                apiKeys: map[string]string{
                        "igdb":   "free_api_key",
                        "github": "free_api_key",
                },
                rateLimiter: make(map[string]*time.Ticker),
        }
}</span>

func (p *GameSoftwareRecognitionProvider) RecognizeMedia(ctx context.Context, req *MediaRecognitionRequest) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        p.logger.Info("Starting game/software recognition",
                zap.String("file_path", req.FilePath),
                zap.String("media_type", string(req.MediaType)))

        // Extract metadata from filename and file structure
        name, version, platform := p.extractSoftwareMetadataFromFilename(req.FileName)

        p.logger.Debug("Extracted metadata from filename",
                zap.String("name", name),
                zap.String("version", version),
                zap.String("platform", platform))

        // Determine if it's a game or software
        isGame := p.looksLikeGame(name, req.FileName)

        if isGame </span><span class="cov0" title="0">{
                // Try game recognition
                if result, err := p.recognizeGame(ctx, name, platform); err == nil </span><span class="cov0" title="0">{
                        p.logger.Info("Successfully recognized as game",
                                zap.String("name", result.Title),
                                zap.Float64("confidence", result.Confidence))
                        return result, nil
                }</span>
        }

        // Try software recognition
        <span class="cov0" title="0">if result, err := p.recognizeSoftware(ctx, name, version, platform, req); err == nil </span><span class="cov0" title="0">{
                p.logger.Info("Successfully recognized as software",
                        zap.String("name", result.Title),
                        zap.Float64("confidence", result.Confidence))
                return result, nil
        }</span>

        // Fallback to basic recognition
        <span class="cov0" title="0">return p.basicGameSoftwareRecognition(req, name, version, platform, isGame), nil</span>
}

func (p *GameSoftwareRecognitionProvider) recognizeGame(ctx context.Context, name, platform string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Try IGDB first
        if result, err := p.searchIGDB(ctx, name, platform); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try Steam as fallback
        <span class="cov0" title="0">if result, err := p.searchSteam(ctx, name); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no game recognition results found")</span>
}

func (p *GameSoftwareRecognitionProvider) searchIGDB(ctx context.Context, name, platform string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Build IGDB query
        query := fmt.Sprintf(`search "%s"; fields *; limit 10;`, name)

        req, err := http.NewRequestWithContext(ctx, "POST", p.baseURLs["igdb"]+"/games", strings.NewReader(query))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Client-ID", p.apiKeys["igdb"])
        req.Header.Set("Authorization", "Bearer "+p.apiKeys["igdb"])
        req.Header.Set("Content-Type", "text/plain")

        resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var games []IGDBGame
        if err := json.NewDecoder(resp.Body).Decode(&amp;games); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(games) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no games found in IGDB")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := games[0]

        return p.convertIGDBGame(bestMatch), nil</span>
}

func (p *GameSoftwareRecognitionProvider) convertIGDBGame(game IGDBGame) *MediaRecognitionResult <span class="cov0" title="0">{
        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("igdb_%d", game.ID),
                MediaType:         MediaTypeGame,
                Title:             game.Name,
                Description:       game.Summary,
                Rating:            game.Rating / 10.0, // IGDB uses 0-100 scale
                Confidence:        p.calculateIGDBConfidence(game.Rating, game.RatingCount, game.Popularity),
                RecognitionMethod: "igdb_api",
                APIProvider:       "IGDB",
                IGDBId:            strconv.Itoa(game.ID),
        }

        // Parse release date
        if game.FirstReleaseDate &gt; 0 </span><span class="cov0" title="0">{
                releaseDate := time.Unix(game.FirstReleaseDate, 0)
                result.ReleaseDate = &amp;releaseDate
                result.Year = releaseDate.Year()
        }</span>

        // Extract genres
        <span class="cov0" title="0">for _, genre := range game.Genres </span><span class="cov0" title="0">{
                result.Genres = append(result.Genres, genre.Name)
        }</span>

        // Extract platforms
        <span class="cov0" title="0">for _, platform := range game.Platforms </span><span class="cov0" title="0">{
                result.Platforms = append(result.Platforms, platform.Name)
        }</span>

        // Extract developer and publisher
        <span class="cov0" title="0">for _, company := range game.InvolvedCompanies </span><span class="cov0" title="0">{
                if company.Developer </span><span class="cov0" title="0">{
                        result.Developer = company.Company.Name
                }</span>
                <span class="cov0" title="0">if company.Publisher </span><span class="cov0" title="0">{
                        result.Publisher_Game = company.Company.Name
                }</span>
        }

        // Get cover art
        <span class="cov0" title="0">if game.Cover.URL != "" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        ID:      game.Cover.ImageID,
                        URL:     p.getIGDBImageURL(game.Cover.ImageID, "cover_big"),
                        Quality: "large",
                        Source:  "IGDB",
                })
        }</span>

        // Get screenshots
        <span class="cov0" title="0">for _, screenshot := range game.Screenshots </span><span class="cov0" title="0">{
                result.Screenshots = append(result.Screenshots, p.getIGDBImageURL(screenshot.ImageID, "screenshot_med"))
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "igdb_id": strconv.Itoa(game.ID),
        }

        // Parse external games for Steam ID
        for _, external := range game.ExternalGames </span><span class="cov0" title="0">{
                if external.Category == 1 </span><span class="cov0" title="0">{ // Steam
                        result.ExternalIDs["steam_id"] = external.UID
                        result.SteamID = external.UID
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func (p *GameSoftwareRecognitionProvider) searchSteam(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Steam doesn't have a direct search API, so we need to use app details
        // This is a simplified implementation - in practice, you'd maintain a database of Steam app IDs

        // For demonstration, we'll generate a mock Steam result
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("steam_%s", p.generateID(name)),
                MediaType:         MediaTypeGame,
                Title:             name,
                Confidence:        0.6,
                RecognitionMethod: "steam_lookup",
                APIProvider:       "Steam",
                ExternalIDs:       make(map[string]string),
        }, nil
}</span>

func (p *GameSoftwareRecognitionProvider) recognizeSoftware(ctx context.Context, name, version, platform string, req *MediaRecognitionRequest) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Try different software repositories based on platform
        switch strings.ToLower(platform) </span>{
        case "windows":<span class="cov0" title="0">
                if result, err := p.searchWinget(ctx, name); err == nil </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
        case "linux":<span class="cov0" title="0">
                if result, err := p.searchFlatpak(ctx, name); err == nil </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
                <span class="cov0" title="0">if result, err := p.searchSnapcraft(ctx, name); err == nil </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
        case "macos", "darwin":<span class="cov0" title="0">
                if result, err := p.searchHomebrew(ctx, name); err == nil </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
        }

        // Try GitHub for open source software
        <span class="cov0" title="0">if result, err := p.searchGitHub(ctx, name); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try SourceForge
        <span class="cov0" title="0">if result, err := p.searchSourceForge(ctx, name); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no software recognition results found")</span>
}

func (p *GameSoftwareRecognitionProvider) searchWinget(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Winget API search
        params := url.Values{}
        params.Set("query", name)

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/packages?%s", p.baseURLs["winget"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var packages []WingetPackage
        if err := json.NewDecoder(resp.Body).Decode(&amp;packages); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(packages) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no packages found in winget")
        }</span>

        <span class="cov0" title="0">pkg := packages[0]
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("winget_%s", pkg.PackageIdentifier),
                MediaType:         MediaTypeSoftware,
                Title:             pkg.PackageName,
                Publisher:         pkg.Publisher,
                Version:           pkg.PackageVersion,
                Platform:          "Windows",
                Confidence:        0.8,
                RecognitionMethod: "winget_api",
                APIProvider:       "Winget",
                ExternalIDs: map[string]string{
                        "winget_id": pkg.PackageIdentifier,
                },
        }, nil</span>
}

func (p *GameSoftwareRecognitionProvider) searchFlatpak(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Flatpak/Flathub API search
        params := url.Values{}
        params.Set("q", name)

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/v1/apps/search?%s", p.baseURLs["flatpak"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var apps []FlatpakApp
        if err := json.NewDecoder(resp.Body).Decode(&amp;apps); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(apps) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no apps found in Flatpak")
        }</span>

        <span class="cov0" title="0">app := apps[0]
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("flatpak_%s", app.FlatpakAppID),
                MediaType:         MediaTypeSoftware,
                Title:             app.Name,
                Description:       app.Summary,
                Platform:          "Linux",
                Confidence:        0.8,
                RecognitionMethod: "flatpak_api",
                APIProvider:       "Flatpak",
                ExternalIDs: map[string]string{
                        "flatpak_id": app.FlatpakAppID,
                },
        }, nil</span>
}

func (p *GameSoftwareRecognitionProvider) searchSnapcraft(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Snapcraft API search
        params := url.Values{}
        params.Set("q", name)

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/v2/find?%s", p.baseURLs["snapcraft"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var result SnapcraftSearchResult
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(result.Results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no snaps found in Snapcraft")
        }</span>

        <span class="cov0" title="0">snap := result.Results[0]
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("snap_%s", snap.Name),
                MediaType:         MediaTypeSoftware,
                Title:             snap.Title,
                Description:       snap.Summary,
                Publisher:         snap.Publisher.DisplayName,
                Platform:          "Linux",
                Confidence:        0.8,
                RecognitionMethod: "snapcraft_api",
                APIProvider:       "Snapcraft",
                ExternalIDs: map[string]string{
                        "snap_id": snap.Name,
                },
        }, nil</span>
}

func (p *GameSoftwareRecognitionProvider) searchHomebrew(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Homebrew formulae API
        resp, err := p.httpClient.Get(fmt.Sprintf("%s/formula/%s.json", p.baseURLs["homebrew"], name))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var formula HomebrewFormula
        if err := json.NewDecoder(resp.Body).Decode(&amp;formula); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("homebrew_%s", formula.Name),
                MediaType:         MediaTypeSoftware,
                Title:             formula.Name,
                Description:       formula.Desc,
                Version:           formula.Versions.Stable,
                Platform:          "macOS",
                Confidence:        0.8,
                RecognitionMethod: "homebrew_api",
                APIProvider:       "Homebrew",
                ExternalIDs: map[string]string{
                        "homebrew_name": formula.Name,
                },
        }, nil</span>
}

func (p *GameSoftwareRecognitionProvider) searchGitHub(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // GitHub repository search
        params := url.Values{}
        params.Set("q", name)
        params.Set("sort", "stars")
        params.Set("order", "desc")

        req, err := http.NewRequestWithContext(ctx, "GET", fmt.Sprintf("%s/search/repositories?%s", p.baseURLs["github"], params.Encode()), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "token "+p.apiKeys["github"])
        req.Header.Set("Accept", "application/vnd.github.v3+json")

        resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResult GitHubSearchResult
        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResult); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResult.Items) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no repositories found on GitHub")
        }</span>

        <span class="cov0" title="0">repo := searchResult.Items[0]
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("github_%d", repo.ID),
                MediaType:         MediaTypeSoftware,
                Title:             repo.Name,
                Description:       repo.Description,
                Developer:         repo.Owner.Login,
                License:           repo.License.Name,
                Confidence:        p.calculateGitHubConfidence(repo.StargazersCount, repo.ForksCount),
                RecognitionMethod: "github_api",
                APIProvider:       "GitHub",
                ExternalIDs: map[string]string{
                        "github_id":  strconv.Itoa(repo.ID),
                        "github_url": repo.HTMLURL,
                },
        }, nil</span>
}

func (p *GameSoftwareRecognitionProvider) searchSourceForge(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // SourceForge API search (simplified)
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("sourceforge_%s", p.generateID(name)),
                MediaType:         MediaTypeSoftware,
                Title:             name,
                Confidence:        0.5,
                RecognitionMethod: "sourceforge_lookup",
                APIProvider:       "SourceForge",
                ExternalIDs:       make(map[string]string),
        }, nil
}</span>

func (p *GameSoftwareRecognitionProvider) basicGameSoftwareRecognition(req *MediaRecognitionRequest, name, version, platform string, isGame bool) *MediaRecognitionResult <span class="cov0" title="0">{
        mediaType := MediaTypeSoftware
        if isGame </span><span class="cov0" title="0">{
                mediaType = MediaTypeGame
        }</span>

        <span class="cov0" title="0">return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("basic_%s_%s_%d", strings.ReplaceAll(name, " ", "_"), platform, time.Now().Unix()),
                MediaType:         mediaType,
                Title:             name,
                Version:           version,
                Platform:          platform,
                Confidence:        0.3,
                RecognitionMethod: "filename_parsing",
                APIProvider:       "basic",
                ExternalIDs:       make(map[string]string),
        }</span>
}

// Helper methods
func (p *GameSoftwareRecognitionProvider) extractSoftwareMetadataFromFilename(filename string) (name, version, platform string) <span class="cov0" title="0">{
        // Remove file extension
        baseName := strings.TrimSuffix(filename, "."+p.getFileExtension(filename))

        // Common patterns for software/games:
        // Name v1.0.0
        // Name-1.0.0-win32
        // Name_Setup_v1.0.exe
        // Game.Name.2023.Repack

        // Extract version patterns
        versionPatterns := []string{
                `v?(\d+\.\d+\.\d+)`,
                `v?(\d+\.\d+)`,
                `(\d{4})`, // Year as version
        }

        for _, pattern := range versionPatterns </span><span class="cov0" title="0">{
                re := regexp.MustCompile(pattern)
                if matches := re.FindStringSubmatch(baseName); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        version = matches[1]
                        // Remove version from name
                        baseName = re.ReplaceAllString(baseName, "")
                        break</span>
                }
        }

        // Extract platform patterns
        <span class="cov0" title="0">platformPatterns := map[string][]string{
                "windows": {"win", "windows", "x86", "x64", "win32", "win64"},
                "linux":   {"linux", "ubuntu", "debian", "fedora", "arch"},
                "macos":   {"mac", "macos", "osx", "darwin"},
                "android": {"android", "apk"},
                "ios":     {"ios", "iphone", "ipad"},
        }

        lowerName := strings.ToLower(baseName)
        for platformName, patterns := range platformPatterns </span><span class="cov0" title="0">{
                for _, pattern := range patterns </span><span class="cov0" title="0">{
                        if strings.Contains(lowerName, pattern) </span><span class="cov0" title="0">{
                                platform = platformName
                                // Remove platform identifier from name
                                baseName = regexp.MustCompile(`(?i)`+pattern).ReplaceAllString(baseName, "")
                                break</span>
                        }
                }
                <span class="cov0" title="0">if platform != "" </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // Clean up name
        <span class="cov0" title="0">name = regexp.MustCompile(`[._-]+`).ReplaceAllString(baseName, " ")
        name = regexp.MustCompile(`\s+`).ReplaceAllString(name, " ")
        name = strings.TrimSpace(name)

        // Remove common software suffixes
        suffixes := []string{"setup", "installer", "install", "portable", "repack", "crack", "keygen"}
        for _, suffix := range suffixes </span><span class="cov0" title="0">{
                re := regexp.MustCompile(`(?i)\b` + suffix + `\b`)
                name = re.ReplaceAllString(name, "")
        }</span>

        <span class="cov0" title="0">name = strings.TrimSpace(name)

        return name, version, platform</span>
}

func (p *GameSoftwareRecognitionProvider) looksLikeGame(name, filename string) bool <span class="cov0" title="0">{
        gameKeywords := []string{
                "game", "play", "quest", "adventure", "action", "rpg", "fps", "strategy",
                "simulation", "racing", "sports", "puzzle", "arcade", "indie", "multiplayer",
                "steam", "gog", "epic", "uplay", "origin", "battle.net",
        }

        searchText := strings.ToLower(name + " " + filename)
        for _, keyword := range gameKeywords </span><span class="cov0" title="0">{
                if strings.Contains(searchText, keyword) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (p *GameSoftwareRecognitionProvider) getFileExtension(filename string) string <span class="cov0" title="0">{
        parts := strings.Split(filename, ".")
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                return parts[len(parts)-1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (p *GameSoftwareRecognitionProvider) getIGDBImageURL(imageID, size string) string <span class="cov0" title="0">{
        return fmt.Sprintf("https://images.igdb.com/igdb/image/upload/t_%s/%s.jpg", size, imageID)
}</span>

func (p *GameSoftwareRecognitionProvider) calculateIGDBConfidence(rating float64, ratingCount int, popularity float64) float64 <span class="cov0" title="0">{
        confidence := 0.5

        if rating &gt; 70 &amp;&amp; ratingCount &gt; 100 </span><span class="cov0" title="0">{
                confidence += 0.3
        }</span> else<span class="cov0" title="0"> if rating &gt; 60 &amp;&amp; ratingCount &gt; 50 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">if popularity &gt; 10 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *GameSoftwareRecognitionProvider) calculateGitHubConfidence(stars, forks int) float64 <span class="cov0" title="0">{
        confidence := 0.5

        if stars &gt; 1000 </span><span class="cov0" title="0">{
                confidence += 0.3
        }</span> else<span class="cov0" title="0"> if stars &gt; 100 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">if forks &gt; 100 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *GameSoftwareRecognitionProvider) generateID(name string) string <span class="cov0" title="0">{
        hash := md5.Sum([]byte(name))
        return hex.EncodeToString(hash[:])[:12]
}</span>

// RecognitionProvider interface implementation
func (p *GameSoftwareRecognitionProvider) GetProviderName() string <span class="cov0" title="0">{
        return "game_software_recognition"
}</span>

func (p *GameSoftwareRecognitionProvider) SupportsMediaType(mediaType MediaType) bool <span class="cov0" title="0">{
        supportedTypes := []MediaType{
                MediaTypeGame,
                MediaTypeGameOS,
                MediaTypeSoftware,
                MediaTypeSoftwareOS,
        }

        for _, supported := range supportedTypes </span><span class="cov0" title="0">{
                if mediaType == supported </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (p *GameSoftwareRecognitionProvider) GetConfidenceThreshold() float64 <span class="cov0" title="0">{
        return 0.4
}</span>

// Additional API structures
type WingetPackage struct {
        PackageIdentifier string `json:"PackageIdentifier"`
        PackageName       string `json:"PackageName"`
        PackageVersion    string `json:"PackageVersion"`
        Publisher         string `json:"Publisher"`
}

type FlatpakApp struct {
        FlatpakAppID  string `json:"flatpakAppId"`
        Name          string `json:"name"`
        Summary       string `json:"summary"`
        Description   string `json:"description"`
        DeveloperName string `json:"developerName"`
}

type SnapcraftSearchResult struct {
        Results []SnapcraftSnap `json:"_embedded"`
}

type SnapcraftSnap struct {
        Name      string             `json:"name"`
        Title     string             `json:"title"`
        Summary   string             `json:"summary"`
        Publisher SnapcraftPublisher `json:"publisher"`
}

type SnapcraftPublisher struct {
        DisplayName string `json:"display-name"`
}

type HomebrewFormula struct {
        Name     string           `json:"name"`
        Desc     string           `json:"desc"`
        Versions HomebrewVersions `json:"versions"`
}

type HomebrewVersions struct {
        Stable string `json:"stable"`
        Head   string `json:"head"`
}

type GitHubSearchResult struct {
        Items []GitHubRepository `json:"items"`
}

type GitHubRepository struct {
        ID              int           `json:"id"`
        Name            string        `json:"name"`
        FullName        string        `json:"full_name"`
        Description     string        `json:"description"`
        HTMLURL         string        `json:"html_url"`
        StargazersCount int           `json:"stargazers_count"`
        ForksCount      int           `json:"forks_count"`
        Language        string        `json:"language"`
        License         GitHubLicense `json:"license"`
        Owner           GitHubOwner   `json:"owner"`
}

type GitHubLicense struct {
        Name string `json:"name"`
}

type GitHubOwner struct {
        Login string `json:"login"`
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "go.uber.org/zap"
)

type LocalizationService struct {
        db                 *sql.DB
        logger             *zap.Logger
        translationService *TranslationService
        cacheService       *CacheService
}

type UserLocalization struct {
        ID                    int64     `json:"id" db:"id"`
        UserID                int64     `json:"user_id" db:"user_id"`
        PrimaryLanguage       string    `json:"primary_language" db:"primary_language"`
        SecondaryLanguages    []string  `json:"secondary_languages" db:"secondary_languages"`
        SubtitleLanguages     []string  `json:"subtitle_languages" db:"subtitle_languages"`
        LyricsLanguages       []string  `json:"lyrics_languages" db:"lyrics_languages"`
        MetadataLanguages     []string  `json:"metadata_languages" db:"metadata_languages"`
        AutoTranslate         bool      `json:"auto_translate" db:"auto_translate"`
        AutoDownloadSubtitles bool      `json:"auto_download_subtitles" db:"auto_download_subtitles"`
        AutoDownloadLyrics    bool      `json:"auto_download_lyrics" db:"auto_download_lyrics"`
        PreferredRegion       string    `json:"preferred_region" db:"preferred_region"`
        DateFormat            string    `json:"date_format" db:"date_format"`
        TimeFormat            string    `json:"time_format" db:"time_format"`
        NumberFormat          string    `json:"number_format" db:"number_format"`
        CurrencyCode          string    `json:"currency_code" db:"currency_code"`
        CreatedAt             time.Time `json:"created_at" db:"created_at"`
        UpdatedAt             time.Time `json:"updated_at" db:"updated_at"`
}

type LanguageProfile struct {
        Code            string   `json:"code"`
        Name            string   `json:"name"`
        NativeName      string   `json:"native_name"`
        Direction       string   `json:"direction"`
        Region          string   `json:"region"`
        Country         string   `json:"country"`
        SupportedBy     []string `json:"supported_by"`
        QualityRating   float64  `json:"quality_rating"`
        PopularityScore int      `json:"popularity_score"`
}

type ContentLanguagePreference struct {
        ID          int64     `json:"id" db:"id"`
        UserID      int64     `json:"user_id" db:"user_id"`
        ContentType string    `json:"content_type" db:"content_type"`
        Languages   []string  `json:"languages" db:"languages"`
        Priority    int       `json:"priority" db:"priority"`
        AutoApply   bool      `json:"auto_apply" db:"auto_apply"`
        CreatedAt   time.Time `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time `json:"updated_at" db:"updated_at"`
}

type LocalizationStats struct {
        TotalUsers             int64                      `json:"total_users"`
        UsersWithLocalization  int64                      `json:"users_with_localization"`
        PopularLanguages       []LanguageStats            `json:"popular_languages"`
        PopularRegions         []RegionStats              `json:"popular_regions"`
        TranslationRequests    int64                      `json:"translation_requests"`
        AutoTranslationEnabled int64                      `json:"auto_translation_enabled"`
        LanguageSupport        map[string]LanguageSupport `json:"language_support"`
}

type LanguageStats struct {
        Language string  `json:"language"`
        Count    int64   `json:"count"`
        Percent  float64 `json:"percent"`
}

type RegionStats struct {
        Region  string  `json:"region"`
        Count   int64   `json:"count"`
        Percent float64 `json:"percent"`
}

type LanguageSupport struct {
        Subtitles bool `json:"subtitles"`
        Lyrics    bool `json:"lyrics"`
        Metadata  bool `json:"metadata"`
        UI        bool `json:"ui"`
}

type WizardLocalizationStep struct {
        UserID                int64    `json:"user_id"`
        PrimaryLanguage       string   `json:"primary_language"`
        SecondaryLanguages    []string `json:"secondary_languages"`
        SubtitleLanguages     []string `json:"subtitle_languages"`
        LyricsLanguages       []string `json:"lyrics_languages"`
        MetadataLanguages     []string `json:"metadata_languages"`
        AutoTranslate         bool     `json:"auto_translate"`
        AutoDownloadSubtitles bool     `json:"auto_download_subtitles"`
        AutoDownloadLyrics    bool     `json:"auto_download_lyrics"`
        PreferredRegion       string   `json:"preferred_region"`
        DateFormat            string   `json:"date_format"`
        TimeFormat            string   `json:"time_format"`
        NumberFormat          string   `json:"number_format"`
        CurrencyCode          string   `json:"currency_code"`
}

type ConfigurationExport struct {
        Version          string                  `json:"version"`
        ExportedAt       time.Time               `json:"exported_at"`
        ExportedBy       int64                   `json:"exported_by"`
        ConfigType       string                  `json:"config_type"`
        Localization     *UserLocalization       `json:"localization,omitempty"`
        WizardStep       *WizardLocalizationStep `json:"wizard_step,omitempty"`
        MediaSettings    *MediaPlayerConfig      `json:"media_settings,omitempty"`
        PlaylistSettings *PlaylistConfig         `json:"playlist_settings,omitempty"`
        Description      string                  `json:"description"`
        Tags             []string                `json:"tags"`
}

type MediaPlayerConfig struct {
        DefaultQuality    string             `json:"default_quality"`
        AutoPlay          bool               `json:"auto_play"`
        CrossfadeEnabled  bool               `json:"crossfade_enabled"`
        CrossfadeDuration int                `json:"crossfade_duration"`
        EqualizerPreset   string             `json:"equalizer_preset"`
        EqualizerBands    map[string]float64 `json:"equalizer_bands"`
        RepeatMode        string             `json:"repeat_mode"`
        ShuffleEnabled    bool               `json:"shuffle_enabled"`
        VolumeLevel       float64            `json:"volume_level"`
        ReplayGainEnabled bool               `json:"replay_gain_enabled"`
}

type PlaylistConfig struct {
        AutoCreatePlaylists  bool     `json:"auto_create_playlists"`
        SmartPlaylistRules   []string `json:"smart_playlist_rules"`
        DefaultPlaylistType  string   `json:"default_playlist_type"`
        CollaborativeDefault bool     `json:"collaborative_default"`
        PublicDefault        bool     `json:"public_default"`
}

type ConfigurationImportResult struct {
        Success          bool                 `json:"success"`
        ImportedConfig   *ConfigurationExport `json:"imported_config"`
        ValidationErrors []string             `json:"validation_errors"`
        AppliedSettings  []string             `json:"applied_settings"`
        SkippedSettings  []string             `json:"skipped_settings"`
        BackupCreated    bool                 `json:"backup_created"`
        BackupPath       string               `json:"backup_path"`
}

const (
        ContentTypeSubtitles = "subtitles"
        ContentTypeLyrics    = "lyrics"
        ContentTypeMetadata  = "metadata"
        ContentTypeUI        = "ui"
)

var SupportedLanguages = map[string]LanguageProfile{
        "en": {Code: "en", Name: "English", NativeName: "English", Direction: "ltr", Region: "US", Country: "United States", SupportedBy: []string{"subtitles", "lyrics", "metadata", "ui"}, QualityRating: 10.0, PopularityScore: 100},
        "es": {Code: "es", Name: "Spanish", NativeName: "Español", Direction: "ltr", Region: "ES", Country: "Spain", SupportedBy: []string{"subtitles", "lyrics", "metadata", "ui"}, QualityRating: 9.5, PopularityScore: 85},
        "fr": {Code: "fr", Name: "French", NativeName: "Français", Direction: "ltr", Region: "FR", Country: "France", SupportedBy: []string{"subtitles", "lyrics", "metadata", "ui"}, QualityRating: 9.5, PopularityScore: 75},
        "de": {Code: "de", Name: "German", NativeName: "Deutsch", Direction: "ltr", Region: "DE", Country: "Germany", SupportedBy: []string{"subtitles", "lyrics", "metadata", "ui"}, QualityRating: 9.2, PopularityScore: 70},
        "it": {Code: "it", Name: "Italian", NativeName: "Italiano", Direction: "ltr", Region: "IT", Country: "Italy", SupportedBy: []string{"subtitles", "lyrics", "metadata", "ui"}, QualityRating: 9.0, PopularityScore: 65},
        "pt": {Code: "pt", Name: "Portuguese", NativeName: "Português", Direction: "ltr", Region: "PT", Country: "Portugal", SupportedBy: []string{"subtitles", "lyrics", "metadata", "ui"}, QualityRating: 8.8, PopularityScore: 60},
        "ru": {Code: "ru", Name: "Russian", NativeName: "Русский", Direction: "ltr", Region: "RU", Country: "Russia", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.5, PopularityScore: 55},
        "ja": {Code: "ja", Name: "Japanese", NativeName: "日本語", Direction: "ltr", Region: "JP", Country: "Japan", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.8, PopularityScore: 50},
        "ko": {Code: "ko", Name: "Korean", NativeName: "한국어", Direction: "ltr", Region: "KR", Country: "South Korea", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.6, PopularityScore: 45},
        "zh": {Code: "zh", Name: "Chinese", NativeName: "中文", Direction: "ltr", Region: "CN", Country: "China", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.7, PopularityScore: 80},
        "ar": {Code: "ar", Name: "Arabic", NativeName: "العربية", Direction: "rtl", Region: "SA", Country: "Saudi Arabia", SupportedBy: []string{"subtitles", "metadata"}, QualityRating: 7.5, PopularityScore: 40},
        "hi": {Code: "hi", Name: "Hindi", NativeName: "हिन्दी", Direction: "ltr", Region: "IN", Country: "India", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 7.8, PopularityScore: 60},
        "nl": {Code: "nl", Name: "Dutch", NativeName: "Nederlands", Direction: "ltr", Region: "NL", Country: "Netherlands", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.9, PopularityScore: 30},
        "sv": {Code: "sv", Name: "Swedish", NativeName: "Svenska", Direction: "ltr", Region: "SE", Country: "Sweden", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.7, PopularityScore: 25},
        "no": {Code: "no", Name: "Norwegian", NativeName: "Norsk", Direction: "ltr", Region: "NO", Country: "Norway", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.6, PopularityScore: 20},
        "da": {Code: "da", Name: "Danish", NativeName: "Dansk", Direction: "ltr", Region: "DK", Country: "Denmark", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.5, PopularityScore: 18},
        "pl": {Code: "pl", Name: "Polish", NativeName: "Polski", Direction: "ltr", Region: "PL", Country: "Poland", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.3, PopularityScore: 35},
        "tr": {Code: "tr", Name: "Turkish", NativeName: "Türkçe", Direction: "ltr", Region: "TR", Country: "Turkey", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.0, PopularityScore: 30},
        "he": {Code: "he", Name: "Hebrew", NativeName: "עברית", Direction: "rtl", Region: "IL", Country: "Israel", SupportedBy: []string{"subtitles", "metadata"}, QualityRating: 7.8, PopularityScore: 15},
        "th": {Code: "th", Name: "Thai", NativeName: "ไทย", Direction: "ltr", Region: "TH", Country: "Thailand", SupportedBy: []string{"subtitles", "metadata"}, QualityRating: 7.2, PopularityScore: 25},
        "vi": {Code: "vi", Name: "Vietnamese", NativeName: "Tiếng Việt", Direction: "ltr", Region: "VN", Country: "Vietnam", SupportedBy: []string{"subtitles", "metadata"}, QualityRating: 7.0, PopularityScore: 28},
}

func NewLocalizationService(
        db *sql.DB,
        logger *zap.Logger,
        translationService *TranslationService,
        cacheService *CacheService,
) *LocalizationService <span class="cov0" title="0">{
        return &amp;LocalizationService{
                db:                 db,
                logger:             logger,
                translationService: translationService,
                cacheService:       cacheService,
        }
}</span>

func (s *LocalizationService) SetupUserLocalization(ctx context.Context, req *WizardLocalizationStep) (*UserLocalization, error) <span class="cov0" title="0">{
        s.logger.Info("Setting up user localization",
                zap.Int64("user_id", req.UserID),
                zap.String("primary_language", req.PrimaryLanguage))

        secondaryLanguagesJSON, _ := json.Marshal(req.SecondaryLanguages)
        subtitleLanguagesJSON, _ := json.Marshal(req.SubtitleLanguages)
        lyricsLanguagesJSON, _ := json.Marshal(req.LyricsLanguages)
        metadataLanguagesJSON, _ := json.Marshal(req.MetadataLanguages)

        query := `
                INSERT INTO user_localization (
                        user_id, primary_language, secondary_languages, subtitle_languages,
                        lyrics_languages, metadata_languages, auto_translate, auto_download_subtitles,
                        auto_download_lyrics, preferred_region, date_format, time_format,
                        number_format, currency_code, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, NOW(), NOW())
                ON CONFLICT (user_id)
                DO UPDATE SET
                        primary_language = EXCLUDED.primary_language,
                        secondary_languages = EXCLUDED.secondary_languages,
                        subtitle_languages = EXCLUDED.subtitle_languages,
                        lyrics_languages = EXCLUDED.lyrics_languages,
                        metadata_languages = EXCLUDED.metadata_languages,
                        auto_translate = EXCLUDED.auto_translate,
                        auto_download_subtitles = EXCLUDED.auto_download_subtitles,
                        auto_download_lyrics = EXCLUDED.auto_download_lyrics,
                        preferred_region = EXCLUDED.preferred_region,
                        date_format = EXCLUDED.date_format,
                        time_format = EXCLUDED.time_format,
                        number_format = EXCLUDED.number_format,
                        currency_code = EXCLUDED.currency_code,
                        updated_at = NOW()
                RETURNING id, created_at, updated_at
        `

        var localization UserLocalization
        err := s.db.QueryRowContext(ctx, query,
                req.UserID, req.PrimaryLanguage, string(secondaryLanguagesJSON),
                string(subtitleLanguagesJSON), string(lyricsLanguagesJSON),
                string(metadataLanguagesJSON), req.AutoTranslate, req.AutoDownloadSubtitles,
                req.AutoDownloadLyrics, req.PreferredRegion, req.DateFormat,
                req.TimeFormat, req.NumberFormat, req.CurrencyCode).Scan(
                &amp;localization.ID, &amp;localization.CreatedAt, &amp;localization.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to setup user localization", zap.Error(err))
                return nil, fmt.Errorf("failed to setup localization: %w", err)
        }</span>

        <span class="cov0" title="0">localization.UserID = req.UserID
        localization.PrimaryLanguage = req.PrimaryLanguage
        localization.SecondaryLanguages = req.SecondaryLanguages
        localization.SubtitleLanguages = req.SubtitleLanguages
        localization.LyricsLanguages = req.LyricsLanguages
        localization.MetadataLanguages = req.MetadataLanguages
        localization.AutoTranslate = req.AutoTranslate
        localization.AutoDownloadSubtitles = req.AutoDownloadSubtitles
        localization.AutoDownloadLyrics = req.AutoDownloadLyrics
        localization.PreferredRegion = req.PreferredRegion
        localization.DateFormat = req.DateFormat
        localization.TimeFormat = req.TimeFormat
        localization.NumberFormat = req.NumberFormat
        localization.CurrencyCode = req.CurrencyCode

        if err := s.setupContentPreferences(ctx, &amp;localization); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to setup content preferences", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.preloadTranslations(ctx, &amp;localization); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to preload translations", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return &amp;localization, nil</span>
}

func (s *LocalizationService) GetUserLocalization(ctx context.Context, userID int64) (*UserLocalization, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting user localization", zap.Int64("user_id", userID))

        query := `
                SELECT id, user_id, primary_language, secondary_languages, subtitle_languages,
                           lyrics_languages, metadata_languages, auto_translate, auto_download_subtitles,
                           auto_download_lyrics, preferred_region, date_format, time_format,
                           number_format, currency_code, created_at, updated_at
                FROM user_localization
                WHERE user_id = $1
        `

        var localization UserLocalization
        var secondaryLanguagesJSON, subtitleLanguagesJSON, lyricsLanguagesJSON, metadataLanguagesJSON string

        err := s.db.QueryRowContext(ctx, query, userID).Scan(
                &amp;localization.ID, &amp;localization.UserID, &amp;localization.PrimaryLanguage,
                &amp;secondaryLanguagesJSON, &amp;subtitleLanguagesJSON, &amp;lyricsLanguagesJSON,
                &amp;metadataLanguagesJSON, &amp;localization.AutoTranslate, &amp;localization.AutoDownloadSubtitles,
                &amp;localization.AutoDownloadLyrics, &amp;localization.PreferredRegion, &amp;localization.DateFormat,
                &amp;localization.TimeFormat, &amp;localization.NumberFormat, &amp;localization.CurrencyCode,
                &amp;localization.CreatedAt, &amp;localization.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return s.createDefaultLocalization(ctx, userID)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get user localization", zap.Error(err))
                return nil, fmt.Errorf("failed to get user localization: %w", err)
        }</span>

        <span class="cov0" title="0">json.Unmarshal([]byte(secondaryLanguagesJSON), &amp;localization.SecondaryLanguages)
        json.Unmarshal([]byte(subtitleLanguagesJSON), &amp;localization.SubtitleLanguages)
        json.Unmarshal([]byte(lyricsLanguagesJSON), &amp;localization.LyricsLanguages)
        json.Unmarshal([]byte(metadataLanguagesJSON), &amp;localization.MetadataLanguages)

        return &amp;localization, nil</span>
}

func (s *LocalizationService) UpdateUserLocalization(ctx context.Context, userID int64, updates map[string]interface{}) error <span class="cov0" title="0">{
        s.logger.Info("Updating user localization", zap.Int64("user_id", userID))

        if len(updates) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no updates provided")
        }</span>

        <span class="cov0" title="0">setParts := []string{}
        args := []interface{}{}
        argIndex := 1

        for field, value := range updates </span><span class="cov0" title="0">{
                switch field </span>{
                case "primary_language", "preferred_region", "date_format", "time_format", "number_format", "currency_code":<span class="cov0" title="0">
                        setParts = append(setParts, fmt.Sprintf("%s = $%d", field, argIndex))
                        args = append(args, value)
                        argIndex++</span>
                case "secondary_languages", "subtitle_languages", "lyrics_languages", "metadata_languages":<span class="cov0" title="0">
                        if languages, ok := value.([]string); ok </span><span class="cov0" title="0">{
                                languagesJSON, _ := json.Marshal(languages)
                                setParts = append(setParts, fmt.Sprintf("%s = $%d", field, argIndex))
                                args = append(args, string(languagesJSON))
                                argIndex++
                        }</span>
                case "auto_translate", "auto_download_subtitles", "auto_download_lyrics":<span class="cov0" title="0">
                        setParts = append(setParts, fmt.Sprintf("%s = $%d", field, argIndex))
                        args = append(args, value)
                        argIndex++</span>
                }
        }

        <span class="cov0" title="0">if len(setParts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no valid updates provided")
        }</span>

        <span class="cov0" title="0">setParts = append(setParts, "updated_at = NOW()")
        args = append(args, userID)

        query := fmt.Sprintf(`
                UPDATE user_localization
                SET %s
                WHERE user_id = $%d
        `, strings.Join(setParts, ", "), argIndex)

        _, err := s.db.ExecContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update user localization", zap.Error(err))
                return fmt.Errorf("failed to update user localization: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalizationService) GetPreferredLanguagesForContent(ctx context.Context, userID int64, contentType string) ([]string, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting preferred languages for content",
                zap.Int64("user_id", userID),
                zap.String("content_type", contentType))

        localization, err := s.GetUserLocalization(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return []string{"en"}, err
        }</span>

        <span class="cov0" title="0">switch contentType </span>{
        case ContentTypeSubtitles:<span class="cov0" title="0">
                if len(localization.SubtitleLanguages) &gt; 0 </span><span class="cov0" title="0">{
                        return localization.SubtitleLanguages, nil
                }</span>
        case ContentTypeLyrics:<span class="cov0" title="0">
                if len(localization.LyricsLanguages) &gt; 0 </span><span class="cov0" title="0">{
                        return localization.LyricsLanguages, nil
                }</span>
        case ContentTypeMetadata:<span class="cov0" title="0">
                if len(localization.MetadataLanguages) &gt; 0 </span><span class="cov0" title="0">{
                        return localization.MetadataLanguages, nil
                }</span>
        }

        <span class="cov0" title="0">languages := []string{localization.PrimaryLanguage}
        languages = append(languages, localization.SecondaryLanguages...)

        if len(languages) == 0 </span><span class="cov0" title="0">{
                return []string{"en"}, nil
        }</span>

        <span class="cov0" title="0">return languages, nil</span>
}

func (s *LocalizationService) ShouldAutoTranslate(ctx context.Context, userID int64, contentType string) (bool, error) <span class="cov0" title="0">{
        localization, err := s.GetUserLocalization(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return localization.AutoTranslate, nil</span>
}

func (s *LocalizationService) ShouldAutoDownload(ctx context.Context, userID int64, contentType string) (bool, error) <span class="cov0" title="0">{
        localization, err := s.GetUserLocalization(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">switch contentType </span>{
        case ContentTypeSubtitles:<span class="cov0" title="0">
                return localization.AutoDownloadSubtitles, nil</span>
        case ContentTypeLyrics:<span class="cov0" title="0">
                return localization.AutoDownloadLyrics, nil</span>
        default:<span class="cov0" title="0">
                return false, nil</span>
        }
}

func (s *LocalizationService) GetSupportedLanguages(ctx context.Context) (map[string]LanguageProfile, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting supported languages")

        cacheKey := "localization:supported_languages"
        var languages map[string]LanguageProfile

        found, err := s.cacheService.Get(ctx, cacheKey, &amp;languages)
        if err == nil &amp;&amp; found </span><span class="cov0" title="0">{
                return languages, nil
        }</span>

        <span class="cov0" title="0">languages = make(map[string]LanguageProfile)
        for code, profile := range SupportedLanguages </span><span class="cov0" title="0">{
                languages[code] = profile
        }</span>

        <span class="cov0" title="0">if err := s.cacheService.Set(ctx, cacheKey, languages, 24*time.Hour); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to cache supported languages", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return languages, nil</span>
}

func (s *LocalizationService) GetLanguageProfile(ctx context.Context, languageCode string) (*LanguageProfile, error) <span class="cov0" title="0">{
        if profile, exists := SupportedLanguages[languageCode]; exists </span><span class="cov0" title="0">{
                return &amp;profile, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("language not supported: %s", languageCode)</span>
}

func (s *LocalizationService) IsLanguageSupported(ctx context.Context, languageCode, contentType string) bool <span class="cov0" title="0">{
        profile, exists := SupportedLanguages[languageCode]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, supportedType := range profile.SupportedBy </span><span class="cov0" title="0">{
                if supportedType == contentType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (s *LocalizationService) GetLocalizationStats(ctx context.Context) (*LocalizationStats, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting localization statistics")

        stats := &amp;LocalizationStats{
                PopularLanguages: make([]LanguageStats, 0),
                PopularRegions:   make([]RegionStats, 0),
                LanguageSupport:  make(map[string]LanguageSupport),
        }

        if err := s.getBasicLocalizationStats(ctx, stats); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.getPopularLanguages(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get popular languages", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getPopularRegions(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get popular regions", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getLanguageSupport(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get language support", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (s *LocalizationService) createDefaultLocalization(ctx context.Context, userID int64) (*UserLocalization, error) <span class="cov0" title="0">{
        s.logger.Info("Creating default localization", zap.Int64("user_id", userID))

        defaultReq := &amp;WizardLocalizationStep{
                UserID:                userID,
                PrimaryLanguage:       "en",
                SecondaryLanguages:    []string{},
                SubtitleLanguages:     []string{"en"},
                LyricsLanguages:       []string{"en"},
                MetadataLanguages:     []string{"en"},
                AutoTranslate:         false,
                AutoDownloadSubtitles: true,
                AutoDownloadLyrics:    true,
                PreferredRegion:       "US",
                DateFormat:            "MM/DD/YYYY",
                TimeFormat:            "12h",
                NumberFormat:          "en-US",
                CurrencyCode:          "USD",
        }

        return s.SetupUserLocalization(ctx, defaultReq)
}</span>

func (s *LocalizationService) setupContentPreferences(ctx context.Context, localization *UserLocalization) error <span class="cov0" title="0">{
        contentTypes := []struct {
                Type      string
                Languages []string
        }{
                {ContentTypeSubtitles, localization.SubtitleLanguages},
                {ContentTypeLyrics, localization.LyricsLanguages},
                {ContentTypeMetadata, localization.MetadataLanguages},
        }

        for _, ct := range contentTypes </span><span class="cov0" title="0">{
                if len(ct.Languages) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">languagesJSON, _ := json.Marshal(ct.Languages)

                query := `
                        INSERT INTO content_language_preferences (user_id, content_type, languages, priority, auto_apply, created_at, updated_at)
                        VALUES ($1, $2, $3, 1, true, NOW(), NOW())
                        ON CONFLICT (user_id, content_type)
                        DO UPDATE SET
                                languages = EXCLUDED.languages,
                                auto_apply = EXCLUDED.auto_apply,
                                updated_at = NOW()
                `

                _, err := s.db.ExecContext(ctx, query, localization.UserID, ct.Type, string(languagesJSON))
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to setup content preference",
                                zap.String("content_type", ct.Type),
                                zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalizationService) preloadTranslations(ctx context.Context, localization *UserLocalization) error <span class="cov0" title="0">{
        if !localization.AutoTranslate </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">commonPhrases := []string{
                "Play", "Pause", "Stop", "Next", "Previous", "Volume", "Subtitles",
                "Audio", "Quality", "Fullscreen", "Playlist", "Lyrics", "Settings",
                "Search", "Library", "Recently Played", "Favorites", "Download",
                "Share", "Info", "Cast", "Speed", "Bookmark", "Chapter",
        }

        sourceLang := "en"
        targetLangs := append([]string{localization.PrimaryLanguage}, localization.SecondaryLanguages...)

        for _, targetLang := range targetLangs </span><span class="cov0" title="0">{
                if targetLang == sourceLang </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, phrase := range commonPhrases </span><span class="cov0" title="0">{
                        req := TranslationRequest{
                                Text:           phrase,
                                SourceLanguage: sourceLang,
                                TargetLanguage: targetLang,
                        }

                        go func(req TranslationRequest) </span><span class="cov0" title="0">{
                                _, err := s.translationService.TranslateText(ctx, req)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Debug("Failed to preload translation",
                                                zap.String("phrase", req.Text),
                                                zap.String("target_lang", req.TargetLanguage),
                                                zap.Error(err))
                                }</span>
                        }(req)
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalizationService) getBasicLocalizationStats(ctx context.Context, stats *LocalizationStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        (SELECT COUNT(*) FROM users) as total_users,
                        COUNT(*) as users_with_localization,
                        COUNT(CASE WHEN auto_translate = true THEN 1 END) as auto_translation_enabled
                FROM user_localization
        `

        return s.db.QueryRowContext(ctx, query).Scan(
                &amp;stats.TotalUsers, &amp;stats.UsersWithLocalization, &amp;stats.AutoTranslationEnabled)
}</span>

func (s *LocalizationService) getPopularLanguages(ctx context.Context, stats *LocalizationStats) error <span class="cov0" title="0">{
        query := `
                SELECT primary_language, COUNT(*) as count
                FROM user_localization
                GROUP BY primary_language
                ORDER BY count DESC
                LIMIT 10
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        total := float64(stats.UsersWithLocalization)
        for rows.Next() </span><span class="cov0" title="0">{
                var lang LanguageStats
                if err := rows.Scan(&amp;lang.Language, &amp;lang.Count); err == nil </span><span class="cov0" title="0">{
                        if total &gt; 0 </span><span class="cov0" title="0">{
                                lang.Percent = float64(lang.Count) / total * 100
                        }</span>
                        <span class="cov0" title="0">stats.PopularLanguages = append(stats.PopularLanguages, lang)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalizationService) getPopularRegions(ctx context.Context, stats *LocalizationStats) error <span class="cov0" title="0">{
        query := `
                SELECT preferred_region, COUNT(*) as count
                FROM user_localization
                WHERE preferred_region != ''
                GROUP BY preferred_region
                ORDER BY count DESC
                LIMIT 10
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        total := float64(stats.UsersWithLocalization)
        for rows.Next() </span><span class="cov0" title="0">{
                var region RegionStats
                if err := rows.Scan(&amp;region.Region, &amp;region.Count); err == nil </span><span class="cov0" title="0">{
                        if total &gt; 0 </span><span class="cov0" title="0">{
                                region.Percent = float64(region.Count) / total * 100
                        }</span>
                        <span class="cov0" title="0">stats.PopularRegions = append(stats.PopularRegions, region)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalizationService) getLanguageSupport(ctx context.Context, stats *LocalizationStats) error <span class="cov0" title="0">{
        for code, profile := range SupportedLanguages </span><span class="cov0" title="0">{
                support := LanguageSupport{}

                for _, contentType := range profile.SupportedBy </span><span class="cov0" title="0">{
                        switch contentType </span>{
                        case "subtitles":<span class="cov0" title="0">
                                support.Subtitles = true</span>
                        case "lyrics":<span class="cov0" title="0">
                                support.Lyrics = true</span>
                        case "metadata":<span class="cov0" title="0">
                                support.Metadata = true</span>
                        case "ui":<span class="cov0" title="0">
                                support.UI = true</span>
                        }
                }

                <span class="cov0" title="0">stats.LanguageSupport[code] = support</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalizationService) DetectUserLanguage(ctx context.Context, userAgent, acceptLanguage string) string <span class="cov0" title="0">{
        if acceptLanguage != "" </span><span class="cov0" title="0">{
                languages := strings.Split(acceptLanguage, ",")
                for _, lang := range languages </span><span class="cov0" title="0">{
                        langCode := strings.TrimSpace(strings.Split(lang, ";")[0])
                        langCode = strings.Split(langCode, "-")[0]

                        if _, exists := SupportedLanguages[langCode]; exists </span><span class="cov0" title="0">{
                                return langCode
                        }</span>
                }
        }

        <span class="cov0" title="0">return "en"</span>
}

func (s *LocalizationService) FormatDateTimeForUser(ctx context.Context, userID int64, timestamp time.Time) (string, error) <span class="cov0" title="0">{
        localization, err := s.GetUserLocalization(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return timestamp.Format("2006-01-02 15:04:05"), nil
        }</span>

        <span class="cov0" title="0">dateFormat := localization.DateFormat
        timeFormat := localization.TimeFormat

        var layout string
        switch dateFormat </span>{
        case "DD/MM/YYYY":<span class="cov0" title="0">
                layout = "02/01/2006"</span>
        case "YYYY-MM-DD":<span class="cov0" title="0">
                layout = "2006-01-02"</span>
        case "MM-DD-YYYY":<span class="cov0" title="0">
                layout = "01-02-2006"</span>
        default:<span class="cov0" title="0">
                layout = "01/02/2006"</span>
        }

        <span class="cov0" title="0">if timeFormat == "24h" </span><span class="cov0" title="0">{
                layout += " 15:04"
        }</span> else<span class="cov0" title="0"> {
                layout += " 03:04 PM"
        }</span>

        <span class="cov0" title="0">return timestamp.Format(layout), nil</span>
}

func (s *LocalizationService) GetWizardDefaults(ctx context.Context, detectedLanguage string) *WizardLocalizationStep <span class="cov0" title="0">{
        profile, exists := SupportedLanguages[detectedLanguage]
        if !exists </span><span class="cov0" title="0">{
                detectedLanguage = "en"
                profile = SupportedLanguages["en"]
        }</span>

        <span class="cov0" title="0">return &amp;WizardLocalizationStep{
                PrimaryLanguage:       detectedLanguage,
                SecondaryLanguages:    []string{},
                SubtitleLanguages:     []string{detectedLanguage, "en"},
                LyricsLanguages:       []string{detectedLanguage, "en"},
                MetadataLanguages:     []string{detectedLanguage, "en"},
                AutoTranslate:         detectedLanguage != "en",
                AutoDownloadSubtitles: true,
                AutoDownloadLyrics:    true,
                PreferredRegion:       profile.Region,
                DateFormat:            s.getDefaultDateFormat(profile.Region),
                TimeFormat:            s.getDefaultTimeFormat(profile.Region),
                NumberFormat:          detectedLanguage + "-" + profile.Region,
                CurrencyCode:          s.getDefaultCurrency(profile.Region),
        }</span>
}

func (s *LocalizationService) getDefaultDateFormat(region string) string <span class="cov0" title="0">{
        switch region </span>{
        case "US":<span class="cov0" title="0">
                return "MM/DD/YYYY"</span>
        case "GB", "AU", "NZ":<span class="cov0" title="0">
                return "DD/MM/YYYY"</span>
        default:<span class="cov0" title="0">
                return "YYYY-MM-DD"</span>
        }
}

func (s *LocalizationService) getDefaultTimeFormat(region string) string <span class="cov0" title="0">{
        switch region </span>{
        case "US":<span class="cov0" title="0">
                return "12h"</span>
        default:<span class="cov0" title="0">
                return "24h"</span>
        }
}

func (s *LocalizationService) getDefaultCurrency(region string) string <span class="cov0" title="0">{
        currencyMap := map[string]string{
                "US": "USD", "CA": "CAD", "GB": "GBP", "EU": "EUR", "FR": "EUR",
                "DE": "EUR", "IT": "EUR", "ES": "EUR", "PT": "EUR", "NL": "EUR",
                "JP": "JPY", "KR": "KRW", "CN": "CNY", "IN": "INR", "AU": "AUD",
                "RU": "RUB", "BR": "BRL", "MX": "MXN", "AR": "ARS", "SE": "SEK",
                "NO": "NOK", "DK": "DKK", "CH": "CHF", "PL": "PLN", "TR": "TRY",
        }

        if currency, exists := currencyMap[region]; exists </span><span class="cov0" title="0">{
                return currency
        }</span>
        <span class="cov0" title="0">return "USD"</span>
}

func (s *LocalizationService) ExportConfiguration(ctx context.Context, userID int64, configType string, description string, tags []string) (*ConfigurationExport, error) <span class="cov0" title="0">{
        s.logger.Info("Exporting user configuration",
                zap.Int64("user_id", userID),
                zap.String("config_type", configType))

        export := &amp;ConfigurationExport{
                Version:     "1.0",
                ExportedAt:  time.Now(),
                ExportedBy:  userID,
                ConfigType:  configType,
                Description: description,
                Tags:        tags,
        }

        // Export localization settings
        if configType == "full" || configType == "localization" </span><span class="cov0" title="0">{
                localization, err := s.GetUserLocalization(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to get localization for export", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        export.Localization = localization
                        export.WizardStep = s.convertLocalizationToWizardStep(localization)
                }</span>
        }

        // Export media player settings
        <span class="cov0" title="0">if configType == "full" || configType == "media" </span><span class="cov0" title="0">{
                mediaSettings, err := s.getMediaPlayerConfig(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to get media settings for export", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        export.MediaSettings = mediaSettings
                }</span>
        }

        // Export playlist settings
        <span class="cov0" title="0">if configType == "full" || configType == "playlists" </span><span class="cov0" title="0">{
                playlistSettings, err := s.getPlaylistConfig(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to get playlist settings for export", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        export.PlaylistSettings = playlistSettings
                }</span>
        }

        // Store export in database for future reference
        <span class="cov0" title="0">if err := s.storeConfigurationExport(ctx, export); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to store export record", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return export, nil</span>
}

func (s *LocalizationService) ImportConfiguration(ctx context.Context, userID int64, configJSON string, options map[string]bool) (*ConfigurationImportResult, error) <span class="cov0" title="0">{
        s.logger.Info("Importing user configuration", zap.Int64("user_id", userID))

        result := &amp;ConfigurationImportResult{
                Success:          false,
                ValidationErrors: make([]string, 0),
                AppliedSettings:  make([]string, 0),
                SkippedSettings:  make([]string, 0),
        }

        // Parse JSON configuration
        var config ConfigurationExport
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                result.ValidationErrors = append(result.ValidationErrors, fmt.Sprintf("Invalid JSON format: %v", err))
                return result, fmt.Errorf("failed to parse configuration JSON: %w", err)
        }</span>

        <span class="cov0" title="0">result.ImportedConfig = &amp;config

        // Validate configuration
        if validationErrors := s.validateConfiguration(&amp;config); len(validationErrors) &gt; 0 </span><span class="cov0" title="0">{
                result.ValidationErrors = append(result.ValidationErrors, validationErrors...)
                if !options["force_import"] </span><span class="cov0" title="0">{
                        return result, fmt.Errorf("configuration validation failed")
                }</span>
        }

        // Create backup of current settings
        <span class="cov0" title="0">if options["create_backup"] </span><span class="cov0" title="0">{
                backup, err := s.ExportConfiguration(ctx, userID, "full", "Pre-import backup", []string{"backup", "auto"})
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to create backup", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        result.BackupCreated = true
                        result.BackupPath = fmt.Sprintf("/backups/user_%d_%d.json", userID, backup.ExportedAt.Unix())
                }</span>
        }

        // Import localization settings
        <span class="cov0" title="0">if config.Localization != nil &amp;&amp; (options["import_localization"] || options["import_all"]) </span><span class="cov0" title="0">{
                if err := s.importLocalizationSettings(ctx, userID, config.Localization); err != nil </span><span class="cov0" title="0">{
                        result.SkippedSettings = append(result.SkippedSettings, fmt.Sprintf("Localization: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        result.AppliedSettings = append(result.AppliedSettings, "Localization preferences")
                }</span>
        }

        // Import wizard step configuration
        <span class="cov0" title="0">if config.WizardStep != nil &amp;&amp; (options["import_wizard"] || options["import_all"]) </span><span class="cov0" title="0">{
                if err := s.importWizardStepSettings(ctx, userID, config.WizardStep); err != nil </span><span class="cov0" title="0">{
                        result.SkippedSettings = append(result.SkippedSettings, fmt.Sprintf("Wizard step: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        result.AppliedSettings = append(result.AppliedSettings, "Wizard step configuration")
                }</span>
        }

        // Import media settings
        <span class="cov0" title="0">if config.MediaSettings != nil &amp;&amp; (options["import_media"] || options["import_all"]) </span><span class="cov0" title="0">{
                if err := s.importMediaSettings(ctx, userID, config.MediaSettings); err != nil </span><span class="cov0" title="0">{
                        result.SkippedSettings = append(result.SkippedSettings, fmt.Sprintf("Media settings: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        result.AppliedSettings = append(result.AppliedSettings, "Media player settings")
                }</span>
        }

        // Import playlist settings
        <span class="cov0" title="0">if config.PlaylistSettings != nil &amp;&amp; (options["import_playlists"] || options["import_all"]) </span><span class="cov0" title="0">{
                if err := s.importPlaylistSettings(ctx, userID, config.PlaylistSettings); err != nil </span><span class="cov0" title="0">{
                        result.SkippedSettings = append(result.SkippedSettings, fmt.Sprintf("Playlist settings: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        result.AppliedSettings = append(result.AppliedSettings, "Playlist settings")
                }</span>
        }

        <span class="cov0" title="0">result.Success = len(result.AppliedSettings) &gt; 0

        // Log import activity
        if err := s.logImportActivity(ctx, userID, &amp;config, result); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to log import activity", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (s *LocalizationService) ValidateConfigurationJSON(ctx context.Context, configJSON string) ([]string, error) <span class="cov0" title="0">{
        s.logger.Debug("Validating configuration JSON")

        var config ConfigurationExport
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                return []string{fmt.Sprintf("Invalid JSON format: %v", err)}, err
        }</span>

        <span class="cov0" title="0">return s.validateConfiguration(&amp;config), nil</span>
}

func (s *LocalizationService) GetConfigurationTemplate(ctx context.Context, templateType string) (*ConfigurationExport, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting configuration template", zap.String("type", templateType))

        template := &amp;ConfigurationExport{
                Version:     "1.0",
                ExportedAt:  time.Now(),
                ExportedBy:  0,
                ConfigType:  templateType,
                Description: fmt.Sprintf("Template for %s configuration", templateType),
                Tags:        []string{"template"},
        }

        switch templateType </span>{
        case "localization":<span class="cov0" title="0">
                template.Localization = s.getDefaultLocalizationTemplate()
                template.WizardStep = s.getDefaultWizardStepTemplate()</span>
        case "media":<span class="cov0" title="0">
                template.MediaSettings = s.getDefaultMediaSettingsTemplate()</span>
        case "playlists":<span class="cov0" title="0">
                template.PlaylistSettings = s.getDefaultPlaylistSettingsTemplate()</span>
        case "full":<span class="cov0" title="0">
                template.Localization = s.getDefaultLocalizationTemplate()
                template.WizardStep = s.getDefaultWizardStepTemplate()
                template.MediaSettings = s.getDefaultMediaSettingsTemplate()
                template.PlaylistSettings = s.getDefaultPlaylistSettingsTemplate()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown template type: %s", templateType)</span>
        }

        <span class="cov0" title="0">return template, nil</span>
}

func (s *LocalizationService) EditConfiguration(ctx context.Context, userID int64, configJSON string, edits map[string]interface{}) (string, error) <span class="cov0" title="0">{
        s.logger.Info("Editing configuration", zap.Int64("user_id", userID))

        var config ConfigurationExport
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse configuration JSON: %w", err)
        }</span>

        // Apply edits to the configuration
        <span class="cov0" title="0">for path, value := range edits </span><span class="cov0" title="0">{
                if err := s.applyConfigurationEdit(&amp;config, path, value); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to apply edit", zap.String("path", path), zap.Error(err))
                        return "", fmt.Errorf("failed to apply edit at path %s: %w", path, err)
                }</span>
        }

        // Update metadata
        <span class="cov0" title="0">config.ExportedAt = time.Now()
        config.ExportedBy = userID

        // Convert back to JSON
        editedJSON, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal edited configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return string(editedJSON), nil</span>
}

func (s *LocalizationService) ConvertWizardToConfiguration(ctx context.Context, wizardStep *WizardLocalizationStep) (*ConfigurationExport, error) <span class="cov0" title="0">{
        s.logger.Debug("Converting wizard step to configuration")

        config := &amp;ConfigurationExport{
                Version:     "1.0",
                ExportedAt:  time.Now(),
                ExportedBy:  wizardStep.UserID,
                ConfigType:  "wizard",
                WizardStep:  wizardStep,
                Description: "Configuration generated from installation wizard",
                Tags:        []string{"wizard", "generated"},
        }

        // Convert wizard step to full localization
        localization := &amp;UserLocalization{
                UserID:                wizardStep.UserID,
                PrimaryLanguage:       wizardStep.PrimaryLanguage,
                SecondaryLanguages:    wizardStep.SecondaryLanguages,
                SubtitleLanguages:     wizardStep.SubtitleLanguages,
                LyricsLanguages:       wizardStep.LyricsLanguages,
                MetadataLanguages:     wizardStep.MetadataLanguages,
                AutoTranslate:         wizardStep.AutoTranslate,
                AutoDownloadSubtitles: wizardStep.AutoDownloadSubtitles,
                AutoDownloadLyrics:    wizardStep.AutoDownloadLyrics,
                PreferredRegion:       wizardStep.PreferredRegion,
                DateFormat:            wizardStep.DateFormat,
                TimeFormat:            wizardStep.TimeFormat,
                NumberFormat:          wizardStep.NumberFormat,
                CurrencyCode:          wizardStep.CurrencyCode,
                CreatedAt:             time.Now(),
                UpdatedAt:             time.Now(),
        }

        config.Localization = localization

        return config, nil
}</span>

// Helper methods for configuration management

func (s *LocalizationService) convertLocalizationToWizardStep(localization *UserLocalization) *WizardLocalizationStep <span class="cov0" title="0">{
        return &amp;WizardLocalizationStep{
                UserID:                localization.UserID,
                PrimaryLanguage:       localization.PrimaryLanguage,
                SecondaryLanguages:    localization.SecondaryLanguages,
                SubtitleLanguages:     localization.SubtitleLanguages,
                LyricsLanguages:       localization.LyricsLanguages,
                MetadataLanguages:     localization.MetadataLanguages,
                AutoTranslate:         localization.AutoTranslate,
                AutoDownloadSubtitles: localization.AutoDownloadSubtitles,
                AutoDownloadLyrics:    localization.AutoDownloadLyrics,
                PreferredRegion:       localization.PreferredRegion,
                DateFormat:            localization.DateFormat,
                TimeFormat:            localization.TimeFormat,
                NumberFormat:          localization.NumberFormat,
                CurrencyCode:          localization.CurrencyCode,
        }
}</span>

func (s *LocalizationService) getMediaPlayerConfig(ctx context.Context, userID int64) (*MediaPlayerConfig, error) <span class="cov0" title="0">{
        // This would typically fetch from a user_media_settings table
        // For now, return default settings
        return &amp;MediaPlayerConfig{
                DefaultQuality:    "high",
                AutoPlay:          true,
                CrossfadeEnabled:  true,
                CrossfadeDuration: 3000,
                EqualizerPreset:   "flat",
                EqualizerBands:    make(map[string]float64),
                RepeatMode:        "none",
                ShuffleEnabled:    false,
                VolumeLevel:       1.0,
                ReplayGainEnabled: true,
        }, nil
}</span>

func (s *LocalizationService) getPlaylistConfig(ctx context.Context, userID int64) (*PlaylistConfig, error) <span class="cov0" title="0">{
        // This would typically fetch from a user_playlist_settings table
        // For now, return default settings
        return &amp;PlaylistConfig{
                AutoCreatePlaylists:  true,
                SmartPlaylistRules:   []string{"recently_played", "top_rated"},
                DefaultPlaylistType:  "standard",
                CollaborativeDefault: false,
                PublicDefault:        false,
        }, nil
}</span>

func (s *LocalizationService) validateConfiguration(config *ConfigurationExport) []string <span class="cov0" title="0">{
        var errors []string

        // Validate version
        if config.Version == "" </span><span class="cov0" title="0">{
                errors = append(errors, "Configuration version is required")
        }</span>

        // Validate config type
        <span class="cov0" title="0">validTypes := []string{"full", "localization", "media", "playlists", "wizard"}
        typeValid := false
        for _, validType := range validTypes </span><span class="cov0" title="0">{
                if config.ConfigType == validType </span><span class="cov0" title="0">{
                        typeValid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !typeValid </span><span class="cov0" title="0">{
                errors = append(errors, fmt.Sprintf("Invalid config type: %s", config.ConfigType))
        }</span>

        // Validate localization settings
        <span class="cov0" title="0">if config.Localization != nil </span><span class="cov0" title="0">{
                if config.Localization.PrimaryLanguage == "" </span><span class="cov0" title="0">{
                        errors = append(errors, "Primary language is required")
                }</span> else<span class="cov0" title="0"> if _, exists := SupportedLanguages[config.Localization.PrimaryLanguage]; !exists </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("Unsupported primary language: %s", config.Localization.PrimaryLanguage))
                }</span>

                // Validate secondary languages
                <span class="cov0" title="0">for _, lang := range config.Localization.SecondaryLanguages </span><span class="cov0" title="0">{
                        if _, exists := SupportedLanguages[lang]; !exists </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Sprintf("Unsupported secondary language: %s", lang))
                        }</span>
                }

                // Validate date/time formats
                <span class="cov0" title="0">validDateFormats := []string{"MM/DD/YYYY", "DD/MM/YYYY", "YYYY-MM-DD"}
                dateFormatValid := false
                for _, format := range validDateFormats </span><span class="cov0" title="0">{
                        if config.Localization.DateFormat == format </span><span class="cov0" title="0">{
                                dateFormatValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !dateFormatValid </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("Invalid date format: %s", config.Localization.DateFormat))
                }</span>

                <span class="cov0" title="0">validTimeFormats := []string{"12h", "24h"}
                timeFormatValid := false
                for _, format := range validTimeFormats </span><span class="cov0" title="0">{
                        if config.Localization.TimeFormat == format </span><span class="cov0" title="0">{
                                timeFormatValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !timeFormatValid </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("Invalid time format: %s", config.Localization.TimeFormat))
                }</span>
        }

        // Validate media settings
        <span class="cov0" title="0">if config.MediaSettings != nil </span><span class="cov0" title="0">{
                validQualities := []string{"low", "medium", "high", "lossless"}
                qualityValid := false
                for _, quality := range validQualities </span><span class="cov0" title="0">{
                        if config.MediaSettings.DefaultQuality == quality </span><span class="cov0" title="0">{
                                qualityValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !qualityValid </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("Invalid default quality: %s", config.MediaSettings.DefaultQuality))
                }</span>

                <span class="cov0" title="0">if config.MediaSettings.VolumeLevel &lt; 0 || config.MediaSettings.VolumeLevel &gt; 1 </span><span class="cov0" title="0">{
                        errors = append(errors, "Volume level must be between 0 and 1")
                }</span>

                <span class="cov0" title="0">if config.MediaSettings.CrossfadeDuration &lt; 0 || config.MediaSettings.CrossfadeDuration &gt; 10000 </span><span class="cov0" title="0">{
                        errors = append(errors, "Crossfade duration must be between 0 and 10000ms")
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

func (s *LocalizationService) importLocalizationSettings(ctx context.Context, userID int64, localization *UserLocalization) error <span class="cov0" title="0">{
        updates := map[string]interface{}{
                "primary_language":        localization.PrimaryLanguage,
                "secondary_languages":     localization.SecondaryLanguages,
                "subtitle_languages":      localization.SubtitleLanguages,
                "lyrics_languages":        localization.LyricsLanguages,
                "metadata_languages":      localization.MetadataLanguages,
                "auto_translate":          localization.AutoTranslate,
                "auto_download_subtitles": localization.AutoDownloadSubtitles,
                "auto_download_lyrics":    localization.AutoDownloadLyrics,
                "preferred_region":        localization.PreferredRegion,
                "date_format":             localization.DateFormat,
                "time_format":             localization.TimeFormat,
                "number_format":           localization.NumberFormat,
                "currency_code":           localization.CurrencyCode,
        }

        return s.UpdateUserLocalization(ctx, userID, updates)
}</span>

func (s *LocalizationService) importWizardStepSettings(ctx context.Context, userID int64, wizardStep *WizardLocalizationStep) error <span class="cov0" title="0">{
        wizardStep.UserID = userID
        _, err := s.SetupUserLocalization(ctx, wizardStep)
        return err
}</span>

func (s *LocalizationService) importMediaSettings(ctx context.Context, userID int64, mediaSettings *MediaPlayerConfig) error <span class="cov0" title="0">{
        // This would typically save to user_media_settings table
        s.logger.Info("Media settings imported", zap.Int64("user_id", userID))
        return nil
}</span>

func (s *LocalizationService) importPlaylistSettings(ctx context.Context, userID int64, playlistSettings *PlaylistConfig) error <span class="cov0" title="0">{
        // This would typically save to user_playlist_settings table
        s.logger.Info("Playlist settings imported", zap.Int64("user_id", userID))
        return nil
}</span>

func (s *LocalizationService) storeConfigurationExport(ctx context.Context, export *ConfigurationExport) error <span class="cov0" title="0">{
        exportJSON, err := json.Marshal(export)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO configuration_exports (user_id, config_type, config_data, description, tags, created_at)
                VALUES ($1, $2, $3, $4, $5, NOW())
        `

        tagsJSON, _ := json.Marshal(export.Tags)
        _, err = s.db.ExecContext(ctx, query, export.ExportedBy, export.ConfigType, string(exportJSON), export.Description, string(tagsJSON))
        return err</span>
}

func (s *LocalizationService) logImportActivity(ctx context.Context, userID int64, config *ConfigurationExport, result *ConfigurationImportResult) error <span class="cov0" title="0">{
        activityJSON, err := json.Marshal(map[string]interface{}{
                "config_version":    config.Version,
                "config_type":       config.ConfigType,
                "original_user":     config.ExportedBy,
                "applied_settings":  result.AppliedSettings,
                "skipped_settings":  result.SkippedSettings,
                "validation_errors": result.ValidationErrors,
                "backup_created":    result.BackupCreated,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO configuration_import_log (user_id, import_data, success, created_at)
                VALUES ($1, $2, $3, NOW())
        `

        _, err = s.db.ExecContext(ctx, query, userID, string(activityJSON), result.Success)
        return err</span>
}

func (s *LocalizationService) applyConfigurationEdit(config *ConfigurationExport, path string, value interface{}) error <span class="cov0" title="0">{
        parts := strings.Split(path, ".")

        switch parts[0] </span>{
        case "localization":<span class="cov0" title="0">
                if config.Localization == nil </span><span class="cov0" title="0">{
                        config.Localization = &amp;UserLocalization{}
                }</span>
                <span class="cov0" title="0">return s.applyLocalizationEdit(config.Localization, parts[1:], value)</span>
        case "wizard_step":<span class="cov0" title="0">
                if config.WizardStep == nil </span><span class="cov0" title="0">{
                        config.WizardStep = &amp;WizardLocalizationStep{}
                }</span>
                <span class="cov0" title="0">return s.applyWizardStepEdit(config.WizardStep, parts[1:], value)</span>
        case "media_settings":<span class="cov0" title="0">
                if config.MediaSettings == nil </span><span class="cov0" title="0">{
                        config.MediaSettings = &amp;MediaPlayerConfig{}
                }</span>
                <span class="cov0" title="0">return s.applyMediaSettingsEdit(config.MediaSettings, parts[1:], value)</span>
        case "playlist_settings":<span class="cov0" title="0">
                if config.PlaylistSettings == nil </span><span class="cov0" title="0">{
                        config.PlaylistSettings = &amp;PlaylistConfig{}
                }</span>
                <span class="cov0" title="0">return s.applyPlaylistSettingsEdit(config.PlaylistSettings, parts[1:], value)</span>
        case "description":<span class="cov0" title="0">
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        config.Description = str
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("description must be a string")</span>
        case "tags":<span class="cov0" title="0">
                if tags, ok := value.([]interface{}); ok </span><span class="cov0" title="0">{
                        stringTags := make([]string, len(tags))
                        for i, tag := range tags </span><span class="cov0" title="0">{
                                if str, ok := tag.(string); ok </span><span class="cov0" title="0">{
                                        stringTags[i] = str
                                }</span> else<span class="cov0" title="0"> {
                                        return fmt.Errorf("all tags must be strings")
                                }</span>
                        }
                        <span class="cov0" title="0">config.Tags = stringTags
                        return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("tags must be an array of strings")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown configuration path: %s", parts[0])</span>
        }
}

func (s *LocalizationService) applyLocalizationEdit(localization *UserLocalization, parts []string, value interface{}) error <span class="cov0" title="0">{
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid localization path")
        }</span>

        <span class="cov0" title="0">switch parts[0] </span>{
        case "primary_language":<span class="cov0" title="0">
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        localization.PrimaryLanguage = str
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("primary_language must be a string")</span>
        case "auto_translate":<span class="cov0" title="0">
                if b, ok := value.(bool); ok </span><span class="cov0" title="0">{
                        localization.AutoTranslate = b
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("auto_translate must be a boolean")</span>
        case "preferred_region":<span class="cov0" title="0">
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        localization.PreferredRegion = str
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("preferred_region must be a string")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown localization field: %s", parts[0])</span>
        }
}

func (s *LocalizationService) applyWizardStepEdit(wizardStep *WizardLocalizationStep, parts []string, value interface{}) error <span class="cov0" title="0">{
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid wizard step path")
        }</span>

        <span class="cov0" title="0">switch parts[0] </span>{
        case "primary_language":<span class="cov0" title="0">
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        wizardStep.PrimaryLanguage = str
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("primary_language must be a string")</span>
        case "auto_translate":<span class="cov0" title="0">
                if b, ok := value.(bool); ok </span><span class="cov0" title="0">{
                        wizardStep.AutoTranslate = b
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("auto_translate must be a boolean")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown wizard step field: %s", parts[0])</span>
        }
}

func (s *LocalizationService) applyMediaSettingsEdit(mediaSettings *MediaPlayerConfig, parts []string, value interface{}) error <span class="cov0" title="0">{
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid media settings path")
        }</span>

        <span class="cov0" title="0">switch parts[0] </span>{
        case "default_quality":<span class="cov0" title="0">
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        mediaSettings.DefaultQuality = str
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("default_quality must be a string")</span>
        case "volume_level":<span class="cov0" title="0">
                if f, ok := value.(float64); ok </span><span class="cov0" title="0">{
                        mediaSettings.VolumeLevel = f
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("volume_level must be a number")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown media settings field: %s", parts[0])</span>
        }
}

func (s *LocalizationService) applyPlaylistSettingsEdit(playlistSettings *PlaylistConfig, parts []string, value interface{}) error <span class="cov0" title="0">{
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid playlist settings path")
        }</span>

        <span class="cov0" title="0">switch parts[0] </span>{
        case "auto_create_playlists":<span class="cov0" title="0">
                if b, ok := value.(bool); ok </span><span class="cov0" title="0">{
                        playlistSettings.AutoCreatePlaylists = b
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("auto_create_playlists must be a boolean")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown playlist settings field: %s", parts[0])</span>
        }
}

func (s *LocalizationService) getDefaultLocalizationTemplate() *UserLocalization <span class="cov0" title="0">{
        return &amp;UserLocalization{
                PrimaryLanguage:       "en",
                SecondaryLanguages:    []string{},
                SubtitleLanguages:     []string{"en"},
                LyricsLanguages:       []string{"en"},
                MetadataLanguages:     []string{"en"},
                AutoTranslate:         false,
                AutoDownloadSubtitles: true,
                AutoDownloadLyrics:    true,
                PreferredRegion:       "US",
                DateFormat:            "MM/DD/YYYY",
                TimeFormat:            "12h",
                NumberFormat:          "en-US",
                CurrencyCode:          "USD",
        }
}</span>

func (s *LocalizationService) getDefaultWizardStepTemplate() *WizardLocalizationStep <span class="cov0" title="0">{
        return &amp;WizardLocalizationStep{
                PrimaryLanguage:       "en",
                SecondaryLanguages:    []string{},
                SubtitleLanguages:     []string{"en"},
                LyricsLanguages:       []string{"en"},
                MetadataLanguages:     []string{"en"},
                AutoTranslate:         false,
                AutoDownloadSubtitles: true,
                AutoDownloadLyrics:    true,
                PreferredRegion:       "US",
                DateFormat:            "MM/DD/YYYY",
                TimeFormat:            "12h",
                NumberFormat:          "en-US",
                CurrencyCode:          "USD",
        }
}</span>

func (s *LocalizationService) getDefaultMediaSettingsTemplate() *MediaPlayerConfig <span class="cov0" title="0">{
        return &amp;MediaPlayerConfig{
                DefaultQuality:    "high",
                AutoPlay:          true,
                CrossfadeEnabled:  false,
                CrossfadeDuration: 3000,
                EqualizerPreset:   "flat",
                EqualizerBands:    make(map[string]float64),
                RepeatMode:        "none",
                ShuffleEnabled:    false,
                VolumeLevel:       1.0,
                ReplayGainEnabled: false,
        }
}</span>

func (s *LocalizationService) getDefaultPlaylistSettingsTemplate() *PlaylistConfig <span class="cov0" title="0">{
        return &amp;PlaylistConfig{
                AutoCreatePlaylists:  false,
                SmartPlaylistRules:   []string{},
                DefaultPlaylistType:  "standard",
                CollaborativeDefault: false,
                PublicDefault:        false,
        }
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "catalogizer/utils"
        "go.uber.org/zap"
)

// LyricsService handles lyrics retrieval, synchronization, and caching
type LyricsService struct {
        db                 *sql.DB
        logger             *zap.Logger
        translationService *TranslationService
        httpClient         *http.Client
        apiKeys            map[string]string
        cacheDir           string
}

// LyricsProvider represents different lyrics providers
type LyricsProvider string

const (
        LyricsProviderGenius     LyricsProvider = "genius"
        LyricsProviderMusixmatch LyricsProvider = "musixmatch"
        LyricsProviderAZLyrics   LyricsProvider = "azlyrics"
        LyricsProviderLyricFind  LyricsProvider = "lyricfind"
        LyricsProviderSongLyrics LyricsProvider = "songlyrics"
        LyricsProviderEmbedded   LyricsProvider = "embedded"
)

// LyricsSearchRequest represents a lyrics search request
type LyricsSearchRequest struct {
        Title      string           `json:"title"`
        Artist     string           `json:"artist"`
        Album      *string          `json:"album,omitempty"`
        Duration   *float64         `json:"duration,omitempty"`
        Languages  []string         `json:"languages,omitempty"`
        Providers  []LyricsProvider `json:"providers,omitempty"`
        SyncedOnly bool             `json:"synced_only"`
        UseCache   bool             `json:"use_cache"`
}

// LyricsSearchResult represents a lyrics search result
type LyricsSearchResult struct {
        ID           string         `json:"id"`
        Provider     LyricsProvider `json:"provider"`
        Title        string         `json:"title"`
        Artist       string         `json:"artist"`
        Album        *string        `json:"album,omitempty"`
        Language     string         `json:"language"`
        LanguageCode string         `json:"language_code"`
        Content      string         `json:"content"`
        IsSynced     bool           `json:"is_synced"`
        SyncData     []LyricsLine   `json:"sync_data,omitempty"`
        Source       string         `json:"source"`
        Confidence   float64        `json:"confidence"`
        MatchScore   float64        `json:"match_score"`
        URL          *string        `json:"url,omitempty"`
        Copyright    *string        `json:"copyright,omitempty"`
        Writer       []string       `json:"writer,omitempty"`
        Publisher    *string        `json:"publisher,omitempty"`
}

// LyricsDownloadRequest represents a lyrics download request
type LyricsDownloadRequest struct {
        MediaItemID   int64    `json:"media_item_id"`
        ResultID      string   `json:"result_id"`
        Language      string   `json:"language"`
        AutoTranslate []string `json:"auto_translate,omitempty"`
        UseForConcert bool     `json:"use_for_concert"` // For concert videos
}

// LyricsTranslationRequest represents a lyrics translation request
type LyricsTranslationRequest struct {
        LyricsID       string `json:"lyrics_id"`
        SourceLanguage string `json:"source_language"`
        TargetLanguage string `json:"target_language"`
        PreserveTiming bool   `json:"preserve_timing"`
        UseCache       bool   `json:"use_cache"`
}

// LyricsSyncRequest represents a request to synchronize lyrics with audio
type LyricsSyncRequest struct {
        MediaItemID int64   `json:"media_item_id"`
        LyricsID    string  `json:"lyrics_id"`
        AudioPath   string  `json:"audio_path"`
        Method      string  `json:"method"` // "auto", "manual", "ai"
        Offset      float64 `json:"offset"` // Manual offset in seconds
}

// ConcertLyricsRequest represents a request to get lyrics for concert videos
type ConcertLyricsRequest struct {
        MediaItemID int64    `json:"media_item_id"`
        SetList     []string `json:"set_list,omitempty"` // List of songs if known
        Artist      string   `json:"artist"`
        VenueDate   *string  `json:"venue_date,omitempty"`
        Venue       *string  `json:"venue,omitempty"`
}

// SyncedLyricsLine represents a single line of synchronized lyrics
type SyncedLyricsLine struct {
        StartTime  float64  `json:"start_time"`
        EndTime    *float64 `json:"end_time,omitempty"`
        Text       string   `json:"text"`
        Type       string   `json:"type"` // "verse", "chorus", "bridge", "instrumental"
        Confidence float64  `json:"confidence"`
}

// NewLyricsService creates a new lyrics service
func NewLyricsService(db *sql.DB, logger *zap.Logger) *LyricsService <span class="cov0" title="0">{
        return &amp;LyricsService{
                db:                 db,
                logger:             logger,
                translationService: NewTranslationService(logger),
                httpClient:         &amp;http.Client{Timeout: 30 * time.Second},
                apiKeys:            make(map[string]string),
                cacheDir:           "./cache/lyrics",
        }
}</span>

// SearchLyrics searches for lyrics across multiple providers
func (s *LyricsService) SearchLyrics(ctx context.Context, request *LyricsSearchRequest) ([]LyricsSearchResult, error) <span class="cov0" title="0">{
        s.logger.Info("Searching lyrics",
                zap.String("title", request.Title),
                zap.String("artist", request.Artist))

        // Check cache first if requested
        if request.UseCache </span><span class="cov0" title="0">{
                if cached := s.getCachedLyrics(ctx, request.Title, request.Artist); cached != nil </span><span class="cov0" title="0">{
                        return []LyricsSearchResult{*cached}, nil
                }</span>
        }

        <span class="cov0" title="0">var allResults []LyricsSearchResult

        // Default providers if none specified
        providers := request.Providers
        if len(providers) == 0 </span><span class="cov0" title="0">{
                providers = []LyricsProvider{
                        LyricsProviderGenius,
                        LyricsProviderMusixmatch,
                        LyricsProviderAZLyrics,
                }
        }</span>

        // Search each provider
        <span class="cov0" title="0">for _, provider := range providers </span><span class="cov0" title="0">{
                results, err := s.searchProvider(ctx, provider, request)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Provider search failed",
                                zap.String("provider", string(provider)),
                                zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">allResults = append(allResults, results...)</span>
        }

        // Filter synced only if requested
        <span class="cov0" title="0">if request.SyncedOnly </span><span class="cov0" title="0">{
                allResults = s.filterSyncedLyrics(allResults)
        }</span>

        // Sort by match score and confidence
        <span class="cov0" title="0">s.sortLyricsResults(allResults)

        s.logger.Info("Lyrics search completed",
                zap.Int("total_results", len(allResults)))

        return allResults, nil</span>
}

// DownloadLyrics downloads and caches lyrics
func (s *LyricsService) DownloadLyrics(ctx context.Context, request *LyricsDownloadRequest) (*LyricsData, error) <span class="cov0" title="0">{
        s.logger.Info("Downloading lyrics",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("result_id", request.ResultID))

        // Get download info
        result, err := s.getLyricsDownloadInfo(ctx, request.ResultID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get download info: %w", err)
        }</span>

        // Create lyrics data
        <span class="cov0" title="0">lyricsData := &amp;LyricsData{
                ID:          generateLyricsID(),
                MediaItemID: request.MediaItemID,
                Source:      string(result.Provider),
                Language:    result.Language,
                Content:     result.Content,
                IsSynced:    result.IsSynced,
                SyncData:    result.SyncData,
                CreatedAt:   time.Now(),
                CachedAt:    timePtr(time.Now()),
        }

        // Save to database
        if err := s.saveLyricsData(ctx, lyricsData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save lyrics: %w", err)
        }</span>

        // Auto-translate if requested
        <span class="cov0" title="0">if len(request.AutoTranslate) &gt; 0 </span><span class="cov0" title="0">{
                go s.autoTranslateLyrics(ctx, lyricsData, request.AutoTranslate)
        }</span>

        <span class="cov0" title="0">return lyricsData, nil</span>
}

// TranslateLyrics translates lyrics to another language
func (s *LyricsService) TranslateLyrics(ctx context.Context, request *LyricsTranslationRequest) (*LyricsData, error) <span class="cov0" title="0">{
        s.logger.Info("Translating lyrics",
                zap.String("lyrics_id", request.LyricsID),
                zap.String("target_language", request.TargetLanguage))

        // Check cache first
        if request.UseCache </span><span class="cov0" title="0">{
                if cached := s.getCachedTranslation(ctx, request.LyricsID, request.TargetLanguage); cached != nil </span><span class="cov0" title="0">{
                        return cached, nil
                }</span>
        }

        // Get original lyrics
        <span class="cov0" title="0">original, err := s.getLyricsData(ctx, request.LyricsID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get original lyrics: %w", err)
        }</span>

        // Translate content
        <span class="cov0" title="0">translatedContent, err := s.translationService.TranslateText(ctx, TranslationRequest{
                Text:           original.Content,
                SourceLanguage: request.SourceLanguage,
                TargetLanguage: request.TargetLanguage,
                Context:        "lyrics",
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to translate lyrics: %w", err)
        }</span>

        // Create translated lyrics
        <span class="cov0" title="0">translatedLyrics := &amp;LyricsData{
                ID:          generateLyricsID(),
                MediaItemID: original.MediaItemID,
                Source:      "translated",
                Language:    getLanguageName(request.TargetLanguage),
                Content:     translatedContent.TranslatedText,
                IsSynced:    original.IsSynced &amp;&amp; request.PreserveTiming,
                CreatedAt:   time.Now(),
                CachedAt:    timePtr(time.Now()),
        }

        // Preserve timing if requested and available
        if request.PreserveTiming &amp;&amp; original.IsSynced </span><span class="cov0" title="0">{
                translatedLyrics.SyncData = s.preserveLyricsTiming(original.SyncData, translatedContent.TranslatedText)
        }</span>

        // Save translation
        <span class="cov0" title="0">if err := s.saveCachedLyricsTranslation(ctx, request.LyricsID, request.TargetLanguage, translatedLyrics); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to cache lyrics translation", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return translatedLyrics, nil</span>
}

// SynchronizeLyrics synchronizes lyrics with audio timing
func (s *LyricsService) SynchronizeLyrics(ctx context.Context, request *LyricsSyncRequest) (*LyricsData, error) <span class="cov0" title="0">{
        s.logger.Info("Synchronizing lyrics",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("method", request.Method))

        // Get existing lyrics
        lyrics, err := s.getLyricsData(ctx, request.LyricsID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get lyrics: %w", err)
        }</span>

        <span class="cov0" title="0">var syncData []LyricsLine

        switch request.Method </span>{
        case "auto":<span class="cov0" title="0">
                syncData, err = s.autoSynchronizeLyrics(ctx, lyrics, request.AudioPath)</span>
        case "manual":<span class="cov0" title="0">
                syncData, err = s.manualSynchronizeLyrics(ctx, lyrics, request.Offset)</span>
        case "ai":<span class="cov0" title="0">
                syncData, err = s.aiSynchronizeLyrics(ctx, lyrics, request.AudioPath)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported synchronization method: %s", request.Method)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to synchronize lyrics: %w", err)
        }</span>

        // Update lyrics with sync data
        <span class="cov0" title="0">lyrics.IsSynced = true
        lyrics.SyncData = syncData

        // Save updated lyrics
        if err := s.saveLyricsData(ctx, lyrics); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save synchronized lyrics: %w", err)
        }</span>

        <span class="cov0" title="0">return lyrics, nil</span>
}

// GetConcertLyrics gets lyrics for concert videos with setlist support
func (s *LyricsService) GetConcertLyrics(ctx context.Context, request *ConcertLyricsRequest) ([]*LyricsData, error) <span class="cov0" title="0">{
        s.logger.Info("Getting concert lyrics",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("artist", request.Artist))

        var concertLyrics []*LyricsData

        // If setlist is provided, get lyrics for each song
        if len(request.SetList) &gt; 0 </span><span class="cov0" title="0">{
                for _, song := range request.SetList </span><span class="cov0" title="0">{
                        lyricsSearch := &amp;LyricsSearchRequest{
                                Title:     song,
                                Artist:    request.Artist,
                                Languages: []string{"en"}, // Default to English, could be configurable
                                UseCache:  true,
                        }

                        results, err := s.SearchLyrics(ctx, lyricsSearch)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to find lyrics for concert song",
                                        zap.String("song", song),
                                        zap.Error(err))
                                continue</span>
                        }

                        <span class="cov0" title="0">if len(results) &gt; 0 </span><span class="cov0" title="0">{
                                // Take the best match
                                downloadReq := &amp;LyricsDownloadRequest{
                                        MediaItemID:   request.MediaItemID,
                                        ResultID:      results[0].ID,
                                        Language:      results[0].Language,
                                        UseForConcert: true,
                                }

                                lyrics, err := s.DownloadLyrics(ctx, downloadReq)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Warn("Failed to download concert lyrics",
                                                zap.String("song", song),
                                                zap.Error(err))
                                        continue</span>
                                }

                                <span class="cov0" title="0">concertLyrics = append(concertLyrics, lyrics)</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // Try to auto-detect setlist from concert metadata or title
                detectedSetlist, err := s.detectConcertSetlist(ctx, request)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to detect concert setlist", zap.Error(err))
                        return concertLyrics, nil
                }</span>

                // Recursively call with detected setlist
                <span class="cov0" title="0">request.SetList = detectedSetlist
                return s.GetConcertLyrics(ctx, request)</span>
        }

        <span class="cov0" title="0">return concertLyrics, nil</span>
}

// GetLyrics returns lyrics for a media item
func (s *LyricsService) GetLyrics(ctx context.Context, mediaItemID int64) (*LyricsData, error) <span class="cov0" title="0">{
        query := `
                SELECT id, media_item_id, source, language, content, is_synced,
                       sync_data, translations, created_at, cached_at
                FROM lyrics_data WHERE media_item_id = ?
                ORDER BY created_at DESC LIMIT 1`

        var lyrics LyricsData
        var syncDataJSON, translationsJSON sql.NullString
        var cachedAt sql.NullTime

        err := s.db.QueryRowContext(ctx, query, mediaItemID).Scan(
                &amp;lyrics.ID, &amp;lyrics.MediaItemID, &amp;lyrics.Source, &amp;lyrics.Language,
                &amp;lyrics.Content, &amp;lyrics.IsSynced, &amp;syncDataJSON, &amp;translationsJSON,
                &amp;lyrics.CreatedAt, &amp;cachedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil // No lyrics found
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get lyrics: %w", err)</span>
        }

        <span class="cov0" title="0">if cachedAt.Valid </span><span class="cov0" title="0">{
                lyrics.CachedAt = &amp;cachedAt.Time
        }</span>

        // Parse sync data
        <span class="cov0" title="0">if syncDataJSON.Valid &amp;&amp; syncDataJSON.String != "" </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(syncDataJSON.String), &amp;lyrics.SyncData); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to parse sync data", zap.Error(err))
                }</span>
        }

        // Parse translations
        <span class="cov0" title="0">if translationsJSON.Valid &amp;&amp; translationsJSON.String != "" </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(translationsJSON.String), &amp;lyrics.Translations); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to parse translations", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return &amp;lyrics, nil</span>
}

// Provider-specific implementations
func (s *LyricsService) searchProvider(ctx context.Context, provider LyricsProvider, request *LyricsSearchRequest) ([]LyricsSearchResult, error) <span class="cov0" title="0">{
        switch provider </span>{
        case LyricsProviderGenius:<span class="cov0" title="0">
                return s.searchGenius(ctx, request)</span>
        case LyricsProviderMusixmatch:<span class="cov0" title="0">
                return s.searchMusixmatch(ctx, request)</span>
        case LyricsProviderAZLyrics:<span class="cov0" title="0">
                return s.searchAZLyrics(ctx, request)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported provider: %s", provider)</span>
        }
}

func (s *LyricsService) searchGenius(ctx context.Context, request *LyricsSearchRequest) ([]LyricsSearchResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Searching Genius",
                zap.String("title", request.Title),
                zap.String("artist", request.Artist))

        // Mock implementation for demonstration
        result := LyricsSearchResult{
                ID:           "genius_1",
                Provider:     LyricsProviderGenius,
                Title:        request.Title,
                Artist:       request.Artist,
                Language:     "English",
                LanguageCode: "en",
                Content:      generateSampleLyrics(request.Title, request.Artist),
                IsSynced:     false,
                Source:       "genius.com",
                Confidence:   0.95,
                MatchScore:   0.9,
                URL:          utils.StringPtr("https://genius.com/sample"),
        }

        return []LyricsSearchResult{result}, nil
}</span>

func (s *LyricsService) searchMusixmatch(ctx context.Context, request *LyricsSearchRequest) ([]LyricsSearchResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Searching Musixmatch")

        // Mock synced lyrics
        syncData := []LyricsLine{
                {StartTime: 0.0, EndTime: floatPtr(3.5), Text: "Verse 1 line 1"},
                {StartTime: 3.5, EndTime: floatPtr(7.0), Text: "Verse 1 line 2"},
                {StartTime: 7.0, EndTime: floatPtr(10.5), Text: "Chorus line 1"},
                {StartTime: 10.5, EndTime: floatPtr(14.0), Text: "Chorus line 2"},
        }

        result := LyricsSearchResult{
                ID:           "musixmatch_1",
                Provider:     LyricsProviderMusixmatch,
                Title:        request.Title,
                Artist:       request.Artist,
                Language:     "English",
                LanguageCode: "en",
                Content:      generateSampleLyrics(request.Title, request.Artist),
                IsSynced:     true,
                SyncData:     syncData,
                Source:       "musixmatch.com",
                Confidence:   0.88,
                MatchScore:   0.85,
        }

        return []LyricsSearchResult{result}, nil
}</span>

func (s *LyricsService) searchAZLyrics(ctx context.Context, request *LyricsSearchRequest) ([]LyricsSearchResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Searching AZLyrics")
        return []LyricsSearchResult{}, nil
}</span>

// Synchronization methods
func (s *LyricsService) autoSynchronizeLyrics(ctx context.Context, lyrics *LyricsData, audioPath string) ([]LyricsLine, error) <span class="cov0" title="0">{
        // Implementation would use audio analysis to automatically sync lyrics
        // This is a complex process involving:
        // 1. Audio feature extraction
        // 2. Text-to-speech alignment
        // 3. Machine learning models for timing prediction

        s.logger.Debug("Auto-synchronizing lyrics", zap.String("audio_path", audioPath))

        // Mock implementation
        lines := s.parseLyricsLines(lyrics.Content)
        duration := 180.0 // Mock 3-minute song

        var syncData []LyricsLine
        timePerLine := duration / float64(len(lines))

        for i, line := range lines </span><span class="cov0" title="0">{
                startTime := float64(i) * timePerLine
                endTime := startTime + timePerLine

                syncData = append(syncData, LyricsLine{
                        StartTime: startTime,
                        EndTime:   &amp;endTime,
                        Text:      line,
                })
        }</span>

        <span class="cov0" title="0">return syncData, nil</span>
}

func (s *LyricsService) manualSynchronizeLyrics(ctx context.Context, lyrics *LyricsData, offset float64) ([]LyricsLine, error) <span class="cov0" title="0">{
        // Apply manual offset to existing sync data
        if !lyrics.IsSynced || len(lyrics.SyncData) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("lyrics not synchronized")
        }</span>

        <span class="cov0" title="0">var syncData []LyricsLine
        for _, line := range lyrics.SyncData </span><span class="cov0" title="0">{
                newLine := line
                newLine.StartTime += offset
                if newLine.EndTime != nil </span><span class="cov0" title="0">{
                        newEndTime := *newLine.EndTime + offset
                        newLine.EndTime = &amp;newEndTime
                }</span>
                <span class="cov0" title="0">syncData = append(syncData, newLine)</span>
        }

        <span class="cov0" title="0">return syncData, nil</span>
}

func (s *LyricsService) aiSynchronizeLyrics(ctx context.Context, lyrics *LyricsData, audioPath string) ([]LyricsLine, error) <span class="cov0" title="0">{
        // AI-powered synchronization using speech recognition and NLP
        s.logger.Debug("AI-synchronizing lyrics")

        // This would involve:
        // 1. Speech-to-text on the audio
        // 2. Text alignment algorithms
        // 3. AI models trained on synchronized lyrics

        return s.autoSynchronizeLyrics(ctx, lyrics, audioPath) // Fallback for now
}</span>

// Helper functions
func (s *LyricsService) parseLyricsLines(content string) []string <span class="cov0" title="0">{
        lines := strings.Split(content, "\n")
        var result []string

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line != "" &amp;&amp; !strings.HasPrefix(line, "[") </span><span class="cov0" title="0">{ // Skip structure markers
                        result = append(result, line)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func (s *LyricsService) filterSyncedLyrics(results []LyricsSearchResult) []LyricsSearchResult <span class="cov0" title="0">{
        var synced []LyricsSearchResult
        for _, result := range results </span><span class="cov0" title="0">{
                if result.IsSynced </span><span class="cov0" title="0">{
                        synced = append(synced, result)
                }</span>
        }
        <span class="cov0" title="0">return synced</span>
}

func (s *LyricsService) sortLyricsResults(results []LyricsSearchResult) <span class="cov0" title="0">{
        // Sort by match score, then by confidence
        for i := 0; i &lt; len(results)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(results); j++ </span><span class="cov0" title="0">{
                        if results[i].MatchScore &lt; results[j].MatchScore ||
                                (results[i].MatchScore == results[j].MatchScore &amp;&amp; results[i].Confidence &lt; results[j].Confidence) </span><span class="cov0" title="0">{
                                results[i], results[j] = results[j], results[i]
                        }</span>
                }
        }
}

func generateSampleLyrics(title, artist string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`[Verse 1]
Sample lyrics for "%s" by %s
This is a demonstration of lyrics content
With multiple lines and verses

[Chorus]
This is the chorus section
It repeats throughout the song
Making it memorable and catchy

[Verse 2]
Another verse with different content
Continuing the story or theme
Building on the first verse

[Chorus]
This is the chorus section
It repeats throughout the song
Making it memorable and catchy

[Bridge]
A bridge section with different melody
Providing contrast to verses and chorus
Leading back to the final chorus

[Chorus]
This is the chorus section
It repeats throughout the song
Making it memorable and catchy`, title, artist)
}</span>

func generateLyricsID() string <span class="cov0" title="0">{
        return fmt.Sprintf("lyrics_%d", time.Now().UnixNano())
}</span>

func timePtr(t time.Time) *time.Time <span class="cov0" title="0">{
        return &amp;t
}</span>

func floatPtr(f float64) *float64 <span class="cov0" title="0">{
        return &amp;f
}</span>

// getCachedLyrics retrieves cached lyrics for a title and artist
func (s *LyricsService) getCachedLyrics(ctx context.Context, title, artist string) *LyricsSearchResult <span class="cov0" title="0">{
        // Implementation would check cache for existing lyrics
        // For now, return nil (cache miss)
        return nil
}</span>

// getLyricsDownloadInfo retrieves download information for a lyrics result
func (s *LyricsService) getLyricsDownloadInfo(ctx context.Context, resultID string) (*LyricsSearchResult, error) <span class="cov0" title="0">{
        // Mock implementation - would normally fetch from provider
        return &amp;LyricsSearchResult{
                ID:           resultID,
                Provider:     LyricsProviderGenius,
                Title:        "Sample Title",
                Artist:       "Sample Artist",
                Language:     "English",
                LanguageCode: "en",
                Content:      "Sample lyrics content",
                IsSynced:     false,
                Source:       "genius.com",
                Confidence:   0.9,
                MatchScore:   0.85,
        }, nil
}</span>

// saveLyricsData saves lyrics data to the database
func (s *LyricsService) saveLyricsData(ctx context.Context, lyrics *LyricsData) error <span class="cov0" title="0">{
        syncDataJSON, err := json.Marshal(lyrics.SyncData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal sync data: %w", err)
        }</span>

        <span class="cov0" title="0">translationsJSON, err := json.Marshal(lyrics.Translations)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal translations: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO lyrics_data (id, media_item_id, source, language, content, is_synced, sync_data, translations, created_at, cached_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(id) DO UPDATE SET
                        content = excluded.content,
                        is_synced = excluded.is_synced,
                        sync_data = excluded.sync_data,
                        translations = excluded.translations,
                        cached_at = excluded.cached_at
        `

        var cachedAt interface{}
        if lyrics.CachedAt != nil </span><span class="cov0" title="0">{
                cachedAt = *lyrics.CachedAt
        }</span>

        <span class="cov0" title="0">_, err = s.db.ExecContext(ctx, query,
                lyrics.ID, lyrics.MediaItemID, lyrics.Source, lyrics.Language,
                lyrics.Content, lyrics.IsSynced, string(syncDataJSON), string(translationsJSON),
                lyrics.CreatedAt, cachedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save lyrics data: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// autoTranslateLyrics automatically translates lyrics to multiple languages
func (s *LyricsService) autoTranslateLyrics(ctx context.Context, lyrics *LyricsData, targetLanguages []string) <span class="cov0" title="0">{
        for _, targetLang := range targetLanguages </span><span class="cov0" title="0">{
                req := &amp;LyricsTranslationRequest{
                        LyricsID:       lyrics.ID,
                        SourceLanguage: lyrics.Language,
                        TargetLanguage: targetLang,
                        PreserveTiming: lyrics.IsSynced,
                        UseCache:       true,
                }

                _, err := s.TranslateLyrics(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to auto-translate lyrics",
                                zap.String("target_language", targetLang),
                                zap.Error(err))
                }</span>
        }
}

// getCachedTranslation retrieves a cached translation of lyrics
func (s *LyricsService) getCachedTranslation(ctx context.Context, lyricsID, targetLanguage string) *LyricsData <span class="cov0" title="0">{
        // Implementation would check cache for translated lyrics
        // For now, return nil (cache miss)
        return nil
}</span>

// getLyricsData retrieves lyrics data by ID
func (s *LyricsService) getLyricsData(ctx context.Context, lyricsID string) (*LyricsData, error) <span class="cov0" title="0">{
        query := `
                SELECT id, media_item_id, source, language, content, is_synced,
                       sync_data, translations, created_at, cached_at
                FROM lyrics_data WHERE id = ?
        `

        var lyrics LyricsData
        var syncDataJSON, translationsJSON sql.NullString
        var cachedAt sql.NullTime

        err := s.db.QueryRowContext(ctx, query, lyricsID).Scan(
                &amp;lyrics.ID, &amp;lyrics.MediaItemID, &amp;lyrics.Source, &amp;lyrics.Language,
                &amp;lyrics.Content, &amp;lyrics.IsSynced, &amp;syncDataJSON, &amp;translationsJSON,
                &amp;lyrics.CreatedAt, &amp;cachedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("lyrics not found: %s", lyricsID)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get lyrics data: %w", err)</span>
        }

        <span class="cov0" title="0">if cachedAt.Valid </span><span class="cov0" title="0">{
                lyrics.CachedAt = &amp;cachedAt.Time
        }</span>

        // Parse sync data
        <span class="cov0" title="0">if syncDataJSON.Valid &amp;&amp; syncDataJSON.String != "" </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(syncDataJSON.String), &amp;lyrics.SyncData); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to parse sync data", zap.Error(err))
                }</span>
        }

        // Parse translations
        <span class="cov0" title="0">if translationsJSON.Valid &amp;&amp; translationsJSON.String != "" </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(translationsJSON.String), &amp;lyrics.Translations); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to parse translations", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return &amp;lyrics, nil</span>
}

// saveCachedLyricsTranslation saves a cached translation of lyrics
func (s *LyricsService) saveCachedLyricsTranslation(ctx context.Context, originalID, targetLanguage string, translation *LyricsData) error <span class="cov0" title="0">{
        // Save the translation to database
        return s.saveLyricsData(ctx, translation)
}</span>

// preserveLyricsTiming preserves timing information when translating lyrics
func (s *LyricsService) preserveLyricsTiming(originalSyncData []LyricsLine, translatedText string) []LyricsLine <span class="cov0" title="0">{
        // Parse translated text into lines
        translatedLines := s.parseLyricsLines(translatedText)

        // If line counts don't match, we can't preserve timing perfectly
        if len(translatedLines) != len(originalSyncData) </span><span class="cov0" title="0">{
                s.logger.Warn("Translated lyrics line count mismatch",
                        zap.Int("original", len(originalSyncData)),
                        zap.Int("translated", len(translatedLines)))

                // Return best-effort sync data
                var syncData []LyricsLine
                minLen := len(originalSyncData)
                if len(translatedLines) &lt; minLen </span><span class="cov0" title="0">{
                        minLen = len(translatedLines)
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; minLen; i++ </span><span class="cov0" title="0">{
                        syncData = append(syncData, LyricsLine{
                                StartTime: originalSyncData[i].StartTime,
                                EndTime:   originalSyncData[i].EndTime,
                                Text:      translatedLines[i],
                        })
                }</span>
                <span class="cov0" title="0">return syncData</span>
        }

        // Create new sync data with preserved timing
        <span class="cov0" title="0">var syncData []LyricsLine
        for i, line := range originalSyncData </span><span class="cov0" title="0">{
                syncData = append(syncData, LyricsLine{
                        StartTime: line.StartTime,
                        EndTime:   line.EndTime,
                        Text:      translatedLines[i],
                })
        }</span>

        <span class="cov0" title="0">return syncData</span>
}

// detectConcertSetlist attempts to detect the setlist from concert metadata
func (s *LyricsService) detectConcertSetlist(ctx context.Context, request *ConcertLyricsRequest) ([]string, error) <span class="cov0" title="0">{
        // Implementation would analyze concert metadata, title, description
        // to extract song list. This could involve:
        // 1. Parsing video description
        // 2. Using AI/NLP to extract song names
        // 3. Querying setlist databases (setlist.fm, etc.)

        s.logger.Debug("Detecting concert setlist",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("artist", request.Artist))

        // Mock implementation - return empty list
        return []string{}, nil
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package services

import (
        "context"
        "database/sql"
        "fmt"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "go.uber.org/zap"
)

// MediaPlayerService handles all media playback functionality
type MediaPlayerService struct {
        db                 *sql.DB
        logger             *zap.Logger
        lyricsService      *LyricsService
        subtitleService    *SubtitleService
        coverArtService    *CoverArtService
        translationService *TranslationService
        positionTracker    *PlaybackPositionService
        playlistService    *PlaylistService
}

// MediaItem represents a media file with all its metadata
type MediaItem struct {
        ID        int64     `json:"id" db:"id"`
        Path      string    `json:"path" db:"path"`
        Filename  string    `json:"filename" db:"filename"`
        Title     string    `json:"title" db:"title"`
        MediaType MediaType `json:"media_type" db:"media_type"`
        MimeType  string    `json:"mime_type" db:"mime_type"`
        Size      int64     `json:"size" db:"size"`
        Duration  *float64  `json:"duration,omitempty" db:"duration"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
        UpdatedAt time.Time `json:"updated_at" db:"updated_at"`

        // Music-specific metadata
        Artist      *string `json:"artist,omitempty" db:"artist"`
        Album       *string `json:"album,omitempty" db:"album"`
        AlbumArtist *string `json:"album_artist,omitempty" db:"album_artist"`
        Genre       *string `json:"genre,omitempty" db:"genre"`
        Year        *int    `json:"year,omitempty" db:"year"`
        TrackNumber *int    `json:"track_number,omitempty" db:"track_number"`
        DiscNumber  *int    `json:"disc_number,omitempty" db:"disc_number"`

        // Video-specific metadata
        VideoCodec *string  `json:"video_codec,omitempty" db:"video_codec"`
        AudioCodec *string  `json:"audio_codec,omitempty" db:"audio_codec"`
        Resolution *string  `json:"resolution,omitempty" db:"resolution"`
        Framerate  *float64 `json:"framerate,omitempty" db:"framerate"`
        Bitrate    *int64   `json:"bitrate,omitempty" db:"bitrate"`

        // TV Show/Series metadata
        SeriesTitle  *string `json:"series_title,omitempty" db:"series_title"`
        Season       *int    `json:"season,omitempty" db:"season"`
        Episode      *int    `json:"episode,omitempty" db:"episode"`
        EpisodeTitle *string `json:"episode_title,omitempty" db:"episode_title"`

        // Additional metadata
        Description *string         `json:"description,omitempty" db:"description"`
        Language    *string         `json:"language,omitempty" db:"language"`
        Subtitles   []SubtitleTrack `json:"subtitles,omitempty"`
        CoverArt    *CoverArt       `json:"cover_art,omitempty"`
        Lyrics      *LyricsData     `json:"lyrics,omitempty"`
        Chapters    []Chapter       `json:"chapters,omitempty"`

        // Playback metadata
        LastPosition *float64   `json:"last_position,omitempty" db:"last_position"`
        PlayCount    int        `json:"play_count" db:"play_count"`
        LastPlayed   *time.Time `json:"last_played,omitempty" db:"last_played"`
        IsFavorite   bool       `json:"is_favorite" db:"is_favorite"`
        Rating       *int       `json:"rating,omitempty" db:"rating"` // 1-5 stars

        // Cached external data
        ExternalData map[string]interface{} `json:"external_data,omitempty"`
}

// PlaybackSession represents an active playback session
type PlaybackSession struct {
        ID              string        `json:"id"`
        UserID          string        `json:"user_id"`
        MediaItem       *MediaItem    `json:"media_item"`
        PlaylistID      *string       `json:"playlist_id,omitempty"`
        CurrentPosition float64       `json:"current_position"`
        State           PlaybackState `json:"state"`
        Volume          float64       `json:"volume"`
        PlaybackRate    float64       `json:"playback_rate"`
        RepeatMode      RepeatMode    `json:"repeat_mode"`
        ShuffleEnabled  bool          `json:"shuffle_enabled"`
        StartedAt       time.Time     `json:"started_at"`
        UpdatedAt       time.Time     `json:"updated_at"`

        // Current subtitle and audio tracks
        CurrentSubtitle *SubtitleTrack `json:"current_subtitle,omitempty"`
        CurrentAudio    *AudioTrack    `json:"current_audio,omitempty"`

        // Player-specific settings
        PlayerSettings map[string]interface{} `json:"player_settings,omitempty"`
}

// SubtitleTrack represents a subtitle track
type SubtitleTrack struct {
        ID           string    `json:"id"`
        Language     string    `json:"language"`
        LanguageCode string    `json:"language_code"`
        Source       string    `json:"source"` // "embedded", "external", "downloaded"
        Format       string    `json:"format"` // "srt", "vtt", "ass", etc.
        Path         *string   `json:"path,omitempty"`
        Content      *string   `json:"content,omitempty"`
        IsDefault    bool      `json:"is_default"`
        IsForced     bool      `json:"is_forced"`
        Encoding     string    `json:"encoding"`
        SyncOffset   float64   `json:"sync_offset"` // Milliseconds offset for sync adjustment
        CreatedAt    time.Time `json:"created_at"`
        VerifiedSync bool      `json:"verified_sync"` // Whether sync has been verified
}

// AudioTrack represents an audio track
type AudioTrack struct {
        ID         string  `json:"id"`
        Language   string  `json:"language"`
        Codec      string  `json:"codec"`
        Channels   int     `json:"channels"`
        Bitrate    *int64  `json:"bitrate,omitempty"`
        SampleRate *int    `json:"sample_rate,omitempty"`
        IsDefault  bool    `json:"is_default"`
        Title      *string `json:"title,omitempty"`
}

// Chapter represents a chapter or bookmark in media
type Chapter struct {
        ID        string   `json:"id"`
        Title     string   `json:"title"`
        StartTime float64  `json:"start_time"`
        EndTime   *float64 `json:"end_time,omitempty"`
        Thumbnail *string  `json:"thumbnail,omitempty"`
}

// CoverArt represents cover art metadata
type CoverArt struct {
        ID          string     `json:"id"`
        MediaItemID int64      `json:"media_item_id"`
        Source      string     `json:"source"` // "embedded", "local", "musicbrainz", "lastfm", etc.
        URL         *string    `json:"url,omitempty"`
        LocalPath   *string    `json:"local_path,omitempty"`
        Width       *int       `json:"width,omitempty"`
        Height      *int       `json:"height,omitempty"`
        Format      string     `json:"format"` // "jpeg", "png", "webp"
        Size        *int64     `json:"size,omitempty"`
        Quality     string     `json:"quality"` // "thumbnail", "medium", "high", "original"
        CreatedAt   time.Time  `json:"created_at"`
        CachedAt    *time.Time `json:"cached_at,omitempty"`
}

// LyricsData represents lyrics information
type LyricsData struct {
        ID           string            `json:"id"`
        MediaItemID  int64             `json:"media_item_id"`
        Source       string            `json:"source"` // "embedded", "genius", "musixmatch", etc.
        Language     string            `json:"language"`
        Content      string            `json:"content"`
        IsSynced     bool              `json:"is_synced"`
        SyncData     []LyricsLine      `json:"sync_data,omitempty"`
        Translations map[string]string `json:"translations,omitempty"` // language_code -&gt; translated content
        CreatedAt    time.Time         `json:"created_at"`
        CachedAt     *time.Time        `json:"cached_at,omitempty"`
}

// LyricsLine represents a synchronized lyrics line
type LyricsLine struct {
        StartTime float64  `json:"start_time"`
        EndTime   *float64 `json:"end_time,omitempty"`
        Text      string   `json:"text"`
}

// PlaybackRequest represents a request to start playback
type PlaybackRequest struct {
        MediaItemID    int64                  `json:"media_item_id"`
        PlaylistID     *string                `json:"playlist_id,omitempty"`
        StartPosition  *float64               `json:"start_position,omitempty"`
        Volume         *float64               `json:"volume,omitempty"`
        PlaybackRate   *float64               `json:"playback_rate,omitempty"`
        SubtitleLang   *string                `json:"subtitle_lang,omitempty"`
        AudioTrackID   *string                `json:"audio_track_id,omitempty"`
        PlayerSettings map[string]interface{} `json:"player_settings,omitempty"`
}

// PlaybackUpdateRequest represents a request to update playback state
type PlaybackUpdateRequest struct {
        SessionID       string         `json:"session_id"`
        Position        *float64       `json:"position,omitempty"`
        State           *PlaybackState `json:"state,omitempty"`
        Volume          *float64       `json:"volume,omitempty"`
        PlaybackRate    *float64       `json:"playback_rate,omitempty"`
        RepeatMode      *RepeatMode    `json:"repeat_mode,omitempty"`
        ShuffleEnabled  *bool          `json:"shuffle_enabled,omitempty"`
        SubtitleTrackID *string        `json:"subtitle_track_id,omitempty"`
        AudioTrackID    *string        `json:"audio_track_id,omitempty"`
}

// NewMediaPlayerService creates a new media player service
func NewMediaPlayerService(db *sql.DB, logger *zap.Logger) *MediaPlayerService <span class="cov0" title="0">{
        return &amp;MediaPlayerService{
                db:                 db,
                logger:             logger,
                lyricsService:      NewLyricsService(db, logger),
                subtitleService:    NewSubtitleService(db, logger),
                coverArtService:    NewCoverArtService(db, logger),
                translationService: NewTranslationService(logger),
                positionTracker:    NewPlaybackPositionService(db, logger),
                playlistService:    NewPlaylistService(db, logger),
        }
}</span>

// StartPlayback initiates playback of a media item
func (s *MediaPlayerService) StartPlayback(ctx context.Context, userID string, request *PlaybackRequest) (*PlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting playback",
                zap.String("user_id", userID),
                zap.Int64("media_item_id", request.MediaItemID))

        // Get media item
        mediaItem, err := s.GetMediaItem(ctx, request.MediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get media item: %w", err)
        }</span>

        // Create playback session
        <span class="cov0" title="0">defaultZero := 0.0
        defaultOne := 1.0
        session := &amp;PlaybackSession{
                ID:              generateSessionID(),
                UserID:          userID,
                MediaItem:       mediaItem,
                PlaylistID:      request.PlaylistID,
                CurrentPosition: getFloatValue(request.StartPosition, mediaItem.LastPosition, &amp;defaultZero),
                State:           PlaybackStateLoading,
                Volume:          getFloatValue(request.Volume, nil, &amp;defaultOne),
                PlaybackRate:    getFloatValue(request.PlaybackRate, nil, &amp;defaultOne),
                RepeatMode:      RepeatModeOff,
                ShuffleEnabled:  false,
                StartedAt:       time.Now(),
                UpdatedAt:       time.Now(),
                PlayerSettings:  request.PlayerSettings,
        }

        // Load subtitles if video
        if mediaItem.MediaType == MediaTypeVideo </span><span class="cov0" title="0">{
                subtitles, err := s.subtitleService.GetSubtitles(ctx, mediaItem.ID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to load subtitles", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        mediaItem.Subtitles = subtitles
                        // Set default subtitle track
                        if request.SubtitleLang != nil </span><span class="cov0" title="0">{
                                session.CurrentSubtitle = s.findSubtitleByLanguage(subtitles, *request.SubtitleLang)
                        }</span>
                }
        }

        // Load lyrics if music
        <span class="cov0" title="0">if mediaItem.MediaType == MediaTypeMusic </span><span class="cov0" title="0">{
                lyrics, err := s.lyricsService.GetLyrics(ctx, mediaItem.ID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to load lyrics", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        mediaItem.Lyrics = lyrics
                }</span>
        }

        // Load cover art
        <span class="cov0" title="0">coverArt, err := s.coverArtService.GetCoverArt(ctx, mediaItem.ID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load cover art", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                mediaItem.CoverArt = coverArt
        }</span>

        // Save session
        <span class="cov0" title="0">if err := s.savePlaybackSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save playback session: %w", err)
        }</span>

        // Update play count and last played
        <span class="cov0" title="0">go s.updatePlaybackStats(ctx, mediaItem.ID)

        return session, nil</span>
}

// UpdatePlayback updates the playback state
func (s *MediaPlayerService) UpdatePlayback(ctx context.Context, userID string, request *PlaybackUpdateRequest) error <span class="cov0" title="0">{
        s.logger.Debug("Updating playback",
                zap.String("session_id", request.SessionID),
                zap.String("user_id", userID))

        session, err := s.getPlaybackSession(ctx, request.SessionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get playback session: %w", err)
        }</span>

        // Update fields if provided
        <span class="cov0" title="0">if request.Position != nil </span><span class="cov0" title="0">{
                session.CurrentPosition = *request.Position
                // Save position to database for resume functionality
                userIDInt, _ := strconv.ParseInt(userID, 10, 64)
                go s.positionTracker.UpdatePosition(ctx, &amp;UpdatePositionRequest{
                        UserID:      userIDInt,
                        MediaItemID: session.MediaItem.ID,
                        Position:    int64(*request.Position * 1000), // Convert seconds to milliseconds
                        Duration:    0,                               // Duration unknown at this point
                })
        }</span>

        <span class="cov0" title="0">if request.State != nil </span><span class="cov0" title="0">{
                session.State = *request.State
        }</span>

        <span class="cov0" title="0">if request.Volume != nil </span><span class="cov0" title="0">{
                session.Volume = *request.Volume
        }</span>

        <span class="cov0" title="0">if request.PlaybackRate != nil </span><span class="cov0" title="0">{
                session.PlaybackRate = *request.PlaybackRate
        }</span>

        <span class="cov0" title="0">if request.RepeatMode != nil </span><span class="cov0" title="0">{
                session.RepeatMode = *request.RepeatMode
        }</span>

        <span class="cov0" title="0">if request.ShuffleEnabled != nil </span><span class="cov0" title="0">{
                session.ShuffleEnabled = *request.ShuffleEnabled
        }</span>

        // Update subtitle track
        <span class="cov0" title="0">if request.SubtitleTrackID != nil </span><span class="cov0" title="0">{
                session.CurrentSubtitle = s.findSubtitleByID(session.MediaItem.Subtitles, *request.SubtitleTrackID)
        }</span>

        <span class="cov0" title="0">session.UpdatedAt = time.Now()

        // Save updated session
        return s.savePlaybackSession(ctx, session)</span>
}

// GetMediaItem retrieves a media item by ID
func (s *MediaPlayerService) GetMediaItem(ctx context.Context, id int64) (*MediaItem, error) <span class="cov0" title="0">{
        query := `
                SELECT id, path, filename, title, media_type, mime_type, size, duration,
                       artist, album, album_artist, genre, year, track_number, disc_number,
                       video_codec, audio_codec, resolution, framerate, bitrate,
                       series_title, season, episode, episode_title,
                       description, language, last_position, play_count, last_played,
                       is_favorite, rating, created_at, updated_at
                FROM media_items WHERE id = ?`

        var item MediaItem
        var lastPlayed sql.NullTime

        err := s.db.QueryRowContext(ctx, query, id).Scan(
                &amp;item.ID, &amp;item.Path, &amp;item.Filename, &amp;item.Title, &amp;item.MediaType, &amp;item.MimeType,
                &amp;item.Size, &amp;item.Duration, &amp;item.Artist, &amp;item.Album, &amp;item.AlbumArtist,
                &amp;item.Genre, &amp;item.Year, &amp;item.TrackNumber, &amp;item.DiscNumber,
                &amp;item.VideoCodec, &amp;item.AudioCodec, &amp;item.Resolution, &amp;item.Framerate, &amp;item.Bitrate,
                &amp;item.SeriesTitle, &amp;item.Season, &amp;item.Episode, &amp;item.EpisodeTitle,
                &amp;item.Description, &amp;item.Language, &amp;item.LastPosition, &amp;item.PlayCount,
                &amp;lastPlayed, &amp;item.IsFavorite, &amp;item.Rating, &amp;item.CreatedAt, &amp;item.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("media item not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get media item: %w", err)</span>
        }

        <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                item.LastPlayed = &amp;lastPlayed.Time
        }</span>

        <span class="cov0" title="0">return &amp;item, nil</span>
}

// Helper functions
func generateSessionID() string <span class="cov0" title="0">{
        return fmt.Sprintf("session_%d", time.Now().UnixNano())
}</span>

func getFloatValue(values ...*float64) float64 <span class="cov0" title="0">{
        for _, v := range values </span><span class="cov0" title="0">{
                if v != nil </span><span class="cov0" title="0">{
                        return *v
                }</span>
        }
        <span class="cov0" title="0">return 0.0</span>
}

func (s *MediaPlayerService) findSubtitleByLanguage(subtitles []SubtitleTrack, lang string) *SubtitleTrack <span class="cov0" title="0">{
        for _, sub := range subtitles </span><span class="cov0" title="0">{
                if sub.Language == lang || sub.LanguageCode == lang </span><span class="cov0" title="0">{
                        return &amp;sub
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *MediaPlayerService) findSubtitleByID(subtitles []SubtitleTrack, id string) *SubtitleTrack <span class="cov0" title="0">{
        for _, sub := range subtitles </span><span class="cov0" title="0">{
                if sub.ID == id </span><span class="cov0" title="0">{
                        return &amp;sub
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *MediaPlayerService) savePlaybackSession(ctx context.Context, session *PlaybackSession) error <span class="cov0" title="0">{
        // Implementation would save to Redis or database
        // For now, we'll use in-memory storage or database
        s.logger.Debug("Saving playback session", zap.String("session_id", session.ID))
        return nil
}</span>

func (s *MediaPlayerService) getPlaybackSession(ctx context.Context, sessionID, userID string) (*PlaybackSession, error) <span class="cov0" title="0">{
        // Implementation would retrieve from Redis or database
        s.logger.Debug("Getting playback session", zap.String("session_id", sessionID))
        return nil, fmt.Errorf("session not found")
}</span>

func (s *MediaPlayerService) updatePlaybackStats(ctx context.Context, mediaItemID int64) <span class="cov0" title="0">{
        query := `UPDATE media_items SET play_count = play_count + 1, last_played = ? WHERE id = ?`
        _, err := s.db.ExecContext(ctx, query, time.Now(), mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update playback stats", zap.Error(err))
        }</span>
}

// GetSupportedMediaTypes returns all supported media types
func (s *MediaPlayerService) GetSupportedMediaTypes() []MediaType <span class="cov0" title="0">{
        return []MediaType{
                MediaTypeMusic,
                MediaTypeVideo,
                MediaTypeGame,
                MediaTypeSoftware,
                MediaTypeEbook,
                MediaTypeDocument,
        }
}</span>

// GetMediaTypeFromExtension determines media type from file extension
func GetMediaTypeFromExtension(filename string) MediaType <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(filename))

        // Music formats
        musicExts := map[string]bool{
                ".mp3": true, ".flac": true, ".wav": true, ".aac": true, ".ogg": true,
                ".m4a": true, ".wma": true, ".opus": true, ".aiff": true, ".ape": true,
        }

        // Video formats
        videoExts := map[string]bool{
                ".mp4": true, ".mkv": true, ".avi": true, ".mov": true, ".wmv": true,
                ".flv": true, ".webm": true, ".m4v": true, ".3gp": true, ".ts": true,
                ".m2ts": true, ".vob": true, ".ogv": true,
        }

        // Game formats
        gameExts := map[string]bool{
                ".exe": true, ".msi": true, ".deb": true, ".rpm": true, ".dmg": true,
                ".app": true, ".apk": true, ".ipa": true,
        }

        // Document formats
        docExts := map[string]bool{
                ".pdf": true, ".doc": true, ".docx": true, ".txt": true, ".rtf": true,
                ".odt": true, ".pages": true,
        }

        // Ebook formats
        ebookExts := map[string]bool{
                ".epub": true, ".mobi": true, ".azw": true, ".azw3": true, ".fb2": true,
                ".lit": true, ".pdb": true,
        }

        if musicExts[ext] </span><span class="cov0" title="0">{
                return MediaTypeMusic
        }</span> else<span class="cov0" title="0"> if videoExts[ext] </span><span class="cov0" title="0">{
                return MediaTypeVideo
        }</span> else<span class="cov0" title="0"> if gameExts[ext] </span><span class="cov0" title="0">{
                return MediaTypeGame
        }</span> else<span class="cov0" title="0"> if docExts[ext] </span><span class="cov0" title="0">{
                return MediaTypeDocument
        }</span> else<span class="cov0" title="0"> if ebookExts[ext] </span><span class="cov0" title="0">{
                return MediaTypeEbook
        }</span>

        <span class="cov0" title="0">return MediaTypeSoftware</span> // Default fallback
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/internal/models"
        "go.uber.org/zap"
)

type MediaRecognitionService struct {
        db                    *sql.DB
        logger                *zap.Logger
        cacheService          *CacheService
        translationService    *TranslationService
        movieAPIBaseURL       string
        musicAPIBaseURL       string
        bookAPIBaseURL        string
        gameAPIBaseURL        string
        ocrAPIBaseURL         string
        fingerprintAPIBaseURL string
}

// Recognition request structure
type MediaRecognitionRequest struct {
        FilePath    string            `json:"file_path"`
        FileName    string            `json:"file_name"`
        FileSize    int64             `json:"file_size"`
        FileHash    string            `json:"file_hash"`
        MimeType    string            `json:"mime_type"`
        MediaType   MediaType         `json:"media_type,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        AudioSample []byte            `json:"audio_sample,omitempty"`
        VideoSample []byte            `json:"video_sample,omitempty"`
        ImageSample []byte            `json:"image_sample,omitempty"`
        TextSample  string            `json:"text_sample,omitempty"`
        UserHints   map[string]string `json:"user_hints,omitempty"`
        Languages   []string          `json:"languages,omitempty"`
}

// Recognition result structure
type MediaRecognitionResult struct {
        MediaID           string     `json:"media_id"`
        MediaType         MediaType  `json:"media_type"`
        Title             string     `json:"title"`
        OriginalTitle     string     `json:"original_title,omitempty"`
        AlternativeTitles []string   `json:"alternative_titles,omitempty"`
        Description       string     `json:"description"`
        Year              int        `json:"year,omitempty"`
        ReleaseDate       *time.Time `json:"release_date,omitempty"`
        Duration          int64      `json:"duration,omitempty"`
        Genres            []string   `json:"genres,omitempty"`
        Tags              []string   `json:"tags,omitempty"`

        // Movie/TV specific
        Director    string   `json:"director,omitempty"`
        Cast        []Person `json:"cast,omitempty"`
        IMDbID      string   `json:"imdb_id,omitempty"`
        TMDbID      string   `json:"tmdb_id,omitempty"`
        TVDBId      string   `json:"tvdb_id,omitempty"`
        Season      int      `json:"season,omitempty"`
        Episode     int      `json:"episode,omitempty"`
        SeriesTitle string   `json:"series_title,omitempty"`
        Rating      float64  `json:"rating,omitempty"`

        // Music specific
        Artist        string `json:"artist,omitempty"`
        AlbumArtist   string `json:"album_artist,omitempty"`
        Album         string `json:"album,omitempty"`
        TrackNumber   int    `json:"track_number,omitempty"`
        DiscNumber    int    `json:"disc_number,omitempty"`
        MusicBrainzID string `json:"musicbrainz_id,omitempty"`
        SpotifyID     string `json:"spotify_id,omitempty"`
        LastFMID      string `json:"lastfm_id,omitempty"`
        BPM           int    `json:"bpm,omitempty"`
        Key           string `json:"key,omitempty"`

        // Book/Publication specific
        Author    string   `json:"author,omitempty"`
        Authors   []Person `json:"authors,omitempty"`
        Publisher string   `json:"publisher,omitempty"`
        ISBN      string   `json:"isbn,omitempty"`
        ISBN10    string   `json:"isbn10,omitempty"`
        ISBN13    string   `json:"isbn13,omitempty"`
        ISSN      string   `json:"issn,omitempty"`
        DOI       string   `json:"doi,omitempty"`
        Language  string   `json:"language,omitempty"`
        PageCount int      `json:"page_count,omitempty"`
        WordCount int      `json:"word_count,omitempty"`
        Edition   string   `json:"edition,omitempty"`
        Series    string   `json:"series,omitempty"`
        Volume    int      `json:"volume,omitempty"`
        Issue     int      `json:"issue,omitempty"`

        // Game/Software specific
        Developer          string            `json:"developer,omitempty"`
        Publisher_Game     string            `json:"publisher_game,omitempty"`
        Platform           string            `json:"platform,omitempty"`
        Platforms          []string          `json:"platforms,omitempty"`
        Version            string            `json:"version,omitempty"`
        BuildNumber        string            `json:"build_number,omitempty"`
        License            string            `json:"license,omitempty"`
        SystemRequirements map[string]string `json:"system_requirements,omitempty"`
        IGDBId             string            `json:"igdb_id,omitempty"`
        SteamID            string            `json:"steam_id,omitempty"`

        // Cover art and media
        CoverArt    []models.CoverArtResult `json:"cover_art,omitempty"`
        Screenshots []string                `json:"screenshots,omitempty"`
        Trailer     string                  `json:"trailer,omitempty"`
        PreviewURL  string                  `json:"preview_url,omitempty"`

        // Recognition metadata
        Confidence        float64           `json:"confidence"`
        RecognitionMethod string            `json:"recognition_method"`
        APIProvider       string            `json:"api_provider"`
        RecognizedAt      time.Time         `json:"recognized_at"`
        ProcessingTime    int64             `json:"processing_time_ms"`
        Fingerprints      map[string]string `json:"fingerprints,omitempty"`

        // Additional metadata
        ExternalIDs  map[string]string      `json:"external_ids,omitempty"`
        Translations map[string]Translation `json:"translations,omitempty"`
        RelatedMedia []string               `json:"related_media,omitempty"`
        Duplicates   []DuplicateMatch       `json:"duplicates,omitempty"`
}

type Person struct {
        Name        string            `json:"name"`
        Role        string            `json:"role,omitempty"`
        Character   string            `json:"character,omitempty"`
        Biography   string            `json:"biography,omitempty"`
        BirthDate   *time.Time        `json:"birth_date,omitempty"`
        PhotoURL    string            `json:"photo_url,omitempty"`
        ExternalIDs map[string]string `json:"external_ids,omitempty"`
}

type Translation struct {
        Language    string   `json:"language"`
        Title       string   `json:"title"`
        Description string   `json:"description"`
        Genres      []string `json:"genres,omitempty"`
}

type DuplicateMatch struct {
        MediaID    string  `json:"media_id"`
        FilePath   string  `json:"file_path"`
        Similarity float64 `json:"similarity"`
        MatchType  string  `json:"match_type"`
}

// Recognition providers interface
type RecognitionProvider interface {
        RecognizeMedia(ctx context.Context, req *MediaRecognitionRequest) (*MediaRecognitionResult, error)
        GetProviderName() string
        SupportsMediaType(mediaType MediaType) bool
        GetConfidenceThreshold() float64
}

// Audio fingerprinting structure
type AudioFingerprint struct {
        Algorithm  string               `json:"algorithm"`
        Hash       string               `json:"hash"`
        Duration   float64              `json:"duration"`
        SampleRate int                  `json:"sample_rate"`
        Channels   int                  `json:"channels"`
        Features   map[string]float64   `json:"features"`
        Segments   []FingerprintSegment `json:"segments"`
}

type FingerprintSegment struct {
        StartTime float64            `json:"start_time"`
        EndTime   float64            `json:"end_time"`
        Hash      string             `json:"hash"`
        Features  map[string]float64 `json:"features"`
}

// OCR result structure for text recognition
type OCRResult struct {
        Text       string            `json:"text"`
        Confidence float64           `json:"confidence"`
        Language   string            `json:"language"`
        Blocks     []TextBlock       `json:"blocks"`
        Layout     LayoutInfo        `json:"layout"`
        Metadata   map[string]string `json:"metadata"`
}

type TextBlock struct {
        Text        string    `json:"text"`
        Confidence  float64   `json:"confidence"`
        BoundingBox Rectangle `json:"bounding_box"`
        WordCount   int       `json:"word_count"`
        FontInfo    FontInfo  `json:"font_info"`
}

type Rectangle struct {
        X      int `json:"x"`
        Y      int `json:"y"`
        Width  int `json:"width"`
        Height int `json:"height"`
}

type FontInfo struct {
        Family string  `json:"family"`
        Size   float64 `json:"size"`
        Bold   bool    `json:"bold"`
        Italic bool    `json:"italic"`
        Color  string  `json:"color"`
}

type LayoutInfo struct {
        PageCount   int           `json:"page_count"`
        Orientation string        `json:"orientation"`
        TextColumns int           `json:"text_columns"`
        Images      []ImageRegion `json:"images"`
        Tables      []TableRegion `json:"tables"`
}

type ImageRegion struct {
        BoundingBox Rectangle `json:"bounding_box"`
        Caption     string    `json:"caption"`
        Type        string    `json:"type"`
}

type TableRegion struct {
        BoundingBox Rectangle `json:"bounding_box"`
        Rows        int       `json:"rows"`
        Columns     int       `json:"columns"`
        Headers     []string  `json:"headers"`
}

func NewMediaRecognitionService(
        db *sql.DB,
        logger *zap.Logger,
        cacheService *CacheService,
        translationService *TranslationService,
        movieAPIBaseURL string,
        musicAPIBaseURL string,
        bookAPIBaseURL string,
        gameAPIBaseURL string,
        ocrAPIBaseURL string,
        fingerprintAPIBaseURL string,
) *MediaRecognitionService <span class="cov0" title="0">{
        return &amp;MediaRecognitionService{
                db:                    db,
                logger:                logger,
                cacheService:          cacheService,
                translationService:    translationService,
                movieAPIBaseURL:       movieAPIBaseURL,
                musicAPIBaseURL:       musicAPIBaseURL,
                bookAPIBaseURL:        bookAPIBaseURL,
                gameAPIBaseURL:        gameAPIBaseURL,
                ocrAPIBaseURL:         ocrAPIBaseURL,
                fingerprintAPIBaseURL: fingerprintAPIBaseURL,
        }
}</span>

// Main recognition method that orchestrates all providers
func (s *MediaRecognitionService) RecognizeMedia(ctx context.Context, req *MediaRecognitionRequest) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        startTime := time.Now()
        s.logger.Info("Starting media recognition",
                zap.String("file_path", req.FilePath),
                zap.String("mime_type", req.MimeType),
                zap.String("media_type", string(req.MediaType)))

        // Check cache first
        cacheKey := fmt.Sprintf("media_recognition:%s", req.FileHash)
        var result MediaRecognitionResult
        if found, err := s.cacheService.Get(ctx, cacheKey, &amp;result); err == nil &amp;&amp; found </span><span class="cov0" title="0">{
                s.logger.Debug("Found cached recognition result", zap.String("media_id", result.MediaID))
                return &amp;result, nil
        }</span>

        // Determine media type if not provided
        <span class="cov0" title="0">if req.MediaType == "" </span><span class="cov0" title="0">{
                detectedType, confidence := s.detectMediaType(req)
                req.MediaType = detectedType
                s.logger.Debug("Detected media type",
                        zap.String("type", string(detectedType)),
                        zap.Float64("confidence", confidence))
        }</span>

        // Get appropriate recognition providers
        <span class="cov0" title="0">providers := s.getProvidersForMediaType(req.MediaType)
        if len(providers) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no recognition providers available for media type: %s", req.MediaType)
        }</span>

        // Try recognition with multiple providers
        <span class="cov0" title="0">var bestResult *MediaRecognitionResult
        var bestConfidence float64

        for _, provider := range providers </span><span class="cov0" title="0">{
                result, err := provider.RecognizeMedia(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Recognition provider failed",
                                zap.String("provider", provider.GetProviderName()),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if result.Confidence &gt; bestConfidence &amp;&amp; result.Confidence &gt;= provider.GetConfidenceThreshold() </span><span class="cov0" title="0">{
                        bestResult = result
                        bestConfidence = result.Confidence
                }</span>
        }

        <span class="cov0" title="0">if bestResult == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no recognition provider returned confident results")
        }</span>

        // Enhance with additional metadata
        <span class="cov0" title="0">s.enhanceRecognitionResult(ctx, bestResult, req)

        // Check for duplicates
        duplicates, err := s.findDuplicates(ctx, bestResult)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to find duplicates", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                bestResult.Duplicates = duplicates
        }</span>

        // Translate metadata if requested
        <span class="cov0" title="0">if len(req.Languages) &gt; 0 </span><span class="cov0" title="0">{
                translations, err := s.translateMetadata(ctx, bestResult, req.Languages)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to translate metadata", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        bestResult.Translations = translations
                }</span>
        }

        // Set processing metadata
        <span class="cov0" title="0">bestResult.RecognizedAt = time.Now()
        bestResult.ProcessingTime = time.Since(startTime).Milliseconds()

        // Cache the result
        resultJSON, _ := json.Marshal(bestResult)
        s.cacheService.Set(ctx, cacheKey, string(resultJSON), 24*time.Hour)

        // Store in database
        if err := s.storeRecognitionResult(ctx, bestResult, req); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to store recognition result", zap.Error(err))
        }</span>

        <span class="cov0" title="0">s.logger.Info("Media recognition completed",
                zap.String("media_id", bestResult.MediaID),
                zap.String("title", bestResult.Title),
                zap.Float64("confidence", bestResult.Confidence),
                zap.Int64("processing_time_ms", bestResult.ProcessingTime))

        return bestResult, nil</span>
}

// Detect media type from file characteristics
func (s *MediaRecognitionService) detectMediaType(req *MediaRecognitionRequest) (MediaType, float64) <span class="cov0" title="0">{
        // Video file detection
        videoMimes := []string{"video/mp4", "video/avi", "video/mkv", "video/mov", "video/wmv", "video/flv", "video/webm"}
        for _, mime := range videoMimes </span><span class="cov0" title="0">{
                if req.MimeType == mime </span><span class="cov0" title="0">{
                        // Further distinguish between movie types
                        if s.looksLikeTVEpisode(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeTVEpisode, 0.9
                        }</span>
                        <span class="cov0" title="0">if s.looksLikeConcert(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeConcert, 0.8
                        }</span>
                        <span class="cov0" title="0">if s.looksLikeDocumentary(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeDocumentary, 0.8
                        }</span>
                        <span class="cov0" title="0">if s.looksLikeCourse(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeCourse, 0.8
                        }</span>
                        <span class="cov0" title="0">return MediaTypeMovie, 0.7</span>
                }
        }

        // Audio file detection
        <span class="cov0" title="0">audioMimes := []string{"audio/mp3", "audio/wav", "audio/flac", "audio/ogg", "audio/aac", "audio/m4a"}
        for _, mime := range audioMimes </span><span class="cov0" title="0">{
                if req.MimeType == mime </span><span class="cov0" title="0">{
                        if s.looksLikeAudiobook(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeAudiobook, 0.9
                        }</span>
                        <span class="cov0" title="0">if s.looksLikePodcast(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypePodcast, 0.8
                        }</span>
                        <span class="cov0" title="0">return MediaTypeMusic, 0.8</span>
                }
        }

        // Text/Document file detection
        <span class="cov0" title="0">textMimes := []string{"application/pdf", "text/plain", "application/epub+zip", "application/x-mobipocket-ebook"}
        for _, mime := range textMimes </span><span class="cov0" title="0">{
                if req.MimeType == mime </span><span class="cov0" title="0">{
                        if s.looksLikeComicBook(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeComicBook, 0.9
                        }</span>
                        <span class="cov0" title="0">if s.looksLikeMagazine(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeMagazine, 0.8
                        }</span>
                        <span class="cov0" title="0">if s.looksLikeManual(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeManual, 0.8
                        }</span>
                        <span class="cov0" title="0">return MediaTypeBook, 0.7</span>
                }
        }

        // Executable/Software detection
        <span class="cov0" title="0">execMimes := []string{"application/x-executable", "application/x-msdos-program", "application/x-msdownload"}
        for _, mime := range execMimes </span><span class="cov0" title="0">{
                if req.MimeType == mime </span><span class="cov0" title="0">{
                        if s.looksLikeGame(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeGame, 0.8
                        }</span>
                        <span class="cov0" title="0">return MediaTypeSoftware, 0.7</span>
                }
        }

        // Default fallback based on file extension
        <span class="cov0" title="0">return s.detectFromFileName(req.FileName), 0.5</span>
}

// Helper methods for media type detection
func (s *MediaRecognitionService) looksLikeTVEpisode(fileName string) bool <span class="cov0" title="0">{
        // Pattern matching for TV episodes (S01E01, 1x01, etc.)
        // Implementation would use regex patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeConcert(fileName string) bool <span class="cov0" title="0">{
        // Look for concert-related keywords
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeDocumentary(fileName string) bool <span class="cov0" title="0">{
        // Look for documentary keywords
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeCourse(fileName string) bool <span class="cov0" title="0">{
        // Look for course/training keywords
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeAudiobook(fileName string) bool <span class="cov0" title="0">{
        // Look for audiobook patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikePodcast(fileName string) bool <span class="cov0" title="0">{
        // Look for podcast patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeComicBook(fileName string) bool <span class="cov0" title="0">{
        // Look for comic book patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeMagazine(fileName string) bool <span class="cov0" title="0">{
        // Look for magazine patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeManual(fileName string) bool <span class="cov0" title="0">{
        // Look for manual/documentation patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeGame(fileName string) bool <span class="cov0" title="0">{
        // Look for game-related patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) detectFromFileName(fileName string) MediaType <span class="cov0" title="0">{
        // Fallback detection based on file extension
        return MediaTypeMovie // Placeholder
}</span>

// Get recognition providers for specific media type
func (s *MediaRecognitionService) getProvidersForMediaType(mediaType MediaType) []RecognitionProvider <span class="cov0" title="0">{
        var providers []RecognitionProvider

        switch mediaType </span>{
        case MediaTypeMovie, MediaTypeTVSeries, MediaTypeTVEpisode, MediaTypeConcert, MediaTypeDocumentary:<span class="cov0" title="0">
                providers = append(providers, s.getMovieProviders()...)</span>
        case MediaTypeMusic, MediaTypeAlbum, MediaTypeAudiobook, MediaTypePodcast:<span class="cov0" title="0">
                providers = append(providers, s.getMusicProviders()...)</span>
        case MediaTypeBook, MediaTypeComicBook, MediaTypeMagazine, MediaTypeEbook:<span class="cov0" title="0">
                providers = append(providers, s.getBookProviders()...)</span>
        case MediaTypeGame, MediaTypeSoftware:<span class="cov0" title="0">
                providers = append(providers, s.getGameProviders()...)</span>
        }

        <span class="cov0" title="0">return providers</span>
}

// Provider getter methods (to be implemented)
func (s *MediaRecognitionService) getMovieProviders() []RecognitionProvider <span class="cov0" title="0">{
        return []RecognitionProvider{} // Placeholder
}</span>

func (s *MediaRecognitionService) getMusicProviders() []RecognitionProvider <span class="cov0" title="0">{
        return []RecognitionProvider{} // Placeholder
}</span>

func (s *MediaRecognitionService) getBookProviders() []RecognitionProvider <span class="cov0" title="0">{
        return []RecognitionProvider{} // Placeholder
}</span>

func (s *MediaRecognitionService) getGameProviders() []RecognitionProvider <span class="cov0" title="0">{
        return []RecognitionProvider{} // Placeholder
}</span>

// Enhance recognition result with additional metadata
func (s *MediaRecognitionService) enhanceRecognitionResult(ctx context.Context, result *MediaRecognitionResult, req *MediaRecognitionRequest) <span class="cov0" title="0">{
        // Get additional cover art
        if coverArt, err := s.getAdditionalCoverArt(ctx, result); err == nil </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, coverArt...)
        }</span>

        // Get additional metadata from alternative sources
        <span class="cov0" title="0">if metadata, err := s.getEnhancedMetadata(ctx, result); err == nil </span><span class="cov0" title="0">{
                // Merge additional metadata
                if result.ExternalIDs == nil </span><span class="cov0" title="0">{
                        result.ExternalIDs = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for key, value := range metadata </span><span class="cov0" title="0">{
                        result.ExternalIDs[key] = value
                }</span>
        }
}

// Find duplicate content
func (s *MediaRecognitionService) findDuplicates(ctx context.Context, result *MediaRecognitionResult) ([]DuplicateMatch, error) <span class="cov0" title="0">{
        var duplicates []DuplicateMatch

        // Query database for potential duplicates based on:
        // 1. Exact title match
        // 2. External IDs (IMDb, ISBN, etc.)
        // 3. Fingerprint similarity
        // 4. File hash similarity

        query := `
                SELECT media_id, file_path, title, external_ids, fingerprints
                FROM media_recognition_results
                WHERE (title = ? OR ? IN (SELECT value FROM json_each(external_ids)))
                AND media_id != ?
        `

        rows, err := s.db.QueryContext(ctx, query, result.Title, result.IMDbID, result.MediaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var mediaID, filePath, title, externalIDsJSON, fingerprintsJSON string
                if err := rows.Scan(&amp;mediaID, &amp;filePath, &amp;title, &amp;externalIDsJSON, &amp;fingerprintsJSON); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">similarity := s.calculateSimilarity(result, title, externalIDsJSON, fingerprintsJSON)
                if similarity &gt; 0.8 </span><span class="cov0" title="0">{ // High similarity threshold
                        duplicates = append(duplicates, DuplicateMatch{
                                MediaID:    mediaID,
                                FilePath:   filePath,
                                Similarity: similarity,
                                MatchType:  s.determineMatchType(similarity),
                        })
                }</span>
        }

        <span class="cov0" title="0">return duplicates, nil</span>
}

// Calculate similarity between media items
func (s *MediaRecognitionService) calculateSimilarity(result *MediaRecognitionResult, title, externalIDsJSON, fingerprintsJSON string) float64 <span class="cov0" title="0">{
        // Implement similarity calculation logic
        // Consider title similarity, external ID matches, fingerprint similarity
        return 0.0 // Placeholder
}</span>

// Determine match type based on similarity score
func (s *MediaRecognitionService) determineMatchType(similarity float64) string <span class="cov0" title="0">{
        if similarity &gt;= 0.95 </span><span class="cov0" title="0">{
                return "exact"
        }</span> else<span class="cov0" title="0"> if similarity &gt;= 0.85 </span><span class="cov0" title="0">{
                return "high"
        }</span> else<span class="cov0" title="0"> if similarity &gt;= 0.8 </span><span class="cov0" title="0">{
                return "medium"
        }</span>
        <span class="cov0" title="0">return "low"</span>
}

// Translate metadata to multiple languages
func (s *MediaRecognitionService) translateMetadata(ctx context.Context, result *MediaRecognitionResult, languages []string) (map[string]Translation, error) <span class="cov0" title="0">{
        translations := make(map[string]Translation)

        for _, lang := range languages </span><span class="cov0" title="0">{
                if lang == result.Language </span><span class="cov0" title="0">{
                        continue</span> // Skip if same as source language
                }

                <span class="cov0" title="0">translation := Translation{Language: lang}

                // Translate title
                if translatedTitle, err := s.translationService.TranslateText(ctx, TranslationRequest{
                        Text:           result.Title,
                        SourceLanguage: result.Language,
                        TargetLanguage: lang,
                }); err == nil </span><span class="cov0" title="0">{
                        translation.Title = translatedTitle.TranslatedText
                }</span>

                // Translate description
                <span class="cov0" title="0">if result.Description != "" </span><span class="cov0" title="0">{
                        if translatedDesc, err := s.translationService.TranslateText(ctx, TranslationRequest{
                                Text:           result.Description,
                                SourceLanguage: result.Language,
                                TargetLanguage: lang,
                        }); err == nil </span><span class="cov0" title="0">{
                                translation.Description = translatedDesc.TranslatedText
                        }</span>
                }

                // Translate genres
                <span class="cov0" title="0">if len(result.Genres) &gt; 0 </span><span class="cov0" title="0">{
                        var translatedGenres []string
                        for _, genre := range result.Genres </span><span class="cov0" title="0">{
                                if translatedGenre, err := s.translationService.TranslateText(ctx, TranslationRequest{
                                        Text:           genre,
                                        SourceLanguage: result.Language,
                                        TargetLanguage: lang,
                                }); err == nil </span><span class="cov0" title="0">{
                                        translatedGenres = append(translatedGenres, translatedGenre.TranslatedText)
                                }</span>
                        }
                        <span class="cov0" title="0">translation.Genres = translatedGenres</span>
                }

                <span class="cov0" title="0">translations[lang] = translation</span>
        }

        <span class="cov0" title="0">return translations, nil</span>
}

// Store recognition result in database
func (s *MediaRecognitionService) storeRecognitionResult(ctx context.Context, result *MediaRecognitionResult, req *MediaRecognitionRequest) error <span class="cov0" title="0">{
        resultJSON, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fingerprintsJSON, _ := json.Marshal(result.Fingerprints)
        externalIDsJSON, _ := json.Marshal(result.ExternalIDs)

        query := `
                INSERT OR REPLACE INTO media_recognition_results (
                        media_id, file_path, file_hash, media_type, title, original_title,
                        description, year, release_date, duration, genres, tags,
                        recognition_data, fingerprints, external_ids, confidence,
                        recognition_method, api_provider, recognized_at, processing_time_ms
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        genresJSON, _ := json.Marshal(result.Genres)
        tagsJSON, _ := json.Marshal(result.Tags)

        _, err = s.db.ExecContext(ctx, query,
                result.MediaID, req.FilePath, req.FileHash, string(result.MediaType),
                result.Title, result.OriginalTitle, result.Description, result.Year,
                result.ReleaseDate, result.Duration, string(genresJSON), string(tagsJSON),
                string(resultJSON), string(fingerprintsJSON), string(externalIDsJSON),
                result.Confidence, result.RecognitionMethod, result.APIProvider,
                result.RecognizedAt, result.ProcessingTime,
        )

        return err</span>
}

// Additional helper methods for enhancement
func (s *MediaRecognitionService) getAdditionalCoverArt(ctx context.Context, result *MediaRecognitionResult) ([]models.CoverArtResult, error) <span class="cov0" title="0">{
        // Implement additional cover art retrieval
        return []models.CoverArtResult{}, nil
}</span>

func (s *MediaRecognitionService) getEnhancedMetadata(ctx context.Context, result *MediaRecognitionResult) (map[string]string, error) <span class="cov0" title="0">{
        // Implement enhanced metadata retrieval
        return make(map[string]string), nil
}</span>

// Batch recognition for multiple files
func (s *MediaRecognitionService) RecognizeMediaBatch(ctx context.Context, requests []*MediaRecognitionRequest) ([]*MediaRecognitionResult, error) <span class="cov0" title="0">{
        results := make([]*MediaRecognitionResult, len(requests))

        for i, req := range requests </span><span class="cov0" title="0">{
                result, err := s.RecognizeMedia(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to recognize media in batch",
                                zap.String("file_path", req.FilePath),
                                zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">results[i] = result</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// Get recognition statistics
func (s *MediaRecognitionService) GetRecognitionStats(ctx context.Context) (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Count by media type
        query := `
                SELECT media_type, COUNT(*) as count, AVG(confidence) as avg_confidence
                FROM media_recognition_results
                GROUP BY media_type
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        typeStats := make(map[string]map[string]interface{})
        for rows.Next() </span><span class="cov0" title="0">{
                var mediaType string
                var count int
                var avgConfidence float64
                if err := rows.Scan(&amp;mediaType, &amp;count, &amp;avgConfidence); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">typeStats[mediaType] = map[string]interface{}{
                        "count":          count,
                        "avg_confidence": avgConfidence,
                }</span>
        }

        <span class="cov0" title="0">stats["by_type"] = typeStats

        // Overall statistics
        totalQuery := `SELECT COUNT(*) FROM media_recognition_results`
        var totalCount int
        s.db.QueryRowContext(ctx, totalQuery).Scan(&amp;totalCount)
        stats["total_recognized"] = totalCount

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "regexp"
        "strconv"
        "strings"
        "time"

        "catalogizer/internal/models"
        "go.uber.org/zap"
)

// Movie/TV recognition provider using free APIs
type MovieRecognitionProvider struct {
        logger      *zap.Logger
        httpClient  *http.Client
        baseURLs    map[string]string
        apiKeys     map[string]string
        rateLimiter map[string]*time.Ticker
}

// External API response structures
type TMDbSearchResponse struct {
        Page         int          `json:"page"`
        Results      []TMDbResult `json:"results"`
        TotalPages   int          `json:"total_pages"`
        TotalResults int          `json:"total_results"`
}

type TMDbResult struct {
        ID               int      `json:"id"`
        Title            string   `json:"title,omitempty"`
        Name             string   `json:"name,omitempty"`
        OriginalTitle    string   `json:"original_title,omitempty"`
        OriginalName     string   `json:"original_name,omitempty"`
        Overview         string   `json:"overview"`
        ReleaseDate      string   `json:"release_date,omitempty"`
        FirstAirDate     string   `json:"first_air_date,omitempty"`
        GenreIDs         []int    `json:"genre_ids"`
        VoteAverage      float64  `json:"vote_average"`
        VoteCount        int      `json:"vote_count"`
        PosterPath       string   `json:"poster_path,omitempty"`
        BackdropPath     string   `json:"backdrop_path,omitempty"`
        Popularity       float64  `json:"popularity"`
        Adult            bool     `json:"adult"`
        Video            bool     `json:"video,omitempty"`
        MediaType        string   `json:"media_type,omitempty"`
        OriginCountry    []string `json:"origin_country,omitempty"`
        OriginalLanguage string   `json:"original_language"`
}

type TMDbMovieDetails struct {
        ID                  int                     `json:"id"`
        Title               string                  `json:"title"`
        OriginalTitle       string                  `json:"original_title"`
        Overview            string                  `json:"overview"`
        ReleaseDate         string                  `json:"release_date"`
        Runtime             int                     `json:"runtime"`
        Genres              []TMDbGenre             `json:"genres"`
        ProductionCompanies []TMDbProductionCompany `json:"production_companies"`
        ProductionCountries []TMDbCountry           `json:"production_countries"`
        SpokenLanguages     []TMDbLanguage          `json:"spoken_languages"`
        VoteAverage         float64                 `json:"vote_average"`
        VoteCount           int                     `json:"vote_count"`
        Popularity          float64                 `json:"popularity"`
        PosterPath          string                  `json:"poster_path"`
        BackdropPath        string                  `json:"backdrop_path"`
        Adult               bool                    `json:"adult"`
        Homepage            string                  `json:"homepage"`
        IMDbID              string                  `json:"imdb_id"`
        Budget              int64                   `json:"budget"`
        Revenue             int64                   `json:"revenue"`
        Status              string                  `json:"status"`
        Tagline             string                  `json:"tagline"`
}

type TMDbTVDetails struct {
        ID                  int                     `json:"id"`
        Name                string                  `json:"name"`
        OriginalName        string                  `json:"original_name"`
        Overview            string                  `json:"overview"`
        FirstAirDate        string                  `json:"first_air_date"`
        LastAirDate         string                  `json:"last_air_date"`
        Genres              []TMDbGenre             `json:"genres"`
        CreatedBy           []TMDbCreator           `json:"created_by"`
        Networks            []TMDbNetwork           `json:"networks"`
        ProductionCompanies []TMDbProductionCompany `json:"production_companies"`
        ProductionCountries []TMDbCountry           `json:"production_countries"`
        SpokenLanguages     []TMDbLanguage          `json:"spoken_languages"`
        VoteAverage         float64                 `json:"vote_average"`
        VoteCount           int                     `json:"vote_count"`
        Popularity          float64                 `json:"popularity"`
        PosterPath          string                  `json:"poster_path"`
        BackdropPath        string                  `json:"backdrop_path"`
        Homepage            string                  `json:"homepage"`
        InProduction        bool                    `json:"in_production"`
        NumberOfEpisodes    int                     `json:"number_of_episodes"`
        NumberOfSeasons     int                     `json:"number_of_seasons"`
        Status              string                  `json:"status"`
        Type                string                  `json:"type"`
        Tagline             string                  `json:"tagline"`
        ExternalIDs         TMDbExternalIDs         `json:"external_ids,omitempty"`
}

type TMDbGenre struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
}

type TMDbProductionCompany struct {
        ID            int    `json:"id"`
        Name          string `json:"name"`
        LogoPath      string `json:"logo_path"`
        OriginCountry string `json:"origin_country"`
}

type TMDbCountry struct {
        ISO31661 string `json:"iso_3166_1"`
        Name     string `json:"name"`
}

type TMDbLanguage struct {
        ISO6391     string `json:"iso_639_1"`
        EnglishName string `json:"english_name"`
        Name        string `json:"name"`
}

type TMDbCreator struct {
        ID          int    `json:"id"`
        Name        string `json:"name"`
        Gender      int    `json:"gender"`
        ProfilePath string `json:"profile_path"`
}

type TMDbNetwork struct {
        ID            int    `json:"id"`
        Name          string `json:"name"`
        LogoPath      string `json:"logo_path"`
        OriginCountry string `json:"origin_country"`
}

type TMDbExternalIDs struct {
        IMDbID      string `json:"imdb_id"`
        TVDBID      int    `json:"tvdb_id"`
        FacebookID  string `json:"facebook_id"`
        InstagramID string `json:"instagram_id"`
        TwitterID   string `json:"twitter_id"`
}

type TMDbCredits struct {
        ID   int              `json:"id"`
        Cast []TMDbCastMember `json:"cast"`
        Crew []TMDbCrewMember `json:"crew"`
}

type TMDbCastMember struct {
        ID          int     `json:"id"`
        Name        string  `json:"name"`
        Character   string  `json:"character"`
        Order       int     `json:"order"`
        Gender      int     `json:"gender"`
        ProfilePath string  `json:"profile_path"`
        CastID      int     `json:"cast_id"`
        CreditID    string  `json:"credit_id"`
        Popularity  float64 `json:"popularity"`
}

type TMDbCrewMember struct {
        ID          int     `json:"id"`
        Name        string  `json:"name"`
        Job         string  `json:"job"`
        Department  string  `json:"department"`
        Gender      int     `json:"gender"`
        ProfilePath string  `json:"profile_path"`
        CreditID    string  `json:"credit_id"`
        Popularity  float64 `json:"popularity"`
}

// OMDb API structures (fallback)
type OMDbResponse struct {
        Title      string       `json:"Title"`
        Year       string       `json:"Year"`
        Rated      string       `json:"Rated"`
        Released   string       `json:"Released"`
        Runtime    string       `json:"Runtime"`
        Genre      string       `json:"Genre"`
        Director   string       `json:"Director"`
        Writer     string       `json:"Writer"`
        Actors     string       `json:"Actors"`
        Plot       string       `json:"Plot"`
        Language   string       `json:"Language"`
        Country    string       `json:"Country"`
        Awards     string       `json:"Awards"`
        Poster     string       `json:"Poster"`
        Ratings    []OMDbRating `json:"Ratings"`
        Metascore  string       `json:"Metascore"`
        IMDbRating string       `json:"imdbRating"`
        IMDbVotes  string       `json:"imdbVotes"`
        IMDbID     string       `json:"imdbID"`
        Type       string       `json:"Type"`
        DVD        string       `json:"DVD,omitempty"`
        BoxOffice  string       `json:"BoxOffice,omitempty"`
        Production string       `json:"Production,omitempty"`
        Website    string       `json:"Website,omitempty"`
        Response   string       `json:"Response"`
        Error      string       `json:"Error,omitempty"`
}

type OMDbRating struct {
        Source string `json:"Source"`
        Value  string `json:"Value"`
}

func NewMovieRecognitionProvider(logger *zap.Logger) *MovieRecognitionProvider <span class="cov0" title="0">{
        return &amp;MovieRecognitionProvider{
                logger:     logger,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                baseURLs: map[string]string{
                        "tmdb": "https://api.themoviedb.org/3",
                        "omdb": "http://www.omdbapi.com",
                        "tvdb": "https://api4.thetvdb.com/v4",
                        "imdb": "https://imdb-api.com",
                },
                apiKeys: map[string]string{
                        "tmdb": "free_api_key", // Using free tier
                        "omdb": "free_api_key", // Using free tier
                },
                rateLimiter: make(map[string]*time.Ticker),
        }
}</span>

func (p *MovieRecognitionProvider) RecognizeMedia(ctx context.Context, req *MediaRecognitionRequest) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        p.logger.Info("Starting movie/TV recognition",
                zap.String("file_path", req.FilePath),
                zap.String("media_type", string(req.MediaType)))

        // Extract title from filename
        title := p.extractTitleFromFilename(req.FileName)
        year := p.extractYearFromFilename(req.FileName)

        // Extract season/episode info for TV shows
        season, episode := p.extractSeasonEpisode(req.FileName)

        p.logger.Debug("Extracted metadata from filename",
                zap.String("title", title),
                zap.Int("year", year),
                zap.Int("season", season),
                zap.Int("episode", episode))

        // Try TMDb first (best free API)
        if result, err := p.searchTMDb(ctx, title, year, req.MediaType, season, episode); err == nil </span><span class="cov0" title="0">{
                p.logger.Info("Successfully recognized via TMDb",
                        zap.String("title", result.Title),
                        zap.Float64("confidence", result.Confidence))
                return result, nil
        }</span>

        // Fallback to OMDb
        <span class="cov0" title="0">if result, err := p.searchOMDb(ctx, title, year, req.MediaType); err == nil </span><span class="cov0" title="0">{
                p.logger.Info("Successfully recognized via OMDb",
                        zap.String("title", result.Title),
                        zap.Float64("confidence", result.Confidence))
                return result, nil
        }</span>

        // Fallback to basic pattern matching
        <span class="cov0" title="0">return p.basicRecognition(req, title, year, season, episode), nil</span>
}

func (p *MovieRecognitionProvider) searchTMDb(ctx context.Context, title string, year int, mediaType MediaType, season, episode int) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Search for the media
        searchURL := fmt.Sprintf("%s/search/multi", p.baseURLs["tmdb"])
        params := url.Values{}
        params.Set("api_key", p.apiKeys["tmdb"])
        params.Set("query", title)
        if year &gt; 0 </span><span class="cov0" title="0">{
                params.Set("year", strconv.Itoa(year))
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", searchURL, params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResp TMDbSearchResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResp.Results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no results found in TMDb")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := searchResp.Results[0]

        // Get detailed information
        if bestMatch.MediaType == "movie" || (bestMatch.Title != "" &amp;&amp; bestMatch.MediaType == "") </span><span class="cov0" title="0">{
                return p.getTMDbMovieDetails(ctx, bestMatch.ID)
        }</span> else<span class="cov0" title="0"> if bestMatch.MediaType == "tv" || bestMatch.Name != "" </span><span class="cov0" title="0">{
                return p.getTMDbTVDetails(ctx, bestMatch.ID, season, episode)
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported media type from TMDb")</span>
}

func (p *MovieRecognitionProvider) getTMDbMovieDetails(ctx context.Context, movieID int) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Get movie details
        detailsURL := fmt.Sprintf("%s/movie/%d", p.baseURLs["tmdb"], movieID)
        params := url.Values{}
        params.Set("api_key", p.apiKeys["tmdb"])
        params.Set("append_to_response", "credits,external_ids,images")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", detailsURL, params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var movie TMDbMovieDetails
        if err := json.NewDecoder(resp.Body).Decode(&amp;movie); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to MediaRecognitionResult
        <span class="cov0" title="0">result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("tmdb_movie_%d", movie.ID),
                MediaType:         MediaTypeMovie,
                Title:             movie.Title,
                OriginalTitle:     movie.OriginalTitle,
                Description:       movie.Overview,
                Year:              p.parseYear(movie.ReleaseDate),
                Duration:          int64(movie.Runtime * 60), // Convert minutes to seconds
                IMDbID:            movie.IMDbID,
                TMDbID:            strconv.Itoa(movie.ID),
                Rating:            movie.VoteAverage,
                Confidence:        p.calculateConfidence(movie.Title, movie.VoteAverage, movie.VoteCount),
                RecognitionMethod: "tmdb_api",
                APIProvider:       "TMDb",
        }

        // Parse release date
        if releaseDate, err := time.Parse("2006-01-02", movie.ReleaseDate); err == nil </span><span class="cov0" title="0">{
                result.ReleaseDate = &amp;releaseDate
        }</span>

        // Extract genres
        <span class="cov0" title="0">for _, genre := range movie.Genres </span><span class="cov0" title="0">{
                result.Genres = append(result.Genres, genre.Name)
        }</span>

        // Get cover art
        <span class="cov0" title="0">if movie.PosterPath != "" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        URL:     fmt.Sprintf("https://image.tmdb.org/t/p/w500%s", movie.PosterPath),
                        Width:   500,
                        Quality: "medium",
                        Source:  "TMDb",
                })
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        URL:     fmt.Sprintf("https://image.tmdb.org/t/p/original%s", movie.PosterPath),
                        Quality: "high",
                        Source:  "TMDb",
                })
        }</span>

        <span class="cov0" title="0">if movie.BackdropPath != "" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        URL:     fmt.Sprintf("https://image.tmdb.org/t/p/w1280%s", movie.BackdropPath),
                        Width:   1280,
                        Quality: "high",
                        Source:  "TMDb",
                })
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "tmdb_id": strconv.Itoa(movie.ID),
        }
        if movie.IMDbID != "" </span><span class="cov0" title="0">{
                result.ExternalIDs["imdb_id"] = movie.IMDbID
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (p *MovieRecognitionProvider) getTMDbTVDetails(ctx context.Context, tvID, season, episode int) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Get TV series details
        detailsURL := fmt.Sprintf("%s/tv/%d", p.baseURLs["tmdb"], tvID)
        params := url.Values{}
        params.Set("api_key", p.apiKeys["tmdb"])
        params.Set("append_to_response", "credits,external_ids,images")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", detailsURL, params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var tv TMDbTVDetails
        if err := json.NewDecoder(resp.Body).Decode(&amp;tv); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine media type
        <span class="cov0" title="0">mediaType := MediaTypeTVSeries
        title := tv.Name
        if season &gt; 0 &amp;&amp; episode &gt; 0 </span><span class="cov0" title="0">{
                mediaType = MediaTypeTVEpisode
                // Try to get episode details
                if episodeDetails, err := p.getTMDbEpisodeDetails(ctx, tvID, season, episode); err == nil </span><span class="cov0" title="0">{
                        title = episodeDetails.Name
                }</span>
        }

        // Convert to MediaRecognitionResult
        <span class="cov0" title="0">result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("tmdb_tv_%d", tv.ID),
                MediaType:         mediaType,
                Title:             title,
                OriginalTitle:     tv.OriginalName,
                SeriesTitle:       tv.Name,
                Description:       tv.Overview,
                Year:              p.parseYear(tv.FirstAirDate),
                Season:            season,
                Episode:           episode,
                TMDbID:            strconv.Itoa(tv.ID),
                Rating:            tv.VoteAverage,
                Confidence:        p.calculateConfidence(tv.Name, tv.VoteAverage, tv.VoteCount),
                RecognitionMethod: "tmdb_api",
                APIProvider:       "TMDb",
        }

        // Parse first air date
        if firstAirDate, err := time.Parse("2006-01-02", tv.FirstAirDate); err == nil </span><span class="cov0" title="0">{
                result.ReleaseDate = &amp;firstAirDate
        }</span>

        // Extract genres
        <span class="cov0" title="0">for _, genre := range tv.Genres </span><span class="cov0" title="0">{
                result.Genres = append(result.Genres, genre.Name)
        }</span>

        // Get cover art
        <span class="cov0" title="0">if tv.PosterPath != "" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        URL:     fmt.Sprintf("https://image.tmdb.org/t/p/w500%s", tv.PosterPath),
                        Width:   500,
                        Quality: "medium",
                        Source:  "TMDb",
                })
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "tmdb_id": strconv.Itoa(tv.ID),
        }
        if tv.ExternalIDs.IMDbID != "" </span><span class="cov0" title="0">{
                result.ExternalIDs["imdb_id"] = tv.ExternalIDs.IMDbID
                result.IMDbID = tv.ExternalIDs.IMDbID
        }</span>
        <span class="cov0" title="0">if tv.ExternalIDs.TVDBID &gt; 0 </span><span class="cov0" title="0">{
                result.ExternalIDs["tvdb_id"] = strconv.Itoa(tv.ExternalIDs.TVDBID)
                result.TVDBId = strconv.Itoa(tv.ExternalIDs.TVDBID)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (p *MovieRecognitionProvider) getTMDbEpisodeDetails(ctx context.Context, tvID, season, episode int) (*TMDbEpisodeDetails, error) <span class="cov0" title="0">{
        detailsURL := fmt.Sprintf("%s/tv/%d/season/%d/episode/%d", p.baseURLs["tmdb"], tvID, season, episode)
        params := url.Values{}
        params.Set("api_key", p.apiKeys["tmdb"])

        resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", detailsURL, params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var episode_details TMDbEpisodeDetails
        if err := json.NewDecoder(resp.Body).Decode(&amp;episode_details); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;episode_details, nil</span>
}

type TMDbEpisodeDetails struct {
        ID            int     `json:"id"`
        Name          string  `json:"name"`
        Overview      string  `json:"overview"`
        AirDate       string  `json:"air_date"`
        EpisodeNumber int     `json:"episode_number"`
        SeasonNumber  int     `json:"season_number"`
        Runtime       int     `json:"runtime"`
        VoteAverage   float64 `json:"vote_average"`
        VoteCount     int     `json:"vote_count"`
        StillPath     string  `json:"still_path"`
}

func (p *MovieRecognitionProvider) searchOMDb(ctx context.Context, title string, year int, mediaType MediaType) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}
        params.Set("apikey", p.apiKeys["omdb"])
        params.Set("t", title)
        if year &gt; 0 </span><span class="cov0" title="0">{
                params.Set("y", strconv.Itoa(year))
        }</span>

        // Set type based on media type
        <span class="cov0" title="0">switch mediaType </span>{
        case MediaTypeMovie, MediaTypeConcert, MediaTypeDocumentary:<span class="cov0" title="0">
                params.Set("type", "movie")</span>
        case MediaTypeTVSeries, MediaTypeTVEpisode:<span class="cov0" title="0">
                params.Set("type", "series")</span>
        }

        <span class="cov0" title="0">resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", p.baseURLs["omdb"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var omdbResp OMDbResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;omdbResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if omdbResp.Response == "False" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OMDb error: %s", omdbResp.Error)
        }</span>

        // Convert OMDb response to MediaRecognitionResult
        <span class="cov0" title="0">result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("omdb_%s", omdbResp.IMDbID),
                MediaType:         p.mapOMDbType(omdbResp.Type),
                Title:             omdbResp.Title,
                Description:       omdbResp.Plot,
                Year:              p.parseYear(omdbResp.Year),
                Director:          omdbResp.Director,
                IMDbID:            omdbResp.IMDbID,
                Confidence:        p.calculateOMDbConfidence(omdbResp.IMDbRating, omdbResp.IMDbVotes),
                RecognitionMethod: "omdb_api",
                APIProvider:       "OMDb",
        }

        // Parse release date
        if releaseDate, err := time.Parse("02 Jan 2006", omdbResp.Released); err == nil </span><span class="cov0" title="0">{
                result.ReleaseDate = &amp;releaseDate
        }</span>

        // Parse genres
        <span class="cov0" title="0">if omdbResp.Genre != "" </span><span class="cov0" title="0">{
                result.Genres = strings.Split(omdbResp.Genre, ", ")
        }</span>

        // Parse runtime
        <span class="cov0" title="0">if runtime := p.parseRuntime(omdbResp.Runtime); runtime &gt; 0 </span><span class="cov0" title="0">{
                result.Duration = runtime
        }</span>

        // Parse rating
        <span class="cov0" title="0">if rating, err := strconv.ParseFloat(omdbResp.IMDbRating, 64); err == nil </span><span class="cov0" title="0">{
                result.Rating = rating
        }</span>

        // Parse cast
        <span class="cov0" title="0">if omdbResp.Actors != "" </span><span class="cov0" title="0">{
                actors := strings.Split(omdbResp.Actors, ", ")
                for _, actor := range actors </span><span class="cov0" title="0">{
                        result.Cast = append(result.Cast, Person{
                                Name: actor,
                                Role: "Actor",
                        })
                }</span>
        }

        // Add cover art
        <span class="cov0" title="0">if omdbResp.Poster != "" &amp;&amp; omdbResp.Poster != "N/A" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        URL:     omdbResp.Poster,
                        Quality: "medium",
                        Source:  "OMDb",
                })
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "imdb_id": omdbResp.IMDbID,
        }

        return result, nil</span>
}

func (p *MovieRecognitionProvider) basicRecognition(req *MediaRecognitionRequest, title string, year, season, episode int) *MediaRecognitionResult <span class="cov0" title="0">{
        // Basic fallback recognition
        mediaType := req.MediaType
        if mediaType == "" </span><span class="cov0" title="0">{
                if season &gt; 0 &amp;&amp; episode &gt; 0 </span><span class="cov0" title="0">{
                        mediaType = MediaTypeTVEpisode
                }</span> else<span class="cov0" title="0"> if season &gt; 0 </span><span class="cov0" title="0">{
                        mediaType = MediaTypeTVSeries
                }</span> else<span class="cov0" title="0"> {
                        mediaType = MediaTypeMovie
                }</span>
        }

        <span class="cov0" title="0">return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("basic_%s_%d", strings.ReplaceAll(title, " ", "_"), time.Now().Unix()),
                MediaType:         mediaType,
                Title:             title,
                Year:              year,
                Season:            season,
                Episode:           episode,
                Confidence:        0.3, // Low confidence for basic recognition
                RecognitionMethod: "filename_parsing",
                APIProvider:       "basic",
                ExternalIDs:       make(map[string]string),
        }</span>
}

// Helper methods
func (p *MovieRecognitionProvider) extractTitleFromFilename(filename string) string <span class="cov0" title="0">{
        // Remove file extension
        name := strings.TrimSuffix(filename, "."+p.getFileExtension(filename))

        // Remove common patterns
        patterns := []string{
                `\d{4}`,           // Year
                `S\d{2}E\d{2}`,    // Season/Episode
                `\d{1,2}x\d{1,2}`, // Alternative season/episode
                `(?i)(720p|1080p|4k|hdtv|webrip|bluray|dvdrip|cam|ts|r5)`, // Quality
                `(?i)(xvid|x264|h264|h265|hevc)`,                          // Codec
                `(?i)(aac|ac3|dts|mp3)`,                                   // Audio
                `\[.*?\]`,                                                 // Brackets
                `\(.*?\)`,                                                 // Parentheses
        }

        for _, pattern := range patterns </span><span class="cov0" title="0">{
                re := regexp.MustCompile(pattern)
                name = re.ReplaceAllString(name, "")
        }</span>

        // Clean up
        <span class="cov0" title="0">name = regexp.MustCompile(`[._-]+`).ReplaceAllString(name, " ")
        name = regexp.MustCompile(`\s+`).ReplaceAllString(name, " ")
        name = strings.TrimSpace(name)

        return name</span>
}

func (p *MovieRecognitionProvider) extractYearFromFilename(filename string) int <span class="cov0" title="0">{
        re := regexp.MustCompile(`\b(19|20)\d{2}\b`)
        matches := re.FindAllString(filename, -1)

        if len(matches) &gt; 0 </span><span class="cov0" title="0">{
                if year, err := strconv.Atoi(matches[len(matches)-1]); err == nil </span><span class="cov0" title="0">{
                        return year
                }</span>
        }

        <span class="cov0" title="0">return 0</span>
}

func (p *MovieRecognitionProvider) extractSeasonEpisode(filename string) (int, int) <span class="cov0" title="0">{
        // Pattern: S01E01
        re := regexp.MustCompile(`S(\d{1,2})E(\d{1,2})`)
        matches := re.FindStringSubmatch(filename)
        if len(matches) == 3 </span><span class="cov0" title="0">{
                season, _ := strconv.Atoi(matches[1])
                episode, _ := strconv.Atoi(matches[2])
                return season, episode
        }</span>

        // Pattern: 1x01
        <span class="cov0" title="0">re = regexp.MustCompile(`(\d{1,2})x(\d{1,2})`)
        matches = re.FindStringSubmatch(filename)
        if len(matches) == 3 </span><span class="cov0" title="0">{
                season, _ := strconv.Atoi(matches[1])
                episode, _ := strconv.Atoi(matches[2])
                return season, episode
        }</span>

        <span class="cov0" title="0">return 0, 0</span>
}

func (p *MovieRecognitionProvider) getFileExtension(filename string) string <span class="cov0" title="0">{
        parts := strings.Split(filename, ".")
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                return parts[len(parts)-1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (p *MovieRecognitionProvider) parseYear(dateStr string) int <span class="cov0" title="0">{
        if len(dateStr) &gt;= 4 </span><span class="cov0" title="0">{
                if year, err := strconv.Atoi(dateStr[:4]); err == nil </span><span class="cov0" title="0">{
                        return year
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func (p *MovieRecognitionProvider) parseRuntime(runtime string) int64 <span class="cov0" title="0">{
        re := regexp.MustCompile(`(\d+)\s*min`)
        matches := re.FindStringSubmatch(runtime)
        if len(matches) == 2 </span><span class="cov0" title="0">{
                if minutes, err := strconv.Atoi(matches[1]); err == nil </span><span class="cov0" title="0">{
                        return int64(minutes * 60) // Convert to seconds
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func (p *MovieRecognitionProvider) calculateConfidence(title string, rating float64, voteCount int) float64 <span class="cov0" title="0">{
        confidence := 0.5 // Base confidence

        // Boost confidence based on rating and vote count
        if rating &gt; 7.0 &amp;&amp; voteCount &gt; 1000 </span><span class="cov0" title="0">{
                confidence += 0.3
        }</span> else<span class="cov0" title="0"> if rating &gt; 6.0 &amp;&amp; voteCount &gt; 100 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span> else<span class="cov0" title="0"> if voteCount &gt; 50 </span><span class="cov0" title="0">{
                confidence += 0.1
        }</span>

        // Boost confidence if title is not empty
        <span class="cov0" title="0">if title != "" </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">if confidence &gt; 1.0 </span><span class="cov0" title="0">{
                confidence = 1.0
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *MovieRecognitionProvider) calculateOMDbConfidence(rating, votes string) float64 <span class="cov0" title="0">{
        confidence := 0.5

        if r, err := strconv.ParseFloat(rating, 64); err == nil &amp;&amp; r &gt; 6.0 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        // Parse vote count (remove commas)
        <span class="cov0" title="0">cleanVotes := strings.ReplaceAll(votes, ",", "")
        if v, err := strconv.Atoi(cleanVotes); err == nil &amp;&amp; v &gt; 1000 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *MovieRecognitionProvider) mapOMDbType(omdbType string) MediaType <span class="cov0" title="0">{
        switch strings.ToLower(omdbType) </span>{
        case "movie":<span class="cov0" title="0">
                return MediaTypeMovie</span>
        case "series":<span class="cov0" title="0">
                return MediaTypeTVSeries</span>
        case "episode":<span class="cov0" title="0">
                return MediaTypeTVEpisode</span>
        default:<span class="cov0" title="0">
                return MediaTypeMovie</span>
        }
}

// RecognitionProvider interface implementation
func (p *MovieRecognitionProvider) GetProviderName() string <span class="cov0" title="0">{
        return "movie_recognition"
}</span>

func (p *MovieRecognitionProvider) SupportsMediaType(mediaType MediaType) bool <span class="cov0" title="0">{
        supportedTypes := []MediaType{
                MediaTypeMovie,
                MediaTypeTVSeries,
                MediaTypeTVEpisode,
                MediaTypeConcert,
                MediaTypeDocumentary,
                MediaTypeCourse,
                MediaTypeTraining,
        }

        for _, supported := range supportedTypes </span><span class="cov0" title="0">{
                if mediaType == supported </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (p *MovieRecognitionProvider) GetConfidenceThreshold() float64 <span class="cov0" title="0">{
        return 0.4 // Minimum 40% confidence required
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "math/rand"
        "sort"
        "strings"
        "time"

        "go.uber.org/zap"
)

type MusicPlayerService struct {
        db                 *sql.DB
        logger             *zap.Logger
        mediaPlayerService *MediaPlayerService
        playlistService    *PlaylistService
        positionService    *PlaybackPositionService
        lyricsService      *LyricsService
        coverArtService    *CoverArtService
        translationService *TranslationService
}

type MusicPlaybackSession struct {
        ID                string             `json:"id"`
        UserID            int64              `json:"user_id"`
        CurrentTrack      *MusicTrack        `json:"current_track"`
        Queue             []MusicTrack       `json:"queue"`
        QueueIndex        int                `json:"queue_index"`
        PlaylistID        *int64             `json:"playlist_id"`
        PlayMode          PlayMode           `json:"play_mode"`
        RepeatMode        RepeatMode         `json:"repeat_mode"`
        ShuffleEnabled    bool               `json:"shuffle_enabled"`
        ShuffleHistory    []int              `json:"shuffle_history"`
        Volume            float64            `json:"volume"`
        IsMuted           bool               `json:"is_muted"`
        Crossfade         bool               `json:"crossfade"`
        CrossfadeDuration int                `json:"crossfade_duration"`
        EqualizerPreset   string             `json:"equalizer_preset"`
        EqualizerBands    map[string]float64 `json:"equalizer_bands"`
        PlaybackState     PlaybackState      `json:"playback_state"`
        Position          int64              `json:"position"`
        Duration          int64              `json:"duration"`
        BufferedRanges    []BufferedRange    `json:"buffered_ranges"`
        PlaybackQuality   AudioQuality       `json:"playback_quality"`
        DeviceInfo        DeviceInfo         `json:"device_info"`
        LastActivity      time.Time          `json:"last_activity"`
        CreatedAt         time.Time          `json:"created_at"`
        UpdatedAt         time.Time          `json:"updated_at"`
}

type MusicTrack struct {
        ID            int64             `json:"id"`
        Title         string            `json:"title"`
        Artist        string            `json:"artist"`
        Album         string            `json:"album"`
        AlbumArtist   string            `json:"album_artist"`
        Genre         string            `json:"genre"`
        Year          int               `json:"year"`
        TrackNumber   int               `json:"track_number"`
        DiscNumber    int               `json:"disc_number"`
        Duration      int64             `json:"duration"`
        FilePath      string            `json:"file_path"`
        FileSize      int64             `json:"file_size"`
        Format        string            `json:"format"`
        Bitrate       int               `json:"bitrate"`
        SampleRate    int               `json:"sample_rate"`
        Channels      int               `json:"channels"`
        BPM           *int              `json:"bpm"`
        Key           *string           `json:"key"`
        Rating        *int              `json:"rating"`
        PlayCount     int64             `json:"play_count"`
        LastPlayed    *time.Time        `json:"last_played"`
        DateAdded     time.Time         `json:"date_added"`
        CoverArt      *CoverArt         `json:"cover_art"`
        Lyrics        *LyricsData       `json:"lyrics"`
        AudioFeatures *AudioFeatures    `json:"audio_features"`
        Waveform      *WaveformData     `json:"waveform"`
        Tags          map[string]string `json:"tags"`
        ReplayGain    *ReplayGainData   `json:"replay_gain"`
}

type AudioFeatures struct {
        Danceability     float64 `json:"danceability"`
        Energy           float64 `json:"energy"`
        Speechiness      float64 `json:"speechiness"`
        Acousticness     float64 `json:"acousticness"`
        Instrumentalness float64 `json:"instrumentalness"`
        Liveness         float64 `json:"liveness"`
        Valence          float64 `json:"valence"`
        Tempo            float64 `json:"tempo"`
        Loudness         float64 `json:"loudness"`
}

type WaveformData struct {
        ID       int64     `json:"id"`
        TrackID  int64     `json:"track_id"`
        Data     []float64 `json:"data"`
        Duration int64     `json:"duration"`
        Created  time.Time `json:"created"`
}

type ReplayGainData struct {
        TrackGain float64 `json:"track_gain"`
        TrackPeak float64 `json:"track_peak"`
        AlbumGain float64 `json:"album_gain"`
        AlbumPeak float64 `json:"album_peak"`
}

type BufferedRange struct {
        Start int64 `json:"start"`
        End   int64 `json:"end"`
}

type PlayMode string

const (
        PlayModeTrack    PlayMode = "track"
        PlayModeAlbum    PlayMode = "album"
        PlayModeArtist   PlayMode = "artist"
        PlayModePlaylist PlayMode = "playlist"
        PlayModeFolder   PlayMode = "folder"
        PlayModeGenre    PlayMode = "genre"
        PlayModeQueue    PlayMode = "queue"
)

type AudioQuality string

const (
        QualityLossless AudioQuality = "lossless" // FLAC/ALAC
)

type DeviceInfo struct {
        DeviceID   string `json:"device_id"`
        DeviceName string `json:"device_name"`
        DeviceType string `json:"device_type"`
        Platform   string `json:"platform"`
        AppVersion string `json:"app_version"`
}

type MusicLibraryStats struct {
        TotalTracks      int64            `json:"total_tracks"`
        TotalAlbums      int64            `json:"total_albums"`
        TotalArtists     int64            `json:"total_artists"`
        TotalGenres      int64            `json:"total_genres"`
        TotalDuration    int64            `json:"total_duration"`
        TotalSize        int64            `json:"total_size"`
        FormatBreakdown  map[string]int64 `json:"format_breakdown"`
        QualityBreakdown map[string]int64 `json:"quality_breakdown"`
        YearBreakdown    map[int]int64    `json:"year_breakdown"`
        TopGenres        []GenreStats     `json:"top_genres"`
        TopArtists       []ArtistStats    `json:"top_artists"`
        RecentlyAdded    []MusicTrack     `json:"recently_added"`
        MostPlayed       []MusicTrack     `json:"most_played"`
}

type Album struct {
        ID          int64        `json:"id"`
        Title       string       `json:"title"`
        Artist      string       `json:"artist"`
        AlbumArtist string       `json:"album_artist"`
        Year        int          `json:"year"`
        Genre       string       `json:"genre"`
        TrackCount  int          `json:"track_count"`
        Duration    int64        `json:"duration"`
        CoverArt    *CoverArt    `json:"cover_art"`
        Tracks      []MusicTrack `json:"tracks"`
        PlayCount   int64        `json:"play_count"`
        Rating      *int         `json:"rating"`
        DateAdded   time.Time    `json:"date_added"`
        LastPlayed  *time.Time   `json:"last_played"`
}

type Artist struct {
        ID         int64        `json:"id"`
        Name       string       `json:"name"`
        Biography  string       `json:"biography"`
        Country    string       `json:"country"`
        Genres     []string     `json:"genres"`
        Albums     []Album      `json:"albums"`
        TopTracks  []MusicTrack `json:"top_tracks"`
        TrackCount int          `json:"track_count"`
        AlbumCount int          `json:"album_count"`
        PlayCount  int64        `json:"play_count"`
        Followers  int64        `json:"followers"`
        CoverImage *CoverArt    `json:"cover_image"`
        DateAdded  time.Time    `json:"date_added"`
        LastPlayed *time.Time   `json:"last_played"`
}

type PlayTrackRequest struct {
        UserID     int64        `json:"user_id"`
        TrackID    int64        `json:"track_id"`
        PlayMode   PlayMode     `json:"play_mode"`
        StartTime  *int64       `json:"start_time"`
        Quality    AudioQuality `json:"quality"`
        DeviceInfo DeviceInfo   `json:"device_info"`
        PlaylistID *int64       `json:"playlist_id"`
        AlbumID    *int64       `json:"album_id"`
        ArtistID   *int64       `json:"artist_id"`
        FolderPath *string      `json:"folder_path"`
}

type PlayAlbumRequest struct {
        UserID     int64        `json:"user_id"`
        AlbumID    int64        `json:"album_id"`
        StartTrack *int         `json:"start_track"`
        Shuffle    bool         `json:"shuffle"`
        Quality    AudioQuality `json:"quality"`
        DeviceInfo DeviceInfo   `json:"device_info"`
}

type PlayArtistRequest struct {
        UserID     int64        `json:"user_id"`
        ArtistID   int64        `json:"artist_id"`
        Mode       string       `json:"mode"` // "top_tracks", "all_tracks", "albums"
        Shuffle    bool         `json:"shuffle"`
        Quality    AudioQuality `json:"quality"`
        DeviceInfo DeviceInfo   `json:"device_info"`
}

type UpdatePlaybackRequest struct {
        SessionID  string         `json:"session_id"`
        Position   *int64         `json:"position"`
        State      *PlaybackState `json:"state"`
        Volume     *float64       `json:"volume"`
        IsMuted    *bool          `json:"is_muted"`
        RepeatMode *RepeatMode    `json:"repeat_mode"`
        Shuffle    *bool          `json:"shuffle"`
}

type SeekRequest struct {
        SessionID string `json:"session_id"`
        Position  int64  `json:"position"`
}

type QueueRequest struct {
        SessionID string  `json:"session_id"`
        TrackIDs  []int64 `json:"track_ids"`
        Position  *int    `json:"position"`
}

func NewMusicPlayerService(
        db *sql.DB,
        logger *zap.Logger,
        mediaPlayerService *MediaPlayerService,
        playlistService *PlaylistService,
        positionService *PlaybackPositionService,
        lyricsService *LyricsService,
        coverArtService *CoverArtService,
        translationService *TranslationService,
) *MusicPlayerService <span class="cov0" title="0">{
        return &amp;MusicPlayerService{
                db:                 db,
                logger:             logger,
                mediaPlayerService: mediaPlayerService,
                playlistService:    playlistService,
                positionService:    positionService,
                lyricsService:      lyricsService,
                coverArtService:    coverArtService,
                translationService: translationService,
        }
}</span>

func (s *MusicPlayerService) PlayTrack(ctx context.Context, req *PlayTrackRequest) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting track playback",
                zap.Int64("user_id", req.UserID),
                zap.Int64("track_id", req.TrackID),
                zap.String("play_mode", string(req.PlayMode)))

        track, err := s.getTrack(ctx, req.TrackID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get track: %w", err)
        }</span>

        <span class="cov0" title="0">session := &amp;MusicPlaybackSession{
                ID:                generateSessionID(),
                UserID:            req.UserID,
                CurrentTrack:      track,
                Queue:             []MusicTrack{*track},
                QueueIndex:        0,
                PlayMode:          req.PlayMode,
                RepeatMode:        RepeatModeOff,
                ShuffleEnabled:    false,
                Volume:            1.0,
                IsMuted:           false,
                Crossfade:         false,
                CrossfadeDuration: 3000,
                EqualizerPreset:   "flat",
                EqualizerBands:    make(map[string]float64),
                PlaybackState:     PlaybackStatePlaying,
                Position:          0,
                Duration:          track.Duration,
                PlaybackQuality:   req.Quality,
                DeviceInfo:        req.DeviceInfo,
                LastActivity:      time.Now(),
                CreatedAt:         time.Now(),
                UpdatedAt:         time.Now(),
        }

        if req.StartTime != nil </span><span class="cov0" title="0">{
                session.Position = *req.StartTime
        }</span>

        <span class="cov0" title="0">switch req.PlayMode </span>{
        case PlayModeAlbum:<span class="cov0" title="0">
                if req.AlbumID != nil </span><span class="cov0" title="0">{
                        if err := s.loadAlbumQueue(ctx, session, *req.AlbumID, track.ID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load album queue", zap.Error(err))
                        }</span>
                }
        case PlayModeArtist:<span class="cov0" title="0">
                if req.ArtistID != nil </span><span class="cov0" title="0">{
                        if err := s.loadArtistQueue(ctx, session, *req.ArtistID, track.ID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load artist queue", zap.Error(err))
                        }</span>
                }
        case PlayModePlaylist:<span class="cov0" title="0">
                if req.PlaylistID != nil </span><span class="cov0" title="0">{
                        session.PlaylistID = req.PlaylistID
                        if err := s.loadPlaylistQueue(ctx, session, *req.PlaylistID, track.ID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load playlist queue", zap.Error(err))
                        }</span>
                }
        case PlayModeFolder:<span class="cov0" title="0">
                if req.FolderPath != nil </span><span class="cov0" title="0">{
                        if err := s.loadFolderQueue(ctx, session, *req.FolderPath, track.ID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load folder queue", zap.Error(err))
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to save session", zap.Error(err))
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.recordPlayback(ctx, req.UserID, track.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to record playback", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) PlayAlbum(ctx context.Context, req *PlayAlbumRequest) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting album playback",
                zap.Int64("user_id", req.UserID),
                zap.Int64("album_id", req.AlbumID),
                zap.Bool("shuffle", req.Shuffle))

        album, err := s.getAlbumWithTracks(ctx, req.AlbumID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get album: %w", err)
        }</span>

        <span class="cov0" title="0">if len(album.Tracks) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("album has no tracks")
        }</span>

        <span class="cov0" title="0">startIndex := 0
        if req.StartTrack != nil &amp;&amp; *req.StartTrack &lt; len(album.Tracks) </span><span class="cov0" title="0">{
                startIndex = *req.StartTrack
        }</span>

        <span class="cov0" title="0">session := &amp;MusicPlaybackSession{
                ID:                generateSessionID(),
                UserID:            req.UserID,
                CurrentTrack:      &amp;album.Tracks[startIndex],
                Queue:             album.Tracks,
                QueueIndex:        startIndex,
                PlayMode:          PlayModeAlbum,
                RepeatMode:        RepeatModeOff,
                ShuffleEnabled:    req.Shuffle,
                Volume:            1.0,
                IsMuted:           false,
                Crossfade:         true,
                CrossfadeDuration: 3000,
                EqualizerPreset:   "flat",
                EqualizerBands:    make(map[string]float64),
                PlaybackState:     PlaybackStatePlaying,
                Position:          0,
                Duration:          album.Tracks[startIndex].Duration,
                PlaybackQuality:   req.Quality,
                DeviceInfo:        req.DeviceInfo,
                LastActivity:      time.Now(),
                CreatedAt:         time.Now(),
                UpdatedAt:         time.Now(),
        }

        if req.Shuffle </span><span class="cov0" title="0">{
                s.shuffleQueue(session)
        }</span>

        <span class="cov0" title="0">if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) PlayArtist(ctx context.Context, req *PlayArtistRequest) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting artist playback",
                zap.Int64("user_id", req.UserID),
                zap.Int64("artist_id", req.ArtistID),
                zap.String("mode", req.Mode))

        var tracks []MusicTrack
        var err error

        switch req.Mode </span>{
        case "top_tracks":<span class="cov0" title="0">
                tracks, err = s.getArtistTopTracks(ctx, req.ArtistID, 50)</span>
        case "all_tracks":<span class="cov0" title="0">
                tracks, err = s.getArtistAllTracks(ctx, req.ArtistID)</span>
        case "albums":<span class="cov0" title="0">
                albums, albumErr := s.getArtistAlbums(ctx, req.ArtistID)
                if albumErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get artist albums: %w", albumErr)
                }</span>
                <span class="cov0" title="0">for _, album := range albums </span><span class="cov0" title="0">{
                        albumTracks, trackErr := s.getAlbumTracks(ctx, album.ID)
                        if trackErr == nil </span><span class="cov0" title="0">{
                                tracks = append(tracks, albumTracks...)
                        }</span>
                }
        default:<span class="cov0" title="0">
                tracks, err = s.getArtistTopTracks(ctx, req.ArtistID, 50)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get artist tracks: %w", err)
        }</span>

        <span class="cov0" title="0">if len(tracks) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("artist has no tracks")
        }</span>

        <span class="cov0" title="0">session := &amp;MusicPlaybackSession{
                ID:                generateSessionID(),
                UserID:            req.UserID,
                CurrentTrack:      &amp;tracks[0],
                Queue:             tracks,
                QueueIndex:        0,
                PlayMode:          PlayModeArtist,
                RepeatMode:        RepeatModeOff,
                ShuffleEnabled:    req.Shuffle,
                Volume:            1.0,
                IsMuted:           false,
                Crossfade:         true,
                CrossfadeDuration: 3000,
                EqualizerPreset:   "flat",
                EqualizerBands:    make(map[string]float64),
                PlaybackState:     PlaybackStatePlaying,
                Position:          0,
                Duration:          tracks[0].Duration,
                PlaybackQuality:   req.Quality,
                DeviceInfo:        req.DeviceInfo,
                LastActivity:      time.Now(),
                CreatedAt:         time.Now(),
                UpdatedAt:         time.Now(),
        }

        if req.Shuffle </span><span class="cov0" title="0">{
                s.shuffleQueue(session)
        }</span>

        <span class="cov0" title="0">if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) GetSession(ctx context.Context, sessionID string) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting playback session", zap.String("session_id", sessionID))

        query := `
                SELECT session_data, updated_at
                FROM music_playback_sessions
                WHERE id = $1 AND expires_at &gt; NOW()
        `

        var sessionData string
        var updatedAt time.Time
        err := s.db.QueryRowContext(ctx, query, sessionID).Scan(&amp;sessionData, &amp;updatedAt)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session not found or expired")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get session: %w", err)
        }</span>

        <span class="cov0" title="0">var session MusicPlaybackSession
        if err := json.Unmarshal([]byte(sessionData), &amp;session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal session: %w", err)
        }</span>

        <span class="cov0" title="0">session.UpdatedAt = updatedAt
        return &amp;session, nil</span>
}

func (s *MusicPlayerService) UpdatePlayback(ctx context.Context, req *UpdatePlaybackRequest) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Updating playback", zap.String("session_id", req.SessionID))

        session, err := s.GetSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Position != nil </span><span class="cov0" title="0">{
                session.Position = *req.Position
                if err := s.positionService.UpdatePosition(ctx, &amp;UpdatePositionRequest{
                        UserID:          session.UserID,
                        MediaItemID:     session.CurrentTrack.ID,
                        Position:        *req.Position,
                        Duration:        session.Duration,
                        DeviceInfo:      session.DeviceInfo.DeviceName,
                        PlaybackQuality: string(session.PlaybackQuality),
                }); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to update position", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">if req.State != nil </span><span class="cov0" title="0">{
                session.PlaybackState = *req.State
        }</span>

        <span class="cov0" title="0">if req.Volume != nil </span><span class="cov0" title="0">{
                session.Volume = *req.Volume
        }</span>

        <span class="cov0" title="0">if req.IsMuted != nil </span><span class="cov0" title="0">{
                session.IsMuted = *req.IsMuted
        }</span>

        <span class="cov0" title="0">if req.RepeatMode != nil </span><span class="cov0" title="0">{
                session.RepeatMode = *req.RepeatMode
        }</span>

        <span class="cov0" title="0">if req.Shuffle != nil </span><span class="cov0" title="0">{
                session.ShuffleEnabled = *req.Shuffle
                if *req.Shuffle </span><span class="cov0" title="0">{
                        s.shuffleQueue(session)
                }</span> else<span class="cov0" title="0"> {
                        s.unshuffleQueue(session)
                }</span>
        }

        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) NextTrack(ctx context.Context, sessionID string) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Skipping to next track", zap.String("session_id", sessionID))

        session, err := s.GetSession(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">nextIndex := s.getNextTrackIndex(session)
        if nextIndex == -1 </span><span class="cov0" title="0">{
                session.PlaybackState = PlaybackStateStopped
                return session, nil
        }</span>

        <span class="cov0" title="0">session.QueueIndex = nextIndex
        session.CurrentTrack = &amp;session.Queue[nextIndex]
        session.Position = 0
        session.Duration = session.CurrentTrack.Duration
        session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.recordPlayback(ctx, session.UserID, session.CurrentTrack.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to record playback", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) PreviousTrack(ctx context.Context, sessionID string) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Skipping to previous track", zap.String("session_id", sessionID))

        session, err := s.GetSession(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if session.Position &gt; 3000 </span><span class="cov0" title="0">{
                session.Position = 0
        }</span> else<span class="cov0" title="0"> {
                prevIndex := s.getPreviousTrackIndex(session)
                if prevIndex != -1 </span><span class="cov0" title="0">{
                        session.QueueIndex = prevIndex
                        session.CurrentTrack = &amp;session.Queue[prevIndex]
                        session.Duration = session.CurrentTrack.Duration
                }</span>
                <span class="cov0" title="0">session.Position = 0</span>
        }

        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) Seek(ctx context.Context, req *SeekRequest) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Seeking in track",
                zap.String("session_id", req.SessionID),
                zap.Int64("position", req.Position))

        session, err := s.GetSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Position &lt; 0 </span><span class="cov0" title="0">{
                req.Position = 0
        }</span>
        <span class="cov0" title="0">if req.Position &gt; session.Duration </span><span class="cov0" title="0">{
                req.Position = session.Duration
        }</span>

        <span class="cov0" title="0">session.Position = req.Position
        session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) AddToQueue(ctx context.Context, req *QueueRequest) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Adding tracks to queue",
                zap.String("session_id", req.SessionID),
                zap.Int("track_count", len(req.TrackIDs)))

        session, err := s.GetSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tracks, err := s.getTracks(ctx, req.TrackIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get tracks: %w", err)
        }</span>

        <span class="cov0" title="0">if req.Position != nil &amp;&amp; *req.Position &gt;= 0 &amp;&amp; *req.Position &lt;= len(session.Queue) </span><span class="cov0" title="0">{
                before := session.Queue[:*req.Position]
                after := session.Queue[*req.Position:]
                session.Queue = append(before, append(tracks, after...)...)

                if *req.Position &lt;= session.QueueIndex </span><span class="cov0" title="0">{
                        session.QueueIndex += len(tracks)
                }</span>
        } else<span class="cov0" title="0"> {
                session.Queue = append(session.Queue, tracks...)
        }</span>

        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) GetLibraryStats(ctx context.Context, userID int64) (*MusicLibraryStats, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting library statistics", zap.Int64("user_id", userID))

        stats := &amp;MusicLibraryStats{
                FormatBreakdown:  make(map[string]int64),
                QualityBreakdown: make(map[string]int64),
                YearBreakdown:    make(map[int]int64),
                TopGenres:        make([]GenreStats, 0),
                TopArtists:       make([]ArtistStats, 0),
                RecentlyAdded:    make([]MusicTrack, 0),
                MostPlayed:       make([]MusicTrack, 0),
        }

        if err := s.getBasicStats(ctx, userID, stats); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.getFormatBreakdown(ctx, userID, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get format breakdown", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getTopGenres(ctx, userID, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get top genres", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getTopArtists(ctx, userID, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get top artists", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getRecentlyAdded(ctx, userID, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get recently added", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getMostPlayed(ctx, userID, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get most played", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (s *MusicPlayerService) SetEqualizer(ctx context.Context, sessionID string, preset string, bands map[string]float64) error <span class="cov0" title="0">{
        s.logger.Debug("Setting equalizer",
                zap.String("session_id", sessionID),
                zap.String("preset", preset))

        session, err := s.GetSession(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.EqualizerPreset = preset
        if bands != nil </span><span class="cov0" title="0">{
                session.EqualizerBands = bands
        }</span>
        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        return s.saveSession(ctx, session)</span>
}

func (s *MusicPlayerService) getTrack(ctx context.Context, trackID int64) (*MusicTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bpm, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE id = $1 AND type = 'audio'
        `

        var track MusicTrack
        var lastPlayed sql.NullTime
        var bpm sql.NullInt64
        var key sql.NullString
        var rating sql.NullInt64

        err := s.db.QueryRowContext(ctx, query, trackID).Scan(
                &amp;track.ID, &amp;track.Title, &amp;track.Artist, &amp;track.Album, &amp;track.AlbumArtist,
                &amp;track.Genre, &amp;track.Year, &amp;track.TrackNumber, &amp;track.DiscNumber,
                &amp;track.Duration, &amp;track.FilePath, &amp;track.FileSize, &amp;track.Format,
                &amp;track.Bitrate, &amp;track.SampleRate, &amp;track.Channels, &amp;bpm, &amp;key,
                &amp;rating, &amp;track.PlayCount, &amp;lastPlayed, &amp;track.DateAdded,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if bpm.Valid </span><span class="cov0" title="0">{
                bpmInt := int(bpm.Int64)
                track.BPM = &amp;bpmInt
        }</span>
        <span class="cov0" title="0">if key.Valid </span><span class="cov0" title="0">{
                track.Key = &amp;key.String
        }</span>
        <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                ratingInt := int(rating.Int64)
                track.Rating = &amp;ratingInt
        }</span>
        <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                track.LastPlayed = &amp;lastPlayed.Time
        }</span>

        <span class="cov0" title="0">return &amp;track, nil</span>
}

func (s *MusicPlayerService) getTracks(ctx context.Context, trackIDs []int64) ([]MusicTrack, error) <span class="cov0" title="0">{
        if len(trackIDs) == 0 </span><span class="cov0" title="0">{
                return []MusicTrack{}, nil
        }</span>

        <span class="cov0" title="0">placeholders := make([]string, len(trackIDs))
        args := make([]interface{}, len(trackIDs))
        for i, id := range trackIDs </span><span class="cov0" title="0">{
                placeholders[i] = fmt.Sprintf("$%d", i+1)
                args[i] = id
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bpm, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE id IN (%s) AND type = 'audio'
                ORDER BY array_position(ARRAY[%s], id)
        `, strings.Join(placeholders, ","), strings.Join(placeholders, ","))

        rows, err := s.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tracks []MusicTrack
        for rows.Next() </span><span class="cov0" title="0">{
                var track MusicTrack
                var lastPlayed sql.NullTime
                var bpm sql.NullInt64
                var key sql.NullString
                var rating sql.NullInt64

                err := rows.Scan(
                        &amp;track.ID, &amp;track.Title, &amp;track.Artist, &amp;track.Album, &amp;track.AlbumArtist,
                        &amp;track.Genre, &amp;track.Year, &amp;track.TrackNumber, &amp;track.DiscNumber,
                        &amp;track.Duration, &amp;track.FilePath, &amp;track.FileSize, &amp;track.Format,
                        &amp;track.Bitrate, &amp;track.SampleRate, &amp;track.Channels, &amp;bpm, &amp;key,
                        &amp;rating, &amp;track.PlayCount, &amp;lastPlayed, &amp;track.DateAdded,
                )

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if bpm.Valid </span><span class="cov0" title="0">{
                        bpmInt := int(bpm.Int64)
                        track.BPM = &amp;bpmInt
                }</span>
                <span class="cov0" title="0">if key.Valid </span><span class="cov0" title="0">{
                        track.Key = &amp;key.String
                }</span>
                <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                        ratingInt := int(rating.Int64)
                        track.Rating = &amp;ratingInt
                }</span>
                <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                        track.LastPlayed = &amp;lastPlayed.Time
                }</span>

                <span class="cov0" title="0">tracks = append(tracks, track)</span>
        }

        <span class="cov0" title="0">return tracks, nil</span>
}

func (s *MusicPlayerService) getAlbumWithTracks(ctx context.Context, albumID int64) (*Album, error) <span class="cov0" title="0">{
        tracks, err := s.getAlbumTracks(ctx, albumID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(tracks) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("album not found")
        }</span>

        <span class="cov0" title="0">album := &amp;Album{
                ID:          albumID,
                Title:       tracks[0].Album,
                Artist:      tracks[0].Artist,
                AlbumArtist: tracks[0].AlbumArtist,
                Year:        tracks[0].Year,
                Genre:       tracks[0].Genre,
                TrackCount:  len(tracks),
                Tracks:      tracks,
                DateAdded:   tracks[0].DateAdded,
        }

        for _, track := range tracks </span><span class="cov0" title="0">{
                album.Duration += track.Duration
                album.PlayCount += track.PlayCount
                if track.LastPlayed != nil &amp;&amp; (album.LastPlayed == nil || track.LastPlayed.After(*album.LastPlayed)) </span><span class="cov0" title="0">{
                        album.LastPlayed = track.LastPlayed
                }</span>
        }

        <span class="cov0" title="0">return album, nil</span>
}

func (s *MusicPlayerService) getAlbumTracks(ctx context.Context, albumID int64) ([]MusicTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bpm, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE album_id = $1 AND type = 'audio'
                ORDER BY disc_number ASC, track_number ASC
        `

        rows, err := s.db.QueryContext(ctx, query, albumID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tracks []MusicTrack
        for rows.Next() </span><span class="cov0" title="0">{
                var track MusicTrack
                var lastPlayed sql.NullTime
                var bpm sql.NullInt64
                var key sql.NullString
                var rating sql.NullInt64

                err := rows.Scan(
                        &amp;track.ID, &amp;track.Title, &amp;track.Artist, &amp;track.Album, &amp;track.AlbumArtist,
                        &amp;track.Genre, &amp;track.Year, &amp;track.TrackNumber, &amp;track.DiscNumber,
                        &amp;track.Duration, &amp;track.FilePath, &amp;track.FileSize, &amp;track.Format,
                        &amp;track.Bitrate, &amp;track.SampleRate, &amp;track.Channels, &amp;bpm, &amp;key,
                        &amp;rating, &amp;track.PlayCount, &amp;lastPlayed, &amp;track.DateAdded,
                )

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if bpm.Valid </span><span class="cov0" title="0">{
                        bpmInt := int(bpm.Int64)
                        track.BPM = &amp;bpmInt
                }</span>
                <span class="cov0" title="0">if key.Valid </span><span class="cov0" title="0">{
                        track.Key = &amp;key.String
                }</span>
                <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                        ratingInt := int(rating.Int64)
                        track.Rating = &amp;ratingInt
                }</span>
                <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                        track.LastPlayed = &amp;lastPlayed.Time
                }</span>

                <span class="cov0" title="0">tracks = append(tracks, track)</span>
        }

        <span class="cov0" title="0">return tracks, nil</span>
}

func (s *MusicPlayerService) getArtistTopTracks(ctx context.Context, artistID int64, limit int) ([]MusicTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bpm, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE artist_id = $1 AND type = 'audio'
                ORDER BY play_count DESC, rating DESC
                LIMIT $2
        `

        rows, err := s.db.QueryContext(ctx, query, artistID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return s.scanTracks(rows)</span>
}

func (s *MusicPlayerService) getArtistAllTracks(ctx context.Context, artistID int64) ([]MusicTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bmp, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE artist_id = $1 AND type = 'audio'
                ORDER BY year DESC, album ASC, disc_number ASC, track_number ASC
        `

        rows, err := s.db.QueryContext(ctx, query, artistID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return s.scanTracks(rows)</span>
}

func (s *MusicPlayerService) getArtistAlbums(ctx context.Context, artistID int64) ([]Album, error) <span class="cov0" title="0">{
        return []Album{}, nil
}</span>

func (s *MusicPlayerService) scanTracks(rows *sql.Rows) ([]MusicTrack, error) <span class="cov0" title="0">{
        var tracks []MusicTrack
        for rows.Next() </span><span class="cov0" title="0">{
                var track MusicTrack
                var lastPlayed sql.NullTime
                var bpm sql.NullInt64
                var key sql.NullString
                var rating sql.NullInt64

                err := rows.Scan(
                        &amp;track.ID, &amp;track.Title, &amp;track.Artist, &amp;track.Album, &amp;track.AlbumArtist,
                        &amp;track.Genre, &amp;track.Year, &amp;track.TrackNumber, &amp;track.DiscNumber,
                        &amp;track.Duration, &amp;track.FilePath, &amp;track.FileSize, &amp;track.Format,
                        &amp;track.Bitrate, &amp;track.SampleRate, &amp;track.Channels, &amp;bpm, &amp;key,
                        &amp;rating, &amp;track.PlayCount, &amp;lastPlayed, &amp;track.DateAdded,
                )

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if bpm.Valid </span><span class="cov0" title="0">{
                        bpmInt := int(bpm.Int64)
                        track.BPM = &amp;bpmInt
                }</span>
                <span class="cov0" title="0">if key.Valid </span><span class="cov0" title="0">{
                        track.Key = &amp;key.String
                }</span>
                <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                        ratingInt := int(rating.Int64)
                        track.Rating = &amp;ratingInt
                }</span>
                <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                        track.LastPlayed = &amp;lastPlayed.Time
                }</span>

                <span class="cov0" title="0">tracks = append(tracks, track)</span>
        }

        <span class="cov0" title="0">return tracks, nil</span>
}

func (s *MusicPlayerService) loadAlbumQueue(ctx context.Context, session *MusicPlaybackSession, albumID, currentTrackID int64) error <span class="cov0" title="0">{
        tracks, err := s.getAlbumTracks(ctx, albumID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.Queue = tracks
        for i, track := range tracks </span><span class="cov0" title="0">{
                if track.ID == currentTrackID </span><span class="cov0" title="0">{
                        session.QueueIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) loadArtistQueue(ctx context.Context, session *MusicPlaybackSession, artistID, currentTrackID int64) error <span class="cov0" title="0">{
        tracks, err := s.getArtistTopTracks(ctx, artistID, 100)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.Queue = tracks
        for i, track := range tracks </span><span class="cov0" title="0">{
                if track.ID == currentTrackID </span><span class="cov0" title="0">{
                        session.QueueIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) loadPlaylistQueue(ctx context.Context, session *MusicPlaybackSession, playlistID, currentTrackID int64) error <span class="cov0" title="0">{
        playlistItems, err := s.playlistService.GetPlaylistItems(ctx, playlistID, session.UserID, 1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var trackIDs []int64
        for _, item := range playlistItems </span><span class="cov0" title="0">{
                trackIDs = append(trackIDs, item.MediaItemID)
        }</span>

        <span class="cov0" title="0">tracks, err := s.getTracks(ctx, trackIDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.Queue = tracks
        for i, track := range tracks </span><span class="cov0" title="0">{
                if track.ID == currentTrackID </span><span class="cov0" title="0">{
                        session.QueueIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) loadFolderQueue(ctx context.Context, session *MusicPlaybackSession, folderPath string, currentTrackID int64) error <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bmp, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE file_path LIKE $1 AND type = 'audio'
                ORDER BY file_path ASC
        `

        rows, err := s.db.QueryContext(ctx, query, folderPath+"%")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        tracks, err := s.scanTracks(rows)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.Queue = tracks
        for i, track := range tracks </span><span class="cov0" title="0">{
                if track.ID == currentTrackID </span><span class="cov0" title="0">{
                        session.QueueIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) shuffleQueue(session *MusicPlaybackSession) <span class="cov0" title="0">{
        if len(session.Queue) &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">currentTrack := session.Queue[session.QueueIndex]
        remainingTracks := make([]MusicTrack, 0, len(session.Queue)-1)

        for i, track := range session.Queue </span><span class="cov0" title="0">{
                if i != session.QueueIndex </span><span class="cov0" title="0">{
                        remainingTracks = append(remainingTracks, track)
                }</span>
        }

        <span class="cov0" title="0">rand.Shuffle(len(remainingTracks), func(i, j int) </span><span class="cov0" title="0">{
                remainingTracks[i], remainingTracks[j] = remainingTracks[j], remainingTracks[i]
        }</span>)

        <span class="cov0" title="0">session.Queue = append([]MusicTrack{currentTrack}, remainingTracks...)
        session.QueueIndex = 0</span>
}

func (s *MusicPlayerService) unshuffleQueue(session *MusicPlaybackSession) <span class="cov0" title="0">{
        if len(session.ShuffleHistory) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">sort.Slice(session.Queue, func(i, j int) bool </span><span class="cov0" title="0">{
                return session.Queue[i].ID &lt; session.Queue[j].ID
        }</span>)

        <span class="cov0" title="0">for i, track := range session.Queue </span><span class="cov0" title="0">{
                if track.ID == session.CurrentTrack.ID </span><span class="cov0" title="0">{
                        session.QueueIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">session.ShuffleHistory = []int{}</span>
}

func (s *MusicPlayerService) getNextTrackIndex(session *MusicPlaybackSession) int <span class="cov0" title="0">{
        if len(session.Queue) == 0 </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">switch session.RepeatMode </span>{
        case RepeatModeTrack:<span class="cov0" title="0">
                return session.QueueIndex</span>
        case RepeatModeAll, RepeatModeAlbum:<span class="cov0" title="0">
                if session.QueueIndex &lt; len(session.Queue)-1 </span><span class="cov0" title="0">{
                        return session.QueueIndex + 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        default:<span class="cov0" title="0">
                if session.QueueIndex &lt; len(session.Queue)-1 </span><span class="cov0" title="0">{
                        return session.QueueIndex + 1
                }</span>
                <span class="cov0" title="0">return -1</span>
        }
}

func (s *MusicPlayerService) getPreviousTrackIndex(session *MusicPlaybackSession) int <span class="cov0" title="0">{
        if len(session.Queue) == 0 </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">if session.QueueIndex &gt; 0 </span><span class="cov0" title="0">{
                return session.QueueIndex - 1
        }</span>

        <span class="cov0" title="0">if session.RepeatMode == RepeatModeAll || session.RepeatMode == RepeatModeAlbum </span><span class="cov0" title="0">{
                return len(session.Queue) - 1
        }</span>

        <span class="cov0" title="0">return -1</span>
}

func (s *MusicPlayerService) saveSession(ctx context.Context, session *MusicPlaybackSession) error <span class="cov0" title="0">{
        sessionData, err := json.Marshal(session)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal session: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO music_playback_sessions (id, user_id, session_data, expires_at, updated_at)
                VALUES ($1, $2, $3, NOW() + INTERVAL '24 hours', NOW())
                ON CONFLICT (id)
                DO UPDATE SET
                        session_data = EXCLUDED.session_data,
                        expires_at = NOW() + INTERVAL '24 hours',
                        updated_at = NOW()
        `

        _, err = s.db.ExecContext(ctx, query, session.ID, session.UserID, string(sessionData))
        return err</span>
}

func (s *MusicPlayerService) recordPlayback(ctx context.Context, userID, trackID int64) error <span class="cov0" title="0">{
        query := `
                UPDATE media_items
                SET play_count = play_count + 1, last_played = NOW()
                WHERE id = $1
        `

        _, err := s.db.ExecContext(ctx, query, trackID)
        return err
}</span>

func (s *MusicPlayerService) getBasicStats(ctx context.Context, userID int64, stats *MusicLibraryStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        COUNT(*) as total_tracks,
                        COUNT(DISTINCT album) as total_albums,
                        COUNT(DISTINCT artist) as total_artists,
                        COUNT(DISTINCT genre) as total_genres,
                        COALESCE(SUM(duration), 0) as total_duration,
                        COALESCE(SUM(file_size), 0) as total_size
                FROM media_items
                WHERE type = 'audio' AND user_id = $1
        `

        return s.db.QueryRowContext(ctx, query, userID).Scan(
                &amp;stats.TotalTracks, &amp;stats.TotalAlbums, &amp;stats.TotalArtists,
                &amp;stats.TotalGenres, &amp;stats.TotalDuration, &amp;stats.TotalSize,
        )
}</span>

func (s *MusicPlayerService) getFormatBreakdown(ctx context.Context, userID int64, stats *MusicLibraryStats) error <span class="cov0" title="0">{
        query := `
                SELECT format, COUNT(*)
                FROM media_items
                WHERE type = 'audio' AND user_id = $1
                GROUP BY format
                ORDER BY COUNT(*) DESC
        `

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var format string
                var count int64
                if err := rows.Scan(&amp;format, &amp;count); err == nil </span><span class="cov0" title="0">{
                        stats.FormatBreakdown[format] = count
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) getTopGenres(ctx context.Context, userID int64, stats *MusicLibraryStats) error <span class="cov0" title="0">{
        query := `
                SELECT genre, COUNT(*) as count, COALESCE(SUM(duration), 0) as duration
                FROM media_items
                WHERE type = 'audio' AND user_id = $1 AND genre != ''
                GROUP BY genre
                ORDER BY COUNT(*) DESC
                LIMIT 10
        `

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var genre GenreStats
                if err := rows.Scan(&amp;genre.Genre, &amp;genre.Count, &amp;genre.Duration); err == nil </span><span class="cov0" title="0">{
                        stats.TopGenres = append(stats.TopGenres, genre)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) getTopArtists(ctx context.Context, userID int64, stats *MusicLibraryStats) error <span class="cov0" title="0">{
        query := `
                SELECT artist, COUNT(*) as count, COALESCE(SUM(duration), 0) as duration
                FROM media_items
                WHERE type = 'audio' AND user_id = $1 AND artist != ''
                GROUP BY artist
                ORDER BY COUNT(*) DESC
                LIMIT 10
        `

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var artist ArtistStats
                if err := rows.Scan(&amp;artist.Artist, &amp;artist.Count, &amp;artist.Duration); err == nil </span><span class="cov0" title="0">{
                        stats.TopArtists = append(stats.TopArtists, artist)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) getRecentlyAdded(ctx context.Context, userID int64, stats *MusicLibraryStats) error <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bmp, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE type = 'audio' AND user_id = $1
                ORDER BY date_added DESC
                LIMIT 20
        `

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        tracks, err := s.scanTracks(rows)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">stats.RecentlyAdded = tracks
        return nil</span>
}

func (s *MusicPlayerService) getMostPlayed(ctx context.Context, userID int64, stats *MusicLibraryStats) error <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bmp, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE type = 'audio' AND user_id = $1 AND play_count &gt; 0
                ORDER BY play_count DESC
                LIMIT 20
        `

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        tracks, err := s.scanTracks(rows)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">stats.MostPlayed = tracks
        return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "math"
        "net/http"
        "net/url"
        "regexp"
        "strconv"
        "strings"
        "time"

        "catalogizer/internal/models"
        "go.uber.org/zap"
)

// Music recognition provider with audio fingerprinting
type MusicRecognitionProvider struct {
        logger      *zap.Logger
        httpClient  *http.Client
        baseURLs    map[string]string
        apiKeys     map[string]string
        rateLimiter map[string]*time.Ticker
}

// Last.fm API structures
type LastFMSearchResponse struct {
        Results LastFMResults `json:"results"`
}

type LastFMResults struct {
        TrackMatches  LastFMTrackMatches  `json:"trackmatches"`
        AlbumMatches  LastFMAlbumMatches  `json:"albummatches"`
        ArtistMatches LastFMArtistMatches `json:"artistmatches"`
}

type LastFMTrackMatches struct {
        Track []LastFMTrack `json:"track"`
}

type LastFMAlbumMatches struct {
        Album []LastFMAlbum `json:"album"`
}

type LastFMArtistMatches struct {
        Artist []LastFMArtist `json:"artist"`
}

type LastFMTrack struct {
        Name       string        `json:"name"`
        Artist     string        `json:"artist"`
        URL        string        `json:"url"`
        Streamable string        `json:"streamable"`
        Listeners  string        `json:"listeners"`
        Image      []LastFMImage `json:"image"`
        MBID       string        `json:"mbid"`
}

type LastFMAlbum struct {
        Name   string        `json:"name"`
        Artist string        `json:"artist"`
        URL    string        `json:"url"`
        Image  []LastFMImage `json:"image"`
        MBID   string        `json:"mbid"`
}

type LastFMArtist struct {
        Name       string        `json:"name"`
        Listeners  string        `json:"listeners"`
        MBID       string        `json:"mbid"`
        URL        string        `json:"url"`
        Streamable string        `json:"streamable"`
        Image      []LastFMImage `json:"image"`
}

type LastFMImage struct {
        Text string `json:"#text"`
        Size string `json:"size"`
}

type LastFMTrackInfo struct {
        Track LastFMTrackDetail `json:"track"`
}

type LastFMTrackDetail struct {
        Name       string             `json:"name"`
        MBID       string             `json:"mbid"`
        URL        string             `json:"url"`
        Duration   string             `json:"duration"`
        Streamable LastFMStreamable   `json:"streamable"`
        Listeners  string             `json:"listeners"`
        Playcount  string             `json:"playcount"`
        Artist     LastFMArtistDetail `json:"artist"`
        Album      LastFMAlbumDetail  `json:"album"`
        TopTags    LastFMTopTags      `json:"toptags"`
        Wiki       LastFMWiki         `json:"wiki"`
}

type LastFMStreamable struct {
        Text      string `json:"#text"`
        Fulltrack string `json:"fulltrack"`
}

type LastFMArtistDetail struct {
        Name string `json:"name"`
        MBID string `json:"mbid"`
        URL  string `json:"url"`
}

type LastFMAlbumDetail struct {
        Artist string        `json:"artist"`
        Title  string        `json:"title"`
        MBID   string        `json:"mbid"`
        URL    string        `json:"url"`
        Image  []LastFMImage `json:"image"`
}

type LastFMTopTags struct {
        Tag []LastFMTag `json:"tag"`
}

type LastFMTag struct {
        Name string `json:"name"`
        URL  string `json:"url"`
}

type LastFMWiki struct {
        Published string `json:"published"`
        Summary   string `json:"summary"`
        Content   string `json:"content"`
}

// MusicBrainz API structures
type MusicBrainzSearchResponse struct {
        Recordings []MusicBrainzRecording `json:"recordings"`
        Releases   []MusicBrainzRelease   `json:"releases"`
        Artists    []MusicBrainzArtist    `json:"artists"`
}

type MusicBrainzRecording struct {
        ID             string                    `json:"id"`
        Score          int                       `json:"score"`
        Title          string                    `json:"title"`
        Length         int                       `json:"length"`
        Disambiguation string                    `json:"disambiguation"`
        ArtistCredit   []MusicBrainzArtistCredit `json:"artist-credit"`
        Releases       []MusicBrainzReleaseBasic `json:"releases"`
        Tags           []MusicBrainzTag          `json:"tags"`
        Genres         []MusicBrainzGenre        `json:"genres"`
        ISRCs          []string                  `json:"isrcs"`
}

type MusicBrainzRelease struct {
        ID           string                    `json:"id"`
        Score        int                       `json:"score"`
        Title        string                    `json:"title"`
        StatusID     string                    `json:"status-id"`
        Status       string                    `json:"status"`
        Packaging    string                    `json:"packaging"`
        Date         string                    `json:"date"`
        Country      string                    `json:"country"`
        Barcode      string                    `json:"barcode"`
        ArtistCredit []MusicBrainzArtistCredit `json:"artist-credit"`
        ReleaseGroup MusicBrainzReleaseGroup   `json:"release-group"`
        Media        []MusicBrainzMedia        `json:"media"`
        LabelInfo    []MusicBrainzLabelInfo    `json:"label-info"`
}

type MusicBrainzArtist struct {
        ID        string              `json:"id"`
        Score     int                 `json:"score"`
        Name      string              `json:"name"`
        SortName  string              `json:"sort-name"`
        Type      string              `json:"type"`
        Gender    string              `json:"gender"`
        Country   string              `json:"country"`
        Area      MusicBrainzArea     `json:"area"`
        BeginArea MusicBrainzArea     `json:"begin-area"`
        EndArea   MusicBrainzArea     `json:"end-area"`
        LifeSpan  MusicBrainzLifeSpan `json:"life-span"`
        Aliases   []MusicBrainzAlias  `json:"aliases"`
        Tags      []MusicBrainzTag    `json:"tags"`
        Genres    []MusicBrainzGenre  `json:"genres"`
}

type MusicBrainzArtistCredit struct {
        Name   string            `json:"name"`
        Artist MusicBrainzArtist `json:"artist"`
}

type MusicBrainzReleaseBasic struct {
        ID       string `json:"id"`
        Title    string `json:"title"`
        StatusID string `json:"status-id"`
        Status   string `json:"status"`
        Date     string `json:"date"`
        Country  string `json:"country"`
}

type MusicBrainzReleaseGroup struct {
        ID               string `json:"id"`
        TypeID           string `json:"type-id"`
        Type             string `json:"type"`
        PrimaryTypeID    string `json:"primary-type-id"`
        PrimaryType      string `json:"primary-type"`
        Title            string `json:"title"`
        FirstReleaseDate string `json:"first-release-date"`
}

type MusicBrainzMedia struct {
        Format     string             `json:"format"`
        DiscCount  int                `json:"disc-count"`
        TrackCount int                `json:"track-count"`
        Tracks     []MusicBrainzTrack `json:"tracks"`
}

type MusicBrainzTrack struct {
        ID       string `json:"id"`
        Number   string `json:"number"`
        Title    string `json:"title"`
        Length   int    `json:"length"`
        Position int    `json:"position"`
}

type MusicBrainzLabelInfo struct {
        CatalogNumber string           `json:"catalog-number"`
        Label         MusicBrainzLabel `json:"label"`
}

type MusicBrainzLabel struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

type MusicBrainzArea struct {
        ID       string   `json:"id"`
        Name     string   `json:"name"`
        SortName string   `json:"sort-name"`
        ISO31661 []string `json:"iso-3166-1-codes"`
}

type MusicBrainzLifeSpan struct {
        Begin string `json:"begin"`
        End   string `json:"end"`
        Ended bool   `json:"ended"`
}

type MusicBrainzAlias struct {
        SortName  string `json:"sort-name"`
        Name      string `json:"name"`
        Locale    string `json:"locale"`
        Type      string `json:"type"`
        Primary   bool   `json:"primary"`
        BeginDate string `json:"begin-date"`
        EndDate   string `json:"end-date"`
}

type MusicBrainzTag struct {
        Count int    `json:"count"`
        Name  string `json:"name"`
}

type MusicBrainzGenre struct {
        Count int    `json:"count"`
        Name  string `json:"name"`
}

// Audio fingerprinting structures
type AudioFingerprintAnalysis struct {
        Duration         float64          `json:"duration"`
        SampleRate       int              `json:"sample_rate"`
        Channels         int              `json:"channels"`
        BitRate          int              `json:"bit_rate"`
        Tempo            float64          `json:"tempo"`
        Key              string           `json:"key"`
        Energy           float64          `json:"energy"`
        Valence          float64          `json:"valence"`
        Danceability     float64          `json:"danceability"`
        Acousticness     float64          `json:"acousticness"`
        Instrumentalness float64          `json:"instrumentalness"`
        Speechiness      float64          `json:"speechiness"`
        SpectralFeatures SpectralFeatures `json:"spectral_features"`
        ChromaFeatures   []float64        `json:"chroma_features"`
        MFCCFeatures     []float64        `json:"mfcc_features"`
        RhythmFeatures   RhythmFeatures   `json:"rhythm_features"`
}

type SpectralFeatures struct {
        SpectralCentroid  []float64 `json:"spectral_centroid"`
        SpectralBandwidth []float64 `json:"spectral_bandwidth"`
        SpectralRolloff   []float64 `json:"spectral_rolloff"`
        ZeroCrossingRate  []float64 `json:"zero_crossing_rate"`
        SpectralContrast  []float64 `json:"spectral_contrast"`
}

type RhythmFeatures struct {
        OnsetStrength []float64   `json:"onset_strength"`
        BeatTrack     []float64   `json:"beat_track"`
        Tempoogram    [][]float64 `json:"tempogram"`
}

func NewMusicRecognitionProvider(logger *zap.Logger) *MusicRecognitionProvider <span class="cov0" title="0">{
        return &amp;MusicRecognitionProvider{
                logger:     logger,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                baseURLs: map[string]string{
                        "lastfm":      "http://ws.audioscrobbler.com/2.0/",
                        "musicbrainz": "https://musicbrainz.org/ws/2",
                        "acoustid":    "https://api.acoustid.org/v2",
                        "spotify":     "https://api.spotify.com/v1",
                        "deezer":      "https://api.deezer.com",
                        "discogs":     "https://api.discogs.com",
                },
                apiKeys: map[string]string{
                        "lastfm":   "free_api_key",
                        "acoustid": "free_api_key",
                        "discogs":  "free_api_key",
                },
                rateLimiter: make(map[string]*time.Ticker),
        }
}</span>

func (p *MusicRecognitionProvider) RecognizeMedia(ctx context.Context, req *MediaRecognitionRequest) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        p.logger.Info("Starting music recognition",
                zap.String("file_path", req.FilePath),
                zap.String("media_type", string(req.MediaType)))

        // Extract metadata from filename
        title, artist, album := p.extractMusicMetadataFromFilename(req.FileName)
        trackNumber := p.extractTrackNumber(req.FileName)

        p.logger.Debug("Extracted metadata from filename",
                zap.String("title", title),
                zap.String("artist", artist),
                zap.String("album", album),
                zap.Int("track_number", trackNumber))

        // Try audio fingerprinting if audio sample provided
        if len(req.AudioSample) &gt; 0 </span><span class="cov0" title="0">{
                if result, err := p.recognizeByFingerprint(ctx, req.AudioSample); err == nil </span><span class="cov0" title="0">{
                        p.logger.Info("Successfully recognized via fingerprint",
                                zap.String("title", result.Title),
                                zap.Float64("confidence", result.Confidence))
                        return result, nil
                }</span>
        }

        // Try metadata-based recognition
        <span class="cov0" title="0">if title != "" || artist != "" </span><span class="cov0" title="0">{
                if result, err := p.recognizeByMetadata(ctx, title, artist, album); err == nil </span><span class="cov0" title="0">{
                        result.TrackNumber = trackNumber
                        p.logger.Info("Successfully recognized via metadata",
                                zap.String("title", result.Title),
                                zap.Float64("confidence", result.Confidence))
                        return result, nil
                }</span>
        }

        // Fallback to basic recognition
        <span class="cov0" title="0">return p.basicMusicRecognition(req, title, artist, album, trackNumber), nil</span>
}

func (p *MusicRecognitionProvider) recognizeByFingerprint(ctx context.Context, audioSample []byte) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Generate audio fingerprint
        fingerprint, err := p.generateAudioFingerprint(audioSample)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Query AcoustID API
        <span class="cov0" title="0">params := url.Values{}
        params.Set("client", p.apiKeys["acoustid"])
        params.Set("format", "json")
        params.Set("meta", "recordings+recordingids+releases+releaseids+releasegroups+releasegroupids+tracks+compress+usermeta+sources")
        params.Set("duration", fmt.Sprintf("%.2f", fingerprint.Duration))
        params.Set("fingerprint", fingerprint.Hash)

        resp, err := p.httpClient.PostForm(p.baseURLs["acoustid"]+"/lookup", params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var acoustIDResp AcoustIDResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;acoustIDResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if acoustIDResp.Status != "ok" || len(acoustIDResp.Results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no results from AcoustID")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestResult := acoustIDResp.Results[0]
        if len(bestResult.Recordings) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no recordings found")
        }</span>

        <span class="cov0" title="0">recording := bestResult.Recordings[0]

        // Convert to MediaRecognitionResult
        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("acoustid_%s", recording.ID),
                MediaType:         p.determineAudioMediaType(recording.Title),
                Title:             recording.Title,
                Duration:          int64(recording.Duration * 1000), // Convert to milliseconds
                Confidence:        bestResult.Score,
                RecognitionMethod: "audio_fingerprint",
                APIProvider:       "AcoustID",
                Fingerprints: map[string]string{
                        "acoustid": fingerprint.Hash,
                },
        }

        // Extract artist information
        if len(recording.Artists) &gt; 0 </span><span class="cov0" title="0">{
                result.Artist = recording.Artists[0].Name
                result.AlbumArtist = recording.Artists[0].Name
        }</span>

        // Extract release information
        <span class="cov0" title="0">if len(recording.Releases) &gt; 0 </span><span class="cov0" title="0">{
                release := recording.Releases[0]
                result.Album = release.Title
                if release.Date != "" </span><span class="cov0" title="0">{
                        result.Year = p.parseYear(release.Date)
                }</span>
        }

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "acoustid":    recording.ID,
                "musicbrainz": recording.ID,
        }

        // Get additional metadata from MusicBrainz
        if mbResult, err := p.getMusicBrainzDetails(ctx, recording.ID); err == nil </span><span class="cov0" title="0">{
                p.enhanceMusicResult(result, mbResult)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (p *MusicRecognitionProvider) recognizeByMetadata(ctx context.Context, title, artist, album string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Try Last.fm first
        if result, err := p.searchLastFM(ctx, title, artist, album); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try MusicBrainz as fallback
        <span class="cov0" title="0">if result, err := p.searchMusicBrainz(ctx, title, artist, album); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no results from metadata APIs")</span>
}

func (p *MusicRecognitionProvider) searchLastFM(ctx context.Context, title, artist, album string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}
        params.Set("method", "track.search")
        params.Set("api_key", p.apiKeys["lastfm"])
        params.Set("format", "json")
        params.Set("limit", "10")

        // Build search query
        query := title
        if artist != "" </span><span class="cov0" title="0">{
                query = fmt.Sprintf("%s %s", artist, title)
        }</span>
        <span class="cov0" title="0">params.Set("track", query)

        resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", p.baseURLs["lastfm"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResp LastFMSearchResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResp.Results.TrackMatches.Track) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no tracks found in Last.fm")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := searchResp.Results.TrackMatches.Track[0]

        // Get detailed track information
        return p.getLastFMTrackDetails(ctx, bestMatch.Name, bestMatch.Artist, bestMatch.MBID)</span>
}

func (p *MusicRecognitionProvider) getLastFMTrackDetails(ctx context.Context, track, artist, mbid string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}
        params.Set("method", "track.getInfo")
        params.Set("api_key", p.apiKeys["lastfm"])
        params.Set("format", "json")
        params.Set("artist", artist)
        params.Set("track", track)
        if mbid != "" </span><span class="cov0" title="0">{
                params.Set("mbid", mbid)
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", p.baseURLs["lastfm"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var trackInfo LastFMTrackInfo
        if err := json.NewDecoder(resp.Body).Decode(&amp;trackInfo); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">track_detail := trackInfo.Track

        // Convert to MediaRecognitionResult
        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("lastfm_%s", p.generateID(track_detail.Name, track_detail.Artist.Name)),
                MediaType:         p.determineAudioMediaType(track_detail.Name),
                Title:             track_detail.Name,
                Artist:            track_detail.Artist.Name,
                AlbumArtist:       track_detail.Artist.Name,
                Album:             track_detail.Album.Title,
                Confidence:        p.calculateLastFMConfidence(track_detail.Listeners, track_detail.Playcount),
                RecognitionMethod: "metadata_search",
                APIProvider:       "Last.fm",
        }

        // Parse duration
        if duration, err := strconv.ParseInt(track_detail.Duration, 10, 64); err == nil </span><span class="cov0" title="0">{
                result.Duration = duration
        }</span>

        // Extract genres from tags
        <span class="cov0" title="0">for _, tag := range track_detail.TopTags.Tag </span><span class="cov0" title="0">{
                result.Genres = append(result.Genres, tag.Name)
        }</span>

        // Extract description from wiki
        <span class="cov0" title="0">if track_detail.Wiki.Summary != "" </span><span class="cov0" title="0">{
                result.Description = track_detail.Wiki.Summary
        }</span>

        // Get cover art from album
        <span class="cov0" title="0">for _, image := range track_detail.Album.Image </span><span class="cov0" title="0">{
                if image.Text != "" </span><span class="cov0" title="0">{
                        size := "medium"
                        if image.Size == "extralarge" </span><span class="cov0" title="0">{
                                size = "large"
                        }</span> else<span class="cov0" title="0"> if image.Size == "large" </span><span class="cov0" title="0">{
                                size = "medium"
                        }</span> else<span class="cov0" title="0"> if image.Size == "medium" </span><span class="cov0" title="0">{
                                size = "small"
                        }</span>

                        <span class="cov0" title="0">result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                                URL:     image.Text,
                                Quality: size,
                                Source:  "Last.fm",
                        })</span>
                }
        }

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "lastfm_url": track_detail.URL,
        }
        if track_detail.MBID != "" </span><span class="cov0" title="0">{
                result.ExternalIDs["musicbrainz"] = track_detail.MBID
                result.MusicBrainzID = track_detail.MBID
        }</span>
        <span class="cov0" title="0">if track_detail.Album.MBID != "" </span><span class="cov0" title="0">{
                result.ExternalIDs["musicbrainz_album"] = track_detail.Album.MBID
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (p *MusicRecognitionProvider) searchMusicBrainz(ctx context.Context, title, artist, album string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Build search query
        query := fmt.Sprintf("recording:\"%s\"", title)
        if artist != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND artist:\"%s\"", artist)
        }</span>
        <span class="cov0" title="0">if album != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND release:\"%s\"", album)
        }</span>

        <span class="cov0" title="0">params := url.Values{}
        params.Set("query", query)
        params.Set("fmt", "json")
        params.Set("limit", "10")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/recording?%s", p.baseURLs["musicbrainz"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResp MusicBrainzSearchResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResp.Recordings) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no recordings found in MusicBrainz")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := searchResp.Recordings[0]

        return p.convertMusicBrainzRecording(bestMatch), nil</span>
}

func (p *MusicRecognitionProvider) getMusicBrainzDetails(ctx context.Context, recordingID string) (*MusicBrainzRecording, error) <span class="cov0" title="0">{
        params := url.Values{}
        params.Set("fmt", "json")
        params.Set("inc", "artists+releases+genres+tags+isrcs")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/recording/%s?%s", p.baseURLs["musicbrainz"], recordingID, params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var recording MusicBrainzRecording
        if err := json.NewDecoder(resp.Body).Decode(&amp;recording); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;recording, nil</span>
}

func (p *MusicRecognitionProvider) convertMusicBrainzRecording(recording MusicBrainzRecording) *MediaRecognitionResult <span class="cov0" title="0">{
        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("musicbrainz_%s", recording.ID),
                MediaType:         p.determineAudioMediaType(recording.Title),
                Title:             recording.Title,
                Duration:          int64(recording.Length),
                Confidence:        float64(recording.Score) / 100.0,
                RecognitionMethod: "metadata_search",
                APIProvider:       "MusicBrainz",
                MusicBrainzID:     recording.ID,
        }

        // Extract artist information
        if len(recording.ArtistCredit) &gt; 0 </span><span class="cov0" title="0">{
                result.Artist = recording.ArtistCredit[0].Artist.Name
                result.AlbumArtist = recording.ArtistCredit[0].Artist.Name
        }</span>

        // Extract release information
        <span class="cov0" title="0">if len(recording.Releases) &gt; 0 </span><span class="cov0" title="0">{
                release := recording.Releases[0]
                result.Album = release.Title
                if release.Date != "" </span><span class="cov0" title="0">{
                        result.Year = p.parseYear(release.Date)
                }</span>
        }

        // Extract genres
        <span class="cov0" title="0">for _, genre := range recording.Genres </span><span class="cov0" title="0">{
                result.Genres = append(result.Genres, genre.Name)
        }</span>

        // Extract tags
        <span class="cov0" title="0">for _, tag := range recording.Tags </span><span class="cov0" title="0">{
                result.Tags = append(result.Tags, tag.Name)
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "musicbrainz": recording.ID,
        }
        if len(recording.ISRCs) &gt; 0 </span><span class="cov0" title="0">{
                result.ExternalIDs["isrc"] = recording.ISRCs[0]
        }</span>

        <span class="cov0" title="0">return result</span>
}

func (p *MusicRecognitionProvider) enhanceMusicResult(result *MediaRecognitionResult, mbRecording *MusicBrainzRecording) <span class="cov0" title="0">{
        // Add additional metadata from MusicBrainz
        if result.Title == "" </span><span class="cov0" title="0">{
                result.Title = mbRecording.Title
        }</span>

        // Add genres if not present
        <span class="cov0" title="0">if len(result.Genres) == 0 </span><span class="cov0" title="0">{
                for _, genre := range mbRecording.Genres </span><span class="cov0" title="0">{
                        result.Genres = append(result.Genres, genre.Name)
                }</span>
        }

        // Add tags if not present
        <span class="cov0" title="0">if len(result.Tags) == 0 </span><span class="cov0" title="0">{
                for _, tag := range mbRecording.Tags </span><span class="cov0" title="0">{
                        result.Tags = append(result.Tags, tag.Name)
                }</span>
        }

        // Add ISRC if available
        <span class="cov0" title="0">if len(mbRecording.ISRCs) &gt; 0 &amp;&amp; result.ExternalIDs != nil </span><span class="cov0" title="0">{
                result.ExternalIDs["isrc"] = mbRecording.ISRCs[0]
        }</span>
}

func (p *MusicRecognitionProvider) basicMusicRecognition(req *MediaRecognitionRequest, title, artist, album string, trackNumber int) *MediaRecognitionResult <span class="cov0" title="0">{
        // Basic fallback recognition
        mediaType := req.MediaType
        if mediaType == "" </span><span class="cov0" title="0">{
                mediaType = p.determineAudioMediaType(title)
        }</span>

        <span class="cov0" title="0">return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("basic_music_%s_%d", strings.ReplaceAll(title, " ", "_"), time.Now().Unix()),
                MediaType:         mediaType,
                Title:             title,
                Artist:            artist,
                Album:             album,
                TrackNumber:       trackNumber,
                Confidence:        0.3, // Low confidence for basic recognition
                RecognitionMethod: "filename_parsing",
                APIProvider:       "basic",
                ExternalIDs:       make(map[string]string),
        }</span>
}

// Audio fingerprinting implementation
func (p *MusicRecognitionProvider) generateAudioFingerprint(audioSample []byte) (*AudioFingerprint, error) <span class="cov0" title="0">{
        // This is a simplified fingerprinting implementation
        // In production, you would use libraries like chromaprint or similar

        // Generate MD5 hash of audio sample as basic fingerprint
        hash := md5.Sum(audioSample)
        fingerprintHash := hex.EncodeToString(hash[:])

        // Extract basic audio features (simplified)
        analysis := p.analyzeAudioFeatures(audioSample)

        fingerprint := &amp;AudioFingerprint{
                Algorithm:  "md5_basic",
                Hash:       fingerprintHash,
                Duration:   analysis.Duration,
                SampleRate: analysis.SampleRate,
                Channels:   analysis.Channels,
                Features: map[string]float64{
                        "energy":  analysis.Energy,
                        "tempo":   analysis.Tempo,
                        "valence": analysis.Valence,
                },
                Segments: p.generateFingerprintSegments(audioSample, analysis),
        }

        return fingerprint, nil
}</span>

func (p *MusicRecognitionProvider) analyzeAudioFeatures(audioSample []byte) *AudioFingerprintAnalysis <span class="cov0" title="0">{
        // Simplified audio analysis
        // In production, use proper audio analysis libraries

        analysis := &amp;AudioFingerprintAnalysis{
                Duration:   float64(len(audioSample)) / 44100.0 / 2.0, // Assume 44.1kHz stereo
                SampleRate: 44100,
                Channels:   2,
                BitRate:    1411,                                      // CD quality
                Tempo:      120.0 + float64(len(audioSample)%60),      // Mock tempo
                Energy:     0.5 + float64(len(audioSample)%100)/200.0, // Mock energy
                Valence:    0.5 + float64(len(audioSample)%50)/100.0,  // Mock valence
        }

        // Generate mock features
        analysis.ChromaFeatures = make([]float64, 12)
        analysis.MFCCFeatures = make([]float64, 13)

        for i := range analysis.ChromaFeatures </span><span class="cov0" title="0">{
                analysis.ChromaFeatures[i] = float64(audioSample[i%len(audioSample)]) / 255.0
        }</span>

        <span class="cov0" title="0">for i := range analysis.MFCCFeatures </span><span class="cov0" title="0">{
                analysis.MFCCFeatures[i] = float64(audioSample[(i*10)%len(audioSample)]) / 255.0
        }</span>

        <span class="cov0" title="0">return analysis</span>
}

func (p *MusicRecognitionProvider) generateFingerprintSegments(audioSample []byte, analysis *AudioFingerprintAnalysis) []FingerprintSegment <span class="cov0" title="0">{
        segments := make([]FingerprintSegment, 0)
        segmentDuration := 10.0 // 10 second segments

        numSegments := int(math.Ceil(analysis.Duration / segmentDuration))
        for i := 0; i &lt; numSegments; i++ </span><span class="cov0" title="0">{
                startTime := float64(i) * segmentDuration
                endTime := math.Min(startTime+segmentDuration, analysis.Duration)

                // Generate segment hash
                segmentStart := int(startTime * float64(analysis.SampleRate) * float64(analysis.Channels))
                segmentEnd := int(endTime * float64(analysis.SampleRate) * float64(analysis.Channels))

                if segmentEnd &gt; len(audioSample) </span><span class="cov0" title="0">{
                        segmentEnd = len(audioSample)
                }</span>
                <span class="cov0" title="0">if segmentStart &gt;= segmentEnd </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">segmentData := audioSample[segmentStart:segmentEnd]
                hash := md5.Sum(segmentData)
                segmentHash := hex.EncodeToString(hash[:])

                segment := FingerprintSegment{
                        StartTime: startTime,
                        EndTime:   endTime,
                        Hash:      segmentHash,
                        Features: map[string]float64{
                                "energy": analysis.Energy * (0.8 + 0.4*float64(i%3)/2.0),
                                "tempo":  analysis.Tempo * (0.9 + 0.2*float64(i%5)/4.0),
                        },
                }

                segments = append(segments, segment)</span>
        }

        <span class="cov0" title="0">return segments</span>
}

// Helper methods
func (p *MusicRecognitionProvider) extractMusicMetadataFromFilename(filename string) (title, artist, album string) <span class="cov0" title="0">{
        // Remove file extension
        name := strings.TrimSuffix(filename, "."+p.getFileExtension(filename))

        // Common patterns for music files:
        // Artist - Title
        // Artist - Album - Track Number - Title
        // Track Number - Artist - Title
        // Album - Track Number - Artist - Title

        // Pattern: Artist - Title
        if parts := strings.Split(name, " - "); len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                artist = strings.TrimSpace(parts[0])
                title = strings.TrimSpace(parts[1])

                // If there are more parts, try to identify album
                if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                        // Check if second part looks like album or track number
                        if !p.looksLikeTrackNumber(parts[1]) </span><span class="cov0" title="0">{
                                album = strings.TrimSpace(parts[1])
                                title = strings.TrimSpace(parts[2])
                        }</span>
                }

                <span class="cov0" title="0">return title, artist, album</span>
        }

        // Pattern: Track Number - Title
        <span class="cov0" title="0">trackNumPattern := regexp.MustCompile(`^(\d+)[\s\-\.]+(.+)$`)
        if matches := trackNumPattern.FindStringSubmatch(name); len(matches) == 3 </span><span class="cov0" title="0">{
                title = strings.TrimSpace(matches[2])
                // Try to extract artist from title if it contains " - "
                if parts := strings.Split(title, " - "); len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        artist = strings.TrimSpace(parts[0])
                        title = strings.TrimSpace(parts[1])
                }</span>
                <span class="cov0" title="0">return title, artist, album</span>
        }

        // Fallback: use filename as title
        <span class="cov0" title="0">title = name
        return title, artist, album</span>
}

func (p *MusicRecognitionProvider) extractTrackNumber(filename string) int <span class="cov0" title="0">{
        // Look for track number at the beginning
        trackNumPattern := regexp.MustCompile(`^(\d+)[\s\-\.]`)
        if matches := trackNumPattern.FindStringSubmatch(filename); len(matches) &gt;= 2 </span><span class="cov0" title="0">{
                if trackNum, err := strconv.Atoi(matches[1]); err == nil </span><span class="cov0" title="0">{
                        return trackNum
                }</span>
        }

        // Look for track number pattern like "Track 01" or "01 -"
        <span class="cov0" title="0">trackPattern := regexp.MustCompile(`(?i)track\s*(\d+)|(\d+)\s*[-\.]`)
        if matches := trackPattern.FindStringSubmatch(filename); len(matches) &gt;= 2 </span><span class="cov0" title="0">{
                for i := 1; i &lt; len(matches); i++ </span><span class="cov0" title="0">{
                        if matches[i] != "" </span><span class="cov0" title="0">{
                                if trackNum, err := strconv.Atoi(matches[i]); err == nil </span><span class="cov0" title="0">{
                                        return trackNum
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return 0</span>
}

func (p *MusicRecognitionProvider) looksLikeTrackNumber(str string) bool <span class="cov0" title="0">{
        // Check if string looks like a track number
        trackPattern := regexp.MustCompile(`^\d{1,3}$`)
        return trackPattern.MatchString(strings.TrimSpace(str))
}</span>

func (p *MusicRecognitionProvider) determineAudioMediaType(title string) MediaType <span class="cov0" title="0">{
        title = strings.ToLower(title)

        // Check for audiobook patterns
        audiobookPatterns := []string{"audiobook", "narrated", "narrator", "chapter", "audio book"}
        for _, pattern := range audiobookPatterns </span><span class="cov0" title="0">{
                if strings.Contains(title, pattern) </span><span class="cov0" title="0">{
                        return MediaTypeAudiobook
                }</span>
        }

        // Check for podcast patterns
        <span class="cov0" title="0">podcastPatterns := []string{"podcast", "episode", "ep.", "show"}
        for _, pattern := range podcastPatterns </span><span class="cov0" title="0">{
                if strings.Contains(title, pattern) </span><span class="cov0" title="0">{
                        return MediaTypePodcast
                }</span>
        }

        // Default to music
        <span class="cov0" title="0">return MediaTypeMusic</span>
}

func (p *MusicRecognitionProvider) getFileExtension(filename string) string <span class="cov0" title="0">{
        parts := strings.Split(filename, ".")
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                return parts[len(parts)-1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (p *MusicRecognitionProvider) parseYear(dateStr string) int <span class="cov0" title="0">{
        if len(dateStr) &gt;= 4 </span><span class="cov0" title="0">{
                if year, err := strconv.Atoi(dateStr[:4]); err == nil </span><span class="cov0" title="0">{
                        return year
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func (p *MusicRecognitionProvider) calculateLastFMConfidence(listeners, playcount string) float64 <span class="cov0" title="0">{
        confidence := 0.5

        if l, err := strconv.Atoi(listeners); err == nil &amp;&amp; l &gt; 1000 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">if p, err := strconv.Atoi(playcount); err == nil &amp;&amp; p &gt; 10000 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *MusicRecognitionProvider) generateID(title, artist string) string <span class="cov0" title="0">{
        combined := fmt.Sprintf("%s_%s", title, artist)
        hash := md5.Sum([]byte(combined))
        return hex.EncodeToString(hash[:])[:12]
}</span>

// RecognitionProvider interface implementation
func (p *MusicRecognitionProvider) GetProviderName() string <span class="cov0" title="0">{
        return "music_recognition"
}</span>

func (p *MusicRecognitionProvider) SupportsMediaType(mediaType MediaType) bool <span class="cov0" title="0">{
        supportedTypes := []MediaType{
                MediaTypeMusic,
                MediaTypeAlbum,
                MediaTypeAudiobook,
                MediaTypePodcast,
        }

        for _, supported := range supportedTypes </span><span class="cov0" title="0">{
                if mediaType == supported </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (p *MusicRecognitionProvider) GetConfidenceThreshold() float64 <span class="cov0" title="0">{
        return 0.4 // Minimum 40% confidence required
}</span>

// AcoustID API response structure
type AcoustIDResponse struct {
        Status  string           `json:"status"`
        Results []AcoustIDResult `json:"results"`
}

type AcoustIDResult struct {
        ID         string              `json:"id"`
        Score      float64             `json:"score"`
        Recordings []AcoustIDRecording `json:"recordings"`
}

type AcoustIDRecording struct {
        ID       string            `json:"id"`
        Title    string            `json:"title"`
        Duration float64           `json:"duration"`
        Artists  []AcoustIDArtist  `json:"artists"`
        Releases []AcoustIDRelease `json:"releases"`
}

type AcoustIDArtist struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

type AcoustIDRelease struct {
        ID      string `json:"id"`
        Title   string `json:"title"`
        Date    string `json:"date"`
        Country string `json:"country"`
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package services

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "go.uber.org/zap"
)

type PlaybackPositionService struct {
        db     *sql.DB
        logger *zap.Logger
}

type PlaybackPosition struct {
        ID              int64     `json:"id" db:"id"`
        UserID          int64     `json:"user_id" db:"user_id"`
        MediaItemID     int64     `json:"media_item_id" db:"media_item_id"`
        Position        int64     `json:"position" db:"position"` // Position in milliseconds
        Duration        int64     `json:"duration" db:"duration"` // Total duration in milliseconds
        PercentComplete float64   `json:"percent_complete" db:"percent_complete"`
        LastPlayed      time.Time `json:"last_played" db:"last_played"`
        IsCompleted     bool      `json:"is_completed" db:"is_completed"`
        DeviceInfo      string    `json:"device_info" db:"device_info"`
        PlaybackQuality string    `json:"playback_quality" db:"playback_quality"`
        CreatedAt       time.Time `json:"created_at" db:"created_at"`
        UpdatedAt       time.Time `json:"updated_at" db:"updated_at"`
}

type PlaybackBookmark struct {
        ID          int64     `json:"id" db:"id"`
        UserID      int64     `json:"user_id" db:"user_id"`
        MediaItemID int64     `json:"media_item_id" db:"media_item_id"`
        Position    int64     `json:"position" db:"position"`
        Name        string    `json:"name" db:"name"`
        Description string    `json:"description" db:"description"`
        CreatedAt   time.Time `json:"created_at" db:"created_at"`
}

type PlaybackHistory struct {
        ID              int64      `json:"id" db:"id"`
        UserID          int64      `json:"user_id" db:"user_id"`
        MediaItemID     int64      `json:"media_item_id" db:"media_item_id"`
        StartTime       time.Time  `json:"start_time" db:"start_time"`
        EndTime         *time.Time `json:"end_time" db:"end_time"`
        Duration        int64      `json:"duration" db:"duration"`
        PercentWatched  float64    `json:"percent_watched" db:"percent_watched"`
        DeviceInfo      string     `json:"device_info" db:"device_info"`
        PlaybackQuality string     `json:"playback_quality" db:"playback_quality"`
        WasCompleted    bool       `json:"was_completed" db:"was_completed"`
}

type UpdatePositionRequest struct {
        UserID          int64  `json:"user_id"`
        MediaItemID     int64  `json:"media_item_id"`
        Position        int64  `json:"position"`
        Duration        int64  `json:"duration"`
        DeviceInfo      string `json:"device_info"`
        PlaybackQuality string `json:"playback_quality"`
}

type BookmarkRequest struct {
        UserID      int64  `json:"user_id"`
        MediaItemID int64  `json:"media_item_id"`
        Position    int64  `json:"position"`
        Name        string `json:"name"`
        Description string `json:"description"`
}

type PlaybackStatsRequest struct {
        UserID    int64      `json:"user_id"`
        StartDate *time.Time `json:"start_date"`
        EndDate   *time.Time `json:"end_date"`
        MediaType string     `json:"media_type"`
        Limit     int        `json:"limit"`
}

type PlaybackStats struct {
        TotalPlaytime     int64             `json:"total_playtime"`
        TotalMediaItems   int64             `json:"total_media_items"`
        CompletedItems    int64             `json:"completed_items"`
        MostPlayedGenres  []GenreStats      `json:"most_played_genres"`
        RecentlyWatched   []PlaybackHistory `json:"recently_watched"`
        TopArtists        []ArtistStats     `json:"top_artists"`
        PlaybackByHour    map[string]int64  `json:"playback_by_hour"`
        WatchTimeByDevice map[string]int64  `json:"watch_time_by_device"`
}

type GenreStats struct {
        Genre    string `json:"genre"`
        Count    int64  `json:"count"`
        Duration int64  `json:"duration"`
}

type ArtistStats struct {
        Artist   string `json:"artist"`
        Count    int64  `json:"count"`
        Duration int64  `json:"duration"`
}

func NewPlaybackPositionService(db *sql.DB, logger *zap.Logger) *PlaybackPositionService <span class="cov0" title="0">{
        return &amp;PlaybackPositionService{
                db:     db,
                logger: logger,
        }
}</span>

func (s *PlaybackPositionService) UpdatePosition(ctx context.Context, req *UpdatePositionRequest) error <span class="cov0" title="0">{
        s.logger.Info("Updating playback position",
                zap.Int64("user_id", req.UserID),
                zap.Int64("media_item_id", req.MediaItemID),
                zap.Int64("position", req.Position),
                zap.Int64("duration", req.Duration))

        percentComplete := float64(req.Position) / float64(req.Duration) * 100
        isCompleted := percentComplete &gt;= 90.0

        query := `
                INSERT INTO playback_positions (
                        user_id, media_item_id, position, duration, percent_complete,
                        last_played, is_completed, device_info, playback_quality, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), NOW())
                ON CONFLICT (user_id, media_item_id)
                DO UPDATE SET
                        position = EXCLUDED.position,
                        duration = EXCLUDED.duration,
                        percent_complete = EXCLUDED.percent_complete,
                        last_played = EXCLUDED.last_played,
                        is_completed = EXCLUDED.is_completed,
                        device_info = EXCLUDED.device_info,
                        playback_quality = EXCLUDED.playback_quality,
                        updated_at = NOW()
        `

        _, err := s.db.ExecContext(ctx, query,
                req.UserID, req.MediaItemID, req.Position, req.Duration,
                percentComplete, time.Now(), isCompleted, req.DeviceInfo, req.PlaybackQuality)

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update playback position", zap.Error(err))
                return fmt.Errorf("failed to update playback position: %w", err)
        }</span>

        <span class="cov0" title="0">if isCompleted </span><span class="cov0" title="0">{
                if err := s.recordPlaybackHistory(ctx, req, true); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to record playback history", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaybackPositionService) GetPosition(ctx context.Context, userID, mediaItemID int64) (*PlaybackPosition, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting playback position",
                zap.Int64("user_id", userID),
                zap.Int64("media_item_id", mediaItemID))

        query := `
                SELECT id, user_id, media_item_id, position, duration, percent_complete,
                           last_played, is_completed, device_info, playback_quality, created_at, updated_at
                FROM playback_positions
                WHERE user_id = $1 AND media_item_id = $2
        `

        var position PlaybackPosition
        err := s.db.QueryRowContext(ctx, query, userID, mediaItemID).Scan(
                &amp;position.ID, &amp;position.UserID, &amp;position.MediaItemID,
                &amp;position.Position, &amp;position.Duration, &amp;position.PercentComplete,
                &amp;position.LastPlayed, &amp;position.IsCompleted, &amp;position.DeviceInfo,
                &amp;position.PlaybackQuality, &amp;position.CreatedAt, &amp;position.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get playback position", zap.Error(err))
                return nil, fmt.Errorf("failed to get playback position: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;position, nil</span>
}

func (s *PlaybackPositionService) GetContinueWatching(ctx context.Context, userID int64, limit int) ([]PlaybackPosition, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting continue watching list",
                zap.Int64("user_id", userID),
                zap.Int("limit", limit))

        query := `
                SELECT pp.id, pp.user_id, pp.media_item_id, pp.position, pp.duration,
                           pp.percent_complete, pp.last_played, pp.is_completed,
                           pp.device_info, pp.playback_quality, pp.created_at, pp.updated_at
                FROM playback_positions pp
                INNER JOIN media_items mi ON pp.media_item_id = mi.id
                WHERE pp.user_id = $1
                  AND pp.percent_complete BETWEEN 5 AND 90
                  AND pp.last_played &gt; NOW() - INTERVAL '30 days'
                ORDER BY pp.last_played DESC
                LIMIT $2
        `

        rows, err := s.db.QueryContext(ctx, query, userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get continue watching list", zap.Error(err))
                return nil, fmt.Errorf("failed to get continue watching: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var positions []PlaybackPosition
        for rows.Next() </span><span class="cov0" title="0">{
                var position PlaybackPosition
                err := rows.Scan(
                        &amp;position.ID, &amp;position.UserID, &amp;position.MediaItemID,
                        &amp;position.Position, &amp;position.Duration, &amp;position.PercentComplete,
                        &amp;position.LastPlayed, &amp;position.IsCompleted, &amp;position.DeviceInfo,
                        &amp;position.PlaybackQuality, &amp;position.CreatedAt, &amp;position.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to scan playback position", zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">positions = append(positions, position)</span>
        }

        <span class="cov0" title="0">return positions, nil</span>
}

func (s *PlaybackPositionService) CreateBookmark(ctx context.Context, req *BookmarkRequest) (*PlaybackBookmark, error) <span class="cov0" title="0">{
        s.logger.Info("Creating playback bookmark",
                zap.Int64("user_id", req.UserID),
                zap.Int64("media_item_id", req.MediaItemID),
                zap.String("name", req.Name))

        query := `
                INSERT INTO playback_bookmarks (user_id, media_item_id, position, name, description, created_at)
                VALUES ($1, $2, $3, $4, $5, NOW())
                RETURNING id, created_at
        `

        var bookmark PlaybackBookmark
        err := s.db.QueryRowContext(ctx, query,
                req.UserID, req.MediaItemID, req.Position, req.Name, req.Description).Scan(
                &amp;bookmark.ID, &amp;bookmark.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create bookmark", zap.Error(err))
                return nil, fmt.Errorf("failed to create bookmark: %w", err)
        }</span>

        <span class="cov0" title="0">bookmark.UserID = req.UserID
        bookmark.MediaItemID = req.MediaItemID
        bookmark.Position = req.Position
        bookmark.Name = req.Name
        bookmark.Description = req.Description

        return &amp;bookmark, nil</span>
}

func (s *PlaybackPositionService) GetBookmarks(ctx context.Context, userID, mediaItemID int64) ([]PlaybackBookmark, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting bookmarks",
                zap.Int64("user_id", userID),
                zap.Int64("media_item_id", mediaItemID))

        query := `
                SELECT id, user_id, media_item_id, position, name, description, created_at
                FROM playback_bookmarks
                WHERE user_id = $1 AND media_item_id = $2
                ORDER BY position ASC
        `

        rows, err := s.db.QueryContext(ctx, query, userID, mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get bookmarks", zap.Error(err))
                return nil, fmt.Errorf("failed to get bookmarks: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var bookmarks []PlaybackBookmark
        for rows.Next() </span><span class="cov0" title="0">{
                var bookmark PlaybackBookmark
                err := rows.Scan(
                        &amp;bookmark.ID, &amp;bookmark.UserID, &amp;bookmark.MediaItemID,
                        &amp;bookmark.Position, &amp;bookmark.Name, &amp;bookmark.Description,
                        &amp;bookmark.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to scan bookmark", zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">bookmarks = append(bookmarks, bookmark)</span>
        }

        <span class="cov0" title="0">return bookmarks, nil</span>
}

func (s *PlaybackPositionService) DeleteBookmark(ctx context.Context, userID, bookmarkID int64) error <span class="cov0" title="0">{
        s.logger.Info("Deleting bookmark",
                zap.Int64("user_id", userID),
                zap.Int64("bookmark_id", bookmarkID))

        query := `DELETE FROM playback_bookmarks WHERE id = $1 AND user_id = $2`

        result, err := s.db.ExecContext(ctx, query, bookmarkID, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to delete bookmark", zap.Error(err))
                return fmt.Errorf("failed to delete bookmark: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("bookmark not found or access denied")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaybackPositionService) GetPlaybackStats(ctx context.Context, req *PlaybackStatsRequest) (*PlaybackStats, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting playback statistics",
                zap.Int64("user_id", req.UserID))

        stats := &amp;PlaybackStats{
                MostPlayedGenres:  make([]GenreStats, 0),
                RecentlyWatched:   make([]PlaybackHistory, 0),
                TopArtists:        make([]ArtistStats, 0),
                PlaybackByHour:    make(map[string]int64),
                WatchTimeByDevice: make(map[string]int64),
        }

        if err := s.getTotalPlaytime(ctx, req, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get total playtime", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.getRecentlyWatched(ctx, req, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get recently watched", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.getPlaybackByHour(ctx, req, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get playback by hour", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.getWatchTimeByDevice(ctx, req, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get watch time by device", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (s *PlaybackPositionService) recordPlaybackHistory(ctx context.Context, req *UpdatePositionRequest, completed bool) error <span class="cov0" title="0">{
        query := `
                INSERT INTO playback_history (
                        user_id, media_item_id, start_time, end_time, duration,
                        percent_watched, device_info, playback_quality, was_completed
                ) VALUES ($1, $2, NOW() - INTERVAL '%d milliseconds', NOW(), $3, $4, $5, $6, $7)
        `

        percentWatched := float64(req.Position) / float64(req.Duration) * 100

        _, err := s.db.ExecContext(ctx, fmt.Sprintf(query, req.Position),
                req.UserID, req.MediaItemID, req.Duration, percentWatched,
                req.DeviceInfo, req.PlaybackQuality, completed)

        return err
}</span>

func (s *PlaybackPositionService) getTotalPlaytime(ctx context.Context, req *PlaybackStatsRequest, stats *PlaybackStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        COALESCE(SUM(duration), 0) as total_playtime,
                        COUNT(*) as total_items,
                        COUNT(CASE WHEN was_completed THEN 1 END) as completed_items
                FROM playback_history
                WHERE user_id = $1
        `

        args := []interface{}{req.UserID}
        if req.StartDate != nil </span><span class="cov0" title="0">{
                query += " AND start_time &gt;= $2"
                args = append(args, *req.StartDate)
        }</span>
        <span class="cov0" title="0">if req.EndDate != nil </span><span class="cov0" title="0">{
                if req.StartDate != nil </span><span class="cov0" title="0">{
                        query += " AND start_time &lt;= $3"
                }</span> else<span class="cov0" title="0"> {
                        query += " AND start_time &lt;= $2"
                }</span>
                <span class="cov0" title="0">args = append(args, *req.EndDate)</span>
        }

        <span class="cov0" title="0">err := s.db.QueryRowContext(ctx, query, args...).Scan(
                &amp;stats.TotalPlaytime, &amp;stats.TotalMediaItems, &amp;stats.CompletedItems)

        return err</span>
}

func (s *PlaybackPositionService) getRecentlyWatched(ctx context.Context, req *PlaybackStatsRequest, stats *PlaybackStats) error <span class="cov0" title="0">{
        limit := req.Limit
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">query := `
                SELECT id, user_id, media_item_id, start_time, end_time, duration,
                           percent_watched, device_info, playback_quality, was_completed
                FROM playback_history
                WHERE user_id = $1
                ORDER BY start_time DESC
                LIMIT $2
        `

        rows, err := s.db.QueryContext(ctx, query, req.UserID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var history PlaybackHistory
                err := rows.Scan(
                        &amp;history.ID, &amp;history.UserID, &amp;history.MediaItemID,
                        &amp;history.StartTime, &amp;history.EndTime, &amp;history.Duration,
                        &amp;history.PercentWatched, &amp;history.DeviceInfo,
                        &amp;history.PlaybackQuality, &amp;history.WasCompleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">stats.RecentlyWatched = append(stats.RecentlyWatched, history)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaybackPositionService) getPlaybackByHour(ctx context.Context, req *PlaybackStatsRequest, stats *PlaybackStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        EXTRACT(HOUR FROM start_time) as hour,
                        COUNT(*) as count
                FROM playback_history
                WHERE user_id = $1
                GROUP BY EXTRACT(HOUR FROM start_time)
                ORDER BY hour
        `

        rows, err := s.db.QueryContext(ctx, query, req.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var hour int
                var count int64
                err := rows.Scan(&amp;hour, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">stats.PlaybackByHour[fmt.Sprintf("%02d:00", hour)] = count</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaybackPositionService) getWatchTimeByDevice(ctx context.Context, req *PlaybackStatsRequest, stats *PlaybackStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        device_info,
                        SUM(duration) as total_duration
                FROM playback_history
                WHERE user_id = $1
                GROUP BY device_info
                ORDER BY total_duration DESC
        `

        rows, err := s.db.QueryContext(ctx, query, req.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var device string
                var duration int64
                err := rows.Scan(&amp;device, &amp;duration)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">stats.WatchTimeByDevice[device] = duration</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaybackPositionService) CleanupOldPositions(ctx context.Context, olderThan time.Duration) error <span class="cov0" title="0">{
        s.logger.Info("Cleaning up old playback positions",
                zap.Duration("older_than", olderThan))

        query := `
                DELETE FROM playback_positions
                WHERE last_played &lt; $1 AND is_completed = true
        `

        cutoff := time.Now().Add(-olderThan)
        result, err := s.db.ExecContext(ctx, query, cutoff)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to cleanup old positions", zap.Error(err))
                return fmt.Errorf("failed to cleanup old positions: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        s.logger.Info("Cleaned up old playback positions",
                zap.Int64("rows_affected", rowsAffected))

        return nil</span>
}

func (s *PlaybackPositionService) SyncAcrossDevices(ctx context.Context, userID int64) error <span class="cov0" title="0">{
        s.logger.Debug("Syncing playback positions across devices",
                zap.Int64("user_id", userID))

        return nil
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "go.uber.org/zap"
)

type PlaylistService struct {
        db     *sql.DB
        logger *zap.Logger
}

type Playlist struct {
        ID              int64      `json:"id" db:"id"`
        UserID          int64      `json:"user_id" db:"user_id"`
        Name            string     `json:"name" db:"name"`
        Description     string     `json:"description" db:"description"`
        IsPublic        bool       `json:"is_public" db:"is_public"`
        IsSmartPlaylist bool       `json:"is_smart_playlist" db:"is_smart_playlist"`
        SmartCriteria   string     `json:"smart_criteria" db:"smart_criteria"`
        CoverArtURL     string     `json:"cover_art_url" db:"cover_art_url"`
        TrackCount      int        `json:"track_count" db:"track_count"`
        TotalDuration   int64      `json:"total_duration" db:"total_duration"`
        PlayCount       int64      `json:"play_count" db:"play_count"`
        LastPlayed      *time.Time `json:"last_played" db:"last_played"`
        CreatedAt       time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt       time.Time  `json:"updated_at" db:"updated_at"`
        Tags            []string   `json:"tags"`
        CollaboratorIDs []int64    `json:"collaborator_ids"`
}

type PlaylistItem struct {
        ID          int64     `json:"id" db:"id"`
        PlaylistID  int64     `json:"playlist_id" db:"playlist_id"`
        MediaItemID int64     `json:"media_item_id" db:"media_item_id"`
        Position    int       `json:"position" db:"position"`
        AddedBy     int64     `json:"added_by" db:"added_by"`
        AddedAt     time.Time `json:"added_at" db:"added_at"`
        CustomTitle string    `json:"custom_title" db:"custom_title"`
        StartTime   *int64    `json:"start_time" db:"start_time"`
        EndTime     *int64    `json:"end_time" db:"end_time"`
}

type PlaybackQueue struct {
        ID              int64     `json:"id" db:"id"`
        UserID          int64     `json:"user_id" db:"user_id"`
        Name            string    `json:"name" db:"name"`
        CurrentItemID   *int64    `json:"current_item_id" db:"current_item_id"`
        CurrentPosition int       `json:"current_position" db:"current_position"`
        ShuffleEnabled  bool      `json:"shuffle_enabled" db:"shuffle_enabled"`
        RepeatMode      string    `json:"repeat_mode" db:"repeat_mode"` // none, track, playlist
        ShuffleHistory  string    `json:"shuffle_history" db:"shuffle_history"`
        CreatedAt       time.Time `json:"created_at" db:"created_at"`
        UpdatedAt       time.Time `json:"updated_at" db:"updated_at"`
}

type QueueItem struct {
        ID               int64     `json:"id" db:"id"`
        QueueID          int64     `json:"queue_id" db:"queue_id"`
        MediaItemID      int64     `json:"media_item_id" db:"media_item_id"`
        Position         int       `json:"position" db:"position"`
        OriginalPosition int       `json:"original_position" db:"original_position"`
        PlayCount        int       `json:"play_count" db:"play_count"`
        AddedAt          time.Time `json:"added_at" db:"added_at"`
}

type SmartPlaylistCriteria struct {
        Rules []SmartRule `json:"rules"`
        Logic string      `json:"logic"` // "AND" or "OR"
        Limit int         `json:"limit"`
        Order string      `json:"order"` // "added_desc", "added_asc", "play_count_desc", "random", etc.
}

type SmartRule struct {
        Field    string      `json:"field"`    // "genre", "artist", "album", "year", "rating", "play_count", etc.
        Operator string      `json:"operator"` // "equals", "contains", "greater_than", "less_than", "in", etc.
        Value    interface{} `json:"value"`
}

type CreatePlaylistRequest struct {
        UserID          int64                  `json:"user_id"`
        Name            string                 `json:"name"`
        Description     string                 `json:"description"`
        IsPublic        bool                   `json:"is_public"`
        IsSmartPlaylist bool                   `json:"is_smart_playlist"`
        SmartCriteria   *SmartPlaylistCriteria `json:"smart_criteria"`
        Tags            []string               `json:"tags"`
        CollaboratorIDs []int64                `json:"collaborator_ids"`
}

type UpdatePlaylistRequest struct {
        ID              int64    `json:"id"`
        UserID          int64    `json:"user_id"`
        Name            *string  `json:"name"`
        Description     *string  `json:"description"`
        IsPublic        *bool    `json:"is_public"`
        CoverArtURL     *string  `json:"cover_art_url"`
        Tags            []string `json:"tags"`
        CollaboratorIDs []int64  `json:"collaborator_ids"`
}

type AddToPlaylistRequest struct {
        PlaylistID   int64            `json:"playlist_id"`
        MediaItemIDs []int64          `json:"media_item_ids"`
        UserID       int64            `json:"user_id"`
        Position     *int             `json:"position"`
        CustomTitles map[int64]string `json:"custom_titles"`
}

type ReorderPlaylistRequest struct {
        PlaylistID  int64 `json:"playlist_id"`
        UserID      int64 `json:"user_id"`
        ItemID      int64 `json:"item_id"`
        NewPosition int   `json:"new_position"`
}

type PlaylistSearchRequest struct {
        UserID   int64    `json:"user_id"`
        Query    string   `json:"query"`
        IsPublic *bool    `json:"is_public"`
        Tags     []string `json:"tags"`
        Limit    int      `json:"limit"`
        Offset   int      `json:"offset"`
}

func NewPlaylistService(db *sql.DB, logger *zap.Logger) *PlaylistService <span class="cov0" title="0">{
        return &amp;PlaylistService{
                db:     db,
                logger: logger,
        }
}</span>

func (s *PlaylistService) CreatePlaylist(ctx context.Context, req *CreatePlaylistRequest) (*Playlist, error) <span class="cov0" title="0">{
        s.logger.Info("Creating playlist",
                zap.Int64("user_id", req.UserID),
                zap.String("name", req.Name),
                zap.Bool("is_smart", req.IsSmartPlaylist))

        var smartCriteriaJSON string
        if req.SmartCriteria != nil </span><span class="cov0" title="0">{
                criteriaBytes, err := json.Marshal(req.SmartCriteria)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal smart criteria: %w", err)
                }</span>
                <span class="cov0" title="0">smartCriteriaJSON = string(criteriaBytes)</span>
        }

        <span class="cov0" title="0">query := `
                INSERT INTO playlists (
                        user_id, name, description, is_public, is_smart_playlist,
                        smart_criteria, track_count, total_duration, play_count,
                        created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, 0, 0, 0, NOW(), NOW())
                RETURNING id, created_at, updated_at
        `

        var playlist Playlist
        err := s.db.QueryRowContext(ctx, query,
                req.UserID, req.Name, req.Description, req.IsPublic,
                req.IsSmartPlaylist, smartCriteriaJSON).Scan(
                &amp;playlist.ID, &amp;playlist.CreatedAt, &amp;playlist.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create playlist", zap.Error(err))
                return nil, fmt.Errorf("failed to create playlist: %w", err)
        }</span>

        <span class="cov0" title="0">playlist.UserID = req.UserID
        playlist.Name = req.Name
        playlist.Description = req.Description
        playlist.IsPublic = req.IsPublic
        playlist.IsSmartPlaylist = req.IsSmartPlaylist
        playlist.SmartCriteria = smartCriteriaJSON
        playlist.Tags = req.Tags
        playlist.CollaboratorIDs = req.CollaboratorIDs

        if len(req.Tags) &gt; 0 </span><span class="cov0" title="0">{
                if err := s.updatePlaylistTags(ctx, playlist.ID, req.Tags); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to add tags to playlist", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">if len(req.CollaboratorIDs) &gt; 0 </span><span class="cov0" title="0">{
                if err := s.updatePlaylistCollaborators(ctx, playlist.ID, req.CollaboratorIDs); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to add collaborators to playlist", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">if req.IsSmartPlaylist &amp;&amp; req.SmartCriteria != nil </span><span class="cov0" title="0">{
                if err := s.RefreshSmartPlaylist(ctx, playlist.ID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to populate smart playlist", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return &amp;playlist, nil</span>
}

func (s *PlaylistService) GetPlaylist(ctx context.Context, playlistID, userID int64) (*Playlist, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting playlist",
                zap.Int64("playlist_id", playlistID),
                zap.Int64("user_id", userID))

        query := `
                SELECT p.id, p.user_id, p.name, p.description, p.is_public,
                           p.is_smart_playlist, p.smart_criteria, p.cover_art_url,
                           p.track_count, p.total_duration, p.play_count, p.last_played,
                           p.created_at, p.updated_at
                FROM playlists p
                LEFT JOIN playlist_collaborators pc ON p.id = pc.playlist_id
                WHERE p.id = $1
                  AND (p.user_id = $2 OR p.is_public = true OR pc.user_id = $2)
        `

        var playlist Playlist
        err := s.db.QueryRowContext(ctx, query, playlistID, userID).Scan(
                &amp;playlist.ID, &amp;playlist.UserID, &amp;playlist.Name, &amp;playlist.Description,
                &amp;playlist.IsPublic, &amp;playlist.IsSmartPlaylist, &amp;playlist.SmartCriteria,
                &amp;playlist.CoverArtURL, &amp;playlist.TrackCount, &amp;playlist.TotalDuration,
                &amp;playlist.PlayCount, &amp;playlist.LastPlayed, &amp;playlist.CreatedAt, &amp;playlist.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("playlist not found or access denied")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get playlist", zap.Error(err))
                return nil, fmt.Errorf("failed to get playlist: %w", err)
        }</span>

        <span class="cov0" title="0">playlist.Tags, _ = s.getPlaylistTags(ctx, playlistID)
        playlist.CollaboratorIDs, _ = s.getPlaylistCollaborators(ctx, playlistID)

        return &amp;playlist, nil</span>
}

func (s *PlaylistService) GetUserPlaylists(ctx context.Context, userID int64, includePublic bool) ([]Playlist, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting user playlists",
                zap.Int64("user_id", userID),
                zap.Bool("include_public", includePublic))

        baseQuery := `
                SELECT DISTINCT p.id, p.user_id, p.name, p.description, p.is_public,
                           p.is_smart_playlist, p.smart_criteria, p.cover_art_url,
                           p.track_count, p.total_duration, p.play_count, p.last_played,
                           p.created_at, p.updated_at
                FROM playlists p
                LEFT JOIN playlist_collaborators pc ON p.id = pc.playlist_id
                WHERE p.user_id = $1 OR pc.user_id = $1
        `

        if includePublic </span><span class="cov0" title="0">{
                baseQuery += " OR p.is_public = true"
        }</span>

        <span class="cov0" title="0">baseQuery += " ORDER BY p.updated_at DESC"

        rows, err := s.db.QueryContext(ctx, baseQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get user playlists", zap.Error(err))
                return nil, fmt.Errorf("failed to get user playlists: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var playlists []Playlist
        for rows.Next() </span><span class="cov0" title="0">{
                var playlist Playlist
                err := rows.Scan(
                        &amp;playlist.ID, &amp;playlist.UserID, &amp;playlist.Name, &amp;playlist.Description,
                        &amp;playlist.IsPublic, &amp;playlist.IsSmartPlaylist, &amp;playlist.SmartCriteria,
                        &amp;playlist.CoverArtURL, &amp;playlist.TrackCount, &amp;playlist.TotalDuration,
                        &amp;playlist.PlayCount, &amp;playlist.LastPlayed, &amp;playlist.CreatedAt, &amp;playlist.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to scan playlist", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">playlist.Tags, _ = s.getPlaylistTags(ctx, playlist.ID)
                playlist.CollaboratorIDs, _ = s.getPlaylistCollaborators(ctx, playlist.ID)

                playlists = append(playlists, playlist)</span>
        }

        <span class="cov0" title="0">return playlists, nil</span>
}

func (s *PlaylistService) AddToPlaylist(ctx context.Context, req *AddToPlaylistRequest) error <span class="cov0" title="0">{
        s.logger.Info("Adding items to playlist",
                zap.Int64("playlist_id", req.PlaylistID),
                zap.Int("item_count", len(req.MediaItemIDs)))

        if !s.canModifyPlaylist(ctx, req.PlaylistID, req.UserID) </span><span class="cov0" title="0">{
                return fmt.Errorf("permission denied to modify playlist")
        }</span>

        <span class="cov0" title="0">tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        position := 0
        if req.Position != nil </span><span class="cov0" title="0">{
                position = *req.Position
        }</span> else<span class="cov0" title="0"> {
                err := tx.QueryRowContext(ctx,
                        "SELECT COALESCE(MAX(position), 0) + 1 FROM playlist_items WHERE playlist_id = $1",
                        req.PlaylistID).Scan(&amp;position)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get next position: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if req.Position != nil </span><span class="cov0" title="0">{
                _, err := tx.ExecContext(ctx,
                        "UPDATE playlist_items SET position = position + $1 WHERE playlist_id = $2 AND position &gt;= $3",
                        len(req.MediaItemIDs), req.PlaylistID, *req.Position)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to shift positions: %w", err)
                }</span>
        }

        <span class="cov0" title="0">for i, mediaItemID := range req.MediaItemIDs </span><span class="cov0" title="0">{
                customTitle := ""
                if req.CustomTitles != nil </span><span class="cov0" title="0">{
                        customTitle = req.CustomTitles[mediaItemID]
                }</span>

                <span class="cov0" title="0">_, err := tx.ExecContext(ctx, `
                        INSERT INTO playlist_items (playlist_id, media_item_id, position, added_by, added_at, custom_title)
                        VALUES ($1, $2, $3, $4, NOW(), $5)
                `, req.PlaylistID, mediaItemID, position+i, req.UserID, customTitle)

                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to add item to playlist", zap.Error(err))
                        return fmt.Errorf("failed to add item to playlist: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if err := s.updatePlaylistStats(ctx, tx, req.PlaylistID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update playlist stats: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaylistService) RemoveFromPlaylist(ctx context.Context, playlistID, itemID, userID int64) error <span class="cov0" title="0">{
        s.logger.Info("Removing item from playlist",
                zap.Int64("playlist_id", playlistID),
                zap.Int64("item_id", itemID))

        if !s.canModifyPlaylist(ctx, playlistID, userID) </span><span class="cov0" title="0">{
                return fmt.Errorf("permission denied to modify playlist")
        }</span>

        <span class="cov0" title="0">tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        var position int
        err = tx.QueryRowContext(ctx,
                "SELECT position FROM playlist_items WHERE id = $1 AND playlist_id = $2",
                itemID, playlistID).Scan(&amp;position)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("playlist item not found: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx,
                "DELETE FROM playlist_items WHERE id = $1 AND playlist_id = $2",
                itemID, playlistID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove item: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx,
                "UPDATE playlist_items SET position = position - 1 WHERE playlist_id = $1 AND position &gt; $2",
                playlistID, position)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update positions: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.updatePlaylistStats(ctx, tx, playlistID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update playlist stats: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaylistService) ReorderPlaylist(ctx context.Context, req *ReorderPlaylistRequest) error <span class="cov0" title="0">{
        s.logger.Info("Reordering playlist",
                zap.Int64("playlist_id", req.PlaylistID),
                zap.Int64("item_id", req.ItemID),
                zap.Int("new_position", req.NewPosition))

        if !s.canModifyPlaylist(ctx, req.PlaylistID, req.UserID) </span><span class="cov0" title="0">{
                return fmt.Errorf("permission denied to modify playlist")
        }</span>

        <span class="cov0" title="0">tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        var currentPosition int
        err = tx.QueryRowContext(ctx,
                "SELECT position FROM playlist_items WHERE id = $1 AND playlist_id = $2",
                req.ItemID, req.PlaylistID).Scan(&amp;currentPosition)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("playlist item not found: %w", err)
        }</span>

        <span class="cov0" title="0">if currentPosition &lt; req.NewPosition </span><span class="cov0" title="0">{
                _, err = tx.ExecContext(ctx, `
                        UPDATE playlist_items
                        SET position = position - 1
                        WHERE playlist_id = $1 AND position &gt; $2 AND position &lt;= $3
                `, req.PlaylistID, currentPosition, req.NewPosition)
        }</span> else<span class="cov0" title="0"> if currentPosition &gt; req.NewPosition </span><span class="cov0" title="0">{
                _, err = tx.ExecContext(ctx, `
                        UPDATE playlist_items
                        SET position = position + 1
                        WHERE playlist_id = $1 AND position &gt;= $2 AND position &lt; $3
                `, req.PlaylistID, req.NewPosition, currentPosition)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update positions: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx,
                "UPDATE playlist_items SET position = $1 WHERE id = $2",
                req.NewPosition, req.ItemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update item position: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaylistService) GetPlaylistItems(ctx context.Context, playlistID, userID int64, limit, offset int) ([]PlaylistItem, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting playlist items",
                zap.Int64("playlist_id", playlistID),
                zap.Int("limit", limit),
                zap.Int("offset", offset))

        query := `
                SELECT pi.id, pi.playlist_id, pi.media_item_id, pi.position,
                           pi.added_by, pi.added_at, pi.custom_title, pi.start_time, pi.end_time
                FROM playlist_items pi
                INNER JOIN playlists p ON pi.playlist_id = p.id
                LEFT JOIN playlist_collaborators pc ON p.id = pc.playlist_id
                WHERE pi.playlist_id = $1
                  AND (p.user_id = $2 OR p.is_public = true OR pc.user_id = $2)
                ORDER BY pi.position ASC
                LIMIT $3 OFFSET $4
        `

        rows, err := s.db.QueryContext(ctx, query, playlistID, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get playlist items", zap.Error(err))
                return nil, fmt.Errorf("failed to get playlist items: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var items []PlaylistItem
        for rows.Next() </span><span class="cov0" title="0">{
                var item PlaylistItem
                err := rows.Scan(
                        &amp;item.ID, &amp;item.PlaylistID, &amp;item.MediaItemID, &amp;item.Position,
                        &amp;item.AddedBy, &amp;item.AddedAt, &amp;item.CustomTitle, &amp;item.StartTime, &amp;item.EndTime,
                )
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to scan playlist item", zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items, nil</span>
}

func (s *PlaylistService) RefreshSmartPlaylist(ctx context.Context, playlistID int64) error <span class="cov0" title="0">{
        s.logger.Info("Refreshing smart playlist", zap.Int64("playlist_id", playlistID))

        playlist, err := s.GetPlaylist(ctx, playlistID, 0)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get playlist: %w", err)
        }</span>

        <span class="cov0" title="0">if !playlist.IsSmartPlaylist </span><span class="cov0" title="0">{
                return fmt.Errorf("playlist is not a smart playlist")
        }</span>

        <span class="cov0" title="0">var criteria SmartPlaylistCriteria
        if err := json.Unmarshal([]byte(playlist.SmartCriteria), &amp;criteria); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse smart criteria: %w", err)
        }</span>

        <span class="cov0" title="0">query, args := s.buildSmartPlaylistQuery(&amp;criteria)

        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        _, err = tx.ExecContext(ctx, "DELETE FROM playlist_items WHERE playlist_id = $1", playlistID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear playlist: %w", err)
        }</span>

        <span class="cov0" title="0">rows, err := tx.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute smart query: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        position := 1
        for rows.Next() </span><span class="cov0" title="0">{
                var mediaItemID int64
                err := rows.Scan(&amp;mediaItemID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">_, err = tx.ExecContext(ctx, `
                        INSERT INTO playlist_items (playlist_id, media_item_id, position, added_by, added_at)
                        VALUES ($1, $2, $3, $4, NOW())
                `, playlistID, mediaItemID, position, playlist.UserID)

                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to add smart playlist item", zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">position++</span>
        }

        <span class="cov0" title="0">if err := s.updatePlaylistStats(ctx, tx, playlistID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update playlist stats: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaylistService) CreateQueue(ctx context.Context, userID int64, name string) (*PlaybackQueue, error) <span class="cov0" title="0">{
        s.logger.Info("Creating playback queue",
                zap.Int64("user_id", userID),
                zap.String("name", name))

        query := `
                INSERT INTO playback_queues (user_id, name, current_position, shuffle_enabled, repeat_mode, created_at, updated_at)
                VALUES ($1, $2, 0, false, 'none', NOW(), NOW())
                RETURNING id, created_at, updated_at
        `

        var queue PlaybackQueue
        err := s.db.QueryRowContext(ctx, query, userID, name).Scan(
                &amp;queue.ID, &amp;queue.CreatedAt, &amp;queue.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create queue", zap.Error(err))
                return nil, fmt.Errorf("failed to create queue: %w", err)
        }</span>

        <span class="cov0" title="0">queue.UserID = userID
        queue.Name = name
        queue.CurrentPosition = 0
        queue.ShuffleEnabled = false
        queue.RepeatMode = "none"

        return &amp;queue, nil</span>
}

func (s *PlaylistService) AddToQueue(ctx context.Context, queueID int64, mediaItemIDs []int64) error <span class="cov0" title="0">{
        s.logger.Info("Adding items to queue",
                zap.Int64("queue_id", queueID),
                zap.Int("item_count", len(mediaItemIDs)))

        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        var position int
        err = tx.QueryRowContext(ctx,
                "SELECT COALESCE(MAX(position), 0) + 1 FROM queue_items WHERE queue_id = $1",
                queueID).Scan(&amp;position)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get next position: %w", err)
        }</span>

        <span class="cov0" title="0">for i, mediaItemID := range mediaItemIDs </span><span class="cov0" title="0">{
                _, err := tx.ExecContext(ctx, `
                        INSERT INTO queue_items (queue_id, media_item_id, position, original_position, play_count, added_at)
                        VALUES ($1, $2, $3, $4, 0, NOW())
                `, queueID, mediaItemID, position+i, position+i)

                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to add item to queue", zap.Error(err))
                        return fmt.Errorf("failed to add item to queue: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaylistService) ShuffleQueue(ctx context.Context, queueID int64, enabled bool) error <span class="cov0" title="0">{
        s.logger.Info("Setting queue shuffle",
                zap.Int64("queue_id", queueID),
                zap.Bool("enabled", enabled))

        _, err := s.db.ExecContext(ctx,
                "UPDATE playback_queues SET shuffle_enabled = $1, updated_at = NOW() WHERE id = $2",
                enabled, queueID)

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update queue shuffle", zap.Error(err))
                return fmt.Errorf("failed to update queue shuffle: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaylistService) canModifyPlaylist(ctx context.Context, playlistID, userID int64) bool <span class="cov0" title="0">{
        var count int
        query := `
                SELECT COUNT(*)
                FROM playlists p
                LEFT JOIN playlist_collaborators pc ON p.id = pc.playlist_id
                WHERE p.id = $1 AND (p.user_id = $2 OR pc.user_id = $2)
        `

        err := s.db.QueryRowContext(ctx, query, playlistID, userID).Scan(&amp;count)
        return err == nil &amp;&amp; count &gt; 0
}</span>

func (s *PlaylistService) updatePlaylistStats(ctx context.Context, tx *sql.Tx, playlistID int64) error <span class="cov0" title="0">{
        query := `
                UPDATE playlists
                SET track_count = (
                                SELECT COUNT(*) FROM playlist_items WHERE playlist_id = $1
                        ),
                        total_duration = (
                                SELECT COALESCE(SUM(mi.duration), 0)
                                FROM playlist_items pi
                                JOIN media_items mi ON pi.media_item_id = mi.id
                                WHERE pi.playlist_id = $1
                        ),
                        updated_at = NOW()
                WHERE id = $1
        `

        _, err := tx.ExecContext(ctx, query, playlistID)
        return err
}</span>

func (s *PlaylistService) updatePlaylistTags(ctx context.Context, playlistID int64, tags []string) error <span class="cov0" title="0">{
        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        _, err = tx.ExecContext(ctx, "DELETE FROM playlist_tags WHERE playlist_id = $1", playlistID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, tag := range tags </span><span class="cov0" title="0">{
                _, err = tx.ExecContext(ctx,
                        "INSERT INTO playlist_tags (playlist_id, tag) VALUES ($1, $2)",
                        playlistID, tag)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit()</span>
}

func (s *PlaylistService) updatePlaylistCollaborators(ctx context.Context, playlistID int64, collaboratorIDs []int64) error <span class="cov0" title="0">{
        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        _, err = tx.ExecContext(ctx, "DELETE FROM playlist_collaborators WHERE playlist_id = $1", playlistID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, userID := range collaboratorIDs </span><span class="cov0" title="0">{
                _, err = tx.ExecContext(ctx,
                        "INSERT INTO playlist_collaborators (playlist_id, user_id, added_at) VALUES ($1, $2, NOW())",
                        playlistID, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit()</span>
}

func (s *PlaylistService) getPlaylistTags(ctx context.Context, playlistID int64) ([]string, error) <span class="cov0" title="0">{
        rows, err := s.db.QueryContext(ctx,
                "SELECT tag FROM playlist_tags WHERE playlist_id = $1", playlistID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tags []string
        for rows.Next() </span><span class="cov0" title="0">{
                var tag string
                if err := rows.Scan(&amp;tag); err == nil </span><span class="cov0" title="0">{
                        tags = append(tags, tag)
                }</span>
        }
        <span class="cov0" title="0">return tags, nil</span>
}

func (s *PlaylistService) getPlaylistCollaborators(ctx context.Context, playlistID int64) ([]int64, error) <span class="cov0" title="0">{
        rows, err := s.db.QueryContext(ctx,
                "SELECT user_id FROM playlist_collaborators WHERE playlist_id = $1", playlistID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var collaborators []int64
        for rows.Next() </span><span class="cov0" title="0">{
                var userID int64
                if err := rows.Scan(&amp;userID); err == nil </span><span class="cov0" title="0">{
                        collaborators = append(collaborators, userID)
                }</span>
        }
        <span class="cov0" title="0">return collaborators, nil</span>
}

func (s *PlaylistService) buildSmartPlaylistQuery(criteria *SmartPlaylistCriteria) (string, []interface{}) <span class="cov0" title="0">{
        baseQuery := "SELECT DISTINCT mi.id FROM media_items mi WHERE "
        var conditions []string
        var args []interface{}
        argIndex := 1

        logic := "AND"
        if criteria.Logic == "OR" </span><span class="cov0" title="0">{
                logic = "OR"
        }</span>

        <span class="cov0" title="0">for _, rule := range criteria.Rules </span><span class="cov0" title="0">{
                condition, ruleArgs := s.buildRuleCondition(rule, &amp;argIndex)
                if condition != "" </span><span class="cov0" title="0">{
                        conditions = append(conditions, condition)
                        args = append(args, ruleArgs...)
                }</span>
        }

        <span class="cov0" title="0">if len(conditions) == 0 </span><span class="cov0" title="0">{
                return "SELECT id FROM media_items LIMIT 0", []interface{}{}
        }</span>

        <span class="cov0" title="0">query := baseQuery + "(" + strings.Join(conditions, " "+logic+" ") + ")"

        if criteria.Order != "" </span><span class="cov0" title="0">{
                query += " ORDER BY " + s.getOrderClause(criteria.Order)
        }</span>

        <span class="cov0" title="0">if criteria.Limit &gt; 0 </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" LIMIT %d", criteria.Limit)
        }</span>

        <span class="cov0" title="0">return query, args</span>
}

func (s *PlaylistService) buildRuleCondition(rule SmartRule, argIndex *int) (string, []interface{}) <span class="cov0" title="0">{
        var condition string
        var args []interface{}

        switch rule.Field </span>{
        case "genre":<span class="cov0" title="0">
                if rule.Operator == "equals" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.genre = $%d", *argIndex)
                        args = append(args, rule.Value)
                        *argIndex++
                }</span> else<span class="cov0" title="0"> if rule.Operator == "contains" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.genre ILIKE $%d", *argIndex)
                        args = append(args, "%"+rule.Value.(string)+"%")
                        *argIndex++
                }</span>
        case "artist":<span class="cov0" title="0">
                if rule.Operator == "equals" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.artist = $%d", *argIndex)
                        args = append(args, rule.Value)
                        *argIndex++
                }</span> else<span class="cov0" title="0"> if rule.Operator == "contains" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.artist ILIKE $%d", *argIndex)
                        args = append(args, "%"+rule.Value.(string)+"%")
                        *argIndex++
                }</span>
        case "year":<span class="cov0" title="0">
                if rule.Operator == "equals" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.year = $%d", *argIndex)
                        args = append(args, rule.Value)
                        *argIndex++
                }</span> else<span class="cov0" title="0"> if rule.Operator == "greater_than" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.year &gt; $%d", *argIndex)
                        args = append(args, rule.Value)
                        *argIndex++
                }</span> else<span class="cov0" title="0"> if rule.Operator == "less_than" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.year &lt; $%d", *argIndex)
                        args = append(args, rule.Value)
                        *argIndex++
                }</span>
        case "rating":<span class="cov0" title="0">
                if rule.Operator == "greater_than" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.rating &gt; $%d", *argIndex)
                        args = append(args, rule.Value)
                        *argIndex++
                }</span>
        }

        <span class="cov0" title="0">return condition, args</span>
}

func (s *PlaylistService) getOrderClause(order string) string <span class="cov0" title="0">{
        switch order </span>{
        case "added_desc":<span class="cov0" title="0">
                return "mi.created_at DESC"</span>
        case "added_asc":<span class="cov0" title="0">
                return "mi.created_at ASC"</span>
        case "play_count_desc":<span class="cov0" title="0">
                return "mi.play_count DESC"</span>
        case "rating_desc":<span class="cov0" title="0">
                return "mi.rating DESC"</span>
        case "random":<span class="cov0" title="0">
                return "RANDOM()"</span>
        case "title_asc":<span class="cov0" title="0">
                return "mi.title ASC"</span>
        case "artist_asc":<span class="cov0" title="0">
                return "mi.artist ASC, mi.album ASC, mi.track_number ASC"</span>
        default:<span class="cov0" title="0">
                return "mi.created_at DESC"</span>
        }
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package services

import (
        "catalogizer/filesystem"
        "context"
        "crypto/md5"
        "fmt"
        "path/filepath"
        "strings"
        "time"

        "go.uber.org/zap"
)

// LocalProtocolHandler handles rename detection for local filesystem
type LocalProtocolHandler struct {
        logger *zap.Logger
}

func NewLocalProtocolHandler(logger *zap.Logger) *LocalProtocolHandler <span class="cov0" title="0">{
        return &amp;LocalProtocolHandler{logger: logger}
}</span>

func (h *LocalProtocolHandler) GetFileIdentifier(ctx context.Context, path string, size int64, isDir bool) (string, error) <span class="cov0" title="0">{
        // For local filesystem, use inode information if available
        // Fallback to path + size + modification time
        return fmt.Sprintf("local:%s:%d:%t", path, size, isDir), nil
}</span>

func (h *LocalProtocolHandler) PerformMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string, isDir bool) error <span class="cov0" title="0">{
        // Local filesystem moves are handled by the OS file system watcher
        // No explicit move operation needed here
        return nil
}</span>

func (h *LocalProtocolHandler) ValidateMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        // Basic validation - ensure paths are different and target doesn't exist
        if oldPath == newPath </span><span class="cov0" title="0">{
                return fmt.Errorf("source and destination paths are the same")
        }</span>

        <span class="cov0" title="0">exists, err := client.FileExists(ctx, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if destination exists: %w", err)
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("destination path already exists: %s", newPath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *LocalProtocolHandler) GetMoveWindow() time.Duration <span class="cov0" title="0">{
        // Local filesystem operations are very fast
        return 2 * time.Second
}</span>

func (h *LocalProtocolHandler) SupportsRealTimeNotification() bool <span class="cov0" title="0">{
        return true // Local filesystem supports inotify/fsnotify
}</span>

// SMBProtocolHandler handles rename detection for SMB protocol
type SMBProtocolHandler struct {
        logger *zap.Logger
}

func NewSMBProtocolHandler(logger *zap.Logger) *SMBProtocolHandler <span class="cov0" title="0">{
        return &amp;SMBProtocolHandler{logger: logger}
}</span>

func (h *SMBProtocolHandler) GetFileIdentifier(ctx context.Context, path string, size int64, isDir bool) (string, error) <span class="cov0" title="0">{
        // For SMB, use file path, size, and directory flag
        // SMB doesn't have reliable inode-like identifiers across all implementations
        return fmt.Sprintf("smb:%s:%d:%t", path, size, isDir), nil
}</span>

func (h *SMBProtocolHandler) PerformMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string, isDir bool) error <span class="cov0" title="0">{
        // For SMB, perform copy + delete since not all SMB servers support native move
        if isDir </span><span class="cov0" title="0">{
                return h.moveDirectory(ctx, client, oldPath, newPath)
        }</span>
        <span class="cov0" title="0">return h.moveFile(ctx, client, oldPath, newPath)</span>
}

func (h *SMBProtocolHandler) moveFile(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        // Copy file content
        if err := client.CopyFile(ctx, oldPath, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        // Delete original file
        <span class="cov0" title="0">if err := client.DeleteFile(ctx, oldPath); err != nil </span><span class="cov0" title="0">{
                // Attempt to clean up the copy if deletion fails
                client.DeleteFile(ctx, newPath)
                return fmt.Errorf("failed to delete original file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *SMBProtocolHandler) moveDirectory(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        // List directory contents
        files, err := client.ListDirectory(ctx, oldPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list directory contents: %w", err)
        }</span>

        // Create destination directory
        <span class="cov0" title="0">if err := client.CreateDirectory(ctx, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Move each file/subdirectory
        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                oldItemPath := filepath.Join(oldPath, file.Name)
                newItemPath := filepath.Join(newPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        if err := h.moveDirectory(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to move subdirectory %s: %w", file.Name, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := h.moveFile(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to move file %s: %w", file.Name, err)
                        }</span>
                }
        }

        // Delete original directory
        <span class="cov0" title="0">if err := client.DeleteDirectory(ctx, oldPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete original directory: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *SMBProtocolHandler) ValidateMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if oldPath == newPath </span><span class="cov0" title="0">{
                return fmt.Errorf("source and destination paths are the same")
        }</span>

        <span class="cov0" title="0">exists, err := client.FileExists(ctx, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if destination exists: %w", err)
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("destination path already exists: %s", newPath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *SMBProtocolHandler) GetMoveWindow() time.Duration <span class="cov0" title="0">{
        // SMB operations can be slower, especially over network
        return 10 * time.Second
}</span>

func (h *SMBProtocolHandler) SupportsRealTimeNotification() bool <span class="cov0" title="0">{
        return false // SMB typically uses polling for change detection
}</span>

// FTPProtocolHandler handles rename detection for FTP protocol
type FTPProtocolHandler struct {
        logger *zap.Logger
}

func NewFTPProtocolHandler(logger *zap.Logger) *FTPProtocolHandler <span class="cov0" title="0">{
        return &amp;FTPProtocolHandler{logger: logger}
}</span>

func (h *FTPProtocolHandler) GetFileIdentifier(ctx context.Context, path string, size int64, isDir bool) (string, error) <span class="cov0" title="0">{
        // For FTP, use path + size + directory flag
        // Some FTP servers provide modification time which could be added
        return fmt.Sprintf("ftp:%s:%d:%t", path, size, isDir), nil
}</span>

func (h *FTPProtocolHandler) PerformMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string, isDir bool) error <span class="cov0" title="0">{
        // FTP doesn't typically support atomic moves, so use copy + delete
        if isDir </span><span class="cov0" title="0">{
                return h.moveDirectory(ctx, client, oldPath, newPath)
        }</span>
        <span class="cov0" title="0">return h.moveFile(ctx, client, oldPath, newPath)</span>
}

func (h *FTPProtocolHandler) moveFile(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if err := client.CopyFile(ctx, oldPath, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file via FTP: %w", err)
        }</span>

        <span class="cov0" title="0">if err := client.DeleteFile(ctx, oldPath); err != nil </span><span class="cov0" title="0">{
                client.DeleteFile(ctx, newPath) // Cleanup on failure
                return fmt.Errorf("failed to delete original file via FTP: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *FTPProtocolHandler) moveDirectory(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        files, err := client.ListDirectory(ctx, oldPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list FTP directory: %w", err)
        }</span>

        <span class="cov0" title="0">if err := client.CreateDirectory(ctx, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create FTP directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                oldItemPath := filepath.Join(oldPath, file.Name)
                newItemPath := filepath.Join(newPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        if err := h.moveDirectory(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := h.moveFile(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return client.DeleteDirectory(ctx, oldPath)</span>
}

func (h *FTPProtocolHandler) ValidateMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if oldPath == newPath </span><span class="cov0" title="0">{
                return fmt.Errorf("source and destination paths are the same")
        }</span>

        <span class="cov0" title="0">exists, err := client.FileExists(ctx, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check FTP destination: %w", err)
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("FTP destination already exists: %s", newPath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *FTPProtocolHandler) GetMoveWindow() time.Duration <span class="cov0" title="0">{
        // FTP operations can be slow, especially for large files
        return 30 * time.Second
}</span>

func (h *FTPProtocolHandler) SupportsRealTimeNotification() bool <span class="cov0" title="0">{
        return false // FTP requires polling
}</span>

// NFSProtocolHandler handles rename detection for NFS protocol
type NFSProtocolHandler struct {
        logger *zap.Logger
}

func NewNFSProtocolHandler(logger *zap.Logger) *NFSProtocolHandler <span class="cov0" title="0">{
        return &amp;NFSProtocolHandler{logger: logger}
}</span>

func (h *NFSProtocolHandler) GetFileIdentifier(ctx context.Context, path string, size int64, isDir bool) (string, error) <span class="cov0" title="0">{
        // NFS can potentially provide inode information
        // For now, use path + size + directory flag
        return fmt.Sprintf("nfs:%s:%d:%t", path, size, isDir), nil
}</span>

func (h *NFSProtocolHandler) PerformMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string, isDir bool) error <span class="cov0" title="0">{
        // NFS supports native rename operations in most cases
        // For simplicity, use copy + delete approach
        if isDir </span><span class="cov0" title="0">{
                return h.moveDirectory(ctx, client, oldPath, newPath)
        }</span>
        <span class="cov0" title="0">return h.moveFile(ctx, client, oldPath, newPath)</span>
}

func (h *NFSProtocolHandler) moveFile(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if err := client.CopyFile(ctx, oldPath, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file via NFS: %w", err)
        }</span>

        <span class="cov0" title="0">if err := client.DeleteFile(ctx, oldPath); err != nil </span><span class="cov0" title="0">{
                client.DeleteFile(ctx, newPath)
                return fmt.Errorf("failed to delete original file via NFS: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *NFSProtocolHandler) moveDirectory(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        files, err := client.ListDirectory(ctx, oldPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list NFS directory: %w", err)
        }</span>

        <span class="cov0" title="0">if err := client.CreateDirectory(ctx, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create NFS directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                oldItemPath := filepath.Join(oldPath, file.Name)
                newItemPath := filepath.Join(newPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        if err := h.moveDirectory(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := h.moveFile(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return client.DeleteDirectory(ctx, oldPath)</span>
}

func (h *NFSProtocolHandler) ValidateMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if oldPath == newPath </span><span class="cov0" title="0">{
                return fmt.Errorf("source and destination paths are the same")
        }</span>

        <span class="cov0" title="0">exists, err := client.FileExists(ctx, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check NFS destination: %w", err)
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("NFS destination already exists: %s", newPath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *NFSProtocolHandler) GetMoveWindow() time.Duration <span class="cov0" title="0">{
        // NFS operations are generally fast
        return 5 * time.Second
}</span>

func (h *NFSProtocolHandler) SupportsRealTimeNotification() bool <span class="cov0" title="0">{
        // NFS can support inotify if mounted locally, but generally uses polling
        return false
}</span>

// WebDAVProtocolHandler handles rename detection for WebDAV protocol
type WebDAVProtocolHandler struct {
        logger *zap.Logger
}

func NewWebDAVProtocolHandler(logger *zap.Logger) *WebDAVProtocolHandler <span class="cov0" title="0">{
        return &amp;WebDAVProtocolHandler{logger: logger}
}</span>

func (h *WebDAVProtocolHandler) GetFileIdentifier(ctx context.Context, path string, size int64, isDir bool) (string, error) <span class="cov0" title="0">{
        // WebDAV can provide ETags for some servers
        // For now, use path + size + directory flag
        pathHash := h.hashString(path)
        return fmt.Sprintf("webdav:%s:%d:%t", pathHash, size, isDir), nil
}</span>

func (h *WebDAVProtocolHandler) hashString(s string) string <span class="cov0" title="0">{
        hash := md5.Sum([]byte(s))
        return fmt.Sprintf("%x", hash)
}</span>

func (h *WebDAVProtocolHandler) PerformMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string, isDir bool) error <span class="cov0" title="0">{
        // WebDAV supports MOVE method, but not all implementations support it
        // Use copy + delete as fallback
        if isDir </span><span class="cov0" title="0">{
                return h.moveDirectory(ctx, client, oldPath, newPath)
        }</span>
        <span class="cov0" title="0">return h.moveFile(ctx, client, oldPath, newPath)</span>
}

func (h *WebDAVProtocolHandler) moveFile(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if err := client.CopyFile(ctx, oldPath, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file via WebDAV: %w", err)
        }</span>

        <span class="cov0" title="0">if err := client.DeleteFile(ctx, oldPath); err != nil </span><span class="cov0" title="0">{
                client.DeleteFile(ctx, newPath)
                return fmt.Errorf("failed to delete original file via WebDAV: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *WebDAVProtocolHandler) moveDirectory(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        files, err := client.ListDirectory(ctx, oldPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list WebDAV directory: %w", err)
        }</span>

        <span class="cov0" title="0">if err := client.CreateDirectory(ctx, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create WebDAV directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                oldItemPath := filepath.Join(oldPath, file.Name)
                newItemPath := filepath.Join(newPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        if err := h.moveDirectory(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := h.moveFile(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return client.DeleteDirectory(ctx, oldPath)</span>
}

func (h *WebDAVProtocolHandler) ValidateMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if oldPath == newPath </span><span class="cov0" title="0">{
                return fmt.Errorf("source and destination paths are the same")
        }</span>

        <span class="cov0" title="0">exists, err := client.FileExists(ctx, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check WebDAV destination: %w", err)
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV destination already exists: %s", newPath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *WebDAVProtocolHandler) GetMoveWindow() time.Duration <span class="cov0" title="0">{
        // WebDAV operations depend on network latency
        return 15 * time.Second
}</span>

func (h *WebDAVProtocolHandler) SupportsRealTimeNotification() bool <span class="cov0" title="0">{
        return false // WebDAV requires polling
}</span>

// ProtocolHandlerFactory creates protocol handlers based on configuration
type ProtocolHandlerFactory struct {
        logger *zap.Logger
}

func NewProtocolHandlerFactory(logger *zap.Logger) *ProtocolHandlerFactory <span class="cov0" title="0">{
        return &amp;ProtocolHandlerFactory{logger: logger}
}</span>

func (f *ProtocolHandlerFactory) CreateHandler(protocol string) (ProtocolHandler, error) <span class="cov0" title="0">{
        switch strings.ToLower(protocol) </span>{
        case "local":<span class="cov0" title="0">
                return NewLocalProtocolHandler(f.logger), nil</span>
        case "smb":<span class="cov0" title="0">
                return NewSMBProtocolHandler(f.logger), nil</span>
        case "ftp":<span class="cov0" title="0">
                return NewFTPProtocolHandler(f.logger), nil</span>
        case "nfs":<span class="cov0" title="0">
                return NewNFSProtocolHandler(f.logger), nil</span>
        case "webdav":<span class="cov0" title="0">
                return NewWebDAVProtocolHandler(f.logger), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported protocol: %s", protocol)</span>
        }
}

func (f *ProtocolHandlerFactory) GetSupportedProtocols() []string <span class="cov0" title="0">{
        return []string{"local", "smb", "ftp", "nfs", "webdav"}
}</span>

// ProtocolCapabilities provides information about protocol capabilities
type ProtocolCapabilities struct {
        Protocol                     string        `json:"protocol"`
        SupportsRealTimeNotification bool          `json:"supports_realtime_notification"`
        MoveWindow                   time.Duration `json:"move_window"`
        SupportsAtomicMove           bool          `json:"supports_atomic_move"`
        RequiresPolling              bool          `json:"requires_polling"`
}

func GetProtocolCapabilities(protocol string, logger *zap.Logger) (*ProtocolCapabilities, error) <span class="cov0" title="0">{
        factory := NewProtocolHandlerFactory(logger)
        handler, err := factory.CreateHandler(protocol)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ProtocolCapabilities{
                Protocol:                     protocol,
                SupportsRealTimeNotification: handler.SupportsRealTimeNotification(),
                MoveWindow:                   handler.GetMoveWindow(),
                SupportsAtomicMove:           protocol == "local" || protocol == "nfs",
                RequiresPolling:              !handler.SupportsRealTimeNotification(),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "go.uber.org/zap"
)

// Advanced reader service with Kindle/Moon Reader Pro-like experience
type ReaderService struct {
        db                  *sql.DB
        logger              *zap.Logger
        cacheService        *CacheService
        translationService  *TranslationService
        localizationService *LocalizationService
}

// Reading session structure
type ReadingSession struct {
        ID              string          `json:"id"`
        UserID          int64           `json:"user_id"`
        BookID          string          `json:"book_id"`
        DeviceID        string          `json:"device_id"`
        DeviceName      string          `json:"device_name"`
        StartedAt       time.Time       `json:"started_at"`
        LastActiveAt    time.Time       `json:"last_active_at"`
        CurrentPosition ReadingPosition `json:"current_position"`
        ReadingSettings ReadingSettings `json:"reading_settings"`
        SyncStatus      SyncStatus      `json:"sync_status"`
        ReadingStats    ReadingStats    `json:"reading_stats"`
        IsActive        bool            `json:"is_active"`
}

// Reading position with multiple granularities
type ReadingPosition struct {
        BookID          string          `json:"book_id"`
        ChapterID       string          `json:"chapter_id,omitempty"`
        PageNumber      int             `json:"page_number"`
        WordOffset      int             `json:"word_offset"`
        CharacterOffset int             `json:"character_offset"`
        PercentComplete float64         `json:"percent_complete"`
        Location        string          `json:"location,omitempty"` // Kindle location equivalent
        CFI             string          `json:"cfi,omitempty"`      // EPUB Canonical Fragment Identifier
        Timestamp       time.Time       `json:"timestamp"`
        PositionContext PositionContext `json:"position_context"`
        Confidence      float64         `json:"confidence"`
}

type PositionContext struct {
        SurroundingText string `json:"surrounding_text"`
        ParagraphStart  string `json:"paragraph_start"`
        SentenceStart   string `json:"sentence_start"`
        ChapterTitle    string `json:"chapter_title,omitempty"`
        SectionTitle    string `json:"section_title,omitempty"`
}

// Reading settings for personalization
type ReadingSettings struct {
        FontFamily      string                `json:"font_family"`
        FontSize        int                   `json:"font_size"`
        LineHeight      float64               `json:"line_height"`
        TextAlign       string                `json:"text_align"`
        Theme           string                `json:"theme"`
        BackgroundColor string                `json:"background_color"`
        TextColor       string                `json:"text_color"`
        PageMargins     PageMargins           `json:"page_margins"`
        ColumnsPerPage  int                   `json:"columns_per_page"`
        PageTransition  string                `json:"page_transition"`
        AutoScroll      bool                  `json:"auto_scroll"`
        AutoScrollSpeed int                   `json:"auto_scroll_speed"`
        ReadingMode     string                `json:"reading_mode"` // day, night, sepia, etc.
        Brightness      float64               `json:"brightness"`
        BlueLight       BlueLightFilter       `json:"blue_light_filter"`
        Hyphenation     bool                  `json:"hyphenation"`
        Justification   bool                  `json:"justification"`
        StatusBar       StatusBarSettings     `json:"status_bar"`
        Gestures        GestureSettings       `json:"gestures"`
        Accessibility   AccessibilitySettings `json:"accessibility"`
}

type PageMargins struct {
        Top    int `json:"top"`
        Bottom int `json:"bottom"`
        Left   int `json:"left"`
        Right  int `json:"right"`
}

type BlueLightFilter struct {
        Enabled      bool    `json:"enabled"`
        Intensity    float64 `json:"intensity"`
        AutoSchedule bool    `json:"auto_schedule"`
        StartTime    string  `json:"start_time"`
        EndTime      string  `json:"end_time"`
}

type StatusBarSettings struct {
        Visible        bool   `json:"visible"`
        ShowProgress   bool   `json:"show_progress"`
        ShowTime       bool   `json:"show_time"`
        ShowBattery    bool   `json:"show_battery"`
        ShowPageNumber bool   `json:"show_page_number"`
        Position       string `json:"position"`
}

type GestureSettings struct {
        TapToTurn        bool     `json:"tap_to_turn"`
        SwipeToTurn      bool     `json:"swipe_to_turn"`
        VolumeKeys       bool     `json:"volume_keys"`
        TapZones         TapZones `json:"tap_zones"`
        SwipeSensitivity float64  `json:"swipe_sensitivity"`
}

type TapZones struct {
        LeftTurn   bool `json:"left_turn"`
        RightTurn  bool `json:"right_turn"`
        CenterMenu bool `json:"center_menu"`
}

type AccessibilitySettings struct {
        TextToSpeech    TTSSettings `json:"text_to_speech"`
        HighContrast    bool        `json:"high_contrast"`
        LargeText       bool        `json:"large_text"`
        ScreenReader    bool        `json:"screen_reader"`
        VoiceNavigation bool        `json:"voice_navigation"`
}

type TTSSettings struct {
        Enabled       bool    `json:"enabled"`
        Voice         string  `json:"voice"`
        Speed         float64 `json:"speed"`
        Pitch         float64 `json:"pitch"`
        AutoPlay      bool    `json:"auto_play"`
        HighlightText bool    `json:"highlight_text"`
}

// Sync status for cross-device reading
type SyncStatus struct {
        LastSyncAt      time.Time      `json:"last_sync_at"`
        IsSynced        bool           `json:"is_synced"`
        ConflictExists  bool           `json:"conflict_exists"`
        ConflictDetails []SyncConflict `json:"conflict_details,omitempty"`
        SyncVersion     int64          `json:"sync_version"`
}

type SyncConflict struct {
        DeviceID     string          `json:"device_id"`
        DeviceName   string          `json:"device_name"`
        Position     ReadingPosition `json:"position"`
        Timestamp    time.Time       `json:"timestamp"`
        ConflictType string          `json:"conflict_type"`
}

// Reading statistics and analytics
type ReadingStats struct {
        TotalReadingTime int64               `json:"total_reading_time_seconds"`
        SessionTime      int64               `json:"session_time_seconds"`
        PagesRead        int                 `json:"pages_read"`
        WordsRead        int                 `json:"words_read"`
        ReadingSpeed     float64             `json:"reading_speed_wpm"`
        AverageSpeed     float64             `json:"average_speed_wpm"`
        DailyGoal        int                 `json:"daily_goal_minutes"`
        DailyProgress    int                 `json:"daily_progress_minutes"`
        WeeklyStats      WeeklyReadingStats  `json:"weekly_stats"`
        MonthlyStats     MonthlyReadingStats `json:"monthly_stats"`
        ReadingStreak    int                 `json:"reading_streak_days"`
        LongestStreak    int                 `json:"longest_streak_days"`
        BooksCompleted   int                 `json:"books_completed"`
        PagesPerSession  float64             `json:"pages_per_session"`
}

type WeeklyReadingStats struct {
        Week          string `json:"week"`
        TotalTime     int64  `json:"total_time_seconds"`
        PagesRead     int    `json:"pages_read"`
        SessionsCount int    `json:"sessions_count"`
        DaysActive    int    `json:"days_active"`
}

type MonthlyReadingStats struct {
        Month          string  `json:"month"`
        TotalTime      int64   `json:"total_time_seconds"`
        PagesRead      int     `json:"pages_read"`
        BooksCompleted int     `json:"books_completed"`
        AverageDaily   float64 `json:"average_daily_minutes"`
}

// Bookmarks and annotations
type Bookmark struct {
        ID        string          `json:"id"`
        UserID    int64           `json:"user_id"`
        BookID    string          `json:"book_id"`
        Position  ReadingPosition `json:"position"`
        Title     string          `json:"title"`
        Note      string          `json:"note,omitempty"`
        Tags      []string        `json:"tags,omitempty"`
        Color     string          `json:"color,omitempty"`
        CreatedAt time.Time       `json:"created_at"`
        UpdatedAt time.Time       `json:"updated_at"`
        IsPublic  bool            `json:"is_public"`
        ShareURL  string          `json:"share_url,omitempty"`
}

type Highlight struct {
        ID            string          `json:"id"`
        UserID        int64           `json:"user_id"`
        BookID        string          `json:"book_id"`
        StartPosition ReadingPosition `json:"start_position"`
        EndPosition   ReadingPosition `json:"end_position"`
        SelectedText  string          `json:"selected_text"`
        Note          string          `json:"note,omitempty"`
        Color         string          `json:"color"`
        Type          string          `json:"type"` // highlight, underline, strikethrough
        Tags          []string        `json:"tags,omitempty"`
        CreatedAt     time.Time       `json:"created_at"`
        UpdatedAt     time.Time       `json:"updated_at"`
        IsPublic      bool            `json:"is_public"`
        ShareURL      string          `json:"share_url,omitempty"`
}

type Annotation struct {
        ID          string          `json:"id"`
        UserID      int64           `json:"user_id"`
        BookID      string          `json:"book_id"`
        Position    ReadingPosition `json:"position"`
        Type        string          `json:"type"` // note, drawing, voice, image
        Content     string          `json:"content"`
        ContentType string          `json:"content_type"`
        ContentURL  string          `json:"content_url,omitempty"`
        Tags        []string        `json:"tags,omitempty"`
        CreatedAt   time.Time       `json:"created_at"`
        UpdatedAt   time.Time       `json:"updated_at"`
        IsPublic    bool            `json:"is_public"`
        ShareURL    string          `json:"share_url,omitempty"`
}

// Reading requests and responses
type StartReadingRequest struct {
        UserID                 int64            `json:"user_id"`
        BookID                 string           `json:"book_id"`
        DeviceInfo             DeviceInfo       `json:"device_info"`
        ReadingSettings        *ReadingSettings `json:"reading_settings,omitempty"`
        ResumeFromLastPosition bool             `json:"resume_from_last_position"`
}

type ReaderUpdatePositionRequest struct {
        SessionID   string          `json:"session_id"`
        Position    ReadingPosition `json:"position"`
        ReadingTime int64           `json:"reading_time_seconds"`
        PagesRead   int             `json:"pages_read"`
        WordsRead   int             `json:"words_read"`
        AutoSync    bool            `json:"auto_sync"`
}

type CreateBookmarkRequest struct {
        UserID   int64           `json:"user_id"`
        BookID   string          `json:"book_id"`
        Position ReadingPosition `json:"position"`
        Title    string          `json:"title"`
        Note     string          `json:"note,omitempty"`
        Tags     []string        `json:"tags,omitempty"`
        Color    string          `json:"color,omitempty"`
        IsPublic bool            `json:"is_public"`
}

type CreateHighlightRequest struct {
        UserID        int64           `json:"user_id"`
        BookID        string          `json:"book_id"`
        StartPosition ReadingPosition `json:"start_position"`
        EndPosition   ReadingPosition `json:"end_position"`
        SelectedText  string          `json:"selected_text"`
        Note          string          `json:"note,omitempty"`
        Color         string          `json:"color"`
        Type          string          `json:"type"`
        Tags          []string        `json:"tags,omitempty"`
        IsPublic      bool            `json:"is_public"`
}

type ReaderDeviceInfo struct {
        DeviceID   string `json:"device_id"`
        DeviceName string `json:"device_name"`
        DeviceType string `json:"device_type"`
        ScreenSize string `json:"screen_size,omitempty"`
        OS         string `json:"os,omitempty"`
        AppVersion string `json:"app_version,omitempty"`
}

// Book content structure for reading
type BookContent struct {
        BookID            string       `json:"book_id"`
        Format            string       `json:"format"` // epub, pdf, mobi, txt
        Chapters          []Chapter    `json:"chapters"`
        TableOfContents   []TOCEntry   `json:"table_of_contents"`
        Metadata          BookMetadata `json:"metadata"`
        TotalPages        int          `json:"total_pages"`
        TotalWords        int          `json:"total_words"`
        EstimatedReadTime int          `json:"estimated_read_time_minutes"`
}

type BookChapter struct {
        ID          string    `json:"id"`
        Title       string    `json:"title"`
        Number      int       `json:"number"`
        Content     string    `json:"content"`
        HTMLContent string    `json:"html_content,omitempty"`
        WordCount   int       `json:"word_count"`
        PageCount   int       `json:"page_count"`
        StartPage   int       `json:"start_page"`
        EndPage     int       `json:"end_page"`
        Sections    []Section `json:"sections,omitempty"`
}

type Section struct {
        ID            string `json:"id"`
        Title         string `json:"title"`
        Content       string `json:"content"`
        Level         int    `json:"level"`
        StartPosition int    `json:"start_position"`
        EndPosition   int    `json:"end_position"`
}

func NewReaderService(
        db *sql.DB,
        logger *zap.Logger,
        cacheService *CacheService,
        translationService *TranslationService,
        localizationService *LocalizationService,
) *ReaderService <span class="cov0" title="0">{
        return &amp;ReaderService{
                db:                  db,
                logger:              logger,
                cacheService:        cacheService,
                translationService:  translationService,
                localizationService: localizationService,
        }
}</span>

// Start a new reading session
func (s *ReaderService) StartReading(ctx context.Context, req *StartReadingRequest) (*ReadingSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting reading session",
                zap.Int64("user_id", req.UserID),
                zap.String("book_id", req.BookID),
                zap.String("device_id", req.DeviceInfo.DeviceID))

        // Generate session ID
        sessionID := s.generateSessionID(req.UserID, req.BookID, req.DeviceInfo.DeviceID)

        // Get last reading position if resuming
        var position ReadingPosition
        if req.ResumeFromLastPosition </span><span class="cov0" title="0">{
                if lastPos, err := s.getLastReadingPosition(ctx, req.UserID, req.BookID); err == nil </span><span class="cov0" title="0">{
                        position = *lastPos
                }</span>
        }

        // Get user's reading settings
        <span class="cov0" title="0">settings := s.getDefaultReadingSettings()
        if req.ReadingSettings != nil </span><span class="cov0" title="0">{
                settings = *req.ReadingSettings
        }</span> else<span class="cov0" title="0"> if userSettings, err := s.getUserReadingSettings(ctx, req.UserID); err == nil </span><span class="cov0" title="0">{
                settings = *userSettings
        }</span>

        // Create reading session
        <span class="cov0" title="0">session := &amp;ReadingSession{
                ID:              sessionID,
                UserID:          req.UserID,
                BookID:          req.BookID,
                DeviceID:        req.DeviceInfo.DeviceID,
                DeviceName:      req.DeviceInfo.DeviceName,
                StartedAt:       time.Now(),
                LastActiveAt:    time.Now(),
                CurrentPosition: position,
                ReadingSettings: settings,
                SyncStatus:      SyncStatus{IsSynced: true, SyncVersion: 1},
                ReadingStats:    s.initializeReadingStats(ctx, req.UserID, req.BookID),
                IsActive:        true,
        }

        // Store session in database
        if err := s.storeReadingSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store reading session: %w", err)
        }</span>

        // Update user's reading history
        <span class="cov0" title="0">s.updateReadingHistory(ctx, req.UserID, req.BookID, time.Now())

        s.logger.Info("Reading session started successfully",
                zap.String("session_id", sessionID),
                zap.Float64("resume_percent", position.PercentComplete))

        return session, nil</span>
}

// Update reading position
func (s *ReaderService) UpdatePosition(ctx context.Context, req *ReaderUpdatePositionRequest) (*ReadingSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Updating reading position",
                zap.String("session_id", req.SessionID),
                zap.Float64("percent_complete", req.Position.PercentComplete))

        // Get current session
        session, err := s.getReadingSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reading session: %w", err)
        }</span>

        // Update position and stats
        <span class="cov0" title="0">session.CurrentPosition = req.Position
        session.LastActiveAt = time.Now()

        // Update reading statistics
        s.updateReadingStats(&amp;session.ReadingStats, req.ReadingTime, req.PagesRead, req.WordsRead)

        // Handle auto-sync if enabled
        if req.AutoSync </span><span class="cov0" title="0">{
                if err := s.syncAcrossDevices(ctx, session); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to sync across devices", zap.Error(err))
                }</span>
        }

        // Store updated session
        <span class="cov0" title="0">if err := s.storeReadingSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update reading session: %w", err)
        }</span>

        // Store position for future resume
        <span class="cov0" title="0">if err := s.storeReadingPosition(ctx, session.UserID, session.BookID, req.Position); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to store reading position", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

// Create a bookmark
func (s *ReaderService) CreateBookmark(ctx context.Context, req *CreateBookmarkRequest) (*Bookmark, error) <span class="cov0" title="0">{
        s.logger.Info("Creating bookmark",
                zap.Int64("user_id", req.UserID),
                zap.String("book_id", req.BookID),
                zap.String("title", req.Title))

        bookmark := &amp;Bookmark{
                ID:        s.generateBookmarkID(req.UserID, req.BookID, req.Position),
                UserID:    req.UserID,
                BookID:    req.BookID,
                Position:  req.Position,
                Title:     req.Title,
                Note:      req.Note,
                Tags:      req.Tags,
                Color:     req.Color,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                IsPublic:  req.IsPublic,
        }

        if req.IsPublic </span><span class="cov0" title="0">{
                bookmark.ShareURL = s.generateShareURL("bookmark", bookmark.ID)
        }</span>

        // Store bookmark
        <span class="cov0" title="0">if err := s.storeBookmark(ctx, bookmark); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store bookmark: %w", err)
        }</span>

        <span class="cov0" title="0">return bookmark, nil</span>
}

// Create a highlight
func (s *ReaderService) CreateHighlight(ctx context.Context, req *CreateHighlightRequest) (*Highlight, error) <span class="cov0" title="0">{
        s.logger.Info("Creating highlight",
                zap.Int64("user_id", req.UserID),
                zap.String("book_id", req.BookID),
                zap.String("text", req.SelectedText[:min(50, len(req.SelectedText))]))

        highlight := &amp;Highlight{
                ID:            s.generateHighlightID(req.UserID, req.BookID, req.StartPosition),
                UserID:        req.UserID,
                BookID:        req.BookID,
                StartPosition: req.StartPosition,
                EndPosition:   req.EndPosition,
                SelectedText:  req.SelectedText,
                Note:          req.Note,
                Color:         req.Color,
                Type:          req.Type,
                Tags:          req.Tags,
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
                IsPublic:      req.IsPublic,
        }

        if req.IsPublic </span><span class="cov0" title="0">{
                highlight.ShareURL = s.generateShareURL("highlight", highlight.ID)
        }</span>

        // Store highlight
        <span class="cov0" title="0">if err := s.storeHighlight(ctx, highlight); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store highlight: %w", err)
        }</span>

        <span class="cov0" title="0">return highlight, nil</span>
}

// Get user's bookmarks for a book
func (s *ReaderService) GetBookmarks(ctx context.Context, userID int64, bookID string) ([]Bookmark, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, book_id, position_data, title, note, tags, color,
                       created_at, updated_at, is_public, share_url
                FROM reading_bookmarks
                WHERE user_id = ? AND book_id = ?
                ORDER BY created_at ASC
        `

        rows, err := s.db.QueryContext(ctx, query, userID, bookID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var bookmarks []Bookmark
        for rows.Next() </span><span class="cov0" title="0">{
                var bookmark Bookmark
                var positionJSON, tagsJSON string
                var shareURL sql.NullString

                err := rows.Scan(
                        &amp;bookmark.ID, &amp;bookmark.UserID, &amp;bookmark.BookID,
                        &amp;positionJSON, &amp;bookmark.Title, &amp;bookmark.Note,
                        &amp;tagsJSON, &amp;bookmark.Color, &amp;bookmark.CreatedAt,
                        &amp;bookmark.UpdatedAt, &amp;bookmark.IsPublic, &amp;shareURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse position JSON
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(positionJSON), &amp;bookmark.Position); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse tags JSON
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(tagsJSON), &amp;bookmark.Tags); err != nil </span><span class="cov0" title="0">{
                        bookmark.Tags = []string{}
                }</span>

                <span class="cov0" title="0">if shareURL.Valid </span><span class="cov0" title="0">{
                        bookmark.ShareURL = shareURL.String
                }</span>

                <span class="cov0" title="0">bookmarks = append(bookmarks, bookmark)</span>
        }

        <span class="cov0" title="0">return bookmarks, nil</span>
}

// Get user's highlights for a book
func (s *ReaderService) GetHighlights(ctx context.Context, userID int64, bookID string) ([]Highlight, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, book_id, start_position_data, end_position_data,
                       selected_text, note, color, type, tags, created_at, updated_at,
                       is_public, share_url
                FROM reading_highlights
                WHERE user_id = ? AND book_id = ?
                ORDER BY start_position_data-&gt;&gt;'$.page_number' ASC
        `

        rows, err := s.db.QueryContext(ctx, query, userID, bookID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var highlights []Highlight
        for rows.Next() </span><span class="cov0" title="0">{
                var highlight Highlight
                var startPosJSON, endPosJSON, tagsJSON string
                var shareURL sql.NullString

                err := rows.Scan(
                        &amp;highlight.ID, &amp;highlight.UserID, &amp;highlight.BookID,
                        &amp;startPosJSON, &amp;endPosJSON, &amp;highlight.SelectedText,
                        &amp;highlight.Note, &amp;highlight.Color, &amp;highlight.Type,
                        &amp;tagsJSON, &amp;highlight.CreatedAt, &amp;highlight.UpdatedAt,
                        &amp;highlight.IsPublic, &amp;shareURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse position JSONs
                <span class="cov0" title="0">json.Unmarshal([]byte(startPosJSON), &amp;highlight.StartPosition)
                json.Unmarshal([]byte(endPosJSON), &amp;highlight.EndPosition)

                // Parse tags JSON
                if err := json.Unmarshal([]byte(tagsJSON), &amp;highlight.Tags); err != nil </span><span class="cov0" title="0">{
                        highlight.Tags = []string{}
                }</span>

                <span class="cov0" title="0">if shareURL.Valid </span><span class="cov0" title="0">{
                        highlight.ShareURL = shareURL.String
                }</span>

                <span class="cov0" title="0">highlights = append(highlights, highlight)</span>
        }

        <span class="cov0" title="0">return highlights, nil</span>
}

// Get reading statistics for a user
func (s *ReaderService) GetReadingStats(ctx context.Context, userID int64, period string) (*ReadingStats, error) <span class="cov0" title="0">{
        var stats ReadingStats

        // Get total reading statistics
        query := `
                SELECT
                        COALESCE(SUM(total_reading_time), 0) as total_time,
                        COALESCE(SUM(pages_read), 0) as total_pages,
                        COALESCE(SUM(words_read), 0) as total_words,
                        COALESCE(AVG(reading_speed), 0) as avg_speed,
                        COUNT(DISTINCT book_id) as books_read
                FROM reading_sessions
                WHERE user_id = ? AND started_at &gt;= ?
        `

        var startDate time.Time
        switch period </span>{
        case "day":<span class="cov0" title="0">
                startDate = time.Now().AddDate(0, 0, -1)</span>
        case "week":<span class="cov0" title="0">
                startDate = time.Now().AddDate(0, 0, -7)</span>
        case "month":<span class="cov0" title="0">
                startDate = time.Now().AddDate(0, -1, 0)</span>
        case "year":<span class="cov0" title="0">
                startDate = time.Now().AddDate(-1, 0, 0)</span>
        default:<span class="cov0" title="0">
                startDate = time.Time{}</span> // All time
        }

        <span class="cov0" title="0">err := s.db.QueryRowContext(ctx, query, userID, startDate).Scan(
                &amp;stats.TotalReadingTime,
                &amp;stats.PagesRead,
                &amp;stats.WordsRead,
                &amp;stats.AverageSpeed,
                &amp;stats.BooksCompleted,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Calculate reading streak
        <span class="cov0" title="0">stats.ReadingStreak = s.calculateReadingStreak(ctx, userID)

        // Get daily goal progress
        stats.DailyGoal = s.getUserDailyGoal(ctx, userID)
        stats.DailyProgress = s.getTodayReadingTime(ctx, userID)

        return &amp;stats, nil</span>
}

// Sync reading progress across devices
func (s *ReaderService) SyncAcrossDevices(ctx context.Context, userID int64, bookID string) error <span class="cov0" title="0">{
        s.logger.Info("Syncing reading progress across devices",
                zap.Int64("user_id", userID),
                zap.String("book_id", bookID))

        // Get all active sessions for this book
        sessions, err := s.getActiveSessionsForBook(ctx, userID, bookID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(sessions) &lt;= 1 </span><span class="cov0" title="0">{
                return nil // No sync needed
        }</span>

        // Find the most recent position
        <span class="cov0" title="0">var latestSession *ReadingSession
        var latestTime time.Time

        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.CurrentPosition.Timestamp.After(latestTime) </span><span class="cov0" title="0">{
                        latestTime = session.CurrentPosition.Timestamp
                        latestSession = &amp;session
                }</span>
        }

        <span class="cov0" title="0">if latestSession == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Update all other sessions with the latest position
        <span class="cov0" title="0">for _, session := range sessions </span><span class="cov0" title="0">{
                if session.ID != latestSession.ID </span><span class="cov0" title="0">{
                        session.CurrentPosition = latestSession.CurrentPosition
                        session.SyncStatus.LastSyncAt = time.Now()
                        session.SyncStatus.IsSynced = true
                        session.SyncStatus.SyncVersion++

                        if err := s.storeReadingSession(ctx, &amp;session); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to sync session",
                                        zap.String("session_id", session.ID),
                                        zap.Error(err))
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper methods
func (s *ReaderService) generateSessionID(userID int64, bookID, deviceID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("session_%d_%s_%s_%d", userID, bookID, deviceID, time.Now().Unix())
}</span>

func (s *ReaderService) generateBookmarkID(userID int64, bookID string, position ReadingPosition) string <span class="cov0" title="0">{
        return fmt.Sprintf("bookmark_%d_%s_%d_%d", userID, bookID, position.PageNumber, time.Now().Unix())
}</span>

func (s *ReaderService) generateHighlightID(userID int64, bookID string, position ReadingPosition) string <span class="cov0" title="0">{
        return fmt.Sprintf("highlight_%d_%s_%d_%d", userID, bookID, position.PageNumber, time.Now().Unix())
}</span>

func (s *ReaderService) generateShareURL(itemType, itemID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("https://catalogizer.com/share/%s/%s", itemType, itemID)
}</span>

func (s *ReaderService) getDefaultReadingSettings() ReadingSettings <span class="cov0" title="0">{
        return ReadingSettings{
                FontFamily:      "serif",
                FontSize:        16,
                LineHeight:      1.5,
                TextAlign:       "justify",
                Theme:           "light",
                BackgroundColor: "#ffffff",
                TextColor:       "#000000",
                PageMargins:     PageMargins{Top: 20, Bottom: 20, Left: 15, Right: 15},
                ColumnsPerPage:  1,
                PageTransition:  "slide",
                AutoScroll:      false,
                AutoScrollSpeed: 5,
                ReadingMode:     "day",
                Brightness:      1.0,
                BlueLight:       BlueLightFilter{Enabled: false, Intensity: 0.3},
                Hyphenation:     true,
                Justification:   true,
                StatusBar:       StatusBarSettings{Visible: true, ShowProgress: true, Position: "bottom"},
                Gestures:        GestureSettings{TapToTurn: true, SwipeToTurn: true, VolumeKeys: false},
                Accessibility:   AccessibilitySettings{},
        }
}</span>

func (s *ReaderService) getUserReadingSettings(ctx context.Context, userID int64) (*ReadingSettings, error) <span class="cov0" title="0">{
        query := `SELECT settings_data FROM user_reading_settings WHERE user_id = ?`

        var settingsJSON string
        err := s.db.QueryRowContext(ctx, query, userID).Scan(&amp;settingsJSON)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var settings ReadingSettings
        if err := json.Unmarshal([]byte(settingsJSON), &amp;settings); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;settings, nil</span>
}

func (s *ReaderService) initializeReadingStats(ctx context.Context, userID int64, bookID string) ReadingStats <span class="cov0" title="0">{
        // Get existing stats or create new ones
        stats := ReadingStats{
                DailyGoal: s.getUserDailyGoal(ctx, userID),
        }

        // Calculate current streak
        stats.ReadingStreak = s.calculateReadingStreak(ctx, userID)

        return stats
}</span>

func (s *ReaderService) updateReadingStats(stats *ReadingStats, readingTime int64, pages, words int) <span class="cov0" title="0">{
        stats.SessionTime += readingTime
        stats.TotalReadingTime += readingTime
        stats.PagesRead += pages
        stats.WordsRead += words

        // Calculate reading speed (words per minute)
        if readingTime &gt; 0 </span><span class="cov0" title="0">{
                stats.ReadingSpeed = float64(words) / (float64(readingTime) / 60.0)
        }</span>

        // Update daily progress
        <span class="cov0" title="0">stats.DailyProgress += int(readingTime / 60)</span> // Convert to minutes
}

func (s *ReaderService) getLastReadingPosition(ctx context.Context, userID int64, bookID string) (*ReadingPosition, error) <span class="cov0" title="0">{
        query := `
                SELECT position_data
                FROM reading_positions
                WHERE user_id = ? AND book_id = ?
                ORDER BY timestamp DESC
                LIMIT 1
        `

        var positionJSON string
        err := s.db.QueryRowContext(ctx, query, userID, bookID).Scan(&amp;positionJSON)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var position ReadingPosition
        if err := json.Unmarshal([]byte(positionJSON), &amp;position); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;position, nil</span>
}

func (s *ReaderService) storeReadingSession(ctx context.Context, session *ReadingSession) error <span class="cov0" title="0">{
        sessionJSON, _ := json.Marshal(session)
        positionJSON, _ := json.Marshal(session.CurrentPosition)
        settingsJSON, _ := json.Marshal(session.ReadingSettings)
        statsJSON, _ := json.Marshal(session.ReadingStats)

        query := `
                INSERT OR REPLACE INTO reading_sessions (
                        id, user_id, book_id, device_id, device_name, started_at, last_active_at,
                        current_position, reading_settings, reading_stats, is_active, session_data
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.ExecContext(ctx, query,
                session.ID, session.UserID, session.BookID, session.DeviceID, session.DeviceName,
                session.StartedAt, session.LastActiveAt, string(positionJSON), string(settingsJSON),
                string(statsJSON), session.IsActive, string(sessionJSON),
        )

        return err
}</span>

func (s *ReaderService) getReadingSession(ctx context.Context, sessionID string) (*ReadingSession, error) <span class="cov0" title="0">{
        query := `SELECT session_data FROM reading_sessions WHERE id = ?`

        var sessionJSON string
        err := s.db.QueryRowContext(ctx, query, sessionID).Scan(&amp;sessionJSON)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var session ReadingSession
        if err := json.Unmarshal([]byte(sessionJSON), &amp;session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;session, nil</span>
}

func (s *ReaderService) storeReadingPosition(ctx context.Context, userID int64, bookID string, position ReadingPosition) error <span class="cov0" title="0">{
        positionJSON, _ := json.Marshal(position)

        query := `
                INSERT OR REPLACE INTO reading_positions (
                        user_id, book_id, position_data, page_number, percent_complete, timestamp
                ) VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.ExecContext(ctx, query,
                userID, bookID, string(positionJSON), position.PageNumber,
                position.PercentComplete, position.Timestamp,
        )

        return err
}</span>

func (s *ReaderService) storeBookmark(ctx context.Context, bookmark *Bookmark) error <span class="cov0" title="0">{
        positionJSON, _ := json.Marshal(bookmark.Position)
        tagsJSON, _ := json.Marshal(bookmark.Tags)

        query := `
                INSERT OR REPLACE INTO reading_bookmarks (
                        id, user_id, book_id, position_data, title, note, tags, color,
                        created_at, updated_at, is_public, share_url
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.ExecContext(ctx, query,
                bookmark.ID, bookmark.UserID, bookmark.BookID, string(positionJSON),
                bookmark.Title, bookmark.Note, string(tagsJSON), bookmark.Color,
                bookmark.CreatedAt, bookmark.UpdatedAt, bookmark.IsPublic, bookmark.ShareURL,
        )

        return err
}</span>

func (s *ReaderService) storeHighlight(ctx context.Context, highlight *Highlight) error <span class="cov0" title="0">{
        startPosJSON, _ := json.Marshal(highlight.StartPosition)
        endPosJSON, _ := json.Marshal(highlight.EndPosition)
        tagsJSON, _ := json.Marshal(highlight.Tags)

        query := `
                INSERT OR REPLACE INTO reading_highlights (
                        id, user_id, book_id, start_position_data, end_position_data,
                        selected_text, note, color, type, tags, created_at, updated_at,
                        is_public, share_url
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.ExecContext(ctx, query,
                highlight.ID, highlight.UserID, highlight.BookID, string(startPosJSON), string(endPosJSON),
                highlight.SelectedText, highlight.Note, highlight.Color, highlight.Type, string(tagsJSON),
                highlight.CreatedAt, highlight.UpdatedAt, highlight.IsPublic, highlight.ShareURL,
        )

        return err
}</span>

func (s *ReaderService) updateReadingHistory(ctx context.Context, userID int64, bookID string, timestamp time.Time) <span class="cov0" title="0">{
        query := `
                INSERT OR REPLACE INTO reading_history (
                        user_id, book_id, last_read_at, read_count
                ) VALUES (?, ?, ?, COALESCE((SELECT read_count FROM reading_history WHERE user_id = ? AND book_id = ?), 0) + 1)
        `

        s.db.ExecContext(ctx, query, userID, bookID, timestamp, userID, bookID)
}</span>

func (s *ReaderService) syncAcrossDevices(ctx context.Context, session *ReadingSession) error <span class="cov0" title="0">{
        return s.SyncAcrossDevices(ctx, session.UserID, session.BookID)
}</span>

func (s *ReaderService) getActiveSessionsForBook(ctx context.Context, userID int64, bookID string) ([]ReadingSession, error) <span class="cov0" title="0">{
        query := `SELECT session_data FROM reading_sessions WHERE user_id = ? AND book_id = ? AND is_active = 1`

        rows, err := s.db.QueryContext(ctx, query, userID, bookID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var sessions []ReadingSession
        for rows.Next() </span><span class="cov0" title="0">{
                var sessionJSON string
                if err := rows.Scan(&amp;sessionJSON); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var session ReadingSession
                if err := json.Unmarshal([]byte(sessionJSON), &amp;session); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">sessions = append(sessions, session)</span>
        }

        <span class="cov0" title="0">return sessions, nil</span>
}

func (s *ReaderService) calculateReadingStreak(ctx context.Context, userID int64) int <span class="cov0" title="0">{
        query := `
                SELECT DATE(last_read_at) as read_date
                FROM reading_history
                WHERE user_id = ?
                ORDER BY last_read_at DESC
        `

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        streak := 0
        expectedDate := time.Now().Truncate(24 * time.Hour)

        for rows.Next() </span><span class="cov0" title="0">{
                var readDate time.Time
                if err := rows.Scan(&amp;readDate); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if readDate.Equal(expectedDate) </span><span class="cov0" title="0">{
                        streak++
                        expectedDate = expectedDate.AddDate(0, 0, -1)
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">return streak</span>
}

func (s *ReaderService) getUserDailyGoal(ctx context.Context, userID int64) int <span class="cov0" title="0">{
        query := `SELECT daily_goal_minutes FROM user_reading_goals WHERE user_id = ?`

        var goal int
        err := s.db.QueryRowContext(ctx, query, userID).Scan(&amp;goal)
        if err != nil </span><span class="cov0" title="0">{
                return 30 // Default 30 minutes
        }</span>

        <span class="cov0" title="0">return goal</span>
}

func (s *ReaderService) getTodayReadingTime(ctx context.Context, userID int64) int <span class="cov0" title="0">{
        today := time.Now().Truncate(24 * time.Hour)
        tomorrow := today.AddDate(0, 0, 1)

        query := `
                SELECT COALESCE(SUM(session_time), 0) / 60 as minutes
                FROM reading_sessions
                WHERE user_id = ? AND started_at &gt;= ? AND started_at &lt; ?
        `

        var minutes int
        err := s.db.QueryRowContext(ctx, query, userID, today, tomorrow).Scan(&amp;minutes)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return minutes</span>
}

func minInt(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "sort"
        "strings"
        "time"

        "catalogizer/internal/models"
)

type RecommendationService struct {
        mediaRecognitionService   *MediaRecognitionService
        duplicateDetectionService *DuplicateDetectionService
        tmdbBaseURL               string
        omdbBaseURL               string
        lastfmBaseURL             string
        igdbBaseURL               string
        googleBooksBaseURL        string
        steamBaseURL              string
        githubBaseURL             string
        tmdbAPIKey                string
        omdbAPIKey                string
        lastfmAPIKey              string
        igdbClientID              string
        igdbClientSecret          string
        httpClient                *http.Client
}

type SimilarItemsRequest struct {
        MediaID             string                 `json:"media_id"`
        MediaMetadata       *models.MediaMetadata  `json:"media_metadata"`
        MaxLocalItems       int                    `json:"max_local_items,omitempty"`
        MaxExternalItems    int                    `json:"max_external_items,omitempty"`
        IncludeExternal     bool                   `json:"include_external,omitempty"`
        SimilarityThreshold float64                `json:"similarity_threshold,omitempty"`
        Filters             *RecommendationFilters `json:"filters,omitempty"`
}

type RecommendationFilters struct {
        GenreFilter    []string     `json:"genre_filter,omitempty"`
        YearRange      *YearRange   `json:"year_range,omitempty"`
        RatingRange    *RatingRange `json:"rating_range,omitempty"`
        LanguageFilter []string     `json:"language_filter,omitempty"`
        ExcludeWatched bool         `json:"exclude_watched,omitempty"`
        ExcludeOwned   bool         `json:"exclude_owned,omitempty"`
        MinConfidence  float64      `json:"min_confidence,omitempty"`
}

type YearRange struct {
        StartYear int `json:"start_year"`
        EndYear   int `json:"end_year"`
}

type RatingRange struct {
        MinRating float64 `json:"min_rating"`
        MaxRating float64 `json:"max_rating"`
}

type SimilarItemsResponse struct {
        LocalItems    []*LocalSimilarItem    `json:"local_items"`
        ExternalItems []*ExternalSimilarItem `json:"external_items"`
        TotalFound    int                    `json:"total_found"`
        GeneratedAt   time.Time              `json:"generated_at"`
        Algorithms    []string               `json:"algorithms_used"`
        Performance   *RecommendationStats   `json:"performance"`
}

type LocalSimilarItem struct {
        MediaID           string                `json:"media_id"`
        MediaMetadata     *models.MediaMetadata `json:"media_metadata"`
        SimilarityScore   float64               `json:"similarity_score"`
        SimilarityReasons []string              `json:"similarity_reasons"`
        DetailLink        string                `json:"detail_link"`
        PlayLink          string                `json:"play_link,omitempty"`
        DownloadLink      string                `json:"download_link,omitempty"`
        LastAccessed      *time.Time            `json:"last_accessed,omitempty"`
        UserRating        *float64              `json:"user_rating,omitempty"`
        IsWatched         bool                  `json:"is_watched"`
        IsOwned           bool                  `json:"is_owned"`
}

type ExternalSimilarItem struct {
        ExternalID        string            `json:"external_id"`
        Title             string            `json:"title"`
        Subtitle          string            `json:"subtitle,omitempty"`
        Description       string            `json:"description"`
        CoverArt          string            `json:"cover_art,omitempty"`
        Year              string            `json:"year,omitempty"`
        Genre             string            `json:"genre,omitempty"`
        Rating            float64           `json:"rating,omitempty"`
        Provider          string            `json:"provider"`
        ExternalLink      string            `json:"external_link"`
        SimilarityScore   float64           `json:"similarity_score"`
        SimilarityReasons []string          `json:"similarity_reasons"`
        AvailabilityInfo  *AvailabilityInfo `json:"availability_info,omitempty"`
        PriceInfo         *PriceInfo        `json:"price_info,omitempty"`
}

type AvailabilityInfo struct {
        IsAvailable       bool     `json:"is_available"`
        StreamingServices []string `json:"streaming_services,omitempty"`
        PurchaseOptions   []string `json:"purchase_options,omitempty"`
        RentalOptions     []string `json:"rental_options,omitempty"`
        Region            string   `json:"region,omitempty"`
}

type PriceInfo struct {
        PurchasePrice string    `json:"purchase_price,omitempty"`
        RentalPrice   string    `json:"rental_price,omitempty"`
        Currency      string    `json:"currency,omitempty"`
        LastUpdated   time.Time `json:"last_updated"`
}

type RecommendationStats struct {
        LocalSearchTime    time.Duration `json:"local_search_time"`
        ExternalSearchTime time.Duration `json:"external_search_time"`
        TotalTime          time.Duration `json:"total_time"`
        LocalItemsFound    int           `json:"local_items_found"`
        ExternalItemsFound int           `json:"external_items_found"`
        CacheHitRatio      float64       `json:"cache_hit_ratio"`
        APICallsCount      int           `json:"api_calls_count"`
}

func NewRecommendationService(
        mediaRecognitionService *MediaRecognitionService,
        duplicateDetectionService *DuplicateDetectionService,
) *RecommendationService <span class="cov0" title="0">{
        return &amp;RecommendationService{
                mediaRecognitionService:   mediaRecognitionService,
                duplicateDetectionService: duplicateDetectionService,
                tmdbBaseURL:               "https://api.themoviedb.org/3",
                omdbBaseURL:               "http://www.omdbapi.com",
                lastfmBaseURL:             "http://ws.audioscrobbler.com/2.0",
                igdbBaseURL:               "https://api.igdb.com/v4",
                googleBooksBaseURL:        "https://www.googleapis.com/books/v1",
                steamBaseURL:              "https://store.steampowered.com/api",
                githubBaseURL:             "https://api.github.com",
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }
}</span>

func (rs *RecommendationService) GetSimilarItems(ctx context.Context, req *SimilarItemsRequest) (*SimilarItemsResponse, error) <span class="cov0" title="0">{
        startTime := time.Now()

        // Set defaults
        if req.MaxLocalItems == 0 </span><span class="cov0" title="0">{
                req.MaxLocalItems = 10
        }</span>
        <span class="cov0" title="0">if req.MaxExternalItems == 0 </span><span class="cov0" title="0">{
                req.MaxExternalItems = 5
        }</span>
        <span class="cov0" title="0">if req.SimilarityThreshold == 0 </span><span class="cov0" title="0">{
                req.SimilarityThreshold = 0.3
        }</span>

        <span class="cov0" title="0">response := &amp;SimilarItemsResponse{
                LocalItems:    make([]*LocalSimilarItem, 0),
                ExternalItems: make([]*ExternalSimilarItem, 0),
                GeneratedAt:   time.Now(),
                Algorithms:    []string{"content_similarity", "metadata_matching", "collaborative_filtering"},
                Performance:   &amp;RecommendationStats{},
        }

        // Find local similar items first
        localStartTime := time.Now()
        localItems, err := rs.findLocalSimilarItems(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find local similar items: %w", err)
        }</span>
        <span class="cov0" title="0">response.LocalItems = localItems
        response.Performance.LocalSearchTime = time.Since(localStartTime)
        response.Performance.LocalItemsFound = len(localItems)

        // Find external similar items if requested and needed
        if req.IncludeExternal &amp;&amp; len(localItems) &lt; req.MaxLocalItems </span><span class="cov0" title="0">{
                externalStartTime := time.Now()
                externalItems, err := rs.findExternalSimilarItems(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the entire request
                        fmt.Printf("Warning: failed to find external similar items: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        response.ExternalItems = externalItems
                        response.Performance.ExternalItemsFound = len(externalItems)
                }</span>
                <span class="cov0" title="0">response.Performance.ExternalSearchTime = time.Since(externalStartTime)</span>
        }

        <span class="cov0" title="0">response.TotalFound = len(response.LocalItems) + len(response.ExternalItems)
        response.Performance.TotalTime = time.Since(startTime)

        return response, nil</span>
}

func (rs *RecommendationService) findLocalSimilarItems(ctx context.Context, req *SimilarItemsRequest) ([]*LocalSimilarItem, error) <span class="cov0" title="0">{
        // This would normally query the local database/catalog
        // For now, we'll simulate finding similar items

        var allLocalMedia []*models.MediaMetadata

        // In a real implementation, this would query the database
        // For demonstration, we'll create some mock similar items
        allLocalMedia = rs.generateMockLocalMedia(req.MediaMetadata)

        var similarItems []*LocalSimilarItem

        for _, media := range allLocalMedia </span><span class="cov0" title="0">{
                // Skip the same item by ID comparison
                if media.ID == req.MediaMetadata.ID </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Calculate similarity
                <span class="cov0" title="0">similarity, reasons := rs.calculateLocalSimilarity(req.MediaMetadata, media)

                // Apply filters
                if !rs.passesFilters(media, similarity, req.Filters) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Apply similarity threshold
                <span class="cov0" title="0">if similarity &lt; req.SimilarityThreshold </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">similarItem := &amp;LocalSimilarItem{
                        MediaID:           rs.generateMediaID(media),
                        MediaMetadata:     media,
                        SimilarityScore:   similarity,
                        SimilarityReasons: reasons,
                        DetailLink:        rs.generateDetailLink(media),
                        PlayLink:          rs.generatePlayLink(media),
                        DownloadLink:      rs.generateDownloadLink(media),
                        IsOwned:           true, // Local items are owned
                }

                similarItems = append(similarItems, similarItem)</span>
        }

        // Sort by similarity score (descending)
        <span class="cov0" title="0">sort.Slice(similarItems, func(i, j int) bool </span><span class="cov0" title="0">{
                return similarItems[i].SimilarityScore &gt; similarItems[j].SimilarityScore
        }</span>)

        // Limit results
        <span class="cov0" title="0">if len(similarItems) &gt; req.MaxLocalItems </span><span class="cov0" title="0">{
                similarItems = similarItems[:req.MaxLocalItems]
        }</span>

        <span class="cov0" title="0">return similarItems, nil</span>
}

func (rs *RecommendationService) findExternalSimilarItems(ctx context.Context, req *SimilarItemsRequest) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        var externalItems []*ExternalSimilarItem

        // Note: MediaMetadata doesn't have MediaType field yet
        // For now, try to find similar items based on genre/description
        // TODO: Add MediaType field to MediaMetadata or use a different approach

        // Try finding similar items across all types
        if movieItems, err := rs.findSimilarMovies(ctx, req.MediaMetadata); err == nil </span><span class="cov0" title="0">{
                externalItems = append(externalItems, movieItems...)
        }</span>

        <span class="cov0" title="0">if musicItems, err := rs.findSimilarMusic(ctx, req.MediaMetadata); err == nil </span><span class="cov0" title="0">{
                externalItems = append(externalItems, musicItems...)
        }</span>

        // Apply filters to external items
        <span class="cov0" title="0">var filteredItems []*ExternalSimilarItem
        for _, item := range externalItems </span><span class="cov0" title="0">{
                if rs.passesExternalFilters(item, req.Filters) </span><span class="cov0" title="0">{
                        filteredItems = append(filteredItems, item)
                }</span>
        }

        // Sort by similarity score (descending)
        <span class="cov0" title="0">sort.Slice(filteredItems, func(i, j int) bool </span><span class="cov0" title="0">{
                return filteredItems[i].SimilarityScore &gt; filteredItems[j].SimilarityScore
        }</span>)

        // Limit results
        <span class="cov0" title="0">if len(filteredItems) &gt; req.MaxExternalItems </span><span class="cov0" title="0">{
                filteredItems = filteredItems[:req.MaxExternalItems]
        }</span>

        <span class="cov0" title="0">return filteredItems, nil</span>
}

func (rs *RecommendationService) findSimilarMovies(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        var items []*ExternalSimilarItem

        // TMDb similar movies
        tmdbItems, err := rs.getTMDbSimilarMovies(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, tmdbItems...)
        }</span>

        // OMDb recommendations (genre-based)
        <span class="cov0" title="0">omdbItems, err := rs.getOMDbSimilarMovies(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, omdbItems...)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) findSimilarMusic(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        var items []*ExternalSimilarItem

        // Last.fm similar artists and tracks
        lastfmItems, err := rs.getLastFmSimilarMusic(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, lastfmItems...)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) findSimilarBooks(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        var items []*ExternalSimilarItem

        // Google Books similar books
        googleItems, err := rs.getGoogleBooksSimilar(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, googleItems...)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) findSimilarGames(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        var items []*ExternalSimilarItem

        // IGDB similar games
        igdbItems, err := rs.getIGDBSimilarGames(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, igdbItems...)
        }</span>

        // Steam recommendations
        <span class="cov0" title="0">steamItems, err := rs.getSteamSimilarGames(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, steamItems...)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) findSimilarSoftware(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        var items []*ExternalSimilarItem

        // GitHub similar repositories
        githubItems, err := rs.getGitHubSimilarSoftware(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, githubItems...)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

// External API integration methods
func (rs *RecommendationService) getTMDbSimilarMovies(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // First, we need to find the movie ID
        searchURL := fmt.Sprintf("%s/search/movie?api_key=%s&amp;query=%s",
                rs.tmdbBaseURL, rs.tmdbAPIKey, url.QueryEscape(metadata.Title))

        resp, err := rs.httpClient.Get(searchURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResult struct {
                Results []struct {
                        ID          int     `json:"id"`
                        Title       string  `json:"title"`
                        ReleaseDate string  `json:"release_date"`
                        Overview    string  `json:"overview"`
                        PosterPath  string  `json:"poster_path"`
                        VoteAverage float64 `json:"vote_average"`
                        GenreIDs    []int   `json:"genre_ids"`
                } `json:"results"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResult); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResult.Results) == 0 </span><span class="cov0" title="0">{
                return []*ExternalSimilarItem{}, nil
        }</span>

        <span class="cov0" title="0">movieID := searchResult.Results[0].ID

        // Get similar movies
        similarURL := fmt.Sprintf("%s/movie/%d/similar?api_key=%s",
                rs.tmdbBaseURL, movieID, rs.tmdbAPIKey)

        resp2, err := rs.httpClient.Get(similarURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp2.Body.Close()

        var similarResult struct {
                Results []struct {
                        ID          int     `json:"id"`
                        Title       string  `json:"title"`
                        ReleaseDate string  `json:"release_date"`
                        Overview    string  `json:"overview"`
                        PosterPath  string  `json:"poster_path"`
                        VoteAverage float64 `json:"vote_average"`
                } `json:"results"`
        }

        if err := json.NewDecoder(resp2.Body).Decode(&amp;similarResult); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var items []*ExternalSimilarItem
        for _, movie := range similarResult.Results </span><span class="cov0" title="0">{
                item := &amp;ExternalSimilarItem{
                        ExternalID:        fmt.Sprintf("tmdb_%d", movie.ID),
                        Title:             movie.Title,
                        Description:       movie.Overview,
                        Year:              rs.extractYear(movie.ReleaseDate),
                        Rating:            movie.VoteAverage,
                        Provider:          "TMDb",
                        ExternalLink:      fmt.Sprintf("https://www.themoviedb.org/movie/%d", movie.ID),
                        SimilarityScore:   rs.calculateTMDbSimilarity(metadata, movie.Title, movie.ReleaseDate, movie.VoteAverage),
                        SimilarityReasons: []string{"genre_match", "tmdb_recommendation"},
                }

                if movie.PosterPath != "" </span><span class="cov0" title="0">{
                        item.CoverArt = fmt.Sprintf("https://image.tmdb.org/t/p/w500%s", movie.PosterPath)
                }</span>

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) getOMDbSimilarMovies(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // OMDb doesn't have a "similar" endpoint, so we'll search by genre
        // This is a simplified implementation
        searchURL := fmt.Sprintf("%s?apikey=%s&amp;s=%s&amp;type=movie",
                rs.omdbBaseURL, rs.omdbAPIKey, url.QueryEscape(metadata.Genre))

        resp, err := rs.httpClient.Get(searchURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResult struct {
                Search []struct {
                        Title  string `json:"Title"`
                        Year   string `json:"Year"`
                        IMDbID string `json:"imdbID"`
                        Type   string `json:"Type"`
                        Poster string `json:"Poster"`
                } `json:"Search"`
                Response string `json:"Response"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResult); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if searchResult.Response != "True" </span><span class="cov0" title="0">{
                return []*ExternalSimilarItem{}, nil
        }</span>

        <span class="cov0" title="0">var items []*ExternalSimilarItem
        for i, movie := range searchResult.Search </span><span class="cov0" title="0">{
                if i &gt;= 3 </span><span class="cov0" title="0">{ // Limit to first 3 results
                        break</span>
                }

                // Skip the same movie
                <span class="cov0" title="0">if strings.ToLower(movie.Title) == strings.ToLower(metadata.Title) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">item := &amp;ExternalSimilarItem{
                        ExternalID:        fmt.Sprintf("imdb_%s", movie.IMDbID),
                        Title:             movie.Title,
                        Year:              movie.Year,
                        Provider:          "IMDb",
                        ExternalLink:      fmt.Sprintf("https://www.imdb.com/title/%s", movie.IMDbID),
                        SimilarityScore:   rs.calculateOMDbSimilarity(metadata, movie.Title, movie.Year),
                        SimilarityReasons: []string{"genre_match", "imdb_search"},
                }

                if movie.Poster != "N/A" </span><span class="cov0" title="0">{
                        item.CoverArt = movie.Poster
                }</span>

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) getLastFmSimilarMusic(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // Get similar artists
        // Note: MediaMetadata doesn't have Artist field, using Director field which may contain artist name
        artist := metadata.Director
        if artist == "" </span><span class="cov0" title="0">{
                artist = metadata.Title // Fallback to title if no director/artist
        }</span>
        <span class="cov0" title="0">artistURL := fmt.Sprintf("%s?method=artist.getsimilar&amp;artist=%s&amp;api_key=%s&amp;format=json",
                rs.lastfmBaseURL, url.QueryEscape(artist), rs.lastfmAPIKey)

        resp, err := rs.httpClient.Get(artistURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var artistResult struct {
                SimilarArtists struct {
                        Artist []struct {
                                Name  string `json:"name"`
                                Match string `json:"match"`
                                URL   string `json:"url"`
                                Image []struct {
                                        Text string `json:"#text"`
                                        Size string `json:"size"`
                                } `json:"image"`
                        } `json:"artist"`
                } `json:"similarartists"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;artistResult); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var items []*ExternalSimilarItem
        for i, artist := range artistResult.SimilarArtists.Artist </span><span class="cov0" title="0">{
                if i &gt;= 5 </span><span class="cov0" title="0">{ // Limit to first 5 results
                        break</span>
                }

                <span class="cov0" title="0">item := &amp;ExternalSimilarItem{
                        ExternalID:        fmt.Sprintf("lastfm_artist_%s", strings.ReplaceAll(artist.Name, " ", "_")),
                        Title:             artist.Name,
                        Subtitle:          "Similar Artist",
                        Provider:          "Last.fm",
                        ExternalLink:      artist.URL,
                        SimilarityScore:   rs.parseLastFmMatch(artist.Match),
                        SimilarityReasons: []string{"artist_similarity", "lastfm_recommendation"},
                }

                // Get the largest image
                for _, img := range artist.Image </span><span class="cov0" title="0">{
                        if img.Size == "large" &amp;&amp; img.Text != "" </span><span class="cov0" title="0">{
                                item.CoverArt = img.Text
                                break</span>
                        }
                }

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) getGoogleBooksSimilar(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // Search for books by similar genre or title keywords
        // Note: MediaMetadata doesn't have Author field, using Title and Genre instead
        searchTerms := []string{
                fmt.Sprintf("intitle:%s", metadata.Title),
                fmt.Sprintf("subject:%s", metadata.Genre),
        }

        var items []*ExternalSimilarItem

        for _, term := range searchTerms </span><span class="cov0" title="0">{
                if term == "inauthor:" || term == "subject:" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">searchURL := fmt.Sprintf("%s/volumes?q=%s&amp;maxResults=3",
                        rs.googleBooksBaseURL, url.QueryEscape(term))

                resp, err := rs.httpClient.Get(searchURL)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var result struct {
                        Items []struct {
                                ID         string `json:"id"`
                                VolumeInfo struct {
                                        Title         string   `json:"title"`
                                        Authors       []string `json:"authors"`
                                        Description   string   `json:"description"`
                                        Categories    []string `json:"categories"`
                                        AverageRating float64  `json:"averageRating"`
                                        PublishedDate string   `json:"publishedDate"`
                                        ImageLinks    struct {
                                                Thumbnail string `json:"thumbnail"`
                                        } `json:"imageLinks"`
                                        CanonicalVolumeLink string `json:"canonicalVolumeLink"`
                                } `json:"volumeInfo"`
                        } `json:"items"`
                }

                if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                        resp.Body.Close()
                        continue</span>
                }
                <span class="cov0" title="0">resp.Body.Close()

                for _, book := range result.Items </span><span class="cov0" title="0">{
                        // Skip the same book
                        if strings.ToLower(book.VolumeInfo.Title) == strings.ToLower(metadata.Title) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">author := ""
                        if len(book.VolumeInfo.Authors) &gt; 0 </span><span class="cov0" title="0">{
                                author = book.VolumeInfo.Authors[0]
                        }</span>

                        <span class="cov0" title="0">item := &amp;ExternalSimilarItem{
                                ExternalID:        fmt.Sprintf("google_books_%s", book.ID),
                                Title:             book.VolumeInfo.Title,
                                Subtitle:          author,
                                Description:       book.VolumeInfo.Description,
                                Year:              rs.extractYear(book.VolumeInfo.PublishedDate),
                                Rating:            book.VolumeInfo.AverageRating,
                                Provider:          "Google Books",
                                ExternalLink:      book.VolumeInfo.CanonicalVolumeLink,
                                SimilarityScore:   rs.calculateGoogleBooksSimilarity(metadata, book.VolumeInfo.Title, author),
                                SimilarityReasons: []string{"author_match", "genre_match"},
                        }

                        if book.VolumeInfo.ImageLinks.Thumbnail != "" </span><span class="cov0" title="0">{
                                item.CoverArt = book.VolumeInfo.ImageLinks.Thumbnail
                        }</span>

                        <span class="cov0" title="0">items = append(items, item)</span>
                }

                <span class="cov0" title="0">if len(items) &gt;= 5 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) getIGDBSimilarGames(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // IGDB requires OAuth token - simplified implementation
        // In a real implementation, you'd get an OAuth token first

        // Mock similar games for demonstration
        var items []*ExternalSimilarItem

        // This would normally use IGDB's similar games endpoint
        similarGames := []struct {
                ID     int
                Name   string
                Genre  string
                Rating float64
                URL    string
        }{
                {1, "Similar Game 1", metadata.Genre, 8.5, "https://www.igdb.com/games/similar-game-1"},
                {2, "Similar Game 2", metadata.Genre, 7.8, "https://www.igdb.com/games/similar-game-2"},
        }

        for _, game := range similarGames </span><span class="cov0" title="0">{
                item := &amp;ExternalSimilarItem{
                        ExternalID:        fmt.Sprintf("igdb_%d", game.ID),
                        Title:             game.Name,
                        Genre:             game.Genre,
                        Rating:            game.Rating,
                        Provider:          "IGDB",
                        ExternalLink:      game.URL,
                        SimilarityScore:   0.8, // Mock score
                        SimilarityReasons: []string{"genre_match", "igdb_recommendation"},
                }

                items = append(items, item)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) getSteamSimilarGames(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // Steam doesn't have a public recommendations API
        // This would normally require Steam Web API key and additional processing

        // Mock implementation
        var items []*ExternalSimilarItem

        // This is just for demonstration
        steamGames := []struct {
                ID    string
                Name  string
                Genre string
                Price string
        }{
                {"123456", "Steam Similar Game 1", metadata.Genre, "$19.99"},
                {"789012", "Steam Similar Game 2", metadata.Genre, "$29.99"},
        }

        for _, game := range steamGames </span><span class="cov0" title="0">{
                item := &amp;ExternalSimilarItem{
                        ExternalID:        fmt.Sprintf("steam_%s", game.ID),
                        Title:             game.Name,
                        Genre:             game.Genre,
                        Provider:          "Steam",
                        ExternalLink:      fmt.Sprintf("https://store.steampowered.com/app/%s", game.ID),
                        SimilarityScore:   0.7, // Mock score
                        SimilarityReasons: []string{"genre_match", "steam_recommendation"},
                        PriceInfo: &amp;PriceInfo{
                                PurchasePrice: game.Price,
                                Currency:      "USD",
                                LastUpdated:   time.Now(),
                        },
                }

                items = append(items, item)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) getGitHubSimilarSoftware(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // Search for similar repositories by topic or language
        searchQuery := fmt.Sprintf("topic:%s", strings.ToLower(metadata.Genre))
        searchURL := fmt.Sprintf("%s/search/repositories?q=%s&amp;sort=stars&amp;order=desc&amp;per_page=5",
                rs.githubBaseURL, url.QueryEscape(searchQuery))

        resp, err := rs.httpClient.Get(searchURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var result struct {
                Items []struct {
                        ID              int    `json:"id"`
                        Name            string `json:"name"`
                        FullName        string `json:"full_name"`
                        Description     string `json:"description"`
                        Language        string `json:"language"`
                        StargazersCount int    `json:"stargazers_count"`
                        HTMLURL         string `json:"html_url"`
                } `json:"items"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var items []*ExternalSimilarItem
        for _, repo := range result.Items </span><span class="cov0" title="0">{
                // Skip if same name
                if strings.ToLower(repo.Name) == strings.ToLower(metadata.Title) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">item := &amp;ExternalSimilarItem{
                        ExternalID:        fmt.Sprintf("github_%d", repo.ID),
                        Title:             repo.Name,
                        Subtitle:          repo.FullName,
                        Description:       repo.Description,
                        Provider:          "GitHub",
                        ExternalLink:      repo.HTMLURL,
                        SimilarityScore:   rs.calculateGitHubSimilarity(metadata, repo.Name, repo.Language, repo.StargazersCount),
                        SimilarityReasons: []string{"topic_match", "github_stars"},
                }

                items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items, nil</span>
}

// Helper methods for similarity calculation
func (rs *RecommendationService) calculateLocalSimilarity(original, candidate *models.MediaMetadata) (float64, []string) <span class="cov0" title="0">{
        var score float64
        var reasons []string

        // Use basic text similarity as a foundation
        titleSimilarity := rs.duplicateDetectionService.calculateTextSimilarity(original.Title, candidate.Title)
        score = titleSimilarity * 0.5

        if titleSimilarity &gt; 0.8 </span><span class="cov0" title="0">{
                reasons = append(reasons, "high_title_similarity")
        }</span>

        // Additional similarity factors
        // Note: MediaType field doesn't exist in MediaMetadata, skipping this comparison
        // if original.MediaType == candidate.MediaType {
        //         score += 0.1
        //         reasons = append(reasons, "same_media_type")
        // }

        <span class="cov0" title="0">if original.Genre == candidate.Genre &amp;&amp; original.Genre != "" </span><span class="cov0" title="0">{
                score += 0.15
                reasons = append(reasons, "same_genre")
        }</span>

        <span class="cov0" title="0">if original.Year != nil &amp;&amp; candidate.Year != nil &amp;&amp; *original.Year == *candidate.Year </span><span class="cov0" title="0">{
                score += 0.1
                reasons = append(reasons, "same_year")
        }</span>

        // Note: Artist field doesn't exist, using Director instead
        <span class="cov0" title="0">if original.Director == candidate.Director &amp;&amp; original.Director != "" </span><span class="cov0" title="0">{
                score += 0.2
                reasons = append(reasons, "same_director")
        }</span>

        // Note: Author field doesn't exist, using Producer instead
        <span class="cov0" title="0">if original.Producer == candidate.Producer &amp;&amp; original.Producer != "" </span><span class="cov0" title="0">{
                score += 0.2
                reasons = append(reasons, "same_producer")
        }</span>

        // Note: Developer field doesn't exist in MediaMetadata
        // if original.Developer == candidate.Developer &amp;&amp; original.Developer != "" {
        //         score += 0.15
        //         reasons = append(reasons, "same_developer")
        // }

        // Normalize score to [0, 1]
        <span class="cov0" title="0">if score &gt; 1.0 </span><span class="cov0" title="0">{
                score = 1.0
        }</span>

        <span class="cov0" title="0">return score, reasons</span>
}

func (rs *RecommendationService) calculateTMDbSimilarity(original *models.MediaMetadata, title, releaseDate string, rating float64) float64 <span class="cov0" title="0">{
        score := 0.5 // Base score for TMDb recommendation

        // Year similarity (Year is *int, candidateYear is string)
        if original.Year != nil </span><span class="cov0" title="0">{
                candidateYear := rs.extractYear(releaseDate)
                if candidateYear != "" &amp;&amp; fmt.Sprintf("%d", *original.Year) == candidateYear </span><span class="cov0" title="0">{
                        score += 0.2
                }</span>
        }

        // Rating similarity (if original has rating)
        <span class="cov0" title="0">if original.Rating != nil &amp;&amp; *original.Rating &gt; 0 </span><span class="cov0" title="0">{
                ratingDiff := abs(*original.Rating - rating)
                if ratingDiff &lt; 1.0 </span><span class="cov0" title="0">{
                        score += 0.1
                }</span>
        }

        // Title similarity
        <span class="cov0" title="0">titleSim := rs.duplicateDetectionService.calculateTextSimilarity(original.Title, title)
        score += titleSim * 0.2

        return score</span>
}

func (rs *RecommendationService) calculateOMDbSimilarity(original *models.MediaMetadata, title, year string) float64 <span class="cov0" title="0">{
        score := 0.4 // Base score for OMDb search

        // Year similarity (Year is *int, year parameter is string)
        if original.Year != nil &amp;&amp; year != "" &amp;&amp; fmt.Sprintf("%d", *original.Year) == year </span><span class="cov0" title="0">{
                score += 0.3
        }</span>

        // Title similarity
        <span class="cov0" title="0">titleSim := rs.duplicateDetectionService.calculateTextSimilarity(original.Title, title)
        score += titleSim * 0.3

        return score</span>
}

func (rs *RecommendationService) calculateGoogleBooksSimilarity(original *models.MediaMetadata, title, author string) float64 <span class="cov0" title="0">{
        score := 0.4 // Base score

        // Author similarity (using Producer as fallback for author)
        if original.Producer != "" &amp;&amp; author != "" </span><span class="cov0" title="0">{
                authorSim := rs.duplicateDetectionService.calculateTextSimilarity(original.Producer, author)
                score += authorSim * 0.4
        }</span>

        // Title similarity
        <span class="cov0" title="0">titleSim := rs.duplicateDetectionService.calculateTextSimilarity(original.Title, title)
        score += titleSim * 0.2

        return score</span>
}

func (rs *RecommendationService) calculateGitHubSimilarity(original *models.MediaMetadata, name, language string, stars int) float64 <span class="cov0" title="0">{
        score := 0.3 // Base score

        // Name similarity
        nameSim := rs.duplicateDetectionService.calculateTextSimilarity(original.Title, name)
        score += nameSim * 0.3

        // Language/genre similarity
        if original.Genre != "" &amp;&amp; language != "" </span><span class="cov0" title="0">{
                langSim := rs.duplicateDetectionService.calculateTextSimilarity(original.Genre, language)
                score += langSim * 0.2
        }</span>

        // Stars boost (popular repositories)
        <span class="cov0" title="0">if stars &gt; 1000 </span><span class="cov0" title="0">{
                score += 0.1
        }</span>
        <span class="cov0" title="0">if stars &gt; 10000 </span><span class="cov0" title="0">{
                score += 0.1
        }</span>

        <span class="cov0" title="0">return score</span>
}

// Utility methods
func (rs *RecommendationService) passesFilters(media *models.MediaMetadata, similarity float64, filters *RecommendationFilters) bool <span class="cov0" title="0">{
        if filters == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        // Minimum confidence check
        <span class="cov0" title="0">if similarity &lt; filters.MinConfidence </span><span class="cov0" title="0">{
                return false
        }</span>

        // Genre filter
        <span class="cov0" title="0">if len(filters.GenreFilter) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, genre := range filters.GenreFilter </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(media.Genre), strings.ToLower(genre)) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Year range filter (Year is *int, not string)
        <span class="cov0" title="0">if filters.YearRange != nil &amp;&amp; media.Year != nil </span><span class="cov0" title="0">{
                year := *media.Year
                if year &lt; filters.YearRange.StartYear || year &gt; filters.YearRange.EndYear </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Rating range filter (Rating is *float64)
        <span class="cov0" title="0">if filters.RatingRange != nil &amp;&amp; media.Rating != nil &amp;&amp; *media.Rating &gt; 0 </span><span class="cov0" title="0">{
                if *media.Rating &lt; filters.RatingRange.MinRating || *media.Rating &gt; filters.RatingRange.MaxRating </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Language filter
        <span class="cov0" title="0">if len(filters.LanguageFilter) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, lang := range filters.LanguageFilter </span><span class="cov0" title="0">{
                        if strings.EqualFold(media.Language, lang) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (rs *RecommendationService) passesExternalFilters(item *ExternalSimilarItem, filters *RecommendationFilters) bool <span class="cov0" title="0">{
        if filters == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        // Genre filter
        <span class="cov0" title="0">if len(filters.GenreFilter) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, genre := range filters.GenreFilter </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(item.Genre), strings.ToLower(genre)) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Year range filter
        <span class="cov0" title="0">if filters.YearRange != nil </span><span class="cov0" title="0">{
                year := parseYear(item.Year)
                if year != 0 &amp;&amp; (year &lt; filters.YearRange.StartYear || year &gt; filters.YearRange.EndYear) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Rating range filter
        <span class="cov0" title="0">if filters.RatingRange != nil &amp;&amp; item.Rating &gt; 0 </span><span class="cov0" title="0">{
                if item.Rating &lt; filters.RatingRange.MinRating || item.Rating &gt; filters.RatingRange.MaxRating </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// Link generation methods
func (rs *RecommendationService) generateDetailLink(media *models.MediaMetadata) string <span class="cov0" title="0">{
        mediaID := rs.generateMediaID(media)
        return fmt.Sprintf("/detail/%s", mediaID)
}</span>

func (rs *RecommendationService) generatePlayLink(media *models.MediaMetadata) string <span class="cov0" title="0">{
        // Note: MediaType doesn't exist in MediaMetadata, returning play link for all media
        mediaID := rs.generateMediaID(media)
        return fmt.Sprintf("/play/%s", mediaID)
}</span>

func (rs *RecommendationService) generateDownloadLink(media *models.MediaMetadata) string <span class="cov0" title="0">{
        mediaID := rs.generateMediaID(media)
        return fmt.Sprintf("/download/%s", mediaID)
}</span>

func (rs *RecommendationService) generateMediaID(media *models.MediaMetadata) string <span class="cov0" title="0">{
        // Generate a unique ID based on media ID (FilePath doesn't exist in MediaMetadata)
        return fmt.Sprintf("%d", media.ID)
}</span>

// Mock data generation for testing
func (rs *RecommendationService) generateMockLocalMedia(original *models.MediaMetadata) []*models.MediaMetadata <span class="cov0" title="0">{
        var mockMedia []*models.MediaMetadata

        // Create mock similar items based on genre
        // Note: This is simplified since MediaMetadata doesn't have MediaType, Artist, Author, FilePath, etc.
        year2022 := 2022
        year2023 := 2023
        rating82 := 8.2
        rating78 := 7.8
        rating85 := 8.5
        duration240 := 240
        duration195 := 195

        mockMedia = append(mockMedia, []*models.MediaMetadata{
                {
                        Title:    "Similar Movie 1",
                        Year:     original.Year,
                        Genre:    original.Genre,
                        Director: "Similar Director",
                        Rating:   &amp;rating82,
                },
                {
                        Title:    "Another " + original.Genre + " Film",
                        Year:     &amp;year2022,
                        Genre:    original.Genre,
                        Director: "Another Director",
                        Rating:   &amp;rating78,
                },
                {
                        Title:    "Similar Track",
                        Year:     original.Year,
                        Genre:    original.Genre,
                        Producer: "Similar Producer",
                        Duration: &amp;duration240,
                        Rating:   &amp;rating85,
                },
                {
                        Title:    "Another Media Item",
                        Year:     &amp;year2023,
                        Genre:    original.Genre,
                        Producer: "Different Producer",
                        Duration: &amp;duration195,
                },
        }...)

        return mockMedia
}</span>

// Utility helper functions
func (rs *RecommendationService) extractYear(dateStr string) string <span class="cov0" title="0">{
        if len(dateStr) &gt;= 4 </span><span class="cov0" title="0">{
                return dateStr[:4]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (rs *RecommendationService) parseLastFmMatch(matchStr string) float64 <span class="cov0" title="0">{
        // Last.fm match is typically a decimal string like "0.85"
        if matchStr == "" </span><span class="cov0" title="0">{
                return 0.5
        }</span>
        // This would normally parse the string to float
        // For simplicity, returning a mock value
        <span class="cov0" title="0">return 0.7</span>
}

func parseYear(yearStr string) int <span class="cov0" title="0">{
        if yearStr == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        // This would normally parse the year string to int
        // For simplicity, returning a mock value
        <span class="cov0" title="0">return 2023</span>
}

func abs(x float64) float64 <span class="cov0" title="0">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                return -x
        }</span>
        <span class="cov0" title="0">return x</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package services

import (
        "context"
        "database/sql"
        "fmt"
        "path/filepath"
        "sync"
        "time"

        "go.uber.org/zap"
)

// RenameEvent represents a file/directory rename operation
type RenameEvent struct {
        ID            int64      `json:"id"`
        StorageRootID int64      `json:"storage_root_id"`
        OldPath       string     `json:"old_path"`
        NewPath       string     `json:"new_path"`
        IsDirectory   bool       `json:"is_directory"`
        Size          int64      `json:"size"`
        FileHash      *string    `json:"file_hash,omitempty"`
        DetectedAt    time.Time  `json:"detected_at"`
        ProcessedAt   *time.Time `json:"processed_at,omitempty"`
        Status        string     `json:"status"` // pending, processed, failed
}

// PendingMove tracks a potential move operation
type PendingMove struct {
        Path        string
        StorageRoot string
        Size        int64
        FileHash    *string
        IsDirectory bool
        DeletedAt   time.Time
        FileID      int64
}

// RenameTracker efficiently detects and handles file/directory renames
type RenameTracker struct {
        db              *sql.DB
        logger          *zap.Logger
        PendingMoves    map[string]*PendingMove // key: storageRoot:hash:size
        PendingMovesMu  sync.RWMutex
        cleanupInterval time.Duration
        moveWindow      time.Duration // time window to detect moves
        stopCh          chan struct{}
        wg              sync.WaitGroup
}

// NewRenameTracker creates a new rename tracker
func NewRenameTracker(db *sql.DB, logger *zap.Logger) *RenameTracker <span class="cov8" title="10">{
        return &amp;RenameTracker{
                db:              db,
                logger:          logger,
                PendingMoves:    make(map[string]*PendingMove),
                cleanupInterval: 30 * time.Second,
                moveWindow:      5 * time.Second, // moves should happen within 5 seconds
                stopCh:          make(chan struct{}),
        }
}</span>

// Start begins the rename tracking service
func (rt *RenameTracker) Start() error <span class="cov1" title="1">{
        rt.logger.Info("Starting rename tracker service")

        // Start cleanup worker
        rt.wg.Add(1)
        go rt.cleanupWorker()

        // Create rename tracking tables if they don't exist
        if err := rt.InitializeTables(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize rename tracking tables: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Stop stops the rename tracking service
func (rt *RenameTracker) Stop() <span class="cov1" title="1">{
        rt.logger.Info("Stopping rename tracker service")
        close(rt.stopCh)
        rt.wg.Wait()
        rt.logger.Info("Rename tracker service stopped")
}</span>

// TrackDelete tracks a file/directory deletion for potential move detection
func (rt *RenameTracker) TrackDelete(ctx context.Context, fileID int64, path, storageRoot string, size int64, fileHash *string, isDirectory bool) <span class="cov7" title="7">{
        // Create move tracking key
        key := rt.CreateMoveKey(storageRoot, fileHash, size, isDirectory)

        rt.PendingMovesMu.Lock()
        rt.PendingMoves[key] = &amp;PendingMove{
                Path:        path,
                StorageRoot: storageRoot,
                Size:        size,
                FileHash:    fileHash,
                IsDirectory: isDirectory,
                DeletedAt:   time.Now(),
                FileID:      fileID,
        }
        rt.PendingMovesMu.Unlock()

        rt.logger.Debug("Tracking potential move deletion",
                zap.String("path", path),
                zap.String("storage_root", storageRoot),
                zap.Int64("file_id", fileID))
}</span>

// DetectCreate checks if a file creation is actually a move from a deletion
func (rt *RenameTracker) DetectCreate(ctx context.Context, newPath, storageRoot string, size int64, fileHash *string, isDirectory bool) (*PendingMove, bool) <span class="cov4" title="3">{
        key := rt.CreateMoveKey(storageRoot, fileHash, size, isDirectory)

        rt.PendingMovesMu.Lock()
        pendingMove, exists := rt.PendingMoves[key]
        if exists </span><span class="cov3" title="2">{
                delete(rt.PendingMoves, key)
        }</span>
        <span class="cov4" title="3">rt.PendingMovesMu.Unlock()

        if !exists </span><span class="cov1" title="1">{
                return nil, false
        }</span>

        // Check if the move happened within the time window
        <span class="cov3" title="2">if time.Since(pendingMove.DeletedAt) &gt; rt.moveWindow </span><span class="cov1" title="1">{
                rt.logger.Debug("Move window expired",
                        zap.String("old_path", pendingMove.Path),
                        zap.String("new_path", newPath),
                        zap.Duration("elapsed", time.Since(pendingMove.DeletedAt)))
                return nil, false
        }</span>

        <span class="cov1" title="1">rt.logger.Info("Detected file/directory move",
                zap.String("old_path", pendingMove.Path),
                zap.String("new_path", newPath),
                zap.String("storage_root", storageRoot),
                zap.Bool("is_directory", isDirectory))

        return pendingMove, true</span>
}

// ProcessMove handles a detected move operation efficiently
func (rt *RenameTracker) ProcessMove(ctx context.Context, oldMove *PendingMove, newPath string) error <span class="cov3" title="2">{
        tx, err := rt.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov3" title="2">defer tx.Rollback()

        // Record the rename event
        renameEventID, err := rt.recordRenameEvent(tx, oldMove, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to record rename event: %w", err)
        }</span>

        <span class="cov3" title="2">if oldMove.IsDirectory </span><span class="cov1" title="1">{
                // Handle directory move - update all child paths
                err = rt.moveDirectory(tx, oldMove.Path, newPath, oldMove.StorageRoot)
        }</span> else<span class="cov1" title="1"> {
                // Handle file move - update single file
                err = rt.moveFile(tx, oldMove.FileID, newPath)
        }</span>

        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                // Mark rename event as failed
                rt.markRenameEventStatus(tx, renameEventID, "failed")
                return fmt.Errorf("failed to process move: %w", err)
        }</span>

        // Mark rename event as processed
        <span class="cov3" title="2">if err = rt.markRenameEventStatus(tx, renameEventID, "processed"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark rename event as processed: %w", err)
        }</span>

        <span class="cov3" title="2">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit move transaction: %w", err)
        }</span>

        <span class="cov3" title="2">rt.logger.Info("Successfully processed move operation",
                zap.String("old_path", oldMove.Path),
                zap.String("new_path", newPath),
                zap.Bool("is_directory", oldMove.IsDirectory),
                zap.Int64("rename_event_id", renameEventID))

        return nil</span>
}

// moveFile updates a single file's path and metadata
func (rt *RenameTracker) moveFile(tx *sql.Tx, fileID int64, newPath string) error <span class="cov1" title="1">{
        // Extract new filename and directory info
        newName := filepath.Base(newPath)
        newDir := filepath.Dir(newPath)

        // Get parent directory ID
        var parentID *int64
        if newDir != "/" &amp;&amp; newDir != "." </span><span class="cov0" title="0">{
                parentQuery := `SELECT id FROM files WHERE path = ? AND is_directory = true LIMIT 1`
                err := tx.QueryRow(parentQuery, newDir).Scan(&amp;parentID)
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get parent directory: %w", err)
                }</span>
        }

        // Update file record
        <span class="cov1" title="1">updateQuery := `
                UPDATE files
                SET path = ?, name = ?, parent_id = ?, updated_at = CURRENT_TIMESTAMP,
                    last_scan_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := tx.Exec(updateQuery, newPath, newName, parentID, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update file path: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// moveDirectory updates a directory and all its children
func (rt *RenameTracker) moveDirectory(tx *sql.Tx, oldPath, newPath, storageRoot string) error <span class="cov1" title="1">{
        // Get all files/directories that need to be updated
        query := `
                SELECT id, path, is_directory
                FROM files
                WHERE storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)
                  AND (path = ? OR path LIKE ?)
                ORDER BY LENGTH(path) ASC` // Process parents before children

        oldPathPattern := oldPath + "/%"
        rows, err := tx.Query(query, storageRoot, oldPath, oldPathPattern)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query directory contents: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        type fileUpdate struct {
                ID          int64
                OldPath     string
                IsDirectory bool
        }

        var updates []fileUpdate
        for rows.Next() </span><span class="cov3" title="2">{
                var update fileUpdate
                if err := rows.Scan(&amp;update.ID, &amp;update.OldPath, &amp;update.IsDirectory); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan file for update: %w", err)
                }</span>
                <span class="cov3" title="2">updates = append(updates, update)</span>
        }

        // Update each file/directory path
        <span class="cov1" title="1">for _, update := range updates </span><span class="cov3" title="2">{
                var updatedPath string
                if update.OldPath == oldPath </span><span class="cov1" title="1">{
                        // This is the directory itself
                        updatedPath = newPath
                }</span> else<span class="cov1" title="1"> {
                        // This is a child - replace the old path prefix with new path
                        relativePath := update.OldPath[len(oldPath):]
                        updatedPath = newPath + relativePath
                }</span>

                // Update the file record
                <span class="cov3" title="2">newName := filepath.Base(updatedPath)
                newDir := filepath.Dir(updatedPath)

                // Get parent directory ID
                var parentID *int64
                if newDir != "/" &amp;&amp; newDir != "." &amp;&amp; newDir != newPath </span><span class="cov0" title="0">{
                        parentQuery := `SELECT id FROM files WHERE path = ? AND is_directory = true LIMIT 1`
                        err := tx.QueryRow(parentQuery, newDir).Scan(&amp;parentID)
                        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get parent directory for %s: %w", updatedPath, err)
                        }</span>
                }

                <span class="cov3" title="2">updateQuery := `
                        UPDATE files
                        SET path = ?, name = ?, parent_id = ?, updated_at = CURRENT_TIMESTAMP,
                            last_scan_at = CURRENT_TIMESTAMP
                        WHERE id = ?`

                _, err := tx.Exec(updateQuery, updatedPath, newName, parentID, update.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update path for file ID %d: %w", update.ID, err)
                }</span>

                <span class="cov3" title="2">rt.logger.Debug("Updated file path",
                        zap.String("old_path", update.OldPath),
                        zap.String("new_path", updatedPath),
                        zap.Int64("file_id", update.ID))</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// recordRenameEvent creates a record of the rename operation
func (rt *RenameTracker) recordRenameEvent(tx *sql.Tx, oldMove *PendingMove, newPath string) (int64, error) <span class="cov3" title="2">{
        query := `
                INSERT INTO rename_events (storage_root_id, old_path, new_path, is_directory, size, file_hash, detected_at, status)
                VALUES ((SELECT id FROM storage_roots WHERE name = ?), ?, ?, ?, ?, ?, ?, 'pending')`

        result, err := tx.Exec(query, oldMove.StorageRoot, oldMove.Path, newPath, oldMove.IsDirectory, oldMove.Size, oldMove.FileHash, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to insert rename event: %w", err)
        }</span>

        <span class="cov3" title="2">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get rename event ID: %w", err)
        }</span>

        <span class="cov3" title="2">return id, nil</span>
}

// markRenameEventStatus updates the status of a rename event
func (rt *RenameTracker) markRenameEventStatus(tx *sql.Tx, eventID int64, status string) error <span class="cov3" title="2">{
        query := `UPDATE rename_events SET status = ?, processed_at = CURRENT_TIMESTAMP WHERE id = ?`
        _, err := tx.Exec(query, status, eventID)
        return err
}</span>

// createMoveKey creates a unique key for tracking potential moves
func (rt *RenameTracker) CreateMoveKey(storageRoot string, fileHash *string, size int64, isDirectory bool) string <span class="cov10" title="14">{
        hashStr := "nil"
        if fileHash != nil </span><span class="cov9" title="12">{
                hashStr = *fileHash
        }</span>

        <span class="cov10" title="14">dirStr := "false"
        if isDirectory </span><span class="cov1" title="1">{
                dirStr = "true"
        }</span>

        <span class="cov10" title="14">return fmt.Sprintf("%s:%s:%d:%s", storageRoot, hashStr, size, dirStr)</span>
}

// cleanupWorker periodically cleans up expired pending moves
func (rt *RenameTracker) cleanupWorker() <span class="cov1" title="1">{
        defer rt.wg.Done()

        ticker := time.NewTicker(rt.cleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-rt.stopCh:<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rt.cleanupExpiredMoves()</span>
                }
        }
}

// cleanupExpiredMoves removes pending moves that have exceeded the time window
func (rt *RenameTracker) cleanupExpiredMoves() <span class="cov1" title="1">{
        rt.PendingMovesMu.Lock()
        defer rt.PendingMovesMu.Unlock()

        now := time.Now()
        expiredKeys := make([]string, 0)

        for key, move := range rt.PendingMoves </span><span class="cov3" title="2">{
                if now.Sub(move.DeletedAt) &gt; rt.moveWindow </span><span class="cov3" title="2">{
                        expiredKeys = append(expiredKeys, key)
                }</span>
        }

        <span class="cov1" title="1">for _, key := range expiredKeys </span><span class="cov3" title="2">{
                move := rt.PendingMoves[key]
                delete(rt.PendingMoves, key)

                rt.logger.Debug("Cleaned up expired pending move",
                        zap.String("path", move.Path),
                        zap.String("storage_root", move.StorageRoot),
                        zap.Duration("age", now.Sub(move.DeletedAt)))
        }</span>

        <span class="cov1" title="1">if len(expiredKeys) &gt; 0 </span><span class="cov1" title="1">{
                rt.logger.Debug("Cleaned up expired pending moves", zap.Int("count", len(expiredKeys)))
        }</span>
}

// GetRenameEvents returns recent rename events for monitoring
func (rt *RenameTracker) GetRenameEvents(ctx context.Context, limit int) ([]RenameEvent, error) <span class="cov1" title="1">{
        query := `
                SELECT re.id, re.storage_root_id, re.old_path, re.new_path, re.is_directory,
                       re.size, re.file_hash, re.detected_at, re.processed_at, re.status
                FROM rename_events re
                ORDER BY re.detected_at DESC
                LIMIT ?`

        rows, err := rt.db.QueryContext(ctx, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query rename events: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        var events []RenameEvent
        for rows.Next() </span><span class="cov3" title="2">{
                var event RenameEvent
                err := rows.Scan(
                        &amp;event.ID, &amp;event.StorageRootID, &amp;event.OldPath, &amp;event.NewPath,
                        &amp;event.IsDirectory, &amp;event.Size, &amp;event.FileHash, &amp;event.DetectedAt,
                        &amp;event.ProcessedAt, &amp;event.Status,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan rename event: %w", err)
                }</span>
                <span class="cov3" title="2">events = append(events, event)</span>
        }

        <span class="cov1" title="1">return events, nil</span>
}

// GetStatistics returns statistics about rename detection
func (rt *RenameTracker) GetStatistics() map[string]interface{} <span class="cov1" title="1">{
        rt.PendingMovesMu.RLock()
        pendingCount := len(rt.PendingMoves)
        rt.PendingMovesMu.RUnlock()

        stats := map[string]interface{}{
                "pending_moves": pendingCount,
                "move_window":   rt.moveWindow.String(),
        }

        // Get database statistics
        var totalRenames, successfulRenames int
        rt.db.QueryRow("SELECT COUNT(*) FROM rename_events").Scan(&amp;totalRenames)
        rt.db.QueryRow("SELECT COUNT(*) FROM rename_events WHERE status = 'processed'").Scan(&amp;successfulRenames)

        stats["total_renames"] = totalRenames
        stats["successful_renames"] = successfulRenames

        if totalRenames &gt; 0 </span><span class="cov1" title="1">{
                stats["success_rate"] = float64(successfulRenames) / float64(totalRenames) * 100
        }</span> else<span class="cov0" title="0"> {
                stats["success_rate"] = 0.0
        }</span>

        <span class="cov1" title="1">return stats</span>
}

// InitializeTables creates the rename tracking tables
func (rt *RenameTracker) InitializeTables() error <span class="cov6" title="5">{
        query := `
                CREATE TABLE IF NOT EXISTS rename_events (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        storage_root_id INTEGER NOT NULL,
                        old_path TEXT NOT NULL,
                        new_path TEXT NOT NULL,
                        is_directory BOOLEAN NOT NULL,
                        size INTEGER NOT NULL,
                        file_hash TEXT,
                        detected_at TIMESTAMP NOT NULL,
                        processed_at TIMESTAMP,
                        status TEXT NOT NULL DEFAULT 'pending',
                        FOREIGN KEY (storage_root_id) REFERENCES storage_roots (id)
                );

                CREATE INDEX IF NOT EXISTS idx_rename_events_storage_root ON rename_events(storage_root_id);
                CREATE INDEX IF NOT EXISTS idx_rename_events_detected_at ON rename_events(detected_at);
                CREATE INDEX IF NOT EXISTS idx_rename_events_status ON rename_events(status);
        `

        _, err := rt.db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create rename tracking tables: %w", err)
        }</span>

        <span class="cov6" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package services

import (
        "catalogizer/internal/config"
        "catalogizer/internal/models"
        "context"
        "fmt"
        "io"
        "net"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/hirochachacha/go-smb2"
        "go.uber.org/zap"
)

// SMBServiceInterface defines the interface for SMB operations
type SMBServiceInterface interface {
        GetHosts() []string
        ListFiles(hostName, path string) ([]os.FileInfo, error)
        DownloadFile(hostName, remotePath, localPath string) error
        UploadFile(hostName, localPath, remotePath string) error
        CopyFile(sourceHost, sourcePath, destHost, destPath string) error
        CreateRemoteDir(share *smb2.Share, path string) error
        FileExists(hostName, path string) (bool, error)
        ListDirectory(hostName, path string) ([]*models.FileInfo, error)
        IsConnected(hostName string) bool
        GetFileSize(hostName, path string) (int64, error)
        CreateDirectory(hostName, path string) error
        DeleteDirectory(hostName, path string) error
        DirectoryExists(hostName, path string) (bool, error)
        IsValidSMBPath(path string) bool
        ParseSMBPath(path string) models.SMBPath
}

type SMBService struct {
        config *config.Config
        logger *zap.Logger
}

func NewSMBService(cfg *config.Config, logger *zap.Logger) *SMBService <span class="cov0" title="0">{
        return &amp;SMBService{
                config: cfg,
                logger: logger,
        }
}</span>

func (s *SMBService) getConnection(hostName string) (*smb2.Session, error) <span class="cov0" title="0">{
        var smbHost *config.SMBHost
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        smbHost = &amp;host
                        break</span>
                }
        }

        <span class="cov0" title="0">if smbHost == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SMB host not found: %s", hostName)
        }</span>

        <span class="cov0" title="0">conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", smbHost.Host, smbHost.Port))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to SMB host: %w", err)
        }</span>

        <span class="cov0" title="0">d := &amp;smb2.Dialer{
                Initiator: &amp;smb2.NTLMInitiator{
                        User:     smbHost.Username,
                        Password: smbHost.Password,
                        Domain:   smbHost.Domain,
                },
        }

        session, err := d.Dial(conn)
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to create SMB session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *SMBService) ListFiles(hostName, path string) ([]os.FileInfo, error) <span class="cov0" title="0">{
        session, err := s.getConnection(hostName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        var smbHost *config.SMBHost
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        smbHost = &amp;host
                        break</span>
                }
        }

        <span class="cov0" title="0">share, err := session.Mount(smbHost.Share)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to mount share: %w", err)
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        files, err := share.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read directory: %w", err)
        }</span>

        <span class="cov0" title="0">return files, nil</span>
}

func (s *SMBService) DownloadFile(hostName, remotePath, localPath string) error <span class="cov0" title="0">{
        session, err := s.getConnection(hostName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        var smbHost *config.SMBHost
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        smbHost = &amp;host
                        break</span>
                }
        }

        <span class="cov0" title="0">share, err := session.Mount(smbHost.Share)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mount share: %w", err)
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        // Create local directory if it doesn't exist
        if err := os.MkdirAll(filepath.Dir(localPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local directory: %w", err)
        }</span>

        // Open remote file
        <span class="cov0" title="0">remoteFile, err := share.Open(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open remote file: %w", err)
        }</span>
        <span class="cov0" title="0">defer remoteFile.Close()

        // Create local file
        localFile, err := os.Create(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local file: %w", err)
        }</span>
        <span class="cov0" title="0">defer localFile.Close()

        // Copy data in chunks
        buf := make([]byte, s.config.SMB.ChunkSize)
        _, err = io.CopyBuffer(localFile, remoteFile, buf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("File downloaded successfully",
                zap.String("remote", remotePath),
                zap.String("local", localPath))

        return nil</span>
}

func (s *SMBService) UploadFile(hostName, localPath, remotePath string) error <span class="cov0" title="0">{
        session, err := s.getConnection(hostName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        var smbHost *config.SMBHost
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        smbHost = &amp;host
                        break</span>
                }
        }

        <span class="cov0" title="0">share, err := session.Mount(smbHost.Share)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mount share: %w", err)
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        // Create remote directory if it doesn't exist
        remoteDir := filepath.Dir(remotePath)
        if remoteDir != "." &amp;&amp; remoteDir != "/" </span><span class="cov0" title="0">{
                if err := s.CreateRemoteDir(share, remoteDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create remote directory: %w", err)
                }</span>
        }

        // Open local file
        <span class="cov0" title="0">localFile, err := os.Open(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open local file: %w", err)
        }</span>
        <span class="cov0" title="0">defer localFile.Close()

        // Create remote file
        remoteFile, err := share.Create(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create remote file: %w", err)
        }</span>
        <span class="cov0" title="0">defer remoteFile.Close()

        // Copy data in chunks
        buf := make([]byte, s.config.SMB.ChunkSize)
        _, err = io.CopyBuffer(remoteFile, localFile, buf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("File uploaded successfully",
                zap.String("local", localPath),
                zap.String("remote", remotePath))

        return nil</span>
}

func (s *SMBService) CopyFile(sourceHost, sourcePath, destHost, destPath string) error <span class="cov0" title="0">{
        _, cancel := context.WithTimeout(context.Background(), time.Duration(s.config.SMB.Timeout)*time.Second)
        defer cancel()

        // Create a temporary file for the transfer
        tempFile, err := os.CreateTemp(s.config.Catalog.TempDir, "smb_copy_*")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp file: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempFile.Name())
        defer tempFile.Close()

        // Download from source
        if err := s.DownloadFile(sourceHost, sourcePath, tempFile.Name()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download from source: %w", err)
        }</span>

        // Upload to destination
        <span class="cov0" title="0">if err := s.UploadFile(destHost, tempFile.Name(), destPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload to destination: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("File copied successfully",
                zap.String("source", fmt.Sprintf("%s:%s", sourceHost, sourcePath)),
                zap.String("destination", fmt.Sprintf("%s:%s", destHost, destPath)))

        return nil</span>
}

func (s *SMBService) CreateRemoteDir(share *smb2.Share, path string) error <span class="cov0" title="0">{
        parts := strings.Split(path, "/")
        currentPath := ""

        for _, part := range parts </span><span class="cov0" title="0">{
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if currentPath == "" </span><span class="cov0" title="0">{
                        currentPath = part
                }</span> else<span class="cov0" title="0"> {
                        currentPath = currentPath + "/" + part
                }</span>

                // Try to create the directory (ignore error if it already exists)
                <span class="cov0" title="0">err := share.Mkdir(currentPath, 0755)
                if err != nil &amp;&amp; !strings.Contains(err.Error(), "already exists") </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %w", currentPath, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SMBService) FileExists(hostName, path string) (bool, error) <span class="cov0" title="0">{
        session, err := s.getConnection(hostName)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        var smbHost *config.SMBHost
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        smbHost = &amp;host
                        break</span>
                }
        }

        <span class="cov0" title="0">share, err := session.Mount(smbHost.Share)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to mount share: %w", err)
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        _, err = share.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to stat file: %w", err)</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

func (s *SMBService) GetHosts() []string <span class="cov0" title="0">{
        var hosts []string
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                hosts = append(hosts, host.Name)
        }</span>
        <span class="cov0" title="0">return hosts</span>
}

// IsValidSMBPath checks if the given path is a valid SMB path
func (s *SMBService) IsValidSMBPath(path string) bool <span class="cov0" title="0">{
        // Basic validation for SMB paths like \\host\share\path
        if !strings.HasPrefix(path, "\\\\") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">parts := strings.Split(strings.TrimPrefix(path, "\\\\"), "\\")
        return len(parts) &gt;= 2 &amp;&amp; parts[0] != "" &amp;&amp; parts[1] != ""</span>
}

// ParseSMBPath parses an SMB path into its components
func (s *SMBService) ParseSMBPath(path string) models.SMBPath <span class="cov0" title="0">{
        smbPath := models.SMBPath{Valid: false}

        if !s.IsValidSMBPath(path) </span><span class="cov0" title="0">{
                return smbPath
        }</span>

        // Remove leading \\ and split
        <span class="cov0" title="0">parts := strings.Split(strings.TrimPrefix(path, "\\\\"), "\\")
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return smbPath
        }</span>

        <span class="cov0" title="0">smbPath.Server = parts[0]
        smbPath.Share = parts[1]
        if len(parts) &gt; 2 </span><span class="cov0" title="0">{
                smbPath.Path = strings.Join(parts[2:], "\\")
        }</span>
        <span class="cov0" title="0">smbPath.Valid = true

        return smbPath</span>
}

// Connect establishes a connection to an SMB host (stub implementation)
func (s *SMBService) Connect(hostName string) error <span class="cov0" title="0">{
        // Check if host exists in config
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        return nil // Connection successful
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("SMB host not found: %s", hostName)</span>
}

// ListDirectory lists files in a directory on an SMB host
func (s *SMBService) ListDirectory(hostName, path string) ([]*models.FileInfo, error) <span class="cov0" title="0">{
        files, err := s.ListFiles(hostName, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result []*models.FileInfo
        for _, file := range files </span><span class="cov0" title="0">{
                fileInfo := &amp;models.FileInfo{
                        Name:         file.Name(),
                        Path:         path + "/" + file.Name(),
                        IsDirectory:  file.IsDir(),
                        Size:         file.Size(),
                        LastModified: file.ModTime(),
                }
                result = append(result, fileInfo)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// IsConnected checks if connected to an SMB host
func (s *SMBService) IsConnected(hostName string) bool <span class="cov0" title="0">{
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetFileSize gets the size of a file on an SMB host
func (s *SMBService) GetFileSize(hostName, path string) (int64, error) <span class="cov0" title="0">{
        files, err := s.ListFiles(hostName, path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("file not found")
        }</span>
        <span class="cov0" title="0">return files[0].Size(), nil</span>
}

// CreateDirectory creates a directory on an SMB host
func (s *SMBService) CreateDirectory(hostName, path string) error <span class="cov0" title="0">{
        // This is a stub implementation
        return fmt.Errorf("CreateDirectory not implemented")
}</span>

// DeleteDirectory deletes a directory on an SMB host
func (s *SMBService) DeleteDirectory(hostName, path string) error <span class="cov0" title="0">{
        // This is a stub implementation
        return fmt.Errorf("DeleteDirectory not implemented")
}</span>

// DirectoryExists checks if a directory exists on an SMB host
func (s *SMBService) DirectoryExists(hostName, path string) (bool, error) <span class="cov0" title="0">{
        // This is a stub implementation
        return false, fmt.Errorf("DirectoryExists not implemented")
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package services

import (
        "context"
        "fmt"
        "net"
        "strings"
        "time"

        "github.com/hirochachacha/go-smb2"
        "go.uber.org/zap"
)

// SMBShareInfo represents an SMB share
type SMBShareInfo struct {
        Host        string  `json:"host"`
        ShareName   string  `json:"share_name"`
        Path        string  `json:"path"`
        Writable    bool    `json:"writable"`
        Description *string `json:"description"`
}

// SMBFileEntry represents a file or directory in an SMB share
type SMBFileEntry struct {
        Name        string  `json:"name"`
        Path        string  `json:"path"`
        IsDirectory bool    `json:"is_directory"`
        Size        *int64  `json:"size"`
        Modified    *string `json:"modified"`
}

// SMBConnectionConfig represents SMB connection parameters
type SMBConnectionConfig struct {
        Host     string  `json:"host"`
        Port     int     `json:"port"`
        Share    string  `json:"share"`
        Username string  `json:"username"`
        Password string  `json:"password"`
        Domain   *string `json:"domain"`
}

// SMBDiscoveryService provides SMB share discovery and testing
type SMBDiscoveryService struct {
        logger  *zap.Logger
        timeout time.Duration
}

// NewSMBDiscoveryService creates a new SMB discovery service
func NewSMBDiscoveryService(logger *zap.Logger) *SMBDiscoveryService <span class="cov3" title="2">{
        return &amp;SMBDiscoveryService{
                logger:  logger,
                timeout: 10 * time.Second,
        }
}</span>

// DiscoverShares discovers available SMB shares on a host
func (s *SMBDiscoveryService) DiscoverShares(ctx context.Context, host string, username, password string, domain *string) ([]SMBShareInfo, error) <span class="cov0" title="0">{
        s.logger.Info("Discovering SMB shares", zap.String("host", host), zap.String("username", username))

        // Establish connection
        conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:445", host), s.timeout)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to connect to SMB host", zap.String("host", host), zap.Error(err))
                return nil, fmt.Errorf("failed to connect to SMB host %s: %w", host, err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create SMB session
        d := &amp;smb2.Dialer{
                Initiator: &amp;smb2.NTLMInitiator{
                        User:     username,
                        Password: password,
                        Domain:   getStringValue(domain),
                },
        }

        session, err := d.Dial(conn)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create SMB session", zap.String("host", host), zap.Error(err))
                return nil, fmt.Errorf("failed to create SMB session: %w", err)
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        // Try to enumerate shares using IPC$ administrative share
        shares, err := s.enumerateShares(session, host)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to enumerate shares via IPC$, falling back to common shares", zap.Error(err))
                // Fallback to common share names
                return s.getCommonShares(ctx, host, username, password, domain), nil
        }</span>

        <span class="cov0" title="0">return shares, nil</span>
}

// enumerateShares attempts to enumerate shares using administrative interfaces
func (s *SMBDiscoveryService) enumerateShares(session *smb2.Session, host string) ([]SMBShareInfo, error) <span class="cov0" title="0">{
        // This is a simplified implementation. In practice, you might need to use
        // Windows administrative APIs through SMB to enumerate shares properly.
        // For now, we'll try to mount IPC$ and see if we can get share information.

        // Try common administrative share names to detect existence
        commonShares := []string{
                "C$", "D$", "E$", "F$", "admin$", "print$", "ipc$",
                "shared", "public", "media", "downloads", "documents",
                "music", "videos", "pictures", "backup", "data",
        }

        var availableShares []SMBShareInfo

        for _, shareName := range commonShares </span><span class="cov0" title="0">{
                if s.testShareAccess(session, shareName) </span><span class="cov0" title="0">{
                        availableShares = append(availableShares, SMBShareInfo{
                                Host:        host,
                                ShareName:   shareName,
                                Path:        fmt.Sprintf("\\\\%s\\%s", host, shareName),
                                Writable:    false, // We don't test write access here
                                Description: getShareDescription(shareName),
                        })
                }</span>
        }

        <span class="cov0" title="0">return availableShares, nil</span>
}

// testShareAccess tests if a share can be accessed
func (s *SMBDiscoveryService) testShareAccess(session *smb2.Session, shareName string) bool <span class="cov0" title="0">{
        share, err := session.Mount(shareName)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        // Try to list the root directory
        _, err = share.ReadDir(".")
        return err == nil</span>
}

// getCommonShares returns common share names to try
func (s *SMBDiscoveryService) getCommonShares(ctx context.Context, host, username, password string, domain *string) []SMBShareInfo <span class="cov1" title="1">{
        commonShares := []SMBShareInfo{
                {Host: host, ShareName: "shared", Path: fmt.Sprintf("\\\\%s\\shared", host), Description: smbStringPtr("Shared folder")},
                {Host: host, ShareName: "public", Path: fmt.Sprintf("\\\\%s\\public", host), Description: smbStringPtr("Public folder")},
                {Host: host, ShareName: "media", Path: fmt.Sprintf("\\\\%s\\media", host), Description: smbStringPtr("Media files")},
                {Host: host, ShareName: "downloads", Path: fmt.Sprintf("\\\\%s\\downloads", host), Description: smbStringPtr("Downloads")},
                {Host: host, ShareName: "documents", Path: fmt.Sprintf("\\\\%s\\documents", host), Description: smbStringPtr("Documents")},
                {Host: host, ShareName: "music", Path: fmt.Sprintf("\\\\%s\\music", host), Description: smbStringPtr("Music files")},
                {Host: host, ShareName: "videos", Path: fmt.Sprintf("\\\\%s\\videos", host), Description: smbStringPtr("Video files")},
                {Host: host, ShareName: "pictures", Path: fmt.Sprintf("\\\\%s\\pictures", host), Description: smbStringPtr("Pictures")},
                {Host: host, ShareName: "backup", Path: fmt.Sprintf("\\\\%s\\backup", host), Description: smbStringPtr("Backup files")},
        }

        // Test which ones are actually accessible
        var accessibleShares []SMBShareInfo
        for _, share := range commonShares </span><span class="cov9" title="9">{
                if s.TestConnection(ctx, SMBConnectionConfig{
                        Host:     host,
                        Port:     445,
                        Share:    share.ShareName,
                        Username: username,
                        Password: password,
                        Domain:   domain,
                }) </span><span class="cov0" title="0">{
                        accessibleShares = append(accessibleShares, share)
                }</span>
        }

        // If no shares are accessible (e.g., host unreachable), return common shares as suggestions
        <span class="cov1" title="1">if len(accessibleShares) == 0 </span><span class="cov1" title="1">{
                return commonShares
        }</span>

        <span class="cov0" title="0">return accessibleShares</span>
}

// TestConnection tests an SMB connection with the provided credentials
func (s *SMBDiscoveryService) TestConnection(ctx context.Context, config SMBConnectionConfig) bool <span class="cov10" title="10">{
        s.logger.Info("Testing SMB connection",
                zap.String("host", config.Host),
                zap.String("share", config.Share),
                zap.String("username", config.Username))

        // Establish connection
        conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", config.Host, config.Port), s.timeout)
        if err != nil </span><span class="cov10" title="10">{
                s.logger.Debug("Failed to connect to SMB host", zap.String("host", config.Host), zap.Error(err))
                return false
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create SMB session
        d := &amp;smb2.Dialer{
                Initiator: &amp;smb2.NTLMInitiator{
                        User:     config.Username,
                        Password: config.Password,
                        Domain:   getStringValue(config.Domain),
                },
        }

        session, err := d.Dial(conn)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to create SMB session", zap.String("host", config.Host), zap.Error(err))
                return false
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        // Try to mount the share
        share, err := session.Mount(config.Share)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to mount SMB share", zap.String("share", config.Share), zap.Error(err))
                return false
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        // Try to list the root directory
        _, err = share.ReadDir(".")
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to read SMB share directory", zap.String("share", config.Share), zap.Error(err))
                return false
        }</span>

        <span class="cov0" title="0">s.logger.Info("SMB connection test successful", zap.String("host", config.Host), zap.String("share", config.Share))
        return true</span>
}

// BrowseShare browses files and directories in an SMB share
func (s *SMBDiscoveryService) BrowseShare(ctx context.Context, config SMBConnectionConfig, path string) ([]SMBFileEntry, error) <span class="cov0" title="0">{
        s.logger.Info("Browsing SMB share",
                zap.String("host", config.Host),
                zap.String("share", config.Share),
                zap.String("path", path))

        // Establish connection
        conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", config.Host, config.Port), s.timeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to SMB host %s: %w", config.Host, err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create SMB session
        d := &amp;smb2.Dialer{
                Initiator: &amp;smb2.NTLMInitiator{
                        User:     config.Username,
                        Password: config.Password,
                        Domain:   getStringValue(config.Domain),
                },
        }

        session, err := d.Dial(conn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create SMB session: %w", err)
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        // Mount the share
        share, err := session.Mount(config.Share)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to mount SMB share: %w", err)
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        // List directory contents
        entries, err := share.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read directory %s: %w", path, err)
        }</span>

        // Convert to our format
        <span class="cov0" title="0">var fileEntries []SMBFileEntry
        for _, entry := range entries </span><span class="cov0" title="0">{
                var size *int64
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        entrySize := entry.Size()
                        size = &amp;entrySize
                }</span>

                <span class="cov0" title="0">modTime := entry.ModTime().Format("2006-01-02 15:04:05")

                fileEntries = append(fileEntries, SMBFileEntry{
                        Name:        entry.Name(),
                        Path:        path + "/" + entry.Name(),
                        IsDirectory: entry.IsDir(),
                        Size:        size,
                        Modified:    &amp;modTime,
                })</span>
        }

        <span class="cov0" title="0">return fileEntries, nil</span>
}

// Helper functions
func getStringValue(s *string) string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *s</span>
}

func smbStringPtr(s string) *string <span class="cov9" title="9">{
        return &amp;s
}</span>

func getShareDescription(shareName string) *string <span class="cov0" title="0">{
        descriptions := map[string]string{
                "C$":        "System drive (administrative)",
                "D$":        "Data drive (administrative)",
                "E$":        "Additional drive (administrative)",
                "F$":        "Additional drive (administrative)",
                "admin$":    "Administrative share",
                "print$":    "Printer drivers",
                "ipc$":      "Inter-process communication",
                "shared":    "Shared folder",
                "public":    "Public folder",
                "media":     "Media files",
                "downloads": "Downloads",
                "documents": "Documents",
                "music":     "Music files",
                "videos":    "Video files",
                "pictures":  "Pictures",
                "backup":    "Backup files",
                "data":      "Data files",
        }

        if desc, exists := descriptions[strings.ToLower(shareName)]; exists </span><span class="cov0" title="0">{
                return &amp;desc
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package services

import (
        "context"
        "database/sql"
        "fmt"
        "io"
        "net/http"
        "regexp"
        "strconv"
        "strings"
        "time"

        "go.uber.org/zap"
)

// SubtitleService handles subtitle management, downloading, and translation
type SubtitleService struct {
        db                 *sql.DB
        logger             *zap.Logger
        translationService *TranslationService
        httpClient         *http.Client
        apiKeys            map[string]string
        cacheDir           string
}

// SubtitleProvider represents different subtitle providers
type SubtitleProvider string

const (
        ProviderOpenSubtitles SubtitleProvider = "opensubtitles"
        ProviderSubDB         SubtitleProvider = "subdb"
        ProviderYifySubtitles SubtitleProvider = "yifysubtitles"
        ProviderSubscene      SubtitleProvider = "subscene"
        ProviderAddic7ed      SubtitleProvider = "addic7ed"
)

// SubtitleSearchRequest represents a subtitle search request
type SubtitleSearchRequest struct {
        MediaPath     string             `json:"media_path"`
        Title         *string            `json:"title,omitempty"`
        Year          *int               `json:"year,omitempty"`
        Season        *int               `json:"season,omitempty"`
        Episode       *int               `json:"episode,omitempty"`
        Languages     []string           `json:"languages"`
        FileHash      *string            `json:"file_hash,omitempty"`
        FileSize      *int64             `json:"file_size,omitempty"`
        Providers     []SubtitleProvider `json:"providers,omitempty"`
        ForceDownload bool               `json:"force_download"`
}

// SubtitleSearchResult represents a subtitle search result
type SubtitleSearchResult struct {
        ID                string           `json:"id"`
        Provider          SubtitleProvider `json:"provider"`
        Language          string           `json:"language"`
        LanguageCode      string           `json:"language_code"`
        Title             string           `json:"title"`
        DownloadURL       string           `json:"download_url"`
        Format            string           `json:"format"`
        Encoding          string           `json:"encoding"`
        UploadDate        time.Time        `json:"upload_date"`
        Downloads         int              `json:"downloads"`
        Rating            float64          `json:"rating"`
        Comments          int              `json:"comments"`
        IsHearingImpaired bool             `json:"is_hearing_impaired"`
        FrameRate         *float64         `json:"frame_rate,omitempty"`
        FileHash          *string          `json:"file_hash,omitempty"`
        MovieHash         *string          `json:"movie_hash,omitempty"`
        MatchScore        float64          `json:"match_score"`
}

// SubtitleSyncResult represents subtitle synchronization verification
type SubtitleSyncResult struct {
        IsValid        bool        `json:"is_valid"`
        SyncOffset     float64     `json:"sync_offset"` // Milliseconds
        Confidence     float64     `json:"confidence"`  // 0-1
        DetectedFrames int         `json:"detected_frames"`
        SamplePoints   []SyncPoint `json:"sample_points"`
        Recommendation string      `json:"recommendation"`
}

// SyncPoint represents a point used for sync verification
type SyncPoint struct {
        SubtitleTime float64 `json:"subtitle_time"`
        VideoTime    float64 `json:"video_time"`
        Text         string  `json:"text"`
        Confidence   float64 `json:"confidence"`
}

// SubtitleDownloadRequest represents a subtitle download request
type SubtitleDownloadRequest struct {
        MediaItemID   int64    `json:"media_item_id"`
        ResultID      string   `json:"result_id"`
        Language      string   `json:"language"`
        VerifySync    bool     `json:"verify_sync"`
        AutoTranslate []string `json:"auto_translate,omitempty"` // Languages to auto-translate to
}

// SubtitleTranslationRequest represents a subtitle translation request
type SubtitleTranslationRequest struct {
        SubtitleID     string `json:"subtitle_id"`
        SourceLanguage string `json:"source_language"`
        TargetLanguage string `json:"target_language"`
        UseCache       bool   `json:"use_cache"`
}

// SubtitleLine represents a single subtitle line
type SubtitleLine struct {
        Index     int    `json:"index"`
        StartTime string `json:"start_time"`
        EndTime   string `json:"end_time"`
        Text      string `json:"text"`
}

// NewSubtitleService creates a new subtitle service
func NewSubtitleService(db *sql.DB, logger *zap.Logger) *SubtitleService <span class="cov0" title="0">{
        return &amp;SubtitleService{
                db:                 db,
                logger:             logger,
                translationService: NewTranslationService(logger),
                httpClient:         &amp;http.Client{Timeout: 30 * time.Second},
                apiKeys:            make(map[string]string),
                cacheDir:           "./cache/subtitles",
        }
}</span>

// SearchSubtitles searches for subtitles across multiple providers
func (s *SubtitleService) SearchSubtitles(ctx context.Context, request *SubtitleSearchRequest) ([]SubtitleSearchResult, error) <span class="cov0" title="0">{
        s.logger.Info("Searching subtitles",
                zap.String("media_path", request.MediaPath),
                zap.Strings("languages", request.Languages))

        var allResults []SubtitleSearchResult

        // Default providers if none specified
        providers := request.Providers
        if len(providers) == 0 </span><span class="cov0" title="0">{
                providers = []SubtitleProvider{
                        ProviderOpenSubtitles,
                        ProviderSubDB,
                        ProviderYifySubtitles,
                }
        }</span>

        // Search each provider in parallel
        <span class="cov0" title="0">resultsChan := make(chan []SubtitleSearchResult, len(providers))
        errorsChan := make(chan error, len(providers))

        for _, provider := range providers </span><span class="cov0" title="0">{
                go func(p SubtitleProvider) </span><span class="cov0" title="0">{
                        results, err := s.searchProvider(ctx, p, request)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Provider search failed",
                                        zap.String("provider", string(p)),
                                        zap.Error(err))
                                errorsChan &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">resultsChan &lt;- results</span>
                }(provider)
        }

        // Collect results
        <span class="cov0" title="0">for i := 0; i &lt; len(providers); i++ </span><span class="cov0" title="0">{
                select </span>{
                case results := &lt;-resultsChan:<span class="cov0" title="0">
                        allResults = append(allResults, results...)</span>
                case &lt;-errorsChan:<span class="cov0" title="0"></span>
                        // Log error but continue with other providers
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                }
        }

        // Sort by match score and rating
        <span class="cov0" title="0">s.sortSubtitleResults(allResults)

        s.logger.Info("Subtitle search completed",
                zap.Int("total_results", len(allResults)))

        return allResults, nil</span>
}

// DownloadSubtitle downloads a subtitle and optionally verifies sync
func (s *SubtitleService) DownloadSubtitle(ctx context.Context, request *SubtitleDownloadRequest) (*SubtitleTrack, error) <span class="cov0" title="0">{
        s.logger.Info("Downloading subtitle",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("result_id", request.ResultID))

        // Get download info from cache or provider
        result, err := s.getDownloadInfo(ctx, request.ResultID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get download info: %w", err)
        }</span>

        // Download subtitle content
        <span class="cov0" title="0">content, encoding, err := s.downloadContent(ctx, result.DownloadURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to download subtitle content: %w", err)
        }</span>

        // Parse and validate subtitle format
        <span class="cov0" title="0">_, err = s.parseSubtitle(content, result.Format)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse subtitle: %w", err)
        }</span>

        // Create subtitle track
        <span class="cov0" title="0">track := &amp;SubtitleTrack{
                ID:           generateSubtitleID(),
                Language:     result.Language,
                LanguageCode: result.LanguageCode,
                Source:       "downloaded",
                Format:       result.Format,
                Content:      &amp;content,
                IsDefault:    false,
                IsForced:     false,
                Encoding:     encoding,
                SyncOffset:   0.0,
                CreatedAt:    time.Now(),
                VerifiedSync: false,
        }

        // Verify synchronization if requested
        if request.VerifySync </span><span class="cov0" title="0">{
                syncResult, err := s.verifySynchronization(ctx, request.MediaItemID, track)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to verify subtitle sync", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        track.VerifiedSync = syncResult.IsValid
                        track.SyncOffset = syncResult.SyncOffset
                }</span>
        }

        // Save to database
        <span class="cov0" title="0">if err := s.saveSubtitleTrack(ctx, request.MediaItemID, track); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save subtitle track: %w", err)
        }</span>

        // Auto-translate to requested languages
        <span class="cov0" title="0">if len(request.AutoTranslate) &gt; 0 </span><span class="cov0" title="0">{
                go s.autoTranslateSubtitle(ctx, track, request.AutoTranslate)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Subtitle downloaded successfully",
                zap.String("subtitle_id", track.ID),
                zap.String("language", track.Language))

        return track, nil</span>
}

// TranslateSubtitle translates a subtitle to another language
func (s *SubtitleService) TranslateSubtitle(ctx context.Context, request *SubtitleTranslationRequest) (*SubtitleTrack, error) <span class="cov0" title="0">{
        s.logger.Info("Translating subtitle",
                zap.String("subtitle_id", request.SubtitleID),
                zap.String("target_language", request.TargetLanguage))

        // Check cache first
        if request.UseCache </span><span class="cov0" title="0">{
                if cached := s.getCachedTranslation(ctx, request.SubtitleID, request.TargetLanguage); cached != nil </span><span class="cov0" title="0">{
                        return cached, nil
                }</span>
        }

        // Get original subtitle
        <span class="cov0" title="0">original, err := s.getSubtitleTrack(ctx, request.SubtitleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get original subtitle: %w", err)
        }</span>

        // Parse subtitle for translation
        <span class="cov0" title="0">lines, err := s.parseSubtitleLines(*original.Content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse subtitle lines: %w", err)
        }</span>

        // Translate each line
        <span class="cov0" title="0">translatedLines, err := s.translateLines(ctx, lines, request.SourceLanguage, request.TargetLanguage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to translate lines: %w", err)
        }</span>

        // Reconstruct subtitle content
        <span class="cov0" title="0">translatedContent, err := s.reconstructSubtitle(original.Format, translatedLines)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to reconstruct subtitle: %w", err)
        }</span>

        // Create translated subtitle track
        <span class="cov0" title="0">translatedTrack := &amp;SubtitleTrack{
                ID:           generateSubtitleID(),
                Language:     getLanguageName(request.TargetLanguage),
                LanguageCode: request.TargetLanguage,
                Source:       "translated",
                Format:       original.Format,
                Content:      &amp;translatedContent,
                IsDefault:    false,
                IsForced:     false,
                Encoding:     original.Encoding,
                SyncOffset:   original.SyncOffset,
                CreatedAt:    time.Now(),
                VerifiedSync: original.VerifiedSync,
        }

        // Save translated subtitle
        if err := s.saveCachedTranslation(ctx, request.SubtitleID, request.TargetLanguage, translatedTrack); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to cache translation", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return translatedTrack, nil</span>
}

// GetSubtitles returns all subtitles for a media item
func (s *SubtitleService) GetSubtitles(ctx context.Context, mediaItemID int64) ([]SubtitleTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, language, language_code, source, format, path, content,
                       is_default, is_forced, encoding, sync_offset, created_at, verified_sync
                FROM subtitle_tracks WHERE media_item_id = ?
                ORDER BY is_default DESC, language`

        rows, err := s.db.QueryContext(ctx, query, mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query subtitles: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var subtitles []SubtitleTrack
        for rows.Next() </span><span class="cov0" title="0">{
                var track SubtitleTrack
                var content sql.NullString
                var path sql.NullString

                err := rows.Scan(
                        &amp;track.ID, &amp;track.Language, &amp;track.LanguageCode, &amp;track.Source,
                        &amp;track.Format, &amp;path, &amp;content, &amp;track.IsDefault, &amp;track.IsForced,
                        &amp;track.Encoding, &amp;track.SyncOffset, &amp;track.CreatedAt, &amp;track.VerifiedSync,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan subtitle: %w", err)
                }</span>

                <span class="cov0" title="0">if path.Valid </span><span class="cov0" title="0">{
                        track.Path = &amp;path.String
                }</span>
                <span class="cov0" title="0">if content.Valid </span><span class="cov0" title="0">{
                        track.Content = &amp;content.String
                }</span>

                <span class="cov0" title="0">subtitles = append(subtitles, track)</span>
        }

        <span class="cov0" title="0">return subtitles, nil</span>
}

// VerifySynchronization checks if subtitles are properly synchronized with video
func (s *SubtitleService) verifySynchronization(ctx context.Context, mediaItemID int64, track *SubtitleTrack) (*SubtitleSyncResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Verifying subtitle synchronization",
                zap.Int64("media_item_id", mediaItemID),
                zap.String("subtitle_id", track.ID))

        // Get video metadata
        videoInfo, err := s.getVideoInfo(ctx, mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get video info: %w", err)
        }</span>

        // Parse subtitle timing
        <span class="cov0" title="0">lines, err := s.parseSubtitleLines(*track.Content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse subtitle lines: %w", err)
        }</span>

        // Analyze timing patterns
        <span class="cov0" title="0">samplePoints := s.extractSamplePoints(lines, videoInfo.Duration)

        // Calculate sync offset and confidence
        syncOffset, confidence := s.calculateSyncOffset(samplePoints, videoInfo)

        result := &amp;SubtitleSyncResult{
                IsValid:        confidence &gt; 0.7, // 70% confidence threshold
                SyncOffset:     syncOffset,
                Confidence:     confidence,
                DetectedFrames: len(samplePoints),
                SamplePoints:   samplePoints,
        }

        if result.IsValid </span><span class="cov0" title="0">{
                result.Recommendation = "Subtitle synchronization is good"
        }</span> else<span class="cov0" title="0"> if confidence &gt; 0.4 </span><span class="cov0" title="0">{
                result.Recommendation = fmt.Sprintf("Subtitle may need %+.1fs offset", syncOffset/1000)
        }</span> else<span class="cov0" title="0"> {
                result.Recommendation = "Subtitle synchronization is poor"
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Provider-specific search implementations
func (s *SubtitleService) searchProvider(ctx context.Context, provider SubtitleProvider, request *SubtitleSearchRequest) ([]SubtitleSearchResult, error) <span class="cov0" title="0">{
        switch provider </span>{
        case ProviderOpenSubtitles:<span class="cov0" title="0">
                return s.searchOpenSubtitles(ctx, request)</span>
        case ProviderSubDB:<span class="cov0" title="0">
                return s.searchSubDB(ctx, request)</span>
        case ProviderYifySubtitles:<span class="cov0" title="0">
                return s.searchYifySubtitles(ctx, request)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported provider: %s", provider)</span>
        }
}

func (s *SubtitleService) searchOpenSubtitles(ctx context.Context, request *SubtitleSearchRequest) ([]SubtitleSearchResult, error) <span class="cov0" title="0">{
        // Implementation for OpenSubtitles API
        // This is a simplified version - real implementation would use their API

        s.logger.Debug("Searching OpenSubtitles", zap.String("title", getStringValue(request.Title)))

        // Mock results for demonstration
        results := []SubtitleSearchResult{
                {
                        ID:           "os_1",
                        Provider:     ProviderOpenSubtitles,
                        Language:     "English",
                        LanguageCode: "en",
                        Title:        "Sample Movie (2024)",
                        DownloadURL:  "https://dl.opensubtitles.org/sample1.srt",
                        Format:       "srt",
                        Encoding:     "utf-8",
                        UploadDate:   time.Now().AddDate(0, 0, -7),
                        Downloads:    1500,
                        Rating:       4.2,
                        Comments:     23,
                        MatchScore:   0.95,
                },
        }

        return results, nil
}</span>

func (s *SubtitleService) searchSubDB(ctx context.Context, request *SubtitleSearchRequest) ([]SubtitleSearchResult, error) <span class="cov0" title="0">{
        // Implementation for SubDB
        s.logger.Debug("Searching SubDB")
        return []SubtitleSearchResult{}, nil
}</span>

func (s *SubtitleService) searchYifySubtitles(ctx context.Context, request *SubtitleSearchRequest) ([]SubtitleSearchResult, error) <span class="cov0" title="0">{
        // Implementation for YifySubtitles
        s.logger.Debug("Searching YifySubtitles")
        return []SubtitleSearchResult{}, nil
}</span>

// Helper functions
func (s *SubtitleService) downloadContent(ctx context.Context, url string) (string, string, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        content, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Detect encoding
        <span class="cov0" title="0">encoding := detectEncoding(content)

        return string(content), encoding, nil</span>
}

func (s *SubtitleService) parseSubtitle(content, format string) (interface{}, error) <span class="cov0" title="0">{
        switch strings.ToLower(format) </span>{
        case "srt":<span class="cov0" title="0">
                return s.parseSRT(content)</span>
        case "vtt":<span class="cov0" title="0">
                return s.parseVTT(content)</span>
        case "ass", "ssa":<span class="cov0" title="0">
                return s.parseASS(content)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported subtitle format: %s", format)</span>
        }
}

func (s *SubtitleService) parseSRT(content string) ([]SubtitleLine, error) <span class="cov0" title="0">{
        var lines []SubtitleLine

        // Simple SRT parser
        re := regexp.MustCompile(`(\d+)\s*\n(\d{2}:\d{2}:\d{2},\d{3}) --&gt; (\d{2}:\d{2}:\d{2},\d{3})\s*\n((?:[^\n]*\n?)+?)(?:\n|$)`)
        matches := re.FindAllStringSubmatch(content, -1)

        for i, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 5 </span><span class="cov0" title="0">{
                        text := strings.TrimSpace(match[4])

                        lines = append(lines, SubtitleLine{
                                Index:     i + 1,
                                StartTime: match[2],
                                EndTime:   match[3],
                                Text:      text,
                        })
                }</span>
        }

        <span class="cov0" title="0">return lines, nil</span>
}

func (s *SubtitleService) parseVTT(content string) (interface{}, error) <span class="cov0" title="0">{
        // WebVTT parser implementation
        return nil, fmt.Errorf("VTT parsing not implemented")
}</span>

func (s *SubtitleService) parseASS(content string) (interface{}, error) <span class="cov0" title="0">{
        // ASS/SSA parser implementation
        return nil, fmt.Errorf("ASS parsing not implemented")
}</span>

func parseTimestamp(timestamp string) (float64, error) <span class="cov0" title="0">{
        // Parse SRT timestamp format: 00:01:23,456
        re := regexp.MustCompile(`(\d{2}):(\d{2}):(\d{2}),(\d{3})`)
        matches := re.FindStringSubmatch(timestamp)

        if len(matches) != 5 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid timestamp format")
        }</span>

        <span class="cov0" title="0">hours, _ := strconv.Atoi(matches[1])
        minutes, _ := strconv.Atoi(matches[2])
        seconds, _ := strconv.Atoi(matches[3])
        milliseconds, _ := strconv.Atoi(matches[4])

        total := float64(hours*3600+minutes*60+seconds) + float64(milliseconds)/1000.0
        return total, nil</span>
}

func detectEncoding(data []byte) string <span class="cov0" title="0">{
        // Simple encoding detection - in practice you'd use a more sophisticated library
        if len(data) &gt; 3 &amp;&amp; data[0] == 0xEF &amp;&amp; data[1] == 0xBB &amp;&amp; data[2] == 0xBF </span><span class="cov0" title="0">{
                return "utf-8"
        }</span>
        <span class="cov0" title="0">return "utf-8"</span> // Default assumption
}

func generateSubtitleID() string <span class="cov0" title="0">{
        return fmt.Sprintf("sub_%d", time.Now().UnixNano())
}</span>

func getSubtitleStringValue(s *string) string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *s</span>
}

func (s *SubtitleService) sortSubtitleResults(results []SubtitleSearchResult) <span class="cov0" title="0">{
        // Sort by match score descending, then by rating
        for i := 0; i &lt; len(results)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(results); j++ </span><span class="cov0" title="0">{
                        if results[i].MatchScore &lt; results[j].MatchScore ||
                                (results[i].MatchScore == results[j].MatchScore &amp;&amp; results[i].Rating &lt; results[j].Rating) </span><span class="cov0" title="0">{
                                results[i], results[j] = results[j], results[i]
                        }</span>
                }
        }
}

// Additional helper methods

// getDownloadInfo retrieves download information for a subtitle result
func (s *SubtitleService) getDownloadInfo(ctx context.Context, resultID string) (*SubtitleSearchResult, error) <span class="cov0" title="0">{
        // TODO: Implement proper caching and retrieval logic
        // For now, return a stub
        return &amp;SubtitleSearchResult{
                ID:           resultID,
                Provider:     ProviderOpenSubtitles,
                Language:     "English",
                LanguageCode: "en",
                DownloadURL:  "https://example.com/subtitle.srt",
                Format:       "srt",
                Encoding:     "utf-8",
        }, nil
}</span>

// saveSubtitleTrack saves a subtitle track to the database
func (s *SubtitleService) saveSubtitleTrack(ctx context.Context, mediaItemID int64, track *SubtitleTrack) error <span class="cov0" title="0">{
        query := `
                INSERT INTO subtitle_tracks
                (id, media_item_id, language, language_code, source, format, content,
                 is_default, is_forced, encoding, sync_offset, verified_sync, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        _, err := s.db.ExecContext(ctx, query,
                track.ID, mediaItemID, track.Language, track.LanguageCode, track.Source,
                track.Format, track.Content, track.IsDefault, track.IsForced,
                track.Encoding, track.SyncOffset, track.VerifiedSync, track.CreatedAt)

        return err
}</span>

// autoTranslateSubtitle automatically translates a subtitle to multiple languages
func (s *SubtitleService) autoTranslateSubtitle(ctx context.Context, track *SubtitleTrack, targetLanguages []string) <span class="cov0" title="0">{
        for _, lang := range targetLanguages </span><span class="cov0" title="0">{
                request := &amp;SubtitleTranslationRequest{
                        SubtitleID:     track.ID,
                        SourceLanguage: track.LanguageCode,
                        TargetLanguage: lang,
                        UseCache:       true,
                }

                _, err := s.TranslateSubtitle(ctx, request)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Auto-translation failed",
                                zap.String("subtitle_id", track.ID),
                                zap.String("target_language", lang),
                                zap.Error(err))
                }</span>
        }
}

// getCachedTranslation retrieves a cached translation
func (s *SubtitleService) getCachedTranslation(ctx context.Context, subtitleID, targetLanguage string) *SubtitleTrack <span class="cov0" title="0">{
        // TODO: Implement proper cache lookup
        return nil
}</span>

// getSubtitleTrack retrieves a subtitle track by ID
func (s *SubtitleService) getSubtitleTrack(ctx context.Context, subtitleID string) (*SubtitleTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, language, language_code, source, format, path, content,
                       is_default, is_forced, encoding, sync_offset, created_at, verified_sync
                FROM subtitle_tracks WHERE id = ?`

        var track SubtitleTrack
        var content sql.NullString
        var path sql.NullString

        err := s.db.QueryRowContext(ctx, query, subtitleID).Scan(
                &amp;track.ID, &amp;track.Language, &amp;track.LanguageCode, &amp;track.Source,
                &amp;track.Format, &amp;path, &amp;content, &amp;track.IsDefault, &amp;track.IsForced,
                &amp;track.Encoding, &amp;track.SyncOffset, &amp;track.CreatedAt, &amp;track.VerifiedSync,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get subtitle track: %w", err)
        }</span>

        <span class="cov0" title="0">if path.Valid </span><span class="cov0" title="0">{
                track.Path = &amp;path.String
        }</span>
        <span class="cov0" title="0">if content.Valid </span><span class="cov0" title="0">{
                track.Content = &amp;content.String
        }</span>

        <span class="cov0" title="0">return &amp;track, nil</span>
}

// saveCachedTranslation saves a translation to cache
func (s *SubtitleService) saveCachedTranslation(ctx context.Context, subtitleID, targetLanguage string, track *SubtitleTrack) error <span class="cov0" title="0">{
        // TODO: Implement proper cache storage
        s.logger.Debug("Saving cached translation",
                zap.String("subtitle_id", subtitleID),
                zap.String("target_language", targetLanguage))
        return nil
}</span>

// parseSubtitleLines parses subtitle content into lines
func (s *SubtitleService) parseSubtitleLines(content string) ([]SubtitleLine, error) <span class="cov0" title="0">{
        // For now, assume SRT format
        return s.parseSRT(content)
}</span>

// translateLines translates subtitle lines using the translation service
func (s *SubtitleService) translateLines(ctx context.Context, lines []SubtitleLine, sourceLang, targetLang string) ([]SubtitleLine, error) <span class="cov0" title="0">{
        translatedLines := make([]SubtitleLine, len(lines))

        for i, line := range lines </span><span class="cov0" title="0">{
                request := TranslationRequest{
                        Text:           line.Text,
                        SourceLanguage: sourceLang,
                        TargetLanguage: targetLang,
                        Context:        "subtitle",
                }

                result, err := s.translationService.TranslateText(ctx, request)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to translate line %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">translatedLines[i] = SubtitleLine{
                        Index:     line.Index,
                        StartTime: line.StartTime,
                        EndTime:   line.EndTime,
                        Text:      result.TranslatedText,
                }</span>
        }

        <span class="cov0" title="0">return translatedLines, nil</span>
}

// reconstructSubtitle reconstructs subtitle content from lines
func (s *SubtitleService) reconstructSubtitle(format string, lines []SubtitleLine) (string, error) <span class="cov0" title="0">{
        switch strings.ToLower(format) </span>{
        case "srt":<span class="cov0" title="0">
                return s.reconstructSRT(lines), nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported format for reconstruction: %s", format)</span>
        }
}

// reconstructSRT reconstructs SRT format from subtitle lines
func (s *SubtitleService) reconstructSRT(lines []SubtitleLine) string <span class="cov0" title="0">{
        var builder strings.Builder

        for _, line := range lines </span><span class="cov0" title="0">{
                builder.WriteString(fmt.Sprintf("%d\n", line.Index))
                builder.WriteString(fmt.Sprintf("%s --&gt; %s\n", line.StartTime, line.EndTime))
                builder.WriteString(line.Text)
                builder.WriteString("\n\n")
        }</span>

        <span class="cov0" title="0">return builder.String()</span>
}

// VideoInfo represents video metadata for sync verification
type VideoInfo struct {
        Duration  float64 // Duration in seconds
        FrameRate float64
        Width     int
        Height    int
}

// getVideoInfo retrieves video metadata for sync verification
func (s *SubtitleService) getVideoInfo(ctx context.Context, mediaItemID int64) (*VideoInfo, error) <span class="cov0" title="0">{
        // TODO: Implement proper video metadata retrieval
        return &amp;VideoInfo{
                Duration:  7200.0, // 2 hours
                FrameRate: 23.976,
                Width:     1920,
                Height:    1080,
        }, nil
}</span>

// extractSamplePoints extracts sample points for sync verification
func (s *SubtitleService) extractSamplePoints(lines []SubtitleLine, duration float64) []SyncPoint <span class="cov0" title="0">{
        var points []SyncPoint

        // Extract sample points at regular intervals
        sampleInterval := len(lines) / 10
        if sampleInterval == 0 </span><span class="cov0" title="0">{
                sampleInterval = 1
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; len(lines); i += sampleInterval </span><span class="cov0" title="0">{
                line := lines[i]
                // Parse timestamp
                time, _ := parseTimestamp(line.StartTime)

                points = append(points, SyncPoint{
                        SubtitleTime: time,
                        VideoTime:    time,
                        Text:         line.Text,
                        Confidence:   0.8,
                })
        }</span>

        <span class="cov0" title="0">return points</span>
}

// calculateSyncOffset calculates sync offset and confidence
func (s *SubtitleService) calculateSyncOffset(points []SyncPoint, videoInfo *VideoInfo) (float64, float64) <span class="cov0" title="0">{
        if len(points) == 0 </span><span class="cov0" title="0">{
                return 0, 0
        }</span>

        // Simple implementation - calculate average offset
        <span class="cov0" title="0">var totalOffset float64
        for _, point := range points </span><span class="cov0" title="0">{
                totalOffset += point.SubtitleTime - point.VideoTime
        }</span>

        <span class="cov0" title="0">avgOffset := totalOffset / float64(len(points))
        confidence := 0.8 // Default confidence

        return avgOffset * 1000, confidence</span> // Convert to milliseconds
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package services

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "time"

        "go.uber.org/zap"
)

// TranslationService handles AI-powered text translation
type TranslationService struct {
        logger     *zap.Logger
        httpClient *http.Client
        providers  map[string]TranslationProvider
        cache      map[string]*TranslationResult // Simple in-memory cache
}

// TranslationProvider represents a translation API provider
type TranslationProvider interface {
        Translate(ctx context.Context, request *TranslationRequest) (*TranslationResult, error)
        GetName() string
        GetSupportedLanguages() []string
        IsAvailable() bool
}

// TranslationRequest represents a translation request
type TranslationRequest struct {
        Text           string            `json:"text"`
        SourceLanguage string            `json:"source_language"`
        TargetLanguage string            `json:"target_language"`
        Context        string            `json:"context,omitempty"` // "lyrics", "subtitle", "general"
        Metadata       map[string]string `json:"metadata,omitempty"`
}

// TranslationResult represents a translation result
type TranslationResult struct {
        OriginalText     string    `json:"original_text"`
        TranslatedText   string    `json:"translated_text"`
        SourceLanguage   string    `json:"source_language"`
        TargetLanguage   string    `json:"target_language"`
        Provider         string    `json:"provider"`
        Confidence       float64   `json:"confidence"`
        DetectedLanguage *string   `json:"detected_language,omitempty"`
        Alternatives     []string  `json:"alternatives,omitempty"`
        ProcessingTime   float64   `json:"processing_time"` // Milliseconds
        CachedAt         time.Time `json:"cached_at"`
}

// BatchTranslationRequest represents a batch translation request
type BatchTranslationRequest struct {
        Texts          []string `json:"texts"`
        SourceLanguage string   `json:"source_language"`
        TargetLanguage string   `json:"target_language"`
        Context        string   `json:"context,omitempty"`
        PreserveFormat bool     `json:"preserve_format"`
}

// BatchTranslationResult represents a batch translation result
type BatchTranslationResult struct {
        Results      []TranslationResult `json:"results"`
        TotalTime    float64             `json:"total_time"`
        SuccessCount int                 `json:"success_count"`
        Provider     string              `json:"provider"`
}

// LanguageDetectionRequest represents a language detection request
type LanguageDetectionRequest struct {
        Text string `json:"text"`
}

// LanguageDetectionResult represents a language detection result
type LanguageDetectionResult struct {
        Language   string  `json:"language"`
        Code       string  `json:"code"`
        Confidence float64 `json:"confidence"`
        Provider   string  `json:"provider"`
}

// SupportedLanguage represents a supported language
type SupportedLanguage struct {
        Code       string `json:"code"`
        Name       string `json:"name"`
        NativeName string `json:"native_name"`
        Flag       string `json:"flag"`      // Unicode flag emoji
        Direction  string `json:"direction"` // "ltr" or "rtl"
        IsPopular  bool   `json:"is_popular"`
}

// NewTranslationService creates a new translation service
func NewTranslationService(logger *zap.Logger) *TranslationService <span class="cov0" title="0">{
        service := &amp;TranslationService{
                logger:     logger,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                providers:  make(map[string]TranslationProvider),
                cache:      make(map[string]*TranslationResult),
        }

        // Initialize providers
        service.initializeProviders()

        return service
}</span>

// TranslateText translates text using the best available provider
func (s *TranslationService) TranslateText(ctx context.Context, request TranslationRequest) (*TranslationResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Translating text",
                zap.String("source_lang", request.SourceLanguage),
                zap.String("target_lang", request.TargetLanguage),
                zap.String("context", request.Context))

        // Check cache first
        cacheKey := s.generateCacheKey(&amp;request)
        if cached, exists := s.cache[cacheKey]; exists </span><span class="cov0" title="0">{
                s.logger.Debug("Using cached translation")
                return cached, nil
        }</span>

        // Get available providers in priority order
        <span class="cov0" title="0">providers := s.getAvailableProviders()
        if len(providers) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no translation providers available")
        }</span>

        <span class="cov0" title="0">var lastError error
        startTime := time.Now()

        // Try providers in order until one succeeds
        for _, provider := range providers </span><span class="cov0" title="0">{
                result, err := provider.Translate(ctx, &amp;request)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Provider failed",
                                zap.String("provider", provider.GetName()),
                                zap.Error(err))
                        lastError = err
                        continue</span>
                }

                // Calculate processing time
                <span class="cov0" title="0">result.ProcessingTime = float64(time.Since(startTime).Nanoseconds()) / 1e6
                result.CachedAt = time.Now()

                // Cache the result
                s.cache[cacheKey] = result

                s.logger.Info("Translation completed",
                        zap.String("provider", result.Provider),
                        zap.Float64("confidence", result.Confidence),
                        zap.Float64("processing_time_ms", result.ProcessingTime))

                return result, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("all translation providers failed, last error: %w", lastError)</span>
}

// TranslateBatch translates multiple texts in a single request
func (s *TranslationService) TranslateBatch(ctx context.Context, request *BatchTranslationRequest) (*BatchTranslationResult, error) <span class="cov0" title="0">{
        s.logger.Info("Translating batch",
                zap.Int("text_count", len(request.Texts)),
                zap.String("source_lang", request.SourceLanguage),
                zap.String("target_lang", request.TargetLanguage))

        startTime := time.Now()
        var results []TranslationResult
        successCount := 0

        // Translate each text
        for _, text := range request.Texts </span><span class="cov0" title="0">{
                translationRequest := TranslationRequest{
                        Text:           text,
                        SourceLanguage: request.SourceLanguage,
                        TargetLanguage: request.TargetLanguage,
                        Context:        request.Context,
                }

                result, err := s.TranslateText(ctx, translationRequest)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to translate text in batch", zap.Error(err))
                        // Add empty result to maintain order
                        results = append(results, TranslationResult{
                                OriginalText:   text,
                                TranslatedText: text, // Fallback to original
                                SourceLanguage: request.SourceLanguage,
                                TargetLanguage: request.TargetLanguage,
                                Provider:       "fallback",
                                Confidence:     0.0,
                        })
                }</span> else<span class="cov0" title="0"> {
                        results = append(results, *result)
                        successCount++
                }</span>
        }

        <span class="cov0" title="0">totalTime := float64(time.Since(startTime).Nanoseconds()) / 1e6

        batchResult := &amp;BatchTranslationResult{
                Results:      results,
                TotalTime:    totalTime,
                SuccessCount: successCount,
                Provider:     "batch",
        }

        return batchResult, nil</span>
}

// DetectLanguage detects the language of the given text
func (s *TranslationService) DetectLanguage(ctx context.Context, request *LanguageDetectionRequest) (*LanguageDetectionResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Detecting language", zap.String("text_preview", s.getTextPreview(request.Text)))

        // Get available providers
        providers := s.getAvailableProviders()
        if len(providers) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no language detection providers available")
        }</span>

        // Use first available provider for language detection
        // In practice, you might want to try multiple providers and compare results
        <span class="cov0" title="0">provider := providers[0]

        // For now, use a simple heuristic approach
        detectedLang := s.simpleLanguageDetection(request.Text)

        result := &amp;LanguageDetectionResult{
                Language:   getLanguageName(detectedLang),
                Code:       detectedLang,
                Confidence: 0.8, // Mock confidence
                Provider:   provider.GetName(),
        }

        return result, nil</span>
}

// GetSupportedLanguages returns all supported languages
func (s *TranslationService) GetSupportedLanguages() []SupportedLanguage <span class="cov0" title="0">{
        return []SupportedLanguage{
                {Code: "en", Name: "English", NativeName: "English", Flag: "🇺🇸", Direction: "ltr", IsPopular: true},
                {Code: "es", Name: "Spanish", NativeName: "Español", Flag: "🇪🇸", Direction: "ltr", IsPopular: true},
                {Code: "fr", Name: "French", NativeName: "Français", Flag: "🇫🇷", Direction: "ltr", IsPopular: true},
                {Code: "de", Name: "German", NativeName: "Deutsch", Flag: "🇩🇪", Direction: "ltr", IsPopular: true},
                {Code: "it", Name: "Italian", NativeName: "Italiano", Flag: "🇮🇹", Direction: "ltr", IsPopular: true},
                {Code: "pt", Name: "Portuguese", NativeName: "Português", Flag: "🇵🇹", Direction: "ltr", IsPopular: true},
                {Code: "ru", Name: "Russian", NativeName: "Русский", Flag: "🇷🇺", Direction: "ltr", IsPopular: true},
                {Code: "ja", Name: "Japanese", NativeName: "日本語", Flag: "🇯🇵", Direction: "ltr", IsPopular: true},
                {Code: "ko", Name: "Korean", NativeName: "한국어", Flag: "🇰🇷", Direction: "ltr", IsPopular: true},
                {Code: "zh", Name: "Chinese", NativeName: "中文", Flag: "🇨🇳", Direction: "ltr", IsPopular: true},
                {Code: "ar", Name: "Arabic", NativeName: "العربية", Flag: "🇸🇦", Direction: "rtl", IsPopular: true},
                {Code: "hi", Name: "Hindi", NativeName: "हिन्दी", Flag: "🇮🇳", Direction: "ltr", IsPopular: true},
                {Code: "th", Name: "Thai", NativeName: "ไทย", Flag: "🇹🇭", Direction: "ltr", IsPopular: false},
                {Code: "vi", Name: "Vietnamese", NativeName: "Tiếng Việt", Flag: "🇻🇳", Direction: "ltr", IsPopular: false},
                {Code: "tr", Name: "Turkish", NativeName: "Türkçe", Flag: "🇹🇷", Direction: "ltr", IsPopular: false},
                {Code: "pl", Name: "Polish", NativeName: "Polski", Flag: "🇵🇱", Direction: "ltr", IsPopular: false},
                {Code: "nl", Name: "Dutch", NativeName: "Nederlands", Flag: "🇳🇱", Direction: "ltr", IsPopular: false},
                {Code: "sv", Name: "Swedish", NativeName: "Svenska", Flag: "🇸🇪", Direction: "ltr", IsPopular: false},
                {Code: "da", Name: "Danish", NativeName: "Dansk", Flag: "🇩🇰", Direction: "ltr", IsPopular: false},
                {Code: "no", Name: "Norwegian", NativeName: "Norsk", Flag: "🇳🇴", Direction: "ltr", IsPopular: false},
        }
}</span>

// Initialize providers
func (s *TranslationService) initializeProviders() <span class="cov0" title="0">{
        // Initialize free translation providers
        s.providers["google_translate_free"] = NewGoogleTranslateFreeProvider(s.httpClient, s.logger)
        s.providers["libre_translate"] = NewLibreTranslateProvider(s.httpClient, s.logger)
        s.providers["mymemory"] = NewMyMemoryProvider(s.httpClient, s.logger)

        // Note: In production, you would also initialize paid providers like:
        // s.providers["google_translate_api"] = NewGoogleTranslateAPIProvider(apiKey, s.httpClient, s.logger)
        // s.providers["azure_translator"] = NewAzureTranslatorProvider(apiKey, s.httpClient, s.logger)
        // s.providers["aws_translate"] = NewAWSTranslateProvider(credentials, s.httpClient, s.logger)
}</span>

// Get available providers in priority order
func (s *TranslationService) getAvailableProviders() []TranslationProvider <span class="cov0" title="0">{
        var available []TranslationProvider

        // Priority order: paid providers first, then free providers
        providerNames := []string{
                "google_translate_api",  // Paid (if configured)
                "azure_translator",      // Paid (if configured)
                "aws_translate",         // Paid (if configured)
                "google_translate_free", // Free
                "libre_translate",       // Free
                "mymemory",              // Free
        }

        for _, name := range providerNames </span><span class="cov0" title="0">{
                if provider, exists := s.providers[name]; exists &amp;&amp; provider.IsAvailable() </span><span class="cov0" title="0">{
                        available = append(available, provider)
                }</span>
        }

        <span class="cov0" title="0">return available</span>
}

// Generate cache key for translation request
func (s *TranslationService) generateCacheKey(request *TranslationRequest) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s_%s_%s_%s",
                request.SourceLanguage,
                request.TargetLanguage,
                request.Context,
                s.hashText(request.Text))
}</span>

// Simple text hashing for cache keys
func (s *TranslationService) hashText(text string) string <span class="cov0" title="0">{
        if len(text) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s...%s_%d", text[:20], text[len(text)-20:], len(text))
        }</span>
        <span class="cov0" title="0">return text</span>
}

// Simple language detection (in practice, use a proper language detection library)
func (s *TranslationService) simpleLanguageDetection(text string) string <span class="cov0" title="0">{
        text = strings.ToLower(text)

        // Simple keyword-based detection
        if strings.Contains(text, "the ") || strings.Contains(text, " and ") || strings.Contains(text, " is ") </span><span class="cov0" title="0">{
                return "en"
        }</span>
        <span class="cov0" title="0">if strings.Contains(text, " el ") || strings.Contains(text, " la ") || strings.Contains(text, " es ") </span><span class="cov0" title="0">{
                return "es"
        }</span>
        <span class="cov0" title="0">if strings.Contains(text, " le ") || strings.Contains(text, " la ") || strings.Contains(text, " est ") </span><span class="cov0" title="0">{
                return "fr"
        }</span>
        <span class="cov0" title="0">if strings.Contains(text, " der ") || strings.Contains(text, " die ") || strings.Contains(text, " ist ") </span><span class="cov0" title="0">{
                return "de"
        }</span>

        // Default to English
        <span class="cov0" title="0">return "en"</span>
}

// Get text preview for logging
func (s *TranslationService) getTextPreview(text string) string <span class="cov0" title="0">{
        if len(text) &gt; 100 </span><span class="cov0" title="0">{
                return text[:100] + "..."
        }</span>
        <span class="cov0" title="0">return text</span>
}

// Helper function to get language name from code
func getLanguageName(code string) string <span class="cov0" title="0">{
        languages := map[string]string{
                "en": "English",
                "es": "Spanish",
                "fr": "French",
                "de": "German",
                "it": "Italian",
                "pt": "Portuguese",
                "ru": "Russian",
                "ja": "Japanese",
                "ko": "Korean",
                "zh": "Chinese",
                "ar": "Arabic",
                "hi": "Hindi",
                "th": "Thai",
                "vi": "Vietnamese",
                "tr": "Turkish",
                "pl": "Polish",
                "nl": "Dutch",
                "sv": "Swedish",
                "da": "Danish",
                "no": "Norwegian",
        }

        if name, exists := languages[code]; exists </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov0" title="0">return code</span>
}

// Provider implementations would be in separate files
// Here are the interfaces they would implement:

// GoogleTranslateFreeProvider implements free Google Translate
type GoogleTranslateFreeProvider struct {
        httpClient *http.Client
        logger     *zap.Logger
        baseURL    string
}

func NewGoogleTranslateFreeProvider(httpClient *http.Client, logger *zap.Logger) *GoogleTranslateFreeProvider <span class="cov0" title="0">{
        return &amp;GoogleTranslateFreeProvider{
                httpClient: httpClient,
                logger:     logger,
                baseURL:    "https://translate.googleapis.com/translate_a/single",
        }
}</span>

func (p *GoogleTranslateFreeProvider) Translate(ctx context.Context, request *TranslationRequest) (*TranslationResult, error) <span class="cov0" title="0">{
        // Implementation would make HTTP request to Google Translate
        // This is a mock implementation
        return &amp;TranslationResult{
                OriginalText:   request.Text,
                TranslatedText: "[GT] " + request.Text, // Mock translation
                SourceLanguage: request.SourceLanguage,
                TargetLanguage: request.TargetLanguage,
                Provider:       "google_translate_free",
                Confidence:     0.9,
        }, nil
}</span>

func (p *GoogleTranslateFreeProvider) GetName() string <span class="cov0" title="0">{
        return "google_translate_free"
}</span>

func (p *GoogleTranslateFreeProvider) GetSupportedLanguages() []string <span class="cov0" title="0">{
        return []string{"en", "es", "fr", "de", "it", "pt", "ru", "ja", "ko", "zh", "ar", "hi"}
}</span>

func (p *GoogleTranslateFreeProvider) IsAvailable() bool <span class="cov0" title="0">{
        return true // Would check actual availability
}</span>

// LibreTranslateProvider implements LibreTranslate
type LibreTranslateProvider struct {
        httpClient *http.Client
        logger     *zap.Logger
        baseURL    string
}

func NewLibreTranslateProvider(httpClient *http.Client, logger *zap.Logger) *LibreTranslateProvider <span class="cov0" title="0">{
        return &amp;LibreTranslateProvider{
                httpClient: httpClient,
                logger:     logger,
                baseURL:    "https://libretranslate.de/translate",
        }
}</span>

func (p *LibreTranslateProvider) Translate(ctx context.Context, request *TranslationRequest) (*TranslationResult, error) <span class="cov0" title="0">{
        // Mock implementation
        return &amp;TranslationResult{
                OriginalText:   request.Text,
                TranslatedText: "[LT] " + request.Text, // Mock translation
                SourceLanguage: request.SourceLanguage,
                TargetLanguage: request.TargetLanguage,
                Provider:       "libre_translate",
                Confidence:     0.85,
        }, nil
}</span>

func (p *LibreTranslateProvider) GetName() string <span class="cov0" title="0">{
        return "libre_translate"
}</span>

func (p *LibreTranslateProvider) GetSupportedLanguages() []string <span class="cov0" title="0">{
        return []string{"en", "es", "fr", "de", "it", "pt", "ru", "ja", "zh", "ar"}
}</span>

func (p *LibreTranslateProvider) IsAvailable() bool <span class="cov0" title="0">{
        return true
}</span>

// MyMemoryProvider implements MyMemory translation
type MyMemoryProvider struct {
        httpClient *http.Client
        logger     *zap.Logger
        baseURL    string
}

func NewMyMemoryProvider(httpClient *http.Client, logger *zap.Logger) *MyMemoryProvider <span class="cov0" title="0">{
        return &amp;MyMemoryProvider{
                httpClient: httpClient,
                logger:     logger,
                baseURL:    "https://api.mymemory.translated.net/get",
        }
}</span>

func (p *MyMemoryProvider) Translate(ctx context.Context, request *TranslationRequest) (*TranslationResult, error) <span class="cov0" title="0">{
        // Mock implementation
        return &amp;TranslationResult{
                OriginalText:   request.Text,
                TranslatedText: "[MM] " + request.Text, // Mock translation
                SourceLanguage: request.SourceLanguage,
                TargetLanguage: request.TargetLanguage,
                Provider:       "mymemory",
                Confidence:     0.8,
        }, nil
}</span>

func (p *MyMemoryProvider) GetName() string <span class="cov0" title="0">{
        return "mymemory"
}</span>

func (p *MyMemoryProvider) GetSupportedLanguages() []string <span class="cov0" title="0">{
        return []string{"en", "es", "fr", "de", "it", "pt", "ru"}
}</span>

func (p *MyMemoryProvider) IsAvailable() bool <span class="cov0" title="0">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package services

import (
        "catalogizer/filesystem"
        "context"
        "database/sql"
        "fmt"
        "path/filepath"
        "sync"
        "time"

        "go.uber.org/zap"
)

// UniversalRenameTracker handles rename detection across all supported protocols
type UniversalRenameTracker struct {
        db               *sql.DB
        logger           *zap.Logger
        pendingMoves     map[string]*UniversalPendingMove // key: protocol:storageRoot:hash:size
        pendingMovesMu   sync.RWMutex
        cleanupInterval  time.Duration
        moveWindow       time.Duration
        stopCh           chan struct{}
        wg               sync.WaitGroup
        protocolHandlers map[string]ProtocolHandler
}

// UniversalPendingMove tracks a potential move operation across any protocol
type UniversalPendingMove struct {
        Path         string
        StorageRoot  string
        Protocol     string
        Size         int64
        FileHash     *string
        IsDirectory  bool
        DeletedAt    time.Time
        FileID       int64
        ProtocolData map[string]interface{} // Protocol-specific metadata
}

// ProtocolHandler defines protocol-specific operations for rename handling
type ProtocolHandler interface {
        // GetFileIdentifier creates a unique identifier for a file in this protocol
        GetFileIdentifier(ctx context.Context, path string, size int64, isDir bool) (string, error)

        // PerformMove executes the actual move operation for this protocol
        PerformMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string, isDir bool) error

        // ValidateMove checks if a move operation is valid for this protocol
        ValidateMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error

        // GetMoveWindow returns the protocol-specific move detection window
        GetMoveWindow() time.Duration

        // SupportsRealTimeNotification indicates if the protocol supports real-time change notifications
        SupportsRealTimeNotification() bool
}

// NewUniversalRenameTracker creates a new universal rename tracker
func NewUniversalRenameTracker(db *sql.DB, logger *zap.Logger) *UniversalRenameTracker <span class="cov0" title="0">{
        tracker := &amp;UniversalRenameTracker{
                db:               db,
                logger:           logger,
                pendingMoves:     make(map[string]*UniversalPendingMove),
                cleanupInterval:  30 * time.Second,
                moveWindow:       10 * time.Second, // Default window, can be overridden per protocol
                stopCh:           make(chan struct{}),
                protocolHandlers: make(map[string]ProtocolHandler),
        }

        // Register default protocol handlers
        tracker.RegisterProtocolHandler("local", NewLocalProtocolHandler(logger))
        tracker.RegisterProtocolHandler("smb", NewSMBProtocolHandler(logger))
        tracker.RegisterProtocolHandler("ftp", NewFTPProtocolHandler(logger))
        tracker.RegisterProtocolHandler("nfs", NewNFSProtocolHandler(logger))
        tracker.RegisterProtocolHandler("webdav", NewWebDAVProtocolHandler(logger))

        return tracker
}</span>

// RegisterProtocolHandler registers a protocol-specific handler
func (rt *UniversalRenameTracker) RegisterProtocolHandler(protocol string, handler ProtocolHandler) <span class="cov0" title="0">{
        rt.protocolHandlers[protocol] = handler
}</span>

// Start begins the universal rename tracking service
func (rt *UniversalRenameTracker) Start() error <span class="cov0" title="0">{
        rt.logger.Info("Starting universal rename tracker service")

        // Start cleanup worker
        rt.wg.Add(1)
        go rt.cleanupWorker()

        // Create rename tracking tables if they don't exist
        if err := rt.InitializeTables(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize rename tracking tables: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the universal rename tracking service
func (rt *UniversalRenameTracker) Stop() <span class="cov0" title="0">{
        rt.logger.Info("Stopping universal rename tracker service")
        close(rt.stopCh)
        rt.wg.Wait()
        rt.logger.Info("Universal rename tracker service stopped")
}</span>

// TrackDelete tracks a file/directory deletion for potential move detection
func (rt *UniversalRenameTracker) TrackDelete(ctx context.Context, fileID int64, path, storageRoot, protocol string, size int64, fileHash *string, isDirectory bool, protocolData map[string]interface{}) <span class="cov0" title="0">{
        handler, exists := rt.protocolHandlers[protocol]
        if !exists </span><span class="cov0" title="0">{
                rt.logger.Warn("No handler for protocol", zap.String("protocol", protocol))
                return
        }</span>

        // Get protocol-specific file identifier
        <span class="cov0" title="0">identifier, err := handler.GetFileIdentifier(ctx, path, size, isDirectory)
        if err != nil </span><span class="cov0" title="0">{
                rt.logger.Error("Failed to get file identifier",
                        zap.String("protocol", protocol),
                        zap.String("path", path),
                        zap.Error(err))
                identifier = rt.createFallbackKey(protocol, storageRoot, fileHash, size, isDirectory)
        }</span>

        <span class="cov0" title="0">key := fmt.Sprintf("%s:%s:%s", protocol, storageRoot, identifier)

        rt.pendingMovesMu.Lock()
        rt.pendingMoves[key] = &amp;UniversalPendingMove{
                Path:         path,
                StorageRoot:  storageRoot,
                Protocol:     protocol,
                Size:         size,
                FileHash:     fileHash,
                IsDirectory:  isDirectory,
                DeletedAt:    time.Now(),
                FileID:       fileID,
                ProtocolData: protocolData,
        }
        rt.pendingMovesMu.Unlock()

        rt.logger.Debug("Tracking potential universal move deletion",
                zap.String("path", path),
                zap.String("storage_root", storageRoot),
                zap.String("protocol", protocol),
                zap.Int64("file_id", fileID))</span>
}

// DetectCreate checks if a file creation is actually a move from a deletion
func (rt *UniversalRenameTracker) DetectCreate(ctx context.Context, newPath, storageRoot, protocol string, size int64, fileHash *string, isDirectory bool, protocolData map[string]interface{}) (*UniversalPendingMove, bool) <span class="cov0" title="0">{
        handler, exists := rt.protocolHandlers[protocol]
        if !exists </span><span class="cov0" title="0">{
                rt.logger.Warn("No handler for protocol", zap.String("protocol", protocol))
                return nil, false
        }</span>

        // Get protocol-specific file identifier
        <span class="cov0" title="0">identifier, err := handler.GetFileIdentifier(ctx, newPath, size, isDirectory)
        if err != nil </span><span class="cov0" title="0">{
                rt.logger.Error("Failed to get file identifier for create detection",
                        zap.String("protocol", protocol),
                        zap.String("path", newPath),
                        zap.Error(err))
                identifier = rt.createFallbackKey(protocol, storageRoot, fileHash, size, isDirectory)
        }</span>

        <span class="cov0" title="0">key := fmt.Sprintf("%s:%s:%s", protocol, storageRoot, identifier)

        rt.pendingMovesMu.Lock()
        pendingMove, exists := rt.pendingMoves[key]
        if exists </span><span class="cov0" title="0">{
                delete(rt.pendingMoves, key)
        }</span>
        <span class="cov0" title="0">rt.pendingMovesMu.Unlock()

        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Check if the move happened within the protocol-specific time window
        <span class="cov0" title="0">moveWindow := handler.GetMoveWindow()
        if time.Since(pendingMove.DeletedAt) &gt; moveWindow </span><span class="cov0" title="0">{
                rt.logger.Debug("Move window expired",
                        zap.String("protocol", protocol),
                        zap.String("old_path", pendingMove.Path),
                        zap.String("new_path", newPath),
                        zap.Duration("elapsed", time.Since(pendingMove.DeletedAt)),
                        zap.Duration("window", moveWindow))
                return nil, false
        }</span>

        <span class="cov0" title="0">rt.logger.Info("Detected universal file/directory move",
                zap.String("old_path", pendingMove.Path),
                zap.String("new_path", newPath),
                zap.String("storage_root", storageRoot),
                zap.String("protocol", protocol),
                zap.Bool("is_directory", isDirectory))

        return pendingMove, true</span>
}

// ProcessMove handles a detected move operation efficiently across protocols
func (rt *UniversalRenameTracker) ProcessMove(ctx context.Context, client filesystem.FileSystemClient, oldMove *UniversalPendingMove, newPath string) error <span class="cov0" title="0">{
        handler, exists := rt.protocolHandlers[oldMove.Protocol]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no handler for protocol: %s", oldMove.Protocol)
        }</span>

        // Validate the move operation
        <span class="cov0" title="0">if err := handler.ValidateMove(ctx, client, oldMove.Path, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("move validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">tx, err := rt.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Record the rename event
        renameEventID, err := rt.recordUniversalRenameEvent(tx, oldMove, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to record rename event: %w", err)
        }</span>

        // Perform protocol-specific move if needed
        <span class="cov0" title="0">if handler.SupportsRealTimeNotification() </span><span class="cov0" title="0">{
                // For protocols with real-time notifications, just update database
                if oldMove.IsDirectory </span><span class="cov0" title="0">{
                        err = rt.moveDirectory(tx, oldMove.Path, newPath, oldMove.StorageRoot)
                }</span> else<span class="cov0" title="0"> {
                        err = rt.moveFile(tx, oldMove.FileID, newPath)
                }</span>
        } else<span class="cov0" title="0"> {
                // For polling-based protocols, perform actual file system move
                if err = handler.PerformMove(ctx, client, oldMove.Path, newPath, oldMove.IsDirectory); err != nil </span><span class="cov0" title="0">{
                        rt.markRenameEventStatus(tx, renameEventID, "failed")
                        return fmt.Errorf("failed to perform protocol move: %w", err)
                }</span>

                <span class="cov0" title="0">if oldMove.IsDirectory </span><span class="cov0" title="0">{
                        err = rt.moveDirectory(tx, oldMove.Path, newPath, oldMove.StorageRoot)
                }</span> else<span class="cov0" title="0"> {
                        err = rt.moveFile(tx, oldMove.FileID, newPath)
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                rt.markRenameEventStatus(tx, renameEventID, "failed")
                return fmt.Errorf("failed to process move: %w", err)
        }</span>

        // Mark rename event as processed
        <span class="cov0" title="0">if err = rt.markRenameEventStatus(tx, renameEventID, "processed"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark rename event as processed: %w", err)
        }</span>

        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit move transaction: %w", err)
        }</span>

        <span class="cov0" title="0">rt.logger.Info("Successfully processed universal move operation",
                zap.String("old_path", oldMove.Path),
                zap.String("new_path", newPath),
                zap.String("protocol", oldMove.Protocol),
                zap.Bool("is_directory", oldMove.IsDirectory),
                zap.Int64("rename_event_id", renameEventID))

        return nil</span>
}

// createFallbackKey creates a fallback key when protocol-specific identification fails
func (rt *UniversalRenameTracker) createFallbackKey(protocol, storageRoot string, fileHash *string, size int64, isDirectory bool) string <span class="cov0" title="0">{
        hashStr := "nil"
        if fileHash != nil </span><span class="cov0" title="0">{
                hashStr = *fileHash
        }</span>

        <span class="cov0" title="0">dirStr := "false"
        if isDirectory </span><span class="cov0" title="0">{
                dirStr = "true"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("fallback:%s:%s:%d:%s", protocol, hashStr, size, dirStr)</span>
}

// moveFile updates a single file's path and metadata
func (rt *UniversalRenameTracker) moveFile(tx *sql.Tx, fileID int64, newPath string) error <span class="cov0" title="0">{
        newName := filepath.Base(newPath)
        newDir := filepath.Dir(newPath)

        var parentID *int64
        if newDir != "/" &amp;&amp; newDir != "." </span><span class="cov0" title="0">{
                parentQuery := `SELECT id FROM files WHERE path = ? AND is_directory = true LIMIT 1`
                err := tx.QueryRow(parentQuery, newDir).Scan(&amp;parentID)
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get parent directory: %w", err)
                }</span>
        }

        <span class="cov0" title="0">updateQuery := `
                UPDATE files
                SET path = ?, name = ?, parent_id = ?, modified_at = CURRENT_TIMESTAMP,
                    last_scan_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := tx.Exec(updateQuery, newPath, newName, parentID, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update file path: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// moveDirectory updates a directory and all its children
func (rt *UniversalRenameTracker) moveDirectory(tx *sql.Tx, oldPath, newPath, storageRootName string) error <span class="cov0" title="0">{
        query := `
                SELECT id, path, is_directory
                FROM files
                WHERE storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)
                  AND (path = ? OR path LIKE ?)
                ORDER BY LENGTH(path) ASC`

        oldPathPattern := oldPath + "/%"
        rows, err := tx.Query(query, storageRootName, oldPath, oldPathPattern)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query directory contents: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        type fileUpdate struct {
                ID          int64
                OldPath     string
                IsDirectory bool
        }

        var updates []fileUpdate
        for rows.Next() </span><span class="cov0" title="0">{
                var update fileUpdate
                if err := rows.Scan(&amp;update.ID, &amp;update.OldPath, &amp;update.IsDirectory); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan file for update: %w", err)
                }</span>
                <span class="cov0" title="0">updates = append(updates, update)</span>
        }

        <span class="cov0" title="0">for _, update := range updates </span><span class="cov0" title="0">{
                var updatedPath string
                if update.OldPath == oldPath </span><span class="cov0" title="0">{
                        updatedPath = newPath
                }</span> else<span class="cov0" title="0"> {
                        relativePath := update.OldPath[len(oldPath):]
                        updatedPath = newPath + relativePath
                }</span>

                <span class="cov0" title="0">if err := rt.moveFile(tx, update.ID, updatedPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update path for file ID %d: %w", update.ID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// recordUniversalRenameEvent creates a record of the rename operation
func (rt *UniversalRenameTracker) recordUniversalRenameEvent(tx *sql.Tx, oldMove *UniversalPendingMove, newPath string) (int64, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO universal_rename_events (storage_root_id, protocol, old_path, new_path, is_directory, size, file_hash, detected_at, status)
                VALUES ((SELECT id FROM storage_roots WHERE name = ?), ?, ?, ?, ?, ?, ?, ?, 'pending')`

        result, err := tx.Exec(query, oldMove.StorageRoot, oldMove.Protocol, oldMove.Path, newPath, oldMove.IsDirectory, oldMove.Size, oldMove.FileHash, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to insert universal rename event: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get rename event ID: %w", err)
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

// markRenameEventStatus updates the status of a rename event
func (rt *UniversalRenameTracker) markRenameEventStatus(tx *sql.Tx, eventID int64, status string) error <span class="cov0" title="0">{
        query := `UPDATE universal_rename_events SET status = ?, processed_at = CURRENT_TIMESTAMP WHERE id = ?`
        _, err := tx.Exec(query, status, eventID)
        return err
}</span>

// cleanupWorker periodically cleans up expired pending moves
func (rt *UniversalRenameTracker) cleanupWorker() <span class="cov0" title="0">{
        defer rt.wg.Done()

        ticker := time.NewTicker(rt.cleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-rt.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rt.cleanupExpiredMoves()</span>
                }
        }
}

// cleanupExpiredMoves removes pending moves that have exceeded their protocol-specific time windows
func (rt *UniversalRenameTracker) cleanupExpiredMoves() <span class="cov0" title="0">{
        rt.pendingMovesMu.Lock()
        defer rt.pendingMovesMu.Unlock()

        now := time.Now()
        expiredKeys := make([]string, 0)

        for key, move := range rt.pendingMoves </span><span class="cov0" title="0">{
                handler, exists := rt.protocolHandlers[move.Protocol]
                if !exists </span><span class="cov0" title="0">{
                        // Use default window if no handler
                        if now.Sub(move.DeletedAt) &gt; rt.moveWindow </span><span class="cov0" title="0">{
                                expiredKeys = append(expiredKeys, key)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">moveWindow := handler.GetMoveWindow()
                if now.Sub(move.DeletedAt) &gt; moveWindow </span><span class="cov0" title="0">{
                        expiredKeys = append(expiredKeys, key)
                }</span>
        }

        <span class="cov0" title="0">for _, key := range expiredKeys </span><span class="cov0" title="0">{
                move := rt.pendingMoves[key]
                delete(rt.pendingMoves, key)

                rt.logger.Debug("Cleaned up expired universal pending move",
                        zap.String("path", move.Path),
                        zap.String("storage_root", move.StorageRoot),
                        zap.String("protocol", move.Protocol),
                        zap.Duration("age", now.Sub(move.DeletedAt)))
        }</span>

        <span class="cov0" title="0">if len(expiredKeys) &gt; 0 </span><span class="cov0" title="0">{
                rt.logger.Debug("Cleaned up expired universal pending moves", zap.Int("count", len(expiredKeys)))
        }</span>
}

// GetStatistics returns statistics about universal rename detection
func (rt *UniversalRenameTracker) GetStatistics() map[string]interface{} <span class="cov0" title="0">{
        rt.pendingMovesMu.RLock()

        // Count pending moves by protocol
        pendingByProtocol := make(map[string]int)
        totalPending := 0

        for _, move := range rt.pendingMoves </span><span class="cov0" title="0">{
                pendingByProtocol[move.Protocol]++
                totalPending++
        }</span>

        <span class="cov0" title="0">rt.pendingMovesMu.RUnlock()

        stats := map[string]interface{}{
                "total_pending_moves": totalPending,
                "pending_by_protocol": pendingByProtocol,
                "supported_protocols": rt.getSupportedProtocols(),
        }

        // Get database statistics
        var totalRenames, successfulRenames int
        rt.db.QueryRow("SELECT COUNT(*) FROM universal_rename_events").Scan(&amp;totalRenames)
        rt.db.QueryRow("SELECT COUNT(*) FROM universal_rename_events WHERE status = 'processed'").Scan(&amp;successfulRenames)

        stats["total_renames"] = totalRenames
        stats["successful_renames"] = successfulRenames

        if totalRenames &gt; 0 </span><span class="cov0" title="0">{
                stats["success_rate"] = float64(successfulRenames) / float64(totalRenames) * 100
        }</span> else<span class="cov0" title="0"> {
                stats["success_rate"] = 0.0
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// getSupportedProtocols returns a list of supported protocols
func (rt *UniversalRenameTracker) getSupportedProtocols() []string <span class="cov0" title="0">{
        protocols := make([]string, 0, len(rt.protocolHandlers))
        for protocol := range rt.protocolHandlers </span><span class="cov0" title="0">{
                protocols = append(protocols, protocol)
        }</span>
        <span class="cov0" title="0">return protocols</span>
}

// InitializeTables creates the universal rename tracking tables
func (rt *UniversalRenameTracker) InitializeTables() error <span class="cov0" title="0">{
        query := `
                CREATE TABLE IF NOT EXISTS universal_rename_events (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        storage_root_id INTEGER NOT NULL,
                        protocol TEXT NOT NULL,
                        old_path TEXT NOT NULL,
                        new_path TEXT NOT NULL,
                        is_directory BOOLEAN NOT NULL,
                        size INTEGER NOT NULL,
                        file_hash TEXT,
                        detected_at TIMESTAMP NOT NULL,
                        processed_at TIMESTAMP,
                        status TEXT NOT NULL DEFAULT 'pending',
                        FOREIGN KEY (storage_root_id) REFERENCES storage_roots (id)
                );

                CREATE INDEX IF NOT EXISTS idx_universal_rename_events_storage_root ON universal_rename_events(storage_root_id);
                CREATE INDEX IF NOT EXISTS idx_universal_rename_events_protocol ON universal_rename_events(protocol);
                CREATE INDEX IF NOT EXISTS idx_universal_rename_events_detected_at ON universal_rename_events(detected_at);
                CREATE INDEX IF NOT EXISTS idx_universal_rename_events_status ON universal_rename_events(status);
        `

        _, err := rt.db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create universal rename tracking tables: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package services

import (
        "catalogizer/filesystem"
        "catalogizer/models"
        "context"
        "database/sql"
        "fmt"
        "path/filepath"
        "sync"
        "time"

        "go.uber.org/zap"
)

// UniversalScanner handles file system scanning across all supported protocols
type UniversalScanner struct {
        db               *sql.DB
        logger           *zap.Logger
        renameTracker    *UniversalRenameTracker
        clientFactory    filesystem.ClientFactory
        scanQueue        chan ScanJob
        workers          int
        stopCh           chan struct{}
        wg               sync.WaitGroup
        protocolScanners map[string]ProtocolScanner
        activeScansMu    sync.RWMutex
        activeScans      map[string]*ScanStatus
}

// ScanJob represents a scan operation for any protocol
type ScanJob struct {
        ID              string
        StorageRoot     *models.StorageRoot
        Path            string
        Priority        int
        ScanType        string // full, incremental, verify
        MaxDepth        int
        IncludePatterns []string
        ExcludePatterns []string
        Context         context.Context
}

// ScanStatus tracks the status of an active scan
type ScanStatus struct {
        JobID           string
        StorageRootName string
        Protocol        string
        StartTime       time.Time
        CurrentPath     string
        FilesProcessed  int64
        FilesFound      int64
        FilesUpdated    int64
        FilesDeleted    int64
        ErrorCount      int64
        Status          string // running, completed, failed, cancelled
        mu              sync.RWMutex
}

// ProtocolScanner defines protocol-specific scanning behavior
type ProtocolScanner interface {
        // ScanPath performs a scan of the specified path
        ScanPath(ctx context.Context, client filesystem.FileSystemClient, job ScanJob, status *ScanStatus) error

        // GetScanStrategy returns the optimal scanning strategy for this protocol
        GetScanStrategy() ScanStrategy

        // SupportsIncrementalScan indicates if the protocol supports incremental scanning
        SupportsIncrementalScan() bool

        // GetOptimalBatchSize returns the optimal batch size for database operations
        GetOptimalBatchSize() int
}

// ScanStrategy defines how scanning should be performed
type ScanStrategy struct {
        UseRecursiveListing     bool
        BatchSize               int
        ParallelDirectories     bool
        ChecksumCalculation     bool
        MetadataExtraction      bool
        RealTimeChangeDetection bool
}

// NewUniversalScanner creates a new universal file system scanner
func NewUniversalScanner(db *sql.DB, logger *zap.Logger, renameTracker *UniversalRenameTracker, clientFactory filesystem.ClientFactory) *UniversalScanner <span class="cov0" title="0">{
        scanner := &amp;UniversalScanner{
                db:               db,
                logger:           logger,
                renameTracker:    renameTracker,
                clientFactory:    clientFactory,
                scanQueue:        make(chan ScanJob, 1000),
                workers:          4,
                stopCh:           make(chan struct{}),
                protocolScanners: make(map[string]ProtocolScanner),
                activeScans:      make(map[string]*ScanStatus),
        }

        // Register protocol scanners
        scanner.RegisterProtocolScanner("local", NewLocalScanner(logger))
        scanner.RegisterProtocolScanner("smb", NewSMBScanner(logger))
        scanner.RegisterProtocolScanner("ftp", NewFTPScanner(logger))
        scanner.RegisterProtocolScanner("nfs", NewNFSScanner(logger))
        scanner.RegisterProtocolScanner("webdav", NewWebDAVScanner(logger))

        return scanner
}</span>

// RegisterProtocolScanner registers a protocol-specific scanner
func (s *UniversalScanner) RegisterProtocolScanner(protocol string, scanner ProtocolScanner) <span class="cov0" title="0">{
        s.protocolScanners[protocol] = scanner
}</span>

// Start begins the universal scanning service
func (s *UniversalScanner) Start() error <span class="cov0" title="0">{
        s.logger.Info("Starting universal scanner service", zap.Int("workers", s.workers))

        // Start worker goroutines
        for i := 0; i &lt; s.workers; i++ </span><span class="cov0" title="0">{
                s.wg.Add(1)
                go s.scanWorker(i)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the universal scanning service
func (s *UniversalScanner) Stop() <span class="cov0" title="0">{
        s.logger.Info("Stopping universal scanner service")
        close(s.stopCh)
        s.wg.Wait()
        s.logger.Info("Universal scanner service stopped")
}</span>

// QueueScan adds a scan job to the queue
func (s *UniversalScanner) QueueScan(job ScanJob) error <span class="cov0" title="0">{
        select </span>{
        case s.scanQueue &lt;- job:<span class="cov0" title="0">
                s.logger.Debug("Queued scan job",
                        zap.String("job_id", job.ID),
                        zap.String("storage_root", job.StorageRoot.Name),
                        zap.String("protocol", job.StorageRoot.Protocol),
                        zap.String("path", job.Path))
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("scan queue is full")</span>
        }
}

// scanWorker processes scan jobs
func (s *UniversalScanner) scanWorker(workerID int) <span class="cov0" title="0">{
        defer s.wg.Done()

        s.logger.Info("Universal scan worker started", zap.Int("worker_id", workerID))

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-s.stopCh:<span class="cov0" title="0">
                        return</span>
                case job := &lt;-s.scanQueue:<span class="cov0" title="0">
                        s.processScanJob(job, workerID)</span>
                }
        }
}

// processScanJob processes a single scan job
func (s *UniversalScanner) processScanJob(job ScanJob, workerID int) <span class="cov0" title="0">{
        s.logger.Debug("Processing scan job",
                zap.Int("worker_id", workerID),
                zap.String("job_id", job.ID),
                zap.String("storage_root", job.StorageRoot.Name),
                zap.String("protocol", job.StorageRoot.Protocol))

        // Create scan status
        status := &amp;ScanStatus{
                JobID:           job.ID,
                StorageRootName: job.StorageRoot.Name,
                Protocol:        job.StorageRoot.Protocol,
                StartTime:       time.Now(),
                Status:          "running",
        }

        // Track active scan
        s.activeScansMu.Lock()
        s.activeScans[job.ID] = status
        s.activeScansMu.Unlock()

        // Cleanup on completion
        defer func() </span><span class="cov0" title="0">{
                s.activeScansMu.Lock()
                delete(s.activeScans, job.ID)
                s.activeScansMu.Unlock()
        }</span>()

        // Get protocol scanner
        <span class="cov0" title="0">protocolScanner, exists := s.protocolScanners[job.StorageRoot.Protocol]
        if !exists </span><span class="cov0" title="0">{
                s.logger.Error("No scanner for protocol",
                        zap.String("protocol", job.StorageRoot.Protocol),
                        zap.String("job_id", job.ID))
                status.updateStatus("failed")
                return
        }</span>

        // Create filesystem client
        <span class="cov0" title="0">client, err := s.clientFactory.CreateClient(&amp;filesystem.StorageConfig{
                ID:       job.StorageRoot.Name,
                Name:     job.StorageRoot.Name,
                Protocol: job.StorageRoot.Protocol,
                Settings: s.storageRootToSettings(job.StorageRoot),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create filesystem client",
                        zap.String("protocol", job.StorageRoot.Protocol),
                        zap.String("job_id", job.ID),
                        zap.Error(err))
                status.updateStatus("failed")
                return
        }</span>

        // Connect to filesystem
        <span class="cov0" title="0">if err := client.Connect(job.Context); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to connect to filesystem",
                        zap.String("protocol", job.StorageRoot.Protocol),
                        zap.String("job_id", job.ID),
                        zap.Error(err))
                status.updateStatus("failed")
                return
        }</span>
        <span class="cov0" title="0">defer client.Disconnect(job.Context)

        // Perform the scan
        if err := protocolScanner.ScanPath(job.Context, client, job, status); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Scan failed",
                        zap.String("job_id", job.ID),
                        zap.Error(err))
                status.updateStatus("failed")
                return
        }</span>

        <span class="cov0" title="0">status.updateStatus("completed")
        s.logger.Info("Scan completed successfully",
                zap.String("job_id", job.ID),
                zap.String("storage_root", job.StorageRoot.Name),
                zap.Int64("files_processed", status.FilesProcessed),
                zap.Duration("duration", time.Since(status.StartTime)))</span>
}

// GetActiveScanStatus returns the status of an active scan
func (s *UniversalScanner) GetActiveScanStatus(jobID string) (*ScanStatus, bool) <span class="cov0" title="0">{
        s.activeScansMu.RLock()
        defer s.activeScansMu.RUnlock()
        status, exists := s.activeScans[jobID]
        return status, exists
}</span>

// GetAllActiveScanStatuses returns all active scan statuses
func (s *UniversalScanner) GetAllActiveScanStatuses() map[string]*ScanStatus <span class="cov0" title="0">{
        s.activeScansMu.RLock()
        defer s.activeScansMu.RUnlock()

        statuses := make(map[string]*ScanStatus)
        for id, status := range s.activeScans </span><span class="cov0" title="0">{
                // Create a copy to avoid race conditions
                statusCopy := &amp;ScanStatus{
                        JobID:           status.JobID,
                        StorageRootName: status.StorageRootName,
                        Protocol:        status.Protocol,
                        StartTime:       status.StartTime,
                        CurrentPath:     status.CurrentPath,
                        FilesProcessed:  status.FilesProcessed,
                        FilesFound:      status.FilesFound,
                        FilesUpdated:    status.FilesUpdated,
                        FilesDeleted:    status.FilesDeleted,
                        ErrorCount:      status.ErrorCount,
                        Status:          status.Status,
                }
                statuses[id] = statusCopy
        }</span>
        <span class="cov0" title="0">return statuses</span>
}

// storageRootToSettings converts StorageRoot to filesystem settings
func (s *UniversalScanner) storageRootToSettings(root *models.StorageRoot) map[string]interface{} <span class="cov0" title="0">{
        settings := make(map[string]interface{})

        switch root.Protocol </span>{
        case "local":<span class="cov0" title="0">
                if root.Path != nil </span><span class="cov0" title="0">{
                        settings["base_path"] = *root.Path
                }</span>

        case "smb":<span class="cov0" title="0">
                if root.Host != nil </span><span class="cov0" title="0">{
                        settings["host"] = *root.Host
                }</span>
                <span class="cov0" title="0">if root.Port != nil </span><span class="cov0" title="0">{
                        settings["port"] = *root.Port
                }</span>
                <span class="cov0" title="0">if root.Path != nil </span><span class="cov0" title="0">{
                        settings["share"] = *root.Path
                }</span>
                <span class="cov0" title="0">if root.Username != nil </span><span class="cov0" title="0">{
                        settings["username"] = *root.Username
                }</span>
                <span class="cov0" title="0">if root.Password != nil </span><span class="cov0" title="0">{
                        settings["password"] = *root.Password
                }</span>
                <span class="cov0" title="0">if root.Domain != nil </span><span class="cov0" title="0">{
                        settings["domain"] = *root.Domain
                }</span>

        case "ftp":<span class="cov0" title="0">
                if root.Host != nil </span><span class="cov0" title="0">{
                        settings["host"] = *root.Host
                }</span>
                <span class="cov0" title="0">if root.Port != nil </span><span class="cov0" title="0">{
                        settings["port"] = *root.Port
                }</span>
                <span class="cov0" title="0">if root.Username != nil </span><span class="cov0" title="0">{
                        settings["username"] = *root.Username
                }</span>
                <span class="cov0" title="0">if root.Password != nil </span><span class="cov0" title="0">{
                        settings["password"] = *root.Password
                }</span>

        case "nfs":<span class="cov0" title="0">
                if root.Host != nil </span><span class="cov0" title="0">{
                        settings["host"] = *root.Host
                }</span>
                <span class="cov0" title="0">if root.Path != nil </span><span class="cov0" title="0">{
                        settings["export_path"] = *root.Path
                }</span>
                <span class="cov0" title="0">if root.MountPoint != nil </span><span class="cov0" title="0">{
                        settings["mount_point"] = *root.MountPoint
                }</span>
                <span class="cov0" title="0">if root.Options != nil </span><span class="cov0" title="0">{
                        settings["options"] = *root.Options
                }</span>

        case "webdav":<span class="cov0" title="0">
                if root.URL != nil </span><span class="cov0" title="0">{
                        settings["url"] = *root.URL
                }</span>
                <span class="cov0" title="0">if root.Username != nil </span><span class="cov0" title="0">{
                        settings["username"] = *root.Username
                }</span>
                <span class="cov0" title="0">if root.Password != nil </span><span class="cov0" title="0">{
                        settings["password"] = *root.Password
                }</span>
        }

        <span class="cov0" title="0">return settings</span>
}

// updateStatus safely updates the scan status
func (s *ScanStatus) updateStatus(newStatus string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.Status = newStatus
}</span>

// updateCurrentPath safely updates the current path being scanned
func (s *ScanStatus) updateCurrentPath(path string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.CurrentPath = path
}</span>

// incrementCounters safely increments the various counters
func (s *ScanStatus) incrementCounters(processed, found, updated, deleted, errors int64) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.FilesProcessed += processed
        s.FilesFound += found
        s.FilesUpdated += updated
        s.FilesDeleted += deleted
        s.ErrorCount += errors
}</span>

// GetSnapshot returns a thread-safe snapshot of the scan status
func (s *ScanStatus) GetSnapshot() ScanStatus <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return ScanStatus{
                JobID:           s.JobID,
                StorageRootName: s.StorageRootName,
                Protocol:        s.Protocol,
                StartTime:       s.StartTime,
                CurrentPath:     s.CurrentPath,
                FilesProcessed:  s.FilesProcessed,
                FilesFound:      s.FilesFound,
                FilesUpdated:    s.FilesUpdated,
                FilesDeleted:    s.FilesDeleted,
                ErrorCount:      s.ErrorCount,
                Status:          s.Status,
        }
}</span>

// LocalScanner implements protocol-specific scanning for local filesystem
type LocalScanner struct {
        logger *zap.Logger
}

func NewLocalScanner(logger *zap.Logger) *LocalScanner <span class="cov0" title="0">{
        return &amp;LocalScanner{logger: logger}
}</span>

func (s *LocalScanner) ScanPath(ctx context.Context, client filesystem.FileSystemClient, job ScanJob, status *ScanStatus) error <span class="cov0" title="0">{
        return s.scanDirectory(ctx, client, job.Path, job, status, 0)
}</span>

func (s *LocalScanner) scanDirectory(ctx context.Context, client filesystem.FileSystemClient, path string, job ScanJob, status *ScanStatus, depth int) error <span class="cov0" title="0">{
        if depth &gt; job.MaxDepth </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">status.updateCurrentPath(path)

        files, err := client.ListDirectory(ctx, path)
        if err != nil </span><span class="cov0" title="0">{
                status.incrementCounters(0, 0, 0, 0, 1)
                return fmt.Errorf("failed to list directory %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">fullPath := filepath.Join(path, file.Name)

                // Process file/directory
                if err := s.processFileInfo(ctx, client, fullPath, file, job, status); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to process file",
                                zap.String("path", fullPath),
                                zap.Error(err))
                        status.incrementCounters(0, 0, 0, 0, 1)
                }</span>

                // Recurse into subdirectories
                <span class="cov0" title="0">if file.IsDir </span><span class="cov0" title="0">{
                        if err := s.scanDirectory(ctx, client, fullPath, job, status, depth+1); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to scan subdirectory",
                                        zap.String("path", fullPath),
                                        zap.Error(err))
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalScanner) processFileInfo(ctx context.Context, client filesystem.FileSystemClient, path string, file *filesystem.FileInfo, job ScanJob, status *ScanStatus) error <span class="cov0" title="0">{
        // Implementation would update database with file information
        // For now, just increment counters
        status.incrementCounters(1, 1, 0, 0, 0)
        return nil
}</span>

func (s *LocalScanner) GetScanStrategy() ScanStrategy <span class="cov0" title="0">{
        return ScanStrategy{
                UseRecursiveListing:     true,
                BatchSize:               1000,
                ParallelDirectories:     true,
                ChecksumCalculation:     true,
                MetadataExtraction:      true,
                RealTimeChangeDetection: true,
        }
}</span>

func (s *LocalScanner) SupportsIncrementalScan() bool <span class="cov0" title="0">{
        return true
}</span>

func (s *LocalScanner) GetOptimalBatchSize() int <span class="cov0" title="0">{
        return 1000
}</span>

// SMBScanner implements protocol-specific scanning for SMB
type SMBScanner struct {
        logger *zap.Logger
}

func NewSMBScanner(logger *zap.Logger) *SMBScanner <span class="cov0" title="0">{
        return &amp;SMBScanner{logger: logger}
}</span>

func (s *SMBScanner) ScanPath(ctx context.Context, client filesystem.FileSystemClient, job ScanJob, status *ScanStatus) error <span class="cov0" title="0">{
        // SMB-specific scanning logic
        return s.scanDirectory(ctx, client, job.Path, job, status, 0)
}</span>

func (s *SMBScanner) scanDirectory(ctx context.Context, client filesystem.FileSystemClient, path string, job ScanJob, status *ScanStatus, depth int) error <span class="cov0" title="0">{
        // Similar to LocalScanner but with SMB-specific optimizations
        if depth &gt; job.MaxDepth </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">status.updateCurrentPath(path)

        files, err := client.ListDirectory(ctx, path)
        if err != nil </span><span class="cov0" title="0">{
                status.incrementCounters(0, 0, 0, 0, 1)
                return fmt.Errorf("failed to list SMB directory %s: %w", path, err)
        }</span>

        // Process files in batches for better SMB performance
        <span class="cov0" title="0">batchSize := s.GetOptimalBatchSize()
        for i := 0; i &lt; len(files); i += batchSize </span><span class="cov0" title="0">{
                end := i + batchSize
                if end &gt; len(files) </span><span class="cov0" title="0">{
                        end = len(files)
                }</span>

                <span class="cov0" title="0">batch := files[i:end]
                for _, file := range batch </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        default:<span class="cov0" title="0"></span>
                        }

                        <span class="cov0" title="0">fullPath := filepath.Join(path, file.Name)
                        status.incrementCounters(1, 1, 0, 0, 0)

                        if file.IsDir </span><span class="cov0" title="0">{
                                if err := s.scanDirectory(ctx, client, fullPath, job, status, depth+1); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("Failed to scan SMB subdirectory",
                                                zap.String("path", fullPath),
                                                zap.Error(err))
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SMBScanner) GetScanStrategy() ScanStrategy <span class="cov0" title="0">{
        return ScanStrategy{
                UseRecursiveListing:     false, // SMB benefits from controlled recursion
                BatchSize:               500,   // Smaller batches for network efficiency
                ParallelDirectories:     false, // Avoid overwhelming SMB server
                ChecksumCalculation:     false, // Expensive over network
                MetadataExtraction:      true,
                RealTimeChangeDetection: false,
        }
}</span>

func (s *SMBScanner) SupportsIncrementalScan() bool <span class="cov0" title="0">{
        return true
}</span>

func (s *SMBScanner) GetOptimalBatchSize() int <span class="cov0" title="0">{
        return 500
}</span>

// Similar implementations for FTP, NFS, and WebDAV scanners...

type FTPScanner struct {
        logger *zap.Logger
}

func NewFTPScanner(logger *zap.Logger) *FTPScanner <span class="cov0" title="0">{
        return &amp;FTPScanner{logger: logger}
}</span>

func (s *FTPScanner) ScanPath(ctx context.Context, client filesystem.FileSystemClient, job ScanJob, status *ScanStatus) error <span class="cov0" title="0">{
        // FTP-specific scanning logic
        return nil
}</span>

func (s *FTPScanner) GetScanStrategy() ScanStrategy <span class="cov0" title="0">{
        return ScanStrategy{
                UseRecursiveListing:     false,
                BatchSize:               100,
                ParallelDirectories:     false,
                ChecksumCalculation:     false,
                MetadataExtraction:      false,
                RealTimeChangeDetection: false,
        }
}</span>

func (s *FTPScanner) SupportsIncrementalScan() bool <span class="cov0" title="0">{
        return false
}</span>

func (s *FTPScanner) GetOptimalBatchSize() int <span class="cov0" title="0">{
        return 100
}</span>

type NFSScanner struct {
        logger *zap.Logger
}

func NewNFSScanner(logger *zap.Logger) *NFSScanner <span class="cov0" title="0">{
        return &amp;NFSScanner{logger: logger}
}</span>

func (s *NFSScanner) ScanPath(ctx context.Context, client filesystem.FileSystemClient, job ScanJob, status *ScanStatus) error <span class="cov0" title="0">{
        // NFS-specific scanning logic
        return nil
}</span>

func (s *NFSScanner) GetScanStrategy() ScanStrategy <span class="cov0" title="0">{
        return ScanStrategy{
                UseRecursiveListing:     true,
                BatchSize:               800,
                ParallelDirectories:     true,
                ChecksumCalculation:     true,
                MetadataExtraction:      true,
                RealTimeChangeDetection: false,
        }
}</span>

func (s *NFSScanner) SupportsIncrementalScan() bool <span class="cov0" title="0">{
        return true
}</span>

func (s *NFSScanner) GetOptimalBatchSize() int <span class="cov0" title="0">{
        return 800
}</span>

type WebDAVScanner struct {
        logger *zap.Logger
}

func NewWebDAVScanner(logger *zap.Logger) *WebDAVScanner <span class="cov0" title="0">{
        return &amp;WebDAVScanner{logger: logger}
}</span>

func (s *WebDAVScanner) ScanPath(ctx context.Context, client filesystem.FileSystemClient, job ScanJob, status *ScanStatus) error <span class="cov0" title="0">{
        // WebDAV-specific scanning logic
        return nil
}</span>

func (s *WebDAVScanner) GetScanStrategy() ScanStrategy <span class="cov0" title="0">{
        return ScanStrategy{
                UseRecursiveListing:     false,
                BatchSize:               200,
                ParallelDirectories:     false,
                ChecksumCalculation:     false,
                MetadataExtraction:      true,
                RealTimeChangeDetection: false,
        }
}</span>

func (s *WebDAVScanner) SupportsIncrementalScan() bool <span class="cov0" title="0">{
        return false
}</span>

func (s *WebDAVScanner) GetOptimalBatchSize() int <span class="cov0" title="0">{
        return 200
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "go.uber.org/zap"
)

type VideoPlayerService struct {
        db                 *sql.DB
        logger             *zap.Logger
        mediaPlayerService *MediaPlayerService
        positionService    *PlaybackPositionService
        subtitleService    *SubtitleService
        coverArtService    *CoverArtService
        translationService *TranslationService
}

type VideoPlaybackSession struct {
        ID               string          `json:"id"`
        UserID           int64           `json:"user_id"`
        CurrentVideo     *VideoContent   `json:"current_video"`
        Playlist         []VideoContent  `json:"playlist"`
        PlaylistIndex    int             `json:"playlist_index"`
        PlayMode         VideoPlayMode   `json:"play_mode"`
        AutoPlay         bool            `json:"auto_play"`
        AutoPlayNext     bool            `json:"auto_play_next"`
        Volume           float64         `json:"volume"`
        IsMuted          bool            `json:"is_muted"`
        PlaybackSpeed    float64         `json:"playback_speed"`
        PlaybackState    PlaybackState   `json:"playback_state"`
        Position         int64           `json:"position"`
        Duration         int64           `json:"duration"`
        BufferedRanges   []BufferedRange `json:"buffered_ranges"`
        SubtitleTracks   []SubtitleTrack `json:"subtitle_tracks"`
        ActiveSubtitle   *int64          `json:"active_subtitle"`
        AudioTracks      []AudioTrack    `json:"audio_tracks"`
        ActiveAudioTrack *int64          `json:"active_audio_track"`
        VideoQuality     VideoQuality    `json:"video_quality"`
        DeviceInfo       DeviceInfo      `json:"device_info"`
        ViewingProgress  ViewingProgress `json:"viewing_progress"`
        Chapters         []Chapter       `json:"chapters"`
        Bookmarks        []VideoBookmark `json:"bookmarks"`
        WatchParty       *WatchPartyInfo `json:"watch_party"`
        LastActivity     time.Time       `json:"last_activity"`
        CreatedAt        time.Time       `json:"created_at"`
        UpdatedAt        time.Time       `json:"updated_at"`
}

type VideoContent struct {
        ID                int64            `json:"id"`
        Title             string           `json:"title"`
        OriginalTitle     string           `json:"original_title"`
        Description       string           `json:"description"`
        Type              VideoType        `json:"type"`
        FilePath          string           `json:"file_path"`
        FileSize          int64            `json:"file_size"`
        Duration          int64            `json:"duration"`
        Resolution        string           `json:"resolution"`
        AspectRatio       string           `json:"aspect_ratio"`
        FrameRate         float64          `json:"frame_rate"`
        Bitrate           int64            `json:"bitrate"`
        Codec             string           `json:"codec"`
        HDR               bool             `json:"hdr"`
        DolbyVision       bool             `json:"dolby_vision"`
        DolbyAtmos        bool             `json:"dolby_atmos"`
        Year              int              `json:"year"`
        ReleaseDate       *time.Time       `json:"release_date"`
        Genres            []string         `json:"genres"`
        Directors         []string         `json:"directors"`
        Actors            []string         `json:"actors"`
        Writers           []string         `json:"writers"`
        Rating            *float64         `json:"rating"`
        IMDbID            string           `json:"imdb_id"`
        TMDbID            string           `json:"tmdb_id"`
        Language          string           `json:"language"`
        Country           string           `json:"country"`
        PlayCount         int64            `json:"play_count"`
        LastPlayed        *time.Time       `json:"last_played"`
        DateAdded         time.Time        `json:"date_added"`
        UserRating        *int             `json:"user_rating"`
        IsFavorite        bool             `json:"is_favorite"`
        WatchedPercentage float64          `json:"watched_percentage"`
        CoverArt          *CoverArt        `json:"cover_art"`
        Backdrop          *CoverArt        `json:"backdrop"`
        Trailer           *TrailerInfo     `json:"trailer"`
        SeriesInfo        *SeriesInfo      `json:"series_info"`
        EpisodeInfo       *EpisodeInfo     `json:"episode_info"`
        MovieInfo         *MovieInfo       `json:"movie_info"`
        Thumbnails        []VideoThumbnail `json:"thumbnails"`
        VideoStreams      []VideoStream    `json:"video_streams"`
        AudioStreams      []AudioStream    `json:"audio_streams"`
        SubtitleStreams   []SubtitleStream `json:"subtitle_streams"`
}

type VideoType string

const (
        VideoTypeMovie   VideoType = "movie"
        VideoTypeEpisode VideoType = "episode"
        VideoTypeClip    VideoType = "clip"
        VideoTypeTrailer VideoType = "trailer"
        VideoTypeOther   VideoType = "other"
)

type VideoPlayMode string

const (
        VideoPlayModeSingle   VideoPlayMode = "single"
        VideoPlayModeEpisode  VideoPlayMode = "episode"
        VideoPlayModeSeason   VideoPlayMode = "season"
        VideoPlayModeSeries   VideoPlayMode = "series"
        VideoPlayModePlaylist VideoPlayMode = "playlist"
)

type VideoQuality string

const (
        Quality480p  VideoQuality = "480p"
        Quality720p  VideoQuality = "720p"
        Quality1080p VideoQuality = "1080p"
        Quality1440p VideoQuality = "1440p"
        Quality2160p VideoQuality = "2160p" // 4K
        Quality4320p VideoQuality = "4320p" // 8K
        QualityAuto  VideoQuality = "auto"
)

type ViewingProgress struct {
        StartedAt        time.Time `json:"started_at"`
        TotalWatchTime   int64     `json:"total_watch_time"`
        SessionWatchTime int64     `json:"session_watch_time"`
        PauseCount       int       `json:"pause_count"`
        SeekCount        int       `json:"seek_count"`
        RewindCount      int       `json:"rewind_count"`
        FastForwardCount int       `json:"fast_forward_count"`
        QualityChanges   int       `json:"quality_changes"`
        BufferingEvents  int       `json:"buffering_events"`
        TotalBufferTime  int64     `json:"total_buffer_time"`
}

type VideoChapter struct {
        ID        int64     `json:"id"`
        Title     string    `json:"title"`
        StartTime int64     `json:"start_time"`
        EndTime   int64     `json:"end_time"`
        Thumbnail *CoverArt `json:"thumbnail"`
}

type VideoBookmark struct {
        ID          int64     `json:"id"`
        UserID      int64     `json:"user_id"`
        VideoID     int64     `json:"video_id"`
        Position    int64     `json:"position"`
        Title       string    `json:"title"`
        Description string    `json:"description"`
        Thumbnail   *CoverArt `json:"thumbnail"`
        CreatedAt   time.Time `json:"created_at"`
}

type WatchPartyInfo struct {
        ID           string    `json:"id"`
        HostUserID   int64     `json:"host_user_id"`
        Participants []int64   `json:"participants"`
        SyncEnabled  bool      `json:"sync_enabled"`
        ChatEnabled  bool      `json:"chat_enabled"`
        CreatedAt    time.Time `json:"created_at"`
}

type TrailerInfo struct {
        URL      string `json:"url"`
        Provider string `json:"provider"`
        Quality  string `json:"quality"`
        Duration int64  `json:"duration"`
}

type SeriesInfo struct {
        ID            int64      `json:"id"`
        Title         string     `json:"title"`
        Description   string     `json:"description"`
        TotalSeasons  int        `json:"total_seasons"`
        TotalEpisodes int        `json:"total_episodes"`
        Status        string     `json:"status"`
        FirstAired    *time.Time `json:"first_aired"`
        LastAired     *time.Time `json:"last_aired"`
        Network       string     `json:"network"`
        Creator       []string   `json:"creator"`
}

type EpisodeInfo struct {
        SeriesID      int64      `json:"series_id"`
        SeasonNumber  int        `json:"season_number"`
        EpisodeNumber int        `json:"episode_number"`
        AirDate       *time.Time `json:"air_date"`
        Runtime       int        `json:"runtime"`
        GuestStars    []string   `json:"guest_stars"`
        NextEpisodeID *int64     `json:"next_episode_id"`
        PrevEpisodeID *int64     `json:"prev_episode_id"`
}

type MovieInfo struct {
        Budget              int64    `json:"budget"`
        Revenue             int64    `json:"revenue"`
        Runtime             int      `json:"runtime"`
        Collection          string   `json:"collection"`
        Studio              []string `json:"studio"`
        ProductionCompanies []string `json:"production_companies"`
}

type VideoThumbnail struct {
        ID        int64     `json:"id"`
        VideoID   int64     `json:"video_id"`
        Position  int64     `json:"position"`
        URL       string    `json:"url"`
        Width     int       `json:"width"`
        Height    int       `json:"height"`
        CreatedAt time.Time `json:"created_at"`
}

type VideoStream struct {
        ID       int64   `json:"id"`
        Index    int     `json:"index"`
        Codec    string  `json:"codec"`
        Width    int     `json:"width"`
        Height   int     `json:"height"`
        Bitrate  int64   `json:"bitrate"`
        FPS      float64 `json:"fps"`
        Language string  `json:"language"`
        Title    string  `json:"title"`
        Default  bool    `json:"default"`
}

type AudioStream struct {
        ID       int64  `json:"id"`
        Index    int    `json:"index"`
        Codec    string `json:"codec"`
        Channels int    `json:"channels"`
        Bitrate  int64  `json:"bitrate"`
        Language string `json:"language"`
        Title    string `json:"title"`
        Default  bool   `json:"default"`
}

type SubtitleStream struct {
        ID       int64  `json:"id"`
        Index    int    `json:"index"`
        Codec    string `json:"codec"`
        Language string `json:"language"`
        Title    string `json:"title"`
        Default  bool   `json:"default"`
        Forced   bool   `json:"forced"`
        External bool   `json:"external"`
        FilePath string `json:"file_path"`
}

type PlayVideoRequest struct {
        UserID       int64         `json:"user_id"`
        VideoID      int64         `json:"video_id"`
        PlayMode     VideoPlayMode `json:"play_mode"`
        StartTime    *int64        `json:"start_time"`
        Quality      VideoQuality  `json:"quality"`
        DeviceInfo   DeviceInfo    `json:"device_info"`
        AutoPlay     bool          `json:"auto_play"`
        SeriesID     *int64        `json:"series_id"`
        SeasonNumber *int          `json:"season_number"`
        PlaylistID   *int64        `json:"playlist_id"`
}

type PlaySeriesRequest struct {
        UserID       int64        `json:"user_id"`
        SeriesID     int64        `json:"series_id"`
        SeasonNumber *int         `json:"season_number"`
        StartEpisode *int         `json:"start_episode"`
        Quality      VideoQuality `json:"quality"`
        DeviceInfo   DeviceInfo   `json:"device_info"`
        AutoPlay     bool         `json:"auto_play"`
}

type UpdateVideoPlaybackRequest struct {
        SessionID      string         `json:"session_id"`
        Position       *int64         `json:"position"`
        State          *PlaybackState `json:"state"`
        Volume         *float64       `json:"volume"`
        IsMuted        *bool          `json:"is_muted"`
        PlaybackSpeed  *float64       `json:"playback_speed"`
        Quality        *VideoQuality  `json:"quality"`
        ActiveSubtitle *int64         `json:"active_subtitle"`
        ActiveAudio    *int64         `json:"active_audio"`
}

type VideoSeekRequest struct {
        SessionID string `json:"session_id"`
        Position  int64  `json:"position"`
}

type CreateVideoBookmarkRequest struct {
        SessionID   string `json:"session_id"`
        Title       string `json:"title"`
        Description string `json:"description"`
}

type WatchHistoryRequest struct {
        UserID    int64      `json:"user_id"`
        StartDate *time.Time `json:"start_date"`
        EndDate   *time.Time `json:"end_date"`
        VideoType *VideoType `json:"video_type"`
        Limit     int        `json:"limit"`
        Offset    int        `json:"offset"`
}

type WatchHistory struct {
        ID             int64        `json:"id"`
        UserID         int64        `json:"user_id"`
        VideoID        int64        `json:"video_id"`
        VideoContent   VideoContent `json:"video_content"`
        WatchedAt      time.Time    `json:"watched_at"`
        WatchDuration  int64        `json:"watch_duration"`
        CompletionRate float64      `json:"completion_rate"`
        StoppedAt      int64        `json:"stopped_at"`
        DeviceInfo     string       `json:"device_info"`
        Quality        string       `json:"quality"`
}

func NewVideoPlayerService(
        db *sql.DB,
        logger *zap.Logger,
        mediaPlayerService *MediaPlayerService,
        positionService *PlaybackPositionService,
        subtitleService *SubtitleService,
        coverArtService *CoverArtService,
        translationService *TranslationService,
) *VideoPlayerService <span class="cov0" title="0">{
        return &amp;VideoPlayerService{
                db:                 db,
                logger:             logger,
                mediaPlayerService: mediaPlayerService,
                positionService:    positionService,
                subtitleService:    subtitleService,
                coverArtService:    coverArtService,
                translationService: translationService,
        }
}</span>

func (s *VideoPlayerService) PlayVideo(ctx context.Context, req *PlayVideoRequest) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting video playback",
                zap.Int64("user_id", req.UserID),
                zap.Int64("video_id", req.VideoID),
                zap.String("play_mode", string(req.PlayMode)))

        video, err := s.getVideoContent(ctx, req.VideoID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get video content: %w", err)
        }</span>

        <span class="cov0" title="0">session := &amp;VideoPlaybackSession{
                ID:            generateSessionID(),
                UserID:        req.UserID,
                CurrentVideo:  video,
                Playlist:      []VideoContent{*video},
                PlaylistIndex: 0,
                PlayMode:      req.PlayMode,
                AutoPlay:      req.AutoPlay,
                AutoPlayNext:  true,
                Volume:        1.0,
                IsMuted:       false,
                PlaybackSpeed: 1.0,
                PlaybackState: PlaybackStatePlaying,
                Position:      0,
                Duration:      video.Duration,
                VideoQuality:  req.Quality,
                DeviceInfo:    req.DeviceInfo,
                ViewingProgress: ViewingProgress{
                        StartedAt: time.Now(),
                },
                LastActivity: time.Now(),
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        if req.StartTime != nil </span><span class="cov0" title="0">{
                session.Position = *req.StartTime
        }</span> else<span class="cov0" title="0"> {
                position, err := s.positionService.GetPosition(ctx, req.UserID, req.VideoID)
                if err == nil &amp;&amp; position != nil &amp;&amp; position.PercentComplete &lt; 90 </span><span class="cov0" title="0">{
                        session.Position = position.Position
                }</span>
        }

        <span class="cov0" title="0">if err := s.loadVideoStreams(ctx, session, video.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load video streams", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.loadSubtitles(ctx, session, video.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load subtitles", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.loadChapters(ctx, session, video.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load chapters", zap.Error(err))
        }</span>

        <span class="cov0" title="0">switch req.PlayMode </span>{
        case VideoPlayModeEpisode:<span class="cov0" title="0">
                if video.EpisodeInfo != nil </span><span class="cov0" title="0">{
                        if err := s.loadEpisodePlaylist(ctx, session, video.EpisodeInfo.SeriesID, video.EpisodeInfo.SeasonNumber); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load episode playlist", zap.Error(err))
                        }</span>
                }
        case VideoPlayModeSeason:<span class="cov0" title="0">
                if req.SeasonNumber != nil &amp;&amp; video.SeriesInfo != nil </span><span class="cov0" title="0">{
                        if err := s.loadSeasonPlaylist(ctx, session, video.SeriesInfo.ID, *req.SeasonNumber); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load season playlist", zap.Error(err))
                        }</span>
                }
        case VideoPlayModeSeries:<span class="cov0" title="0">
                if req.SeriesID != nil </span><span class="cov0" title="0">{
                        if err := s.loadSeriesPlaylist(ctx, session, *req.SeriesID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load series playlist", zap.Error(err))
                        }</span>
                }
        case VideoPlayModePlaylist:<span class="cov0" title="0">
                if req.PlaylistID != nil </span><span class="cov0" title="0">{
                        if err := s.loadVideoPlaylist(ctx, session, *req.PlaylistID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load video playlist", zap.Error(err))
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := s.saveVideoSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.recordVideoPlayback(ctx, req.UserID, video.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to record playback", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *VideoPlayerService) PlaySeries(ctx context.Context, req *PlaySeriesRequest) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting series playback",
                zap.Int64("user_id", req.UserID),
                zap.Int64("series_id", req.SeriesID))

        _, err := s.getSeriesInfo(ctx, req.SeriesID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get series info: %w", err)
        }</span>

        <span class="cov0" title="0">seasonNumber := 1
        if req.SeasonNumber != nil </span><span class="cov0" title="0">{
                seasonNumber = *req.SeasonNumber
        }</span>

        <span class="cov0" title="0">episodes, err := s.getSeasonEpisodes(ctx, req.SeriesID, seasonNumber)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get season episodes: %w", err)
        }</span>

        <span class="cov0" title="0">if len(episodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no episodes found for season %d", seasonNumber)
        }</span>

        <span class="cov0" title="0">startIndex := 0
        if req.StartEpisode != nil &amp;&amp; *req.StartEpisode &lt; len(episodes) </span><span class="cov0" title="0">{
                startIndex = *req.StartEpisode
        }</span>

        <span class="cov0" title="0">session := &amp;VideoPlaybackSession{
                ID:            generateSessionID(),
                UserID:        req.UserID,
                CurrentVideo:  &amp;episodes[startIndex],
                Playlist:      episodes,
                PlaylistIndex: startIndex,
                PlayMode:      VideoPlayModeSeries,
                AutoPlay:      req.AutoPlay,
                AutoPlayNext:  true,
                Volume:        1.0,
                IsMuted:       false,
                PlaybackSpeed: 1.0,
                PlaybackState: PlaybackStatePlaying,
                Position:      0,
                Duration:      episodes[startIndex].Duration,
                VideoQuality:  req.Quality,
                DeviceInfo:    req.DeviceInfo,
                ViewingProgress: ViewingProgress{
                        StartedAt: time.Now(),
                },
                LastActivity: time.Now(),
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        position, err := s.positionService.GetPosition(ctx, req.UserID, episodes[startIndex].ID)
        if err == nil &amp;&amp; position != nil &amp;&amp; position.PercentComplete &lt; 90 </span><span class="cov0" title="0">{
                session.Position = position.Position
        }</span>

        <span class="cov0" title="0">if err := s.loadVideoStreams(ctx, session, episodes[startIndex].ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load video streams", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.loadSubtitles(ctx, session, episodes[startIndex].ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load subtitles", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.saveVideoSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *VideoPlayerService) GetVideoSession(ctx context.Context, sessionID string) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting video session", zap.String("session_id", sessionID))

        query := `
                SELECT session_data, updated_at
                FROM video_playback_sessions
                WHERE id = $1 AND expires_at &gt; NOW()
        `

        var sessionData string
        var updatedAt time.Time
        err := s.db.QueryRowContext(ctx, query, sessionID).Scan(&amp;sessionData, &amp;updatedAt)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session not found or expired")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get session: %w", err)
        }</span>

        <span class="cov0" title="0">var session VideoPlaybackSession
        if err := json.Unmarshal([]byte(sessionData), &amp;session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal session: %w", err)
        }</span>

        <span class="cov0" title="0">session.UpdatedAt = updatedAt
        return &amp;session, nil</span>
}

func (s *VideoPlayerService) UpdateVideoPlayback(ctx context.Context, req *UpdateVideoPlaybackRequest) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Updating video playback", zap.String("session_id", req.SessionID))

        session, err := s.GetVideoSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Position != nil </span><span class="cov0" title="0">{
                oldPosition := session.Position
                session.Position = *req.Position
                session.ViewingProgress.SessionWatchTime += *req.Position - oldPosition

                if err := s.positionService.UpdatePosition(ctx, &amp;UpdatePositionRequest{
                        UserID:          session.UserID,
                        MediaItemID:     session.CurrentVideo.ID,
                        Position:        *req.Position,
                        Duration:        session.Duration,
                        DeviceInfo:      session.DeviceInfo.DeviceName,
                        PlaybackQuality: string(session.VideoQuality),
                }); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to update position", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">if req.State != nil </span><span class="cov0" title="0">{
                session.PlaybackState = *req.State
                if *req.State == PlaybackStatePaused </span><span class="cov0" title="0">{
                        session.ViewingProgress.PauseCount++
                }</span>
        }

        <span class="cov0" title="0">if req.Volume != nil </span><span class="cov0" title="0">{
                session.Volume = *req.Volume
        }</span>

        <span class="cov0" title="0">if req.IsMuted != nil </span><span class="cov0" title="0">{
                session.IsMuted = *req.IsMuted
        }</span>

        <span class="cov0" title="0">if req.PlaybackSpeed != nil </span><span class="cov0" title="0">{
                session.PlaybackSpeed = *req.PlaybackSpeed
        }</span>

        <span class="cov0" title="0">if req.Quality != nil </span><span class="cov0" title="0">{
                if session.VideoQuality != *req.Quality </span><span class="cov0" title="0">{
                        session.ViewingProgress.QualityChanges++
                }</span>
                <span class="cov0" title="0">session.VideoQuality = *req.Quality</span>
        }

        <span class="cov0" title="0">if req.ActiveSubtitle != nil </span><span class="cov0" title="0">{
                session.ActiveSubtitle = req.ActiveSubtitle
        }</span>

        <span class="cov0" title="0">if req.ActiveAudio != nil </span><span class="cov0" title="0">{
                session.ActiveAudioTrack = req.ActiveAudio
        }</span>

        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveVideoSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *VideoPlayerService) NextVideo(ctx context.Context, sessionID string) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Skipping to next video", zap.String("session_id", sessionID))

        session, err := s.GetVideoSession(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if session.PlaylistIndex &gt;= len(session.Playlist)-1 </span><span class="cov0" title="0">{
                session.PlaybackState = PlaybackStateStopped
                return session, nil
        }</span>

        <span class="cov0" title="0">session.PlaylistIndex++
        session.CurrentVideo = &amp;session.Playlist[session.PlaylistIndex]
        session.Position = 0
        session.Duration = session.CurrentVideo.Duration

        position, err := s.positionService.GetPosition(ctx, session.UserID, session.CurrentVideo.ID)
        if err == nil &amp;&amp; position != nil &amp;&amp; position.PercentComplete &lt; 90 </span><span class="cov0" title="0">{
                session.Position = position.Position
        }</span>

        <span class="cov0" title="0">if err := s.loadVideoStreams(ctx, session, session.CurrentVideo.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load video streams", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.loadSubtitles(ctx, session, session.CurrentVideo.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load subtitles", zap.Error(err))
        }</span>

        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveVideoSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.recordVideoPlayback(ctx, session.UserID, session.CurrentVideo.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to record playback", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *VideoPlayerService) PreviousVideo(ctx context.Context, sessionID string) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Skipping to previous video", zap.String("session_id", sessionID))

        session, err := s.GetVideoSession(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if session.Position &gt; 10000 </span><span class="cov0" title="0">{
                session.Position = 0
        }</span> else<span class="cov0" title="0"> if session.PlaylistIndex &gt; 0 </span><span class="cov0" title="0">{
                session.PlaylistIndex--
                session.CurrentVideo = &amp;session.Playlist[session.PlaylistIndex]
                session.Duration = session.CurrentVideo.Duration

                position, err := s.positionService.GetPosition(ctx, session.UserID, session.CurrentVideo.ID)
                if err == nil &amp;&amp; position != nil &amp;&amp; position.PercentComplete &lt; 90 </span><span class="cov0" title="0">{
                        session.Position = position.Position
                }</span> else<span class="cov0" title="0"> {
                        session.Position = 0
                }</span>

                <span class="cov0" title="0">if err := s.loadVideoStreams(ctx, session, session.CurrentVideo.ID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to load video streams", zap.Error(err))
                }</span>

                <span class="cov0" title="0">if err := s.loadSubtitles(ctx, session, session.CurrentVideo.ID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to load subtitles", zap.Error(err))
                }</span>
        } else<span class="cov0" title="0"> {
                session.Position = 0
        }</span>

        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveVideoSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *VideoPlayerService) SeekVideo(ctx context.Context, req *VideoSeekRequest) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Seeking in video",
                zap.String("session_id", req.SessionID),
                zap.Int64("position", req.Position))

        session, err := s.GetVideoSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Position &lt; 0 </span><span class="cov0" title="0">{
                req.Position = 0
        }</span>
        <span class="cov0" title="0">if req.Position &gt; session.Duration </span><span class="cov0" title="0">{
                req.Position = session.Duration
        }</span>

        <span class="cov0" title="0">if req.Position &lt; session.Position </span><span class="cov0" title="0">{
                session.ViewingProgress.RewindCount++
        }</span> else<span class="cov0" title="0"> if req.Position &gt; session.Position+5000 </span><span class="cov0" title="0">{
                session.ViewingProgress.FastForwardCount++
        }</span>

        <span class="cov0" title="0">session.ViewingProgress.SeekCount++
        session.Position = req.Position
        session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveVideoSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *VideoPlayerService) CreateVideoBookmark(ctx context.Context, req *CreateVideoBookmarkRequest) (*VideoBookmark, error) <span class="cov0" title="0">{
        s.logger.Info("Creating video bookmark", zap.String("session_id", req.SessionID))

        session, err := s.GetVideoSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">thumbnail, err := s.generateThumbnail(ctx, session.CurrentVideo.ID, session.Position)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to generate thumbnail", zap.Error(err))
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO video_bookmarks (user_id, video_id, position, title, description, thumbnail_url, created_at)
                VALUES ($1, $2, $3, $4, $5, $6, NOW())
                RETURNING id, created_at
        `

        var bookmark VideoBookmark
        var thumbnailURL string
        if thumbnail != nil &amp;&amp; thumbnail.URL != nil </span><span class="cov0" title="0">{
                thumbnailURL = *thumbnail.URL
        }</span>

        <span class="cov0" title="0">err = s.db.QueryRowContext(ctx, query,
                session.UserID, session.CurrentVideo.ID, session.Position,
                req.Title, req.Description, thumbnailURL).Scan(
                &amp;bookmark.ID, &amp;bookmark.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create bookmark: %w", err)
        }</span>

        <span class="cov0" title="0">bookmark.UserID = session.UserID
        bookmark.VideoID = session.CurrentVideo.ID
        bookmark.Position = session.Position
        bookmark.Title = req.Title
        bookmark.Description = req.Description
        bookmark.Thumbnail = thumbnail

        return &amp;bookmark, nil</span>
}

func (s *VideoPlayerService) GetWatchHistory(ctx context.Context, req *WatchHistoryRequest) ([]WatchHistory, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting watch history", zap.Int64("user_id", req.UserID))

        baseQuery := `
                SELECT vh.id, vh.user_id, vh.video_id, vh.watched_at, vh.watch_duration,
                           vh.completion_rate, vh.stopped_at, vh.device_info, vh.quality
                FROM video_watch_history vh
                WHERE vh.user_id = $1
        `

        args := []interface{}{req.UserID}
        argIndex := 2

        if req.StartDate != nil </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" AND vh.watched_at &gt;= $%d", argIndex)
                args = append(args, *req.StartDate)
                argIndex++
        }</span>

        <span class="cov0" title="0">if req.EndDate != nil </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" AND vh.watched_at &lt;= $%d", argIndex)
                args = append(args, *req.EndDate)
                argIndex++
        }</span>

        <span class="cov0" title="0">if req.VideoType != nil </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" AND mi.type = $%d", argIndex)
                args = append(args, string(*req.VideoType))
                argIndex++
                baseQuery = strings.Replace(baseQuery, "FROM video_watch_history vh",
                        "FROM video_watch_history vh INNER JOIN media_items mi ON vh.video_id = mi.id", 1)
        }</span>

        <span class="cov0" title="0">baseQuery += " ORDER BY vh.watched_at DESC"

        if req.Limit &gt; 0 </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" LIMIT $%d", argIndex)
                args = append(args, req.Limit)
                argIndex++
        }</span>

        <span class="cov0" title="0">if req.Offset &gt; 0 </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" OFFSET $%d", argIndex)
                args = append(args, req.Offset)
        }</span>

        <span class="cov0" title="0">rows, err := s.db.QueryContext(ctx, baseQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get watch history: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var history []WatchHistory
        var videoIDs []int64

        for rows.Next() </span><span class="cov0" title="0">{
                var item WatchHistory
                err := rows.Scan(
                        &amp;item.ID, &amp;item.UserID, &amp;item.VideoID, &amp;item.WatchedAt,
                        &amp;item.WatchDuration, &amp;item.CompletionRate, &amp;item.StoppedAt,
                        &amp;item.DeviceInfo, &amp;item.Quality,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">history = append(history, item)
                videoIDs = append(videoIDs, item.VideoID)</span>
        }

        <span class="cov0" title="0">videoMap, err := s.getVideoContentsMap(ctx, videoIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load video contents", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                for i := range history </span><span class="cov0" title="0">{
                        if video, exists := videoMap[history[i].VideoID]; exists </span><span class="cov0" title="0">{
                                history[i].VideoContent = video
                        }</span>
                }
        }

        <span class="cov0" title="0">return history, nil</span>
}

func (s *VideoPlayerService) GetContinueWatching(ctx context.Context, userID int64, limit int) ([]VideoContent, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting continue watching", zap.Int64("user_id", userID))

        query := `
                SELECT DISTINCT pp.media_item_id
                FROM playback_positions pp
                INNER JOIN media_items mi ON pp.media_item_id = mi.id
                WHERE pp.user_id = $1
                  AND mi.type = 'video'
                  AND pp.percent_complete BETWEEN 5 AND 90
                  AND pp.last_played &gt; NOW() - INTERVAL '30 days'
                ORDER BY pp.last_played DESC
                LIMIT $2
        `

        rows, err := s.db.QueryContext(ctx, query, userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get continue watching: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var videoIDs []int64
        for rows.Next() </span><span class="cov0" title="0">{
                var videoID int64
                if err := rows.Scan(&amp;videoID); err == nil </span><span class="cov0" title="0">{
                        videoIDs = append(videoIDs, videoID)
                }</span>
        }

        <span class="cov0" title="0">videos, err := s.getVideoContents(ctx, videoIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get video contents: %w", err)
        }</span>

        <span class="cov0" title="0">return videos, nil</span>
}

func (s *VideoPlayerService) getVideoContent(ctx context.Context, videoID int64) (*VideoContent, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, original_title, description, type, file_path, file_size,
                           duration, resolution, aspect_ratio, frame_rate, bitrate, codec,
                           hdr, dolby_vision, dolby_atmos, year, release_date, genres,
                           directors, actors, writers, rating, imdb_id, tmdb_id, language,
                           country, play_count, last_played, date_added, user_rating,
                           is_favorite, watched_percentage
                FROM media_items
                WHERE id = $1 AND type = 'video'
        `

        var video VideoContent
        var releaseDate sql.NullTime
        var lastPlayed sql.NullTime
        var genresJSON, directorsJSON, actorsJSON, writersJSON sql.NullString
        var rating sql.NullFloat64
        var userRating sql.NullInt64

        err := s.db.QueryRowContext(ctx, query, videoID).Scan(
                &amp;video.ID, &amp;video.Title, &amp;video.OriginalTitle, &amp;video.Description,
                &amp;video.Type, &amp;video.FilePath, &amp;video.FileSize, &amp;video.Duration,
                &amp;video.Resolution, &amp;video.AspectRatio, &amp;video.FrameRate, &amp;video.Bitrate,
                &amp;video.Codec, &amp;video.HDR, &amp;video.DolbyVision, &amp;video.DolbyAtmos,
                &amp;video.Year, &amp;releaseDate, &amp;genresJSON, &amp;directorsJSON, &amp;actorsJSON,
                &amp;writersJSON, &amp;rating, &amp;video.IMDbID, &amp;video.TMDbID, &amp;video.Language,
                &amp;video.Country, &amp;video.PlayCount, &amp;lastPlayed, &amp;video.DateAdded,
                &amp;userRating, &amp;video.IsFavorite, &amp;video.WatchedPercentage,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if releaseDate.Valid </span><span class="cov0" title="0">{
                video.ReleaseDate = &amp;releaseDate.Time
        }</span>
        <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                video.LastPlayed = &amp;lastPlayed.Time
        }</span>
        <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                video.Rating = &amp;rating.Float64
        }</span>
        <span class="cov0" title="0">if userRating.Valid </span><span class="cov0" title="0">{
                ratingInt := int(userRating.Int64)
                video.UserRating = &amp;ratingInt
        }</span>

        <span class="cov0" title="0">if genresJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(genresJSON.String), &amp;video.Genres)
        }</span>
        <span class="cov0" title="0">if directorsJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(directorsJSON.String), &amp;video.Directors)
        }</span>
        <span class="cov0" title="0">if actorsJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(actorsJSON.String), &amp;video.Actors)
        }</span>
        <span class="cov0" title="0">if writersJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(writersJSON.String), &amp;video.Writers)
        }</span>

        <span class="cov0" title="0">if err := s.loadVideoMetadata(ctx, &amp;video); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load video metadata", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return &amp;video, nil</span>
}

func (s *VideoPlayerService) getVideoContents(ctx context.Context, videoIDs []int64) ([]VideoContent, error) <span class="cov0" title="0">{
        if len(videoIDs) == 0 </span><span class="cov0" title="0">{
                return []VideoContent{}, nil
        }</span>

        <span class="cov0" title="0">videoMap, err := s.getVideoContentsMap(ctx, videoIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var videos []VideoContent
        for _, id := range videoIDs </span><span class="cov0" title="0">{
                if video, exists := videoMap[id]; exists </span><span class="cov0" title="0">{
                        videos = append(videos, video)
                }</span>
        }

        <span class="cov0" title="0">return videos, nil</span>
}

func (s *VideoPlayerService) getVideoContentsMap(ctx context.Context, videoIDs []int64) (map[int64]VideoContent, error) <span class="cov0" title="0">{
        if len(videoIDs) == 0 </span><span class="cov0" title="0">{
                return make(map[int64]VideoContent), nil
        }</span>

        <span class="cov0" title="0">placeholders := make([]string, len(videoIDs))
        args := make([]interface{}, len(videoIDs))
        for i, id := range videoIDs </span><span class="cov0" title="0">{
                placeholders[i] = fmt.Sprintf("$%d", i+1)
                args[i] = id
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT id, title, original_title, description, type, file_path, file_size,
                           duration, resolution, aspect_ratio, frame_rate, bitrate, codec,
                           hdr, dolby_vision, dolby_atmos, year, release_date, genres,
                           directors, actors, writers, rating, imdb_id, tmdb_id, language,
                           country, play_count, last_played, date_added, user_rating,
                           is_favorite, watched_percentage
                FROM media_items
                WHERE id IN (%s) AND type = 'video'
        `, strings.Join(placeholders, ","))

        rows, err := s.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        videoMap := make(map[int64]VideoContent)
        for rows.Next() </span><span class="cov0" title="0">{
                var video VideoContent
                var releaseDate sql.NullTime
                var lastPlayed sql.NullTime
                var genresJSON, directorsJSON, actorsJSON, writersJSON sql.NullString
                var rating sql.NullFloat64
                var userRating sql.NullInt64

                err := rows.Scan(
                        &amp;video.ID, &amp;video.Title, &amp;video.OriginalTitle, &amp;video.Description,
                        &amp;video.Type, &amp;video.FilePath, &amp;video.FileSize, &amp;video.Duration,
                        &amp;video.Resolution, &amp;video.AspectRatio, &amp;video.FrameRate, &amp;video.Bitrate,
                        &amp;video.Codec, &amp;video.HDR, &amp;video.DolbyVision, &amp;video.DolbyAtmos,
                        &amp;video.Year, &amp;releaseDate, &amp;genresJSON, &amp;directorsJSON, &amp;actorsJSON,
                        &amp;writersJSON, &amp;rating, &amp;video.IMDbID, &amp;video.TMDbID, &amp;video.Language,
                        &amp;video.Country, &amp;video.PlayCount, &amp;lastPlayed, &amp;video.DateAdded,
                        &amp;userRating, &amp;video.IsFavorite, &amp;video.WatchedPercentage,
                )

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if releaseDate.Valid </span><span class="cov0" title="0">{
                        video.ReleaseDate = &amp;releaseDate.Time
                }</span>
                <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                        video.LastPlayed = &amp;lastPlayed.Time
                }</span>
                <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                        video.Rating = &amp;rating.Float64
                }</span>
                <span class="cov0" title="0">if userRating.Valid </span><span class="cov0" title="0">{
                        ratingInt := int(userRating.Int64)
                        video.UserRating = &amp;ratingInt
                }</span>

                <span class="cov0" title="0">if genresJSON.Valid </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(genresJSON.String), &amp;video.Genres)
                }</span>
                <span class="cov0" title="0">if directorsJSON.Valid </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(directorsJSON.String), &amp;video.Directors)
                }</span>
                <span class="cov0" title="0">if actorsJSON.Valid </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(actorsJSON.String), &amp;video.Actors)
                }</span>
                <span class="cov0" title="0">if writersJSON.Valid </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(writersJSON.String), &amp;video.Writers)
                }</span>

                <span class="cov0" title="0">videoMap[video.ID] = video</span>
        }

        <span class="cov0" title="0">return videoMap, nil</span>
}

func (s *VideoPlayerService) getSeriesInfo(ctx context.Context, seriesID int64) (*SeriesInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, description, total_seasons, total_episodes, status,
                           first_aired, last_aired, network, creator
                FROM series
                WHERE id = $1
        `

        var series SeriesInfo
        var firstAired, lastAired sql.NullTime
        var creatorJSON sql.NullString

        err := s.db.QueryRowContext(ctx, query, seriesID).Scan(
                &amp;series.ID, &amp;series.Title, &amp;series.Description, &amp;series.TotalSeasons,
                &amp;series.TotalEpisodes, &amp;series.Status, &amp;firstAired, &amp;lastAired,
                &amp;series.Network, &amp;creatorJSON,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if firstAired.Valid </span><span class="cov0" title="0">{
                series.FirstAired = &amp;firstAired.Time
        }</span>
        <span class="cov0" title="0">if lastAired.Valid </span><span class="cov0" title="0">{
                series.LastAired = &amp;lastAired.Time
        }</span>
        <span class="cov0" title="0">if creatorJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(creatorJSON.String), &amp;series.Creator)
        }</span>

        <span class="cov0" title="0">return &amp;series, nil</span>
}

func (s *VideoPlayerService) getSeasonEpisodes(ctx context.Context, seriesID int64, seasonNumber int) ([]VideoContent, error) <span class="cov0" title="0">{
        query := `
                SELECT mi.id
                FROM media_items mi
                INNER JOIN episodes e ON mi.id = e.media_item_id
                WHERE e.series_id = $1 AND e.season_number = $2 AND mi.type = 'video'
                ORDER BY e.episode_number ASC
        `

        rows, err := s.db.QueryContext(ctx, query, seriesID, seasonNumber)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var episodeIDs []int64
        for rows.Next() </span><span class="cov0" title="0">{
                var episodeID int64
                if err := rows.Scan(&amp;episodeID); err == nil </span><span class="cov0" title="0">{
                        episodeIDs = append(episodeIDs, episodeID)
                }</span>
        }

        <span class="cov0" title="0">return s.getVideoContents(ctx, episodeIDs)</span>
}

func (s *VideoPlayerService) loadVideoMetadata(ctx context.Context, video *VideoContent) error <span class="cov0" title="0">{
        if err := s.loadSeriesInfo(ctx, video); err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to load series info", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.loadEpisodeInfo(ctx, video); err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to load episode info", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.loadMovieInfo(ctx, video); err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to load movie info", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *VideoPlayerService) loadSeriesInfo(ctx context.Context, video *VideoContent) error <span class="cov0" title="0">{
        if video.Type != VideoTypeEpisode </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := `
                SELECT s.id, s.title, s.description, s.total_seasons, s.total_episodes,
                           s.status, s.first_aired, s.last_aired, s.network, s.creator
                FROM series s
                INNER JOIN episodes e ON s.id = e.series_id
                WHERE e.media_item_id = $1
        `

        var series SeriesInfo
        var firstAired, lastAired sql.NullTime
        var creatorJSON sql.NullString

        err := s.db.QueryRowContext(ctx, query, video.ID).Scan(
                &amp;series.ID, &amp;series.Title, &amp;series.Description, &amp;series.TotalSeasons,
                &amp;series.TotalEpisodes, &amp;series.Status, &amp;firstAired, &amp;lastAired,
                &amp;series.Network, &amp;creatorJSON,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if firstAired.Valid </span><span class="cov0" title="0">{
                series.FirstAired = &amp;firstAired.Time
        }</span>
        <span class="cov0" title="0">if lastAired.Valid </span><span class="cov0" title="0">{
                series.LastAired = &amp;lastAired.Time
        }</span>
        <span class="cov0" title="0">if creatorJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(creatorJSON.String), &amp;series.Creator)
        }</span>

        <span class="cov0" title="0">video.SeriesInfo = &amp;series
        return nil</span>
}

func (s *VideoPlayerService) loadEpisodeInfo(ctx context.Context, video *VideoContent) error <span class="cov0" title="0">{
        if video.Type != VideoTypeEpisode </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := `
                SELECT series_id, season_number, episode_number, air_date, runtime, guest_stars,
                           next_episode_id, prev_episode_id
                FROM episodes
                WHERE media_item_id = $1
        `

        var episode EpisodeInfo
        var airDate sql.NullTime
        var guestStarsJSON sql.NullString
        var nextEpisodeID, prevEpisodeID sql.NullInt64

        err := s.db.QueryRowContext(ctx, query, video.ID).Scan(
                &amp;episode.SeriesID, &amp;episode.SeasonNumber, &amp;episode.EpisodeNumber,
                &amp;airDate, &amp;episode.Runtime, &amp;guestStarsJSON, &amp;nextEpisodeID, &amp;prevEpisodeID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if airDate.Valid </span><span class="cov0" title="0">{
                episode.AirDate = &amp;airDate.Time
        }</span>
        <span class="cov0" title="0">if guestStarsJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(guestStarsJSON.String), &amp;episode.GuestStars)
        }</span>
        <span class="cov0" title="0">if nextEpisodeID.Valid </span><span class="cov0" title="0">{
                nextID := nextEpisodeID.Int64
                episode.NextEpisodeID = &amp;nextID
        }</span>
        <span class="cov0" title="0">if prevEpisodeID.Valid </span><span class="cov0" title="0">{
                prevID := prevEpisodeID.Int64
                episode.PrevEpisodeID = &amp;prevID
        }</span>

        <span class="cov0" title="0">video.EpisodeInfo = &amp;episode
        return nil</span>
}

func (s *VideoPlayerService) loadMovieInfo(ctx context.Context, video *VideoContent) error <span class="cov0" title="0">{
        if video.Type != VideoTypeMovie </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := `
                SELECT budget, revenue, runtime, collection, studio, production_companies
                FROM movies
                WHERE media_item_id = $1
        `

        var movie MovieInfo
        var studioJSON, companiesJSON sql.NullString

        err := s.db.QueryRowContext(ctx, query, video.ID).Scan(
                &amp;movie.Budget, &amp;movie.Revenue, &amp;movie.Runtime, &amp;movie.Collection,
                &amp;studioJSON, &amp;companiesJSON,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if studioJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(studioJSON.String), &amp;movie.Studio)
        }</span>
        <span class="cov0" title="0">if companiesJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(companiesJSON.String), &amp;movie.ProductionCompanies)
        }</span>

        <span class="cov0" title="0">video.MovieInfo = &amp;movie
        return nil</span>
}

func (s *VideoPlayerService) loadVideoStreams(ctx context.Context, session *VideoPlaybackSession, videoID int64) error <span class="cov0" title="0">{
        query := `
                SELECT id, stream_index, codec, width, height, bitrate, fps, language, title, is_default
                FROM video_streams
                WHERE media_item_id = $1
                ORDER BY stream_index ASC
        `

        rows, err := s.db.QueryContext(ctx, query, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var videoStreams []VideoStream
        for rows.Next() </span><span class="cov0" title="0">{
                var stream VideoStream
                err := rows.Scan(
                        &amp;stream.ID, &amp;stream.Index, &amp;stream.Codec, &amp;stream.Width, &amp;stream.Height,
                        &amp;stream.Bitrate, &amp;stream.FPS, &amp;stream.Language, &amp;stream.Title, &amp;stream.Default,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">videoStreams = append(videoStreams, stream)</span>
        }

        <span class="cov0" title="0">session.CurrentVideo.VideoStreams = videoStreams

        audioQuery := `
                SELECT id, stream_index, codec, channels, bitrate, language, title, is_default
                FROM audio_streams
                WHERE media_item_id = $1
                ORDER BY stream_index ASC
        `

        audioRows, err := s.db.QueryContext(ctx, audioQuery, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer audioRows.Close()

        var audioStreams []AudioStream
        var audioTracks []AudioTrack
        for audioRows.Next() </span><span class="cov0" title="0">{
                var stream AudioStream
                err := audioRows.Scan(
                        &amp;stream.ID, &amp;stream.Index, &amp;stream.Codec, &amp;stream.Channels,
                        &amp;stream.Bitrate, &amp;stream.Language, &amp;stream.Title, &amp;stream.Default,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">audioStreams = append(audioStreams, stream)

                audioTrack := AudioTrack{
                        ID:        fmt.Sprintf("%d", stream.ID),
                        Language:  stream.Language,
                        Title:     &amp;stream.Title,
                        Codec:     stream.Codec,
                        Channels:  stream.Channels,
                        Bitrate:   &amp;stream.Bitrate,
                        IsDefault: stream.Default,
                }
                audioTracks = append(audioTracks, audioTrack)

                if stream.Default &amp;&amp; session.ActiveAudioTrack == nil </span><span class="cov0" title="0">{
                        session.ActiveAudioTrack = &amp;stream.ID
                }</span>
        }

        <span class="cov0" title="0">session.CurrentVideo.AudioStreams = audioStreams
        session.AudioTracks = audioTracks

        return nil</span>
}

func (s *VideoPlayerService) loadSubtitles(ctx context.Context, session *VideoPlaybackSession, videoID int64) error <span class="cov0" title="0">{
        subtitleStreams, err := s.getSubtitleStreams(ctx, videoID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get subtitle streams", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                session.CurrentVideo.SubtitleStreams = subtitleStreams
        }</span>

        <span class="cov0" title="0">subtitleTracks, err := s.getSubtitleTracks(ctx, videoID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get subtitle tracks", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                session.SubtitleTracks = subtitleTracks

                for _, track := range subtitleTracks </span><span class="cov0" title="0">{
                        if track.IsDefault &amp;&amp; session.ActiveSubtitle == nil </span><span class="cov0" title="0">{
                                // TODO: Fix type mismatch - ActiveSubtitle expects *int64 but track.ID is string
                                // For now, we'll skip setting the active subtitle
                                _ = track
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *VideoPlayerService) getSubtitleStreams(ctx context.Context, videoID int64) ([]SubtitleStream, error) <span class="cov0" title="0">{
        query := `
                SELECT id, stream_index, codec, language, title, is_default, is_forced, is_external, file_path
                FROM subtitle_streams
                WHERE media_item_id = $1
                ORDER BY stream_index ASC
        `

        rows, err := s.db.QueryContext(ctx, query, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var streams []SubtitleStream
        for rows.Next() </span><span class="cov0" title="0">{
                var stream SubtitleStream
                err := rows.Scan(
                        &amp;stream.ID, &amp;stream.Index, &amp;stream.Codec, &amp;stream.Language,
                        &amp;stream.Title, &amp;stream.Default, &amp;stream.Forced, &amp;stream.External, &amp;stream.FilePath,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">streams = append(streams, stream)</span>
        }

        <span class="cov0" title="0">return streams, nil</span>
}

func (s *VideoPlayerService) getSubtitleTracks(ctx context.Context, videoID int64) ([]SubtitleTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, language, language_code, source, format, path, content,
                           is_default, is_forced, encoding, sync_offset, created_at, verified_sync
                FROM subtitle_tracks
                WHERE media_item_id = $1
                ORDER BY is_default DESC, language ASC
        `

        rows, err := s.db.QueryContext(ctx, query, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tracks []SubtitleTrack
        for rows.Next() </span><span class="cov0" title="0">{
                var track SubtitleTrack
                var path sql.NullString
                var content sql.NullString

                err := rows.Scan(
                        &amp;track.ID, &amp;track.Language, &amp;track.LanguageCode, &amp;track.Source,
                        &amp;track.Format, &amp;path, &amp;content, &amp;track.IsDefault, &amp;track.IsForced,
                        &amp;track.Encoding, &amp;track.SyncOffset, &amp;track.CreatedAt, &amp;track.VerifiedSync,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if path.Valid </span><span class="cov0" title="0">{
                        track.Path = &amp;path.String
                }</span>
                <span class="cov0" title="0">if content.Valid </span><span class="cov0" title="0">{
                        track.Content = &amp;content.String
                }</span>

                <span class="cov0" title="0">tracks = append(tracks, track)</span>
        }

        <span class="cov0" title="0">return tracks, nil</span>
}

func (s *VideoPlayerService) loadChapters(ctx context.Context, session *VideoPlaybackSession, videoID int64) error <span class="cov0" title="0">{
        query := `
                SELECT id, title, start_time, end_time, thumbnail_url
                FROM video_chapters
                WHERE media_item_id = $1
                ORDER BY start_time ASC
        `

        rows, err := s.db.QueryContext(ctx, query, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var chapters []Chapter
        for rows.Next() </span><span class="cov0" title="0">{
                var chapter Chapter
                var thumbnailURL sql.NullString
                err := rows.Scan(
                        &amp;chapter.ID, &amp;chapter.Title, &amp;chapter.StartTime, &amp;chapter.EndTime, &amp;thumbnailURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if thumbnailURL.Valid </span><span class="cov0" title="0">{
                        chapter.Thumbnail = &amp;thumbnailURL.String
                }</span>

                <span class="cov0" title="0">chapters = append(chapters, chapter)</span>
        }

        <span class="cov0" title="0">session.Chapters = chapters
        return nil</span>
}

func (s *VideoPlayerService) loadEpisodePlaylist(ctx context.Context, session *VideoPlaybackSession, seriesID int64, seasonNumber int) error <span class="cov0" title="0">{
        episodes, err := s.getSeasonEpisodes(ctx, seriesID, seasonNumber)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.Playlist = episodes
        for i, episode := range episodes </span><span class="cov0" title="0">{
                if episode.ID == session.CurrentVideo.ID </span><span class="cov0" title="0">{
                        session.PlaylistIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *VideoPlayerService) loadSeasonPlaylist(ctx context.Context, session *VideoPlaybackSession, seriesID int64, seasonNumber int) error <span class="cov0" title="0">{
        return s.loadEpisodePlaylist(ctx, session, seriesID, seasonNumber)
}</span>

func (s *VideoPlayerService) loadSeriesPlaylist(ctx context.Context, session *VideoPlaybackSession, seriesID int64) error <span class="cov0" title="0">{
        query := `
                SELECT mi.id
                FROM media_items mi
                INNER JOIN episodes e ON mi.id = e.media_item_id
                WHERE e.series_id = $1 AND mi.type = 'video'
                ORDER BY e.season_number ASC, e.episode_number ASC
        `

        rows, err := s.db.QueryContext(ctx, query, seriesID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var episodeIDs []int64
        for rows.Next() </span><span class="cov0" title="0">{
                var episodeID int64
                if err := rows.Scan(&amp;episodeID); err == nil </span><span class="cov0" title="0">{
                        episodeIDs = append(episodeIDs, episodeID)
                }</span>
        }

        <span class="cov0" title="0">episodes, err := s.getVideoContents(ctx, episodeIDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.Playlist = episodes
        for i, episode := range episodes </span><span class="cov0" title="0">{
                if episode.ID == session.CurrentVideo.ID </span><span class="cov0" title="0">{
                        session.PlaylistIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *VideoPlayerService) loadVideoPlaylist(ctx context.Context, session *VideoPlaybackSession, playlistID int64) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *VideoPlayerService) generateThumbnail(ctx context.Context, videoID, position int64) (*CoverArt, error) <span class="cov0" title="0">{
        video, err := s.getVideoContent(ctx, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">thumbnailRequest := &amp;VideoThumbnailRequest{
                MediaItemID: videoID,
                VideoPath:   video.FilePath,
                Timestamps:  []float64{float64(position)},
                Quality:     QualityThumbnail,
                Count:       1,
        }

        thumbnails, err := s.coverArtService.GenerateVideoThumbnails(ctx, thumbnailRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(thumbnails) &gt; 0 </span><span class="cov0" title="0">{
                return thumbnails[0], nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("failed to generate thumbnail")</span>
}

func (s *VideoPlayerService) saveVideoSession(ctx context.Context, session *VideoPlaybackSession) error <span class="cov0" title="0">{
        sessionData, err := json.Marshal(session)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal session: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO video_playback_sessions (id, user_id, session_data, expires_at, updated_at)
                VALUES ($1, $2, $3, NOW() + INTERVAL '24 hours', NOW())
                ON CONFLICT (id)
                DO UPDATE SET
                        session_data = EXCLUDED.session_data,
                        expires_at = NOW() + INTERVAL '24 hours',
                        updated_at = NOW()
        `

        _, err = s.db.ExecContext(ctx, query, session.ID, session.UserID, string(sessionData))
        return err</span>
}

func (s *VideoPlayerService) recordVideoPlayback(ctx context.Context, userID, videoID int64) error <span class="cov0" title="0">{
        query := `
                UPDATE media_items
                SET play_count = play_count + 1, last_played = NOW()
                WHERE id = $1
        `

        _, err := s.db.ExecContext(ctx, query, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">historyQuery := `
                INSERT INTO video_watch_history (user_id, video_id, watched_at, watch_duration, completion_rate, stopped_at, device_info, quality)
                VALUES ($1, $2, NOW(), 0, 0, 0, '', '')
        `

        _, err = s.db.ExecContext(ctx, historyQuery, userID, videoID)
        return err</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package smb

import (
        "context"
        "fmt"
        "sync"
        "time"

        "go.uber.org/zap"
)

// ConnectionState represents the state of an SMB connection
type ConnectionState int

const (
        StateConnected ConnectionState = iota
        StateDisconnected
        StateReconnecting
        StateOffline
)

func (s ConnectionState) String() string <span class="cov0" title="0">{
        switch s </span>{
        case StateConnected:<span class="cov0" title="0">
                return "connected"</span>
        case StateDisconnected:<span class="cov0" title="0">
                return "disconnected"</span>
        case StateReconnecting:<span class="cov0" title="0">
                return "reconnecting"</span>
        case StateOffline:<span class="cov0" title="0">
                return "offline"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// SMBSource represents a configured SMB source with resilience capabilities
type SMBSource struct {
        ID                  string          `json:"id"`
        Name                string          `json:"name"`
        Path                string          `json:"path"`
        Username            string          `json:"username"`
        Password            string          `json:"password"`
        Domain              string          `json:"domain"`
        State               ConnectionState `json:"state"`
        LastConnected       time.Time       `json:"last_connected"`
        LastError           string          `json:"last_error,omitempty"`
        RetryAttempts       int             `json:"retry_attempts"`
        MaxRetryAttempts    int             `json:"max_retry_attempts"`
        RetryDelay          time.Duration   `json:"retry_delay"`
        ConnectionTimeout   time.Duration   `json:"connection_timeout"`
        HealthCheckInterval time.Duration   `json:"health_check_interval"`
        IsEnabled           bool            `json:"is_enabled"`
        mutex               sync.RWMutex
}

// ResilientSMBManager manages multiple SMB sources with automatic recovery
type ResilientSMBManager struct {
        sources       map[string]*SMBSource
        logger        *zap.Logger
        offlineCache  *OfflineCache
        healthChecker *HealthChecker
        eventChannel  chan SMBEvent
        stopChannel   chan struct{}
        wg            sync.WaitGroup
        mutex         sync.RWMutex
        startTime     time.Time
}

// SMBEvent represents events from SMB operations
type SMBEvent struct {
        Type      EventType   `json:"type"`
        SourceID  string      `json:"source_id"`
        Path      string      `json:"path,omitempty"`
        Error     error       `json:"error,omitempty"`
        Timestamp time.Time   `json:"timestamp"`
        Data      interface{} `json:"data,omitempty"`
}

type EventType int

const (
        EventConnected EventType = iota
        EventDisconnected
        EventReconnecting
        EventOffline
        EventFileChange
        EventError
        EventHealthCheck
)

func (e EventType) String() string <span class="cov0" title="0">{
        switch e </span>{
        case EventConnected:<span class="cov0" title="0">
                return "connected"</span>
        case EventDisconnected:<span class="cov0" title="0">
                return "disconnected"</span>
        case EventReconnecting:<span class="cov0" title="0">
                return "reconnecting"</span>
        case EventOffline:<span class="cov0" title="0">
                return "offline"</span>
        case EventFileChange:<span class="cov0" title="0">
                return "file_change"</span>
        case EventError:<span class="cov0" title="0">
                return "error"</span>
        case EventHealthCheck:<span class="cov0" title="0">
                return "health_check"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// OfflineCache stores metadata when SMB sources are unavailable
type OfflineCache struct {
        entries map[string]*CacheEntry
        maxSize int
        mutex   sync.RWMutex
        logger  *zap.Logger
}

type CacheEntry struct {
        Path        string                 `json:"path"`
        Metadata    map[string]interface{} `json:"metadata"`
        LastSeen    time.Time              `json:"last_seen"`
        IsAvailable bool                   `json:"is_available"`
        SourceID    string                 `json:"source_id"`
}

// HealthChecker periodically checks SMB source health
type HealthChecker struct {
        manager  *ResilientSMBManager
        interval time.Duration
        timeout  time.Duration
        logger   *zap.Logger
        ticker   *time.Ticker
        ctx      context.Context
        cancel   context.CancelFunc
}

// NewResilientSMBManager creates a new resilient SMB manager
func NewResilientSMBManager(logger *zap.Logger, cacheSize int) *ResilientSMBManager <span class="cov0" title="0">{
        manager := &amp;ResilientSMBManager{
                sources:      make(map[string]*SMBSource),
                logger:       logger,
                offlineCache: NewOfflineCache(cacheSize, logger),
                eventChannel: make(chan SMBEvent, 100),
                stopChannel:  make(chan struct{}),
                startTime:    time.Now(),
        }

        manager.healthChecker = NewHealthChecker(manager, 60*time.Second, 30*time.Second, logger)
        return manager
}</span>

// NewOfflineCache creates a new offline cache
func NewOfflineCache(maxSize int, logger *zap.Logger) *OfflineCache <span class="cov0" title="0">{
        return &amp;OfflineCache{
                entries: make(map[string]*CacheEntry),
                maxSize: maxSize,
                logger:  logger,
        }
}</span>

// NewHealthChecker creates a new health checker
func NewHealthChecker(manager *ResilientSMBManager, interval, timeout time.Duration, logger *zap.Logger) *HealthChecker <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        return &amp;HealthChecker{
                manager:  manager,
                interval: interval,
                timeout:  timeout,
                logger:   logger,
                ctx:      ctx,
                cancel:   cancel,
        }
}</span>

// AddSource adds a new SMB source to the manager
func (m *ResilientSMBManager) AddSource(source *SMBSource) error <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if source.ID == "" </span><span class="cov0" title="0">{
                source.ID = fmt.Sprintf("smb_%d", time.Now().Unix())
        }</span>

        // Set default values
        <span class="cov0" title="0">if source.MaxRetryAttempts == 0 </span><span class="cov0" title="0">{
                source.MaxRetryAttempts = 5
        }</span>
        <span class="cov0" title="0">if source.RetryDelay == 0 </span><span class="cov0" title="0">{
                source.RetryDelay = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if source.ConnectionTimeout == 0 </span><span class="cov0" title="0">{
                source.ConnectionTimeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if source.HealthCheckInterval == 0 </span><span class="cov0" title="0">{
                source.HealthCheckInterval = 60 * time.Second
        }</span>

        <span class="cov0" title="0">source.State = StateDisconnected
        source.IsEnabled = true

        m.sources[source.ID] = source

        // Try initial connection
        go m.connectSource(source)

        m.logger.Info("SMB source added",
                zap.String("id", source.ID),
                zap.String("name", source.Name),
                zap.String("path", source.Path))

        return nil</span>
}

// RemoveSource removes an SMB source from the manager
func (m *ResilientSMBManager) RemoveSource(sourceID string) error <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        source, exists := m.sources[sourceID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("source not found: %s", sourceID)
        }</span>

        <span class="cov0" title="0">source.IsEnabled = false
        delete(m.sources, sourceID)

        m.logger.Info("SMB source removed", zap.String("id", sourceID))
        return nil</span>
}

// Start begins monitoring all SMB sources
func (m *ResilientSMBManager) Start() error <span class="cov0" title="0">{
        m.logger.Info("Starting resilient SMB manager")

        // Start health checker
        m.healthChecker.Start()

        // Start event processor
        m.wg.Add(1)
        go m.processEvents()

        // Start monitoring existing sources
        m.mutex.RLock()
        sources := make([]*SMBSource, 0, len(m.sources))
        for _, source := range m.sources </span><span class="cov0" title="0">{
                if source.IsEnabled </span><span class="cov0" title="0">{
                        sources = append(sources, source)
                }</span>
        }
        <span class="cov0" title="0">m.mutex.RUnlock()

        for _, source := range sources </span><span class="cov0" title="0">{
                go m.monitorSource(source)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop shuts down the SMB manager
func (m *ResilientSMBManager) Stop() error <span class="cov0" title="0">{
        m.logger.Info("Stopping resilient SMB manager")

        // Stop health checker
        m.healthChecker.Stop()

        // Signal shutdown
        close(m.stopChannel)

        // Wait for goroutines to finish
        m.wg.Wait()

        return nil
}</span>

// connectSource attempts to connect to an SMB source
func (m *ResilientSMBManager) connectSource(source *SMBSource) error <span class="cov0" title="0">{
        source.mutex.Lock()
        defer source.mutex.Unlock()

        if !source.IsEnabled </span><span class="cov0" title="0">{
                return fmt.Errorf("source is disabled")
        }</span>

        <span class="cov0" title="0">source.State = StateReconnecting
        m.sendEvent(SMBEvent{
                Type:      EventReconnecting,
                SourceID:  source.ID,
                Timestamp: time.Now(),
        })

        // Simulate connection attempt (replace with actual SMB connection logic)
        ctx, cancel := context.WithTimeout(context.Background(), source.ConnectionTimeout)
        defer cancel()

        err := m.attemptConnection(ctx, source)
        if err != nil </span><span class="cov0" title="0">{
                source.State = StateDisconnected
                source.LastError = err.Error()
                source.RetryAttempts++

                m.logger.Error("Failed to connect to SMB source",
                        zap.String("id", source.ID),
                        zap.String("path", source.Path),
                        zap.Error(err),
                        zap.Int("retry_attempts", source.RetryAttempts))

                m.sendEvent(SMBEvent{
                        Type:      EventDisconnected,
                        SourceID:  source.ID,
                        Error:     err,
                        Timestamp: time.Now(),
                })

                // Schedule retry if not exceeded max attempts
                if source.RetryAttempts &lt; source.MaxRetryAttempts </span><span class="cov0" title="0">{
                        go m.scheduleRetry(source)
                }</span> else<span class="cov0" title="0"> {
                        source.State = StateOffline
                        m.sendEvent(SMBEvent{
                                Type:      EventOffline,
                                SourceID:  source.ID,
                                Timestamp: time.Now(),
                        })
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        // Connection successful
        <span class="cov0" title="0">source.State = StateConnected
        source.LastConnected = time.Now()
        source.LastError = ""
        source.RetryAttempts = 0

        m.logger.Info("Successfully connected to SMB source",
                zap.String("id", source.ID),
                zap.String("path", source.Path))

        m.sendEvent(SMBEvent{
                Type:      EventConnected,
                SourceID:  source.ID,
                Timestamp: time.Now(),
        })

        return nil</span>
}

// attemptConnection performs the actual SMB connection
func (m *ResilientSMBManager) attemptConnection(ctx context.Context, source *SMBSource) error <span class="cov0" title="0">{
        // This is a placeholder for actual SMB connection logic
        // In a real implementation, you would:
        // 1. Parse the SMB URL
        // 2. Create SMB connection with credentials
        // 3. Test connectivity with a simple operation
        // 4. Set up file system watcher

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("connection timeout: %s", source.Path)</span>
        case &lt;-time.After(100 * time.Millisecond):<span class="cov0" title="0"> // Simulate connection time
                // Simulate random connection failures for testing
                if time.Now().Unix()%7 == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("simulated connection failure")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// scheduleRetry schedules a retry attempt for a failed source
func (m *ResilientSMBManager) scheduleRetry(source *SMBSource) <span class="cov0" title="0">{
        delay := source.RetryDelay * time.Duration(source.RetryAttempts)
        if delay &gt; 5*time.Minute </span><span class="cov0" title="0">{
                delay = 5 * time.Minute // Cap maximum delay
        }</span>

        <span class="cov0" title="0">m.logger.Info("Scheduling retry for SMB source",
                zap.String("id", source.ID),
                zap.Duration("delay", delay),
                zap.Int("attempt", source.RetryAttempts+1))

        timer := time.NewTimer(delay)
        defer timer.Stop()

        select </span>{
        case &lt;-timer.C:<span class="cov0" title="0">
                m.connectSource(source)</span>
        case &lt;-m.stopChannel:<span class="cov0" title="0">
                return</span>
        }
}

// monitorSource continuously monitors an SMB source
func (m *ResilientSMBManager) monitorSource(source *SMBSource) <span class="cov0" title="0">{
        m.wg.Add(1)
        defer m.wg.Done()

        ticker := time.NewTicker(10 * time.Second) // Monitor every 10 seconds
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if source.IsEnabled &amp;&amp; source.State == StateConnected </span><span class="cov0" title="0">{
                                m.checkSourceHealth(source)
                        }</span>
                case &lt;-m.stopChannel:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// checkSourceHealth performs a health check on an SMB source
func (m *ResilientSMBManager) checkSourceHealth(source *SMBSource) <span class="cov0" title="0">{
        // Simulate health check (replace with actual SMB operation)
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        err := m.performHealthCheck(ctx, source)

        m.sendEvent(SMBEvent{
                Type:      EventHealthCheck,
                SourceID:  source.ID,
                Error:     err,
                Timestamp: time.Now(),
        })

        if err != nil </span><span class="cov0" title="0">{
                m.logger.Warn("SMB source health check failed",
                        zap.String("id", source.ID),
                        zap.Error(err))

                source.mutex.Lock()
                source.State = StateDisconnected
                source.LastError = err.Error()
                source.mutex.Unlock()

                // Attempt reconnection
                go m.connectSource(source)
        }</span>
}

// performHealthCheck performs the actual health check operation
func (m *ResilientSMBManager) performHealthCheck(ctx context.Context, source *SMBSource) error <span class="cov0" title="0">{
        // This is a placeholder for actual health check logic
        // In a real implementation, you would:
        // 1. Try to list a directory
        // 2. Check if the connection is still alive
        // 3. Verify read/write permissions

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("health check timeout")</span>
        case &lt;-time.After(50 * time.Millisecond):<span class="cov0" title="0"> // Simulate check time
                // Simulate random health check failures
                if time.Now().Unix()%20 == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("simulated health check failure")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// processEvents processes SMB events
func (m *ResilientSMBManager) processEvents() <span class="cov0" title="0">{
        defer m.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case event := &lt;-m.eventChannel:<span class="cov0" title="0">
                        m.handleEvent(event)</span>
                case &lt;-m.stopChannel:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// handleEvent handles individual SMB events
func (m *ResilientSMBManager) handleEvent(event SMBEvent) <span class="cov0" title="0">{
        m.logger.Debug("Processing SMB event",
                zap.String("type", event.Type.String()),
                zap.String("source_id", event.SourceID))

        switch event.Type </span>{
        case EventConnected:<span class="cov0" title="0">
                m.onSourceConnected(event.SourceID)</span>
        case EventDisconnected:<span class="cov0" title="0">
                m.onSourceDisconnected(event.SourceID, event.Error)</span>
        case EventOffline:<span class="cov0" title="0">
                m.onSourceOffline(event.SourceID)</span>
        case EventFileChange:<span class="cov0" title="0">
                m.onFileChange(event.SourceID, event.Path)</span>
        case EventError:<span class="cov0" title="0">
                m.onError(event.SourceID, event.Error)</span>
        }
}

// sendEvent sends an event to the event channel
func (m *ResilientSMBManager) sendEvent(event SMBEvent) <span class="cov0" title="0">{
        select </span>{
        case m.eventChannel &lt;- event:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                m.logger.Warn("Event channel full, dropping event",
                        zap.String("type", event.Type.String()),
                        zap.String("source_id", event.SourceID))</span>
        }
}

// Event handlers
func (m *ResilientSMBManager) onSourceConnected(sourceID string) <span class="cov0" title="0">{
        // Source reconnected, process any cached changes
        m.offlineCache.ProcessCachedChanges(sourceID)
}</span>

func (m *ResilientSMBManager) onSourceDisconnected(sourceID string, err error) <span class="cov0" title="0">{
        // Source disconnected, enable offline mode
        m.offlineCache.EnableOfflineMode(sourceID)
}</span>

func (m *ResilientSMBManager) onSourceOffline(sourceID string) <span class="cov0" title="0">{
        // Source is offline, full offline mode
        m.logger.Warn("SMB source is now offline", zap.String("source_id", sourceID))
}</span>

func (m *ResilientSMBManager) onFileChange(sourceID, path string) <span class="cov0" title="0">{
        // Handle file change, with offline caching if needed
        if m.isSourceConnected(sourceID) </span><span class="cov0" title="0">{
                // Process change immediately
                m.processFileChange(sourceID, path)
        }</span> else<span class="cov0" title="0"> {
                // Cache change for later processing
                m.offlineCache.CacheChange(sourceID, path)
        }</span>
}

func (m *ResilientSMBManager) onError(sourceID string, err error) <span class="cov0" title="0">{
        m.logger.Error("SMB source error",
                zap.String("source_id", sourceID),
                zap.Error(err))
}</span>

// Utility methods
func (m *ResilientSMBManager) isSourceConnected(sourceID string) bool <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        source, exists := m.sources[sourceID]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">source.mutex.RLock()
        defer source.mutex.RUnlock()

        return source.State == StateConnected</span>
}

func (m *ResilientSMBManager) processFileChange(sourceID, path string) <span class="cov0" title="0">{
        // Process file change logic here
        m.logger.Info("Processing file change",
                zap.String("source_id", sourceID),
                zap.String("path", path))
}</span>

// GetSourceStatus returns the status of all sources
func (m *ResilientSMBManager) GetSourceStatus() map[string]interface{} <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        status := make(map[string]interface{})
        for id, source := range m.sources </span><span class="cov0" title="0">{
                source.mutex.RLock()
                status[id] = map[string]interface{}{
                        "name":           source.Name,
                        "path":           source.Path,
                        "state":          source.State.String(),
                        "last_connected": source.LastConnected,
                        "last_error":     source.LastError,
                        "retry_attempts": source.RetryAttempts,
                        "is_enabled":     source.IsEnabled,
                }
                source.mutex.RUnlock()
        }</span>

        <span class="cov0" title="0">return status</span>
}

// GetStartTime returns when the manager was started
func (m *ResilientSMBManager) GetStartTime() time.Time <span class="cov0" title="0">{
        return m.startTime
}</span>

// ForceReconnect forces a reconnection attempt for a specific source
func (m *ResilientSMBManager) ForceReconnect(sourceID string) error <span class="cov0" title="0">{
        m.mutex.RLock()
        source, exists := m.sources[sourceID]
        m.mutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("source not found: %s", sourceID)
        }</span>

        <span class="cov0" title="0">if !source.IsEnabled </span><span class="cov0" title="0">{
                return fmt.Errorf("source is disabled: %s", sourceID)
        }</span>

        // Reset retry attempts to allow reconnection
        <span class="cov0" title="0">source.mutex.Lock()
        source.RetryAttempts = 0
        source.mutex.Unlock()

        // Trigger reconnection
        go m.connectSource(source)

        m.logger.Info("Force reconnect initiated", zap.String("source_id", sourceID))
        return nil</span>
}

// UpdateSource updates an existing SMB source
func (m *ResilientSMBManager) UpdateSource(sourceID string, updates interface{}) error <span class="cov0" title="0">{
        m.mutex.RLock()
        _, exists := m.sources[sourceID]
        m.mutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("source not found: %s", sourceID)
        }</span>

        // This would handle the actual update logic
        // For now, just log the update attempt
        <span class="cov0" title="0">m.logger.Info("SMB source update requested",
                zap.String("source_id", sourceID))

        return nil</span>
}

// OfflineCache methods
func (c *OfflineCache) CacheChange(sourceID, path string) <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        // Evict oldest entries if cache is full
        if len(c.entries) &gt;= c.maxSize </span><span class="cov0" title="0">{
                c.evictOldest()
        }</span>

        <span class="cov0" title="0">key := fmt.Sprintf("%s:%s", sourceID, path)
        c.entries[key] = &amp;CacheEntry{
                Path:        path,
                LastSeen:    time.Now(),
                IsAvailable: false,
                SourceID:    sourceID,
                Metadata:    make(map[string]interface{}),
        }

        c.logger.Debug("Cached file change",
                zap.String("source_id", sourceID),
                zap.String("path", path))</span>
}

func (c *OfflineCache) ProcessCachedChanges(sourceID string) <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        processed := 0
        for _, entry := range c.entries </span><span class="cov0" title="0">{
                if entry.SourceID == sourceID &amp;&amp; !entry.IsAvailable </span><span class="cov0" title="0">{
                        // Process cached change
                        c.logger.Info("Processing cached change",
                                zap.String("source_id", sourceID),
                                zap.String("path", entry.Path))

                        entry.IsAvailable = true
                        processed++
                }</span>
        }

        <span class="cov0" title="0">c.logger.Info("Processed cached changes",
                zap.String("source_id", sourceID),
                zap.Int("count", processed))</span>
}

func (c *OfflineCache) EnableOfflineMode(sourceID string) <span class="cov0" title="0">{
        c.logger.Info("Enabling offline mode for source", zap.String("source_id", sourceID))
}</span>

func (c *OfflineCache) evictOldest() <span class="cov0" title="0">{
        var oldestKey string
        var oldestTime time.Time

        for key, entry := range c.entries </span><span class="cov0" title="0">{
                if oldestKey == "" || entry.LastSeen.Before(oldestTime) </span><span class="cov0" title="0">{
                        oldestKey = key
                        oldestTime = entry.LastSeen
                }</span>
        }

        <span class="cov0" title="0">if oldestKey != "" </span><span class="cov0" title="0">{
                delete(c.entries, oldestKey)
                c.logger.Debug("Evicted cache entry", zap.String("key", oldestKey))
        }</span>
}

// HealthChecker methods
func (h *HealthChecker) Start() <span class="cov0" title="0">{
        h.ticker = time.NewTicker(h.interval)
        go h.run()
}</span>

func (h *HealthChecker) Stop() <span class="cov0" title="0">{
        if h.ticker != nil </span><span class="cov0" title="0">{
                h.ticker.Stop()
        }</span>
        <span class="cov0" title="0">h.cancel()</span>
}

func (h *HealthChecker) run() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-h.ticker.C:<span class="cov0" title="0">
                        h.performHealthChecks()</span>
                case &lt;-h.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (h *HealthChecker) performHealthChecks() <span class="cov0" title="0">{
        h.manager.mutex.RLock()
        sources := make([]*SMBSource, 0, len(h.manager.sources))
        for _, source := range h.manager.sources </span><span class="cov0" title="0">{
                if source.IsEnabled </span><span class="cov0" title="0">{
                        sources = append(sources, source)
                }</span>
        }
        <span class="cov0" title="0">h.manager.mutex.RUnlock()

        for _, source := range sources </span><span class="cov0" title="0">{
                go h.manager.checkSourceHealth(source)
        }</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package tests

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/http/httptest"
        "strings"
        "time"

        "go.uber.org/zap"
)

// Comprehensive mock servers for media recognition APIs
type MediaRecognitionMockServers struct {
        logger            *zap.Logger
        tmdbServer        *httptest.Server
        omdbServer        *httptest.Server
        lastfmServer      *httptest.Server
        musicbrainzServer *httptest.Server
        acoustidServer    *httptest.Server
        igdbServer        *httptest.Server
        steamServer       *httptest.Server
        githubServer      *httptest.Server
        googlebooksServer *httptest.Server
        openlibraryServer *httptest.Server
        crossrefServer    *httptest.Server
        ocrServer         *httptest.Server
        wingetServer      *httptest.Server
        flatpakServer     *httptest.Server
        snapcraftServer   *httptest.Server
        homebrewServer    *httptest.Server

        // Request logging
        requestLogs []RequestLog
}

type RequestLog struct {
        Timestamp  time.Time         `json:"timestamp"`
        Method     string            `json:"method"`
        URL        string            `json:"url"`
        Headers    map[string]string `json:"headers"`
        Body       string            `json:"body"`
        Response   string            `json:"response"`
        StatusCode int               `json:"status_code"`
        ServerType string            `json:"server_type"`
}

func NewMediaRecognitionMockServers(logger *zap.Logger) *MediaRecognitionMockServers <span class="cov0" title="0">{
        m := &amp;MediaRecognitionMockServers{
                logger:      logger,
                requestLogs: make([]RequestLog, 0),
        }

        m.setupTMDbServer()
        m.setupOMDbServer()
        m.setupLastFMServer()
        m.setupMusicBrainzServer()
        m.setupAcoustIDServer()
        m.setupIGDBServer()
        m.setupSteamServer()
        m.setupGitHubServer()
        m.setupGoogleBooksServer()
        m.setupOpenLibraryServer()
        m.setupCrossrefServer()
        m.setupOCRServer()
        m.setupWingetServer()
        m.setupFlatpakServer()
        m.setupSnapcraftServer()
        m.setupHomebrewServer()

        return m
}</span>

// TMDb Mock Server
func (m *MediaRecognitionMockServers) setupTMDbServer() <span class="cov0" title="0">{
        m.tmdbServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "tmdb")

                path := r.URL.Path
                query := r.URL.Query().Get("query")

                if strings.Contains(path, "/search/multi") </span><span class="cov0" title="0">{
                        m.handleTMDbSearch(w, r, query)
                }</span> else<span class="cov0" title="0"> if strings.Contains(path, "/movie/") </span><span class="cov0" title="0">{
                        m.handleTMDbMovieDetails(w, r)
                }</span> else<span class="cov0" title="0"> if strings.Contains(path, "/tv/") </span><span class="cov0" title="0">{
                        m.handleTMDbTVDetails(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Not found", http.StatusNotFound)
                }</span>
        }))
}

func (m *MediaRecognitionMockServers) handleTMDbSearch(w http.ResponseWriter, r *http.Request, query string) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "page":          1,
                "total_pages":   1,
                "total_results": 1,
                "results": []map[string]interface{}{
                        {
                                "id":                12345,
                                "title":             fmt.Sprintf("Mock Movie: %s", query),
                                "name":              fmt.Sprintf("Mock TV Show: %s", query),
                                "media_type":        "movie",
                                "overview":          "This is a mock movie/TV show for testing purposes.",
                                "release_date":      "2023-01-01",
                                "first_air_date":    "2023-01-01",
                                "genre_ids":         []int{28, 12, 878},
                                "vote_average":      8.5,
                                "vote_count":        1500,
                                "poster_path":       "/mock_poster.jpg",
                                "backdrop_path":     "/mock_backdrop.jpg",
                                "popularity":        95.5,
                                "adult":             false,
                                "original_language": "en",
                        },
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

func (m *MediaRecognitionMockServers) handleTMDbMovieDetails(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "id":             12345,
                "title":          "Mock Movie Details",
                "original_title": "Mock Movie Details",
                "overview":       "Detailed mock movie information for testing.",
                "release_date":   "2023-01-01",
                "runtime":        125,
                "vote_average":   8.5,
                "vote_count":     1500,
                "poster_path":    "/mock_poster.jpg",
                "backdrop_path":  "/mock_backdrop.jpg",
                "imdb_id":        "tt1234567",
                "budget":         150000000,
                "revenue":        500000000,
                "status":         "Released",
                "tagline":        "The ultimate mock movie experience",
                "genres": []map[string]interface{}{
                        {"id": 28, "name": "Action"},
                        {"id": 12, "name": "Adventure"},
                        {"id": 878, "name": "Science Fiction"},
                },
                "production_companies": []map[string]interface{}{
                        {
                                "id":             1,
                                "name":           "Mock Studios",
                                "logo_path":      "/mock_logo.png",
                                "origin_country": "US",
                        },
                },
                "production_countries": []map[string]interface{}{
                        {"iso_3166_1": "US", "name": "United States of America"},
                },
                "spoken_languages": []map[string]interface{}{
                        {"iso_639_1": "en", "name": "English", "english_name": "English"},
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

func (m *MediaRecognitionMockServers) handleTMDbTVDetails(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "id":                 12345,
                "name":               "Mock TV Series",
                "original_name":      "Mock TV Series",
                "overview":           "Detailed mock TV series information for testing.",
                "first_air_date":     "2023-01-01",
                "last_air_date":      "2023-12-31",
                "vote_average":       8.7,
                "vote_count":         2000,
                "poster_path":        "/mock_tv_poster.jpg",
                "backdrop_path":      "/mock_tv_backdrop.jpg",
                "number_of_episodes": 24,
                "number_of_seasons":  2,
                "status":             "Ended",
                "type":               "Scripted",
                "external_ids": map[string]interface{}{
                        "imdb_id": "tt7654321",
                        "tvdb_id": 98765,
                },
                "genres": []map[string]interface{}{
                        {"id": 18, "name": "Drama"},
                        {"id": 80, "name": "Crime"},
                },
                "created_by": []map[string]interface{}{
                        {
                                "id":           1,
                                "name":         "Mock Creator",
                                "profile_path": "/mock_creator.jpg",
                        },
                },
                "networks": []map[string]interface{}{
                        {
                                "id":             1,
                                "name":           "Mock Network",
                                "logo_path":      "/mock_network.png",
                                "origin_country": "US",
                        },
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

// OMDb Mock Server
func (m *MediaRecognitionMockServers) setupOMDbServer() <span class="cov0" title="0">{
        m.omdbServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "omdb")

                title := r.URL.Query().Get("t")
                if title == "" </span><span class="cov0" title="0">{
                        title = "Mock Title"
                }</span>

                <span class="cov0" title="0">response := map[string]interface{}{
                        "Title":    title,
                        "Year":     "2023",
                        "Rated":    "PG-13",
                        "Released": "01 Jan 2023",
                        "Runtime":  "125 min",
                        "Genre":    "Action, Adventure, Sci-Fi",
                        "Director": "Mock Director",
                        "Writer":   "Mock Writer",
                        "Actors":   "Mock Actor 1, Mock Actor 2, Mock Actor 3",
                        "Plot":     "A comprehensive mock plot for testing purposes.",
                        "Language": "English",
                        "Country":  "USA",
                        "Awards":   "Won 2 Oscars. Another 15 wins &amp; 30 nominations.",
                        "Poster":   "https://example.com/mock_poster.jpg",
                        "Ratings": []map[string]string{
                                {"Source": "Internet Movie Database", "Value": "8.5/10"},
                                {"Source": "Rotten Tomatoes", "Value": "85%"},
                                {"Source": "Metacritic", "Value": "78/100"},
                        },
                        "Metascore":  "78",
                        "imdbRating": "8.5",
                        "imdbVotes":  "150,000",
                        "imdbID":     "tt1234567",
                        "Type":       "movie",
                        "DVD":        "01 Jun 2023",
                        "BoxOffice":  "$500,000,000",
                        "Production": "Mock Studios",
                        "Website":    "https://example.com/mock-movie",
                        "Response":   "True",
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)</span>
        }))
}

// Last.fm Mock Server
func (m *MediaRecognitionMockServers) setupLastFMServer() <span class="cov0" title="0">{
        m.lastfmServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "lastfm")

                method := r.URL.Query().Get("method")
                track := r.URL.Query().Get("track")
                artist := r.URL.Query().Get("artist")

                if method == "track.search" </span><span class="cov0" title="0">{
                        m.handleLastFMTrackSearch(w, r, track)
                }</span> else<span class="cov0" title="0"> if method == "track.getInfo" </span><span class="cov0" title="0">{
                        m.handleLastFMTrackInfo(w, r, track, artist)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method not supported", http.StatusBadRequest)
                }</span>
        }))
}

func (m *MediaRecognitionMockServers) handleLastFMTrackSearch(w http.ResponseWriter, r *http.Request, track string) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "results": map[string]interface{}{
                        "trackmatches": map[string]interface{}{
                                "track": []map[string]interface{}{
                                        {
                                                "name":       fmt.Sprintf("Mock Track: %s", track),
                                                "artist":     "Mock Artist",
                                                "url":        "https://last.fm/music/mock-artist/mock-track",
                                                "streamable": "FIXME",
                                                "listeners":  "50000",
                                                "mbid":       "mock-mbid-12345",
                                                "image": []map[string]string{
                                                        {"#text": "https://example.com/mock_small.jpg", "size": "small"},
                                                        {"#text": "https://example.com/mock_medium.jpg", "size": "medium"},
                                                        {"#text": "https://example.com/mock_large.jpg", "size": "large"},
                                                },
                                        },
                                },
                        },
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

func (m *MediaRecognitionMockServers) handleLastFMTrackInfo(w http.ResponseWriter, r *http.Request, track, artist string) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "track": map[string]interface{}{
                        "name":      track,
                        "mbid":      "mock-mbid-12345",
                        "url":       "https://last.fm/music/mock-artist/mock-track",
                        "duration":  "240000",
                        "listeners": "50000",
                        "playcount": "500000",
                        "streamable": map[string]string{
                                "#text":     "1",
                                "fulltrack": "0",
                        },
                        "artist": map[string]string{
                                "name": artist,
                                "mbid": "mock-artist-mbid",
                                "url":  "https://last.fm/music/mock-artist",
                        },
                        "album": map[string]interface{}{
                                "artist": artist,
                                "title":  "Mock Album",
                                "mbid":   "mock-album-mbid",
                                "url":    "https://last.fm/music/mock-artist/mock-album",
                                "image": []map[string]string{
                                        {"#text": "https://example.com/mock_album_small.jpg", "size": "small"},
                                        {"#text": "https://example.com/mock_album_medium.jpg", "size": "medium"},
                                        {"#text": "https://example.com/mock_album_large.jpg", "size": "large"},
                                },
                        },
                        "toptags": map[string]interface{}{
                                "tag": []map[string]string{
                                        {"name": "rock", "url": "https://last.fm/tag/rock"},
                                        {"name": "alternative", "url": "https://last.fm/tag/alternative"},
                                        {"name": "indie", "url": "https://last.fm/tag/indie"},
                                },
                        },
                        "wiki": map[string]string{
                                "published": "01 Jan 2023, 12:00",
                                "summary":   "This is a mock track summary for testing purposes.",
                                "content":   "Extended mock content about this track with detailed information for testing.",
                        },
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

// MusicBrainz Mock Server
func (m *MediaRecognitionMockServers) setupMusicBrainzServer() <span class="cov0" title="0">{
        m.musicbrainzServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "musicbrainz")

                path := r.URL.Path
                if strings.Contains(path, "/recording") </span><span class="cov0" title="0">{
                        m.handleMusicBrainzRecordingSearch(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Not found", http.StatusNotFound)
                }</span>
        }))
}

func (m *MediaRecognitionMockServers) handleMusicBrainzRecordingSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "recordings": []map[string]interface{}{
                        {
                                "id":             "mock-recording-id-12345",
                                "score":          95,
                                "title":          "Mock Recording Title",
                                "length":         240000,
                                "disambiguation": "",
                                "artist-credit": []map[string]interface{}{
                                        {
                                                "name": "Mock Artist",
                                                "artist": map[string]interface{}{
                                                        "id":        "mock-artist-id",
                                                        "name":      "Mock Artist",
                                                        "sort-name": "Artist, Mock",
                                                        "type":      "Person",
                                                },
                                        },
                                },
                                "releases": []map[string]interface{}{
                                        {
                                                "id":      "mock-release-id",
                                                "title":   "Mock Album",
                                                "status":  "Official",
                                                "date":    "2023",
                                                "country": "US",
                                        },
                                },
                                "tags": []map[string]interface{}{
                                        {"count": 5, "name": "rock"},
                                        {"count": 3, "name": "alternative"},
                                },
                                "genres": []map[string]interface{}{
                                        {"count": 8, "name": "rock"},
                                        {"count": 4, "name": "pop"},
                                },
                                "isrcs": []string{"USMOCK2300001"},
                        },
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

// AcoustID Mock Server
func (m *MediaRecognitionMockServers) setupAcoustIDServer() <span class="cov0" title="0">{
        m.acoustidServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "acoustid")

                r.ParseForm()
                fingerprint := r.Form.Get("fingerprint")

                if fingerprint == "" </span><span class="cov0" title="0">{
                        http.Error(w, "Fingerprint required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">response := map[string]interface{}{
                        "status": "ok",
                        "results": []map[string]interface{}{
                                {
                                        "id":    "mock-acoustid-" + fingerprint[:8],
                                        "score": 0.95,
                                        "recordings": []map[string]interface{}{
                                                {
                                                        "id":       "mock-recording-id-12345",
                                                        "title":    "Mock Track from Fingerprint",
                                                        "duration": 240.5,
                                                        "artists": []map[string]interface{}{
                                                                {
                                                                        "id":   "mock-artist-id",
                                                                        "name": "Mock Artist",
                                                                },
                                                        },
                                                        "releases": []map[string]interface{}{
                                                                {
                                                                        "id":      "mock-release-id",
                                                                        "title":   "Mock Album",
                                                                        "date":    "2023",
                                                                        "country": "US",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)</span>
        }))
}

// IGDB Mock Server
func (m *MediaRecognitionMockServers) setupIGDBServer() <span class="cov0" title="0">{
        m.igdbServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "igdb")

                if r.Method != "POST" </span><span class="cov0" title="0">{
                        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                        return
                }</span>

                <span class="cov0" title="0">response := []map[string]interface{}{
                        {
                                "id":                 12345,
                                "name":               "Mock Game Title",
                                "summary":            "This is a comprehensive mock game for testing purposes with detailed gameplay mechanics.",
                                "storyline":          "An epic storyline that spans across multiple dimensions and realities.",
                                "first_release_date": 1672531200, // Unix timestamp for 2023-01-01
                                "category":           0,
                                "status":             6,
                                "rating":             85.5,
                                "rating_count":       1500,
                                "aggregated_rating":  88.2,
                                "total_rating":       86.8,
                                "popularity":         95.7,
                                "cover": map[string]interface{}{
                                        "id":       1,
                                        "url":      "//images.igdb.com/igdb/image/upload/t_cover_big/mock_cover.jpg",
                                        "image_id": "mock_cover",
                                        "width":    264,
                                        "height":   374,
                                },
                                "screenshots": []map[string]interface{}{
                                        {
                                                "id":       1,
                                                "url":      "//images.igdb.com/igdb/image/upload/t_screenshot_med/mock_screenshot1.jpg",
                                                "image_id": "mock_screenshot1",
                                                "width":    1920,
                                                "height":   1080,
                                        },
                                },
                                "genres": []map[string]interface{}{
                                        {"id": 12, "name": "Role-playing (RPG)", "slug": "role-playing-rpg"},
                                        {"id": 31, "name": "Adventure", "slug": "adventure"},
                                },
                                "themes": []map[string]interface{}{
                                        {"id": 1, "name": "Action", "slug": "action"},
                                        {"id": 17, "name": "Fantasy", "slug": "fantasy"},
                                },
                                "platforms": []map[string]interface{}{
                                        {
                                                "id":           6,
                                                "name":         "PC (Microsoft Windows)",
                                                "abbreviation": "PC",
                                                "category":     4,
                                                "generation":   8,
                                        },
                                        {
                                                "id":           48,
                                                "name":         "PlayStation 4",
                                                "abbreviation": "PS4",
                                                "category":     1,
                                                "generation":   8,
                                        },
                                },
                                "involved_companies": []map[string]interface{}{
                                        {
                                                "id":        1,
                                                "developer": true,
                                                "publisher": false,
                                                "company": map[string]interface{}{
                                                        "id":   1,
                                                        "name": "Mock Game Studios",
                                                        "slug": "mock-game-studios",
                                                },
                                        },
                                        {
                                                "id":        2,
                                                "developer": false,
                                                "publisher": true,
                                                "company": map[string]interface{}{
                                                        "id":   2,
                                                        "name": "Mock Publishers",
                                                        "slug": "mock-publishers",
                                                },
                                        },
                                },
                                "external_games": []map[string]interface{}{
                                        {
                                                "id":       1,
                                                "category": 1, // Steam
                                                "uid":      "12345",
                                                "url":      "https://store.steampowered.com/app/12345/",
                                        },
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)</span>
        }))
}

// GitHub Mock Server
func (m *MediaRecognitionMockServers) setupGitHubServer() <span class="cov0" title="0">{
        m.githubServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "github")

                path := r.URL.Path
                if strings.Contains(path, "/search/repositories") </span><span class="cov0" title="0">{
                        m.handleGitHubRepositorySearch(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Not found", http.StatusNotFound)
                }</span>
        }))
}

func (m *MediaRecognitionMockServers) handleGitHubRepositorySearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query().Get("q")

        response := map[string]interface{}{
                "total_count":        1,
                "incomplete_results": false,
                "items": []map[string]interface{}{
                        {
                                "id":               12345,
                                "name":             fmt.Sprintf("mock-%s", strings.ReplaceAll(query, " ", "-")),
                                "full_name":        fmt.Sprintf("mockuser/mock-%s", strings.ReplaceAll(query, " ", "-")),
                                "description":      fmt.Sprintf("Mock repository for %s - comprehensive testing implementation", query),
                                "html_url":         fmt.Sprintf("https://github.com/mockuser/mock-%s", strings.ReplaceAll(query, " ", "-")),
                                "stargazers_count": 1250,
                                "forks_count":      234,
                                "language":         "Go",
                                "license": map[string]interface{}{
                                        "key":     "mit",
                                        "name":    "MIT License",
                                        "spdx_id": "MIT",
                                },
                                "owner": map[string]interface{}{
                                        "login":      "mockuser",
                                        "id":         67890,
                                        "avatar_url": "https://avatars.githubusercontent.com/u/67890?v=4",
                                        "type":       "User",
                                },
                                "created_at":     "2020-01-01T00:00:00Z",
                                "updated_at":     "2023-12-01T00:00:00Z",
                                "pushed_at":      "2023-12-01T00:00:00Z",
                                "default_branch": "main",
                                "topics":         []string{"mock", "testing", "api", "software"},
                        },
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

// Google Books Mock Server
func (m *MediaRecognitionMockServers) setupGoogleBooksServer() <span class="cov0" title="0">{
        m.googlebooksServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "googlebooks")

                query := r.URL.Query().Get("q")

                response := map[string]interface{}{
                        "kind":       "books#volumes",
                        "totalItems": 1,
                        "items": []map[string]interface{}{
                                {
                                        "kind":     "books#volume",
                                        "id":       "mock-book-id-12345",
                                        "etag":     "mock-etag",
                                        "selfLink": "https://www.googleapis.com/books/v1/volumes/mock-book-id-12345",
                                        "volumeInfo": map[string]interface{}{
                                                "title":         fmt.Sprintf("Mock Book: %s", query),
                                                "subtitle":      "A Comprehensive Guide to Testing",
                                                "authors":       []string{"Mock Author", "Test Writer"},
                                                "publisher":     "Mock Publishing House",
                                                "publishedDate": "2023-01-01",
                                                "description":   "This is a comprehensive mock book designed for testing purposes. It contains detailed information about various testing methodologies and best practices.",
                                                "industryIdentifiers": []map[string]interface{}{
                                                        {
                                                                "type":       "ISBN_13",
                                                                "identifier": "9781234567890",
                                                        },
                                                        {
                                                                "type":       "ISBN_10",
                                                                "identifier": "1234567890",
                                                        },
                                                },
                                                "readingModes": map[string]bool{
                                                        "text":  true,
                                                        "image": true,
                                                },
                                                "pageCount":      456,
                                                "printType":      "BOOK",
                                                "categories":     []string{"Computers", "Testing", "Software Engineering"},
                                                "averageRating":  4.5,
                                                "ratingsCount":   125,
                                                "maturityRating": "NOT_MATURE",
                                                "imageLinks": map[string]string{
                                                        "smallThumbnail": "https://example.com/mock_book_small.jpg",
                                                        "thumbnail":      "https://example.com/mock_book_medium.jpg",
                                                        "small":          "https://example.com/mock_book_small.jpg",
                                                        "medium":         "https://example.com/mock_book_medium.jpg",
                                                        "large":          "https://example.com/mock_book_large.jpg",
                                                },
                                                "language":            "en",
                                                "previewLink":         "https://books.google.com/books?id=mock-book-id-12345",
                                                "infoLink":            "https://books.google.com/books?id=mock-book-id-12345",
                                                "canonicalVolumeLink": "https://books.google.com/books/about/Mock_Book.html?id=mock-book-id-12345",
                                        },
                                        "saleInfo": map[string]interface{}{
                                                "country":     "US",
                                                "saleability": "FOR_SALE",
                                                "isEbook":     true,
                                                "listPrice": map[string]interface{}{
                                                        "amount":       29.99,
                                                        "currencyCode": "USD",
                                                },
                                                "retailPrice": map[string]interface{}{
                                                        "amount":       24.99,
                                                        "currencyCode": "USD",
                                                },
                                                "buyLink": "https://books.google.com/books?id=mock-book-id-12345&amp;buy",
                                        },
                                        "accessInfo": map[string]interface{}{
                                                "country":                "US",
                                                "viewability":            "PARTIAL",
                                                "embeddable":             true,
                                                "publicDomain":           false,
                                                "textToSpeechPermission": "ALLOWED",
                                                "epub": map[string]interface{}{
                                                        "isAvailable": true,
                                                },
                                                "pdf": map[string]interface{}{
                                                        "isAvailable": true,
                                                },
                                                "webReaderLink":       "https://books.google.com/books/reader?id=mock-book-id-12345",
                                                "accessViewStatus":    "SAMPLE",
                                                "quoteSharingAllowed": true,
                                        },
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

// Open Library Mock Server
func (m *MediaRecognitionMockServers) setupOpenLibraryServer() <span class="cov0" title="0">{
        m.openlibraryServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "openlibrary")

                query := r.URL.Query().Get("q")

                response := map[string]interface{}{
                        "numFound":      1,
                        "start":         0,
                        "numFoundExact": true,
                        "docs": []map[string]interface{}{
                                {
                                        "key":                    "/works/OL12345W",
                                        "type":                   "work",
                                        "title":                  fmt.Sprintf("Mock Open Library Book: %s", query),
                                        "title_suggest":          fmt.Sprintf("Mock Open Library Book: %s", query),
                                        "subtitle":               "An Open Source Testing Guide",
                                        "author_name":            []string{"Mock Author", "Open Contributor"},
                                        "author_key":             []string{"/authors/OL123A", "/authors/OL456A"},
                                        "publisher":              []string{"Open Source Press", "Community Publishers"},
                                        "publish_date":           []string{"2023", "January 2023"},
                                        "publish_year":           []int{2023},
                                        "first_publish_year":     2023,
                                        "number_of_pages_median": 340,
                                        "edition_count":          3,
                                        "edition_key":            []string{"/books/OL123M", "/books/OL456M", "/books/OL789M"},
                                        "isbn":                   []string{"9780987654321", "0987654321"},
                                        "lccn":                   []string{"2023123456"},
                                        "oclc":                   []string{"1234567890"},
                                        "subject":                []string{"Testing", "Software Development", "Open Source", "Programming"},
                                        "place":                  []string{"San Francisco", "California"},
                                        "person":                 []string{"Linus Torvalds", "Richard Stallman"},
                                        "language":               []string{"eng"},
                                        "id_goodreads":           []string{"12345678"},
                                        "id_librarything":        []string{"987654"},
                                        "cover_i":                98765,
                                        "cover_edition_key":      "/books/OL123M",
                                        "first_sentence":         []string{"This comprehensive guide introduces the fundamentals of testing in open source environments."},
                                        "ebook_count_i":          2,
                                        "ebook_access":           "borrowable",
                                        "has_fulltext":           true,
                                        "public_scan_b":          true,
                                        "last_modified_i":        time.Now().Unix(),
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

// Crossref Mock Server
func (m *MediaRecognitionMockServers) setupCrossrefServer() <span class="cov0" title="0">{
        m.crossrefServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "crossref")

                query := r.URL.Query().Get("query")

                response := map[string]interface{}{
                        "status": "ok",
                        "message": map[string]interface{}{
                                "total-results":  1,
                                "items-per-page": 20,
                                "items": []map[string]interface{}{
                                        {
                                                "indexed": map[string]interface{}{
                                                        "date-parts": [][]int{{2023, 1, 15}},
                                                        "date-time":  "2023-01-15T10:30:00Z",
                                                        "timestamp":  1673779800000,
                                                },
                                                "reference-count": 25,
                                                "publisher":       "Mock Academic Press",
                                                "issue":           "1",
                                                "content-domain": map[string]interface{}{
                                                        "domain":                []string{"mockacademic.org"},
                                                        "crossmark-restriction": false,
                                                },
                                                "published": map[string]interface{}{
                                                        "date-parts": [][]int{{2023, 1, 1}},
                                                },
                                                "abstract": fmt.Sprintf("This is a comprehensive academic paper about %s, providing detailed analysis and research findings.", query),
                                                "DOI":      "10.1000/mock-doi-12345",
                                                "type":     "journal-article",
                                                "created": map[string]interface{}{
                                                        "date-parts": [][]int{{2023, 1, 1}},
                                                        "date-time":  "2023-01-01T00:00:00Z",
                                                        "timestamp":  1672531200000,
                                                },
                                                "page":                   "1-25",
                                                "source":                 "Crossref",
                                                "is-referenced-by-count": 15,
                                                "title":                  []string{fmt.Sprintf("Mock Academic Paper: %s", query)},
                                                "prefix":                 "10.1000",
                                                "volume":                 "45",
                                                "author": []map[string]interface{}{
                                                        {
                                                                "given":    "John",
                                                                "family":   "MockResearcher",
                                                                "sequence": "first",
                                                                "affiliation": []map[string]interface{}{
                                                                        {"name": "Mock University, Department of Computer Science"},
                                                                },
                                                        },
                                                        {
                                                                "given":    "Jane",
                                                                "family":   "TestScientist",
                                                                "sequence": "additional",
                                                                "affiliation": []map[string]interface{}{
                                                                        {"name": "Research Institute of Technology"},
                                                                },
                                                        },
                                                },
                                                "member":          "1000",
                                                "container-title": []string{"Journal of Mock Research"},
                                                "language":        "en",
                                                "deposited": map[string]interface{}{
                                                        "date-parts": [][]int{{2023, 1, 15}},
                                                        "date-time":  "2023-01-15T10:30:00Z",
                                                        "timestamp":  1673779800000,
                                                },
                                                "score": 95.5,
                                                "issued": map[string]interface{}{
                                                        "date-parts": [][]int{{2023, 1, 1}},
                                                },
                                                "references-count": 25,
                                                "URL":              "https://mockacademic.org/articles/mock-doi-12345",
                                                "ISSN":             []string{"1234-5678", "9876-5432"},
                                                "subject":          []string{"Computer Science", "Software Engineering", "Testing"},
                                        },
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

// OCR Mock Server
func (m *MediaRecognitionMockServers) setupOCRServer() <span class="cov0" title="0">{
        m.ocrServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "ocr")

                response := map[string]interface{}{
                        "ParsedResults": []map[string]interface{}{
                                {
                                        "TextOverlay": map[string]interface{}{
                                                "Lines": []map[string]interface{}{
                                                        {
                                                                "LineText": "Mock Book Title",
                                                                "Words": []map[string]interface{}{
                                                                        {
                                                                                "WordText": "Mock",
                                                                                "Left":     50,
                                                                                "Top":      100,
                                                                                "Height":   30,
                                                                                "Width":    80,
                                                                        },
                                                                        {
                                                                                "WordText": "Book",
                                                                                "Left":     140,
                                                                                "Top":      100,
                                                                                "Height":   30,
                                                                                "Width":    80,
                                                                        },
                                                                        {
                                                                                "WordText": "Title",
                                                                                "Left":     230,
                                                                                "Top":      100,
                                                                                "Height":   30,
                                                                                "Width":    80,
                                                                        },
                                                                },
                                                        },
                                                        {
                                                                "LineText": "By Mock Author",
                                                                "Words": []map[string]interface{}{
                                                                        {
                                                                                "WordText": "By",
                                                                                "Left":     50,
                                                                                "Top":      150,
                                                                                "Height":   25,
                                                                                "Width":    30,
                                                                        },
                                                                        {
                                                                                "WordText": "Mock",
                                                                                "Left":     90,
                                                                                "Top":      150,
                                                                                "Height":   25,
                                                                                "Width":    60,
                                                                        },
                                                                        {
                                                                                "WordText": "Author",
                                                                                "Left":     160,
                                                                                "Top":      150,
                                                                                "Height":   25,
                                                                                "Width":    80,
                                                                        },
                                                                },
                                                        },
                                                        {
                                                                "LineText": "ISBN: 978-1234567890",
                                                                "Words": []map[string]interface{}{
                                                                        {
                                                                                "WordText": "ISBN:",
                                                                                "Left":     50,
                                                                                "Top":      200,
                                                                                "Height":   20,
                                                                                "Width":    50,
                                                                        },
                                                                        {
                                                                                "WordText": "978-1234567890",
                                                                                "Left":     110,
                                                                                "Top":      200,
                                                                                "Height":   20,
                                                                                "Width":    150,
                                                                        },
                                                                },
                                                        },
                                                },
                                                "HasOverlay": true,
                                                "Message":    "Total lines: 3",
                                        },
                                        "FileParseExitCode": 1,
                                        "ParsedText":        "Mock Book Title\nBy Mock Author\nISBN: 978-1234567890\n\nThis is sample text content from a book page that has been processed through OCR. The text includes chapter headings, author information, and ISBN details that can be extracted for book recognition purposes.",
                                        "ErrorMessage":      "",
                                        "ErrorDetails":      "",
                                },
                        },
                        "OCRExitCode":                  1,
                        "IsErroredOnProcessing":        false,
                        "ProcessingTimeInMilliseconds": "1250",
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

// Package manager mock servers
func (m *MediaRecognitionMockServers) setupWingetServer() <span class="cov0" title="0">{
        m.wingetServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "winget")

                query := r.URL.Query().Get("query")

                response := []map[string]interface{}{
                        {
                                "PackageIdentifier": "MockSoftware.TestApp",
                                "PackageName":       fmt.Sprintf("Mock %s", query),
                                "PackageVersion":    "1.2.3",
                                "Publisher":         "Mock Software Inc.",
                                "Description":       fmt.Sprintf("A comprehensive mock application for %s testing purposes.", query),
                                "License":           "MIT",
                                "Tags":              []string{"mock", "testing", "software"},
                                "Homepage":          "https://mocksoft.com/testapp",
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

func (m *MediaRecognitionMockServers) setupFlatpakServer() <span class="cov0" title="0">{
        m.flatpakServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "flatpak")

                query := r.URL.Query().Get("q")

                response := []map[string]interface{}{
                        {
                                "flatpakAppId":   "org.mocksoft.TestApp",
                                "name":           fmt.Sprintf("Mock %s", query),
                                "summary":        fmt.Sprintf("Mock application for %s testing", query),
                                "description":    fmt.Sprintf("A comprehensive Flatpak application designed for testing %s functionality.", query),
                                "developerName":  "Mock Software Foundation",
                                "projectLicense": "GPL-3.0+",
                                "categories":     []string{"Development", "Education"},
                                "screenshots": []string{
                                        "https://example.com/mock_screenshot1.png",
                                        "https://example.com/mock_screenshot2.png",
                                },
                                "iconDesktopUrl":        "https://example.com/mock_icon.png",
                                "downloadFlatpakRefUrl": "https://dl.flathub.org/repo/appstream/org.mocksoft.TestApp.flatpakref",
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

func (m *MediaRecognitionMockServers) setupSnapcraftServer() <span class="cov0" title="0">{
        m.snapcraftServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "snapcraft")

                query := r.URL.Query().Get("q")

                response := map[string]interface{}{
                        "_embedded": []map[string]interface{}{
                                {
                                        "name":        fmt.Sprintf("mock-%s", strings.ReplaceAll(strings.ToLower(query), " ", "-")),
                                        "title":       fmt.Sprintf("Mock %s", query),
                                        "summary":     fmt.Sprintf("A mock snap package for %s testing", query),
                                        "description": fmt.Sprintf("Comprehensive snap package designed for testing %s functionality with all necessary components.", query),
                                        "publisher": map[string]interface{}{
                                                "display-name": "Mock Software Publishers",
                                                "username":     "mockpublisher",
                                                "validation":   "verified",
                                        },
                                        "license":     "MIT",
                                        "version":     "1.2.3",
                                        "revision":    42,
                                        "confinement": "strict",
                                        "grade":       "stable",
                                        "categories": []map[string]interface{}{
                                                {"name": "development"},
                                                {"name": "education"},
                                        },
                                        "screenshots": []string{
                                                "https://example.com/snap_screenshot1.png",
                                                "https://example.com/snap_screenshot2.png",
                                        },
                                        "media": []map[string]interface{}{
                                                {
                                                        "type": "icon",
                                                        "url":  "https://example.com/snap_icon.png",
                                                },
                                        },
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

func (m *MediaRecognitionMockServers) setupHomebrewServer() <span class="cov0" title="0">{
        m.homebrewServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "homebrew")

                // Extract formula name from path
                pathParts := strings.Split(r.URL.Path, "/")
                formulaName := "mock-formula"
                if len(pathParts) &gt; 3 </span><span class="cov0" title="0">{
                        formulaName = strings.TrimSuffix(pathParts[len(pathParts)-1], ".json")
                }</span>

                <span class="cov0" title="0">response := map[string]interface{}{
                        "name":               formulaName,
                        "full_name":          fmt.Sprintf("mock/%s", formulaName),
                        "tap":                "homebrew/core",
                        "oldname":            nil,
                        "aliases":            []string{},
                        "versioned_formulae": []string{},
                        "desc":               fmt.Sprintf("Mock Homebrew formula for %s testing purposes", formulaName),
                        "license":            "MIT",
                        "homepage":           "https://mocksoft.com/homebrew-formula",
                        "versions": map[string]interface{}{
                                "stable": "1.2.3",
                                "head":   "HEAD",
                                "bottle": true,
                        },
                        "urls": map[string]interface{}{
                                "stable": map[string]interface{}{
                                        "url":      fmt.Sprintf("https://github.com/mocksoft/%s/archive/v1.2.3.tar.gz", formulaName),
                                        "tag":      "v1.2.3",
                                        "revision": "abc123def456",
                                },
                        },
                        "revision":       0,
                        "version_scheme": 0,
                        "bottle": map[string]interface{}{
                                "stable": map[string]interface{}{
                                        "rebuild":  0,
                                        "root_url": "https://homebrew.bintray.com/bottles",
                                        "files": map[string]interface{}{
                                                "monterey": map[string]interface{}{
                                                        "cellar": "/usr/local/Cellar",
                                                        "url":    fmt.Sprintf("https://homebrew.bintray.com/bottles/%s-1.2.3.monterey.bottle.tar.gz", formulaName),
                                                        "sha256": "mock_sha256_hash_for_monterey_bottle",
                                                },
                                                "big_sur": map[string]interface{}{
                                                        "cellar": "/usr/local/Cellar",
                                                        "url":    fmt.Sprintf("https://homebrew.bintray.com/bottles/%s-1.2.3.big_sur.bottle.tar.gz", formulaName),
                                                        "sha256": "mock_sha256_hash_for_big_sur_bottle",
                                                },
                                        },
                                },
                        },
                        "dependencies":             []string{"mock-dependency-1", "mock-dependency-2"},
                        "test_dependencies":        []string{"mock-test-dep"},
                        "recommended_dependencies": []string{},
                        "optional_dependencies":    []string{},
                        "build_dependencies":       []string{"cmake", "pkg-config"},
                        "conflicts_with":           []string{},
                        "caveats":                  nil,
                        "installed":                []string{},
                        "linked_keg":               nil,
                        "pinned":                   false,
                        "outdated":                 false,
                        "deprecated":               false,
                        "deprecation_date":         nil,
                        "deprecation_reason":       nil,
                        "disabled":                 false,
                        "disable_date":             nil,
                        "disable_reason":           nil,
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)</span>
        }))
}

// Steam Mock Server
func (m *MediaRecognitionMockServers) setupSteamServer() <span class="cov0" title="0">{
        m.steamServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "steam")

                // Mock Steam app details
                response := map[string]interface{}{
                        "12345": map[string]interface{}{
                                "success": true,
                                "data": map[string]interface{}{
                                        "type":                 "game",
                                        "name":                 "Mock Steam Game",
                                        "steam_appid":          12345,
                                        "required_age":         0,
                                        "is_free":              false,
                                        "detailed_description": "A comprehensive mock Steam game for testing purposes with detailed gameplay mechanics and storyline.",
                                        "about_the_game":       "Experience the ultimate mock gaming adventure with cutting-edge graphics and immersive gameplay.",
                                        "short_description":    "The definitive mock game experience.",
                                        "supported_languages":  "English&lt;strong&gt;*&lt;/strong&gt;, French, German, Spanish&lt;br&gt;&lt;strong&gt;*&lt;/strong&gt;languages with full audio support",
                                        "header_image":         "https://cdn.akamai.steamstatic.com/steam/apps/12345/header.jpg",
                                        "website":              "https://mockgame.com",
                                        "pc_requirements": map[string]interface{}{
                                                "minimum":     "&lt;strong&gt;Minimum:&lt;/strong&gt;&lt;br&gt;&lt;ul class=\"bb_ul\"&gt;&lt;li&gt;&lt;strong&gt;OS:&lt;/strong&gt; Windows 10 64-bit&lt;li&gt;&lt;strong&gt;Processor:&lt;/strong&gt; Intel Core i5-8400 / AMD Ryzen 5 2600&lt;li&gt;&lt;strong&gt;Memory:&lt;/strong&gt; 8 GB RAM&lt;li&gt;&lt;strong&gt;Graphics:&lt;/strong&gt; NVIDIA GTX 1060 / AMD RX 580&lt;li&gt;&lt;strong&gt;DirectX:&lt;/strong&gt; Version 12&lt;li&gt;&lt;strong&gt;Storage:&lt;/strong&gt; 50 GB available space&lt;/ul&gt;",
                                                "recommended": "&lt;strong&gt;Recommended:&lt;/strong&gt;&lt;br&gt;&lt;ul class=\"bb_ul\"&gt;&lt;li&gt;&lt;strong&gt;OS:&lt;/strong&gt; Windows 11 64-bit&lt;li&gt;&lt;strong&gt;Processor:&lt;/strong&gt; Intel Core i7-10700K / AMD Ryzen 7 3700X&lt;li&gt;&lt;strong&gt;Memory:&lt;/strong&gt; 16 GB RAM&lt;li&gt;&lt;strong&gt;Graphics:&lt;/strong&gt; NVIDIA RTX 3070 / AMD RX 6700 XT&lt;li&gt;&lt;strong&gt;DirectX:&lt;/strong&gt; Version 12&lt;li&gt;&lt;strong&gt;Storage:&lt;/strong&gt; 50 GB available space (SSD recommended)&lt;/ul&gt;",
                                        },
                                        "developers": []string{"Mock Game Studios"},
                                        "publishers": []string{"Mock Publishers"},
                                        "platforms": map[string]bool{
                                                "windows": true,
                                                "mac":     false,
                                                "linux":   true,
                                        },
                                        "metacritic": map[string]interface{}{
                                                "score": 85,
                                                "url":   "https://www.metacritic.com/game/pc/mock-steam-game",
                                        },
                                        "categories": []map[string]interface{}{
                                                {"id": 2, "description": "Single-player"},
                                                {"id": 1, "description": "Multi-player"},
                                                {"id": 22, "description": "Steam Achievements"},
                                                {"id": 29, "description": "Steam Trading Cards"},
                                        },
                                        "genres": []map[string]interface{}{
                                                {"id": "1", "description": "Action"},
                                                {"id": "25", "description": "Adventure"},
                                                {"id": "23", "description": "Indie"},
                                        },
                                        "screenshots": []map[string]interface{}{
                                                {
                                                        "id":             1,
                                                        "path_thumbnail": "https://cdn.akamai.steamstatic.com/steam/apps/12345/ss_1_thumbnail.jpg",
                                                        "path_full":      "https://cdn.akamai.steamstatic.com/steam/apps/12345/ss_1.jpg",
                                                },
                                        },
                                        "release_date": map[string]interface{}{
                                                "coming_soon": false,
                                                "date":        "Jan 1, 2023",
                                        },
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

// Request logging functionality
func (m *MediaRecognitionMockServers) logRequest(r *http.Request, serverType string) <span class="cov0" title="0">{
        headers := make(map[string]string)
        for name, values := range r.Header </span><span class="cov0" title="0">{
                headers[name] = strings.Join(values, ", ")
        }</span>

        <span class="cov0" title="0">body := ""
        if r.Body != nil </span><span class="cov0" title="0">{
                bodyBytes := make([]byte, r.ContentLength)
                r.Body.Read(bodyBytes)
                body = string(bodyBytes)
        }</span>

        <span class="cov0" title="0">log := RequestLog{
                Timestamp:  time.Now(),
                Method:     r.Method,
                URL:        r.URL.String(),
                Headers:    headers,
                Body:       body,
                ServerType: serverType,
        }

        m.requestLogs = append(m.requestLogs, log)</span>
}

// Get request logs for analysis
func (m *MediaRecognitionMockServers) GetRequestLogs() []RequestLog <span class="cov0" title="0">{
        return m.requestLogs
}</span>

// Clear request logs
func (m *MediaRecognitionMockServers) ClearRequestLogs() <span class="cov0" title="0">{
        m.requestLogs = make([]RequestLog, 0)
}</span>

// Get server URLs for configuration
func (m *MediaRecognitionMockServers) GetURLs() map[string]string <span class="cov0" title="0">{
        return map[string]string{
                "tmdb":        m.tmdbServer.URL,
                "omdb":        m.omdbServer.URL,
                "lastfm":      m.lastfmServer.URL,
                "musicbrainz": m.musicbrainzServer.URL,
                "acoustid":    m.acoustidServer.URL,
                "igdb":        m.igdbServer.URL,
                "steam":       m.steamServer.URL,
                "github":      m.githubServer.URL,
                "googlebooks": m.googlebooksServer.URL,
                "openlibrary": m.openlibraryServer.URL,
                "crossref":    m.crossrefServer.URL,
                "ocr":         m.ocrServer.URL,
                "winget":      m.wingetServer.URL,
                "flatpak":     m.flatpakServer.URL,
                "snapcraft":   m.snapcraftServer.URL,
                "homebrew":    m.homebrewServer.URL,
        }
}</span>

// Close all mock servers
func (m *MediaRecognitionMockServers) Close() <span class="cov0" title="0">{
        if m.tmdbServer != nil </span><span class="cov0" title="0">{
                m.tmdbServer.Close()
        }</span>
        <span class="cov0" title="0">if m.omdbServer != nil </span><span class="cov0" title="0">{
                m.omdbServer.Close()
        }</span>
        <span class="cov0" title="0">if m.lastfmServer != nil </span><span class="cov0" title="0">{
                m.lastfmServer.Close()
        }</span>
        <span class="cov0" title="0">if m.musicbrainzServer != nil </span><span class="cov0" title="0">{
                m.musicbrainzServer.Close()
        }</span>
        <span class="cov0" title="0">if m.acoustidServer != nil </span><span class="cov0" title="0">{
                m.acoustidServer.Close()
        }</span>
        <span class="cov0" title="0">if m.igdbServer != nil </span><span class="cov0" title="0">{
                m.igdbServer.Close()
        }</span>
        <span class="cov0" title="0">if m.steamServer != nil </span><span class="cov0" title="0">{
                m.steamServer.Close()
        }</span>
        <span class="cov0" title="0">if m.githubServer != nil </span><span class="cov0" title="0">{
                m.githubServer.Close()
        }</span>
        <span class="cov0" title="0">if m.googlebooksServer != nil </span><span class="cov0" title="0">{
                m.googlebooksServer.Close()
        }</span>
        <span class="cov0" title="0">if m.openlibraryServer != nil </span><span class="cov0" title="0">{
                m.openlibraryServer.Close()
        }</span>
        <span class="cov0" title="0">if m.crossrefServer != nil </span><span class="cov0" title="0">{
                m.crossrefServer.Close()
        }</span>
        <span class="cov0" title="0">if m.ocrServer != nil </span><span class="cov0" title="0">{
                m.ocrServer.Close()
        }</span>
        <span class="cov0" title="0">if m.wingetServer != nil </span><span class="cov0" title="0">{
                m.wingetServer.Close()
        }</span>
        <span class="cov0" title="0">if m.flatpakServer != nil </span><span class="cov0" title="0">{
                m.flatpakServer.Close()
        }</span>
        <span class="cov0" title="0">if m.snapcraftServer != nil </span><span class="cov0" title="0">{
                m.snapcraftServer.Close()
        }</span>
        <span class="cov0" title="0">if m.homebrewServer != nil </span><span class="cov0" title="0">{
                m.homebrewServer.Close()
        }</span>
}

// Helper function to simulate network delays for realistic testing
func (m *MediaRecognitionMockServers) simulateNetworkDelay() <span class="cov0" title="0">{
        // Simulate 50-200ms network delay
        delay := time.Duration(50+time.Now().UnixNano()%150) * time.Millisecond
        time.Sleep(delay)
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package tests

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/http/httptest"
        "strings"
        "time"

        "github.com/gorilla/mux"
)

type MockServer struct {
        Server        *httptest.Server
        RequestLog    []MockRequest
        ResponseDelay time.Duration
}

type MockRequest struct {
        Method    string              `json:"method"`
        URL       string              `json:"url"`
        Headers   map[string]string   `json:"headers"`
        Body      string              `json:"body"`
        Timestamp time.Time           `json:"timestamp"`
        Query     map[string][]string `json:"query"`
}

type MockResponse struct {
        StatusCode int               `json:"status_code"`
        Headers    map[string]string `json:"headers"`
        Body       interface{}       `json:"body"`
        Delay      time.Duration     `json:"delay"`
}

func NewMockServer() *MockServer <span class="cov0" title="0">{
        mock := &amp;MockServer{
                RequestLog: make([]MockRequest, 0),
        }

        router := mux.NewRouter()
        mock.setupRoutes(router)

        mock.Server = httptest.NewServer(router)
        return mock
}</span>

func (m *MockServer) Close() <span class="cov0" title="0">{
        m.Server.Close()
}</span>

func (m *MockServer) URL() string <span class="cov0" title="0">{
        return m.Server.URL
}</span>

func (m *MockServer) GetRequestLog() []MockRequest <span class="cov0" title="0">{
        return m.RequestLog
}</span>

func (m *MockServer) ClearRequestLog() <span class="cov0" title="0">{
        m.RequestLog = make([]MockRequest, 0)
}</span>

func (m *MockServer) SetResponseDelay(delay time.Duration) <span class="cov0" title="0">{
        m.ResponseDelay = delay
}</span>

func (m *MockServer) logRequest(r *http.Request, body string) <span class="cov0" title="0">{
        headers := make(map[string]string)
        for key, values := range r.Header </span><span class="cov0" title="0">{
                headers[key] = strings.Join(values, ", ")
        }</span>

        <span class="cov0" title="0">request := MockRequest{
                Method:    r.Method,
                URL:       r.URL.String(),
                Headers:   headers,
                Body:      body,
                Timestamp: time.Now(),
                Query:     r.URL.Query(),
        }

        m.RequestLog = append(m.RequestLog, request)</span>
}

func (m *MockServer) respondWithDelay(w http.ResponseWriter, response MockResponse) <span class="cov0" title="0">{
        if m.ResponseDelay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.ResponseDelay)
        }</span>
        <span class="cov0" title="0">if response.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(response.Delay)
        }</span>

        <span class="cov0" title="0">for key, value := range response.Headers </span><span class="cov0" title="0">{
                w.Header().Set(key, value)
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)
        json.NewEncoder(w).Encode(response.Body)</span>
}

func (m *MockServer) setupRoutes(router *mux.Router) <span class="cov0" title="0">{
        // OpenSubtitles API Mock
        router.HandleFunc("/opensubtitles/api/v1/login", m.mockOpenSubtitlesLogin).Methods("POST")
        router.HandleFunc("/opensubtitles/api/v1/subtitles", m.mockOpenSubtitlesSearch).Methods("GET")
        router.HandleFunc("/opensubtitles/api/v1/download", m.mockOpenSubtitlesDownload).Methods("POST")

        // SubDB API Mock
        router.HandleFunc("/subdb", m.mockSubDBSearch).Methods("GET")

        // YifySubtitles API Mock
        router.HandleFunc("/yifysubtitles/api/v1/subtitles", m.mockYifySubtitlesSearch).Methods("GET")

        // Genius API Mock
        router.HandleFunc("/genius/api/search", m.mockGeniusSearch).Methods("GET")
        router.HandleFunc("/genius/api/songs/{id}/lyrics", m.mockGeniusLyrics).Methods("GET")

        // Musixmatch API Mock
        router.HandleFunc("/musixmatch/ws/1.1/track.search", m.mockMusixmatchSearch).Methods("GET")
        router.HandleFunc("/musixmatch/ws/1.1/track.lyrics.get", m.mockMusixmatchLyrics).Methods("GET")

        // AZLyrics Mock
        router.HandleFunc("/azlyrics/{artist}/{song}", m.mockAZLyrics).Methods("GET")

        // MusicBrainz API Mock
        router.HandleFunc("/musicbrainz/ws/2/recording", m.mockMusicBrainzSearch).Methods("GET")
        router.HandleFunc("/musicbrainz/ws/2/release", m.mockMusicBrainzRelease).Methods("GET")

        // Last.FM API Mock
        router.HandleFunc("/lastfm/2.0", m.mockLastFMAPI).Methods("GET")

        // iTunes API Mock
        router.HandleFunc("/itunes/search", m.mockiTunesSearch).Methods("GET")

        // Spotify API Mock
        router.HandleFunc("/spotify/v1/search", m.mockSpotifySearch).Methods("GET")
        router.HandleFunc("/spotify/api/token", m.mockSpotifyToken).Methods("POST")

        // Discogs API Mock
        router.HandleFunc("/discogs/database/search", m.mockDiscogsSearch).Methods("GET")

        // Google Translate Mock
        router.HandleFunc("/google/translate/v2", m.mockGoogleTranslate).Methods("POST")
        router.HandleFunc("/google/translate/v2/detect", m.mockGoogleDetect).Methods("POST")

        // LibreTranslate Mock
        router.HandleFunc("/libretranslate/translate", m.mockLibreTranslate).Methods("POST")
        router.HandleFunc("/libretranslate/detect", m.mockLibreDetect).Methods("POST")

        // MyMemory Translation Mock
        router.HandleFunc("/mymemory/get", m.mockMyMemoryTranslate).Methods("GET")

        // Setlist.fm API Mock
        router.HandleFunc("/setlistfm/rest/1.0/search/setlists", m.mockSetlistFMSearch).Methods("GET")
}</span>

// OpenSubtitles API Mocks

func (m *MockServer) mockOpenSubtitlesLogin(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "token": "mock_opensubtitles_token_12345",
                        "user": map[string]interface{}{
                                "allowed_downloads": 200,
                                "level":             "VIP",
                                "user_id":           12345,
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockOpenSubtitlesSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        imdbID := r.URL.Query().Get("imdb_id")
        languages := r.URL.Query().Get("languages")

        if imdbID == "" </span><span class="cov0" title="0">{
                response := MockResponse{
                        StatusCode: 400,
                        Body: map[string]interface{}{
                                "message": "imdb_id parameter is required",
                        },
                }
                m.respondWithDelay(w, response)
                return
        }</span>

        <span class="cov0" title="0">subtitles := []map[string]interface{}{
                {
                        "id":           "subtitle_123",
                        "type":         "subtitle",
                        "language":     strings.Split(languages, ",")[0],
                        "filename":     "movie.srt",
                        "url":          fmt.Sprintf("%s/opensubtitles/files/subtitle_123.srt", m.URL()),
                        "download_url": fmt.Sprintf("%s/opensubtitles/api/v1/download", m.URL()),
                        "fps":          23.976,
                        "file_id":      123456,
                        "rating":       8.5,
                        "downloads":    15420,
                },
                {
                        "id":           "subtitle_124",
                        "type":         "subtitle",
                        "language":     "en",
                        "filename":     "movie_eng.srt",
                        "url":          fmt.Sprintf("%s/opensubtitles/files/subtitle_124.srt", m.URL()),
                        "download_url": fmt.Sprintf("%s/opensubtitles/api/v1/download", m.URL()),
                        "fps":          23.976,
                        "file_id":      123457,
                        "rating":       9.0,
                        "downloads":    25830,
                },
        }

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "total_pages": 1,
                        "total_count": len(subtitles),
                        "per_page":    60,
                        "page":        1,
                        "data":        subtitles,
                },
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockOpenSubtitlesDownload(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "link":           fmt.Sprintf("%s/opensubtitles/files/subtitle.srt", m.URL()),
                        "file_name":      "subtitle.srt",
                        "requests":       199,
                        "remaining":      199,
                        "message":        "Download successful",
                        "reset_time":     "24:00:00",
                        "reset_time_utc": time.Now().Add(24 * time.Hour).Format(time.RFC3339),
                },
        }
        m.respondWithDelay(w, response)
}</span>

// SubDB API Mock

func (m *MockServer) mockSubDBSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        action := r.URL.Query().Get("action")
        hash := r.URL.Query().Get("hash")

        if action != "search" || hash == "" </span><span class="cov0" title="0">{
                w.WriteHeader(404)
                return
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Headers: map[string]string{
                        "Content-Type": "text/plain",
                },
                Body: "en,es,fr,de",
        }
        m.respondWithDelay(w, response)</span>
}

// Genius API Mocks

func (m *MockServer) mockGeniusSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        query := r.URL.Query().Get("q")
        if query == "" </span><span class="cov0" title="0">{
                response := MockResponse{
                        StatusCode: 400,
                        Body: map[string]interface{}{
                                "error": "Missing required parameter: q",
                        },
                }
                m.respondWithDelay(w, response)
                return
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "meta": map[string]interface{}{
                                "status": 200,
                        },
                        "response": map[string]interface{}{
                                "hits": []map[string]interface{}{
                                        {
                                                "type":  "song",
                                                "index": "song",
                                                "result": map[string]interface{}{
                                                        "id":                  123456,
                                                        "title":               "Test Song",
                                                        "title_with_featured": "Test Song (feat. Test Artist)",
                                                        "full_title":          "Test Song by Test Artist",
                                                        "artist_names":        "Test Artist",
                                                        "primary_artist": map[string]interface{}{
                                                                "id":   98765,
                                                                "name": "Test Artist",
                                                                "url":  fmt.Sprintf("%s/genius/artists/98765", m.URL()),
                                                        },
                                                        "url":                          fmt.Sprintf("%s/genius/songs/123456", m.URL()),
                                                        "song_art_image_thumbnail_url": fmt.Sprintf("%s/images/song_art_123456_thumb.jpg", m.URL()),
                                                        "song_art_image_url":           fmt.Sprintf("%s/images/song_art_123456.jpg", m.URL()),
                                                },
                                        },
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockGeniusLyrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        songID := mux.Vars(r)["id"]

        mockLyrics := `[Verse 1]
This is a test song
With some mock lyrics
For testing purposes only

[Chorus]
La la la la la
Test test test
Mock lyrics here

[Verse 2]
More test lyrics
In a structured format
With timestamps if needed

[Outro]
End of mock song`

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "meta": map[string]interface{}{
                                "status": 200,
                        },
                        "response": map[string]interface{}{
                                "song": map[string]interface{}{
                                        "id":     songID,
                                        "lyrics": mockLyrics,
                                        "title":  "Test Song",
                                        "artist": "Test Artist",
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

// Google Translate Mocks

func (m *MockServer) mockGoogleTranslate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        var reqData map[string]interface{}
        json.Unmarshal([]byte(body), &amp;reqData)

        text := "Mock translated text"
        if q, ok := reqData["q"].(string); ok </span><span class="cov0" title="0">{
                text = fmt.Sprintf("Translated: %s", q)
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "data": map[string]interface{}{
                                "translations": []map[string]interface{}{
                                        {
                                                "translatedText":         text,
                                                "detectedSourceLanguage": "en",
                                        },
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockGoogleDetect(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "data": map[string]interface{}{
                                "detections": [][]map[string]interface{}{
                                        {
                                                {
                                                        "language":   "en",
                                                        "isReliable": true,
                                                        "confidence": 0.95,
                                                },
                                        },
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

// LibreTranslate Mocks

func (m *MockServer) mockLibreTranslate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        var reqData map[string]interface{}
        json.Unmarshal([]byte(body), &amp;reqData)

        text := "Mock LibreTranslate result"
        if q, ok := reqData["q"].(string); ok </span><span class="cov0" title="0">{
                text = fmt.Sprintf("LibreTranslated: %s", q)
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "translatedText": text,
                },
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockLibreDetect(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: []map[string]interface{}{
                        {
                                "confidence": 0.92,
                                "language":   "en",
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

// MyMemory Translation Mock

func (m *MockServer) mockMyMemoryTranslate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        q := r.URL.Query().Get("q")

        text := "Mock MyMemory translation"
        if q != "" </span><span class="cov0" title="0">{
                text = fmt.Sprintf("MyMemory: %s", q)
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "responseData": map[string]interface{}{
                                "translatedText": text,
                                "match":          0.85,
                        },
                        "quotaFinished":   false,
                        "mtLangSupported": true,
                        "responseDetails": "",
                        "responseStatus":  200,
                        "responderId":     "MyMemory",
                },
        }
        m.respondWithDelay(w, response)</span>
}

// Music API Mocks

func (m *MockServer) mockMusicBrainzSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        format := r.URL.Query().Get("fmt")

        if format != "json" </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/xml")
                w.WriteHeader(200)
                w.Write([]byte(`&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;metadata/&gt;`))
                return
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "recordings": []map[string]interface{}{
                                {
                                        "id":    "test-recording-id-123",
                                        "title": "Test Recording",
                                        "artist-credit": []map[string]interface{}{
                                                {
                                                        "name": "Test Artist",
                                                        "artist": map[string]interface{}{
                                                                "id":   "test-artist-id-456",
                                                                "name": "Test Artist",
                                                        },
                                                },
                                        },
                                        "releases": []map[string]interface{}{
                                                {
                                                        "id":    "test-release-id-789",
                                                        "title": "Test Album",
                                                        "date":  "2023-01-01",
                                                },
                                        },
                                },
                        },
                        "count":  1,
                        "offset": 0,
                },
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockLastFMAPI(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        method := r.URL.Query().Get("method")
        format := r.URL.Query().Get("format")

        if format != "json" </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/xml")
                w.WriteHeader(200)
                w.Write([]byte(`&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;lfm status="ok"&gt;&lt;/lfm&gt;`))
                return
        }</span>

        <span class="cov0" title="0">var responseBody interface{}

        switch method </span>{
        case "album.getinfo":<span class="cov0" title="0">
                responseBody = map[string]interface{}{
                        "album": map[string]interface{}{
                                "name":   "Test Album",
                                "artist": "Test Artist",
                                "image": []map[string]interface{}{
                                        {
                                                "#text": fmt.Sprintf("%s/images/album_small.jpg", m.URL()),
                                                "size":  "small",
                                        },
                                        {
                                                "#text": fmt.Sprintf("%s/images/album_large.jpg", m.URL()),
                                                "size":  "large",
                                        },
                                },
                        },
                }</span>
        case "track.getinfo":<span class="cov0" title="0">
                responseBody = map[string]interface{}{
                        "track": map[string]interface{}{
                                "name": "Test Track",
                                "artist": map[string]interface{}{
                                        "name": "Test Artist",
                                },
                                "album": map[string]interface{}{
                                        "title": "Test Album",
                                        "image": []map[string]interface{}{
                                                {
                                                        "#text": fmt.Sprintf("%s/images/track_large.jpg", m.URL()),
                                                        "size":  "large",
                                                },
                                        },
                                },
                        },
                }</span>
        default:<span class="cov0" title="0">
                responseBody = map[string]interface{}{
                        "error":   6,
                        "message": "Invalid method",
                }</span>
        }

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body:       responseBody,
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockiTunesSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        results := []map[string]interface{}{
                {
                        "trackId":        123456789,
                        "trackName":      "Test Song",
                        "artistName":     "Test Artist",
                        "collectionName": "Test Album",
                        "artworkUrl30":   fmt.Sprintf("%s/images/itunes_30.jpg", m.URL()),
                        "artworkUrl60":   fmt.Sprintf("%s/images/itunes_60.jpg", m.URL()),
                        "artworkUrl100":  fmt.Sprintf("%s/images/itunes_100.jpg", m.URL()),
                        "artworkUrl500":  fmt.Sprintf("%s/images/itunes_500.jpg", m.URL()),
                        "releaseDate":    "2023-01-01T00:00:00Z",
                        "kind":           "song",
                        "trackPrice":     0.99,
                        "currency":       "USD",
                },
        }

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "resultCount": len(results),
                        "results":     results,
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockSpotifyToken(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "access_token": "mock_spotify_access_token_12345",
                        "token_type":   "Bearer",
                        "expires_in":   3600,
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockSpotifySearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        searchType := r.URL.Query().Get("type")

        var results interface{}

        if strings.Contains(searchType, "track") </span><span class="cov0" title="0">{
                results = map[string]interface{}{
                        "tracks": map[string]interface{}{
                                "items": []map[string]interface{}{
                                        {
                                                "id":   "test_track_id_123",
                                                "name": "Test Track",
                                                "artists": []map[string]interface{}{
                                                        {
                                                                "id":   "test_artist_id_456",
                                                                "name": "Test Artist",
                                                        },
                                                },
                                                "album": map[string]interface{}{
                                                        "id":   "test_album_id_789",
                                                        "name": "Test Album",
                                                        "images": []map[string]interface{}{
                                                                {
                                                                        "url":    fmt.Sprintf("%s/images/spotify_640.jpg", m.URL()),
                                                                        "height": 640,
                                                                        "width":  640,
                                                                },
                                                                {
                                                                        "url":    fmt.Sprintf("%s/images/spotify_300.jpg", m.URL()),
                                                                        "height": 300,
                                                                        "width":  300,
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                }
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body:       results,
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockDiscogsSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "results": []map[string]interface{}{
                                {
                                        "id":          123456,
                                        "title":       "Test Artist - Test Album",
                                        "type":        "release",
                                        "thumb":       fmt.Sprintf("%s/images/discogs_thumb.jpg", m.URL()),
                                        "cover_image": fmt.Sprintf("%s/images/discogs_cover.jpg", m.URL()),
                                        "year":        2023,
                                },
                        },
                        "pagination": map[string]interface{}{
                                "page":     1,
                                "pages":    1,
                                "per_page": 50,
                                "items":    1,
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

// Additional mocks for other services

func (m *MockServer) mockMusixmatchSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "message": map[string]interface{}{
                                "header": map[string]interface{}{
                                        "status_code": 200,
                                },
                                "body": map[string]interface{}{
                                        "track_list": []map[string]interface{}{
                                                {
                                                        "track": map[string]interface{}{
                                                                "track_id":      123456,
                                                                "track_name":    "Test Song",
                                                                "artist_name":   "Test Artist",
                                                                "album_name":    "Test Album",
                                                                "has_lyrics":    1,
                                                                "has_subtitles": 1,
                                                                "has_richsync":  1,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockMusixmatchLyrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        mockLyrics := `This is a test song
With mock lyrics from Musixmatch
Line by line format
For testing purposes`

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "message": map[string]interface{}{
                                "header": map[string]interface{}{
                                        "status_code": 200,
                                },
                                "body": map[string]interface{}{
                                        "lyrics": map[string]interface{}{
                                                "lyrics_id":           123456,
                                                "lyrics_body":         mockLyrics,
                                                "script_tracking_url": "",
                                                "pixel_tracking_url":  "",
                                                "lyrics_copyright":    "Mock Copyright",
                                        },
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockAZLyrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        artist := mux.Vars(r)["artist"]
        song := mux.Vars(r)["song"]

        mockHTML := fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;%s - %s Lyrics&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div class="lyrics"&gt;
This is a test song&lt;br&gt;
With mock lyrics from AZLyrics&lt;br&gt;
Artist: %s&lt;br&gt;
Song: %s&lt;br&gt;
For testing purposes only
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`, artist, song, artist, song)

        w.Header().Set("Content-Type", "text/html")
        w.WriteHeader(200)
        w.Write([]byte(mockHTML))
}</span>

func (m *MockServer) mockYifySubtitlesSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        subtitles := []map[string]interface{}{
                {
                        "id":        "yify_123",
                        "language":  "English",
                        "lang_code": "en",
                        "url":       fmt.Sprintf("%s/yifysubtitles/files/subtitle_en.srt", m.URL()),
                        "rating":    "good",
                        "downloads": 1250,
                },
                {
                        "id":        "yify_124",
                        "language":  "Spanish",
                        "lang_code": "es",
                        "url":       fmt.Sprintf("%s/yifysubtitles/files/subtitle_es.srt", m.URL()),
                        "rating":    "good",
                        "downloads": 890,
                },
        }

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "success": true,
                        "data":    subtitles,
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockMusicBrainzRelease(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "id":    "test-release-id-789",
                        "title": "Test Album",
                        "date":  "2023-01-01",
                        "cover-art-archive": map[string]interface{}{
                                "artwork": true,
                                "count":   1,
                                "front":   true,
                                "back":    false,
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockSetlistFMSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        artistName := r.URL.Query().Get("artistName")

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "type":         "setlists",
                        "itemsPerPage": 20,
                        "page":         1,
                        "total":        1,
                        "setlist": []map[string]interface{}{
                                {
                                        "id":        "test-setlist-123",
                                        "versionId": "test-version-456",
                                        "eventDate": "01-01-2023",
                                        "artist": map[string]interface{}{
                                                "mbid": "test-artist-mbid-789",
                                                "name": artistName,
                                        },
                                        "venue": map[string]interface{}{
                                                "id":   "test-venue-123",
                                                "name": "Test Venue",
                                                "city": map[string]interface{}{
                                                        "id":   "test-city-456",
                                                        "name": "Test City",
                                                        "country": map[string]interface{}{
                                                                "code": "US",
                                                                "name": "United States",
                                                        },
                                                },
                                        },
                                        "sets": map[string]interface{}{
                                                "set": []map[string]interface{}{
                                                        {
                                                                "song": []map[string]interface{}{
                                                                        {
                                                                                "name": "Test Song 1",
                                                                        },
                                                                        {
                                                                                "name": "Test Song 2",
                                                                        },
                                                                        {
                                                                                "name": "Test Song 3",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) readBody(r *http.Request) string <span class="cov0" title="0">{
        if r.Body == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">buf := make([]byte, r.ContentLength)
        r.Body.Read(buf)
        return string(buf)</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package main

import (
        "catalogizer/internal/config"
        "catalogizer/internal/handlers"
        "catalogizer/internal/middleware"
        "catalogizer/internal/services"
        "context"
        "database/sql"
        "flag"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"
        _ "github.com/mattn/go-sqlite3"
        "go.uber.org/zap"
)

// @title Catalog API
// @version 2.0
// @description REST API for browsing and searching multi-protocol file catalog (SMB, FTP, NFS, WebDAV, Local)
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /

// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

func main() <span class="cov0" title="0">{
        // Parse command line flags
        testMode := flag.Bool("test-mode", false, "Run in test mode with additional logging")
        flag.Parse()

        // Initialize logger
        logger, _ := zap.NewProduction()
        defer logger.Sync()

        if *testMode </span><span class="cov0" title="0">{
                logger.Info("Running in test mode")
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to load configuration:", err)
        }</span>

        // Initialize database
        // Use the Database field as the path for SQLite
        <span class="cov0" title="0">dbPath := cfg.Database.Database
        if dbPath == "" </span><span class="cov0" title="0">{
                dbPath = "./data/catalogizer.db" // Default path
        }</span>
        <span class="cov0" title="0">db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to connect to database:", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Initialize services
        catalogService := services.NewCatalogService(cfg, logger)
        catalogService.SetDB(db)
        smbService := services.NewSMBService(cfg, logger)
        smbDiscoveryService := services.NewSMBDiscoveryService(logger)

        // Initialize handlers
        catalogHandler := handlers.NewCatalogHandler(catalogService, smbService, logger)
        downloadHandler := handlers.NewDownloadHandler(catalogService, smbService, cfg.Catalog.TempDir, cfg.Catalog.MaxArchiveSize, cfg.Catalog.DownloadChunkSize, logger)
        copyHandler := handlers.NewCopyHandler(catalogService, smbService, cfg.Catalog.TempDir, logger)
        smbDiscoveryHandler := handlers.NewSMBDiscoveryHandler(smbDiscoveryService, logger)

        // Setup Gin router
        router := gin.Default()

        // Middleware
        router.Use(middleware.CORS())
        router.Use(middleware.Logger(logger))
        router.Use(middleware.ErrorHandler())
        router.Use(middleware.RequestID())

        // Health check
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"status": "healthy", "time": time.Now().UTC()})
        }</span>)

        // API routes
        <span class="cov0" title="0">api := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Catalog browsing endpoints
                api.GET("/catalog", catalogHandler.ListRoot)
                api.GET("/catalog/*path", catalogHandler.ListPath)
                api.GET("/catalog-info/*path", catalogHandler.GetFileInfo)

                // Search endpoints
                api.GET("/search", catalogHandler.Search)
                api.GET("/search/duplicates", catalogHandler.SearchDuplicates)

                // Download endpoints
                api.GET("/download/file/:id", downloadHandler.DownloadFile)
                api.GET("/download/directory/*path", downloadHandler.DownloadDirectory)
                api.POST("/download/archive", downloadHandler.DownloadArchive)

                // File operations
                api.POST("/copy/storage", copyHandler.CopyToStorage)
                api.POST("/copy/local", copyHandler.CopyToLocal)
                api.POST("/copy/upload", copyHandler.CopyFromLocal)
                api.GET("/storage/list/*path", copyHandler.ListStoragePath)
                api.GET("/storage/roots", copyHandler.GetStorageRoots)

                // Statistics and sorting
                api.GET("/stats/directories/by-size", catalogHandler.GetDirectoriesBySize)
                api.GET("/stats/duplicates/count", catalogHandler.GetDuplicatesCount)

                // SMB Discovery endpoints
                smbGroup := api.Group("/smb")
                </span><span class="cov0" title="0">{
                        smbGroup.POST("/discover", smbDiscoveryHandler.DiscoverShares)
                        smbGroup.GET("/discover", smbDiscoveryHandler.DiscoverSharesGET)
                        smbGroup.POST("/test", smbDiscoveryHandler.TestConnection)
                        smbGroup.GET("/test", smbDiscoveryHandler.TestConnectionGET)
                        smbGroup.POST("/browse", smbDiscoveryHandler.BrowseShare)
                }</span>
        }

        // Create HTTP server
        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:         cfg.GetServerAddress(),
                Handler:      router,
                ReadTimeout:  time.Duration(cfg.Server.ReadTimeout) * time.Second,
                WriteTimeout: time.Duration(cfg.Server.WriteTimeout) * time.Second,
                IdleTimeout:  time.Duration(cfg.Server.IdleTimeout) * time.Second,
        }

        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                logger.Info("Starting catalog API server", zap.String("address", cfg.GetServerAddress()))
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to start server", zap.Error(err))
                }</span>
        }()

        // Wait for interrupt signal to gracefully shutdown the server
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit
        logger.Info("Shutting down server...")

        // The context is used to inform the server it has 30 seconds to finish
        // the request it is currently handling
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Server forced to shutdown", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Info("Server exited")</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package middleware

import (
        "net/http"
        "strings"
        "time"

        "catalogizer/utils"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
)

// JWTMiddleware handles JWT authentication
type JWTMiddleware struct {
        secretKey []byte
}

// Claims represents JWT claims
type Claims struct {
        Username string `json:"username"`
        jwt.RegisteredClaims
}

// NewJWTMiddleware creates a new JWT middleware
func NewJWTMiddleware(secretKey string) *JWTMiddleware <span class="cov0" title="0">{
        return &amp;JWTMiddleware{
                secretKey: []byte(secretKey),
        }
}</span>

// RequireAuth returns a middleware that requires valid JWT authentication
func (m *JWTMiddleware) RequireAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusUnauthorized, "Authorization header required", nil)
                        c.Abort()
                        return
                }</span>

                // Extract token from "Bearer &lt;token&gt;"
                <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusUnauthorized, "Invalid authorization header format", nil)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">tokenString := parts[1]

                // Parse and validate token
                claims := &amp;Claims{}
                token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        return m.secretKey, nil
                }</span>)

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusUnauthorized, "Invalid token", err)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusUnauthorized, "Invalid token", nil)
                        c.Abort()
                        return
                }</span>

                // Set user info in context
                <span class="cov0" title="0">c.Set("username", claims.Username)
                c.Set("user_id", claims.Subject)

                c.Next()</span>
        }
}

// GenerateToken generates a new JWT token
func (m *JWTMiddleware) GenerateToken(username, userID string, expirationHours int) (string, error) <span class="cov0" title="0">{
        claims := &amp;Claims{
                Username: username,
                RegisteredClaims: jwt.RegisteredClaims{
                        Subject:   userID,
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Duration(expirationHours) * time.Hour)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        Issuer:    "catalog-api",
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(m.secretKey)
}</span>

// ValidateToken validates a JWT token and returns claims
func (m *JWTMiddleware) ValidateToken(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        claims := &amp;Claims{}
        token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return m.secretKey, nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                return nil, jwt.ErrTokenNotValidYet
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// RequestID adds a unique request ID to each request
func RequestID() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = uuid.New().String()
                }</span>

                <span class="cov0" title="0">c.Header("X-Request-ID", requestID)
                c.Set("request_id", requestID)
                c.Next()</span>
        }
}

// RateLimiter implements basic rate limiting
func RateLimiter(requestsPerMinute int) gin.HandlerFunc <span class="cov0" title="0">{
        // This is a simplified rate limiter
        // In production, you'd want to use Redis or similar for distributed rate limiting
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Placeholder for rate limiting logic
                c.Next()
        }</span>
}

// CORS handles Cross-Origin Resource Sharing
func CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Credentials", "true")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Header("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "time"
)

// User represents a system user with role-based permissions
type User struct {
        ID                  int        `json:"id" db:"id"`
        Username            string     `json:"username" db:"username"`
        Email               string     `json:"email" db:"email"`
        PasswordHash        string     `json:"-" db:"password_hash"` // Never include in JSON
        Salt                string     `json:"-" db:"salt"`          // Never include in JSON
        RoleID              int        `json:"role_id" db:"role_id"`
        Role                *Role      `json:"role,omitempty"`
        FirstName           *string    `json:"first_name" db:"first_name"`
        LastName            *string    `json:"last_name" db:"last_name"`
        DisplayName         *string    `json:"display_name" db:"display_name"`
        AvatarURL           *string    `json:"avatar_url" db:"avatar_url"`
        TimeZone            *string    `json:"time_zone" db:"time_zone"`
        Language            *string    `json:"language" db:"language"`
        Settings            string     `json:"settings" db:"settings"`
        IsActive            bool       `json:"is_active" db:"is_active"`
        IsLocked            bool       `json:"is_locked" db:"is_locked"`
        LockedUntil         *time.Time `json:"locked_until,omitempty" db:"locked_until"`
        FailedLoginAttempts int        `json:"failed_login_attempts" db:"failed_login_attempts"`
        LastLoginAt         *time.Time `json:"last_login_at" db:"last_login_at"`
        LastLoginIP         *string    `json:"last_login_ip,omitempty" db:"last_login_ip"`
        CreatedAt           time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt           time.Time  `json:"updated_at" db:"updated_at"`
}

// Role represents a user role with specific permissions
type Role struct {
        ID          int         `json:"id" db:"id"`
        Name        string      `json:"name" db:"name"`
        Description *string     `json:"description" db:"description"`
        Permissions Permissions `json:"permissions" db:"permissions"`
        IsSystem    bool        `json:"is_system" db:"is_system"`
        CreatedAt   time.Time   `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time   `json:"updated_at" db:"updated_at"`
}

// Permissions represents a list of permission strings
type Permissions []string

// Value implements the driver.Valuer interface for database storage
func (p Permissions) Value() (driver.Value, error) <span class="cov0" title="0">{
        if len(p) == 0 </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>
        <span class="cov0" title="0">return json.Marshal(p)</span>
}

// Scan implements the sql.Scanner interface for database retrieval
func (p *Permissions) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *p = Permissions{}
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), p)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, p)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// HasPermission checks if the permissions include a specific permission
func (p Permissions) HasPermission(permission string) bool <span class="cov0" title="0">{
        // Check for wildcard permission
        for _, perm := range p </span><span class="cov0" title="0">{
                if perm == "*" </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if perm == permission </span><span class="cov0" title="0">{
                        return true
                }</span>
                // Check for wildcard patterns (e.g., "media.*" matches "media.view")
                <span class="cov0" title="0">if len(perm) &gt; 0 &amp;&amp; perm[len(perm)-1] == '*' </span><span class="cov0" title="0">{
                        prefix := perm[:len(perm)-1]
                        if len(permission) &gt;= len(prefix) &amp;&amp; permission[:len(prefix)] == prefix </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// HasAnyPermission checks if the permissions include any of the specified permissions
func (p Permissions) HasAnyPermission(permissions []string) bool <span class="cov0" title="0">{
        for _, permission := range permissions </span><span class="cov0" title="0">{
                if p.HasPermission(permission) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// UserPreferences represents user-specific preferences
type UserPreferences struct {
        Theme                string            `json:"theme,omitempty"`
        Language             string            `json:"language,omitempty"`
        Timezone             string            `json:"timezone,omitempty"`
        MediaPlayerSettings  MediaPlayerPrefs  `json:"media_player,omitempty"`
        NotificationSettings NotificationPrefs `json:"notifications,omitempty"`
        PrivacySettings      PrivacyPrefs      `json:"privacy,omitempty"`
        UISettings           UIPrefs           `json:"ui,omitempty"`
}

// MediaPlayerPrefs represents media player preferences
type MediaPlayerPrefs struct {
        AutoPlay       bool    `json:"auto_play"`
        DefaultQuality string  `json:"default_quality"`
        Volume         float64 `json:"volume"`
        Subtitles      bool    `json:"subtitles"`
        SkipIntro      bool    `json:"skip_intro"`
}

// NotificationPrefs represents notification preferences
type NotificationPrefs struct {
        EmailNotifications bool `json:"email_notifications"`
        PushNotifications  bool `json:"push_notifications"`
        SyncNotifications  bool `json:"sync_notifications"`
        ErrorNotifications bool `json:"error_notifications"`
}

// PrivacyPrefs represents privacy preferences
type PrivacyPrefs struct {
        ShareUsageData      bool `json:"share_usage_data"`
        LocationTracking    bool `json:"location_tracking"`
        AnalyticsTracking   bool `json:"analytics_tracking"`
        PersonalizedContent bool `json:"personalized_content"`
}

// UIPrefs represents UI preferences
type UIPrefs struct {
        DensityMode     string `json:"density_mode"` // compact, comfortable, spacious
        GridSize        int    `json:"grid_size"`    // items per row
        ShowThumbnails  bool   `json:"show_thumbnails"`
        ShowMetadata    bool   `json:"show_metadata"`
        DefaultSortBy   string `json:"default_sort_by"`
        DefaultSortDesc bool   `json:"default_sort_desc"`
}

// UserSettings represents user-specific settings
type UserSettings struct {
        DefaultShare         string                 `json:"default_share,omitempty"`
        AutoSync             bool                   `json:"auto_sync"`
        SyncIntervalMinutes  int                    `json:"sync_interval_minutes"`
        DownloadQuality      string                 `json:"download_quality"`
        CacheSettings        CacheSettings          `json:"cache,omitempty"`
        ConversionSettings   ConversionSettings     `json:"conversion,omitempty"`
        BackupSettings       BackupSettings         `json:"backup,omitempty"`
        SecuritySettings     SecuritySettings       `json:"security,omitempty"`
        ExperimentalFeatures map[string]interface{} `json:"experimental_features,omitempty"`
}

// CacheSettings represents caching preferences
type CacheSettings struct {
        MaxCacheSize    int64 `json:"max_cache_size"` // bytes
        CacheThumbnails bool  `json:"cache_thumbnails"`
        CacheMetadata   bool  `json:"cache_metadata"`
        CacheTimeout    int   `json:"cache_timeout"` // minutes
}

// ConversionSettings represents format conversion preferences
type ConversionSettings struct {
        DefaultVideoFormat string `json:"default_video_format"`
        DefaultAudioFormat string `json:"default_audio_format"`
        DefaultQuality     string `json:"default_quality"`
        MaxConcurrentJobs  int    `json:"max_concurrent_jobs"`
}

// BackupSettings represents backup preferences
type BackupSettings struct {
        AutoBackup       bool   `json:"auto_backup"`
        BackupInterval   string `json:"backup_interval"`  // daily, weekly, monthly
        BackupRetention  int    `json:"backup_retention"` // days
        BackupLocation   string `json:"backup_location"`
        BackupEncryption bool   `json:"backup_encryption"`
}

// SecuritySettings represents security preferences
type SecuritySettings struct {
        TwoFactorEnabled   bool     `json:"two_factor_enabled"`
        SessionTimeout     int      `json:"session_timeout"`      // minutes
        RequirePasswordFor []string `json:"require_password_for"` // actions requiring password
        LoginNotifications bool     `json:"login_notifications"`
}

// Value implements the driver.Valuer interface for UserPreferences
func (up UserPreferences) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(up)
}</span>

// Scan implements the sql.Scanner interface for UserPreferences
func (up *UserPreferences) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *up = UserPreferences{}
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), up)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, up)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface for UserSettings
func (us UserSettings) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(us)
}</span>

// Scan implements the sql.Scanner interface for UserSettings
func (us *UserSettings) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *us = UserSettings{}
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), us)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, us)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// UserSession represents an active user session
type UserSession struct {
        ID             int        `json:"id" db:"id"`
        UserID         int        `json:"user_id" db:"user_id"`
        SessionToken   string     `json:"session_token" db:"session_token"`
        RefreshToken   *string    `json:"refresh_token,omitempty" db:"refresh_token"`
        DeviceInfo     DeviceInfo `json:"device_info" db:"device_info"`
        IPAddress      *string    `json:"ip_address,omitempty" db:"ip_address"`
        UserAgent      *string    `json:"user_agent,omitempty" db:"user_agent"`
        IsActive       bool       `json:"is_active" db:"is_active"`
        ExpiresAt      time.Time  `json:"expires_at" db:"expires_at"`
        CreatedAt      time.Time  `json:"created_at" db:"created_at"`
        LastActivityAt time.Time  `json:"last_activity_at" db:"last_activity_at"`
}

// DeviceInfo represents information about the user's device
type DeviceInfo struct {
        DeviceType      string  `json:"device_type"` // mobile, tablet, desktop, tv
        Platform        string  `json:"platform"`    // android, ios, windows, macos, linux
        PlatformVersion string  `json:"platform_version"`
        AppVersion      string  `json:"app_version"`
        DeviceModel     *string `json:"device_model,omitempty"`
        DeviceName      *string `json:"device_name,omitempty"`
        ScreenSize      *string `json:"screen_size,omitempty"`
        IsEmulator      bool    `json:"is_emulator"`
}

// Value implements the driver.Valuer interface for DeviceInfo
func (di DeviceInfo) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(di)
}</span>

// Scan implements the sql.Scanner interface for DeviceInfo
func (di *DeviceInfo) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *di = DeviceInfo{}
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), di)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, di)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// UserSummary represents a summary view of user information
type UserSummary struct {
        ID                 int        `json:"id" db:"id"`
        Username           string     `json:"username" db:"username"`
        Email              string     `json:"email" db:"email"`
        DisplayName        *string    `json:"display_name" db:"display_name"`
        RoleName           string     `json:"role_name" db:"role_name"`
        RoleDisplayName    string     `json:"role_display_name" db:"role_display_name"`
        IsActive           bool       `json:"is_active" db:"is_active"`
        LastLoginAt        *time.Time `json:"last_login_at" db:"last_login_at"`
        TotalMediaAccesses int        `json:"total_media_accesses" db:"total_media_accesses"`
        TotalFavorites     int        `json:"total_favorites" db:"total_favorites"`
        CreatedAt          time.Time  `json:"created_at" db:"created_at"`
}

// CreateUserRequest represents a request to create a new user
type CreateUserRequest struct {
        Username                string           `json:"username" validate:"required,min=3,max=50"`
        Email                   string           `json:"email" validate:"required,email"`
        Password                string           `json:"password" validate:"required,min=8"`
        RoleID                  int              `json:"role_id" validate:"required"`
        FirstName               *string          `json:"first_name"`
        LastName                *string          `json:"last_name"`
        TimeZone                *string          `json:"time_zone"`
        Language                *string          `json:"language"`
        IsActive                *bool            `json:"is_active"`
        DisplayName             *string          `json:"display_name"`
        LocationTrackingEnabled *bool            `json:"location_tracking_enabled"`
        AnalyticsEnabled        *bool            `json:"analytics_enabled"`
        Preferences             *UserPreferences `json:"preferences"`
        Settings                *UserSettings    `json:"settings"`
}

// UpdateUserRequest represents a request to update user information
type UpdateUserRequest struct {
        Username                *string          `json:"username" validate:"omitempty,min=3,max=50"`
        Email                   *string          `json:"email" validate:"omitempty,email"`
        RoleID                  *int             `json:"role_id"`
        FirstName               *string          `json:"first_name"`
        LastName                *string          `json:"last_name"`
        TimeZone                *string          `json:"time_zone"`
        Language                *string          `json:"language"`
        DisplayName             *string          `json:"display_name"`
        AvatarURL               *string          `json:"avatar_url"`
        LocationTrackingEnabled *bool            `json:"location_tracking_enabled"`
        AnalyticsEnabled        *bool            `json:"analytics_enabled"`
        IsActive                *bool            `json:"is_active"`
        Preferences             *UserPreferences `json:"preferences"`
        Settings                *UserSettings    `json:"settings"`
}

// CreateRoleRequest represents a request to create a new role
type CreateRoleRequest struct {
        Name        string   `json:"name" validate:"required,min=2,max=50"`
        Description *string  `json:"description"`
        Permissions []string `json:"permissions" validate:"required"`
}

// UpdateRoleRequest represents a request to update role information
type UpdateRoleRequest struct {
        Name        *string  `json:"name" validate:"omitempty,min=2,max=50"`
        Description *string  `json:"description"`
        Permissions []string `json:"permissions"`
}

// ChangePasswordRequest represents a request to change user password
type ChangePasswordRequest struct {
        CurrentPassword string `json:"current_password" validate:"required"`
        NewPassword     string `json:"new_password" validate:"required,min=8"`
}

// LoginRequest represents a login request
type LoginRequest struct {
        Username   string     `json:"username" validate:"required"`
        Password   string     `json:"password" validate:"required"`
        DeviceInfo DeviceInfo `json:"device_info"`
        RememberMe bool       `json:"remember_me"`
}

// LoginResponse represents a login response
type LoginResponse struct {
        User         User      `json:"user"`
        SessionToken string    `json:"session_token"`
        RefreshToken string    `json:"refresh_token"`
        ExpiresAt    time.Time `json:"expires_at"`
}

// RefreshTokenRequest represents a token refresh request
type RefreshTokenRequest struct {
        RefreshToken string `json:"refresh_token" validate:"required"`
}

// UserListResponse represents a paginated list of users
type UserListResponse struct {
        Users      []UserSummary `json:"users"`
        Total      int           `json:"total"`
        Page       int           `json:"page"`
        PageSize   int           `json:"page_size"`
        TotalPages int           `json:"total_pages"`
}

// Common permission constants
const (
        // System permissions
        PermissionSystemAdmin  = "system.admin"
        PermissionSystemConfig = "system.configure"

        // User management permissions
        PermissionUserView   = "user.view"
        PermissionUserCreate = "user.create"
        PermissionUserUpdate = "user.update"
        PermissionUserDelete = "user.delete"
        PermissionUserManage = "user.manage" // includes all user operations

        // Media permissions
        PermissionMediaView     = "media.view"
        PermissionMediaUpload   = "media.upload"
        PermissionMediaEdit     = "media.edit"
        PermissionMediaDelete   = "media.delete"
        PermissionMediaShare    = "media.share"
        PermissionMediaDownload = "media.download"
        PermissionMediaConvert  = "media.convert"
        PermissionMediaManage   = "media.manage" // includes all media operations

        // Share permissions
        PermissionShareView    = "share.view"
        PermissionShareCreate  = "share.create"
        PermissionShareEdit    = "share.edit"
        PermissionShareDelete  = "share.delete"
        PermissionShareManage  = "share.manage" // includes all share operations
        PermissionViewShares   = "share.view"
        PermissionEditShares   = "share.edit"
        PermissionDeleteShares = "share.delete"

        // Analytics permissions
        PermissionAnalyticsView   = "analytics.view"
        PermissionAnalyticsExport = "analytics.export"
        PermissionAnalyticsManage = "analytics.manage"
        PermissionViewAnalytics   = "analytics.view"

        // Favorites permissions
        PermissionFavoriteView   = "favorite.view"
        PermissionFavoriteCreate = "favorite.create"
        PermissionFavoriteDelete = "favorite.delete"

        // Profile permissions
        PermissionProfileView   = "profile.view"
        PermissionProfileUpdate = "profile.update"

        // Sync permissions
        PermissionSyncView    = "sync.view"
        PermissionSyncCreate  = "sync.create"
        PermissionSyncExecute = "sync.execute"
        PermissionSyncManage  = "sync.manage"

        // Conversion permissions
        PermissionConversionView   = "conversion.view"
        PermissionConversionCreate = "conversion.create"
        PermissionConversionManage = "conversion.manage"

        // Report permissions
        PermissionReportView   = "report.view"
        PermissionReportCreate = "report.create"
        PermissionReportExport = "report.export"

        // Wildcard permission
        PermissionWildcard = "*"
)

// Utility functions

// IsAccountLocked checks if the user account is currently locked
func (u *User) IsAccountLocked() bool <span class="cov0" title="0">{
        return u.IsLocked || (u.LockedUntil != nil &amp;&amp; u.LockedUntil.After(time.Now()))
}</span>

// CanLogin checks if the user can login (active and not locked)
func (u *User) CanLogin() bool <span class="cov0" title="0">{
        return u.IsActive &amp;&amp; !u.IsAccountLocked()
}</span>

// HasPermission checks if the user has a specific permission
func (u *User) HasPermission(permission string) bool <span class="cov0" title="0">{
        if u.Role == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return u.Role.Permissions.HasPermission(permission)</span>
}

// HasAnyPermission checks if the user has any of the specified permissions
func (u *User) HasAnyPermission(permissions []string) bool <span class="cov0" title="0">{
        if u.Role == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return u.Role.Permissions.HasAnyPermission(permissions)</span>
}

// IsAdmin checks if the user is an administrator
func (u *User) IsAdmin() bool <span class="cov0" title="0">{
        return u.HasPermission(PermissionSystemAdmin) || u.HasPermission(PermissionWildcard)
}</span>

// GetDefaultPreferences returns default user preferences
func GetDefaultPreferences() UserPreferences <span class="cov0" title="0">{
        return UserPreferences{
                Theme:    "auto",
                Language: "en",
                Timezone: "UTC",
                MediaPlayerSettings: MediaPlayerPrefs{
                        AutoPlay:       false,
                        DefaultQuality: "auto",
                        Volume:         0.8,
                        Subtitles:      false,
                        SkipIntro:      false,
                },
                NotificationSettings: NotificationPrefs{
                        EmailNotifications: true,
                        PushNotifications:  true,
                        SyncNotifications:  true,
                        ErrorNotifications: true,
                },
                PrivacySettings: PrivacyPrefs{
                        ShareUsageData:      true,
                        LocationTracking:    true,
                        AnalyticsTracking:   true,
                        PersonalizedContent: true,
                },
                UISettings: UIPrefs{
                        DensityMode:     "comfortable",
                        GridSize:        4,
                        ShowThumbnails:  true,
                        ShowMetadata:    true,
                        DefaultSortBy:   "name",
                        DefaultSortDesc: false,
                },
        }
}</span>

// GetDefaultSettings returns default user settings
func GetDefaultSettings() UserSettings <span class="cov0" title="0">{
        return UserSettings{
                AutoSync:            true,
                SyncIntervalMinutes: 60,
                DownloadQuality:     "original",
                CacheSettings: CacheSettings{
                        MaxCacheSize:    1024 * 1024 * 1024, // 1GB
                        CacheThumbnails: true,
                        CacheMetadata:   true,
                        CacheTimeout:    60, // 1 hour
                },
                ConversionSettings: ConversionSettings{
                        DefaultVideoFormat: "mp4",
                        DefaultAudioFormat: "mp3",
                        DefaultQuality:     "high",
                        MaxConcurrentJobs:  3,
                },
                BackupSettings: BackupSettings{
                        AutoBackup:       false,
                        BackupInterval:   "weekly",
                        BackupRetention:  30,
                        BackupEncryption: true,
                },
                SecuritySettings: SecuritySettings{
                        TwoFactorEnabled:   false,
                        SessionTimeout:     1440, // 24 hours in minutes
                        RequirePasswordFor: []string{"delete", "share"},
                        LoginNotifications: true,
                },
                ExperimentalFeatures: make(map[string]interface{}),
        }
}</span>

// Analytics and Reporting Models

// MediaAccessLog represents a log entry for media access
type MediaAccessLog struct {
        ID               int            `json:"id" db:"id"`
        UserID           int            `json:"user_id" db:"user_id"`
        MediaID          int            `json:"media_id" db:"media_id"`
        Action           string         `json:"action" db:"action"`
        DeviceInfo       *DeviceInfo    `json:"device_info,omitempty" db:"device_info"`
        Location         *Location      `json:"location,omitempty" db:"location"`
        IPAddress        *string        `json:"ip_address,omitempty" db:"ip_address"`
        UserAgent        *string        `json:"user_agent,omitempty" db:"user_agent"`
        PlaybackDuration *time.Duration `json:"playback_duration,omitempty" db:"playback_duration"`
        AccessTime       time.Time      `json:"access_time" db:"access_time"`
}

// AnalyticsEvent represents a general analytics event
type AnalyticsEvent struct {
        ID            int         `json:"id" db:"id"`
        UserID        int         `json:"user_id" db:"user_id"`
        EventType     string      `json:"event_type" db:"event_type"`
        EventCategory string      `json:"event_category" db:"event_category"`
        Data          string      `json:"data" db:"data"`
        DeviceInfo    *DeviceInfo `json:"device_info,omitempty" db:"device_info"`
        Location      *Location   `json:"location,omitempty" db:"location"`
        IPAddress     *string     `json:"ip_address,omitempty" db:"ip_address"`
        UserAgent     *string     `json:"user_agent,omitempty" db:"user_agent"`
        Timestamp     time.Time   `json:"timestamp" db:"timestamp"`
}

// Location represents geographic coordinates
type Location struct {
        Latitude  float64  `json:"latitude"`
        Longitude float64  `json:"longitude"`
        Country   *string  `json:"country,omitempty"`
        City      *string  `json:"city,omitempty"`
        Accuracy  *float64 `json:"accuracy,omitempty"`
}

// AnalyticsEventRequest represents a request to track an analytics event
type AnalyticsEventRequest struct {
        EventType  string                 `json:"event_type"`
        EntityType string                 `json:"entity_type,omitempty"`
        EntityID   int                    `json:"entity_id,omitempty"`
        Metadata   map[string]interface{} `json:"metadata,omitempty"`
        SessionID  string                 `json:"session_id,omitempty"`
}

// AnalyticsFilters represents filters for analytics queries
type AnalyticsFilters struct {
        StartDate   *time.Time `json:"start_date,omitempty"`
        EndDate     *time.Time `json:"end_date,omitempty"`
        EventTypes  []string   `json:"event_types,omitempty"`
        EntityTypes []string   `json:"entity_types,omitempty"`
        Limit       int        `json:"limit,omitempty"`
        Offset      int        `json:"offset,omitempty"`
}

// AnalyticsData represents aggregated analytics data
type AnalyticsData struct {
        TotalEvents    int64                    `json:"total_events"`
        EventBreakdown map[string]int           `json:"event_breakdown"`
        Trends         map[string][]interface{} `json:"trends"`
        TopEntities    []map[string]interface{} `json:"top_entities"`
}

// DashboardMetrics represents dashboard metrics
type DashboardMetrics struct {
        TotalUsers       int64 `json:"total_users"`
        ActiveUsers      int64 `json:"active_users"`
        TotalMediaItems  int64 `json:"total_media_items"`
        TotalStorageUsed int64 `json:"total_storage_used"`
        RecentActivity   int64 `json:"recent_activity"`
}

// RealtimeMetrics represents realtime metrics
type RealtimeMetrics struct {
        ActiveUsers    int     `json:"active_users"`
        CurrentStreams int     `json:"current_streams"`
        RecentEvents   int     `json:"recent_events"`
        SystemLoad     float64 `json:"system_load"`
}

// ReportRequest represents a request to generate a report
type ReportRequest struct {
        ReportType string                 `json:"report_type"`
        Params     map[string]interface{} `json:"params,omitempty"`
}

// UserAnalytics represents analytics data for a user
type UserAnalytics struct {
        UserID               int                `json:"user_id"`
        StartDate            time.Time          `json:"start_date"`
        EndDate              time.Time          `json:"end_date"`
        TotalMediaAccesses   int                `json:"total_media_accesses"`
        TotalEvents          int                `json:"total_events"`
        UniqueMediaAccessed  int                `json:"unique_media_accessed"`
        TotalPlaybackTime    time.Duration      `json:"total_playback_time"`
        MostAccessedMedia    []MediaAccessCount `json:"most_accessed_media"`
        PreferredAccessTimes map[string]int     `json:"preferred_access_times"`
        DeviceUsage          map[string]int     `json:"device_usage"`
        LocationAnalysis     map[string]int     `json:"location_analysis"`
}

// SystemAnalytics represents system-wide analytics
type SystemAnalytics struct {
        StartDate              time.Time              `json:"start_date"`
        EndDate                time.Time              `json:"end_date"`
        TotalUsers             int                    `json:"total_users"`
        ActiveUsers            int                    `json:"active_users"`
        TotalMediaAccesses     int                    `json:"total_media_accesses"`
        TotalEvents            int                    `json:"total_events"`
        TopAccessedMedia       []MediaAccessCount     `json:"top_accessed_media"`
        UserGrowthData         []UserGrowthPoint      `json:"user_growth_data"`
        AverageSessionDuration time.Duration          `json:"average_session_duration"`
        PeakUsageHours         map[string]int         `json:"peak_usage_hours"`
        PopularFileTypes       map[string]int         `json:"popular_file_types"`
        GeographicDistribution map[string]interface{} `json:"geographic_distribution"`
}

// MediaAnalytics represents analytics for specific media
type MediaAnalytics struct {
        MediaID             int                    `json:"media_id"`
        StartDate           time.Time              `json:"start_date"`
        EndDate             time.Time              `json:"end_date"`
        TotalAccesses       int                    `json:"total_accesses"`
        UniqueUsers         int                    `json:"unique_users"`
        TotalPlaybackTime   time.Duration          `json:"total_playback_time"`
        AveragePlaybackTime time.Duration          `json:"average_playback_time"`
        AccessPatterns      map[string]interface{} `json:"access_patterns"`
        UserRetention       float64                `json:"user_retention"`
        PopularTimeRanges   map[string]int         `json:"popular_time_ranges"`
        DevicePreferences   map[string]int         `json:"device_preferences"`
}

// MediaAccessCount represents media access statistics
type MediaAccessCount struct {
        MediaID     int `json:"media_id"`
        AccessCount int `json:"access_count"`
}

// UserGrowthPoint represents a point in user growth data
type UserGrowthPoint struct {
        Date      time.Time `json:"date"`
        UserCount int       `json:"user_count"`
}

// SessionData represents session information for analytics
type SessionData struct {
        UserID    int           `json:"user_id"`
        StartTime time.Time     `json:"start_time"`
        EndTime   time.Time     `json:"end_time"`
        Duration  time.Duration `json:"duration"`
}

// AnalyticsReport represents a generated analytics report
type AnalyticsReport struct {
        Type      string    `json:"type"`
        Data      string    `json:"data"`
        CreatedAt time.Time `json:"created_at"`
        Status    string    `json:"status"`
}

// Favorites Models

// Favorite represents a user's favorite item
type Favorite struct {
        ID         int        `json:"id" db:"id"`
        UserID     int        `json:"user_id" db:"user_id"`
        EntityType string     `json:"entity_type" db:"entity_type"`
        EntityID   int        `json:"entity_id" db:"entity_id"`
        Category   *string    `json:"category,omitempty" db:"category"`
        Notes      *string    `json:"notes,omitempty" db:"notes"`
        Tags       *[]string  `json:"tags,omitempty" db:"tags"`
        IsPublic   bool       `json:"is_public" db:"is_public"`
        CreatedAt  time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt  *time.Time `json:"updated_at,omitempty" db:"updated_at"`
}

// FavoriteCategory represents a category for organizing favorites
type FavoriteCategory struct {
        ID          int        `json:"id" db:"id"`
        UserID      int        `json:"user_id" db:"user_id"`
        Name        string     `json:"name" db:"name"`
        Description *string    `json:"description,omitempty" db:"description"`
        Color       *string    `json:"color,omitempty" db:"color"`
        Icon        *string    `json:"icon,omitempty" db:"icon"`
        IsPublic    bool       `json:"is_public" db:"is_public"`
        CreatedAt   time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt   *time.Time `json:"updated_at,omitempty" db:"updated_at"`
}

// FavoriteShare represents sharing of favorites between users
type FavoriteShare struct {
        ID           int              `json:"id" db:"id"`
        FavoriteID   int              `json:"favorite_id" db:"favorite_id"`
        SharedByUser int              `json:"shared_by_user" db:"shared_by_user"`
        SharedWith   []int            `json:"shared_with" db:"shared_with"`
        Permissions  SharePermissions `json:"permissions" db:"permissions"`
        CreatedAt    time.Time        `json:"created_at" db:"created_at"`
        IsActive     bool             `json:"is_active" db:"is_active"`
}

// SharePermissions represents permissions for shared favorites
type SharePermissions struct {
        CanView   bool `json:"can_view"`
        CanEdit   bool `json:"can_edit"`
        CanDelete bool `json:"can_delete"`
        CanShare  bool `json:"can_share"`
}

// FavoriteStatistics represents statistics about user's favorites
type FavoriteStatistics struct {
        UserID                int            `json:"user_id"`
        TotalFavorites        int            `json:"total_favorites"`
        FavoritesByEntityType map[string]int `json:"favorites_by_entity_type"`
        FavoritesByCategory   map[string]int `json:"favorites_by_category"`
        RecentFavorites       []Favorite     `json:"recent_favorites"`
}

// RecommendedFavorite represents a recommended favorite item
type RecommendedFavorite struct {
        Favorite        Favorite  `json:"favorite"`
        RecommendReason string    `json:"recommend_reason"`
        RecommendScore  float64   `json:"recommend_score"`
        RecommendedAt   time.Time `json:"recommended_at"`
}

// Request/Response Models

// UpdateFavoriteRequest represents a request to update a favorite
type UpdateFavoriteRequest struct {
        Category *string   `json:"category,omitempty"`
        Notes    *string   `json:"notes,omitempty"`
        Tags     *[]string `json:"tags,omitempty"`
        IsPublic *bool     `json:"is_public,omitempty"`
}

// UpdateFavoriteCategoryRequest represents a request to update a favorite category
type UpdateFavoriteCategoryRequest struct {
        Name        string  `json:"name,omitempty"`
        Description *string `json:"description,omitempty"`
        Color       *string `json:"color,omitempty"`
        Icon        *string `json:"icon,omitempty"`
        IsPublic    *bool   `json:"is_public,omitempty"`
}

// BulkFavoriteRequest represents a request to add multiple favorites
type BulkFavoriteRequest struct {
        EntityType string    `json:"entity_type"`
        EntityID   int       `json:"entity_id"`
        Category   *string   `json:"category,omitempty"`
        Notes      *string   `json:"notes,omitempty"`
        Tags       *[]string `json:"tags,omitempty"`
        IsPublic   bool      `json:"is_public"`
}

// BulkFavoriteRemoveRequest represents a request to remove multiple favorites
type BulkFavoriteRemoveRequest struct {
        EntityType string `json:"entity_type"`
        EntityID   int    `json:"entity_id"`
}

// Reporting Models

// GeneratedReport represents a generated report
type GeneratedReport struct {
        Type        string                 `json:"type"`
        Format      string                 `json:"format"`
        Content     []byte                 `json:"content"`
        GeneratedAt time.Time              `json:"generated_at"`
        Parameters  map[string]interface{} `json:"parameters"`
}

// UserAnalyticsReport represents a user analytics report
type UserAnalyticsReport struct {
        User               *User                  `json:"user"`
        StartDate          time.Time              `json:"start_date"`
        EndDate            time.Time              `json:"end_date"`
        TotalMediaAccesses int                    `json:"total_media_accesses"`
        TotalEvents        int                    `json:"total_events"`
        MediaAccessLogs    []MediaAccessLog       `json:"media_access_logs"`
        Events             []AnalyticsEvent       `json:"events"`
        AccessPatterns     map[string]interface{} `json:"access_patterns"`
        DeviceUsage        map[string]int         `json:"device_usage"`
        LocationAnalysis   map[string]int         `json:"location_analysis"`
        TimePatterns       map[string]interface{} `json:"time_patterns"`
        PopularContent     []MediaAccessCount     `json:"popular_content"`
}

// SystemOverviewReport represents a system overview report
type SystemOverviewReport struct {
        StartDate          time.Time          `json:"start_date"`
        EndDate            time.Time          `json:"end_date"`
        TotalUsers         int                `json:"total_users"`
        ActiveUsers        int                `json:"active_users"`
        TotalMediaAccesses int                `json:"total_media_accesses"`
        TotalEvents        int                `json:"total_events"`
        TopAccessedMedia   []MediaAccessCount `json:"top_accessed_media"`
        UserGrowthData     []UserGrowthPoint  `json:"user_growth_data"`
        SystemHealth       SystemHealth       `json:"system_health"`
        UsageStatistics    UsageStatistics    `json:"usage_statistics"`
        PerformanceMetrics PerformanceMetrics `json:"performance_metrics"`
}

// MediaAnalyticsReport represents a media analytics report
type MediaAnalyticsReport struct {
        MediaID        int                    `json:"media_id"`
        StartDate      time.Time              `json:"start_date"`
        EndDate        time.Time              `json:"end_date"`
        TotalAccesses  int                    `json:"total_accesses"`
        UniqueUsers    int                    `json:"unique_users"`
        AccessLogs     []MediaAccessLog       `json:"access_logs"`
        AccessPatterns map[string]interface{} `json:"access_patterns"`
        UserEngagement UserEngagement         `json:"user_engagement"`
        GeographicData map[string]int         `json:"geographic_data"`
        DeviceAnalysis map[string]int         `json:"device_analysis"`
        TimeAnalysis   map[string]int         `json:"time_analysis"`
}

// UserActivityReport represents a user activity report
type UserActivityReport struct {
        StartDate      time.Time             `json:"start_date"`
        EndDate        time.Time             `json:"end_date"`
        UserActivities []UserActivitySummary `json:"user_activities"`
        TotalUsers     int                   `json:"total_users"`
        TotalAccesses  int                   `json:"total_accesses"`
        Summary        ActivitySummary       `json:"summary"`
}

// SecurityAuditReport represents a security audit report
type SecurityAuditReport struct {
        StartDate           time.Time          `json:"start_date"`
        EndDate             time.Time          `json:"end_date"`
        FailedLoginAttempts int                `json:"failed_login_attempts"`
        SuccessfulLogins    int                `json:"successful_logins"`
        SuspiciousActivity  []SecurityIncident `json:"suspicious_activity"`
        SecurityMetrics     SecurityMetrics    `json:"security_metrics"`
}

// PerformanceMetricsReport represents a performance metrics report
type PerformanceMetricsReport struct {
        StartDate              time.Time     `json:"start_date"`
        EndDate                time.Time     `json:"end_date"`
        AverageSessionDuration time.Duration `json:"average_session_duration"`
        TotalSessions          int           `json:"total_sessions"`
        ResponseTimes          ResponseTimes `json:"response_times"`
        SystemLoad             SystemLoad    `json:"system_load"`
        ErrorRates             ErrorRates    `json:"error_rates"`
}

// Supporting Types for Reports

type SystemHealthScore struct {
        Score  float64 `json:"score"`
        Status string  `json:"status"`
}

type UsageStatistics struct {
        PeakHours    []int   `json:"peak_hours"`
        AverageDaily int     `json:"average_daily"`
        GrowthRate   float64 `json:"growth_rate"`
}

type PerformanceMetrics struct {
        ResponseTime float64 `json:"response_time"`
        Throughput   int     `json:"throughput"`
        ErrorRate    float64 `json:"error_rate"`
}

type UserEngagement struct {
        AverageSessionTime float64 `json:"average_session_time"`
        ReturnRate         float64 `json:"return_rate"`
        InteractionDepth   float64 `json:"interaction_depth"`
}

type UserActivitySummary struct {
        User              *User     `json:"user"`
        TotalAccesses     int       `json:"total_accesses"`
        LastActivity      time.Time `json:"last_activity"`
        MostActiveHour    int       `json:"most_active_hour"`
        PreferredDevices  []string  `json:"preferred_devices"`
        AccessedLocations []string  `json:"accessed_locations"`
}

type ActivitySummary struct {
        TotalUsers       int     `json:"total_users"`
        TotalAccesses    int     `json:"total_accesses"`
        AverageAccesses  float64 `json:"average_accesses"`
        MostActiveUsers  int     `json:"most_active_users"`
        LeastActiveUsers int     `json:"least_active_users"`
}

type SecurityIncident struct {
        Type        string    `json:"type"`
        Description string    `json:"description"`
        Severity    string    `json:"severity"`
        UserID      *int      `json:"user_id,omitempty"`
        IPAddress   *string   `json:"ip_address,omitempty"`
        Timestamp   time.Time `json:"timestamp"`
}

type SecurityMetrics struct {
        ThreatLevel        string  `json:"threat_level"`
        VulnerabilityCount int     `json:"vulnerability_count"`
        SecurityScore      float64 `json:"security_score"`
}

type ResponseTimes struct {
        Average float64 `json:"average"`
        Min     float64 `json:"min"`
        Max     float64 `json:"max"`
        P95     float64 `json:"p95"`
        P99     float64 `json:"p99"`
}

type SystemLoad struct {
        CPU     float64 `json:"cpu"`
        Memory  float64 `json:"memory"`
        Disk    float64 `json:"disk"`
        Network float64 `json:"network"`
}

type ErrorRates struct {
        HTTP4xx  float64 `json:"http_4xx"`
        HTTP5xx  float64 `json:"http_5xx"`
        Timeouts float64 `json:"timeouts"`
        Total    float64 `json:"total"`
}

// Conversion Models

// ConversionJob represents a media conversion job
type ConversionJob struct {
        ID             int            `json:"id" db:"id"`
        UserID         int            `json:"user_id" db:"user_id"`
        SourcePath     string         `json:"source_path" db:"source_path"`
        TargetPath     string         `json:"target_path" db:"target_path"`
        SourceFormat   string         `json:"source_format" db:"source_format"`
        TargetFormat   string         `json:"target_format" db:"target_format"`
        ConversionType string         `json:"conversion_type" db:"conversion_type"`
        Quality        string         `json:"quality" db:"quality"`
        Settings       *string        `json:"settings,omitempty" db:"settings"`
        Priority       int            `json:"priority" db:"priority"`
        Status         string         `json:"status" db:"status"`
        CreatedAt      time.Time      `json:"created_at" db:"created_at"`
        StartedAt      *time.Time     `json:"started_at,omitempty" db:"started_at"`
        CompletedAt    *time.Time     `json:"completed_at,omitempty" db:"completed_at"`
        ScheduledFor   *time.Time     `json:"scheduled_for,omitempty" db:"scheduled_for"`
        Duration       *time.Duration `json:"duration,omitempty" db:"duration"`
        ErrorMessage   *string        `json:"error_message,omitempty" db:"error_message"`
}

// ConversionRequest represents a request to create a conversion job
type ConversionRequest struct {
        SourcePath     string     `json:"source_path"`
        TargetPath     string     `json:"target_path"`
        SourceFormat   string     `json:"source_format"`
        TargetFormat   string     `json:"target_format"`
        ConversionType string     `json:"conversion_type"`
        Quality        string     `json:"quality"`
        Settings       *string    `json:"settings,omitempty"`
        Priority       int        `json:"priority"`
        ScheduledFor   *time.Time `json:"scheduled_for,omitempty"`
}

// ConversionStatistics represents conversion statistics
type ConversionStatistics struct {
        StartDate       time.Time      `json:"start_date"`
        EndDate         time.Time      `json:"end_date"`
        TotalJobs       int            `json:"total_jobs"`
        ByStatus        map[string]int `json:"by_status"`
        ByType          map[string]int `json:"by_type"`
        ByFormat        map[string]int `json:"by_format"`
        AverageDuration *time.Duration `json:"average_duration,omitempty"`
        SuccessRate     float64        `json:"success_rate"`
}

// SupportedFormats represents supported conversion formats
type SupportedFormats struct {
        Video    VideoFormats    `json:"video"`
        Audio    AudioFormats    `json:"audio"`
        Document DocumentFormats `json:"document"`
        Image    ImageFormats    `json:"image"`
}

// VideoFormats represents supported video formats
type VideoFormats struct {
        Input  []string `json:"input"`
        Output []string `json:"output"`
}

// AudioFormats represents supported audio formats
type AudioFormats struct {
        Input  []string `json:"input"`
        Output []string `json:"output"`
}

// DocumentFormats represents supported document formats
type DocumentFormats struct {
        Input  []string `json:"input"`
        Output []string `json:"output"`
}

// ImageFormats represents supported image formats
type ImageFormats struct {
        Input  []string `json:"input"`
        Output []string `json:"output"`
}

// FormatPopularity represents format usage statistics
type FormatPopularity struct {
        Format string `json:"format"`
        Count  int    `json:"count"`
}

// Conversion Status Constants
const (
        ConversionStatusPending   = "pending"
        ConversionStatusRunning   = "running"
        ConversionStatusCompleted = "completed"
        ConversionStatusFailed    = "failed"
        ConversionStatusCancelled = "cancelled"
)

// Conversion Type Constants
const (
        ConversionTypeVideo    = "video"
        ConversionTypeAudio    = "audio"
        ConversionTypeDocument = "document"
        ConversionTypeImage    = "image"
)

// Sync and Backup Models

// SyncEndpoint represents a sync endpoint configuration
type SyncEndpoint struct {
        ID            int        `json:"id" db:"id"`
        UserID        int        `json:"user_id" db:"user_id"`
        Name          string     `json:"name" db:"name"`
        Type          string     `json:"type" db:"type"`
        URL           string     `json:"url" db:"url"`
        Username      string     `json:"username" db:"username"`
        Password      string     `json:"-" db:"password"` // Never include in JSON
        SyncDirection string     `json:"sync_direction" db:"sync_direction"`
        LocalPath     string     `json:"local_path" db:"local_path"`
        RemotePath    string     `json:"remote_path" db:"remote_path"`
        SyncSettings  *string    `json:"sync_settings,omitempty" db:"sync_settings"`
        Status        string     `json:"status" db:"status"`
        CreatedAt     time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt     time.Time  `json:"updated_at" db:"updated_at"`
        LastSyncAt    *time.Time `json:"last_sync_at,omitempty" db:"last_sync_at"`
}

// SyncSession represents a sync session
type SyncSession struct {
        ID           int            `json:"id" db:"id"`
        EndpointID   int            `json:"endpoint_id" db:"endpoint_id"`
        UserID       int            `json:"user_id" db:"user_id"`
        Status       string         `json:"status" db:"status"`
        SyncType     string         `json:"sync_type" db:"sync_type"`
        StartedAt    time.Time      `json:"started_at" db:"started_at"`
        CompletedAt  *time.Time     `json:"completed_at,omitempty" db:"completed_at"`
        Duration     *time.Duration `json:"duration,omitempty" db:"duration"`
        TotalFiles   int            `json:"total_files" db:"total_files"`
        SyncedFiles  int            `json:"synced_files" db:"synced_files"`
        FailedFiles  int            `json:"failed_files" db:"failed_files"`
        SkippedFiles int            `json:"skipped_files" db:"skipped_files"`
        ErrorMessage *string        `json:"error_message,omitempty" db:"error_message"`
}

// SyncSchedule represents a scheduled sync
type SyncSchedule struct {
        ID         int        `json:"id" db:"id"`
        EndpointID int        `json:"endpoint_id" db:"endpoint_id"`
        UserID     int        `json:"user_id" db:"user_id"`
        Frequency  string     `json:"frequency" db:"frequency"`
        LastRun    *time.Time `json:"last_run,omitempty" db:"last_run"`
        NextRun    *time.Time `json:"next_run,omitempty" db:"next_run"`
        IsActive   bool       `json:"is_active" db:"is_active"`
        CreatedAt  time.Time  `json:"created_at" db:"created_at"`
}

// SyncStatistics represents sync statistics
type SyncStatistics struct {
        StartDate        time.Time      `json:"start_date"`
        EndDate          time.Time      `json:"end_date"`
        TotalSessions    int            `json:"total_sessions"`
        TotalFilesSynced int            `json:"total_files_synced"`
        TotalFilesFailed int            `json:"total_files_failed"`
        ByStatus         map[string]int `json:"by_status"`
        ByType           map[string]int `json:"by_type"`
        AverageDuration  *time.Duration `json:"average_duration,omitempty"`
        SuccessRate      float64        `json:"success_rate"`
}

// UpdateSyncEndpointRequest represents a request to update a sync endpoint
type UpdateSyncEndpointRequest struct {
        Name          string  `json:"name,omitempty"`
        URL           string  `json:"url,omitempty"`
        Username      string  `json:"username,omitempty"`
        Password      string  `json:"password,omitempty"`
        SyncDirection string  `json:"sync_direction,omitempty"`
        LocalPath     string  `json:"local_path,omitempty"`
        RemotePath    string  `json:"remote_path,omitempty"`
        SyncSettings  *string `json:"sync_settings,omitempty"`
        IsActive      *bool   `json:"is_active,omitempty"`
}

// Sync Status Constants
const (
        SyncStatusActive   = "active"
        SyncStatusInactive = "inactive"
        SyncStatusError    = "error"
)

// Sync Session Status Constants
const (
        SyncSessionStatusRunning   = "running"
        SyncSessionStatusCompleted = "completed"
        SyncSessionStatusFailed    = "failed"
        SyncSessionStatusCancelled = "cancelled"
)

// Sync Type Constants
const (
        SyncTypeWebDAV       = "webdav"
        SyncTypeCloudStorage = "cloud_storage"
        SyncTypeLocal        = "local"
        SyncTypeManual       = "manual"
        SyncTypeScheduled    = "scheduled"
)

// Sync Direction Constants
const (
        SyncDirectionUpload        = "upload"
        SyncDirectionDownload      = "download"
        SyncDirectionBidirectional = "bidirectional"
)

// Sync Frequency Constants
const (
        SyncFrequencyHourly  = "hourly"
        SyncFrequencyDaily   = "daily"
        SyncFrequencyWeekly  = "weekly"
        SyncFrequencyMonthly = "monthly"
)

// Error and Crash Reporting Models

// ErrorReport represents an error report
type ErrorReport struct {
        ID          int                    `json:"id" db:"id"`
        UserID      int                    `json:"user_id" db:"user_id"`
        Level       string                 `json:"level" db:"level"`
        Message     string                 `json:"message" db:"message"`
        ErrorCode   string                 `json:"error_code" db:"error_code"`
        Component   string                 `json:"component" db:"component"`
        StackTrace  string                 `json:"stack_trace" db:"stack_trace"`
        Context     map[string]interface{} `json:"context" db:"context"`
        SystemInfo  map[string]interface{} `json:"system_info" db:"system_info"`
        UserAgent   string                 `json:"user_agent" db:"user_agent"`
        URL         string                 `json:"url" db:"url"`
        Fingerprint string                 `json:"fingerprint" db:"fingerprint"`
        Status      string                 `json:"status" db:"status"`
        ReportedAt  time.Time              `json:"reported_at" db:"reported_at"`
        ResolvedAt  *time.Time             `json:"resolved_at,omitempty" db:"resolved_at"`
}

// CrashReport represents a crash report
type CrashReport struct {
        ID          int                    `json:"id" db:"id"`
        UserID      int                    `json:"user_id" db:"user_id"`
        Signal      string                 `json:"signal" db:"signal"`
        Message     string                 `json:"message" db:"message"`
        StackTrace  string                 `json:"stack_trace" db:"stack_trace"`
        Context     map[string]interface{} `json:"context" db:"context"`
        SystemInfo  map[string]interface{} `json:"system_info" db:"system_info"`
        Fingerprint string                 `json:"fingerprint" db:"fingerprint"`
        Status      string                 `json:"status" db:"status"`
        ReportedAt  time.Time              `json:"reported_at" db:"reported_at"`
        ResolvedAt  *time.Time             `json:"resolved_at,omitempty" db:"resolved_at"`
}

// ErrorReportRequest represents a request to create an error report
type ErrorReportRequest struct {
        Level      string                 `json:"level" validate:"required"`
        Message    string                 `json:"message" validate:"required"`
        ErrorCode  string                 `json:"error_code,omitempty"`
        Component  string                 `json:"component,omitempty"`
        StackTrace string                 `json:"stack_trace,omitempty"`
        Context    map[string]interface{} `json:"context,omitempty"`
        UserAgent  string                 `json:"user_agent,omitempty"`
        URL        string                 `json:"url,omitempty"`
}

// CrashReportRequest represents a request to create a crash report
type CrashReportRequest struct {
        Signal     string                 `json:"signal" validate:"required"`
        Message    string                 `json:"message" validate:"required"`
        StackTrace string                 `json:"stack_trace,omitempty"`
        Context    map[string]interface{} `json:"context,omitempty"`
}

// ErrorReportFilters represents filters for error report queries
type ErrorReportFilters struct {
        Level     string     `json:"level,omitempty"`
        Component string     `json:"component,omitempty"`
        Status    string     `json:"status,omitempty"`
        StartDate *time.Time `json:"start_date,omitempty"`
        EndDate   *time.Time `json:"end_date,omitempty"`
        Limit     int        `json:"limit,omitempty"`
        Offset    int        `json:"offset,omitempty"`
}

// CrashReportFilters represents filters for crash report queries
type CrashReportFilters struct {
        Signal    string     `json:"signal,omitempty"`
        Status    string     `json:"status,omitempty"`
        StartDate *time.Time `json:"start_date,omitempty"`
        EndDate   *time.Time `json:"end_date,omitempty"`
        Limit     int        `json:"limit,omitempty"`
        Offset    int        `json:"offset,omitempty"`
}

// ExportFilters represents filters for report export
type ExportFilters struct {
        Format         string     `json:"format"`
        Level          string     `json:"level,omitempty"`
        Component      string     `json:"component,omitempty"`
        Signal         string     `json:"signal,omitempty"`
        StartDate      *time.Time `json:"start_date,omitempty"`
        EndDate        *time.Time `json:"end_date,omitempty"`
        Limit          int        `json:"limit,omitempty"`
        IncludeErrors  bool       `json:"include_errors"`
        IncludeCrashes bool       `json:"include_crashes"`
}

// ErrorStatistics represents error reporting statistics
type ErrorStatistics struct {
        TotalErrors       int            `json:"total_errors"`
        ErrorsByLevel     map[string]int `json:"errors_by_level"`
        ErrorsByComponent map[string]int `json:"errors_by_component"`
        RecentErrors      int            `json:"recent_errors"`
        ResolvedErrors    int            `json:"resolved_errors"`
        AvgResolutionTime float64        `json:"avg_resolution_time"`
}

// CrashStatistics represents crash reporting statistics
type CrashStatistics struct {
        TotalCrashes      int            `json:"total_crashes"`
        CrashesBySignal   map[string]int `json:"crashes_by_signal"`
        RecentCrashes     int            `json:"recent_crashes"`
        ResolvedCrashes   int            `json:"resolved_crashes"`
        AvgResolutionTime float64        `json:"avg_resolution_time"`
        CrashRate         float64        `json:"crash_rate"`
}

// SystemHealth represents system health status
type SystemHealth struct {
        Score     float64                `json:"score"`
        Status    string                 `json:"status"`
        CheckedAt time.Time              `json:"checked_at"`
        Metrics   map[string]interface{} `json:"metrics"`
}

// TopError represents frequently occurring errors
type TopError struct {
        Fingerprint string    `json:"fingerprint"`
        Count       int       `json:"count"`
        LastSeen    time.Time `json:"last_seen"`
        FirstSeen   time.Time `json:"first_seen"`
        Message     string    `json:"message"`
        Component   string    `json:"component"`
        Level       string    `json:"level"`
}

// TopCrash represents frequently occurring crashes
type TopCrash struct {
        Fingerprint string    `json:"fingerprint"`
        Count       int       `json:"count"`
        LastSeen    time.Time `json:"last_seen"`
        FirstSeen   time.Time `json:"first_seen"`
        Message     string    `json:"message"`
        Signal      string    `json:"signal"`
}

// CrashTrend represents crash trends over time
type CrashTrend struct {
        Date  time.Time `json:"date"`
        Count int       `json:"count"`
}

// Error Status Constants
const (
        ErrorStatusNew        = "new"
        ErrorStatusInProgress = "in_progress"
        ErrorStatusResolved   = "resolved"
        ErrorStatusIgnored    = "ignored"
)

// Crash Status Constants
const (
        CrashStatusNew        = "new"
        CrashStatusInProgress = "in_progress"
        CrashStatusResolved   = "resolved"
        CrashStatusIgnored    = "ignored"
)

// Error Level Constants
const (
        ErrorLevelDebug   = "debug"
        ErrorLevelInfo    = "info"
        ErrorLevelWarning = "warning"
        ErrorLevelError   = "error"
        ErrorLevelFatal   = "fatal"
)

// Signal Constants
const (
        SignalSIGABRT = "SIGABRT"
        SignalSIGFPE  = "SIGFPE"
        SignalSIGILL  = "SIGILL"
        SignalSIGINT  = "SIGINT"
        SignalSIGSEGV = "SIGSEGV"
        SignalSIGTERM = "SIGTERM"
)

// Log Management Models

// LogCollection represents a collection of logs
type LogCollection struct {
        ID          int                    `json:"id" db:"id"`
        UserID      int                    `json:"user_id" db:"user_id"`
        Name        string                 `json:"name" db:"name"`
        Description string                 `json:"description" db:"description"`
        Components  []string               `json:"components" db:"components"`
        LogLevel    string                 `json:"log_level" db:"log_level"`
        StartTime   *time.Time             `json:"start_time,omitempty" db:"start_time"`
        EndTime     *time.Time             `json:"end_time,omitempty" db:"end_time"`
        CreatedAt   time.Time              `json:"created_at" db:"created_at"`
        CompletedAt *time.Time             `json:"completed_at,omitempty" db:"completed_at"`
        Status      string                 `json:"status" db:"status"`
        EntryCount  int                    `json:"entry_count" db:"entry_count"`
        Filters     map[string]interface{} `json:"filters,omitempty" db:"filters"`
}

// LogEntry represents a single log entry
type LogEntry struct {
        ID           int                    `json:"id" db:"id"`
        CollectionID int                    `json:"collection_id" db:"collection_id"`
        Timestamp    time.Time              `json:"timestamp" db:"timestamp"`
        Level        string                 `json:"level" db:"level"`
        Component    string                 `json:"component" db:"component"`
        Message      string                 `json:"message" db:"message"`
        Context      map[string]interface{} `json:"context,omitempty" db:"context"`
}

// LogShare represents a shared log collection
type LogShare struct {
        ID           int        `json:"id" db:"id"`
        CollectionID int        `json:"collection_id" db:"collection_id"`
        UserID       int        `json:"user_id" db:"user_id"`
        ShareToken   string     `json:"share_token" db:"share_token"`
        ShareType    string     `json:"share_type" db:"share_type"`
        ExpiresAt    time.Time  `json:"expires_at" db:"expires_at"`
        CreatedAt    time.Time  `json:"created_at" db:"created_at"`
        AccessedAt   *time.Time `json:"accessed_at,omitempty" db:"accessed_at"`
        IsActive     bool       `json:"is_active" db:"is_active"`
        Permissions  []string   `json:"permissions" db:"permissions"`
        Recipients   []string   `json:"recipients,omitempty" db:"recipients"`
}

// LogCollectionRequest represents a request to create a log collection
type LogCollectionRequest struct {
        Name        string                 `json:"name" validate:"required"`
        Description string                 `json:"description,omitempty"`
        Components  []string               `json:"components" validate:"required"`
        LogLevel    string                 `json:"log_level,omitempty"`
        StartTime   *time.Time             `json:"start_time,omitempty"`
        EndTime     *time.Time             `json:"end_time,omitempty"`
        Filters     map[string]interface{} `json:"filters,omitempty"`
}

// LogShareRequest represents a request to create a log share
type LogShareRequest struct {
        CollectionID int        `json:"collection_id" validate:"required"`
        ShareType    string     `json:"share_type" validate:"required"`
        ExpiresAt    *time.Time `json:"expires_at,omitempty"`
        Permissions  []string   `json:"permissions" validate:"required"`
        Recipients   []string   `json:"recipients,omitempty"`
}

// LogEntryFilters represents filters for log entry queries
type LogEntryFilters struct {
        Level     string     `json:"level,omitempty"`
        Component string     `json:"component,omitempty"`
        Search    string     `json:"search,omitempty"`
        StartTime *time.Time `json:"start_time,omitempty"`
        EndTime   *time.Time `json:"end_time,omitempty"`
        Limit     int        `json:"limit,omitempty"`
        Offset    int        `json:"offset,omitempty"`
}

// LogStreamFilters represents filters for log streaming
type LogStreamFilters struct {
        Level     string `json:"level,omitempty"`
        Component string `json:"component,omitempty"`
        Search    string `json:"search,omitempty"`
}

// LogAnalysis represents log analysis results
type LogAnalysis struct {
        CollectionID       int            `json:"collection_id"`
        TotalEntries       int            `json:"total_entries"`
        EntriesByLevel     map[string]int `json:"entries_by_level"`
        EntriesByComponent map[string]int `json:"entries_by_component"`
        ErrorPatterns      map[string]int `json:"error_patterns"`
        TimeRange          *TimeRange     `json:"time_range"`
        Insights           []string       `json:"insights"`
}

// TimeRange represents a time range
type TimeRange struct {
        Start time.Time `json:"start"`
        End   time.Time `json:"end"`
}

// LogStatistics represents log management statistics
type LogStatistics struct {
        TotalCollections    int            `json:"total_collections"`
        TotalEntries        int            `json:"total_entries"`
        ActiveShares        int            `json:"active_shares"`
        CollectionsByStatus map[string]int `json:"collections_by_status"`
        RecentCollections   int            `json:"recent_collections"`
}

// Log Collection Status Constants
const (
        LogCollectionStatusPending    = "pending"
        LogCollectionStatusInProgress = "in_progress"
        LogCollectionStatusCompleted  = "completed"
        LogCollectionStatusFailed     = "failed"
)

// Log Share Type Constants
const (
        LogShareTypePublic   = "public"
        LogShareTypePrivate  = "private"
        LogShareTypeInternal = "internal"
)

// Log Level Constants
const (
        LogLevelDebug   = "debug"
        LogLevelInfo    = "info"
        LogLevelWarning = "warning"
        LogLevelError   = "error"
        LogLevelFatal   = "fatal"
)

// Configuration and Installer Models

// SystemConfiguration represents the complete system configuration
type SystemConfiguration struct {
        Version          string                  `json:"version" db:"version"`
        CreatedAt        time.Time               `json:"created_at" db:"created_at"`
        UpdatedAt        time.Time               `json:"updated_at" db:"updated_at"`
        Database         *DatabaseConfig         `json:"database,omitempty"`
        Storage          *StorageConfig          `json:"storage,omitempty"`
        Network          *NetworkConfig          `json:"network,omitempty"`
        Authentication   *AuthenticationConfig   `json:"authentication,omitempty"`
        Features         *FeatureConfig          `json:"features,omitempty"`
        ExternalServices *ExternalServicesConfig `json:"external_services,omitempty"`
}

// DatabaseConfig represents database configuration
type DatabaseConfig struct {
        Type     string `json:"type"`
        Host     string `json:"host,omitempty"`
        Port     int    `json:"port,omitempty"`
        Name     string `json:"name"`
        Username string `json:"username,omitempty"`
        Password string `json:"password,omitempty"`
}

// StorageConfig represents storage configuration
type StorageConfig struct {
        MediaDirectory     string `json:"media_directory"`
        ThumbnailDirectory string `json:"thumbnail_directory"`
        TempDirectory      string `json:"temp_directory"`
        MaxFileSize        int64  `json:"max_file_size"`
        StorageQuota       int64  `json:"storage_quota,omitempty"`
}

// NetworkConfig represents network configuration
type NetworkConfig struct {
        Host  string       `json:"host"`
        Port  int          `json:"port"`
        HTTPS *HTTPSConfig `json:"https,omitempty"`
        CORS  *CORSConfig  `json:"cors,omitempty"`
}

// HTTPSConfig represents HTTPS configuration
type HTTPSConfig struct {
        Enabled  bool   `json:"enabled"`
        CertPath string `json:"cert_path,omitempty"`
        KeyPath  string `json:"key_path,omitempty"`
}

// CORSConfig represents CORS configuration
type CORSConfig struct {
        AllowedOrigins []string `json:"allowed_origins"`
        AllowedMethods []string `json:"allowed_methods,omitempty"`
        AllowedHeaders []string `json:"allowed_headers,omitempty"`
}

// AuthenticationConfig represents authentication configuration
type AuthenticationConfig struct {
        JWTSecret                string        `json:"jwt_secret"`
        SessionTimeout           time.Duration `json:"session_timeout"`
        EnableRegistration       bool          `json:"enable_registration"`
        RequireEmailVerification bool          `json:"require_email_verification"`
        AdminEmail               string        `json:"admin_email,omitempty"`
}

// FeatureConfig represents feature toggles
type FeatureConfig struct {
        MediaConversion bool `json:"media_conversion"`
        WebDAVSync      bool `json:"webdav_sync"`
        StressTesting   bool `json:"stress_testing"`
        ErrorReporting  bool `json:"error_reporting"`
        LogManagement   bool `json:"log_management"`
}

// ExternalServicesConfig represents external service configurations
type ExternalServicesConfig struct {
        SMTP      *SMTPConfig  `json:"smtp,omitempty"`
        Slack     *SlackConfig `json:"slack,omitempty"`
        Analytics bool         `json:"analytics"`
}

// SMTPConfig represents SMTP configuration
type SMTPConfig struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Username string `json:"username"`
        Password string `json:"password"`
}

// SlackConfig represents Slack integration configuration
type SlackConfig struct {
        WebhookURL string `json:"webhook_url"`
}

// WizardStep represents a setup wizard step
type WizardStep struct {
        ID           string                 `json:"id"`
        Name         string                 `json:"name"`
        Description  string                 `json:"description"`
        Type         string                 `json:"type"`
        Required     bool                   `json:"required"`
        Order        int                    `json:"order"`
        Fields       []*WizardField         `json:"fields,omitempty"`
        Content      map[string]interface{} `json:"content,omitempty"`
        Validation   map[string]interface{} `json:"validation,omitempty"`
        Dependencies []string               `json:"dependencies,omitempty"`
}

// WizardField represents a field in a wizard step
type WizardField struct {
        Name         string                 `json:"name"`
        Label        string                 `json:"label"`
        Type         string                 `json:"type"`
        Required     bool                   `json:"required"`
        DefaultValue interface{}            `json:"default_value,omitempty"`
        Options      []string               `json:"options,omitempty"`
        Validation   map[string]interface{} `json:"validation,omitempty"`
        ShowWhen     map[string]interface{} `json:"show_when,omitempty"`
        Generate     bool                   `json:"generate,omitempty"`
}

// WizardProgress represents wizard completion progress
type WizardProgress struct {
        UserID      int                    `json:"user_id" db:"user_id"`
        CurrentStep string                 `json:"current_step" db:"current_step"`
        StepData    map[string]interface{} `json:"step_data" db:"step_data"`
        AllData     map[string]interface{} `json:"all_data" db:"all_data"`
        UpdatedAt   time.Time              `json:"updated_at" db:"updated_at"`
}

// WizardStepValidation represents validation results for a wizard step
type WizardStepValidation struct {
        StepID   string            `json:"step_id"`
        Valid    bool              `json:"valid"`
        Errors   map[string]string `json:"errors"`
        Warnings map[string]string `json:"warnings"`
}

// ConfigurationSchema represents the configuration schema
type ConfigurationSchema struct {
        Version  string           `json:"version"`
        Sections []*ConfigSection `json:"sections"`
}

// ConfigSection represents a configuration section
type ConfigSection struct {
        Name        string         `json:"name"`
        Key         string         `json:"key"`
        Description string         `json:"description"`
        Fields      []*ConfigField `json:"fields"`
}

// ConfigField represents a configuration field
type ConfigField struct {
        Name         string      `json:"name"`
        Label        string      `json:"label"`
        Type         string      `json:"type"`
        Required     bool        `json:"required"`
        DefaultValue interface{} `json:"default_value,omitempty"`
        Description  string      `json:"description,omitempty"`
}

// ConfigurationTest represents configuration test results
type ConfigurationTest struct {
        TestedAt      time.Time              `json:"tested_at"`
        OverallStatus string                 `json:"overall_status"`
        Results       map[string]*TestResult `json:"results"`
}

// TestResult represents a single test result
type TestResult struct {
        Status  string `json:"status"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
}

// ConfigurationHistory represents configuration history
type ConfigurationHistory struct {
        ID        int       `json:"id" db:"id"`
        Version   string    `json:"version" db:"version"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
        UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

// ConfigurationBackup represents a configuration backup
type ConfigurationBackup struct {
        ID            int                  `json:"id" db:"id"`
        Name          string               `json:"name" db:"name"`
        Version       string               `json:"version" db:"version"`
        Configuration *SystemConfiguration `json:"configuration,omitempty" db:"configuration"`
        CreatedAt     time.Time            `json:"created_at" db:"created_at"`
}

// ConfigurationTemplate represents a configuration template
type ConfigurationTemplate struct {
        ID            int                  `json:"id" db:"id"`
        Name          string               `json:"name" db:"name"`
        Description   string               `json:"description" db:"description"`
        Category      string               `json:"category" db:"category"`
        Configuration *SystemConfiguration `json:"configuration" db:"configuration"`
        CreatedAt     time.Time            `json:"created_at" db:"created_at"`
}

// ConfigurationStatistics represents configuration statistics
type ConfigurationStatistics struct {
        TotalConfigurations int       `json:"total_configurations"`
        TotalBackups        int       `json:"total_backups"`
        TotalTemplates      int       `json:"total_templates"`
        WizardCompletions   int       `json:"wizard_completions"`
        LastUpdate          time.Time `json:"last_update"`
}

// Wizard Step Type Constants
const (
        WizardStepTypeInfo     = "info"
        WizardStepTypeForm     = "form"
        WizardStepTypeSummary  = "summary"
        WizardStepTypeComplete = "complete"
)

// Field Type Constants
const (
        FieldTypeText      = "text"
        FieldTypePassword  = "password"
        FieldTypeEmail     = "email"
        FieldTypeNumber    = "number"
        FieldTypeCheckbox  = "checkbox"
        FieldTypeSelect    = "select"
        FieldTypeTextarea  = "textarea"
        FieldTypeFile      = "file"
        FieldTypeDirectory = "directory"
)

// Test Status Constants
const (
        TestStatusPassed  = "passed"
        TestStatusFailed  = "failed"
        TestStatusWarning = "warning"
)

// Configuration Category Constants
const (
        ConfigCategoryEnvironment = "Environment"
        ConfigCategoryPerformance = "Performance"
        ConfigCategorySecurity    = "Security"
        ConfigCategoryDevelopment = "Development"
)

// Common Error Variables
var (
        ErrUnauthorized = errors.New("unauthorized")
        ErrForbidden    = errors.New("forbidden")
        ErrNotFound     = errors.New("not found")
        ErrConflict     = errors.New("conflict")
)
</pre>
		
		<pre class="file" id="file81" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
)

type AnalyticsRepository struct {
        db *sql.DB
}

func NewAnalyticsRepository(db *sql.DB) *AnalyticsRepository <span class="cov0" title="0">{
        return &amp;AnalyticsRepository{db: db}
}</span>

func (r *AnalyticsRepository) LogMediaAccess(access *models.MediaAccessLog) error <span class="cov0" title="0">{
        query := `
                INSERT INTO media_access_logs (user_id, media_id, action, device_info, location,
                                                                          ip_address, user_agent, playback_duration, access_time)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        var deviceInfoJSON, locationJSON *string

        if access.DeviceInfo != nil </span><span class="cov0" title="0">{
                data, err := json.Marshal(access.DeviceInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal device info: %w", err)
                }</span>
                <span class="cov0" title="0">deviceInfoStr := string(data)
                deviceInfoJSON = &amp;deviceInfoStr</span>
        }

        <span class="cov0" title="0">if access.Location != nil </span><span class="cov0" title="0">{
                data, err := json.Marshal(access.Location)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal location: %w", err)
                }</span>
                <span class="cov0" title="0">locationStr := string(data)
                locationJSON = &amp;locationStr</span>
        }

        <span class="cov0" title="0">var playbackDurationSeconds *int64
        if access.PlaybackDuration != nil </span><span class="cov0" title="0">{
                seconds := int64(access.PlaybackDuration.Seconds())
                playbackDurationSeconds = &amp;seconds
        }</span>

        <span class="cov0" title="0">_, err := r.db.Exec(query,
                access.UserID, access.MediaID, access.Action, deviceInfoJSON, locationJSON,
                access.IPAddress, access.UserAgent, playbackDurationSeconds, access.AccessTime)

        return err</span>
}

func (r *AnalyticsRepository) LogEvent(event *models.AnalyticsEvent) error <span class="cov0" title="0">{
        query := `
                INSERT INTO analytics_events (user_id, event_type, event_category, data,
                                                                         device_info, location, ip_address, user_agent, timestamp)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        var deviceInfoJSON, locationJSON *string

        if event.DeviceInfo != nil </span><span class="cov0" title="0">{
                data, err := json.Marshal(event.DeviceInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal device info: %w", err)
                }</span>
                <span class="cov0" title="0">deviceInfoStr := string(data)
                deviceInfoJSON = &amp;deviceInfoStr</span>
        }

        <span class="cov0" title="0">if event.Location != nil </span><span class="cov0" title="0">{
                data, err := json.Marshal(event.Location)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal location: %w", err)
                }</span>
                <span class="cov0" title="0">locationStr := string(data)
                locationJSON = &amp;locationStr</span>
        }

        <span class="cov0" title="0">_, err := r.db.Exec(query,
                event.UserID, event.EventType, event.EventCategory, event.Data,
                deviceInfoJSON, locationJSON, event.IPAddress, event.UserAgent, event.Timestamp)

        return err</span>
}

func (r *AnalyticsRepository) GetMediaAccessLogs(userID int, mediaID *int, limit, offset int) ([]models.MediaAccessLog, error) <span class="cov0" title="0">{
        var query string
        var args []interface{}

        if mediaID != nil </span><span class="cov0" title="0">{
                if userID &gt; 0 </span><span class="cov0" title="0">{
                        query = `
                                SELECT id, user_id, media_id, action, device_info, location, ip_address,
                                           user_agent, playback_duration, access_time
                                FROM media_access_logs
                                WHERE user_id = ? AND media_id = ?
                                ORDER BY access_time DESC
                                LIMIT ? OFFSET ?
                        `
                        args = []interface{}{userID, *mediaID, limit, offset}
                }</span> else<span class="cov0" title="0"> {
                        query = `
                                SELECT id, user_id, media_id, action, device_info, location, ip_address,
                                           user_agent, playback_duration, access_time
                                FROM media_access_logs
                                WHERE media_id = ?
                                ORDER BY access_time DESC
                                LIMIT ? OFFSET ?
                        `
                        args = []interface{}{*mediaID, limit, offset}
                }</span>
        } else<span class="cov0" title="0"> if userID &gt; 0 </span><span class="cov0" title="0">{
                query = `
                        SELECT id, user_id, media_id, action, device_info, location, ip_address,
                                   user_agent, playback_duration, access_time
                        FROM media_access_logs
                        WHERE user_id = ?
                        ORDER BY access_time DESC
                        LIMIT ? OFFSET ?
                `
                args = []interface{}{userID, limit, offset}
        }</span> else<span class="cov0" title="0"> {
                query = `
                        SELECT id, user_id, media_id, action, device_info, location, ip_address,
                                   user_agent, playback_duration, access_time
                        FROM media_access_logs
                        ORDER BY access_time DESC
                        LIMIT ? OFFSET ?
                `
                args = []interface{}{limit, offset}
        }</span>

        <span class="cov0" title="0">rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get media access logs: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var logs []models.MediaAccessLog
        for rows.Next() </span><span class="cov0" title="0">{
                var log models.MediaAccessLog
                var deviceInfoJSON, locationJSON sql.NullString
                var playbackDurationSeconds sql.NullInt64

                err := rows.Scan(
                        &amp;log.ID, &amp;log.UserID, &amp;log.MediaID, &amp;log.Action, &amp;deviceInfoJSON,
                        &amp;locationJSON, &amp;log.IPAddress, &amp;log.UserAgent, &amp;playbackDurationSeconds,
                        &amp;log.AccessTime)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan media access log: %w", err)
                }</span>

                <span class="cov0" title="0">if deviceInfoJSON.Valid </span><span class="cov0" title="0">{
                        var deviceInfo models.DeviceInfo
                        if err := json.Unmarshal([]byte(deviceInfoJSON.String), &amp;deviceInfo); err == nil </span><span class="cov0" title="0">{
                                log.DeviceInfo = &amp;deviceInfo
                        }</span>
                }

                <span class="cov0" title="0">if locationJSON.Valid </span><span class="cov0" title="0">{
                        var location models.Location
                        if err := json.Unmarshal([]byte(locationJSON.String), &amp;location); err == nil </span><span class="cov0" title="0">{
                                log.Location = &amp;location
                        }</span>
                }

                <span class="cov0" title="0">if playbackDurationSeconds.Valid </span><span class="cov0" title="0">{
                        duration := time.Duration(playbackDurationSeconds.Int64) * time.Second
                        log.PlaybackDuration = &amp;duration
                }</span>

                <span class="cov0" title="0">logs = append(logs, log)</span>
        }

        <span class="cov0" title="0">return logs, nil</span>
}

func (r *AnalyticsRepository) GetUserMediaAccessLogs(userID int, startDate, endDate time.Time) ([]models.MediaAccessLog, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, media_id, action, device_info, location, ip_address,
                           user_agent, playback_duration, access_time
                FROM media_access_logs
                WHERE user_id = ? AND access_time BETWEEN ? AND ?
                ORDER BY access_time DESC
        `

        rows, err := r.db.Query(query, userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user media access logs: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanMediaAccessLogs(rows)</span>
}

func (r *AnalyticsRepository) GetUserEvents(userID int, startDate, endDate time.Time) ([]models.AnalyticsEvent, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, event_type, event_category, data, device_info, location,
                           ip_address, user_agent, timestamp
                FROM analytics_events
                WHERE user_id = ? AND timestamp BETWEEN ? AND ?
                ORDER BY timestamp DESC
        `

        rows, err := r.db.Query(query, userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user events: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanAnalyticsEvents(rows)</span>
}

func (r *AnalyticsRepository) GetTotalUsers() (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM users`
        var count int
        err := r.db.QueryRow(query).Scan(&amp;count)
        return count, err
}</span>

func (r *AnalyticsRepository) GetActiveUsers(startDate, endDate time.Time) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(DISTINCT user_id)
                FROM media_access_logs
                WHERE access_time BETWEEN ? AND ?
        `
        var count int
        err := r.db.QueryRow(query, startDate, endDate).Scan(&amp;count)
        return count, err
}</span>

func (r *AnalyticsRepository) GetTotalMediaAccesses(startDate, endDate time.Time) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*)
                FROM media_access_logs
                WHERE access_time BETWEEN ? AND ?
        `
        var count int
        err := r.db.QueryRow(query, startDate, endDate).Scan(&amp;count)
        return count, err
}</span>

func (r *AnalyticsRepository) GetTotalEvents(startDate, endDate time.Time) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*)
                FROM analytics_events
                WHERE timestamp BETWEEN ? AND ?
        `
        var count int
        err := r.db.QueryRow(query, startDate, endDate).Scan(&amp;count)
        return count, err
}</span>

func (r *AnalyticsRepository) GetTopAccessedMedia(startDate, endDate time.Time, limit int) ([]models.MediaAccessCount, error) <span class="cov0" title="0">{
        query := `
                SELECT media_id, COUNT(*) as access_count
                FROM media_access_logs
                WHERE access_time BETWEEN ? AND ?
                GROUP BY media_id
                ORDER BY access_count DESC
                LIMIT ?
        `

        rows, err := r.db.Query(query, startDate, endDate, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top accessed media: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []models.MediaAccessCount
        for rows.Next() </span><span class="cov0" title="0">{
                var result models.MediaAccessCount
                err := rows.Scan(&amp;result.MediaID, &amp;result.AccessCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan media access count: %w", err)
                }</span>
                <span class="cov0" title="0">results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

func (r *AnalyticsRepository) GetUserGrowthData(startDate, endDate time.Time) ([]models.UserGrowthPoint, error) <span class="cov0" title="0">{
        query := `
                SELECT DATE(created_at) as date, COUNT(*) as user_count
                FROM users
                WHERE created_at BETWEEN ? AND ?
                GROUP BY DATE(created_at)
                ORDER BY date ASC
        `

        rows, err := r.db.Query(query, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user growth data: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []models.UserGrowthPoint
        for rows.Next() </span><span class="cov0" title="0">{
                var result models.UserGrowthPoint
                var dateStr string
                err := rows.Scan(&amp;dateStr, &amp;result.UserCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user growth point: %w", err)
                }</span>

                <span class="cov0" title="0">date, err := time.Parse("2006-01-02", dateStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse date: %w", err)
                }</span>
                <span class="cov0" title="0">result.Date = date

                results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

func (r *AnalyticsRepository) GetSessionData(startDate, endDate time.Time) ([]models.SessionData, error) <span class="cov0" title="0">{
        query := `
                SELECT user_id,
                           MIN(last_activity_at) as session_start,
                           MAX(last_activity_at) as session_end,
                           (julianday(MAX(last_activity_at)) - julianday(MIN(last_activity_at))) * 24 * 60 * 60 as duration_seconds
                FROM user_sessions
                WHERE created_at BETWEEN ? AND ? AND is_active = 1
                GROUP BY user_id, DATE(created_at)
                ORDER BY session_start ASC
        `

        rows, err := r.db.Query(query, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get session data: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []models.SessionData
        for rows.Next() </span><span class="cov0" title="0">{
                var result models.SessionData
                var durationSeconds float64

                err := rows.Scan(&amp;result.UserID, &amp;result.StartTime, &amp;result.EndTime, &amp;durationSeconds)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan session data: %w", err)
                }</span>

                <span class="cov0" title="0">result.Duration = time.Duration(durationSeconds) * time.Second
                results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

func (r *AnalyticsRepository) GetAllMediaAccessLogs(startDate, endDate time.Time) ([]models.MediaAccessLog, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, media_id, action, device_info, location, ip_address,
                           user_agent, playback_duration, access_time
                FROM media_access_logs
                WHERE access_time BETWEEN ? AND ?
                ORDER BY access_time DESC
        `

        rows, err := r.db.Query(query, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all media access logs: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanMediaAccessLogs(rows)</span>
}

func (r *AnalyticsRepository) GetFileTypeData(startDate, endDate time.Time) (map[string]int, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        CASE
                                WHEN LOWER(data) LIKE '%"file_type":"video%' THEN 'video'
                                WHEN LOWER(data) LIKE '%"file_type":"audio%' THEN 'audio'
                                WHEN LOWER(data) LIKE '%"file_type":"image%' THEN 'image'
                                WHEN LOWER(data) LIKE '%"file_type":"document%' THEN 'document'
                                ELSE 'other'
                        END as file_type,
                        COUNT(*) as count
                FROM analytics_events
                WHERE timestamp BETWEEN ? AND ? AND event_type = 'media_access'
                GROUP BY file_type
                ORDER BY count DESC
        `

        rows, err := r.db.Query(query, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file type data: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        fileTypes := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var fileType string
                var count int
                err := rows.Scan(&amp;fileType, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan file type data: %w", err)
                }</span>
                <span class="cov0" title="0">fileTypes[fileType] = count</span>
        }

        <span class="cov0" title="0">return fileTypes, nil</span>
}

func (r *AnalyticsRepository) GetGeographicData(startDate, endDate time.Time) (map[string]interface{}, error) <span class="cov0" title="0">{
        query := `
                SELECT location, COUNT(*) as access_count
                FROM media_access_logs
                WHERE access_time BETWEEN ? AND ? AND location IS NOT NULL
                GROUP BY location
                ORDER BY access_count DESC
                LIMIT 100
        `

        rows, err := r.db.Query(query, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get geographic data: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var locations []map[string]interface{}
        countryCount := make(map[string]int)

        for rows.Next() </span><span class="cov0" title="0">{
                var locationJSON string
                var accessCount int

                err := rows.Scan(&amp;locationJSON, &amp;accessCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan geographic data: %w", err)
                }</span>

                <span class="cov0" title="0">var location models.Location
                if err := json.Unmarshal([]byte(locationJSON), &amp;location); err == nil </span><span class="cov0" title="0">{
                        locationData := map[string]interface{}{
                                "latitude":     location.Latitude,
                                "longitude":    location.Longitude,
                                "access_count": accessCount,
                        }

                        if location.Country != nil </span><span class="cov0" title="0">{
                                locationData["country"] = *location.Country
                                countryCount[*location.Country] += accessCount
                        }</span>

                        <span class="cov0" title="0">if location.City != nil </span><span class="cov0" title="0">{
                                locationData["city"] = *location.City
                        }</span>

                        <span class="cov0" title="0">locations = append(locations, locationData)</span>
                }
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "locations": locations,
                "countries": countryCount,
        }, nil</span>
}

func (r *AnalyticsRepository) scanMediaAccessLogs(rows *sql.Rows) ([]models.MediaAccessLog, error) <span class="cov0" title="0">{
        var logs []models.MediaAccessLog

        for rows.Next() </span><span class="cov0" title="0">{
                var log models.MediaAccessLog
                var deviceInfoJSON, locationJSON sql.NullString
                var playbackDurationSeconds sql.NullInt64

                err := rows.Scan(
                        &amp;log.ID, &amp;log.UserID, &amp;log.MediaID, &amp;log.Action, &amp;deviceInfoJSON,
                        &amp;locationJSON, &amp;log.IPAddress, &amp;log.UserAgent, &amp;playbackDurationSeconds,
                        &amp;log.AccessTime)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan media access log: %w", err)
                }</span>

                <span class="cov0" title="0">if deviceInfoJSON.Valid </span><span class="cov0" title="0">{
                        var deviceInfo models.DeviceInfo
                        if err := json.Unmarshal([]byte(deviceInfoJSON.String), &amp;deviceInfo); err == nil </span><span class="cov0" title="0">{
                                log.DeviceInfo = &amp;deviceInfo
                        }</span>
                }

                <span class="cov0" title="0">if locationJSON.Valid </span><span class="cov0" title="0">{
                        var location models.Location
                        if err := json.Unmarshal([]byte(locationJSON.String), &amp;location); err == nil </span><span class="cov0" title="0">{
                                log.Location = &amp;location
                        }</span>
                }

                <span class="cov0" title="0">if playbackDurationSeconds.Valid </span><span class="cov0" title="0">{
                        duration := time.Duration(playbackDurationSeconds.Int64) * time.Second
                        log.PlaybackDuration = &amp;duration
                }</span>

                <span class="cov0" title="0">logs = append(logs, log)</span>
        }

        <span class="cov0" title="0">return logs, nil</span>
}

func (r *AnalyticsRepository) scanAnalyticsEvents(rows *sql.Rows) ([]models.AnalyticsEvent, error) <span class="cov0" title="0">{
        var events []models.AnalyticsEvent

        for rows.Next() </span><span class="cov0" title="0">{
                var event models.AnalyticsEvent
                var deviceInfoJSON, locationJSON sql.NullString

                err := rows.Scan(
                        &amp;event.ID, &amp;event.UserID, &amp;event.EventType, &amp;event.EventCategory,
                        &amp;event.Data, &amp;deviceInfoJSON, &amp;locationJSON, &amp;event.IPAddress,
                        &amp;event.UserAgent, &amp;event.Timestamp)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan analytics event: %w", err)
                }</span>

                <span class="cov0" title="0">if deviceInfoJSON.Valid </span><span class="cov0" title="0">{
                        var deviceInfo models.DeviceInfo
                        if err := json.Unmarshal([]byte(deviceInfoJSON.String), &amp;deviceInfo); err == nil </span><span class="cov0" title="0">{
                                event.DeviceInfo = &amp;deviceInfo
                        }</span>
                }

                <span class="cov0" title="0">if locationJSON.Valid </span><span class="cov0" title="0">{
                        var location models.Location
                        if err := json.Unmarshal([]byte(locationJSON.String), &amp;location); err == nil </span><span class="cov0" title="0">{
                                event.Location = &amp;location
                        }</span>
                }

                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
)

type ConfigurationRepository struct {
        db *sql.DB
}

func NewConfigurationRepository(db *sql.DB) *ConfigurationRepository <span class="cov0" title="0">{
        return &amp;ConfigurationRepository{db: db}
}</span>

func (r *ConfigurationRepository) SaveConfiguration(config *models.SystemConfiguration) error <span class="cov0" title="0">{
        configJSON, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT OR REPLACE INTO system_configuration (
                        id, version, configuration, created_at, updated_at
                ) VALUES (1, ?, ?, ?, ?)`

        _, err = r.db.Exec(query, config.Version, string(configJSON), config.CreatedAt, config.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) GetConfiguration() (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        query := `
                SELECT version, configuration, created_at, updated_at
                FROM system_configuration
                WHERE id = 1`

        var version, configJSON string
        var createdAt, updatedAt time.Time

        err := r.db.QueryRow(query).Scan(&amp;version, &amp;configJSON, &amp;createdAt, &amp;updatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get configuration: %w", err)
        }</span>

        <span class="cov0" title="0">var config models.SystemConfiguration
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">config.Version = version
        config.CreatedAt = createdAt
        config.UpdatedAt = updatedAt

        return &amp;config, nil</span>
}

func (r *ConfigurationRepository) SaveWizardProgress(progress *models.WizardProgress) error <span class="cov0" title="0">{
        stepDataJSON, err := json.Marshal(progress.StepData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal step data: %w", err)
        }</span>

        <span class="cov0" title="0">allDataJSON, err := json.Marshal(progress.AllData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal all data: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT OR REPLACE INTO wizard_progress (
                        user_id, current_step, step_data, all_data, updated_at
                ) VALUES (?, ?, ?, ?, ?)`

        _, err = r.db.Exec(query,
                progress.UserID, progress.CurrentStep, string(stepDataJSON),
                string(allDataJSON), progress.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save wizard progress: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) GetWizardProgress(userID int) (*models.WizardProgress, error) <span class="cov0" title="0">{
        query := `
                SELECT user_id, current_step, step_data, all_data, updated_at
                FROM wizard_progress
                WHERE user_id = ?`

        var progress models.WizardProgress
        var stepDataJSON, allDataJSON string

        err := r.db.QueryRow(query, userID).Scan(
                &amp;progress.UserID, &amp;progress.CurrentStep, &amp;stepDataJSON,
                &amp;allDataJSON, &amp;progress.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get wizard progress: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(stepDataJSON), &amp;progress.StepData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal step data: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(allDataJSON), &amp;progress.AllData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal all data: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;progress, nil</span>
}

func (r *ConfigurationRepository) DeleteWizardProgress(userID int) error <span class="cov0" title="0">{
        query := "DELETE FROM wizard_progress WHERE user_id = ?"
        _, err := r.db.Exec(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete wizard progress: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) MarkWizardCompleted(userID int) error <span class="cov0" title="0">{
        query := `
                INSERT OR REPLACE INTO wizard_completion (
                        user_id, completed_at
                ) VALUES (?, ?)`

        _, err := r.db.Exec(query, userID, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark wizard as completed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) IsWizardCompleted(userID int) (bool, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*)
                FROM wizard_completion
                WHERE user_id = ?`

        var count int
        err := r.db.QueryRow(query, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check wizard completion: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (r *ConfigurationRepository) GetConfigurationHistory(limit int) ([]*models.ConfigurationHistory, error) <span class="cov0" title="0">{
        query := `
                SELECT id, version, created_at, updated_at
                FROM system_configuration_history
                ORDER BY created_at DESC
                LIMIT ?`

        rows, err := r.db.Query(query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get configuration history: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var history []*models.ConfigurationHistory
        for rows.Next() </span><span class="cov0" title="0">{
                var entry models.ConfigurationHistory
                err := rows.Scan(&amp;entry.ID, &amp;entry.Version, &amp;entry.CreatedAt, &amp;entry.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan configuration history: %w", err)
                }</span>
                <span class="cov0" title="0">history = append(history, &amp;entry)</span>
        }

        <span class="cov0" title="0">return history, nil</span>
}

func (r *ConfigurationRepository) SaveConfigurationHistory(config *models.SystemConfiguration) error <span class="cov0" title="0">{
        configJSON, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO system_configuration_history (
                        version, configuration, created_at, updated_at
                ) VALUES (?, ?, ?, ?)`

        _, err = r.db.Exec(query, config.Version, string(configJSON), config.CreatedAt, config.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration history: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) CreateConfigurationBackup(name string, config *models.SystemConfiguration) error <span class="cov0" title="0">{
        configJSON, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO configuration_backups (
                        name, version, configuration, created_at
                ) VALUES (?, ?, ?, ?)`

        _, err = r.db.Exec(query, name, config.Version, string(configJSON), time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create configuration backup: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) GetConfigurationBackups() ([]*models.ConfigurationBackup, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, version, created_at
                FROM configuration_backups
                ORDER BY created_at DESC`

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get configuration backups: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var backups []*models.ConfigurationBackup
        for rows.Next() </span><span class="cov0" title="0">{
                var backup models.ConfigurationBackup
                err := rows.Scan(&amp;backup.ID, &amp;backup.Name, &amp;backup.Version, &amp;backup.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan configuration backup: %w", err)
                }</span>
                <span class="cov0" title="0">backups = append(backups, &amp;backup)</span>
        }

        <span class="cov0" title="0">return backups, nil</span>
}

func (r *ConfigurationRepository) RestoreConfigurationBackup(backupID int) (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        query := `
                SELECT configuration
                FROM configuration_backups
                WHERE id = ?`

        var configJSON string
        err := r.db.QueryRow(query, backupID).Scan(&amp;configJSON)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get configuration backup: %w", err)
        }</span>

        <span class="cov0" title="0">var config models.SystemConfiguration
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
        }</span>

        // Update timestamps
        <span class="cov0" title="0">config.UpdatedAt = time.Now()

        // Save as current configuration
        if err := r.SaveConfiguration(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to restore configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (r *ConfigurationRepository) DeleteConfigurationBackup(backupID int) error <span class="cov0" title="0">{
        query := "DELETE FROM configuration_backups WHERE id = ?"
        _, err := r.db.Exec(query, backupID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete configuration backup: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) GetConfigurationTemplates() ([]*models.ConfigurationTemplate, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, category, configuration, created_at
                FROM configuration_templates
                ORDER BY category, name`

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get configuration templates: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var templates []*models.ConfigurationTemplate
        for rows.Next() </span><span class="cov0" title="0">{
                var template models.ConfigurationTemplate
                var configJSON string

                err := rows.Scan(
                        &amp;template.ID, &amp;template.Name, &amp;template.Description,
                        &amp;template.Category, &amp;configJSON, &amp;template.CreatedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan configuration template: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(configJSON), &amp;template.Configuration); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal template configuration: %w", err)
                }</span>

                <span class="cov0" title="0">templates = append(templates, &amp;template)</span>
        }

        <span class="cov0" title="0">return templates, nil</span>
}

func (r *ConfigurationRepository) CreateConfigurationTemplate(template *models.ConfigurationTemplate) error <span class="cov0" title="0">{
        configJSON, err := json.Marshal(template.Configuration)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO configuration_templates (
                        name, description, category, configuration, created_at
                ) VALUES (?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                template.Name, template.Description, template.Category,
                string(configJSON), template.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create configuration template: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">template.ID = int(id)
        return nil</span>
}

func (r *ConfigurationRepository) DeleteConfigurationTemplate(templateID int) error <span class="cov0" title="0">{
        query := "DELETE FROM configuration_templates WHERE id = ?"
        _, err := r.db.Exec(query, templateID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete configuration template: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) ApplyConfigurationTemplate(templateID int) (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        query := `
                SELECT configuration
                FROM configuration_templates
                WHERE id = ?`

        var configJSON string
        err := r.db.QueryRow(query, templateID).Scan(&amp;configJSON)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get configuration template: %w", err)
        }</span>

        <span class="cov0" title="0">var config models.SystemConfiguration
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
        }</span>

        // Update timestamps
        <span class="cov0" title="0">config.CreatedAt = time.Now()
        config.UpdatedAt = time.Now()

        // Save as current configuration
        if err := r.SaveConfiguration(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply template: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (r *ConfigurationRepository) CleanupOldHistory(olderThan time.Time) error <span class="cov0" title="0">{
        query := "DELETE FROM system_configuration_history WHERE created_at &lt; ?"
        _, err := r.db.Exec(query, olderThan)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old configuration history: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) GetConfigurationStatistics() (*models.ConfigurationStatistics, error) <span class="cov0" title="0">{
        stats := &amp;models.ConfigurationStatistics{}

        // Total configurations in history
        err := r.db.QueryRow("SELECT COUNT(*) FROM system_configuration_history").Scan(&amp;stats.TotalConfigurations)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total configurations: %w", err)
        }</span>

        // Total backups
        <span class="cov0" title="0">err = r.db.QueryRow("SELECT COUNT(*) FROM configuration_backups").Scan(&amp;stats.TotalBackups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total backups: %w", err)
        }</span>

        // Total templates
        <span class="cov0" title="0">err = r.db.QueryRow("SELECT COUNT(*) FROM configuration_templates").Scan(&amp;stats.TotalTemplates)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total templates: %w", err)
        }</span>

        // Wizard completions
        <span class="cov0" title="0">err = r.db.QueryRow("SELECT COUNT(*) FROM wizard_completion").Scan(&amp;stats.WizardCompletions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get wizard completions: %w", err)
        }</span>

        // Last configuration update
        <span class="cov0" title="0">err = r.db.QueryRow("SELECT updated_at FROM system_configuration WHERE id = 1").Scan(&amp;stats.LastUpdate)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get last update: %w", err)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// SaveWizardSession saves a wizard session
func (r *ConfigurationRepository) SaveWizardSession(session *models.WizardSession) error <span class="cov0" title="0">{
        query := `
                INSERT OR REPLACE INTO wizard_sessions (
                        session_id, user_id, current_step, total_steps, step_data,
                        configuration, started_at, last_activity, is_completed, config_type
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        stepDataJSON, err := json.Marshal(session.StepData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal step data: %w", err)
        }</span>

        <span class="cov0" title="0">configJSON, err := json.Marshal(session.Configuration)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = r.db.Exec(query,
                session.SessionID, session.UserID, session.CurrentStep, session.TotalSteps,
                string(stepDataJSON), string(configJSON), session.StartedAt,
                session.LastActivity, session.IsCompleted, session.ConfigType)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save wizard session: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetWizardSession retrieves a wizard session by session ID
func (r *ConfigurationRepository) GetWizardSession(sessionID string) (*models.WizardSession, error) <span class="cov0" title="0">{
        query := `
                SELECT session_id, user_id, current_step, total_steps, step_data,
                           configuration, started_at, last_activity, is_completed, config_type
                FROM wizard_sessions WHERE session_id = ?`

        session := &amp;models.WizardSession{}
        var stepDataJSON, configJSON string

        err := r.db.QueryRow(query, sessionID).Scan(
                &amp;session.SessionID, &amp;session.UserID, &amp;session.CurrentStep, &amp;session.TotalSteps,
                &amp;stepDataJSON, &amp;configJSON, &amp;session.StartedAt, &amp;session.LastActivity,
                &amp;session.IsCompleted, &amp;session.ConfigType)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("wizard session not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get wizard session: %w", err)</span>
        }

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(stepDataJSON), &amp;session.StepData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal step data: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(configJSON), &amp;session.Configuration); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

// SaveConfigurationProfile saves a configuration profile
func (r *ConfigurationRepository) SaveConfigurationProfile(profile *models.ConfigurationProfile) error <span class="cov0" title="0">{
        query := `
                INSERT OR REPLACE INTO configuration_profiles (
                        profile_id, name, description, user_id, configuration,
                        created_at, updated_at, is_active, tags
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`

        configJSON, err := json.Marshal(profile.Configuration)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">tagsJSON, err := json.Marshal(profile.Tags)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal tags: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = r.db.Exec(query,
                profile.ProfileID, profile.Name, profile.Description, profile.UserID,
                string(configJSON), profile.CreatedAt, profile.UpdatedAt,
                profile.IsActive, string(tagsJSON))

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration profile: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetConfigurationProfile retrieves a configuration profile by profile ID
func (r *ConfigurationRepository) GetConfigurationProfile(profileID string) (*models.ConfigurationProfile, error) <span class="cov0" title="0">{
        query := `
                SELECT profile_id, name, description, user_id, configuration,
                           created_at, updated_at, is_active, tags
                FROM configuration_profiles WHERE profile_id = ?`

        profile := &amp;models.ConfigurationProfile{}
        var configJSON, tagsJSON string

        err := r.db.QueryRow(query, profileID).Scan(
                &amp;profile.ProfileID, &amp;profile.Name, &amp;profile.Description, &amp;profile.UserID,
                &amp;configJSON, &amp;profile.CreatedAt, &amp;profile.UpdatedAt, &amp;profile.IsActive, &amp;tagsJSON)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("configuration profile not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get configuration profile: %w", err)</span>
        }

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(configJSON), &amp;profile.Configuration); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(tagsJSON), &amp;profile.Tags); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal tags: %w", err)
        }</span>

        <span class="cov0" title="0">return profile, nil</span>
}

// GetUserConfigurationProfiles retrieves all configuration profiles for a user
func (r *ConfigurationRepository) GetUserConfigurationProfiles(userID int) ([]*models.ConfigurationProfile, error) <span class="cov0" title="0">{
        query := `
                SELECT profile_id, name, description, user_id, configuration,
                           created_at, updated_at, is_active, tags
                FROM configuration_profiles WHERE user_id = ? ORDER BY created_at DESC`

        rows, err := r.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user configuration profiles: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var profiles []*models.ConfigurationProfile
        for rows.Next() </span><span class="cov0" title="0">{
                profile := &amp;models.ConfigurationProfile{}
                var configJSON, tagsJSON string

                err := rows.Scan(
                        &amp;profile.ProfileID, &amp;profile.Name, &amp;profile.Description, &amp;profile.UserID,
                        &amp;configJSON, &amp;profile.CreatedAt, &amp;profile.UpdatedAt, &amp;profile.IsActive, &amp;tagsJSON)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan configuration profile: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(configJSON), &amp;profile.Configuration); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(tagsJSON), &amp;profile.Tags); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal tags: %w", err)
                }</span>

                <span class="cov0" title="0">profiles = append(profiles, profile)</span>
        }

        <span class="cov0" title="0">return profiles, nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package repository

import (
        "database/sql"
        "fmt"
        "time"

        "catalogizer/models"
)

type ConversionRepository struct {
        db *sql.DB
}

func NewConversionRepository(db *sql.DB) *ConversionRepository <span class="cov0" title="0">{
        return &amp;ConversionRepository{db: db}
}</span>

func (r *ConversionRepository) CreateJob(job *models.ConversionJob) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO conversion_jobs (user_id, source_path, target_path, source_format, target_format,
                                                                        conversion_type, quality, settings, priority, status, created_at, scheduled_for)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query,
                job.UserID, job.SourcePath, job.TargetPath, job.SourceFormat, job.TargetFormat,
                job.ConversionType, job.Quality, job.Settings, job.Priority, job.Status,
                job.CreatedAt, job.ScheduledFor)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create conversion job: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get job ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *ConversionRepository) GetJob(jobID int) (*models.ConversionJob, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, source_path, target_path, source_format, target_format,
                           conversion_type, quality, settings, priority, status, created_at,
                           started_at, completed_at, scheduled_for, duration, error_message
                FROM conversion_jobs
                WHERE id = ?
        `

        job := &amp;models.ConversionJob{}
        var settings, errorMessage sql.NullString
        var startedAt, completedAt, scheduledFor sql.NullTime
        var durationSeconds sql.NullInt64

        err := r.db.QueryRow(query, jobID).Scan(
                &amp;job.ID, &amp;job.UserID, &amp;job.SourcePath, &amp;job.TargetPath, &amp;job.SourceFormat, &amp;job.TargetFormat,
                &amp;job.ConversionType, &amp;job.Quality, &amp;settings, &amp;job.Priority, &amp;job.Status, &amp;job.CreatedAt,
                &amp;startedAt, &amp;completedAt, &amp;scheduledFor, &amp;durationSeconds, &amp;errorMessage)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("job not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get job: %w", err)</span>
        }

        <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                job.Settings = &amp;settings.String
        }</span>

        <span class="cov0" title="0">if errorMessage.Valid </span><span class="cov0" title="0">{
                job.ErrorMessage = &amp;errorMessage.String
        }</span>

        <span class="cov0" title="0">if startedAt.Valid </span><span class="cov0" title="0">{
                job.StartedAt = &amp;startedAt.Time
        }</span>

        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                job.CompletedAt = &amp;completedAt.Time
        }</span>

        <span class="cov0" title="0">if scheduledFor.Valid </span><span class="cov0" title="0">{
                job.ScheduledFor = &amp;scheduledFor.Time
        }</span>

        <span class="cov0" title="0">if durationSeconds.Valid </span><span class="cov0" title="0">{
                duration := time.Duration(durationSeconds.Int64) * time.Second
                job.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">return job, nil</span>
}

func (r *ConversionRepository) UpdateJob(job *models.ConversionJob) error <span class="cov0" title="0">{
        query := `
                UPDATE conversion_jobs
                SET status = ?, started_at = ?, completed_at = ?, duration = ?, error_message = ?, updated_at = ?
                WHERE id = ?
        `

        var startedAt, completedAt sql.NullTime
        var durationSeconds sql.NullInt64
        var errorMessage sql.NullString

        if job.StartedAt != nil </span><span class="cov0" title="0">{
                startedAt = sql.NullTime{Time: *job.StartedAt, Valid: true}
        }</span>

        <span class="cov0" title="0">if job.CompletedAt != nil </span><span class="cov0" title="0">{
                completedAt = sql.NullTime{Time: *job.CompletedAt, Valid: true}
        }</span>

        <span class="cov0" title="0">if job.Duration != nil </span><span class="cov0" title="0">{
                durationSeconds = sql.NullInt64{Int64: int64(job.Duration.Seconds()), Valid: true}
        }</span>

        <span class="cov0" title="0">if job.ErrorMessage != nil </span><span class="cov0" title="0">{
                errorMessage = sql.NullString{String: *job.ErrorMessage, Valid: true}
        }</span>

        <span class="cov0" title="0">_, err := r.db.Exec(query, job.Status, startedAt, completedAt, durationSeconds, errorMessage, time.Now(), job.ID)
        return err</span>
}

func (r *ConversionRepository) GetUserJobs(userID int, status *string, limit, offset int) ([]models.ConversionJob, error) <span class="cov0" title="0">{
        whereClause := "WHERE user_id = ?"
        args := []interface{}{userID}

        if status != nil </span><span class="cov0" title="0">{
                whereClause += " AND status = ?"
                args = append(args, *status)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT id, user_id, source_path, target_path, source_format, target_format,
                           conversion_type, quality, settings, priority, status, created_at,
                           started_at, completed_at, scheduled_for, duration, error_message
                FROM conversion_jobs
                %s
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `, whereClause)

        args = append(args, limit, offset)

        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user jobs: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanJobs(rows)</span>
}

func (r *ConversionRepository) GetJobsByStatus(status string, limit, offset int) ([]models.ConversionJob, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, source_path, target_path, source_format, target_format,
                           conversion_type, quality, settings, priority, status, created_at,
                           started_at, completed_at, scheduled_for, duration, error_message
                FROM conversion_jobs
                WHERE status = ?
                ORDER BY priority DESC, created_at ASC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.Query(query, status, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get jobs by status: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanJobs(rows)</span>
}

func (r *ConversionRepository) GetStatistics(userID *int, startDate, endDate time.Time) (*models.ConversionStatistics, error) <span class="cov0" title="0">{
        whereClause := "WHERE created_at BETWEEN ? AND ?"
        args := []interface{}{startDate, endDate}

        if userID != nil </span><span class="cov0" title="0">{
                whereClause += " AND user_id = ?"
                args = append(args, *userID)
        }</span>

        // Get total counts by status
        <span class="cov0" title="0">statusQuery := fmt.Sprintf(`
                SELECT status, COUNT(*) as count
                FROM conversion_jobs
                %s
                GROUP BY status
        `, whereClause)

        statusRows, err := r.db.Query(statusQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get status statistics: %w", err)
        }</span>
        <span class="cov0" title="0">defer statusRows.Close()

        stats := &amp;models.ConversionStatistics{
                StartDate: startDate,
                EndDate:   endDate,
                ByStatus:  make(map[string]int),
                ByType:    make(map[string]int),
                ByFormat:  make(map[string]int),
        }

        for statusRows.Next() </span><span class="cov0" title="0">{
                var status string
                var count int
                err := statusRows.Scan(&amp;status, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan status stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ByStatus[status] = count
                stats.TotalJobs += count</span>
        }

        // Get counts by conversion type
        <span class="cov0" title="0">typeQuery := fmt.Sprintf(`
                SELECT conversion_type, COUNT(*) as count
                FROM conversion_jobs
                %s
                GROUP BY conversion_type
        `, whereClause)

        typeRows, err := r.db.Query(typeQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get type statistics: %w", err)
        }</span>
        <span class="cov0" title="0">defer typeRows.Close()

        for typeRows.Next() </span><span class="cov0" title="0">{
                var convType string
                var count int
                err := typeRows.Scan(&amp;convType, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan type stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ByType[convType] = count</span>
        }

        // Get counts by target format
        <span class="cov0" title="0">formatQuery := fmt.Sprintf(`
                SELECT target_format, COUNT(*) as count
                FROM conversion_jobs
                %s
                GROUP BY target_format
                ORDER BY count DESC
                LIMIT 10
        `, whereClause)

        formatRows, err := r.db.Query(formatQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get format statistics: %w", err)
        }</span>
        <span class="cov0" title="0">defer formatRows.Close()

        for formatRows.Next() </span><span class="cov0" title="0">{
                var format string
                var count int
                err := formatRows.Scan(&amp;format, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan format stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ByFormat[format] = count</span>
        }

        // Get average duration for completed jobs
        <span class="cov0" title="0">durationQuery := fmt.Sprintf(`
                SELECT AVG(duration) as avg_duration
                FROM conversion_jobs
                %s AND status = 'completed' AND duration IS NOT NULL
        `, whereClause)

        var avgDurationSeconds sql.NullFloat64
        err = r.db.QueryRow(durationQuery, args...).Scan(&amp;avgDurationSeconds)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get duration statistics: %w", err)
        }</span>

        <span class="cov0" title="0">if avgDurationSeconds.Valid </span><span class="cov0" title="0">{
                avgDuration := time.Duration(avgDurationSeconds.Float64) * time.Second
                stats.AverageDuration = &amp;avgDuration
        }</span>

        // Calculate success rate
        <span class="cov0" title="0">if completed, ok := stats.ByStatus[models.ConversionStatusCompleted]; ok </span><span class="cov0" title="0">{
                if failed, failedOk := stats.ByStatus[models.ConversionStatusFailed]; failedOk </span><span class="cov0" title="0">{
                        total := completed + failed
                        if total &gt; 0 </span><span class="cov0" title="0">{
                                stats.SuccessRate = float64(completed) / float64(total) * 100
                        }</span>
                } else<span class="cov0" title="0"> if completed &gt; 0 </span><span class="cov0" title="0">{
                        stats.SuccessRate = 100.0
                }</span>
        }

        <span class="cov0" title="0">return stats, nil</span>
}

func (r *ConversionRepository) CleanupJobs(olderThan time.Time) error <span class="cov0" title="0">{
        query := `
                DELETE FROM conversion_jobs
                WHERE completed_at &lt; ? AND status IN ('completed', 'failed', 'cancelled')
        `

        _, err := r.db.Exec(query, olderThan)
        return err
}</span>

func (r *ConversionRepository) GetActiveJobsCount() (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM conversion_jobs WHERE status IN ('pending', 'running')`
        var count int
        err := r.db.QueryRow(query).Scan(&amp;count)
        return count, err
}</span>

func (r *ConversionRepository) GetJobsCountByUser(userID int) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM conversion_jobs WHERE user_id = ?`
        var count int
        err := r.db.QueryRow(query, userID).Scan(&amp;count)
        return count, err
}</span>

func (r *ConversionRepository) GetPopularFormats(limit int) ([]models.FormatPopularity, error) <span class="cov0" title="0">{
        query := `
                SELECT target_format, COUNT(*) as count
                FROM conversion_jobs
                WHERE status = 'completed'
                GROUP BY target_format
                ORDER BY count DESC
                LIMIT ?
        `

        rows, err := r.db.Query(query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get popular formats: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var formats []models.FormatPopularity
        for rows.Next() </span><span class="cov0" title="0">{
                var format models.FormatPopularity
                err := rows.Scan(&amp;format.Format, &amp;format.Count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan format popularity: %w", err)
                }</span>
                <span class="cov0" title="0">formats = append(formats, format)</span>
        }

        <span class="cov0" title="0">return formats, nil</span>
}

func (r *ConversionRepository) scanJobs(rows *sql.Rows) ([]models.ConversionJob, error) <span class="cov0" title="0">{
        var jobs []models.ConversionJob

        for rows.Next() </span><span class="cov0" title="0">{
                var job models.ConversionJob
                var settings, errorMessage sql.NullString
                var startedAt, completedAt, scheduledFor sql.NullTime
                var durationSeconds sql.NullInt64

                err := rows.Scan(
                        &amp;job.ID, &amp;job.UserID, &amp;job.SourcePath, &amp;job.TargetPath, &amp;job.SourceFormat, &amp;job.TargetFormat,
                        &amp;job.ConversionType, &amp;job.Quality, &amp;settings, &amp;job.Priority, &amp;job.Status, &amp;job.CreatedAt,
                        &amp;startedAt, &amp;completedAt, &amp;scheduledFor, &amp;durationSeconds, &amp;errorMessage)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan job: %w", err)
                }</span>

                <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                        job.Settings = &amp;settings.String
                }</span>

                <span class="cov0" title="0">if errorMessage.Valid </span><span class="cov0" title="0">{
                        job.ErrorMessage = &amp;errorMessage.String
                }</span>

                <span class="cov0" title="0">if startedAt.Valid </span><span class="cov0" title="0">{
                        job.StartedAt = &amp;startedAt.Time
                }</span>

                <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                        job.CompletedAt = &amp;completedAt.Time
                }</span>

                <span class="cov0" title="0">if scheduledFor.Valid </span><span class="cov0" title="0">{
                        job.ScheduledFor = &amp;scheduledFor.Time
                }</span>

                <span class="cov0" title="0">if durationSeconds.Valid </span><span class="cov0" title="0">{
                        duration := time.Duration(durationSeconds.Int64) * time.Second
                        job.Duration = &amp;duration
                }</span>

                <span class="cov0" title="0">jobs = append(jobs, job)</span>
        }

        <span class="cov0" title="0">return jobs, nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
)

type CrashReportingRepository struct {
        db *sql.DB
}

func NewCrashReportingRepository(db *sql.DB) *CrashReportingRepository <span class="cov0" title="0">{
        return &amp;CrashReportingRepository{db: db}
}</span>

func (r *CrashReportingRepository) CreateCrashReport(report *models.CrashReport) error <span class="cov0" title="0">{
        contextJSON, err := json.Marshal(report.Context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal context: %w", err)
        }</span>

        <span class="cov0" title="0">systemInfoJSON, err := json.Marshal(report.SystemInfo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal system info: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO crash_reports (
                        user_id, signal, message, stack_trace, context, system_info,
                        fingerprint, status, reported_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                report.UserID, report.Signal, report.Message, report.StackTrace,
                string(contextJSON), string(systemInfoJSON), report.Fingerprint,
                report.Status, report.ReportedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create crash report: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">report.ID = int(id)
        return nil</span>
}

func (r *CrashReportingRepository) GetCrashReport(id int) (*models.CrashReport, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, signal, message, stack_trace, context, system_info,
                           fingerprint, status, reported_at, resolved_at
                FROM crash_reports WHERE id = ?`

        var report models.CrashReport
        var contextJSON, systemInfoJSON string
        var resolvedAt sql.NullTime

        err := r.db.QueryRow(query, id).Scan(
                &amp;report.ID, &amp;report.UserID, &amp;report.Signal, &amp;report.Message,
                &amp;report.StackTrace, &amp;contextJSON, &amp;systemInfoJSON,
                &amp;report.Fingerprint, &amp;report.Status, &amp;report.ReportedAt, &amp;resolvedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crash report: %w", err)
        }</span>

        <span class="cov0" title="0">if resolvedAt.Valid </span><span class="cov0" title="0">{
                report.ResolvedAt = &amp;resolvedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;report.Context); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal context: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(systemInfoJSON), &amp;report.SystemInfo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal system info: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;report, nil</span>
}

func (r *CrashReportingRepository) UpdateCrashReport(report *models.CrashReport) error <span class="cov0" title="0">{
        contextJSON, err := json.Marshal(report.Context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal context: %w", err)
        }</span>

        <span class="cov0" title="0">systemInfoJSON, err := json.Marshal(report.SystemInfo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal system info: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE crash_reports SET
                        signal = ?, message = ?, stack_trace = ?, context = ?,
                        system_info = ?, fingerprint = ?, status = ?, resolved_at = ?
                WHERE id = ?`

        _, err = r.db.Exec(query,
                report.Signal, report.Message, report.StackTrace,
                string(contextJSON), string(systemInfoJSON), report.Fingerprint,
                report.Status, report.ResolvedAt, report.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update crash report: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *CrashReportingRepository) GetCrashReportsByUser(userID int, filters *models.CrashReportFilters) ([]*models.CrashReport, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, signal, message, stack_trace, context, system_info,
                           fingerprint, status, reported_at, resolved_at
                FROM crash_reports
                WHERE user_id = ?`

        args := []interface{}{userID}

        if filters != nil </span><span class="cov0" title="0">{
                if filters.Signal != "" </span><span class="cov0" title="0">{
                        query += " AND signal = ?"
                        args = append(args, filters.Signal)
                }</span>

                <span class="cov0" title="0">if filters.Status != "" </span><span class="cov0" title="0">{
                        query += " AND status = ?"
                        args = append(args, filters.Status)
                }</span>

                <span class="cov0" title="0">if filters.StartDate != nil </span><span class="cov0" title="0">{
                        query += " AND reported_at &gt;= ?"
                        args = append(args, *filters.StartDate)
                }</span>

                <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                        query += " AND reported_at &lt;= ?"
                        args = append(args, *filters.EndDate)
                }</span>
        }

        <span class="cov0" title="0">query += " ORDER BY reported_at DESC"

        if filters != nil &amp;&amp; filters.Limit &gt; 0 </span><span class="cov0" title="0">{
                query += " LIMIT ?"
                args = append(args, filters.Limit)

                if filters.Offset &gt; 0 </span><span class="cov0" title="0">{
                        query += " OFFSET ?"
                        args = append(args, filters.Offset)
                }</span>
        }

        <span class="cov0" title="0">rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crash reports: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reports []*models.CrashReport
        for rows.Next() </span><span class="cov0" title="0">{
                var report models.CrashReport
                var contextJSON, systemInfoJSON string
                var resolvedAt sql.NullTime

                err := rows.Scan(
                        &amp;report.ID, &amp;report.UserID, &amp;report.Signal, &amp;report.Message,
                        &amp;report.StackTrace, &amp;contextJSON, &amp;systemInfoJSON,
                        &amp;report.Fingerprint, &amp;report.Status, &amp;report.ReportedAt, &amp;resolvedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan crash report: %w", err)
                }</span>

                <span class="cov0" title="0">if resolvedAt.Valid </span><span class="cov0" title="0">{
                        report.ResolvedAt = &amp;resolvedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;report.Context); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal context: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(systemInfoJSON), &amp;report.SystemInfo); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal system info: %w", err)
                }</span>

                <span class="cov0" title="0">reports = append(reports, &amp;report)</span>
        }

        <span class="cov0" title="0">return reports, nil</span>
}

func (r *CrashReportingRepository) DeleteCrashReport(id int) error <span class="cov0" title="0">{
        query := "DELETE FROM crash_reports WHERE id = ?"
        _, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete crash report: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CrashReportingRepository) GetRecentCrashCount(duration time.Duration) (int, error) <span class="cov0" title="0">{
        since := time.Now().Add(-duration)
        query := `
                SELECT COUNT(*)
                FROM crash_reports
                WHERE reported_at &gt; ?`

        var count int
        err := r.db.QueryRow(query, since).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get recent crash count: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

func (r *CrashReportingRepository) GetCrashStatistics(userID int) (*models.CrashStatistics, error) <span class="cov0" title="0">{
        stats := &amp;models.CrashStatistics{}

        // Total crashes
        err := r.db.QueryRow("SELECT COUNT(*) FROM crash_reports WHERE user_id = ?", userID).Scan(&amp;stats.TotalCrashes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total crashes: %w", err)
        }</span>

        // Crashes by signal
        <span class="cov0" title="0">signalQuery := `
                SELECT signal, COUNT(*)
                FROM crash_reports
                WHERE user_id = ?
                GROUP BY signal`

        rows, err := r.db.Query(signalQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crash signals: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        stats.CrashesBySignal = make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var signal string
                var count int
                if err := rows.Scan(&amp;signal, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan crash signal: %w", err)
                }</span>
                <span class="cov0" title="0">stats.CrashesBySignal[signal] = count</span>
        }

        // Recent crashes (last 24 hours)
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM crash_reports
                WHERE user_id = ? AND reported_at &gt; datetime('now', '-1 day')`, userID).Scan(&amp;stats.RecentCrashes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent crashes: %w", err)
        }</span>

        // Resolved crashes
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM crash_reports
                WHERE user_id = ? AND status = ?`, userID, models.CrashStatusResolved).Scan(&amp;stats.ResolvedCrashes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get resolved crashes: %w", err)
        }</span>

        // Average resolution time (in hours)
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT AVG(
                        CASE
                                WHEN resolved_at IS NOT NULL
                                THEN (julianday(resolved_at) - julianday(reported_at)) * 24
                                ELSE NULL
                        END
                )
                FROM crash_reports
                WHERE user_id = ? AND resolved_at IS NOT NULL`, userID).Scan(&amp;stats.AvgResolutionTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get average resolution time: %w", err)
        }</span>

        // Crash rate (crashes per day over last 30 days)
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT CAST(COUNT(*) AS FLOAT) / 30
                FROM crash_reports
                WHERE user_id = ? AND reported_at &gt; datetime('now', '-30 days')`, userID).Scan(&amp;stats.CrashRate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crash rate: %w", err)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (r *CrashReportingRepository) GetCrashesByFingerprint(fingerprint string, limit int) ([]*models.CrashReport, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, signal, message, stack_trace, context, system_info,
                           fingerprint, status, reported_at, resolved_at
                FROM crash_reports
                WHERE fingerprint = ?
                ORDER BY reported_at DESC
                LIMIT ?`

        rows, err := r.db.Query(query, fingerprint, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crashes by fingerprint: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reports []*models.CrashReport
        for rows.Next() </span><span class="cov0" title="0">{
                var report models.CrashReport
                var contextJSON, systemInfoJSON string
                var resolvedAt sql.NullTime

                err := rows.Scan(
                        &amp;report.ID, &amp;report.UserID, &amp;report.Signal, &amp;report.Message,
                        &amp;report.StackTrace, &amp;contextJSON, &amp;systemInfoJSON,
                        &amp;report.Fingerprint, &amp;report.Status, &amp;report.ReportedAt, &amp;resolvedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan crash report: %w", err)
                }</span>

                <span class="cov0" title="0">if resolvedAt.Valid </span><span class="cov0" title="0">{
                        report.ResolvedAt = &amp;resolvedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;report.Context); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal context: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(systemInfoJSON), &amp;report.SystemInfo); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal system info: %w", err)
                }</span>

                <span class="cov0" title="0">reports = append(reports, &amp;report)</span>
        }

        <span class="cov0" title="0">return reports, nil</span>
}

func (r *CrashReportingRepository) CleanupOldReports(olderThan time.Time) error <span class="cov0" title="0">{
        query := "DELETE FROM crash_reports WHERE reported_at &lt; ?"
        _, err := r.db.Exec(query, olderThan)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old crash reports: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CrashReportingRepository) GetTopCrashes(userID int, limit int, timeRange time.Duration) ([]*models.TopCrash, error) <span class="cov0" title="0">{
        since := time.Now().Add(-timeRange)
        query := `
                SELECT fingerprint, COUNT(*) as count, MAX(reported_at) as last_seen,
                           MIN(reported_at) as first_seen, message, signal
                FROM crash_reports
                WHERE user_id = ? AND reported_at &gt; ?
                GROUP BY fingerprint
                ORDER BY count DESC
                LIMIT ?`

        rows, err := r.db.Query(query, userID, since, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top crashes: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var topCrashes []*models.TopCrash
        for rows.Next() </span><span class="cov0" title="0">{
                var topCrash models.TopCrash
                err := rows.Scan(
                        &amp;topCrash.Fingerprint, &amp;topCrash.Count, &amp;topCrash.LastSeen,
                        &amp;topCrash.FirstSeen, &amp;topCrash.Message, &amp;topCrash.Signal)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan top crash: %w", err)
                }</span>

                <span class="cov0" title="0">topCrashes = append(topCrashes, &amp;topCrash)</span>
        }

        <span class="cov0" title="0">return topCrashes, nil</span>
}

func (r *CrashReportingRepository) GetCrashTrends(userID int, days int) ([]*models.CrashTrend, error) <span class="cov0" title="0">{
        query := `
                SELECT DATE(reported_at) as date, COUNT(*) as count
                FROM crash_reports
                WHERE user_id = ? AND reported_at &gt; datetime('now', '-' || ? || ' days')
                GROUP BY DATE(reported_at)
                ORDER BY date ASC`

        rows, err := r.db.Query(query, userID, days)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crash trends: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var trends []*models.CrashTrend
        for rows.Next() </span><span class="cov0" title="0">{
                var trend models.CrashTrend
                var dateStr string
                err := rows.Scan(&amp;dateStr, &amp;trend.Count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan crash trend: %w", err)
                }</span>

                <span class="cov0" title="0">date, err := time.Parse("2006-01-02", dateStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse date: %w", err)
                }</span>
                <span class="cov0" title="0">trend.Date = date

                trends = append(trends, &amp;trend)</span>
        }

        <span class="cov0" title="0">return trends, nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
)

type ErrorReportingRepository struct {
        db *sql.DB
}

func NewErrorReportingRepository(db *sql.DB) *ErrorReportingRepository <span class="cov0" title="0">{
        return &amp;ErrorReportingRepository{db: db}
}</span>

func (r *ErrorReportingRepository) CreateErrorReport(report *models.ErrorReport) error <span class="cov0" title="0">{
        contextJSON, err := json.Marshal(report.Context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal context: %w", err)
        }</span>

        <span class="cov0" title="0">systemInfoJSON, err := json.Marshal(report.SystemInfo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal system info: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO error_reports (
                        user_id, level, message, error_code, component, stack_trace,
                        context, system_info, user_agent, url, fingerprint, status, reported_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                report.UserID, report.Level, report.Message, report.ErrorCode,
                report.Component, report.StackTrace, string(contextJSON),
                string(systemInfoJSON), report.UserAgent, report.URL,
                report.Fingerprint, report.Status, report.ReportedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create error report: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">report.ID = int(id)
        return nil</span>
}

func (r *ErrorReportingRepository) GetErrorReport(id int) (*models.ErrorReport, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, level, message, error_code, component, stack_trace,
                           context, system_info, user_agent, url, fingerprint, status,
                           reported_at, resolved_at
                FROM error_reports WHERE id = ?`

        var report models.ErrorReport
        var contextJSON, systemInfoJSON string
        var resolvedAt sql.NullTime

        err := r.db.QueryRow(query, id).Scan(
                &amp;report.ID, &amp;report.UserID, &amp;report.Level, &amp;report.Message,
                &amp;report.ErrorCode, &amp;report.Component, &amp;report.StackTrace,
                &amp;contextJSON, &amp;systemInfoJSON, &amp;report.UserAgent, &amp;report.URL,
                &amp;report.Fingerprint, &amp;report.Status, &amp;report.ReportedAt, &amp;resolvedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get error report: %w", err)
        }</span>

        <span class="cov0" title="0">if resolvedAt.Valid </span><span class="cov0" title="0">{
                report.ResolvedAt = &amp;resolvedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;report.Context); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal context: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(systemInfoJSON), &amp;report.SystemInfo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal system info: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;report, nil</span>
}

func (r *ErrorReportingRepository) UpdateErrorReport(report *models.ErrorReport) error <span class="cov0" title="0">{
        contextJSON, err := json.Marshal(report.Context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal context: %w", err)
        }</span>

        <span class="cov0" title="0">systemInfoJSON, err := json.Marshal(report.SystemInfo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal system info: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE error_reports SET
                        level = ?, message = ?, error_code = ?, component = ?,
                        stack_trace = ?, context = ?, system_info = ?, user_agent = ?,
                        url = ?, fingerprint = ?, status = ?, resolved_at = ?
                WHERE id = ?`

        _, err = r.db.Exec(query,
                report.Level, report.Message, report.ErrorCode, report.Component,
                report.StackTrace, string(contextJSON), string(systemInfoJSON),
                report.UserAgent, report.URL, report.Fingerprint, report.Status,
                report.ResolvedAt, report.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update error report: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ErrorReportingRepository) GetErrorReportsByUser(userID int, filters *models.ErrorReportFilters) ([]*models.ErrorReport, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, level, message, error_code, component, stack_trace,
                           context, system_info, user_agent, url, fingerprint, status,
                           reported_at, resolved_at
                FROM error_reports
                WHERE user_id = ?`

        args := []interface{}{userID}

        if filters != nil </span><span class="cov0" title="0">{
                if filters.Level != "" </span><span class="cov0" title="0">{
                        query += " AND level = ?"
                        args = append(args, filters.Level)
                }</span>

                <span class="cov0" title="0">if filters.Component != "" </span><span class="cov0" title="0">{
                        query += " AND component = ?"
                        args = append(args, filters.Component)
                }</span>

                <span class="cov0" title="0">if filters.Status != "" </span><span class="cov0" title="0">{
                        query += " AND status = ?"
                        args = append(args, filters.Status)
                }</span>

                <span class="cov0" title="0">if filters.StartDate != nil </span><span class="cov0" title="0">{
                        query += " AND reported_at &gt;= ?"
                        args = append(args, *filters.StartDate)
                }</span>

                <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                        query += " AND reported_at &lt;= ?"
                        args = append(args, *filters.EndDate)
                }</span>
        }

        <span class="cov0" title="0">query += " ORDER BY reported_at DESC"

        if filters != nil &amp;&amp; filters.Limit &gt; 0 </span><span class="cov0" title="0">{
                query += " LIMIT ?"
                args = append(args, filters.Limit)

                if filters.Offset &gt; 0 </span><span class="cov0" title="0">{
                        query += " OFFSET ?"
                        args = append(args, filters.Offset)
                }</span>
        }

        <span class="cov0" title="0">rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get error reports: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reports []*models.ErrorReport
        for rows.Next() </span><span class="cov0" title="0">{
                var report models.ErrorReport
                var contextJSON, systemInfoJSON string
                var resolvedAt sql.NullTime

                err := rows.Scan(
                        &amp;report.ID, &amp;report.UserID, &amp;report.Level, &amp;report.Message,
                        &amp;report.ErrorCode, &amp;report.Component, &amp;report.StackTrace,
                        &amp;contextJSON, &amp;systemInfoJSON, &amp;report.UserAgent, &amp;report.URL,
                        &amp;report.Fingerprint, &amp;report.Status, &amp;report.ReportedAt, &amp;resolvedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan error report: %w", err)
                }</span>

                <span class="cov0" title="0">if resolvedAt.Valid </span><span class="cov0" title="0">{
                        report.ResolvedAt = &amp;resolvedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;report.Context); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal context: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(systemInfoJSON), &amp;report.SystemInfo); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal system info: %w", err)
                }</span>

                <span class="cov0" title="0">reports = append(reports, &amp;report)</span>
        }

        <span class="cov0" title="0">return reports, nil</span>
}

func (r *ErrorReportingRepository) DeleteErrorReport(id int) error <span class="cov0" title="0">{
        query := "DELETE FROM error_reports WHERE id = ?"
        _, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete error report: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ErrorReportingRepository) GetErrorCountInLastHour(userID int) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*)
                FROM error_reports
                WHERE user_id = ? AND reported_at &gt; datetime('now', '-1 hour')`

        var count int
        err := r.db.QueryRow(query, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get error count: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

func (r *ErrorReportingRepository) GetRecentErrorCount(duration time.Duration) (int, error) <span class="cov0" title="0">{
        since := time.Now().Add(-duration)
        query := `
                SELECT COUNT(*)
                FROM error_reports
                WHERE reported_at &gt; ?`

        var count int
        err := r.db.QueryRow(query, since).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get recent error count: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

func (r *ErrorReportingRepository) GetErrorStatistics(userID int) (*models.ErrorStatistics, error) <span class="cov0" title="0">{
        stats := &amp;models.ErrorStatistics{}

        // Total errors
        err := r.db.QueryRow("SELECT COUNT(*) FROM error_reports WHERE user_id = ?", userID).Scan(&amp;stats.TotalErrors)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total errors: %w", err)
        }</span>

        // Errors by level
        <span class="cov0" title="0">levelQuery := `
                SELECT level, COUNT(*)
                FROM error_reports
                WHERE user_id = ?
                GROUP BY level`

        rows, err := r.db.Query(levelQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get error levels: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        stats.ErrorsByLevel = make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var level string
                var count int
                if err := rows.Scan(&amp;level, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan error level: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ErrorsByLevel[level] = count</span>
        }

        // Errors by component
        <span class="cov0" title="0">componentQuery := `
                SELECT component, COUNT(*)
                FROM error_reports
                WHERE user_id = ?
                GROUP BY component
                ORDER BY COUNT(*) DESC
                LIMIT 10`

        rows, err = r.db.Query(componentQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get error components: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        stats.ErrorsByComponent = make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var component string
                var count int
                if err := rows.Scan(&amp;component, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan error component: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ErrorsByComponent[component] = count</span>
        }

        // Recent errors (last 24 hours)
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM error_reports
                WHERE user_id = ? AND reported_at &gt; datetime('now', '-1 day')`, userID).Scan(&amp;stats.RecentErrors)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent errors: %w", err)
        }</span>

        // Resolved errors
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM error_reports
                WHERE user_id = ? AND status = ?`, userID, models.ErrorStatusResolved).Scan(&amp;stats.ResolvedErrors)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get resolved errors: %w", err)
        }</span>

        // Average resolution time (in hours)
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT AVG(
                        CASE
                                WHEN resolved_at IS NOT NULL
                                THEN (julianday(resolved_at) - julianday(reported_at)) * 24
                                ELSE NULL
                        END
                )
                FROM error_reports
                WHERE user_id = ? AND resolved_at IS NOT NULL`, userID).Scan(&amp;stats.AvgResolutionTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get average resolution time: %w", err)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (r *ErrorReportingRepository) GetErrorsByFingerprint(fingerprint string, limit int) ([]*models.ErrorReport, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, level, message, error_code, component, stack_trace,
                           context, system_info, user_agent, url, fingerprint, status,
                           reported_at, resolved_at
                FROM error_reports
                WHERE fingerprint = ?
                ORDER BY reported_at DESC
                LIMIT ?`

        rows, err := r.db.Query(query, fingerprint, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get errors by fingerprint: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reports []*models.ErrorReport
        for rows.Next() </span><span class="cov0" title="0">{
                var report models.ErrorReport
                var contextJSON, systemInfoJSON string
                var resolvedAt sql.NullTime

                err := rows.Scan(
                        &amp;report.ID, &amp;report.UserID, &amp;report.Level, &amp;report.Message,
                        &amp;report.ErrorCode, &amp;report.Component, &amp;report.StackTrace,
                        &amp;contextJSON, &amp;systemInfoJSON, &amp;report.UserAgent, &amp;report.URL,
                        &amp;report.Fingerprint, &amp;report.Status, &amp;report.ReportedAt, &amp;resolvedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan error report: %w", err)
                }</span>

                <span class="cov0" title="0">if resolvedAt.Valid </span><span class="cov0" title="0">{
                        report.ResolvedAt = &amp;resolvedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;report.Context); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal context: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(systemInfoJSON), &amp;report.SystemInfo); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal system info: %w", err)
                }</span>

                <span class="cov0" title="0">reports = append(reports, &amp;report)</span>
        }

        <span class="cov0" title="0">return reports, nil</span>
}

func (r *ErrorReportingRepository) CleanupOldReports(olderThan time.Time) error <span class="cov0" title="0">{
        query := "DELETE FROM error_reports WHERE reported_at &lt; ?"
        _, err := r.db.Exec(query, olderThan)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old error reports: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ErrorReportingRepository) GetTopErrors(userID int, limit int, timeRange time.Duration) ([]*models.TopError, error) <span class="cov0" title="0">{
        since := time.Now().Add(-timeRange)
        query := `
                SELECT fingerprint, COUNT(*) as count, MAX(reported_at) as last_seen,
                           MIN(reported_at) as first_seen, message, component, level
                FROM error_reports
                WHERE user_id = ? AND reported_at &gt; ?
                GROUP BY fingerprint
                ORDER BY count DESC
                LIMIT ?`

        rows, err := r.db.Query(query, userID, since, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top errors: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var topErrors []*models.TopError
        for rows.Next() </span><span class="cov0" title="0">{
                var topError models.TopError
                err := rows.Scan(
                        &amp;topError.Fingerprint, &amp;topError.Count, &amp;topError.LastSeen,
                        &amp;topError.FirstSeen, &amp;topError.Message, &amp;topError.Component, &amp;topError.Level)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan top error: %w", err)
                }</span>

                <span class="cov0" title="0">topErrors = append(topErrors, &amp;topError)</span>
        }

        <span class="cov0" title="0">return topErrors, nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"

        "catalogizer/models"
)

type FavoritesRepository struct {
        db *sql.DB
}

func NewFavoritesRepository(db *sql.DB) *FavoritesRepository <span class="cov0" title="0">{
        return &amp;FavoritesRepository{db: db}
}</span>

func (r *FavoritesRepository) CreateFavorite(favorite *models.Favorite) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO favorites (user_id, entity_type, entity_id, category, notes, tags, is_public, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        var tagsJSON *string
        if favorite.Tags != nil &amp;&amp; len(*favorite.Tags) &gt; 0 </span><span class="cov0" title="0">{
                data, err := json.Marshal(*favorite.Tags)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to marshal tags: %w", err)
                }</span>
                <span class="cov0" title="0">tagsStr := string(data)
                tagsJSON = &amp;tagsStr</span>
        }

        <span class="cov0" title="0">result, err := r.db.Exec(query,
                favorite.UserID, favorite.EntityType, favorite.EntityID,
                favorite.Category, favorite.Notes, tagsJSON, favorite.IsPublic, favorite.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create favorite: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get favorite ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *FavoritesRepository) GetFavorite(userID int, entityType string, entityID int) (*models.Favorite, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                WHERE user_id = ? AND entity_type = ? AND entity_id = ?
        `

        favorite := &amp;models.Favorite{}
        var tagsJSON sql.NullString
        var updatedAt sql.NullTime

        err := r.db.QueryRow(query, userID, entityType, entityID).Scan(
                &amp;favorite.ID, &amp;favorite.UserID, &amp;favorite.EntityType, &amp;favorite.EntityID,
                &amp;favorite.Category, &amp;favorite.Notes, &amp;tagsJSON, &amp;favorite.IsPublic,
                &amp;favorite.CreatedAt, &amp;updatedAt)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get favorite: %w", err)</span>
        }

        <span class="cov0" title="0">if tagsJSON.Valid </span><span class="cov0" title="0">{
                var tags []string
                if err := json.Unmarshal([]byte(tagsJSON.String), &amp;tags); err == nil </span><span class="cov0" title="0">{
                        favorite.Tags = &amp;tags
                }</span>
        }

        <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                favorite.UpdatedAt = &amp;updatedAt.Time
        }</span>

        <span class="cov0" title="0">return favorite, nil</span>
}

func (r *FavoritesRepository) GetFavoriteByID(favoriteID int) (*models.Favorite, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                WHERE id = ?
        `

        favorite := &amp;models.Favorite{}
        var tagsJSON sql.NullString
        var updatedAt sql.NullTime

        err := r.db.QueryRow(query, favoriteID).Scan(
                &amp;favorite.ID, &amp;favorite.UserID, &amp;favorite.EntityType, &amp;favorite.EntityID,
                &amp;favorite.Category, &amp;favorite.Notes, &amp;tagsJSON, &amp;favorite.IsPublic,
                &amp;favorite.CreatedAt, &amp;updatedAt)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("favorite not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get favorite: %w", err)</span>
        }

        <span class="cov0" title="0">if tagsJSON.Valid </span><span class="cov0" title="0">{
                var tags []string
                if err := json.Unmarshal([]byte(tagsJSON.String), &amp;tags); err == nil </span><span class="cov0" title="0">{
                        favorite.Tags = &amp;tags
                }</span>
        }

        <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                favorite.UpdatedAt = &amp;updatedAt.Time
        }</span>

        <span class="cov0" title="0">return favorite, nil</span>
}

func (r *FavoritesRepository) UpdateFavorite(favorite *models.Favorite) error <span class="cov0" title="0">{
        query := `
                UPDATE favorites
                SET category = ?, notes = ?, tags = ?, is_public = ?, updated_at = ?
                WHERE id = ?
        `

        var tagsJSON *string
        if favorite.Tags != nil &amp;&amp; len(*favorite.Tags) &gt; 0 </span><span class="cov0" title="0">{
                data, err := json.Marshal(*favorite.Tags)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal tags: %w", err)
                }</span>
                <span class="cov0" title="0">tagsStr := string(data)
                tagsJSON = &amp;tagsStr</span>
        }

        <span class="cov0" title="0">_, err := r.db.Exec(query,
                favorite.Category, favorite.Notes, tagsJSON, favorite.IsPublic,
                favorite.UpdatedAt, favorite.ID)

        return err</span>
}

func (r *FavoritesRepository) DeleteFavorite(favoriteID int) error <span class="cov0" title="0">{
        query := `DELETE FROM favorites WHERE id = ?`
        _, err := r.db.Exec(query, favoriteID)
        return err
}</span>

func (r *FavoritesRepository) GetUserFavorites(userID int, entityType *string, category *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        whereClause := "WHERE user_id = ?"
        args := []interface{}{userID}

        if entityType != nil </span><span class="cov0" title="0">{
                whereClause += " AND entity_type = ?"
                args = append(args, *entityType)
        }</span>

        <span class="cov0" title="0">if category != nil </span><span class="cov0" title="0">{
                whereClause += " AND category = ?"
                args = append(args, *category)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                %s
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `, whereClause)

        args = append(args, limit, offset)

        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user favorites: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavorites(rows)</span>
}

func (r *FavoritesRepository) GetPublicFavorites(entityType *string, category *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        whereClause := "WHERE is_public = 1"
        args := []interface{}{}

        if entityType != nil </span><span class="cov0" title="0">{
                whereClause += " AND entity_type = ?"
                args = append(args, *entityType)
        }</span>

        <span class="cov0" title="0">if category != nil </span><span class="cov0" title="0">{
                whereClause += " AND category = ?"
                args = append(args, *category)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                %s
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `, whereClause)

        args = append(args, limit, offset)

        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get public favorites: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavorites(rows)</span>
}

func (r *FavoritesRepository) SearchFavorites(userID int, query string, entityType *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        searchPattern := "%" + query + "%"
        whereClause := "WHERE user_id = ? AND (notes LIKE ? OR tags LIKE ?)"
        args := []interface{}{userID, searchPattern, searchPattern}

        if entityType != nil </span><span class="cov0" title="0">{
                whereClause += " AND entity_type = ?"
                args = append(args, *entityType)
        }</span>

        <span class="cov0" title="0">sqlQuery := fmt.Sprintf(`
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                %s
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `, whereClause)

        args = append(args, limit, offset)

        rows, err := r.db.Query(sqlQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search favorites: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavorites(rows)</span>
}

func (r *FavoritesRepository) CountUserFavorites(userID int, entityType *string) (int, error) <span class="cov0" title="0">{
        whereClause := "WHERE user_id = ?"
        args := []interface{}{userID}

        if entityType != nil </span><span class="cov0" title="0">{
                whereClause += " AND entity_type = ?"
                args = append(args, *entityType)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf("SELECT COUNT(*) FROM favorites %s", whereClause)

        var count int
        err := r.db.QueryRow(query, args...).Scan(&amp;count)
        return count, err</span>
}

func (r *FavoritesRepository) GetFavoritesCountByEntityType(userID int) (map[string]int, error) <span class="cov0" title="0">{
        query := `
                SELECT entity_type, COUNT(*) as count
                FROM favorites
                WHERE user_id = ?
                GROUP BY entity_type
                ORDER BY count DESC
        `

        rows, err := r.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get favorites count by entity type: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        counts := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var entityType string
                var count int
                err := rows.Scan(&amp;entityType, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan entity type count: %w", err)
                }</span>
                <span class="cov0" title="0">counts[entityType] = count</span>
        }

        <span class="cov0" title="0">return counts, nil</span>
}

func (r *FavoritesRepository) GetFavoritesCountByCategory(userID int) (map[string]int, error) <span class="cov0" title="0">{
        query := `
                SELECT COALESCE(category, 'uncategorized') as category, COUNT(*) as count
                FROM favorites
                WHERE user_id = ?
                GROUP BY category
                ORDER BY count DESC
        `

        rows, err := r.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get favorites count by category: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        counts := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var category string
                var count int
                err := rows.Scan(&amp;category, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan category count: %w", err)
                }</span>
                <span class="cov0" title="0">counts[category] = count</span>
        }

        <span class="cov0" title="0">return counts, nil</span>
}

func (r *FavoritesRepository) GetRecentFavorites(userID int, limit int) ([]models.Favorite, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                WHERE user_id = ?
                ORDER BY created_at DESC
                LIMIT ?
        `

        rows, err := r.db.Query(query, userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent favorites: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavorites(rows)</span>
}

func (r *FavoritesRepository) GetSimilarFavorites(userID int, entityType string, limit int) ([]models.Favorite, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                WHERE user_id != ? AND entity_type = ? AND is_public = 1
                ORDER BY created_at DESC
                LIMIT ?
        `

        rows, err := r.db.Query(query, userID, entityType, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get similar favorites: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavorites(rows)</span>
}

func (r *FavoritesRepository) CreateFavoriteCategory(category *models.FavoriteCategory) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO favorite_categories (user_id, name, description, color, icon, is_public, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query,
                category.UserID, category.Name, category.Description, category.Color,
                category.Icon, category.IsPublic, category.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create favorite category: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get category ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *FavoritesRepository) GetFavoriteCategories(userID int, entityType *string) ([]models.FavoriteCategory, error) <span class="cov0" title="0">{
        whereClause := "WHERE user_id = ?"
        args := []interface{}{userID}

        if entityType != nil </span><span class="cov0" title="0">{
                whereClause += " AND entity_type = ?"
                args = append(args, *entityType)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT id, user_id, name, description, color, icon, is_public, created_at, updated_at
                FROM favorite_categories
                %s
                ORDER BY name ASC
        `, whereClause)

        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get favorite categories: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavoriteCategories(rows)</span>
}

func (r *FavoritesRepository) GetFavoriteCategoryByID(categoryID int) (*models.FavoriteCategory, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, description, color, icon, is_public, created_at, updated_at
                FROM favorite_categories
                WHERE id = ?
        `

        category := &amp;models.FavoriteCategory{}
        var updatedAt sql.NullTime

        err := r.db.QueryRow(query, categoryID).Scan(
                &amp;category.ID, &amp;category.UserID, &amp;category.Name, &amp;category.Description,
                &amp;category.Color, &amp;category.Icon, &amp;category.IsPublic, &amp;category.CreatedAt, &amp;updatedAt)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("category not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get category: %w", err)</span>
        }

        <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                category.UpdatedAt = &amp;updatedAt.Time
        }</span>

        <span class="cov0" title="0">return category, nil</span>
}

func (r *FavoritesRepository) UpdateFavoriteCategory(category *models.FavoriteCategory) error <span class="cov0" title="0">{
        query := `
                UPDATE favorite_categories
                SET name = ?, description = ?, color = ?, icon = ?, is_public = ?, updated_at = ?
                WHERE id = ?
        `

        _, err := r.db.Exec(query,
                category.Name, category.Description, category.Color, category.Icon,
                category.IsPublic, category.UpdatedAt, category.ID)

        return err
}</span>

func (r *FavoritesRepository) DeleteFavoriteCategory(categoryID int) error <span class="cov0" title="0">{
        query := `DELETE FROM favorite_categories WHERE id = ?`
        _, err := r.db.Exec(query, categoryID)
        return err
}</span>

func (r *FavoritesRepository) CountFavoritesByCategory(categoryID int) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM favorites WHERE category = (SELECT name FROM favorite_categories WHERE id = ?)`
        var count int
        err := r.db.QueryRow(query, categoryID).Scan(&amp;count)
        return count, err
}</span>

func (r *FavoritesRepository) CreateFavoriteShare(share *models.FavoriteShare) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO favorite_shares (favorite_id, shared_by_user, shared_with, permissions, created_at, is_active)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        sharedWithJSON, err := json.Marshal(share.SharedWith)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to marshal shared_with: %w", err)
        }</span>

        <span class="cov0" title="0">permissionsJSON, err := json.Marshal(share.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to marshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">result, err := r.db.Exec(query,
                share.FavoriteID, share.SharedByUser, string(sharedWithJSON),
                string(permissionsJSON), share.CreatedAt, share.IsActive)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create favorite share: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get share ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *FavoritesRepository) GetFavoriteShareByID(shareID int) (*models.FavoriteShare, error) <span class="cov0" title="0">{
        query := `
                SELECT id, favorite_id, shared_by_user, shared_with, permissions, created_at, is_active
                FROM favorite_shares
                WHERE id = ?
        `

        share := &amp;models.FavoriteShare{}
        var sharedWithJSON, permissionsJSON string

        err := r.db.QueryRow(query, shareID).Scan(
                &amp;share.ID, &amp;share.FavoriteID, &amp;share.SharedByUser, &amp;sharedWithJSON,
                &amp;permissionsJSON, &amp;share.CreatedAt, &amp;share.IsActive)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("share not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get share: %w", err)</span>
        }

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(sharedWithJSON), &amp;share.SharedWith); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal shared_with: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(permissionsJSON), &amp;share.Permissions); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">return share, nil</span>
}

func (r *FavoritesRepository) GetSharedFavorites(userID int, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        query := `
                SELECT f.id, f.user_id, f.entity_type, f.entity_id, f.category, f.notes, f.tags, f.is_public, f.created_at, f.updated_at
                FROM favorites f
                INNER JOIN favorite_shares fs ON f.id = fs.favorite_id
                WHERE JSON_EXTRACT(fs.shared_with, '$') LIKE ? AND fs.is_active = 1
                ORDER BY f.created_at DESC
                LIMIT ? OFFSET ?
        `

        userIDPattern := fmt.Sprintf("%%\"%d\"%%", userID)

        rows, err := r.db.Query(query, userIDPattern, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get shared favorites: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavorites(rows)</span>
}

func (r *FavoritesRepository) RevokeFavoriteShare(shareID int) error <span class="cov0" title="0">{
        query := `UPDATE favorite_shares SET is_active = 0 WHERE id = ?`
        _, err := r.db.Exec(query, shareID)
        return err
}</span>

func (r *FavoritesRepository) scanFavorites(rows *sql.Rows) ([]models.Favorite, error) <span class="cov0" title="0">{
        var favorites []models.Favorite

        for rows.Next() </span><span class="cov0" title="0">{
                var favorite models.Favorite
                var tagsJSON sql.NullString
                var updatedAt sql.NullTime

                err := rows.Scan(
                        &amp;favorite.ID, &amp;favorite.UserID, &amp;favorite.EntityType, &amp;favorite.EntityID,
                        &amp;favorite.Category, &amp;favorite.Notes, &amp;tagsJSON, &amp;favorite.IsPublic,
                        &amp;favorite.CreatedAt, &amp;updatedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan favorite: %w", err)
                }</span>

                <span class="cov0" title="0">if tagsJSON.Valid </span><span class="cov0" title="0">{
                        var tags []string
                        if err := json.Unmarshal([]byte(tagsJSON.String), &amp;tags); err == nil </span><span class="cov0" title="0">{
                                favorite.Tags = &amp;tags
                        }</span>
                }

                <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                        favorite.UpdatedAt = &amp;updatedAt.Time
                }</span>

                <span class="cov0" title="0">favorites = append(favorites, favorite)</span>
        }

        <span class="cov0" title="0">return favorites, nil</span>
}

func (r *FavoritesRepository) scanFavoriteCategories(rows *sql.Rows) ([]models.FavoriteCategory, error) <span class="cov0" title="0">{
        var categories []models.FavoriteCategory

        for rows.Next() </span><span class="cov0" title="0">{
                var category models.FavoriteCategory
                var updatedAt sql.NullTime

                err := rows.Scan(
                        &amp;category.ID, &amp;category.UserID, &amp;category.Name, &amp;category.Description,
                        &amp;category.Color, &amp;category.Icon, &amp;category.IsPublic, &amp;category.CreatedAt, &amp;updatedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan category: %w", err)
                }</span>

                <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                        category.UpdatedAt = &amp;updatedAt.Time
                }</span>

                <span class="cov0" title="0">categories = append(categories, category)</span>
        }

        <span class="cov0" title="0">return categories, nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "path/filepath"
        "strings"

        "catalogizer/database"
        "catalogizer/models"
)

// FileRepository handles file-related database operations
type FileRepository struct {
        db *database.DB
}

// NewFileRepository creates a new file repository
func NewFileRepository(db *database.DB) *FileRepository <span class="cov0" title="0">{
        return &amp;FileRepository{db: db}
}</span>

// GetFileByID retrieves a file by its ID
func (r *FileRepository) GetFileByID(ctx context.Context, id int64) (*models.FileWithMetadata, error) <span class="cov0" title="0">{
        query := `
                SELECT f.id, f.storage_root_id, sr.name as storage_root_name, f.path, f.name, f.extension,
                           f.mime_type, f.file_type, f.size, f.is_directory, f.created_at, f.modified_at,
                           f.accessed_at, f.deleted, f.deleted_at, f.last_scan_at, f.last_verified_at,
                           f.md5, f.sha256, f.sha1, f.blake3, f.quick_hash, f.is_duplicate,
                           f.duplicate_group_id, f.parent_id
                FROM files f
                JOIN storage_roots sr ON f.storage_root_id = sr.id
                WHERE f.id = ?`

        var file models.File
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;file.ID, &amp;file.StorageRootID, &amp;file.StorageRootName, &amp;file.Path, &amp;file.Name,
                &amp;file.Extension, &amp;file.MimeType, &amp;file.FileType, &amp;file.Size, &amp;file.IsDirectory,
                &amp;file.CreatedAt, &amp;file.ModifiedAt, &amp;file.AccessedAt, &amp;file.Deleted,
                &amp;file.DeletedAt, &amp;file.LastScanAt, &amp;file.LastVerifiedAt, &amp;file.MD5,
                &amp;file.SHA256, &amp;file.SHA1, &amp;file.BLAKE3, &amp;file.QuickHash, &amp;file.IsDuplicate,
                &amp;file.DuplicateGroupID, &amp;file.ParentID,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("file not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get file: %w", err)</span>
        }

        // Get metadata
        <span class="cov0" title="0">metadata, err := r.getFileMetadata(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file metadata: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;models.FileWithMetadata{
                File:     file,
                Metadata: metadata,
        }, nil</span>
}

// GetDirectoryContents retrieves files and directories within a path
func (r *FileRepository) GetDirectoryContents(ctx context.Context, storageRootName, path string, pagination models.PaginationOptions, sort models.SortOptions) (*models.SearchResult, error) <span class="cov0" title="0">{
        // Build the base query
        baseQuery := `
                FROM files f
                JOIN storage_roots sr ON f.storage_root_id = sr.id
                WHERE sr.name = ? AND f.deleted = FALSE`

        args := []interface{}{storageRootName}

        // Handle path filtering
        if path == "/" || path == "" </span><span class="cov0" title="0">{
                baseQuery += " AND f.parent_id IS NULL"
        }</span> else<span class="cov0" title="0"> {
                baseQuery += " AND f.path LIKE ?"
                args = append(args, path+"/%")
                // Ensure we only get direct children, not deeper descendants
                baseQuery += " AND f.path NOT LIKE ?"
                args = append(args, path+"/%/%")
        }</span>

        // Count total records
        <span class="cov0" title="0">countQuery := "SELECT COUNT(*) " + baseQuery
        var totalCount int64
        err := r.db.QueryRowContext(ctx, countQuery, args...).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count files: %w", err)
        }</span>

        // Build the main query with sorting and pagination
        <span class="cov0" title="0">selectQuery := `
                SELECT f.id, f.storage_root_id, sr.name as storage_root_name, f.path, f.name, f.extension,
                           f.mime_type, f.file_type, f.size, f.is_directory, f.created_at, f.modified_at,
                           f.accessed_at, f.deleted, f.deleted_at, f.last_scan_at, f.last_verified_at,
                           f.md5, f.sha256, f.sha1, f.blake3, f.quick_hash, f.is_duplicate,
                           f.duplicate_group_id, f.parent_id ` + baseQuery

        // Add sorting
        selectQuery += r.buildSortClause(sort)

        // Add pagination
        selectQuery += " LIMIT ? OFFSET ?"
        offset := (pagination.Page - 1) * pagination.Limit
        args = append(args, pagination.Limit, offset)

        rows, err := r.db.QueryContext(ctx, selectQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query files: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var files []models.FileWithMetadata
        for rows.Next() </span><span class="cov0" title="0">{
                var file models.File
                err := rows.Scan(
                        &amp;file.ID, &amp;file.StorageRootID, &amp;file.StorageRootName, &amp;file.Path, &amp;file.Name,
                        &amp;file.Extension, &amp;file.MimeType, &amp;file.FileType, &amp;file.Size, &amp;file.IsDirectory,
                        &amp;file.CreatedAt, &amp;file.ModifiedAt, &amp;file.AccessedAt, &amp;file.Deleted,
                        &amp;file.DeletedAt, &amp;file.LastScanAt, &amp;file.LastVerifiedAt, &amp;file.MD5,
                        &amp;file.SHA256, &amp;file.SHA1, &amp;file.BLAKE3, &amp;file.QuickHash, &amp;file.IsDuplicate,
                        &amp;file.DuplicateGroupID, &amp;file.ParentID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan file: %w", err)
                }</span>

                <span class="cov0" title="0">files = append(files, models.FileWithMetadata{File: file})</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating rows: %w", err)
        }</span>

        <span class="cov0" title="0">totalPages := int((totalCount + int64(pagination.Limit) - 1) / int64(pagination.Limit))

        return &amp;models.SearchResult{
                Files:      files,
                TotalCount: totalCount,
                Page:       pagination.Page,
                Limit:      pagination.Limit,
                TotalPages: totalPages,
        }, nil</span>
}

// SearchFiles performs advanced file search
func (r *FileRepository) SearchFiles(ctx context.Context, filter models.SearchFilter, pagination models.PaginationOptions, sort models.SortOptions) (*models.SearchResult, error) <span class="cov0" title="0">{
        // Build the base query
        baseQuery := `
                FROM files f
                JOIN storage_roots sr ON f.storage_root_id = sr.id
                WHERE 1=1`

        args := []interface{}{}

        // Apply filters
        baseQuery, args = r.applySearchFilters(baseQuery, args, filter)

        // Count total records
        countQuery := "SELECT COUNT(*) " + baseQuery
        var totalCount int64
        err := r.db.QueryRowContext(ctx, countQuery, args...).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count search results: %w", err)
        }</span>

        // Build the main query with sorting and pagination
        <span class="cov0" title="0">selectQuery := `
                SELECT f.id, f.storage_root_id, sr.name as storage_root_name, f.path, f.name, f.extension,
                           f.mime_type, f.file_type, f.size, f.is_directory, f.created_at, f.modified_at,
                           f.accessed_at, f.deleted, f.deleted_at, f.last_scan_at, f.last_verified_at,
                           f.md5, f.sha256, f.sha1, f.blake3, f.quick_hash, f.is_duplicate,
                           f.duplicate_group_id, f.parent_id ` + baseQuery

        // Add sorting
        selectQuery += r.buildSortClause(sort)

        // Add pagination
        selectQuery += " LIMIT ? OFFSET ?"
        offset := (pagination.Page - 1) * pagination.Limit
        args = append(args, pagination.Limit, offset)

        rows, err := r.db.QueryContext(ctx, selectQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute search query: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var files []models.FileWithMetadata
        for rows.Next() </span><span class="cov0" title="0">{
                var file models.File
                err := rows.Scan(
                        &amp;file.ID, &amp;file.StorageRootID, &amp;file.StorageRootName, &amp;file.Path, &amp;file.Name,
                        &amp;file.Extension, &amp;file.MimeType, &amp;file.FileType, &amp;file.Size, &amp;file.IsDirectory,
                        &amp;file.CreatedAt, &amp;file.ModifiedAt, &amp;file.AccessedAt, &amp;file.Deleted,
                        &amp;file.DeletedAt, &amp;file.LastScanAt, &amp;file.LastVerifiedAt, &amp;file.MD5,
                        &amp;file.SHA256, &amp;file.SHA1, &amp;file.BLAKE3, &amp;file.QuickHash, &amp;file.IsDuplicate,
                        &amp;file.DuplicateGroupID, &amp;file.ParentID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan search result: %w", err)
                }</span>

                // Get metadata for search results if needed
                <span class="cov0" title="0">metadata, err := r.getFileMetadata(ctx, file.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get file metadata: %w", err)
                }</span>

                <span class="cov0" title="0">files = append(files, models.FileWithMetadata{
                        File:     file,
                        Metadata: metadata,
                })</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating search results: %w", err)
        }</span>

        <span class="cov0" title="0">totalPages := int((totalCount + int64(pagination.Limit) - 1) / int64(pagination.Limit))

        return &amp;models.SearchResult{
                Files:      files,
                TotalCount: totalCount,
                Page:       pagination.Page,
                Limit:      pagination.Limit,
                TotalPages: totalPages,
        }, nil</span>
}

// GetDirectoriesSortedBySize retrieves directories sorted by total size
func (r *FileRepository) GetDirectoriesSortedBySize(ctx context.Context, storageRootName string, pagination models.PaginationOptions, ascending bool) ([]models.DirectoryInfo, error) <span class="cov0" title="0">{
        order := "DESC"
        if ascending </span><span class="cov0" title="0">{
                order = "ASC"
        }</span>

        <span class="cov0" title="0">query := `
                WITH RECURSIVE directory_tree AS (
                        SELECT f.path, f.name, sr.name as storage_root_name,
                                   COUNT(CASE WHEN f2.is_directory = FALSE THEN 1 END) as file_count,
                                   COUNT(CASE WHEN f2.is_directory = TRUE THEN 1 END) as directory_count,
                                   COALESCE(SUM(CASE WHEN f2.is_directory = FALSE THEN f2.size ELSE 0 END), 0) as total_size,
                                   COUNT(CASE WHEN f2.is_duplicate = TRUE THEN 1 END) as duplicate_count,
                                   MAX(f.modified_at) as modified_at
                        FROM files f
                        JOIN storage_roots sr ON f.storage_root_id = sr.id
                        LEFT JOIN files f2 ON f2.path LIKE f.path || '/%' AND f2.storage_root_id = f.storage_root_id AND f2.deleted = FALSE
                        WHERE f.is_directory = TRUE AND f.deleted = FALSE AND sr.name = ?
                        GROUP BY f.path, f.name, sr.name
                )
                SELECT path, name, storage_root_name, file_count, directory_count, total_size, duplicate_count, modified_at
                FROM directory_tree
                ORDER BY total_size ` + order + `
                LIMIT ? OFFSET ?`

        offset := (pagination.Page - 1) * pagination.Limit
        rows, err := r.db.QueryContext(ctx, query, storageRootName, pagination.Limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query directories by size: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var directories []models.DirectoryInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var dir models.DirectoryInfo
                err := rows.Scan(
                        &amp;dir.Path, &amp;dir.Name, &amp;dir.StorageRootName, &amp;dir.FileCount,
                        &amp;dir.DirectoryCount, &amp;dir.TotalSize, &amp;dir.DuplicateCount, &amp;dir.ModifiedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan directory info: %w", err)
                }</span>
                <span class="cov0" title="0">directories = append(directories, dir)</span>
        }

        <span class="cov0" title="0">return directories, nil</span>
}

// GetDirectoriesSortedByDuplicates retrieves directories sorted by duplicate count
func (r *FileRepository) GetDirectoriesSortedByDuplicates(ctx context.Context, storageRootName string, pagination models.PaginationOptions, ascending bool) ([]models.DirectoryInfo, error) <span class="cov0" title="0">{
        order := "DESC"
        if ascending </span><span class="cov0" title="0">{
                order = "ASC"
        }</span>

        <span class="cov0" title="0">query := `
                WITH RECURSIVE directory_tree AS (
                        SELECT f.path, f.name, sr.name as storage_root_name,
                                   COUNT(CASE WHEN f2.is_directory = FALSE THEN 1 END) as file_count,
                                   COUNT(CASE WHEN f2.is_directory = TRUE THEN 1 END) as directory_count,
                                   COALESCE(SUM(CASE WHEN f2.is_directory = FALSE THEN f2.size ELSE 0 END), 0) as total_size,
                                   COUNT(CASE WHEN f2.is_duplicate = TRUE THEN 1 END) as duplicate_count,
                                   MAX(f.modified_at) as modified_at
                        FROM files f
                        JOIN storage_roots sr ON f.storage_root_id = sr.id
                        LEFT JOIN files f2 ON f2.path LIKE f.path || '/%' AND f2.storage_root_id = f.storage_root_id AND f2.deleted = FALSE
                        WHERE f.is_directory = TRUE AND f.deleted = FALSE AND sr.name = ?
                        GROUP BY f.path, f.name, sr.name
                )
                SELECT path, name, storage_root_name, file_count, directory_count, total_size, duplicate_count, modified_at
                FROM directory_tree
                ORDER BY duplicate_count ` + order + `
                LIMIT ? OFFSET ?`

        offset := (pagination.Page - 1) * pagination.Limit
        rows, err := r.db.QueryContext(ctx, query, storageRootName, pagination.Limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query directories by duplicates: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var directories []models.DirectoryInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var dir models.DirectoryInfo
                err := rows.Scan(
                        &amp;dir.Path, &amp;dir.Name, &amp;dir.StorageRootName, &amp;dir.FileCount,
                        &amp;dir.DirectoryCount, &amp;dir.TotalSize, &amp;dir.DuplicateCount, &amp;dir.ModifiedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan directory info: %w", err)
                }</span>
                <span class="cov0" title="0">directories = append(directories, dir)</span>
        }

        <span class="cov0" title="0">return directories, nil</span>
}

// GetStorageRoots retrieves all storage roots
func (r *FileRepository) GetStorageRoots(ctx context.Context) ([]models.StorageRoot, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, protocol, host, port, path, username, password, domain,
                           mount_point, options, url, enabled, max_depth,
                           enable_duplicate_detection, enable_metadata_extraction, include_patterns,
                           exclude_patterns, created_at, updated_at, last_scan_at
                FROM storage_roots
                ORDER BY name`

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query storage roots: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var roots []models.StorageRoot
        for rows.Next() </span><span class="cov0" title="0">{
                var root models.StorageRoot
                err := rows.Scan(
                        &amp;root.ID, &amp;root.Name, &amp;root.Protocol, &amp;root.Host, &amp;root.Port, &amp;root.Path,
                        &amp;root.Username, &amp;root.Password, &amp;root.Domain, &amp;root.MountPoint, &amp;root.Options,
                        &amp;root.URL, &amp;root.Enabled, &amp;root.MaxDepth, &amp;root.EnableDuplicateDetection,
                        &amp;root.EnableMetadataExtraction, &amp;root.IncludePatterns, &amp;root.ExcludePatterns,
                        &amp;root.CreatedAt, &amp;root.UpdatedAt, &amp;root.LastScanAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan storage root: %w", err)
                }</span>
                <span class="cov0" title="0">roots = append(roots, root)</span>
        }

        <span class="cov0" title="0">return roots, nil</span>
}

// Helper methods

func (r *FileRepository) getFileMetadata(ctx context.Context, fileID int64) ([]models.FileMetadata, error) <span class="cov0" title="0">{
        query := `
                SELECT id, file_id, key, value, data_type
                FROM file_metadata
                WHERE file_id = ?
                ORDER BY key`

        rows, err := r.db.QueryContext(ctx, query, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query file metadata: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var metadata []models.FileMetadata
        for rows.Next() </span><span class="cov0" title="0">{
                var meta models.FileMetadata
                err := rows.Scan(&amp;meta.ID, &amp;meta.FileID, &amp;meta.Key, &amp;meta.Value, &amp;meta.DataType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan metadata: %w", err)
                }</span>
                <span class="cov0" title="0">metadata = append(metadata, meta)</span>
        }

        <span class="cov0" title="0">return metadata, nil</span>
}

func (r *FileRepository) buildSortClause(sort models.SortOptions) string <span class="cov0" title="0">{
        var clause strings.Builder
        clause.WriteString(" ORDER BY ")

        switch sort.Field </span>{
        case "name":<span class="cov0" title="0">
                clause.WriteString("f.name")</span>
        case "size":<span class="cov0" title="0">
                clause.WriteString("f.size")</span>
        case "modified_at":<span class="cov0" title="0">
                clause.WriteString("f.modified_at")</span>
        case "created_at":<span class="cov0" title="0">
                clause.WriteString("f.created_at")</span>
        case "path":<span class="cov0" title="0">
                clause.WriteString("f.path")</span>
        case "extension":<span class="cov0" title="0">
                clause.WriteString("f.extension")</span>
        default:<span class="cov0" title="0">
                clause.WriteString("f.name")</span> // Default sort
        }

        <span class="cov0" title="0">if sort.Order == "desc" </span><span class="cov0" title="0">{
                clause.WriteString(" DESC")
        }</span> else<span class="cov0" title="0"> {
                clause.WriteString(" ASC")
        }</span>

        <span class="cov0" title="0">return clause.String()</span>
}

func (r *FileRepository) applySearchFilters(baseQuery string, args []interface{}, filter models.SearchFilter) (string, []interface{}) <span class="cov0" title="0">{
        if !filter.IncludeDeleted </span><span class="cov0" title="0">{
                baseQuery += " AND f.deleted = FALSE"
        }</span>

        <span class="cov0" title="0">if filter.Query != "" </span><span class="cov0" title="0">{
                baseQuery += " AND (f.name LIKE ? OR f.path LIKE ?)"
                searchPattern := "%" + filter.Query + "%"
                args = append(args, searchPattern, searchPattern)
        }</span>

        <span class="cov0" title="0">if filter.Path != "" </span><span class="cov0" title="0">{
                baseQuery += " AND f.path LIKE ?"
                args = append(args, "%"+filter.Path+"%")
        }</span>

        <span class="cov0" title="0">if filter.Name != "" </span><span class="cov0" title="0">{
                baseQuery += " AND f.name LIKE ?"
                args = append(args, "%"+filter.Name+"%")
        }</span>

        <span class="cov0" title="0">if filter.Extension != "" </span><span class="cov0" title="0">{
                baseQuery += " AND f.extension = ?"
                args = append(args, filter.Extension)
        }</span>

        <span class="cov0" title="0">if filter.FileType != "" </span><span class="cov0" title="0">{
                baseQuery += " AND f.file_type = ?"
                args = append(args, filter.FileType)
        }</span>

        <span class="cov0" title="0">if filter.MimeType != "" </span><span class="cov0" title="0">{
                baseQuery += " AND f.mime_type = ?"
                args = append(args, filter.MimeType)
        }</span>

        <span class="cov0" title="0">if len(filter.StorageRoots) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := strings.Repeat("?,", len(filter.StorageRoots))
                placeholders = placeholders[:len(placeholders)-1] // Remove trailing comma
                baseQuery += " AND sr.name IN (" + placeholders + ")"
                for _, root := range filter.StorageRoots </span><span class="cov0" title="0">{
                        args = append(args, root)
                }</span>
        }

        <span class="cov0" title="0">if filter.MinSize != nil </span><span class="cov0" title="0">{
                baseQuery += " AND f.size &gt;= ?"
                args = append(args, *filter.MinSize)
        }</span>

        <span class="cov0" title="0">if filter.MaxSize != nil </span><span class="cov0" title="0">{
                baseQuery += " AND f.size &lt;= ?"
                args = append(args, *filter.MaxSize)
        }</span>

        <span class="cov0" title="0">if filter.ModifiedAfter != nil </span><span class="cov0" title="0">{
                baseQuery += " AND f.modified_at &gt;= ?"
                args = append(args, *filter.ModifiedAfter)
        }</span>

        <span class="cov0" title="0">if filter.ModifiedBefore != nil </span><span class="cov0" title="0">{
                baseQuery += " AND f.modified_at &lt;= ?"
                args = append(args, *filter.ModifiedBefore)
        }</span>

        <span class="cov0" title="0">if filter.OnlyDuplicates </span><span class="cov0" title="0">{
                baseQuery += " AND f.is_duplicate = TRUE"
        }</span> else<span class="cov0" title="0"> if filter.ExcludeDuplicates </span><span class="cov0" title="0">{
                baseQuery += " AND f.is_duplicate = FALSE"
        }</span>

        <span class="cov0" title="0">if !filter.IncludeDirectories </span><span class="cov0" title="0">{
                baseQuery += " AND f.is_directory = FALSE"
        }</span>

        <span class="cov0" title="0">return baseQuery, args</span>
}

// UpdateFilePath updates a file's path and related metadata efficiently
func (r *FileRepository) UpdateFilePath(ctx context.Context, fileID int64, newPath string) error <span class="cov0" title="0">{
        // Extract new filename and directory info
        newName := filepath.Base(newPath)
        newDir := filepath.Dir(newPath)

        // Get parent directory ID
        var parentID *int64
        if newDir != "/" &amp;&amp; newDir != "." </span><span class="cov0" title="0">{
                parentQuery := `SELECT id FROM files WHERE path = ? AND is_directory = true LIMIT 1`
                err := r.db.QueryRowContext(ctx, parentQuery, newDir).Scan(&amp;parentID)
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get parent directory: %w", err)
                }</span>
        }

        // Update file record
        <span class="cov0" title="0">updateQuery := `
                UPDATE files
                SET path = ?, name = ?, parent_id = ?, modified_at = CURRENT_TIMESTAMP,
                    last_scan_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := r.db.ExecContext(ctx, updateQuery, newPath, newName, parentID, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update file path: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateDirectoryPaths updates a directory and all its children paths efficiently
func (r *FileRepository) UpdateDirectoryPaths(ctx context.Context, oldPath, newPath, storageRootName string) error <span class="cov0" title="0">{
        // Get all files/directories that need to be updated
        query := `
                SELECT id, path, is_directory
                FROM files
                WHERE storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)
                  AND (path = ? OR path LIKE ?)
                ORDER BY LENGTH(path) ASC` // Process parents before children

        oldPathPattern := oldPath + "/%"
        rows, err := r.db.QueryContext(ctx, query, storageRootName, oldPath, oldPathPattern)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query directory contents: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        type fileUpdate struct {
                ID          int64
                OldPath     string
                IsDirectory bool
        }

        var updates []fileUpdate
        for rows.Next() </span><span class="cov0" title="0">{
                var update fileUpdate
                if err := rows.Scan(&amp;update.ID, &amp;update.OldPath, &amp;update.IsDirectory); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan file for update: %w", err)
                }</span>
                <span class="cov0" title="0">updates = append(updates, update)</span>
        }

        // Update each file/directory path
        <span class="cov0" title="0">for _, update := range updates </span><span class="cov0" title="0">{
                var updatedPath string
                if update.OldPath == oldPath </span><span class="cov0" title="0">{
                        // This is the directory itself
                        updatedPath = newPath
                }</span> else<span class="cov0" title="0"> {
                        // This is a child - replace the old path prefix with new path
                        relativePath := update.OldPath[len(oldPath):]
                        updatedPath = newPath + relativePath
                }</span>

                // Update the file record using the existing method
                <span class="cov0" title="0">if err := r.UpdateFilePath(ctx, update.ID, updatedPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update path for file ID %d: %w", update.ID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetFileByPathAndStorage retrieves a file by path and storage root
func (r *FileRepository) GetFileByPathAndStorage(ctx context.Context, path, storageRootName string) (*models.File, error) <span class="cov0" title="0">{
        query := `
                SELECT f.id, f.storage_root_id, sr.name as storage_root_name, f.path, f.name, f.extension,
                       f.mime_type, f.file_type, f.size, f.is_directory, f.created_at, f.modified_at,
                       f.accessed_at, f.deleted, f.deleted_at, f.last_scan_at, f.last_verified_at,
                       f.md5, f.sha256, f.sha1, f.blake3, f.quick_hash, f.is_duplicate,
                       f.duplicate_group_id, f.parent_id
                FROM files f
                JOIN storage_roots sr ON f.storage_root_id = sr.id
                WHERE f.path = ? AND sr.name = ?`

        var file models.File
        err := r.db.QueryRowContext(ctx, query, path, storageRootName).Scan(
                &amp;file.ID, &amp;file.StorageRootID, &amp;file.StorageRootName, &amp;file.Path, &amp;file.Name,
                &amp;file.Extension, &amp;file.MimeType, &amp;file.FileType, &amp;file.Size, &amp;file.IsDirectory,
                &amp;file.CreatedAt, &amp;file.ModifiedAt, &amp;file.AccessedAt, &amp;file.Deleted,
                &amp;file.DeletedAt, &amp;file.LastScanAt, &amp;file.LastVerifiedAt, &amp;file.MD5,
                &amp;file.SHA256, &amp;file.SHA1, &amp;file.BLAKE3, &amp;file.QuickHash, &amp;file.IsDuplicate,
                &amp;file.DuplicateGroupID, &amp;file.ParentID,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get file: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;file, nil</span>
}

// MarkFileAsDeleted marks a file as deleted instead of removing it immediately
func (r *FileRepository) MarkFileAsDeleted(ctx context.Context, fileID int64) error <span class="cov0" title="0">{
        query := `
                UPDATE files
                SET deleted = true, deleted_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := r.db.ExecContext(ctx, query, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark file as deleted: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RestoreDeletedFile restores a file that was marked as deleted
func (r *FileRepository) RestoreDeletedFile(ctx context.Context, fileID int64) error <span class="cov0" title="0">{
        query := `
                UPDATE files
                SET deleted = false, deleted_at = NULL, last_scan_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := r.db.ExecContext(ctx, query, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restore deleted file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFilesWithHash finds files by their hash for duplicate detection and move tracking
func (r *FileRepository) GetFilesWithHash(ctx context.Context, hash string, storageRootName string) ([]models.File, error) <span class="cov0" title="0">{
        query := `
                SELECT f.id, f.storage_root_id, sr.name as storage_root_name, f.path, f.name, f.extension,
                       f.mime_type, f.file_type, f.size, f.is_directory, f.created_at, f.modified_at,
                       f.accessed_at, f.deleted, f.deleted_at, f.last_scan_at, f.last_verified_at,
                       f.md5, f.sha256, f.sha1, f.blake3, f.quick_hash, f.is_duplicate,
                       f.duplicate_group_id, f.parent_id
                FROM files f
                JOIN storage_roots sr ON f.storage_root_id = sr.id
                WHERE (f.md5 = ? OR f.sha256 = ? OR f.sha1 = ? OR f.blake3 = ? OR f.quick_hash = ?)
                  AND sr.name = ?
                  AND f.deleted = false`

        rows, err := r.db.QueryContext(ctx, query, hash, hash, hash, hash, hash, storageRootName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query files by hash: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var files []models.File
        for rows.Next() </span><span class="cov0" title="0">{
                var file models.File
                err := rows.Scan(
                        &amp;file.ID, &amp;file.StorageRootID, &amp;file.StorageRootName, &amp;file.Path, &amp;file.Name,
                        &amp;file.Extension, &amp;file.MimeType, &amp;file.FileType, &amp;file.Size, &amp;file.IsDirectory,
                        &amp;file.CreatedAt, &amp;file.ModifiedAt, &amp;file.AccessedAt, &amp;file.Deleted,
                        &amp;file.DeletedAt, &amp;file.LastScanAt, &amp;file.LastVerifiedAt, &amp;file.MD5,
                        &amp;file.SHA256, &amp;file.SHA1, &amp;file.BLAKE3, &amp;file.QuickHash, &amp;file.IsDuplicate,
                        &amp;file.DuplicateGroupID, &amp;file.ParentID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan file: %w", err)
                }</span>
                <span class="cov0" title="0">files = append(files, file)</span>
        }

        <span class="cov0" title="0">return files, nil</span>
}

// UpdateFileMetadata updates file metadata without triggering a full rescan
func (r *FileRepository) UpdateFileMetadata(ctx context.Context, fileID int64, size int64, hash *string) error <span class="cov0" title="0">{
        query := `
                UPDATE files
                SET size = ?, quick_hash = ?, last_scan_at = CURRENT_TIMESTAMP, modified_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := r.db.ExecContext(ctx, query, size, hash, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update file metadata: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
)

type LogManagementRepository struct {
        db *sql.DB
}

func NewLogManagementRepository(db *sql.DB) *LogManagementRepository <span class="cov0" title="0">{
        return &amp;LogManagementRepository{db: db}
}</span>

func (r *LogManagementRepository) CreateLogCollection(collection *models.LogCollection) error <span class="cov0" title="0">{
        componentsJSON, err := json.Marshal(collection.Components)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal components: %w", err)
        }</span>

        <span class="cov0" title="0">filtersJSON, err := json.Marshal(collection.Filters)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal filters: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO log_collections (
                        user_id, name, description, components, log_level, start_time,
                        end_time, created_at, status, filters
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                collection.UserID, collection.Name, collection.Description,
                string(componentsJSON), collection.LogLevel, collection.StartTime,
                collection.EndTime, collection.CreatedAt, collection.Status,
                string(filtersJSON))

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log collection: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">collection.ID = int(id)
        return nil</span>
}

func (r *LogManagementRepository) GetLogCollection(id int) (*models.LogCollection, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, description, components, log_level, start_time,
                           end_time, created_at, completed_at, status, entry_count, filters
                FROM log_collections WHERE id = ?`

        var collection models.LogCollection
        var componentsJSON, filtersJSON string
        var startTime, endTime, completedAt sql.NullTime

        err := r.db.QueryRow(query, id).Scan(
                &amp;collection.ID, &amp;collection.UserID, &amp;collection.Name,
                &amp;collection.Description, &amp;componentsJSON, &amp;collection.LogLevel,
                &amp;startTime, &amp;endTime, &amp;collection.CreatedAt, &amp;completedAt,
                &amp;collection.Status, &amp;collection.EntryCount, &amp;filtersJSON)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log collection: %w", err)
        }</span>

        <span class="cov0" title="0">if startTime.Valid </span><span class="cov0" title="0">{
                collection.StartTime = &amp;startTime.Time
        }</span>
        <span class="cov0" title="0">if endTime.Valid </span><span class="cov0" title="0">{
                collection.EndTime = &amp;endTime.Time
        }</span>
        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                collection.CompletedAt = &amp;completedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(componentsJSON), &amp;collection.Components); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal components: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(filtersJSON), &amp;collection.Filters); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal filters: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;collection, nil</span>
}

func (r *LogManagementRepository) UpdateLogCollection(collection *models.LogCollection) error <span class="cov0" title="0">{
        componentsJSON, err := json.Marshal(collection.Components)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal components: %w", err)
        }</span>

        <span class="cov0" title="0">filtersJSON, err := json.Marshal(collection.Filters)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal filters: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE log_collections SET
                        name = ?, description = ?, components = ?, log_level = ?,
                        start_time = ?, end_time = ?, completed_at = ?, status = ?,
                        entry_count = ?, filters = ?
                WHERE id = ?`

        _, err = r.db.Exec(query,
                collection.Name, collection.Description, string(componentsJSON),
                collection.LogLevel, collection.StartTime, collection.EndTime,
                collection.CompletedAt, collection.Status, collection.EntryCount,
                string(filtersJSON), collection.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update log collection: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *LogManagementRepository) GetLogCollectionsByUser(userID int, limit, offset int) ([]*models.LogCollection, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, description, components, log_level, start_time,
                           end_time, created_at, completed_at, status, entry_count, filters
                FROM log_collections
                WHERE user_id = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?`

        rows, err := r.db.Query(query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log collections: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var collections []*models.LogCollection
        for rows.Next() </span><span class="cov0" title="0">{
                var collection models.LogCollection
                var componentsJSON, filtersJSON string
                var startTime, endTime, completedAt sql.NullTime

                err := rows.Scan(
                        &amp;collection.ID, &amp;collection.UserID, &amp;collection.Name,
                        &amp;collection.Description, &amp;componentsJSON, &amp;collection.LogLevel,
                        &amp;startTime, &amp;endTime, &amp;collection.CreatedAt, &amp;completedAt,
                        &amp;collection.Status, &amp;collection.EntryCount, &amp;filtersJSON)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan log collection: %w", err)
                }</span>

                <span class="cov0" title="0">if startTime.Valid </span><span class="cov0" title="0">{
                        collection.StartTime = &amp;startTime.Time
                }</span>
                <span class="cov0" title="0">if endTime.Valid </span><span class="cov0" title="0">{
                        collection.EndTime = &amp;endTime.Time
                }</span>
                <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                        collection.CompletedAt = &amp;completedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(componentsJSON), &amp;collection.Components); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal components: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(filtersJSON), &amp;collection.Filters); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal filters: %w", err)
                }</span>

                <span class="cov0" title="0">collections = append(collections, &amp;collection)</span>
        }

        <span class="cov0" title="0">return collections, nil</span>
}

func (r *LogManagementRepository) DeleteLogCollection(id int) error <span class="cov0" title="0">{
        // First delete associated log entries
        if err := r.DeleteLogEntriesByCollection(id); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete log entries: %w", err)
        }</span>

        <span class="cov0" title="0">query := "DELETE FROM log_collections WHERE id = ?"
        _, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete log collection: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *LogManagementRepository) CreateLogEntry(entry *models.LogEntry) error <span class="cov0" title="0">{
        contextJSON, err := json.Marshal(entry.Context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal context: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO log_entries (
                        collection_id, timestamp, level, component, message, context
                ) VALUES (?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                entry.CollectionID, entry.Timestamp, entry.Level,
                entry.Component, entry.Message, string(contextJSON))

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log entry: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">entry.ID = int(id)
        return nil</span>
}

func (r *LogManagementRepository) GetLogEntries(collectionID int, filters *models.LogEntryFilters) ([]*models.LogEntry, error) <span class="cov0" title="0">{
        query := `
                SELECT id, collection_id, timestamp, level, component, message, context
                FROM log_entries
                WHERE collection_id = ?`

        args := []interface{}{collectionID}

        if filters != nil </span><span class="cov0" title="0">{
                if filters.Level != "" </span><span class="cov0" title="0">{
                        query += " AND level = ?"
                        args = append(args, filters.Level)
                }</span>

                <span class="cov0" title="0">if filters.Component != "" </span><span class="cov0" title="0">{
                        query += " AND component = ?"
                        args = append(args, filters.Component)
                }</span>

                <span class="cov0" title="0">if filters.StartTime != nil </span><span class="cov0" title="0">{
                        query += " AND timestamp &gt;= ?"
                        args = append(args, *filters.StartTime)
                }</span>

                <span class="cov0" title="0">if filters.EndTime != nil </span><span class="cov0" title="0">{
                        query += " AND timestamp &lt;= ?"
                        args = append(args, *filters.EndTime)
                }</span>

                <span class="cov0" title="0">if filters.Search != "" </span><span class="cov0" title="0">{
                        query += " AND message LIKE ?"
                        args = append(args, "%"+filters.Search+"%")
                }</span>
        }

        <span class="cov0" title="0">query += " ORDER BY timestamp ASC"

        if filters != nil &amp;&amp; filters.Limit &gt; 0 </span><span class="cov0" title="0">{
                query += " LIMIT ?"
                args = append(args, filters.Limit)

                if filters.Offset &gt; 0 </span><span class="cov0" title="0">{
                        query += " OFFSET ?"
                        args = append(args, filters.Offset)
                }</span>
        }

        <span class="cov0" title="0">rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log entries: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var entries []*models.LogEntry
        for rows.Next() </span><span class="cov0" title="0">{
                var entry models.LogEntry
                var contextJSON string

                err := rows.Scan(
                        &amp;entry.ID, &amp;entry.CollectionID, &amp;entry.Timestamp,
                        &amp;entry.Level, &amp;entry.Component, &amp;entry.Message, &amp;contextJSON)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan log entry: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;entry.Context); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal context: %w", err)
                }</span>

                <span class="cov0" title="0">entries = append(entries, &amp;entry)</span>
        }

        <span class="cov0" title="0">return entries, nil</span>
}

func (r *LogManagementRepository) DeleteLogEntriesByCollection(collectionID int) error <span class="cov0" title="0">{
        query := "DELETE FROM log_entries WHERE collection_id = ?"
        _, err := r.db.Exec(query, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete log entries: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *LogManagementRepository) GetRecentLogEntries(component string, limit int) ([]*models.LogEntry, error) <span class="cov0" title="0">{
        query := `
                SELECT id, collection_id, timestamp, level, component, message, context
                FROM log_entries
                WHERE component = ?
                ORDER BY timestamp DESC
                LIMIT ?`

        rows, err := r.db.Query(query, component, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent log entries: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var entries []*models.LogEntry
        for rows.Next() </span><span class="cov0" title="0">{
                var entry models.LogEntry
                var contextJSON string

                err := rows.Scan(
                        &amp;entry.ID, &amp;entry.CollectionID, &amp;entry.Timestamp,
                        &amp;entry.Level, &amp;entry.Component, &amp;entry.Message, &amp;contextJSON)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan log entry: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;entry.Context); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal context: %w", err)
                }</span>

                <span class="cov0" title="0">entries = append(entries, &amp;entry)</span>
        }

        <span class="cov0" title="0">return entries, nil</span>
}

func (r *LogManagementRepository) CreateLogShare(share *models.LogShare) error <span class="cov0" title="0">{
        permissionsJSON, err := json.Marshal(share.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">recipientsJSON, err := json.Marshal(share.Recipients)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal recipients: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO log_shares (
                        collection_id, user_id, share_token, share_type, expires_at,
                        created_at, is_active, permissions, recipients
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                share.CollectionID, share.UserID, share.ShareToken, share.ShareType,
                share.ExpiresAt, share.CreatedAt, share.IsActive,
                string(permissionsJSON), string(recipientsJSON))

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log share: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">share.ID = int(id)
        return nil</span>
}

func (r *LogManagementRepository) GetLogShare(id int) (*models.LogShare, error) <span class="cov0" title="0">{
        query := `
                SELECT id, collection_id, user_id, share_token, share_type, expires_at,
                           created_at, accessed_at, is_active, permissions, recipients
                FROM log_shares WHERE id = ?`

        var share models.LogShare
        var permissionsJSON, recipientsJSON string
        var accessedAt sql.NullTime

        err := r.db.QueryRow(query, id).Scan(
                &amp;share.ID, &amp;share.CollectionID, &amp;share.UserID, &amp;share.ShareToken,
                &amp;share.ShareType, &amp;share.ExpiresAt, &amp;share.CreatedAt, &amp;accessedAt,
                &amp;share.IsActive, &amp;permissionsJSON, &amp;recipientsJSON)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log share: %w", err)
        }</span>

        <span class="cov0" title="0">if accessedAt.Valid </span><span class="cov0" title="0">{
                share.AccessedAt = &amp;accessedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(permissionsJSON), &amp;share.Permissions); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(recipientsJSON), &amp;share.Recipients); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal recipients: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;share, nil</span>
}

func (r *LogManagementRepository) GetLogShareByToken(token string) (*models.LogShare, error) <span class="cov0" title="0">{
        query := `
                SELECT id, collection_id, user_id, share_token, share_type, expires_at,
                           created_at, accessed_at, is_active, permissions, recipients
                FROM log_shares WHERE share_token = ?`

        var share models.LogShare
        var permissionsJSON, recipientsJSON string
        var accessedAt sql.NullTime

        err := r.db.QueryRow(query, token).Scan(
                &amp;share.ID, &amp;share.CollectionID, &amp;share.UserID, &amp;share.ShareToken,
                &amp;share.ShareType, &amp;share.ExpiresAt, &amp;share.CreatedAt, &amp;accessedAt,
                &amp;share.IsActive, &amp;permissionsJSON, &amp;recipientsJSON)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log share by token: %w", err)
        }</span>

        <span class="cov0" title="0">if accessedAt.Valid </span><span class="cov0" title="0">{
                share.AccessedAt = &amp;accessedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(permissionsJSON), &amp;share.Permissions); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(recipientsJSON), &amp;share.Recipients); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal recipients: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;share, nil</span>
}

func (r *LogManagementRepository) UpdateLogShare(share *models.LogShare) error <span class="cov0" title="0">{
        permissionsJSON, err := json.Marshal(share.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">recipientsJSON, err := json.Marshal(share.Recipients)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal recipients: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE log_shares SET
                        share_type = ?, expires_at = ?, accessed_at = ?, is_active = ?,
                        permissions = ?, recipients = ?
                WHERE id = ?`

        _, err = r.db.Exec(query,
                share.ShareType, share.ExpiresAt, share.AccessedAt, share.IsActive,
                string(permissionsJSON), string(recipientsJSON), share.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update log share: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *LogManagementRepository) GetLogSharesByUser(userID int) ([]*models.LogShare, error) <span class="cov0" title="0">{
        query := `
                SELECT id, collection_id, user_id, share_token, share_type, expires_at,
                           created_at, accessed_at, is_active, permissions, recipients
                FROM log_shares
                WHERE user_id = ?
                ORDER BY created_at DESC`

        rows, err := r.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log shares: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var shares []*models.LogShare
        for rows.Next() </span><span class="cov0" title="0">{
                var share models.LogShare
                var permissionsJSON, recipientsJSON string
                var accessedAt sql.NullTime

                err := rows.Scan(
                        &amp;share.ID, &amp;share.CollectionID, &amp;share.UserID, &amp;share.ShareToken,
                        &amp;share.ShareType, &amp;share.ExpiresAt, &amp;share.CreatedAt, &amp;accessedAt,
                        &amp;share.IsActive, &amp;permissionsJSON, &amp;recipientsJSON)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan log share: %w", err)
                }</span>

                <span class="cov0" title="0">if accessedAt.Valid </span><span class="cov0" title="0">{
                        share.AccessedAt = &amp;accessedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(permissionsJSON), &amp;share.Permissions); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal permissions: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(recipientsJSON), &amp;share.Recipients); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal recipients: %w", err)
                }</span>

                <span class="cov0" title="0">shares = append(shares, &amp;share)</span>
        }

        <span class="cov0" title="0">return shares, nil</span>
}

func (r *LogManagementRepository) CleanupOldCollections(olderThan time.Time) error <span class="cov0" title="0">{
        query := "DELETE FROM log_collections WHERE created_at &lt; ?"
        _, err := r.db.Exec(query, olderThan)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old collections: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *LogManagementRepository) CleanupExpiredShares() error <span class="cov0" title="0">{
        query := "UPDATE log_shares SET is_active = 0 WHERE expires_at &lt; datetime('now') AND is_active = 1"
        _, err := r.db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup expired shares: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *LogManagementRepository) GetLogStatistics(userID int) (*models.LogStatistics, error) <span class="cov0" title="0">{
        stats := &amp;models.LogStatistics{}

        // Total collections
        err := r.db.QueryRow("SELECT COUNT(*) FROM log_collections WHERE user_id = ?", userID).Scan(&amp;stats.TotalCollections)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total collections: %w", err)
        }</span>

        // Total entries
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COALESCE(SUM(lc.entry_count), 0)
                FROM log_collections lc
                WHERE lc.user_id = ?`, userID).Scan(&amp;stats.TotalEntries)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total entries: %w", err)
        }</span>

        // Active shares
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM log_shares
                WHERE user_id = ? AND is_active = 1 AND expires_at &gt; datetime('now')`, userID).Scan(&amp;stats.ActiveShares)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active shares: %w", err)
        }</span>

        // Collections by status
        <span class="cov0" title="0">statusQuery := `
                SELECT status, COUNT(*)
                FROM log_collections
                WHERE user_id = ?
                GROUP BY status`

        rows, err := r.db.Query(statusQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get status counts: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        stats.CollectionsByStatus = make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var status string
                var count int
                if err := rows.Scan(&amp;status, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan status count: %w", err)
                }</span>
                <span class="cov0" title="0">stats.CollectionsByStatus[status] = count</span>
        }

        // Recent collections (last 7 days)
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM log_collections
                WHERE user_id = ? AND created_at &gt; datetime('now', '-7 days')`, userID).Scan(&amp;stats.RecentCollections)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent collections: %w", err)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "catalogizer/database"
        "catalogizer/internal/models"
)

// StatsRepository handles statistics-related database operations
type StatsRepository struct {
        db *database.DB
}

// NewStatsRepository creates a new stats repository
func NewStatsRepository(db *database.DB) *StatsRepository <span class="cov0" title="0">{
        return &amp;StatsRepository{db: db}
}</span>

// GetOverallStats retrieves overall catalog statistics
func (r *StatsRepository) GetOverallStats(ctx context.Context) (*models.OverallStats, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        COUNT(CASE WHEN is_directory = 0 AND deleted = 0 THEN 1 END) as total_files,
                        COUNT(CASE WHEN is_directory = 1 AND deleted = 0 THEN 1 END) as total_directories,
                        COALESCE(SUM(CASE WHEN is_directory = 0 AND deleted = 0 THEN size ELSE 0 END), 0) as total_size,
                        COUNT(CASE WHEN is_duplicate = 1 AND deleted = 0 THEN 1 END) as total_duplicates,
                        COUNT(DISTINCT duplicate_group_id) as duplicate_groups,
                        (SELECT COUNT(*) FROM storage_roots) as storage_roots_count,
                        (SELECT COUNT(*) FROM storage_roots WHERE enabled = 1) as active_storage_roots,
                        COALESCE(MAX(last_scan_at), 0) as last_scan_time
                FROM files`

        var stats models.OverallStats
        err := r.db.QueryRowContext(ctx, query).Scan(
                &amp;stats.TotalFiles,
                &amp;stats.TotalDirectories,
                &amp;stats.TotalSize,
                &amp;stats.TotalDuplicates,
                &amp;stats.DuplicateGroups,
                &amp;stats.StorageRootsCount,
                &amp;stats.ActiveStorageRoots,
                &amp;stats.LastScanTime,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get overall stats: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;stats, nil</span>
}

// GetStorageRootStats retrieves statistics for a specific storage root
func (r *StatsRepository) GetStorageRootStats(ctx context.Context, storageRootName string) (*models.StorageRootStats, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        sr.name,
                        COUNT(CASE WHEN f.is_directory = 0 AND f.deleted = 0 THEN 1 END) as total_files,
                        COUNT(CASE WHEN f.is_directory = 1 AND f.deleted = 0 THEN 1 END) as total_directories,
                        COALESCE(SUM(CASE WHEN f.is_directory = 0 AND f.deleted = 0 THEN f.size ELSE 0 END), 0) as total_size,
                        COUNT(CASE WHEN f.is_duplicate = 1 AND f.deleted = 0 THEN 1 END) as duplicate_files,
                        COUNT(DISTINCT f.duplicate_group_id) as duplicate_groups,
                        COALESCE(MAX(f.last_scan_at), 0) as last_scan_time,
                        sr.enabled as is_online
                FROM storage_roots sr
                LEFT JOIN files f ON sr.id = f.storage_root_id
                WHERE sr.name = ?
                GROUP BY sr.id, sr.name, sr.enabled`

        var stats models.StorageRootStats
        err := r.db.QueryRowContext(ctx, query, storageRootName).Scan(
                &amp;stats.Name,
                &amp;stats.TotalFiles,
                &amp;stats.TotalDirectories,
                &amp;stats.TotalSize,
                &amp;stats.DuplicateFiles,
                &amp;stats.DuplicateGroups,
                &amp;stats.LastScanTime,
                &amp;stats.IsOnline,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("storage root not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get storage root stats: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;stats, nil</span>
}

// GetFileTypeStats retrieves file type statistics
func (r *StatsRepository) GetFileTypeStats(ctx context.Context, storageRootName string, limit int) ([]models.FileTypeStats, error) <span class="cov0" title="0">{
        baseQuery := `
                SELECT
                        COALESCE(file_type, 'unknown') as file_type,
                        COALESCE(extension, 'none') as extension,
                        COUNT(*) as count,
                        SUM(size) as total_size,
                        AVG(size) as average_size
                FROM files f`

        args := []interface{}{}
        whereClause := " WHERE f.is_directory = 0 AND f.deleted = 0"

        if storageRootName != "" </span><span class="cov0" title="0">{
                whereClause += " AND f.smb_root_id = (SELECT id FROM smb_roots WHERE name = ?)"
                args = append(args, storageRootName)
        }</span>

        <span class="cov0" title="0">query := baseQuery + whereClause + `
                GROUP BY file_type, extension
                ORDER BY count DESC
                LIMIT ?`

        args = append(args, limit)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file type stats: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var stats []models.FileTypeStats
        for rows.Next() </span><span class="cov0" title="0">{
                var stat models.FileTypeStats
                err := rows.Scan(
                        &amp;stat.FileType,
                        &amp;stat.Extension,
                        &amp;stat.Count,
                        &amp;stat.TotalSize,
                        &amp;stat.AverageSize,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan file type stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats = append(stats, stat)</span>
        }

        <span class="cov0" title="0">return stats, nil</span>
}

// GetSizeDistribution retrieves file size distribution
func (r *StatsRepository) GetSizeDistribution(ctx context.Context, storageRootName string) (*models.SizeDistribution, error) <span class="cov0" title="0">{
        baseQuery := `
                SELECT
                        COUNT(CASE WHEN size = 0 THEN 1 END) as empty,
                        COUNT(CASE WHEN size &gt; 0 AND size &lt; 1024 THEN 1 END) as tiny,
                        COUNT(CASE WHEN size &gt;= 1024 AND size &lt; 1048576 THEN 1 END) as small,
                        COUNT(CASE WHEN size &gt;= 1048576 AND size &lt; 10485760 THEN 1 END) as medium,
                        COUNT(CASE WHEN size &gt;= 10485760 AND size &lt; 104857600 THEN 1 END) as large,
                        COUNT(CASE WHEN size &gt;= 104857600 AND size &lt; 1073741824 THEN 1 END) as huge,
                        COUNT(CASE WHEN size &gt;= 1073741824 THEN 1 END) as massive
                FROM files f`

        args := []interface{}{}
        whereClause := " WHERE f.is_directory = 0 AND f.deleted = 0"

        if storageRootName != "" </span><span class="cov0" title="0">{
                whereClause += " AND f.smb_root_id = (SELECT id FROM smb_roots WHERE name = ?)"
                args = append(args, storageRootName)
        }</span>

        <span class="cov0" title="0">query := baseQuery + whereClause

        var distribution models.SizeDistribution
        var empty int64
        err := r.db.QueryRowContext(ctx, query, args...).Scan(
                &amp;empty,
                &amp;distribution.Tiny,
                &amp;distribution.Small,
                &amp;distribution.Medium,
                &amp;distribution.Large,
                &amp;distribution.Huge,
                &amp;distribution.Massive,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get size distribution: %w", err)
        }</span>

        // Add empty files to tiny category
        <span class="cov0" title="0">distribution.Tiny += empty

        return &amp;distribution, nil</span>
}

// GetDuplicateStats retrieves duplicate file statistics
func (r *StatsRepository) GetDuplicateStats(ctx context.Context, storageRootName string) (*models.DuplicateStats, error) <span class="cov0" title="0">{
        baseQuery := `
                WITH duplicate_analysis AS (
                        SELECT
                                duplicate_group_id,
                                COUNT(*) as group_size,
                                MAX(size) as file_size
                        FROM files f
                        WHERE f.is_duplicate = 1 AND f.deleted = 0`

        args := []interface{}{}
        if storageRootName != "" </span><span class="cov0" title="0">{
                args = append(args, storageRootName)
        }</span>

        <span class="cov0" title="0">baseQuery += `
                        GROUP BY duplicate_group_id
                )
                SELECT
                        (SELECT COUNT(*) FROM files f WHERE f.is_duplicate = 1 AND f.deleted = 0` +
                (func() string </span><span class="cov0" title="0">{
                        if storageRootName != "" </span><span class="cov0" title="0">{
                                return " AND f.storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)"
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                })() + `) as total_duplicates,
                        COUNT(*) as duplicate_groups,
                        COALESCE(SUM((group_size - 1) * file_size), 0) as wasted_space,
                        COALESCE(MAX(group_size), 0) as largest_group,
                        COALESCE(AVG(group_size), 0) as average_group_size
                FROM duplicate_analysis`

        <span class="cov0" title="0">if storageRootName != "" </span><span class="cov0" title="0">{
                args = append(args, storageRootName) // For the subquery
        }</span>

        <span class="cov0" title="0">var stats models.DuplicateStats
        err := r.db.QueryRowContext(ctx, baseQuery, args...).Scan(
                &amp;stats.TotalDuplicates,
                &amp;stats.DuplicateGroups,
                &amp;stats.WastedSpace,
                &amp;stats.LargestDuplicateGroup,
                &amp;stats.AverageGroupSize,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get duplicate stats: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;stats, nil</span>
}

// GetTopDuplicateGroups retrieves the top duplicate groups
func (r *StatsRepository) GetTopDuplicateGroups(ctx context.Context, sortBy string, limit int, storageRootName string) ([]models.DuplicateGroupStats, error) <span class="cov0" title="0">{
        baseQuery := `
                SELECT
                        dg.id as group_id,
                        dg.file_count,
                        dg.total_size,
                        (dg.file_count - 1) * (dg.total_size / dg.file_count) as wasted_space,
                        (SELECT f.path FROM files f WHERE f.duplicate_group_id = dg.id AND f.deleted = 0 LIMIT 1) as sample_path
                FROM duplicate_groups dg`

        args := []interface{}{}
        whereClause := ""

        if storageRootName != "" </span><span class="cov0" title="0">{
                whereClause = ` WHERE EXISTS (
                        SELECT 1 FROM files f
                        WHERE f.duplicate_group_id = dg.id
                        AND f.storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)
                )`
                args = append(args, storageRootName)
        }</span>

        <span class="cov0" title="0">orderClause := " ORDER BY "
        if sortBy == "size" </span><span class="cov0" title="0">{
                orderClause += "dg.total_size DESC"
        }</span> else<span class="cov0" title="0"> {
                orderClause += "dg.file_count DESC"
        }</span>

        <span class="cov0" title="0">query := baseQuery + whereClause + orderClause + " LIMIT ?"
        args = append(args, limit)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top duplicate groups: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var groups []models.DuplicateGroupStats
        for rows.Next() </span><span class="cov0" title="0">{
                var group models.DuplicateGroupStats
                err := rows.Scan(
                        &amp;group.GroupID,
                        &amp;group.FileCount,
                        &amp;group.TotalSize,
                        &amp;group.WastedSpace,
                        &amp;group.SamplePath,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan duplicate group: %w", err)
                }</span>
                <span class="cov0" title="0">groups = append(groups, group)</span>
        }

        <span class="cov0" title="0">return groups, nil</span>
}

// GetAccessPatterns retrieves file access patterns
func (r *StatsRepository) GetAccessPatterns(ctx context.Context, storageRootName string, days int) (*models.AccessPatterns, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        // In a real scenario, you'd need to track actual access times
        baseQuery := `
                SELECT
                        COUNT(CASE WHEN accessed_at IS NOT NULL AND accessed_at &gt; ? THEN 1 END) as recently_accessed,
                        COUNT(CASE WHEN accessed_at IS NULL THEN 1 END) as never_accessed
                FROM files f`

        args := []interface{}{time.Now().AddDate(0, 0, -days).Unix()}
        whereClause := " WHERE f.is_directory = 0 AND f.deleted = 0"

        if storageRootName != "" </span><span class="cov0" title="0">{
                whereClause += " AND f.storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)"
                args = append(args, storageRootName)
        }</span>

        <span class="cov0" title="0">query := baseQuery + whereClause

        var patterns models.AccessPatterns
        err := r.db.QueryRowContext(ctx, query, args...).Scan(
                &amp;patterns.RecentlyAccessed,
                &amp;patterns.NeverAccessed,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get access patterns: %w", err)
        }</span>

        // Initialize arrays with default values
        <span class="cov0" title="0">patterns.AccessFrequency = make([]int64, days)
        patterns.PopularExtensions = []string{}
        patterns.PopularDirectories = []string{}

        return &amp;patterns, nil</span>
}

// GetGrowthTrends retrieves storage growth trends
func (r *StatsRepository) GetGrowthTrends(ctx context.Context, storageRootName string, months int) (*models.GrowthTrends, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        // In a real scenario, you'd need historical data tracking
        baseQuery := `
                SELECT
                        strftime('%Y-%m', datetime(created_at, 'unixepoch')) as month,
                        COUNT(*) as files_added,
                        SUM(size) as size_added
                FROM files f`

        args := []interface{}{}
        whereClause := " WHERE f.is_directory = 0 AND f.deleted = 0 AND created_at &gt; ?"

        monthsAgo := time.Now().AddDate(0, -months, 0).Unix()
        args = append(args, monthsAgo)

        if storageRootName != "" </span><span class="cov0" title="0">{
                whereClause += " AND f.storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)"
                args = append(args, storageRootName)
        }</span>

        <span class="cov0" title="0">query := baseQuery + whereClause + " GROUP BY month ORDER BY month"

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get growth trends: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var trends models.GrowthTrends
        var monthlyGrowth []models.MonthlyGrowth

        for rows.Next() </span><span class="cov0" title="0">{
                var growth models.MonthlyGrowth
                err := rows.Scan(
                        &amp;growth.Month,
                        &amp;growth.FilesAdded,
                        &amp;growth.SizeAdded,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan growth trend: %w", err)
                }</span>
                <span class="cov0" title="0">monthlyGrowth = append(monthlyGrowth, growth)</span>
        }

        <span class="cov0" title="0">trends.MonthlyGrowth = monthlyGrowth
        trends.TotalGrowthRate = 0.0 // Calculate based on data
        trends.FileGrowthRate = 0.0  // Calculate based on data
        trends.SizeGrowthRate = 0.0  // Calculate based on data

        return &amp;trends, nil</span>
}

// GetScanHistory retrieves scan operation history
func (r *StatsRepository) GetScanHistory(ctx context.Context, storageRootName string, limit, offset int) ([]models.ScanHistoryItem, int64, error) <span class="cov0" title="0">{
        countQuery := `
                SELECT COUNT(*)
                FROM scan_history sh
                JOIN storage_roots sr ON sh.storage_root_id = sr.id`

        selectQuery := `
                SELECT
                        sh.id,
                        sr.name as storage_root_name,
                        sh.scan_type,
                        sh.status,
                        sh.start_time,
                        sh.end_time,
                        sh.files_processed,
                        sh.files_added,
                        sh.files_updated,
                        sh.files_deleted,
                        sh.error_count,
                        sh.error_message
                FROM scan_history sh
                JOIN storage_roots sr ON sh.storage_root_id = sr.id`

        args := []interface{}{}
        whereClause := ""

        if storageRootName != "" </span><span class="cov0" title="0">{
                whereClause += " AND f.storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)"
                args = append(args, storageRootName)
        }</span>

        // Get total count
        <span class="cov0" title="0">var totalCount int64
        err := r.db.QueryRowContext(ctx, countQuery+whereClause, args...).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to count scan history: %w", err)
        }</span>

        // Get paginated results
        <span class="cov0" title="0">query := selectQuery + whereClause + " ORDER BY sh.start_time DESC LIMIT ? OFFSET ?"
        args = append(args, limit, offset)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get scan history: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var history []models.ScanHistoryItem
        for rows.Next() </span><span class="cov0" title="0">{
                var item models.ScanHistoryItem
                err := rows.Scan(
                        &amp;item.ID,
                        &amp;item.SmbRootName,
                        &amp;item.ScanType,
                        &amp;item.Status,
                        &amp;item.StartTime,
                        &amp;item.EndTime,
                        &amp;item.FilesProcessed,
                        &amp;item.FilesAdded,
                        &amp;item.FilesUpdated,
                        &amp;item.FilesDeleted,
                        &amp;item.ErrorCount,
                        &amp;item.ErrorMessage,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to scan history item: %w", err)
                }</span>
                <span class="cov0" title="0">history = append(history, item)</span>
        }

        <span class="cov0" title="0">return history, totalCount, nil</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
)

type StressTestRepository struct {
        db *sql.DB
}

func NewStressTestRepository(db *sql.DB) *StressTestRepository <span class="cov0" title="0">{
        return &amp;StressTestRepository{db: db}
}</span>

func (r *StressTestRepository) CreateStressTest(test *models.StressTest) error <span class="cov0" title="0">{
        scenariosJSON, err := json.Marshal(test.Scenarios)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal scenarios: %w", err)
        }</span>

        <span class="cov0" title="0">configJSON, err := json.Marshal(test.Configuration)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO stress_tests (
                        name, description, type, status, scenarios, configuration,
                        concurrent_users, duration_seconds, ramp_up_time, created_by, created_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                test.Name, test.Description, test.Type, test.Status,
                string(scenariosJSON), string(configJSON),
                test.ConcurrentUsers, test.DurationSeconds, test.RampUpTime,
                test.CreatedBy, test.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stress test: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">test.ID = id
        return nil</span>
}

func (r *StressTestRepository) GetStressTest(id int) (*models.StressTest, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, type, status, scenarios, configuration,
                           concurrent_users, duration_seconds, ramp_up_time, created_by,
                           created_at, started_at, completed_at
                FROM stress_tests WHERE id = ?`

        var test models.StressTest
        var scenariosJSON, configJSON string
        var startedAt, completedAt sql.NullTime

        err := r.db.QueryRow(query, id).Scan(
                &amp;test.ID, &amp;test.Name, &amp;test.Description, &amp;test.Type, &amp;test.Status,
                &amp;scenariosJSON, &amp;configJSON, &amp;test.ConcurrentUsers,
                &amp;test.DurationSeconds, &amp;test.RampUpTime, &amp;test.CreatedBy,
                &amp;test.CreatedAt, &amp;startedAt, &amp;completedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get stress test: %w", err)
        }</span>

        <span class="cov0" title="0">if startedAt.Valid </span><span class="cov0" title="0">{
                test.StartedAt = &amp;startedAt.Time
        }</span>
        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                test.CompletedAt = &amp;completedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(scenariosJSON), &amp;test.Scenarios); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal scenarios: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(configJSON), &amp;test.Configuration); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;test, nil</span>
}

func (r *StressTestRepository) UpdateStressTest(test *models.StressTest) error <span class="cov0" title="0">{
        scenariosJSON, err := json.Marshal(test.Scenarios)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal scenarios: %w", err)
        }</span>

        <span class="cov0" title="0">configJSON, err := json.Marshal(test.Configuration)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE stress_tests SET
                        name = ?, description = ?, type = ?, status = ?,
                        scenarios = ?, configuration = ?, concurrent_users = ?,
                        duration_seconds = ?, ramp_up_time = ?, started_at = ?, completed_at = ?
                WHERE id = ?`

        _, err = r.db.Exec(query,
                test.Name, test.Description, test.Type, test.Status,
                string(scenariosJSON), string(configJSON),
                test.ConcurrentUsers, test.DurationSeconds, test.RampUpTime,
                test.StartedAt, test.CompletedAt, test.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update stress test: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *StressTestRepository) GetStressTestsByUser(userID int, limit, offset int) ([]*models.StressTest, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, type, status, scenarios, configuration,
                           concurrent_users, duration_seconds, ramp_up_time, created_by,
                           created_at, started_at, completed_at
                FROM stress_tests
                WHERE created_by = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?`

        rows, err := r.db.Query(query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get stress tests: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tests []*models.StressTest
        for rows.Next() </span><span class="cov0" title="0">{
                var test models.StressTest
                var scenariosJSON, configJSON string
                var startedAt, completedAt sql.NullTime

                err := rows.Scan(
                        &amp;test.ID, &amp;test.Name, &amp;test.Description, &amp;test.Type, &amp;test.Status,
                        &amp;scenariosJSON, &amp;configJSON, &amp;test.ConcurrentUsers,
                        &amp;test.DurationSeconds, &amp;test.RampUpTime, &amp;test.CreatedBy,
                        &amp;test.CreatedAt, &amp;startedAt, &amp;completedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan stress test: %w", err)
                }</span>

                <span class="cov0" title="0">if startedAt.Valid </span><span class="cov0" title="0">{
                        test.StartedAt = &amp;startedAt.Time
                }</span>
                <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                        test.CompletedAt = &amp;completedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(scenariosJSON), &amp;test.Scenarios); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal scenarios: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(configJSON), &amp;test.Configuration); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
                }</span>

                <span class="cov0" title="0">tests = append(tests, &amp;test)</span>
        }

        <span class="cov0" title="0">return tests, nil</span>
}

func (r *StressTestRepository) DeleteStressTest(id int) error <span class="cov0" title="0">{
        // First delete associated executions
        if err := r.DeleteExecutionsByTestID(id); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete test executions: %w", err)
        }</span>

        <span class="cov0" title="0">query := "DELETE FROM stress_tests WHERE id = ?"
        _, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete stress test: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *StressTestRepository) CreateExecution(execution *models.StressTestExecution) error <span class="cov0" title="0">{
        metricsJSON, err := json.Marshal(execution.Metrics)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metrics: %w", err)
        }</span>

        <span class="cov0" title="0">resultsJSON, err := json.Marshal(execution.Results)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal results: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO stress_test_executions (
                        stress_test_id, status, started_at, metrics, results, error_message
                ) VALUES (?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                execution.StressTestID, execution.Status, execution.StartedAt,
                string(metricsJSON), string(resultsJSON), execution.ErrorMessage)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create execution: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">execution.ID = id
        return nil</span>
}

func (r *StressTestRepository) UpdateExecution(execution *models.StressTestExecution) error <span class="cov0" title="0">{
        metricsJSON, err := json.Marshal(execution.Metrics)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metrics: %w", err)
        }</span>

        <span class="cov0" title="0">resultsJSON, err := json.Marshal(execution.Results)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal results: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE stress_test_executions SET
                        status = ?, completed_at = ?, metrics = ?, results = ?, error_message = ?
                WHERE id = ?`

        _, err = r.db.Exec(query,
                execution.Status, execution.CompletedAt,
                string(metricsJSON), string(resultsJSON),
                execution.ErrorMessage, execution.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update execution: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *StressTestRepository) GetExecution(id int) (*models.StressTestExecution, error) <span class="cov0" title="0">{
        query := `
                SELECT id, stress_test_id, status, started_at, completed_at,
                           metrics, results, error_message
                FROM stress_test_executions WHERE id = ?`

        var execution models.StressTestExecution
        var metricsJSON, resultsJSON string
        var completedAt sql.NullTime

        err := r.db.QueryRow(query, id).Scan(
                &amp;execution.ID, &amp;execution.StressTestID, &amp;execution.Status,
                &amp;execution.StartedAt, &amp;completedAt,
                &amp;metricsJSON, &amp;resultsJSON, &amp;execution.ErrorMessage)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get execution: %w", err)
        }</span>

        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                execution.CompletedAt = &amp;completedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(metricsJSON), &amp;execution.Metrics); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal metrics: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(resultsJSON), &amp;execution.Results); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal results: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;execution, nil</span>
}

func (r *StressTestRepository) GetExecutionsByTestID(testID int) ([]*models.StressTestExecution, error) <span class="cov0" title="0">{
        query := `
                SELECT id, stress_test_id, status, started_at, completed_at,
                           metrics, results, error_message
                FROM stress_test_executions
                WHERE stress_test_id = ?
                ORDER BY started_at DESC`

        rows, err := r.db.Query(query, testID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get executions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var executions []*models.StressTestExecution
        for rows.Next() </span><span class="cov0" title="0">{
                var execution models.StressTestExecution
                var metricsJSON, resultsJSON string
                var completedAt sql.NullTime

                err := rows.Scan(
                        &amp;execution.ID, &amp;execution.StressTestID, &amp;execution.Status,
                        &amp;execution.StartedAt, &amp;completedAt,
                        &amp;metricsJSON, &amp;resultsJSON, &amp;execution.ErrorMessage)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan execution: %w", err)
                }</span>

                <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                        execution.CompletedAt = &amp;completedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(metricsJSON), &amp;execution.Metrics); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal metrics: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(resultsJSON), &amp;execution.Results); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal results: %w", err)
                }</span>

                <span class="cov0" title="0">executions = append(executions, &amp;execution)</span>
        }

        <span class="cov0" title="0">return executions, nil</span>
}

func (r *StressTestRepository) DeleteExecutionsByTestID(testID int) error <span class="cov0" title="0">{
        query := "DELETE FROM stress_test_executions WHERE stress_test_id = ?"
        _, err := r.db.Exec(query, testID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete executions: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *StressTestRepository) GetStatistics(userID int) (*models.StressTestStatistics, error) <span class="cov0" title="0">{
        stats := &amp;models.StressTestStatistics{}

        // Total tests
        err := r.db.QueryRow("SELECT COUNT(*) FROM stress_tests WHERE created_by = ?", userID).Scan(&amp;stats.TotalTests)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total tests: %w", err)
        }</span>

        // Tests by status
        <span class="cov0" title="0">statusQuery := `
                SELECT status, COUNT(*)
                FROM stress_tests
                WHERE created_by = ?
                GROUP BY status`

        rows, err := r.db.Query(statusQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get status counts: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        stats.TestsByStatus = make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var status string
                var count int
                if err := rows.Scan(&amp;status, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan status count: %w", err)
                }</span>
                <span class="cov0" title="0">stats.TestsByStatus[status] = count</span>
        }

        // Total executions
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM stress_test_executions ste
                JOIN stress_tests st ON ste.stress_test_id = st.id
                WHERE st.created_by = ?`, userID).Scan(&amp;stats.TotalExecutions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total executions: %w", err)
        }</span>

        // Average execution duration
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT AVG(
                        CASE
                                WHEN ste.completed_at IS NOT NULL
                                THEN (julianday(ste.completed_at) - julianday(ste.started_at)) * 24 * 60 * 60
                                ELSE NULL
                        END
                )
                FROM stress_test_executions ste
                JOIN stress_tests st ON ste.stress_test_id = st.id
                WHERE st.created_by = ? AND ste.completed_at IS NOT NULL`, userID).Scan(&amp;stats.AvgExecutionDuration)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get average duration: %w", err)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (r *StressTestRepository) CleanupOldExecutions(olderThan time.Time) error <span class="cov0" title="0">{
        query := "DELETE FROM stress_test_executions WHERE started_at &lt; ?"
        _, err := r.db.Exec(query, olderThan)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old executions: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Wrapper methods to match service expectations
func (r *StressTestRepository) CreateTest(test *models.StressTest) (int64, error) <span class="cov0" title="0">{
        err := r.CreateStressTest(test)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return test.ID, nil</span>
}

func (r *StressTestRepository) GetTest(id int) (*models.StressTest, error) <span class="cov0" title="0">{
        return r.GetStressTest(id)
}</span>

func (r *StressTestRepository) UpdateTest(test *models.StressTest) error <span class="cov0" title="0">{
        return r.UpdateStressTest(test)
}</span>

func (r *StressTestRepository) GetUserTests(userID int, limit, offset int) ([]*models.StressTest, error) <span class="cov0" title="0">{
        return r.GetStressTestsByUser(userID, limit, offset)
}</span>

func (r *StressTestRepository) DeleteTest(id int) error <span class="cov0" title="0">{
        return r.DeleteStressTest(id)
}</span>

func (r *StressTestRepository) SaveResult(result *models.StressTestResult) error <span class="cov0" title="0">{
        // This would need a table for results, but for now just return nil
        return nil
}</span>

func (r *StressTestRepository) GetResult(testID int) (*models.StressTestResult, error) <span class="cov0" title="0">{
        // This would need a table for results, but for now return nil
        return nil, fmt.Errorf("not implemented")
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package repository

import (
        "database/sql"
        "fmt"
        "time"

        "catalogizer/models"
)

type SyncRepository struct {
        db *sql.DB
}

func NewSyncRepository(db *sql.DB) *SyncRepository <span class="cov0" title="0">{
        return &amp;SyncRepository{db: db}
}</span>

func (r *SyncRepository) CreateEndpoint(endpoint *models.SyncEndpoint) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO sync_endpoints (user_id, name, type, url, username, password, sync_direction,
                                                                   local_path, remote_path, sync_settings, status, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query,
                endpoint.UserID, endpoint.Name, endpoint.Type, endpoint.URL, endpoint.Username,
                endpoint.Password, endpoint.SyncDirection, endpoint.LocalPath, endpoint.RemotePath,
                endpoint.SyncSettings, endpoint.Status, endpoint.CreatedAt, endpoint.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create sync endpoint: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get endpoint ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *SyncRepository) GetEndpoint(endpointID int) (*models.SyncEndpoint, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, type, url, username, password, sync_direction,
                           local_path, remote_path, sync_settings, status, created_at, updated_at, last_sync_at
                FROM sync_endpoints
                WHERE id = ?
        `

        endpoint := &amp;models.SyncEndpoint{}
        var syncSettings sql.NullString
        var lastSyncAt sql.NullTime

        err := r.db.QueryRow(query, endpointID).Scan(
                &amp;endpoint.ID, &amp;endpoint.UserID, &amp;endpoint.Name, &amp;endpoint.Type, &amp;endpoint.URL,
                &amp;endpoint.Username, &amp;endpoint.Password, &amp;endpoint.SyncDirection, &amp;endpoint.LocalPath,
                &amp;endpoint.RemotePath, &amp;syncSettings, &amp;endpoint.Status, &amp;endpoint.CreatedAt,
                &amp;endpoint.UpdatedAt, &amp;lastSyncAt)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("endpoint not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get endpoint: %w", err)</span>
        }

        <span class="cov0" title="0">if syncSettings.Valid </span><span class="cov0" title="0">{
                endpoint.SyncSettings = &amp;syncSettings.String
        }</span>

        <span class="cov0" title="0">if lastSyncAt.Valid </span><span class="cov0" title="0">{
                endpoint.LastSyncAt = &amp;lastSyncAt.Time
        }</span>

        <span class="cov0" title="0">return endpoint, nil</span>
}

func (r *SyncRepository) UpdateEndpoint(endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        query := `
                UPDATE sync_endpoints
                SET name = ?, type = ?, url = ?, username = ?, password = ?, sync_direction = ?,
                        local_path = ?, remote_path = ?, sync_settings = ?, status = ?, updated_at = ?, last_sync_at = ?
                WHERE id = ?
        `

        var lastSyncAt sql.NullTime
        if endpoint.LastSyncAt != nil </span><span class="cov0" title="0">{
                lastSyncAt = sql.NullTime{Time: *endpoint.LastSyncAt, Valid: true}
        }</span>

        <span class="cov0" title="0">_, err := r.db.Exec(query,
                endpoint.Name, endpoint.Type, endpoint.URL, endpoint.Username, endpoint.Password,
                endpoint.SyncDirection, endpoint.LocalPath, endpoint.RemotePath, endpoint.SyncSettings,
                endpoint.Status, endpoint.UpdatedAt, lastSyncAt, endpoint.ID)

        return err</span>
}

func (r *SyncRepository) DeleteEndpoint(endpointID int) error <span class="cov0" title="0">{
        query := `DELETE FROM sync_endpoints WHERE id = ?`
        _, err := r.db.Exec(query, endpointID)
        return err
}</span>

func (r *SyncRepository) GetUserEndpoints(userID int) ([]models.SyncEndpoint, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, type, url, username, password, sync_direction,
                           local_path, remote_path, sync_settings, status, created_at, updated_at, last_sync_at
                FROM sync_endpoints
                WHERE user_id = ?
                ORDER BY created_at DESC
        `

        rows, err := r.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user endpoints: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanEndpoints(rows)</span>
}

func (r *SyncRepository) CreateSession(session *models.SyncSession) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO sync_sessions (endpoint_id, user_id, status, sync_type, started_at,
                                                                  total_files, synced_files, failed_files, skipped_files)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query,
                session.EndpointID, session.UserID, session.Status, session.SyncType, session.StartedAt,
                session.TotalFiles, session.SyncedFiles, session.FailedFiles, session.SkippedFiles)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create sync session: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get session ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *SyncRepository) GetSession(sessionID int) (*models.SyncSession, error) <span class="cov0" title="0">{
        query := `
                SELECT id, endpoint_id, user_id, status, sync_type, started_at, completed_at,
                           duration, total_files, synced_files, failed_files, skipped_files, error_message
                FROM sync_sessions
                WHERE id = ?
        `

        session := &amp;models.SyncSession{}
        var completedAt sql.NullTime
        var durationSeconds sql.NullInt64
        var errorMessage sql.NullString

        err := r.db.QueryRow(query, sessionID).Scan(
                &amp;session.ID, &amp;session.EndpointID, &amp;session.UserID, &amp;session.Status, &amp;session.SyncType,
                &amp;session.StartedAt, &amp;completedAt, &amp;durationSeconds, &amp;session.TotalFiles,
                &amp;session.SyncedFiles, &amp;session.FailedFiles, &amp;session.SkippedFiles, &amp;errorMessage)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("session not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get session: %w", err)</span>
        }

        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                session.CompletedAt = &amp;completedAt.Time
        }</span>

        <span class="cov0" title="0">if durationSeconds.Valid </span><span class="cov0" title="0">{
                duration := time.Duration(durationSeconds.Int64) * time.Second
                session.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">if errorMessage.Valid </span><span class="cov0" title="0">{
                session.ErrorMessage = &amp;errorMessage.String
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (r *SyncRepository) UpdateSession(session *models.SyncSession) error <span class="cov0" title="0">{
        query := `
                UPDATE sync_sessions
                SET status = ?, completed_at = ?, duration = ?, total_files = ?, synced_files = ?,
                        failed_files = ?, skipped_files = ?, error_message = ?, updated_at = ?
                WHERE id = ?
        `

        var completedAt sql.NullTime
        var durationSeconds sql.NullInt64
        var errorMessage sql.NullString

        if session.CompletedAt != nil </span><span class="cov0" title="0">{
                completedAt = sql.NullTime{Time: *session.CompletedAt, Valid: true}
        }</span>

        <span class="cov0" title="0">if session.Duration != nil </span><span class="cov0" title="0">{
                durationSeconds = sql.NullInt64{Int64: int64(session.Duration.Seconds()), Valid: true}
        }</span>

        <span class="cov0" title="0">if session.ErrorMessage != nil </span><span class="cov0" title="0">{
                errorMessage = sql.NullString{String: *session.ErrorMessage, Valid: true}
        }</span>

        <span class="cov0" title="0">_, err := r.db.Exec(query,
                session.Status, completedAt, durationSeconds, session.TotalFiles, session.SyncedFiles,
                session.FailedFiles, session.SkippedFiles, errorMessage, time.Now(), session.ID)

        return err</span>
}

func (r *SyncRepository) GetUserSessions(userID int, limit, offset int) ([]models.SyncSession, error) <span class="cov0" title="0">{
        query := `
                SELECT id, endpoint_id, user_id, status, sync_type, started_at, completed_at,
                           duration, total_files, synced_files, failed_files, skipped_files, error_message
                FROM sync_sessions
                WHERE user_id = ?
                ORDER BY started_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.Query(query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user sessions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanSessions(rows)</span>
}

func (r *SyncRepository) CreateSchedule(schedule *models.SyncSchedule) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO sync_schedules (endpoint_id, user_id, frequency, is_active, created_at)
                VALUES (?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query,
                schedule.EndpointID, schedule.UserID, schedule.Frequency, schedule.IsActive, schedule.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create sync schedule: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get schedule ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *SyncRepository) GetActiveSchedules() ([]models.SyncSchedule, error) <span class="cov0" title="0">{
        query := `
                SELECT id, endpoint_id, user_id, frequency, last_run, next_run, is_active, created_at
                FROM sync_schedules
                WHERE is_active = 1
                ORDER BY next_run ASC
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active schedules: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanSchedules(rows)</span>
}

func (r *SyncRepository) GetStatistics(userID *int, startDate, endDate time.Time) (*models.SyncStatistics, error) <span class="cov0" title="0">{
        whereClause := "WHERE started_at BETWEEN ? AND ?"
        args := []interface{}{startDate, endDate}

        if userID != nil </span><span class="cov0" title="0">{
                whereClause += " AND user_id = ?"
                args = append(args, *userID)
        }</span>

        // Get session counts by status
        <span class="cov0" title="0">statusQuery := fmt.Sprintf(`
                SELECT status, COUNT(*) as count
                FROM sync_sessions
                %s
                GROUP BY status
        `, whereClause)

        statusRows, err := r.db.Query(statusQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get status statistics: %w", err)
        }</span>
        <span class="cov0" title="0">defer statusRows.Close()

        stats := &amp;models.SyncStatistics{
                StartDate: startDate,
                EndDate:   endDate,
                ByStatus:  make(map[string]int),
                ByType:    make(map[string]int),
        }

        for statusRows.Next() </span><span class="cov0" title="0">{
                var status string
                var count int
                err := statusRows.Scan(&amp;status, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan status stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ByStatus[status] = count
                stats.TotalSessions += count</span>
        }

        // Get session counts by sync type
        <span class="cov0" title="0">typeQuery := fmt.Sprintf(`
                SELECT sync_type, COUNT(*) as count
                FROM sync_sessions
                %s
                GROUP BY sync_type
        `, whereClause)

        typeRows, err := r.db.Query(typeQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get type statistics: %w", err)
        }</span>
        <span class="cov0" title="0">defer typeRows.Close()

        for typeRows.Next() </span><span class="cov0" title="0">{
                var syncType string
                var count int
                err := typeRows.Scan(&amp;syncType, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan type stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ByType[syncType] = count</span>
        }

        // Get total files synced
        <span class="cov0" title="0">filesQuery := fmt.Sprintf(`
                SELECT SUM(synced_files) as total_synced, SUM(failed_files) as total_failed
                FROM sync_sessions
                %s AND status = 'completed'
        `, whereClause)

        var totalSynced, totalFailed sql.NullInt64
        err = r.db.QueryRow(filesQuery, args...).Scan(&amp;totalSynced, &amp;totalFailed)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file statistics: %w", err)
        }</span>

        <span class="cov0" title="0">if totalSynced.Valid </span><span class="cov0" title="0">{
                stats.TotalFilesSynced = int(totalSynced.Int64)
        }</span>

        <span class="cov0" title="0">if totalFailed.Valid </span><span class="cov0" title="0">{
                stats.TotalFilesFailed = int(totalFailed.Int64)
        }</span>

        // Get average duration for completed sessions
        <span class="cov0" title="0">durationQuery := fmt.Sprintf(`
                SELECT AVG(duration) as avg_duration
                FROM sync_sessions
                %s AND status = 'completed' AND duration IS NOT NULL
        `, whereClause)

        var avgDurationSeconds sql.NullFloat64
        err = r.db.QueryRow(durationQuery, args...).Scan(&amp;avgDurationSeconds)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get duration statistics: %w", err)
        }</span>

        <span class="cov0" title="0">if avgDurationSeconds.Valid </span><span class="cov0" title="0">{
                avgDuration := time.Duration(avgDurationSeconds.Float64) * time.Second
                stats.AverageDuration = &amp;avgDuration
        }</span>

        // Calculate success rate
        <span class="cov0" title="0">if completed, ok := stats.ByStatus[models.SyncSessionStatusCompleted]; ok </span><span class="cov0" title="0">{
                if failed, failedOk := stats.ByStatus[models.SyncSessionStatusFailed]; failedOk </span><span class="cov0" title="0">{
                        total := completed + failed
                        if total &gt; 0 </span><span class="cov0" title="0">{
                                stats.SuccessRate = float64(completed) / float64(total) * 100
                        }</span>
                } else<span class="cov0" title="0"> if completed &gt; 0 </span><span class="cov0" title="0">{
                        stats.SuccessRate = 100.0
                }</span>
        }

        <span class="cov0" title="0">return stats, nil</span>
}

func (r *SyncRepository) CleanupSessions(olderThan time.Time) error <span class="cov0" title="0">{
        query := `
                DELETE FROM sync_sessions
                WHERE completed_at &lt; ? AND status IN ('completed', 'failed', 'cancelled')
        `

        _, err := r.db.Exec(query, olderThan)
        return err
}</span>

func (r *SyncRepository) GetEndpointsByType(syncType string) ([]models.SyncEndpoint, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, type, url, username, password, sync_direction,
                           local_path, remote_path, sync_settings, status, created_at, updated_at, last_sync_at
                FROM sync_endpoints
                WHERE type = ? AND status = 'active'
                ORDER BY created_at DESC
        `

        rows, err := r.db.Query(query, syncType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get endpoints by type: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanEndpoints(rows)</span>
}

func (r *SyncRepository) scanEndpoints(rows *sql.Rows) ([]models.SyncEndpoint, error) <span class="cov0" title="0">{
        var endpoints []models.SyncEndpoint

        for rows.Next() </span><span class="cov0" title="0">{
                var endpoint models.SyncEndpoint
                var syncSettings sql.NullString
                var lastSyncAt sql.NullTime

                err := rows.Scan(
                        &amp;endpoint.ID, &amp;endpoint.UserID, &amp;endpoint.Name, &amp;endpoint.Type, &amp;endpoint.URL,
                        &amp;endpoint.Username, &amp;endpoint.Password, &amp;endpoint.SyncDirection, &amp;endpoint.LocalPath,
                        &amp;endpoint.RemotePath, &amp;syncSettings, &amp;endpoint.Status, &amp;endpoint.CreatedAt,
                        &amp;endpoint.UpdatedAt, &amp;lastSyncAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan endpoint: %w", err)
                }</span>

                <span class="cov0" title="0">if syncSettings.Valid </span><span class="cov0" title="0">{
                        endpoint.SyncSettings = &amp;syncSettings.String
                }</span>

                <span class="cov0" title="0">if lastSyncAt.Valid </span><span class="cov0" title="0">{
                        endpoint.LastSyncAt = &amp;lastSyncAt.Time
                }</span>

                <span class="cov0" title="0">endpoints = append(endpoints, endpoint)</span>
        }

        <span class="cov0" title="0">return endpoints, nil</span>
}

func (r *SyncRepository) scanSessions(rows *sql.Rows) ([]models.SyncSession, error) <span class="cov0" title="0">{
        var sessions []models.SyncSession

        for rows.Next() </span><span class="cov0" title="0">{
                var session models.SyncSession
                var completedAt sql.NullTime
                var durationSeconds sql.NullInt64
                var errorMessage sql.NullString

                err := rows.Scan(
                        &amp;session.ID, &amp;session.EndpointID, &amp;session.UserID, &amp;session.Status, &amp;session.SyncType,
                        &amp;session.StartedAt, &amp;completedAt, &amp;durationSeconds, &amp;session.TotalFiles,
                        &amp;session.SyncedFiles, &amp;session.FailedFiles, &amp;session.SkippedFiles, &amp;errorMessage)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan session: %w", err)
                }</span>

                <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                        session.CompletedAt = &amp;completedAt.Time
                }</span>

                <span class="cov0" title="0">if durationSeconds.Valid </span><span class="cov0" title="0">{
                        duration := time.Duration(durationSeconds.Int64) * time.Second
                        session.Duration = &amp;duration
                }</span>

                <span class="cov0" title="0">if errorMessage.Valid </span><span class="cov0" title="0">{
                        session.ErrorMessage = &amp;errorMessage.String
                }</span>

                <span class="cov0" title="0">sessions = append(sessions, session)</span>
        }

        <span class="cov0" title="0">return sessions, nil</span>
}

func (r *SyncRepository) scanSchedules(rows *sql.Rows) ([]models.SyncSchedule, error) <span class="cov0" title="0">{
        var schedules []models.SyncSchedule

        for rows.Next() </span><span class="cov0" title="0">{
                var schedule models.SyncSchedule
                var lastRun, nextRun sql.NullTime

                err := rows.Scan(
                        &amp;schedule.ID, &amp;schedule.EndpointID, &amp;schedule.UserID, &amp;schedule.Frequency,
                        &amp;lastRun, &amp;nextRun, &amp;schedule.IsActive, &amp;schedule.CreatedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan schedule: %w", err)
                }</span>

                <span class="cov0" title="0">if lastRun.Valid </span><span class="cov0" title="0">{
                        schedule.LastRun = &amp;lastRun.Time
                }</span>

                <span class="cov0" title="0">if nextRun.Valid </span><span class="cov0" title="0">{
                        schedule.NextRun = &amp;nextRun.Time
                }</span>

                <span class="cov0" title="0">schedules = append(schedules, schedule)</span>
        }

        <span class="cov0" title="0">return schedules, nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "catalogizer/models"
)

type UserRepository struct {
        db *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{db: db}
}</span>

func (r *UserRepository) Create(user *models.User) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO users (username, email, password_hash, salt, role_id, first_name, last_name,
                                                  display_name, avatar_url, time_zone, language, is_active, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        now := time.Now()
        result, err := r.db.Exec(query,
                user.Username, user.Email, user.PasswordHash, user.Salt, user.RoleID,
                user.FirstName, user.LastName, user.DisplayName, user.AvatarURL,
                user.TimeZone, user.Language, user.IsActive, now, now)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get user ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *UserRepository) GetByID(id int) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, salt, role_id, first_name, last_name,
                           display_name, avatar_url, time_zone, language, is_active, is_locked,
                           locked_until, failed_login_attempts, last_login_at, last_login_ip,
                           created_at, updated_at, settings
                FROM users WHERE id = ?
        `

        user := &amp;models.User{}
        var settings sql.NullString

        err := r.db.QueryRow(query, id).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Salt,
                &amp;user.RoleID, &amp;user.FirstName, &amp;user.LastName, &amp;user.DisplayName,
                &amp;user.AvatarURL, &amp;user.TimeZone, &amp;user.Language, &amp;user.IsActive,
                &amp;user.IsLocked, &amp;user.LockedUntil, &amp;user.FailedLoginAttempts,
                &amp;user.LastLoginAt, &amp;user.LastLoginIP, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;settings)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, errors.New("user not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                user.Settings = settings.String
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) GetByUsername(username string) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, salt, role_id, first_name, last_name,
                           display_name, avatar_url, time_zone, language, is_active, is_locked,
                           locked_until, failed_login_attempts, last_login_at, last_login_ip,
                           created_at, updated_at, settings
                FROM users WHERE username = ?
        `

        user := &amp;models.User{}
        var settings sql.NullString

        err := r.db.QueryRow(query, username).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Salt,
                &amp;user.RoleID, &amp;user.FirstName, &amp;user.LastName, &amp;user.DisplayName,
                &amp;user.AvatarURL, &amp;user.TimeZone, &amp;user.Language, &amp;user.IsActive,
                &amp;user.IsLocked, &amp;user.LockedUntil, &amp;user.FailedLoginAttempts,
                &amp;user.LastLoginAt, &amp;user.LastLoginIP, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;settings)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                user.Settings = settings.String
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) GetByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, salt, role_id, first_name, last_name,
                           display_name, avatar_url, time_zone, language, is_active, is_locked,
                           locked_until, failed_login_attempts, last_login_at, last_login_ip,
                           created_at, updated_at, settings
                FROM users WHERE email = ?
        `

        user := &amp;models.User{}
        var settings sql.NullString

        err := r.db.QueryRow(query, email).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Salt,
                &amp;user.RoleID, &amp;user.FirstName, &amp;user.LastName, &amp;user.DisplayName,
                &amp;user.AvatarURL, &amp;user.TimeZone, &amp;user.Language, &amp;user.IsActive,
                &amp;user.IsLocked, &amp;user.LockedUntil, &amp;user.FailedLoginAttempts,
                &amp;user.LastLoginAt, &amp;user.LastLoginIP, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;settings)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                user.Settings = settings.String
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) GetByUsernameOrEmail(usernameOrEmail string) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, salt, role_id, first_name, last_name,
                           display_name, avatar_url, time_zone, language, is_active, is_locked,
                           locked_until, failed_login_attempts, last_login_at, last_login_ip,
                           created_at, updated_at, settings
                FROM users WHERE username = ? OR email = ?
        `

        user := &amp;models.User{}
        var settings sql.NullString

        err := r.db.QueryRow(query, usernameOrEmail, usernameOrEmail).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Salt,
                &amp;user.RoleID, &amp;user.FirstName, &amp;user.LastName, &amp;user.DisplayName,
                &amp;user.AvatarURL, &amp;user.TimeZone, &amp;user.Language, &amp;user.IsActive,
                &amp;user.IsLocked, &amp;user.LockedUntil, &amp;user.FailedLoginAttempts,
                &amp;user.LastLoginAt, &amp;user.LastLoginIP, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;settings)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                user.Settings = settings.String
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) Update(user *models.User) error <span class="cov0" title="0">{
        query := `
                UPDATE users SET
                        username = ?, email = ?, first_name = ?, last_name = ?, display_name = ?,
                        avatar_url = ?, time_zone = ?, language = ?, is_active = ?, settings = ?,
                        updated_at = ?
                WHERE id = ?
        `

        _, err := r.db.Exec(query,
                user.Username, user.Email, user.FirstName, user.LastName, user.DisplayName,
                user.AvatarURL, user.TimeZone, user.Language, user.IsActive, user.Settings,
                time.Now(), user.ID)

        return err
}</span>

func (r *UserRepository) UpdatePassword(userID int, passwordHash, salt string) error <span class="cov0" title="0">{
        query := `UPDATE users SET password_hash = ?, salt = ?, updated_at = ? WHERE id = ?`
        _, err := r.db.Exec(query, passwordHash, salt, time.Now(), userID)
        return err
}</span>

func (r *UserRepository) UpdateLastLogin(userID int, ipAddress string) error <span class="cov0" title="0">{
        query := `UPDATE users SET last_login_at = ?, last_login_ip = ? WHERE id = ?`
        _, err := r.db.Exec(query, time.Now(), ipAddress, userID)
        return err
}</span>

func (r *UserRepository) IncrementFailedLoginAttempts(userID int) error <span class="cov0" title="0">{
        query := `UPDATE users SET failed_login_attempts = failed_login_attempts + 1 WHERE id = ?`
        _, err := r.db.Exec(query, userID)
        return err
}</span>

func (r *UserRepository) ResetFailedLoginAttempts(userID int) error <span class="cov0" title="0">{
        query := `UPDATE users SET failed_login_attempts = 0 WHERE id = ?`
        _, err := r.db.Exec(query, userID)
        return err
}</span>

func (r *UserRepository) LockAccount(userID int, lockUntil time.Time) error <span class="cov0" title="0">{
        query := `UPDATE users SET is_locked = 1, locked_until = ? WHERE id = ?`
        _, err := r.db.Exec(query, lockUntil, userID)
        return err
}</span>

func (r *UserRepository) UnlockAccount(userID int) error <span class="cov0" title="0">{
        query := `UPDATE users SET is_locked = 0, locked_until = NULL WHERE id = ?`
        _, err := r.db.Exec(query, userID)
        return err
}</span>

func (r *UserRepository) Delete(id int) error <span class="cov0" title="0">{
        query := `DELETE FROM users WHERE id = ?`
        _, err := r.db.Exec(query, id)
        return err
}</span>

func (r *UserRepository) List(limit, offset int) ([]models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, salt, role_id, first_name, last_name,
                           display_name, avatar_url, time_zone, language, is_active, is_locked,
                           locked_until, failed_login_attempts, last_login_at, last_login_ip,
                           created_at, updated_at, settings
                FROM users
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.Query(query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list users: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []models.User
        for rows.Next() </span><span class="cov0" title="0">{
                var user models.User
                var settings sql.NullString

                err := rows.Scan(
                        &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Salt,
                        &amp;user.RoleID, &amp;user.FirstName, &amp;user.LastName, &amp;user.DisplayName,
                        &amp;user.AvatarURL, &amp;user.TimeZone, &amp;user.Language, &amp;user.IsActive,
                        &amp;user.IsLocked, &amp;user.LockedUntil, &amp;user.FailedLoginAttempts,
                        &amp;user.LastLoginAt, &amp;user.LastLoginIP, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                        &amp;settings)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user: %w", err)
                }</span>

                <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                        user.Settings = settings.String
                }</span>

                <span class="cov0" title="0">users = append(users, user)</span>
        }

        <span class="cov0" title="0">return users, nil</span>
}

func (r *UserRepository) Count() (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM users`
        var count int
        err := r.db.QueryRow(query).Scan(&amp;count)
        return count, err
}</span>

func (r *UserRepository) GetRole(roleID int) (*models.Role, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, permissions, is_system, created_at, updated_at
                FROM roles WHERE id = ?
        `

        role := &amp;models.Role{}
        var permissionsJSON string

        err := r.db.QueryRow(query, roleID).Scan(
                &amp;role.ID, &amp;role.Name, &amp;role.Description, &amp;permissionsJSON,
                &amp;role.IsSystem, &amp;role.CreatedAt, &amp;role.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, errors.New("role not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get role: %w", err)</span>
        }

        <span class="cov0" title="0">err = json.Unmarshal([]byte(permissionsJSON), &amp;role.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">return role, nil</span>
}

func (r *UserRepository) CreateSession(session *models.UserSession) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO user_sessions (user_id, session_token, refresh_token, device_info,
                                                                  ip_address, user_agent, is_active, expires_at, created_at, last_activity_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        deviceInfoJSON, err := json.Marshal(session.DeviceInfo)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to marshal device info: %w", err)
        }</span>

        <span class="cov0" title="0">result, err := r.db.Exec(query,
                session.UserID, session.SessionToken, session.RefreshToken, string(deviceInfoJSON),
                session.IPAddress, session.UserAgent, session.IsActive, session.ExpiresAt,
                session.CreatedAt, session.LastActivityAt)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create session: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get session ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *UserRepository) GetSession(sessionID string) (*models.UserSession, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, session_token, refresh_token, device_info, ip_address,
                           user_agent, is_active, expires_at, created_at, last_activity_at
                FROM user_sessions WHERE id = ?
        `

        session := &amp;models.UserSession{}
        var deviceInfoJSON string

        err := r.db.QueryRow(query, sessionID).Scan(
                &amp;session.ID, &amp;session.UserID, &amp;session.SessionToken, &amp;session.RefreshToken,
                &amp;deviceInfoJSON, &amp;session.IPAddress, &amp;session.UserAgent, &amp;session.IsActive,
                &amp;session.ExpiresAt, &amp;session.CreatedAt, &amp;session.LastActivityAt)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, errors.New("session not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get session: %w", err)</span>
        }

        <span class="cov0" title="0">err = json.Unmarshal([]byte(deviceInfoJSON), &amp;session.DeviceInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal device info: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (r *UserRepository) GetSessionByRefreshToken(refreshToken string) (*models.UserSession, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, session_token, refresh_token, device_info, ip_address,
                           user_agent, is_active, expires_at, created_at, last_activity_at
                FROM user_sessions WHERE refresh_token = ? AND is_active = 1
        `

        session := &amp;models.UserSession{}
        var deviceInfoJSON string

        err := r.db.QueryRow(query, refreshToken).Scan(
                &amp;session.ID, &amp;session.UserID, &amp;session.SessionToken, &amp;session.RefreshToken,
                &amp;deviceInfoJSON, &amp;session.IPAddress, &amp;session.UserAgent, &amp;session.IsActive,
                &amp;session.ExpiresAt, &amp;session.CreatedAt, &amp;session.LastActivityAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal([]byte(deviceInfoJSON), &amp;session.DeviceInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal device info: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (r *UserRepository) UpdateSessionTokens(sessionID int, sessionToken, refreshToken string) error <span class="cov0" title="0">{
        query := `UPDATE user_sessions SET session_token = ?, refresh_token = ? WHERE id = ?`
        _, err := r.db.Exec(query, sessionToken, refreshToken, sessionID)
        return err
}</span>

func (r *UserRepository) UpdateSessionTokensAndExpiry(sessionID int, sessionToken, refreshToken string, expiresAt time.Time) error <span class="cov0" title="0">{
        query := `UPDATE user_sessions SET session_token = ?, refresh_token = ?, expires_at = ? WHERE id = ?`
        _, err := r.db.Exec(query, sessionToken, refreshToken, expiresAt, sessionID)
        return err
}</span>

func (r *UserRepository) UpdateSessionActivity(sessionID int) error <span class="cov0" title="0">{
        query := `UPDATE user_sessions SET last_activity_at = ? WHERE id = ?`
        _, err := r.db.Exec(query, time.Now(), sessionID)
        return err
}</span>

func (r *UserRepository) DeactivateSession(sessionID int) error <span class="cov0" title="0">{
        query := `UPDATE user_sessions SET is_active = 0 WHERE id = ?`
        _, err := r.db.Exec(query, sessionID)
        return err
}</span>

func (r *UserRepository) DeactivateAllUserSessions(userID int) error <span class="cov0" title="0">{
        query := `UPDATE user_sessions SET is_active = 0 WHERE user_id = ?`
        _, err := r.db.Exec(query, userID)
        return err
}</span>

func (r *UserRepository) GetActiveUserSessions(userID int) ([]models.UserSession, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, session_token, refresh_token, device_info, ip_address,
                           user_agent, is_active, expires_at, created_at, last_activity_at
                FROM user_sessions
                WHERE user_id = ? AND is_active = 1 AND expires_at &gt; ?
                ORDER BY last_activity_at DESC
        `

        rows, err := r.db.Query(query, userID, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active sessions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var sessions []models.UserSession
        for rows.Next() </span><span class="cov0" title="0">{
                var session models.UserSession
                var deviceInfoJSON string

                err := rows.Scan(
                        &amp;session.ID, &amp;session.UserID, &amp;session.SessionToken, &amp;session.RefreshToken,
                        &amp;deviceInfoJSON, &amp;session.IPAddress, &amp;session.UserAgent, &amp;session.IsActive,
                        &amp;session.ExpiresAt, &amp;session.CreatedAt, &amp;session.LastActivityAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan session: %w", err)
                }</span>

                <span class="cov0" title="0">err = json.Unmarshal([]byte(deviceInfoJSON), &amp;session.DeviceInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal device info: %w", err)
                }</span>

                <span class="cov0" title="0">sessions = append(sessions, session)</span>
        }

        <span class="cov0" title="0">return sessions, nil</span>
}

func (r *UserRepository) CleanupExpiredSessions() error <span class="cov0" title="0">{
        query := `DELETE FROM user_sessions WHERE expires_at &lt; ? OR (is_active = 0 AND created_at &lt; ?)`
        cutoff := time.Now().Add(-30 * 24 * time.Hour) // Remove inactive sessions older than 30 days
        _, err := r.db.Exec(query, time.Now(), cutoff)
        return err
}</span>

func (r *UserRepository) CreateRole(role *models.Role) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO roles (name, description, permissions, is_system, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        permissionsJSON, err := json.Marshal(role.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to marshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        result, err := r.db.Exec(query, role.Name, role.Description, string(permissionsJSON),
                role.IsSystem, now, now)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create role: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get role ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *UserRepository) UpdateRole(role *models.Role) error <span class="cov0" title="0">{
        query := `
                UPDATE roles SET name = ?, description = ?, permissions = ?, updated_at = ?
                WHERE id = ? AND is_system = 0
        `

        permissionsJSON, err := json.Marshal(role.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">result, err := r.db.Exec(query, role.Name, role.Description, string(permissionsJSON),
                time.Now(), role.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update role: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("role not found or is system role")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *UserRepository) DeleteRole(roleID int) error <span class="cov0" title="0">{
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        var userCount int
        err = tx.QueryRow("SELECT COUNT(*) FROM users WHERE role_id = ?", roleID).Scan(&amp;userCount)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check role usage: %w", err)
        }</span>

        <span class="cov0" title="0">if userCount &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("cannot delete role that is assigned to users")
        }</span>

        <span class="cov0" title="0">result, err := tx.Exec("DELETE FROM roles WHERE id = ? AND is_system = 0", roleID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete role: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("role not found or is system role")
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}

func (r *UserRepository) ListRoles() ([]models.Role, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, permissions, is_system, created_at, updated_at
                FROM roles ORDER BY is_system DESC, name ASC
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list roles: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var roles []models.Role
        for rows.Next() </span><span class="cov0" title="0">{
                var role models.Role
                var permissionsJSON string

                err := rows.Scan(&amp;role.ID, &amp;role.Name, &amp;role.Description, &amp;permissionsJSON,
                        &amp;role.IsSystem, &amp;role.CreatedAt, &amp;role.UpdatedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan role: %w", err)
                }</span>

                <span class="cov0" title="0">err = json.Unmarshal([]byte(permissionsJSON), &amp;role.Permissions)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal permissions: %w", err)
                }</span>

                <span class="cov0" title="0">roles = append(roles, role)</span>
        }

        <span class="cov0" title="0">return roles, nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package services

import (
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type AnalyticsService struct {
        analyticsRepo *repository.AnalyticsRepository
}

func NewAnalyticsService(analyticsRepo *repository.AnalyticsRepository) *AnalyticsService <span class="cov0" title="0">{
        return &amp;AnalyticsService{
                analyticsRepo: analyticsRepo,
        }
}</span>

func (s *AnalyticsService) LogMediaAccess(access *models.MediaAccessLog) error <span class="cov0" title="0">{
        return s.analyticsRepo.LogMediaAccess(access)
}</span>

func (s *AnalyticsService) LogEvent(event *models.AnalyticsEvent) error <span class="cov0" title="0">{
        return s.analyticsRepo.LogEvent(event)
}</span>

func (s *AnalyticsService) GetMediaAccessLogs(userID int, mediaID *int, limit, offset int) ([]models.MediaAccessLog, error) <span class="cov0" title="0">{
        return s.analyticsRepo.GetMediaAccessLogs(userID, mediaID, limit, offset)
}</span>

func (s *AnalyticsService) GetUserAnalytics(userID int, startDate, endDate time.Time) (*models.UserAnalytics, error) <span class="cov0" title="0">{
        logs, err := s.analyticsRepo.GetUserMediaAccessLogs(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">events, err := s.analyticsRepo.GetUserEvents(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">analytics := &amp;models.UserAnalytics{
                UserID:               userID,
                StartDate:            startDate,
                EndDate:              endDate,
                TotalMediaAccesses:   len(logs),
                TotalEvents:          len(events),
                UniqueMediaAccessed:  s.countUniqueMedia(logs),
                TotalPlaybackTime:    s.calculateTotalPlaybackTime(logs),
                MostAccessedMedia:    s.findMostAccessedMedia(logs),
                PreferredAccessTimes: s.analyzeAccessTimes(logs),
                DeviceUsage:          s.analyzeDeviceUsage(logs),
                LocationAnalysis:     s.analyzeLocations(logs),
        }

        return analytics, nil</span>
}

func (s *AnalyticsService) GetSystemAnalytics(startDate, endDate time.Time) (*models.SystemAnalytics, error) <span class="cov0" title="0">{
        totalUsers, err := s.analyticsRepo.GetTotalUsers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">activeUsers, err := s.analyticsRepo.GetActiveUsers(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">totalMediaAccesses, err := s.analyticsRepo.GetTotalMediaAccesses(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">totalEvents, err := s.analyticsRepo.GetTotalEvents(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">topMedia, err := s.analyticsRepo.GetTopAccessedMedia(startDate, endDate, 10)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">userGrowth, err := s.analyticsRepo.GetUserGrowthData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">analytics := &amp;models.SystemAnalytics{
                StartDate:              startDate,
                EndDate:                endDate,
                TotalUsers:             totalUsers,
                ActiveUsers:            activeUsers,
                TotalMediaAccesses:     totalMediaAccesses,
                TotalEvents:            totalEvents,
                TopAccessedMedia:       topMedia,
                UserGrowthData:         userGrowth,
                AverageSessionDuration: s.calculateAverageSessionDuration(startDate, endDate),
                PeakUsageHours:         s.analyzePeakUsageHours(startDate, endDate),
                PopularFileTypes:       s.analyzePopularFileTypes(startDate, endDate),
                GeographicDistribution: s.analyzeGeographicDistribution(startDate, endDate),
        }

        return analytics, nil</span>
}

func (s *AnalyticsService) GetMediaAnalytics(mediaID int, startDate, endDate time.Time) (*models.MediaAnalytics, error) <span class="cov0" title="0">{
        logs, err := s.analyticsRepo.GetMediaAccessLogs(0, &amp;mediaID, 1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filteredLogs := s.filterLogsByDate(logs, startDate, endDate)

        analytics := &amp;models.MediaAnalytics{
                MediaID:             mediaID,
                StartDate:           startDate,
                EndDate:             endDate,
                TotalAccesses:       len(filteredLogs),
                UniqueUsers:         s.countUniqueUsers(filteredLogs),
                TotalPlaybackTime:   s.calculateTotalPlaybackTime(filteredLogs),
                AveragePlaybackTime: s.calculateAveragePlaybackTime(filteredLogs),
                AccessPatterns:      s.analyzeAccessPatterns(filteredLogs),
                UserRetention:       s.calculateUserRetention(filteredLogs),
                PopularTimeRanges:   s.analyzePopularTimeRanges(filteredLogs),
                DevicePreferences:   s.analyzeDevicePreferences(filteredLogs),
        }

        return analytics, nil</span>
}

func (s *AnalyticsService) CreateReport(reportType string, params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        switch reportType </span>{
        case "user_activity":<span class="cov0" title="0">
                return s.generateUserActivityReport(params)</span>
        case "media_popularity":<span class="cov0" title="0">
                return s.generateMediaPopularityReport(params)</span>
        case "system_overview":<span class="cov0" title="0">
                return s.generateSystemOverviewReport(params)</span>
        case "geographic_analysis":<span class="cov0" title="0">
                return s.generateGeographicAnalysisReport(params)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported report type: %s", reportType)</span>
        }
}

func (s *AnalyticsService) generateUserActivityReport(params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">systemAnalytics, err := s.GetSystemAnalytics(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "analytics": systemAnalytics,
                "summary": map[string]interface{}{
                        "period":         fmt.Sprintf("%s to %s", startDate.Format("2006-01-02"), endDate.Format("2006-01-02")),
                        "active_users":   systemAnalytics.ActiveUsers,
                        "total_accesses": systemAnalytics.TotalMediaAccesses,
                },
        }

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.AnalyticsReport{
                Type:      "user_activity",
                Data:      string(dataJSON),
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil</span>
}

func (s *AnalyticsService) generateMediaPopularityReport(params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">topMedia, err := s.analyticsRepo.GetTopAccessedMedia(startDate, endDate, 50)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "top_media": topMedia,
                "period":    fmt.Sprintf("%s to %s", startDate.Format("2006-01-02"), endDate.Format("2006-01-02")),
                "total":     len(topMedia),
        }

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.AnalyticsReport{
                Type:      "media_popularity",
                Data:      string(dataJSON),
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil</span>
}

func (s *AnalyticsService) generateSystemOverviewReport(params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">systemAnalytics, err := s.GetSystemAnalytics(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "system_analytics": systemAnalytics,
                "summary": map[string]interface{}{
                        "health_score":     s.calculateSystemHealthScore(systemAnalytics),
                        "growth_rate":      s.calculateGrowthRate(systemAnalytics.UserGrowthData),
                        "engagement_level": s.calculateEngagementLevel(systemAnalytics),
                },
        }

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.AnalyticsReport{
                Type:      "system_overview",
                Data:      string(dataJSON),
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil</span>
}

func (s *AnalyticsService) generateGeographicAnalysisReport(params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">geographicData, err := s.analyticsRepo.GetGeographicData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "geographic_distribution": geographicData,
                "period":                  fmt.Sprintf("%s to %s", startDate.Format("2006-01-02"), endDate.Format("2006-01-02")),
                "top_locations":           s.getTopLocations(geographicData, 10),
        }

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.AnalyticsReport{
                Type:      "geographic_analysis",
                Data:      string(dataJSON),
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil</span>
}

func (s *AnalyticsService) countUniqueMedia(logs []models.MediaAccessLog) int <span class="cov0" title="0">{
        mediaSet := make(map[int]bool)
        for _, log := range logs </span><span class="cov0" title="0">{
                mediaSet[log.MediaID] = true
        }</span>
        <span class="cov0" title="0">return len(mediaSet)</span>
}

func (s *AnalyticsService) countUniqueUsers(logs []models.MediaAccessLog) int <span class="cov0" title="0">{
        userSet := make(map[int]bool)
        for _, log := range logs </span><span class="cov0" title="0">{
                userSet[log.UserID] = true
        }</span>
        <span class="cov0" title="0">return len(userSet)</span>
}

func (s *AnalyticsService) calculateTotalPlaybackTime(logs []models.MediaAccessLog) time.Duration <span class="cov0" title="0">{
        var total time.Duration
        for _, log := range logs </span><span class="cov0" title="0">{
                if log.PlaybackDuration != nil </span><span class="cov0" title="0">{
                        total += *log.PlaybackDuration
                }</span>
        }
        <span class="cov0" title="0">return total</span>
}

func (s *AnalyticsService) calculateAveragePlaybackTime(logs []models.MediaAccessLog) time.Duration <span class="cov0" title="0">{
        total := s.calculateTotalPlaybackTime(logs)
        if len(logs) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return total / time.Duration(len(logs))</span>
}

func (s *AnalyticsService) findMostAccessedMedia(logs []models.MediaAccessLog) []models.MediaAccessCount <span class="cov0" title="0">{
        counts := make(map[int]int)
        for _, log := range logs </span><span class="cov0" title="0">{
                counts[log.MediaID]++
        }</span>

        <span class="cov0" title="0">var results []models.MediaAccessCount
        for mediaID, count := range counts </span><span class="cov0" title="0">{
                results = append(results, models.MediaAccessCount{
                        MediaID:     mediaID,
                        AccessCount: count,
                })
        }</span>

        <span class="cov0" title="0">return results</span>
}

func (s *AnalyticsService) analyzeAccessTimes(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        hourCounts := make(map[string]int)
        for _, log := range logs </span><span class="cov0" title="0">{
                hour := log.AccessTime.Format("15")
                hourCounts[hour]++
        }</span>
        <span class="cov0" title="0">return hourCounts</span>
}

func (s *AnalyticsService) analyzeDeviceUsage(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        deviceCounts := make(map[string]int)
        for _, log := range logs </span><span class="cov0" title="0">{
                if log.DeviceInfo != nil </span><span class="cov0" title="0">{
                        deviceModel := ""
                        if log.DeviceInfo.DeviceModel != nil </span><span class="cov0" title="0">{
                                deviceModel = *log.DeviceInfo.DeviceModel
                        }</span>
                        <span class="cov0" title="0">deviceType := fmt.Sprintf("%s %s", log.DeviceInfo.Platform, deviceModel)
                        deviceCounts[deviceType]++</span>
                }
        }
        <span class="cov0" title="0">return deviceCounts</span>
}

func (s *AnalyticsService) analyzeLocations(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        locationCounts := make(map[string]int)
        for _, log := range logs </span><span class="cov0" title="0">{
                if log.Location != nil </span><span class="cov0" title="0">{
                        location := fmt.Sprintf("%.2f,%.2f", log.Location.Latitude, log.Location.Longitude)
                        locationCounts[location]++
                }</span>
        }
        <span class="cov0" title="0">return locationCounts</span>
}

func (s *AnalyticsService) filterLogsByDate(logs []models.MediaAccessLog, startDate, endDate time.Time) []models.MediaAccessLog <span class="cov0" title="0">{
        var filtered []models.MediaAccessLog
        for _, log := range logs </span><span class="cov0" title="0">{
                if log.AccessTime.After(startDate) &amp;&amp; log.AccessTime.Before(endDate) </span><span class="cov0" title="0">{
                        filtered = append(filtered, log)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

func (s *AnalyticsService) analyzeAccessPatterns(logs []models.MediaAccessLog) map[string]interface{} <span class="cov0" title="0">{
        patterns := make(map[string]interface{})

        hourlyPatterns := s.analyzeAccessTimes(logs)
        dailyPatterns := make(map[string]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                day := log.AccessTime.Weekday().String()
                dailyPatterns[day]++
        }</span>

        <span class="cov0" title="0">patterns["hourly"] = hourlyPatterns
        patterns["daily"] = dailyPatterns

        return patterns</span>
}

func (s *AnalyticsService) calculateUserRetention(logs []models.MediaAccessLog) float64 <span class="cov0" title="0">{
        if len(logs) &lt;= 1 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">userFirstAccess := make(map[int]time.Time)
        userLastAccess := make(map[int]time.Time)

        for _, log := range logs </span><span class="cov0" title="0">{
                if first, exists := userFirstAccess[log.UserID]; !exists || log.AccessTime.Before(first) </span><span class="cov0" title="0">{
                        userFirstAccess[log.UserID] = log.AccessTime
                }</span>
                <span class="cov0" title="0">if last, exists := userLastAccess[log.UserID]; !exists || log.AccessTime.After(last) </span><span class="cov0" title="0">{
                        userLastAccess[log.UserID] = log.AccessTime
                }</span>
        }

        <span class="cov0" title="0">totalRetention := 0.0
        userCount := 0

        for userID, firstAccess := range userFirstAccess </span><span class="cov0" title="0">{
                lastAccess := userLastAccess[userID]
                retention := lastAccess.Sub(firstAccess).Hours() / 24.0
                totalRetention += retention
                userCount++
        }</span>

        <span class="cov0" title="0">if userCount == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return totalRetention / float64(userCount)</span>
}

func (s *AnalyticsService) analyzePopularTimeRanges(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        timeRanges := make(map[string]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                hour := log.AccessTime.Hour()
                var timeRange string

                switch </span>{
                case hour &gt;= 6 &amp;&amp; hour &lt; 12:<span class="cov0" title="0">
                        timeRange = "morning"</span>
                case hour &gt;= 12 &amp;&amp; hour &lt; 18:<span class="cov0" title="0">
                        timeRange = "afternoon"</span>
                case hour &gt;= 18 &amp;&amp; hour &lt; 22:<span class="cov0" title="0">
                        timeRange = "evening"</span>
                default:<span class="cov0" title="0">
                        timeRange = "night"</span>
                }

                <span class="cov0" title="0">timeRanges[timeRange]++</span>
        }

        <span class="cov0" title="0">return timeRanges</span>
}

func (s *AnalyticsService) analyzeDevicePreferences(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        return s.analyzeDeviceUsage(logs)
}</span>

func (s *AnalyticsService) calculateAverageSessionDuration(startDate, endDate time.Time) time.Duration <span class="cov0" title="0">{
        sessions, err := s.analyticsRepo.GetSessionData(startDate, endDate)
        if err != nil || len(sessions) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var totalDuration time.Duration
        for _, session := range sessions </span><span class="cov0" title="0">{
                totalDuration += session.Duration
        }</span>

        <span class="cov0" title="0">return totalDuration / time.Duration(len(sessions))</span>
}

func (s *AnalyticsService) analyzePeakUsageHours(startDate, endDate time.Time) map[string]int <span class="cov0" title="0">{
        logs, err := s.analyticsRepo.GetAllMediaAccessLogs(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]int)
        }</span>

        <span class="cov0" title="0">return s.analyzeAccessTimes(logs)</span>
}

func (s *AnalyticsService) analyzePopularFileTypes(startDate, endDate time.Time) map[string]int <span class="cov0" title="0">{
        fileTypes, err := s.analyticsRepo.GetFileTypeData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]int)
        }</span>

        <span class="cov0" title="0">return fileTypes</span>
}

func (s *AnalyticsService) analyzeGeographicDistribution(startDate, endDate time.Time) map[string]interface{} <span class="cov0" title="0">{
        geographicData, err := s.analyticsRepo.GetGeographicData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">return geographicData</span>
}

func (s *AnalyticsService) calculateSystemHealthScore(analytics *models.SystemAnalytics) float64 <span class="cov0" title="0">{
        score := 0.0

        if analytics.TotalUsers &gt; 0 </span><span class="cov0" title="0">{
                activeUserRatio := float64(analytics.ActiveUsers) / float64(analytics.TotalUsers)
                score += activeUserRatio * 40
        }</span>

        <span class="cov0" title="0">if analytics.TotalMediaAccesses &gt; 0 </span><span class="cov0" title="0">{
                score += 30
        }</span>

        <span class="cov0" title="0">if analytics.TotalEvents &gt; 0 </span><span class="cov0" title="0">{
                score += 20
        }</span>

        <span class="cov0" title="0">if analytics.AverageSessionDuration &gt; time.Minute*5 </span><span class="cov0" title="0">{
                score += 10
        }</span>

        <span class="cov0" title="0">return score</span>
}

func (s *AnalyticsService) calculateGrowthRate(growthData []models.UserGrowthPoint) float64 <span class="cov0" title="0">{
        if len(growthData) &lt; 2 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">first := growthData[0]
        last := growthData[len(growthData)-1]

        if first.UserCount == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return (float64(last.UserCount) - float64(first.UserCount)) / float64(first.UserCount) * 100</span>
}

func (s *AnalyticsService) calculateEngagementLevel(analytics *models.SystemAnalytics) string <span class="cov0" title="0">{
        if analytics.TotalUsers == 0 </span><span class="cov0" title="0">{
                return "low"
        }</span>

        <span class="cov0" title="0">accessesPerUser := float64(analytics.TotalMediaAccesses) / float64(analytics.TotalUsers)

        switch </span>{
        case accessesPerUser &gt;= 50:<span class="cov0" title="0">
                return "high"</span>
        case accessesPerUser &gt;= 20:<span class="cov0" title="0">
                return "medium"</span>
        default:<span class="cov0" title="0">
                return "low"</span>
        }
}

func (s *AnalyticsService) getTopLocations(geographicData map[string]interface{}, limit int) []map[string]interface{} <span class="cov0" title="0">{
        var locations []map[string]interface{}

        if locationsData, ok := geographicData["locations"].([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                for i, location := range locationsData </span><span class="cov0" title="0">{
                        if i &gt;= limit </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">locations = append(locations, location)</span>
                }
        }

        <span class="cov0" title="0">return locations</span>
}

// TrackEvent tracks an analytics event
func (s *AnalyticsService) TrackEvent(userID int, event *models.AnalyticsEventRequest) error <span class="cov0" title="0">{
        // Convert AnalyticsEventRequest to AnalyticsEvent
        data, _ := json.Marshal(event)
        analyticsEvent := &amp;models.AnalyticsEvent{
                UserID:    userID,
                EventType: event.EventType,
                Data:      string(data),
                Timestamp: time.Now(),
        }
        return s.LogEvent(analyticsEvent)
}</span>

// GetEventsByUser gets events for a user with filters
func (s *AnalyticsService) GetEventsByUser(userID int, filters *models.AnalyticsFilters) ([]models.AnalyticsEvent, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        return []models.AnalyticsEvent{}, nil
}</span>

// GetAnalytics gets analytics data with filters
func (s *AnalyticsService) GetAnalytics(userID int, filters *models.AnalyticsFilters) (*models.AnalyticsData, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        return &amp;models.AnalyticsData{}, nil
}</span>

// GetDashboardMetrics gets dashboard metrics
func (s *AnalyticsService) GetDashboardMetrics(userID int) (*models.DashboardMetrics, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        return &amp;models.DashboardMetrics{}, nil
}</span>

// GetRealtimeMetrics gets realtime metrics
func (s *AnalyticsService) GetRealtimeMetrics(userID int) (*models.RealtimeMetrics, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        return &amp;models.RealtimeMetrics{}, nil
}</span>

// GenerateReport generates an analytics report
func (s *AnalyticsService) GenerateReport(userID int, request *models.ReportRequest) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        // Stub implementation for testing
        return &amp;models.AnalyticsReport{
                Type:      request.ReportType,
                Data:      "{}",
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil
}</span>

// CleanupOldEvents cleans up old events
func (s *AnalyticsService) CleanupOldEvents(daysOld int) error <span class="cov0" title="0">{
        // This is a simplified implementation
        return nil
}</span>

func (s *AnalyticsService) extractDateRange(params map[string]interface{}) (time.Time, time.Time, error) <span class="cov0" title="0">{
        startDateStr, ok := params["start_date"].(string)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("start_date parameter required")
        }</span>

        <span class="cov0" title="0">endDateStr, ok := params["end_date"].(string)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("end_date parameter required")
        }</span>

        <span class="cov0" title="0">startDate, err := time.Parse("2006-01-02", startDateStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("invalid start_date format")
        }</span>

        <span class="cov0" title="0">endDate, err := time.Parse("2006-01-02", endDateStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("invalid end_date format")
        }</span>

        <span class="cov0" title="0">return startDate, endDate, nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package services

import (
        "crypto/rand"
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "errors"
        "fmt"
        "strconv"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "golang.org/x/crypto/bcrypt"

        "catalogizer/models"
        "catalogizer/repository"
)

// AuthService handles authentication and authorization
type AuthService struct {
        userRepo   *repository.UserRepository
        jwtSecret  []byte
        jwtExpiry  time.Duration
        refreshExp time.Duration
}

// NewAuthService creates a new authentication service
func NewAuthService(userRepo *repository.UserRepository, jwtSecret string) *AuthService <span class="cov0" title="0">{
        return &amp;AuthService{
                userRepo:   userRepo,
                jwtSecret:  []byte(jwtSecret),
                jwtExpiry:  24 * time.Hour,     // 24 hours
                refreshExp: 7 * 24 * time.Hour, // 7 days
        }
}</span>

// JWTClaims represents the claims in our JWT tokens
type JWTClaims struct {
        UserID    int    `json:"user_id"`
        Username  string `json:"username"`
        RoleID    int    `json:"role_id"`
        SessionID string `json:"session_id"`
        jwt.RegisteredClaims
}

// AuthResult represents the result of authentication
type AuthResult struct {
        User         *models.User `json:"user"`
        SessionToken string       `json:"session_token"`
        RefreshToken string       `json:"refresh_token"`
        ExpiresAt    time.Time    `json:"expires_at"`
}

// Login authenticates a user and creates a session
func (s *AuthService) Login(req models.LoginRequest, ipAddress string, userAgent string) (*AuthResult, error) <span class="cov0" title="0">{
        // Find user by username or email
        user, err := s.userRepo.GetByUsernameOrEmail(req.Username)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid credentials")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        // Check if user can login
        <span class="cov0" title="0">if !user.CanLogin() </span><span class="cov0" title="0">{
                if user.IsLocked </span><span class="cov0" title="0">{
                        return nil, errors.New("account is temporarily locked")
                }</span>
                <span class="cov0" title="0">return nil, errors.New("account is disabled")</span>
        }

        // Verify password
        <span class="cov0" title="0">if !s.verifyPassword(req.Password, user.Salt, user.PasswordHash) </span><span class="cov0" title="0">{
                // Increment failed login attempts
                s.userRepo.IncrementFailedLoginAttempts(user.ID)
                return nil, errors.New("invalid credentials")
        }</span>

        // Reset failed login attempts on successful login
        <span class="cov0" title="0">s.userRepo.ResetFailedLoginAttempts(user.ID)

        // Create session
        session, err := s.createSession(user, req.DeviceInfo, ipAddress, userAgent, req.RememberMe)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create session: %w", err)
        }</span>

        // Update last login information
        <span class="cov0" title="0">s.userRepo.UpdateLastLogin(user.ID, ipAddress)

        // Load user role
        role, err := s.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user role: %w", err)
        }</span>
        <span class="cov0" title="0">user.Role = role

        // Generate JWT token
        token, err := s.generateJWT(user, session.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // Generate refresh token
        <span class="cov0" title="0">refreshToken, err := s.generateRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        // Update session with tokens
        <span class="cov0" title="0">err = s.userRepo.UpdateSessionTokens(session.ID, token, refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update session tokens: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;AuthResult{
                User:         user,
                SessionToken: token,
                RefreshToken: refreshToken,
                ExpiresAt:    session.ExpiresAt,
        }, nil</span>
}

// RefreshToken refreshes an authentication token
func (s *AuthService) RefreshToken(refreshToken string) (*AuthResult, error) <span class="cov0" title="0">{
        // Find session by refresh token
        session, err := s.userRepo.GetSessionByRefreshToken(refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid refresh token")
        }</span>

        // Check if session is still valid
        <span class="cov0" title="0">if !session.IsActive || session.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, errors.New("session expired")
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := s.userRepo.GetByID(session.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        // Check if user can still login
        <span class="cov0" title="0">if !user.CanLogin() </span><span class="cov0" title="0">{
                // Deactivate session
                s.userRepo.DeactivateSession(session.ID)
                return nil, errors.New("account is disabled")
        }</span>

        // Load user role
        <span class="cov0" title="0">role, err := s.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user role: %w", err)
        }</span>
        <span class="cov0" title="0">user.Role = role

        // Generate new JWT token
        newToken, err := s.generateJWT(user, session.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // Generate new refresh token
        <span class="cov0" title="0">newRefreshToken, err := s.generateRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        // Update session with new tokens and extend expiry
        <span class="cov0" title="0">newExpiry := time.Now().Add(s.refreshExp)
        err = s.userRepo.UpdateSessionTokensAndExpiry(session.ID, newToken, newRefreshToken, newExpiry)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update session: %w", err)
        }</span>

        // Update last activity
        <span class="cov0" title="0">s.userRepo.UpdateSessionActivity(session.ID)

        return &amp;AuthResult{
                User:         user,
                SessionToken: newToken,
                RefreshToken: newRefreshToken,
                ExpiresAt:    newExpiry,
        }, nil</span>
}

// Logout terminates a user session
func (s *AuthService) Logout(sessionToken string) error <span class="cov0" title="0">{
        claims, err := s.validateToken(sessionToken)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sessionID, _ := strconv.Atoi(claims.SessionID)
        return s.userRepo.DeactivateSession(sessionID)</span>
}

// LogoutAll terminates all sessions for a user
func (s *AuthService) LogoutAll(userID int) error <span class="cov0" title="0">{
        return s.userRepo.DeactivateAllUserSessions(userID)
}</span>

// ValidateToken validates a JWT token and returns the claims
func (s *AuthService) ValidateToken(tokenString string) (*JWTClaims, error) <span class="cov0" title="0">{
        return s.validateToken(tokenString)
}</span>

// GetCurrentUser gets the current user from a JWT token
func (s *AuthService) GetCurrentUser(tokenString string) (*models.User, error) <span class="cov0" title="0">{
        claims, err := s.validateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if session is still active
        <span class="cov0" title="0">session, err := s.userRepo.GetSession(claims.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("session not found")
        }</span>

        <span class="cov0" title="0">if !session.IsActive || session.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, errors.New("session expired")
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := s.userRepo.GetByID(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        // Load user role
        <span class="cov0" title="0">role, err := s.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user role: %w", err)
        }</span>
        <span class="cov0" title="0">user.Role = role

        // Update session activity
        sessionID, _ := strconv.Atoi(claims.SessionID)
        s.userRepo.UpdateSessionActivity(sessionID)

        return user, nil</span>
}

// ChangePassword changes a user's password
func (s *AuthService) ChangePassword(userID int, currentPassword, newPassword string) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>

        // Verify current password
        <span class="cov0" title="0">if !s.verifyPassword(currentPassword, user.Salt, user.PasswordHash) </span><span class="cov0" title="0">{
                return errors.New("current password is incorrect")
        }</span>

        // Generate new salt and hash
        <span class="cov0" title="0">salt, err := s.generateSalt()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov0" title="0">passwordHash, err := s.hashPassword(newPassword, salt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Update password
        <span class="cov0" title="0">err = s.userRepo.UpdatePassword(userID, passwordHash, salt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        // Deactivate all sessions except current one (force re-login on other devices)
        // This is a security best practice when password changes
        <span class="cov0" title="0">return s.userRepo.DeactivateAllUserSessions(userID)</span>
}

// ResetPassword resets a user's password (admin function)
func (s *AuthService) ResetPassword(userID int, newPassword string) error <span class="cov0" title="0">{
        // Generate new salt and hash
        salt, err := s.generateSalt()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov0" title="0">passwordHash, err := s.hashPassword(newPassword, salt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Update password
        <span class="cov0" title="0">err = s.userRepo.UpdatePassword(userID, passwordHash, salt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        // Deactivate all sessions (force re-login)
        <span class="cov0" title="0">return s.userRepo.DeactivateAllUserSessions(userID)</span>
}

// CheckPermission checks if a user has a specific permission
func (s *AuthService) CheckPermission(userID int, permission string) (bool, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">role, err := s.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get user role: %w", err)
        }</span>

        <span class="cov0" title="0">return role.Permissions.HasPermission(permission), nil</span>
}

// Private helper methods

func (s *AuthService) createSession(user *models.User, deviceInfo models.DeviceInfo, ipAddress, userAgent string, rememberMe bool) (*models.UserSession, error) <span class="cov0" title="0">{
        sessionToken, err := s.generateSessionToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set expiry based on remember me
        <span class="cov0" title="0">expiry := time.Now().Add(s.jwtExpiry)
        if rememberMe </span><span class="cov0" title="0">{
                expiry = time.Now().Add(s.refreshExp)
        }</span>

        <span class="cov0" title="0">session := &amp;models.UserSession{
                UserID:         user.ID,
                SessionToken:   sessionToken,
                DeviceInfo:     deviceInfo,
                IPAddress:      &amp;ipAddress,
                UserAgent:      &amp;userAgent,
                IsActive:       true,
                ExpiresAt:      expiry,
                CreatedAt:      time.Now(),
                LastActivityAt: time.Now(),
        }

        id, err := s.userRepo.CreateSession(session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">session.ID = id
        return session, nil</span>
}

func (s *AuthService) generateJWT(user *models.User, sessionID int) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        claims := JWTClaims{
                UserID:    user.ID,
                Username:  user.Username,
                RoleID:    user.RoleID,
                SessionID: fmt.Sprintf("%d", sessionID),
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(now.Add(s.jwtExpiry)),
                        IssuedAt:  jwt.NewNumericDate(now),
                        Issuer:    "catalogizer",
                        Subject:   fmt.Sprintf("%d", user.ID),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(s.jwtSecret)
}</span>

func (s *AuthService) validateToken(tokenString string) (*JWTClaims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return s.jwtSecret, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}

func (s *AuthService) generateSessionToken() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

func (s *AuthService) generateRefreshToken() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

func (s *AuthService) generateSalt() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 16)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

func (s *AuthService) hashPassword(password, salt string) (string, error) <span class="cov0" title="0">{
        // Combine password and salt
        combined := password + salt

        // Use bcrypt for additional security
        hash, err := bcrypt.GenerateFromPassword([]byte(combined), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(hash), nil</span>
}

func (s *AuthService) verifyPassword(password, salt, hash string) bool <span class="cov0" title="0">{
        // Combine password and salt
        combined := password + salt

        // Compare with bcrypt
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(combined))
        return err == nil
}</span>

// Session management methods

// GetActiveSessions returns all active sessions for a user
func (s *AuthService) GetActiveSessions(userID int) ([]models.UserSession, error) <span class="cov0" title="0">{
        return s.userRepo.GetActiveUserSessions(userID)
}</span>

// DeactivateSession deactivates a specific session
func (s *AuthService) DeactivateSession(sessionID int) error <span class="cov0" title="0">{
        return s.userRepo.DeactivateSession(sessionID)
}</span>

// CleanupExpiredSessions removes expired sessions from the database
func (s *AuthService) CleanupExpiredSessions() error <span class="cov0" title="0">{
        return s.userRepo.CleanupExpiredSessions()
}</span>

// UpdateSessionActivity updates the last activity time for a session
func (s *AuthService) UpdateSessionActivity(sessionID int) error <span class="cov0" title="0">{
        return s.userRepo.UpdateSessionActivity(sessionID)
}</span>

// Security utilities

// GenerateSecureToken generates a cryptographically secure random token
func (s *AuthService) GenerateSecureToken(length int) (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, length)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

// HashData creates a SHA-256 hash of the given data
func (s *AuthService) HashData(data string) string <span class="cov0" title="0">{
        hash := sha256.Sum256([]byte(data))
        return hex.EncodeToString(hash[:])
}</span>

// ValidatePassword checks if a password meets security requirements
func (s *AuthService) ValidatePassword(password string) error <span class="cov0" title="0">{
        if len(password) &lt; 8 </span><span class="cov0" title="0">{
                return errors.New("password must be at least 8 characters long")
        }</span>

        // Add more password validation rules as needed
        // - Must contain uppercase letter
        // - Must contain lowercase letter
        // - Must contain number
        // - Must contain special character

        <span class="cov0" title="0">return nil</span>
}

// Account security methods

// LockAccount locks a user account until the specified time
func (s *AuthService) LockAccount(userID int, lockUntil time.Time) error <span class="cov0" title="0">{
        return s.userRepo.LockAccount(userID, lockUntil)
}</span>

// UnlockAccount unlocks a user account
func (s *AuthService) UnlockAccount(userID int) error <span class="cov0" title="0">{
        return s.userRepo.UnlockAccount(userID)
}</span>

// CheckAccountLockout checks if an account should be locked due to failed attempts
func (s *AuthService) CheckAccountLockout(userID int) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Lock account if too many failed attempts
        <span class="cov0" title="0">maxAttempts := 5 // This should be configurable
        if user.FailedLoginAttempts &gt;= maxAttempts </span><span class="cov0" title="0">{
                lockDuration := 30 * time.Minute // This should be configurable
                lockUntil := time.Now().Add(lockDuration)
                return s.LockAccount(userID, lockUntil)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package services

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "reflect"
        "sort"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type ConfigurationService struct {
        configRepo  *repository.ConfigurationRepository
        configPath  string
        config      *models.SystemConfiguration
        wizardSteps []*models.WizardStep
        validators  map[string]ConfigValidator
}

type ConfigValidator interface {
        Validate(value interface{}) error
}

type DatabaseValidator struct{}
type NetworkValidator struct{}
type PathValidator struct{}
type EmailValidator struct{}

func NewConfigurationService(configRepo *repository.ConfigurationRepository, configPath string) *ConfigurationService <span class="cov0" title="0">{
        service := &amp;ConfigurationService{
                configRepo: configRepo,
                configPath: configPath,
                validators: make(map[string]ConfigValidator),
        }

        // Register validators
        service.validators["database"] = &amp;DatabaseValidator{}
        service.validators["network"] = &amp;NetworkValidator{}
        service.validators["path"] = &amp;PathValidator{}
        service.validators["email"] = &amp;EmailValidator{}

        // Initialize wizard steps
        service.initializeWizardSteps()

        // Load current configuration
        service.loadConfiguration()

        return service
}</span>

func (s *ConfigurationService) initializeWizardSteps() <span class="cov0" title="0">{
        s.wizardSteps = []*models.WizardStep{
                {
                        ID:          "welcome",
                        Name:        "Welcome",
                        Description: "Welcome to Catalogizer Setup Wizard",
                        Type:        models.WizardStepTypeInfo,
                        Required:    true,
                        Order:       1,
                        Content: map[string]interface{}{
                                "title":   "Welcome to Catalogizer v3.0",
                                "message": "This wizard will help you configure your media cataloging system.",
                        },
                },
                {
                        ID:          "database",
                        Name:        "Database Configuration",
                        Description: "Configure your database connection",
                        Type:        models.WizardStepTypeForm,
                        Required:    true,
                        Order:       2,
                        Fields: []*models.WizardField{
                                {
                                        Name:         "database_type",
                                        Label:        "Database Type",
                                        Type:         "select",
                                        Required:     true,
                                        Options:      []string{"sqlite", "mysql", "postgresql"},
                                        DefaultValue: "sqlite",
                                },
                                {
                                        Name:         "database_host",
                                        Label:        "Database Host",
                                        Type:         "text",
                                        Required:     false,
                                        DefaultValue: "localhost",
                                        ShowWhen:     map[string]interface{}{"database_type": []string{"mysql", "postgresql"}},
                                },
                                {
                                        Name:         "database_port",
                                        Label:        "Database Port",
                                        Type:         "number",
                                        Required:     false,
                                        DefaultValue: 3306,
                                        ShowWhen:     map[string]interface{}{"database_type": []string{"mysql", "postgresql"}},
                                },
                                {
                                        Name:         "database_name",
                                        Label:        "Database Name",
                                        Type:         "text",
                                        Required:     true,
                                        DefaultValue: "catalogizer",
                                },
                                {
                                        Name:     "database_username",
                                        Label:    "Database Username",
                                        Type:     "text",
                                        Required: false,
                                        ShowWhen: map[string]interface{}{"database_type": []string{"mysql", "postgresql"}},
                                },
                                {
                                        Name:     "database_password",
                                        Label:    "Database Password",
                                        Type:     "password",
                                        Required: false,
                                        ShowWhen: map[string]interface{}{"database_type": []string{"mysql", "postgresql"}},
                                },
                        },
                        Validation: map[string]interface{}{
                                "validator": "database",
                        },
                },
                {
                        ID:          "storage",
                        Name:        "Storage Configuration",
                        Description: "Configure storage locations and settings",
                        Type:        models.WizardStepTypeForm,
                        Required:    true,
                        Order:       3,
                        Fields: []*models.WizardField{
                                {
                                        Name:         "media_directory",
                                        Label:        "Media Directory",
                                        Type:         "directory",
                                        Required:     true,
                                        DefaultValue: "/var/lib/catalogizer/media",
                                        Validation:   map[string]interface{}{"validator": "path"},
                                },
                                {
                                        Name:         "thumbnail_directory",
                                        Label:        "Thumbnail Directory",
                                        Type:         "directory",
                                        Required:     true,
                                        DefaultValue: "/var/lib/catalogizer/thumbnails",
                                        Validation:   map[string]interface{}{"validator": "path"},
                                },
                                {
                                        Name:         "temp_directory",
                                        Label:        "Temporary Directory",
                                        Type:         "directory",
                                        Required:     true,
                                        DefaultValue: "/tmp/catalogizer",
                                        Validation:   map[string]interface{}{"validator": "path"},
                                },
                                {
                                        Name:         "max_file_size",
                                        Label:        "Maximum File Size (MB)",
                                        Type:         "number",
                                        Required:     true,
                                        DefaultValue: 1000,
                                },
                                {
                                        Name:         "storage_quota",
                                        Label:        "Storage Quota (GB, 0 = unlimited)",
                                        Type:         "number",
                                        Required:     false,
                                        DefaultValue: 0,
                                },
                        },
                },
                {
                        ID:          "network",
                        Name:        "Network Configuration",
                        Description: "Configure network and API settings",
                        Type:        models.WizardStepTypeForm,
                        Required:    true,
                        Order:       4,
                        Fields: []*models.WizardField{
                                {
                                        Name:         "server_host",
                                        Label:        "Server Host",
                                        Type:         "text",
                                        Required:     true,
                                        DefaultValue: "0.0.0.0",
                                        Validation:   map[string]interface{}{"validator": "network"},
                                },
                                {
                                        Name:         "server_port",
                                        Label:        "Server Port",
                                        Type:         "number",
                                        Required:     true,
                                        DefaultValue: 8080,
                                        Validation:   map[string]interface{}{"validator": "network"},
                                },
                                {
                                        Name:         "enable_https",
                                        Label:        "Enable HTTPS",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: false,
                                },
                                {
                                        Name:     "ssl_cert_path",
                                        Label:    "SSL Certificate Path",
                                        Type:     "file",
                                        Required: false,
                                        ShowWhen: map[string]interface{}{"enable_https": true},
                                },
                                {
                                        Name:     "ssl_key_path",
                                        Label:    "SSL Private Key Path",
                                        Type:     "file",
                                        Required: false,
                                        ShowWhen: map[string]interface{}{"enable_https": true},
                                },
                                {
                                        Name:         "cors_origins",
                                        Label:        "CORS Allowed Origins",
                                        Type:         "text",
                                        Required:     false,
                                        DefaultValue: "*",
                                },
                        },
                },
                {
                        ID:          "authentication",
                        Name:        "Authentication Setup",
                        Description: "Configure authentication and security settings",
                        Type:        models.WizardStepTypeForm,
                        Required:    true,
                        Order:       5,
                        Fields: []*models.WizardField{
                                {
                                        Name:     "jwt_secret",
                                        Label:    "JWT Secret Key",
                                        Type:     "password",
                                        Required: true,
                                        Generate: true,
                                },
                                {
                                        Name:         "session_timeout",
                                        Label:        "Session Timeout (hours)",
                                        Type:         "number",
                                        Required:     true,
                                        DefaultValue: 24,
                                },
                                {
                                        Name:         "enable_registration",
                                        Label:        "Allow User Registration",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                                {
                                        Name:         "require_email_verification",
                                        Label:        "Require Email Verification",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: false,
                                },
                                {
                                        Name:       "admin_email",
                                        Label:      "Administrator Email",
                                        Type:       "email",
                                        Required:   true,
                                        Validation: map[string]interface{}{"validator": "email"},
                                },
                        },
                },
                {
                        ID:          "features",
                        Name:        "Feature Configuration",
                        Description: "Enable and configure advanced features",
                        Type:        models.WizardStepTypeForm,
                        Required:    false,
                        Order:       6,
                        Fields: []*models.WizardField{
                                {
                                        Name:         "enable_media_conversion",
                                        Label:        "Enable Media Format Conversion",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                                {
                                        Name:         "enable_webdav_sync",
                                        Label:        "Enable WebDAV Synchronization",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: false,
                                },
                                {
                                        Name:         "enable_stress_testing",
                                        Label:        "Enable Stress Testing",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: false,
                                },
                                {
                                        Name:         "enable_error_reporting",
                                        Label:        "Enable Error Reporting",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                                {
                                        Name:         "enable_log_management",
                                        Label:        "Enable Log Management",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                        },
                },
                {
                        ID:          "external_services",
                        Name:        "External Services",
                        Description: "Configure integrations with external services",
                        Type:        models.WizardStepTypeForm,
                        Required:    false,
                        Order:       7,
                        Fields: []*models.WizardField{
                                {
                                        Name:     "smtp_host",
                                        Label:    "SMTP Host",
                                        Type:     "text",
                                        Required: false,
                                },
                                {
                                        Name:         "smtp_port",
                                        Label:        "SMTP Port",
                                        Type:         "number",
                                        Required:     false,
                                        DefaultValue: 587,
                                },
                                {
                                        Name:     "smtp_username",
                                        Label:    "SMTP Username",
                                        Type:     "text",
                                        Required: false,
                                },
                                {
                                        Name:     "smtp_password",
                                        Label:    "SMTP Password",
                                        Type:     "password",
                                        Required: false,
                                },
                                {
                                        Name:     "slack_webhook_url",
                                        Label:    "Slack Webhook URL",
                                        Type:     "text",
                                        Required: false,
                                },
                                {
                                        Name:         "enable_analytics",
                                        Label:        "Enable Analytics",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                        },
                },
                {
                        ID:          "summary",
                        Name:        "Configuration Summary",
                        Description: "Review your configuration before applying",
                        Type:        models.WizardStepTypeSummary,
                        Required:    true,
                        Order:       8,
                },
                {
                        ID:          "complete",
                        Name:        "Setup Complete",
                        Description: "Configuration has been applied successfully",
                        Type:        models.WizardStepTypeComplete,
                        Required:    true,
                        Order:       9,
                },
        }

        // Sort steps by order
        sort.Slice(s.wizardSteps, func(i, j int) bool </span><span class="cov0" title="0">{
                return s.wizardSteps[i].Order &lt; s.wizardSteps[j].Order
        }</span>)
}

func (s *ConfigurationService) GetWizardSteps() ([]*models.WizardStep, error) <span class="cov0" title="0">{
        return s.wizardSteps, nil
}</span>

func (s *ConfigurationService) GetWizardStep(stepID string) (*models.WizardStep, error) <span class="cov0" title="0">{
        for _, step := range s.wizardSteps </span><span class="cov0" title="0">{
                if step.ID == stepID </span><span class="cov0" title="0">{
                        return step, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("wizard step not found: %s", stepID)</span>
}

func (s *ConfigurationService) ValidateWizardStep(stepID string, data map[string]interface{}) (*models.WizardStepValidation, error) <span class="cov0" title="0">{
        step, err := s.GetWizardStep(stepID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">validation := &amp;models.WizardStepValidation{
                StepID:   stepID,
                Valid:    true,
                Errors:   make(map[string]string),
                Warnings: make(map[string]string),
        }

        // Validate required fields
        for _, field := range step.Fields </span><span class="cov0" title="0">{
                value, exists := data[field.Name]

                if field.Required &amp;&amp; (!exists || s.isEmptyValue(value)) </span><span class="cov0" title="0">{
                        validation.Valid = false
                        validation.Errors[field.Name] = fmt.Sprintf("%s is required", field.Label)
                        continue</span>
                }

                // Validate field using validator
                <span class="cov0" title="0">if exists &amp;&amp; field.Validation != nil </span><span class="cov0" title="0">{
                        if validatorName, ok := field.Validation["validator"].(string); ok </span><span class="cov0" title="0">{
                                if validator, validatorExists := s.validators[validatorName]; validatorExists </span><span class="cov0" title="0">{
                                        if err := validator.Validate(value); err != nil </span><span class="cov0" title="0">{
                                                validation.Valid = false
                                                validation.Errors[field.Name] = err.Error()
                                        }</span>
                                }
                        }
                }
        }

        // Custom step validation
        <span class="cov0" title="0">if step.Validation != nil </span><span class="cov0" title="0">{
                if validatorName, ok := step.Validation["validator"].(string); ok </span><span class="cov0" title="0">{
                        if validator, exists := s.validators[validatorName]; exists </span><span class="cov0" title="0">{
                                if err := validator.Validate(data); err != nil </span><span class="cov0" title="0">{
                                        validation.Valid = false
                                        validation.Errors["_general"] = err.Error()
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return validation, nil</span>
}

func (s *ConfigurationService) SaveWizardProgress(userID int, stepID string, data map[string]interface{}) error <span class="cov0" title="0">{
        progress := &amp;models.WizardProgress{
                UserID:      userID,
                CurrentStep: stepID,
                StepData:    data,
                UpdatedAt:   time.Now(),
        }

        return s.configRepo.SaveWizardProgress(progress)
}</span>

func (s *ConfigurationService) GetWizardProgress(userID int) (*models.WizardProgress, error) <span class="cov0" title="0">{
        return s.configRepo.GetWizardProgress(userID)
}</span>

func (s *ConfigurationService) CompleteWizard(userID int, finalData map[string]interface{}) (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        // Generate the full configuration from wizard data
        config := s.generateConfiguration(finalData)

        // Validate the complete configuration
        if err := s.validateConfiguration(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        // Save configuration
        <span class="cov0" title="0">if err := s.SaveConfiguration(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save configuration: %w", err)
        }</span>

        // Mark wizard as completed
        <span class="cov0" title="0">if err := s.configRepo.MarkWizardCompleted(userID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to mark wizard as completed: %w", err)
        }</span>

        // Clean up wizard progress
        <span class="cov0" title="0">s.configRepo.DeleteWizardProgress(userID)

        return config, nil</span>
}

func (s *ConfigurationService) GetConfiguration() (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        if s.config == nil </span><span class="cov0" title="0">{
                return s.loadConfiguration()
        }</span>
        <span class="cov0" title="0">return s.config, nil</span>
}

func (s *ConfigurationService) SaveConfiguration(config *models.SystemConfiguration) error <span class="cov0" title="0">{
        // Validate configuration
        if err := s.validateConfiguration(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        // Save to database
        <span class="cov0" title="0">if err := s.configRepo.SaveConfiguration(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration to database: %w", err)
        }</span>

        // Save to file
        <span class="cov0" title="0">if err := s.saveConfigurationFile(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration file: %w", err)
        }</span>

        <span class="cov0" title="0">s.config = config
        return nil</span>
}

func (s *ConfigurationService) UpdateConfiguration(updates map[string]interface{}) (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        config, err := s.GetConfiguration()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Apply updates using reflection
        <span class="cov0" title="0">configValue := reflect.ValueOf(config).Elem()
        for key, value := range updates </span><span class="cov0" title="0">{
                field := configValue.FieldByName(s.toCamelCase(key))
                if field.IsValid() &amp;&amp; field.CanSet() </span><span class="cov0" title="0">{
                        newValue := reflect.ValueOf(value)
                        if newValue.Type().ConvertibleTo(field.Type()) </span><span class="cov0" title="0">{
                                field.Set(newValue.Convert(field.Type()))
                        }</span>
                }
        }

        <span class="cov0" title="0">return config, s.SaveConfiguration(config)</span>
}

func (s *ConfigurationService) ResetConfiguration() error <span class="cov0" title="0">{
        // Create default configuration
        config := s.createDefaultConfiguration()

        return s.SaveConfiguration(config)
}</span>

func (s *ConfigurationService) ExportConfiguration() ([]byte, error) <span class="cov0" title="0">{
        config, err := s.GetConfiguration()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return json.MarshalIndent(config, "", "  ")</span>
}

func (s *ConfigurationService) ImportConfiguration(data []byte) (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        var config models.SystemConfiguration
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse configuration: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.SaveConfiguration(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (s *ConfigurationService) GetConfigurationSchema() (*models.ConfigurationSchema, error) <span class="cov0" title="0">{
        return &amp;models.ConfigurationSchema{
                Version: "3.0.0",
                Sections: []*models.ConfigSection{
                        {
                                Name:        "Database",
                                Key:         "database",
                                Description: "Database configuration settings",
                                Fields:      s.getDatabaseFields(),
                        },
                        {
                                Name:        "Storage",
                                Key:         "storage",
                                Description: "Storage and file system settings",
                                Fields:      s.getStorageFields(),
                        },
                        {
                                Name:        "Network",
                                Key:         "network",
                                Description: "Network and API settings",
                                Fields:      s.getNetworkFields(),
                        },
                        {
                                Name:        "Authentication",
                                Key:         "authentication",
                                Description: "Authentication and security settings",
                                Fields:      s.getAuthenticationFields(),
                        },
                        {
                                Name:        "Features",
                                Key:         "features",
                                Description: "Feature toggles and advanced settings",
                                Fields:      s.getFeatureFields(),
                        },
                },
        }, nil
}</span>

func (s *ConfigurationService) TestConfiguration(config *models.SystemConfiguration) (*models.ConfigurationTest, error) <span class="cov0" title="0">{
        test := &amp;models.ConfigurationTest{
                TestedAt: time.Now(),
                Results:  make(map[string]*models.TestResult),
        }

        // Test database connection
        test.Results["database"] = s.testDatabaseConnection(config)

        // Test storage paths
        test.Results["storage"] = s.testStoragePaths(config)

        // Test network configuration
        test.Results["network"] = s.testNetworkConfiguration(config)

        // Test external services
        test.Results["external_services"] = s.testExternalServices(config)

        // Calculate overall status
        test.OverallStatus = "passed"
        for _, result := range test.Results </span><span class="cov0" title="0">{
                if result.Status == "failed" </span><span class="cov0" title="0">{
                        test.OverallStatus = "failed"
                        break</span>
                } else<span class="cov0" title="0"> if result.Status == "warning" &amp;&amp; test.OverallStatus == "passed" </span><span class="cov0" title="0">{
                        test.OverallStatus = "warning"
                }</span>
        }

        <span class="cov0" title="0">return test, nil</span>
}

// Helper methods

func (s *ConfigurationService) loadConfiguration() (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        // Try to load from database first
        config, err := s.configRepo.GetConfiguration()
        if err == nil </span><span class="cov0" title="0">{
                s.config = config
                return config, nil
        }</span>

        // Try to load from file
        <span class="cov0" title="0">if _, err := os.Stat(s.configPath); err == nil </span><span class="cov0" title="0">{
                config, err := s.loadConfigurationFile()
                if err == nil </span><span class="cov0" title="0">{
                        s.config = config
                        return config, nil
                }</span>
        }

        // Create default configuration
        <span class="cov0" title="0">config = s.createDefaultConfiguration()
        s.config = config
        return config, nil</span>
}

func (s *ConfigurationService) loadConfigurationFile() (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(s.configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var config models.SystemConfiguration
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (s *ConfigurationService) saveConfigurationFile(config *models.SystemConfiguration) error <span class="cov0" title="0">{
        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(s.configPath), 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(s.configPath, data, 0644)</span>
}

func (s *ConfigurationService) createDefaultConfiguration() *models.SystemConfiguration <span class="cov0" title="0">{
        return &amp;models.SystemConfiguration{
                Version:   "3.0.0",
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Database: &amp;models.DatabaseConfig{
                        Type: "sqlite",
                        Name: "catalogizer.db",
                },
                Storage: &amp;models.StorageConfig{
                        MediaDirectory:     "/var/lib/catalogizer/media",
                        ThumbnailDirectory: "/var/lib/catalogizer/thumbnails",
                        TempDirectory:      "/tmp/catalogizer",
                        MaxFileSize:        1000 * 1024 * 1024, // 1GB
                },
                Network: &amp;models.NetworkConfig{
                        Host: "0.0.0.0",
                        Port: 8080,
                        CORS: &amp;models.CORSConfig{
                                AllowedOrigins: []string{"*"},
                        },
                },
                Authentication: &amp;models.AuthenticationConfig{
                        SessionTimeout:           24 * time.Hour,
                        EnableRegistration:       true,
                        RequireEmailVerification: false,
                },
                Features: &amp;models.FeatureConfig{
                        MediaConversion: true,
                        ErrorReporting:  true,
                        LogManagement:   true,
                },
        }
}</span>

func (s *ConfigurationService) generateConfiguration(wizardData map[string]interface{}) *models.SystemConfiguration <span class="cov0" title="0">{
        config := s.createDefaultConfiguration()

        // Apply wizard data to configuration
        // This is a simplified implementation
        for key, value := range wizardData </span><span class="cov0" title="0">{
                switch key </span>{
                case "database_type":<span class="cov0" title="0">
                        config.Database.Type = value.(string)</span>
                case "database_host":<span class="cov0" title="0">
                        config.Database.Host = value.(string)</span>
                case "database_port":<span class="cov0" title="0">
                        if port, ok := value.(float64); ok </span><span class="cov0" title="0">{
                                config.Database.Port = int(port)
                        }</span>
                case "database_name":<span class="cov0" title="0">
                        config.Database.Name = value.(string)</span>
                case "database_username":<span class="cov0" title="0">
                        config.Database.Username = value.(string)</span>
                case "database_password":<span class="cov0" title="0">
                        config.Database.Password = value.(string)</span>
                case "media_directory":<span class="cov0" title="0">
                        config.Storage.MediaDirectory = value.(string)</span>
                case "thumbnail_directory":<span class="cov0" title="0">
                        config.Storage.ThumbnailDirectory = value.(string)</span>
                case "temp_directory":<span class="cov0" title="0">
                        config.Storage.TempDirectory = value.(string)</span>
                case "server_host":<span class="cov0" title="0">
                        config.Network.Host = value.(string)</span>
                case "server_port":<span class="cov0" title="0">
                        if port, ok := value.(float64); ok </span><span class="cov0" title="0">{
                                config.Network.Port = int(port)
                        }</span>
                case "enable_https":<span class="cov0" title="0">
                        config.Network.HTTPS = &amp;models.HTTPSConfig{
                                Enabled: value.(bool),
                        }</span>
                }
        }

        <span class="cov0" title="0">config.UpdatedAt = time.Now()
        return config</span>
}

func (s *ConfigurationService) validateConfiguration(config *models.SystemConfiguration) error <span class="cov0" title="0">{
        // Basic validation
        if config.Database == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database configuration is required")
        }</span>

        <span class="cov0" title="0">if config.Storage == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("storage configuration is required")
        }</span>

        <span class="cov0" title="0">if config.Network == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("network configuration is required")
        }</span>

        // Validate database configuration
        <span class="cov0" title="0">if config.Database.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database type is required")
        }</span>

        // Validate storage paths
        <span class="cov0" title="0">if config.Storage.MediaDirectory == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("media directory is required")
        }</span>

        // Validate network configuration
        <span class="cov0" title="0">if config.Network.Port &lt;= 0 || config.Network.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid network port: %d", config.Network.Port)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationService) isEmptyValue(value interface{}) bool <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return strings.TrimSpace(v) == ""</span>
        case []string:<span class="cov0" title="0">
                return len(v) == 0</span>
        case map[string]interface{}:<span class="cov0" title="0">
                return len(v) == 0</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (s *ConfigurationService) toCamelCase(str string) string <span class="cov0" title="0">{
        parts := strings.Split(str, "_")
        for i := range parts </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        parts[i] = strings.Title(parts[i])
                }</span>
        }
        <span class="cov0" title="0">return strings.Join(parts, "")</span>
}

func (s *ConfigurationService) getDatabaseFields() []*models.ConfigField <span class="cov0" title="0">{
        return []*models.ConfigField{
                {Name: "type", Label: "Database Type", Type: "select", Required: true},
                {Name: "host", Label: "Host", Type: "text", Required: false},
                {Name: "port", Label: "Port", Type: "number", Required: false},
                {Name: "name", Label: "Database Name", Type: "text", Required: true},
                {Name: "username", Label: "Username", Type: "text", Required: false},
                {Name: "password", Label: "Password", Type: "password", Required: false},
        }
}</span>

func (s *ConfigurationService) getStorageFields() []*models.ConfigField <span class="cov0" title="0">{
        return []*models.ConfigField{
                {Name: "media_directory", Label: "Media Directory", Type: "directory", Required: true},
                {Name: "thumbnail_directory", Label: "Thumbnail Directory", Type: "directory", Required: true},
                {Name: "temp_directory", Label: "Temporary Directory", Type: "directory", Required: true},
                {Name: "max_file_size", Label: "Max File Size (MB)", Type: "number", Required: true},
        }
}</span>

func (s *ConfigurationService) getNetworkFields() []*models.ConfigField <span class="cov0" title="0">{
        return []*models.ConfigField{
                {Name: "host", Label: "Host", Type: "text", Required: true},
                {Name: "port", Label: "Port", Type: "number", Required: true},
                {Name: "enable_https", Label: "Enable HTTPS", Type: "checkbox", Required: false},
        }
}</span>

func (s *ConfigurationService) getAuthenticationFields() []*models.ConfigField <span class="cov0" title="0">{
        return []*models.ConfigField{
                {Name: "jwt_secret", Label: "JWT Secret", Type: "password", Required: true},
                {Name: "session_timeout", Label: "Session Timeout (hours)", Type: "number", Required: true},
                {Name: "enable_registration", Label: "Enable Registration", Type: "checkbox", Required: false},
        }
}</span>

func (s *ConfigurationService) getFeatureFields() []*models.ConfigField <span class="cov0" title="0">{
        return []*models.ConfigField{
                {Name: "media_conversion", Label: "Media Conversion", Type: "checkbox", Required: false},
                {Name: "error_reporting", Label: "Error Reporting", Type: "checkbox", Required: false},
                {Name: "log_management", Label: "Log Management", Type: "checkbox", Required: false},
        }
}</span>

func (s *ConfigurationService) testDatabaseConnection(config *models.SystemConfiguration) *models.TestResult <span class="cov0" title="0">{
        // Simplified test implementation
        return &amp;models.TestResult{
                Status:  "passed",
                Message: "Database connection test passed",
        }
}</span>

func (s *ConfigurationService) testStoragePaths(config *models.SystemConfiguration) *models.TestResult <span class="cov0" title="0">{
        // Test if storage directories are accessible
        paths := []string{
                config.Storage.MediaDirectory,
                config.Storage.ThumbnailDirectory,
                config.Storage.TempDirectory,
        }

        for _, path := range paths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return &amp;models.TestResult{
                                Status:  "warning",
                                Message: fmt.Sprintf("Directory does not exist: %s", path),
                        }
                }</span>
        }

        <span class="cov0" title="0">return &amp;models.TestResult{
                Status:  "passed",
                Message: "All storage paths are accessible",
        }</span>
}

func (s *ConfigurationService) testNetworkConfiguration(config *models.SystemConfiguration) *models.TestResult <span class="cov0" title="0">{
        // Simplified network test
        if config.Network.Port &lt; 1024 &amp;&amp; os.Getuid() != 0 </span><span class="cov0" title="0">{
                return &amp;models.TestResult{
                        Status:  "warning",
                        Message: "Port below 1024 requires root privileges",
                }
        }</span>

        <span class="cov0" title="0">return &amp;models.TestResult{
                Status:  "passed",
                Message: "Network configuration is valid",
        }</span>
}

func (s *ConfigurationService) testExternalServices(config *models.SystemConfiguration) *models.TestResult <span class="cov0" title="0">{
        // Test external service connections
        return &amp;models.TestResult{
                Status:  "passed",
                Message: "External services test passed",
        }
}</span>

// Validator implementations

func (v *DatabaseValidator) Validate(value interface{}) error <span class="cov0" title="0">{
        // Database validation logic
        return nil
}</span>

func (v *NetworkValidator) Validate(value interface{}) error <span class="cov0" title="0">{
        // Network validation logic
        return nil
}</span>

func (v *PathValidator) Validate(value interface{}) error <span class="cov0" title="0">{
        // Path validation logic
        if path, ok := value.(string); ok </span><span class="cov0" title="0">{
                if !filepath.IsAbs(path) </span><span class="cov0" title="0">{
                        return fmt.Errorf("path must be absolute")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (v *EmailValidator) Validate(value interface{}) error <span class="cov0" title="0">{
        // Email validation logic
        if email, ok := value.(string); ok </span><span class="cov0" title="0">{
                if !strings.Contains(email, "@") </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid email format")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package services

import (
        "encoding/json"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type ConfigurationWizardService struct {
        repo            *repository.ConfigurationRepository
        configPath      string
        backupPath      string
        templatesPath   string
        currentSession  *models.WizardSession
        validationRules map[string]ValidationRule
        configTemplates map[string]ConfigTemplate
}

// models.WizardSession is defined in models package

type WizardStep struct {
        StepID          string                 `json:"step_id"`
        Title           string                 `json:"title"`
        Description     string                 `json:"description"`
        StepType        string                 `json:"step_type"` // input, select, multi-select, file-upload, test
        Fields          []FieldDefinition      `json:"fields"`
        Dependencies    []string               `json:"dependencies"`
        ValidationRules []string               `json:"validation_rules"`
        HelpText        string                 `json:"help_text"`
        IsOptional      bool                   `json:"is_optional"`
        SkipCondition   map[string]interface{} `json:"skip_condition,omitempty"`
}

type FieldDefinition struct {
        FieldID      string                 `json:"field_id"`
        Label        string                 `json:"label"`
        Type         string                 `json:"type"` // text, password, number, boolean, select, file, directory
        Required     bool                   `json:"required"`
        DefaultValue interface{}            `json:"default_value,omitempty"`
        Options      []FieldOption          `json:"options,omitempty"`
        Validation   string                 `json:"validation,omitempty"`
        HelpText     string                 `json:"help_text,omitempty"`
        Placeholder  string                 `json:"placeholder,omitempty"`
        MinValue     *float64               `json:"min_value,omitempty"`
        MaxValue     *float64               `json:"max_value,omitempty"`
        Pattern      string                 `json:"pattern,omitempty"`
        Dependencies map[string]interface{} `json:"dependencies,omitempty"`
}

type FieldOption struct {
        Value       string `json:"value"`
        Label       string `json:"label"`
        Description string `json:"description,omitempty"`
}

type ValidationRule struct {
        RuleID       string                 `json:"rule_id"`
        Type         string                 `json:"type"` // required, format, range, custom
        ErrorMessage string                 `json:"error_message"`
        Parameters   map[string]interface{} `json:"parameters,omitempty"`
}

type ConfigTemplate struct {
        TemplateID    string                 `json:"template_id"`
        Name          string                 `json:"name"`
        Description   string                 `json:"description"`
        Category      string                 `json:"category"`
        Steps         []WizardStep           `json:"steps"`
        DefaultValues map[string]interface{} `json:"default_values"`
        Requirements  []string               `json:"requirements"`
        PostInstall   []PostInstallAction    `json:"post_install_actions"`
}

type PostInstallAction struct {
        ActionType  string                 `json:"action_type"` // service_restart, file_create, command_run, validation
        Description string                 `json:"description"`
        Parameters  map[string]interface{} `json:"parameters"`
        Required    bool                   `json:"required"`
}

// ConfigurationProfile is defined in models package

type SystemInfo struct {
        OS              string            `json:"os"`
        Architecture    string            `json:"architecture"`
        GoVersion       string            `json:"go_version"`
        CPUCores        int               `json:"cpu_cores"`
        MemoryGB        float64           `json:"memory_gb"`
        DiskSpaceGB     float64           `json:"disk_space_gb"`
        NetworkInfo     NetworkInfo       `json:"network_info"`
        InstalledTools  []string          `json:"installed_tools"`
        EnvironmentVars map[string]string `json:"environment_vars"`
        Recommendations []string          `json:"recommendations"`
}

type NetworkInfo struct {
        Hostname    string   `json:"hostname"`
        IPAddresses []string `json:"ip_addresses"`
        DNSServers  []string `json:"dns_servers"`
        HasInternet bool     `json:"has_internet"`
}

type InstallationRequest struct {
        ConfigType     string                 `json:"config_type"`
        QuickInstall   bool                   `json:"quick_install"`
        CustomConfig   map[string]interface{} `json:"custom_config,omitempty"`
        SkipTests      bool                   `json:"skip_tests"`
        BackupExisting bool                   `json:"backup_existing"`
}

type InstallationProgress struct {
        SessionID      string    `json:"session_id"`
        CurrentAction  string    `json:"current_action"`
        Progress       float64   `json:"progress"`
        CompletedSteps []string  `json:"completed_steps"`
        FailedSteps    []string  `json:"failed_steps"`
        EstimatedTime  string    `json:"estimated_time"`
        LastUpdate     time.Time `json:"last_update"`
        IsCompleted    bool      `json:"is_completed"`
        HasErrors      bool      `json:"has_errors"`
        ErrorMessage   string    `json:"error_message,omitempty"`
}

func NewConfigurationWizardService(repo *repository.ConfigurationRepository) *ConfigurationWizardService <span class="cov0" title="0">{
        configPath := os.Getenv("CONFIG_PATH")
        if configPath == "" </span><span class="cov0" title="0">{
                configPath = "./config"
        }</span>

        <span class="cov0" title="0">service := &amp;ConfigurationWizardService{
                repo:            repo,
                configPath:      configPath,
                backupPath:      filepath.Join(configPath, "backups"),
                templatesPath:   filepath.Join(configPath, "templates"),
                validationRules: make(map[string]ValidationRule),
                configTemplates: make(map[string]ConfigTemplate),
        }

        // Initialize default templates and validation rules
        service.initializeDefaultTemplates()
        service.initializeValidationRules()

        // Ensure directories exist
        os.MkdirAll(service.configPath, 0755)
        os.MkdirAll(service.backupPath, 0755)
        os.MkdirAll(service.templatesPath, 0755)

        return service</span>
}

func (s *ConfigurationWizardService) initializeDefaultTemplates() <span class="cov0" title="0">{
        // Basic Installation Template
        s.configTemplates["basic"] = ConfigTemplate{
                TemplateID:  "basic",
                Name:        "Basic Installation",
                Description: "Quick setup for basic Catalogizer functionality",
                Category:    "installation",
                Steps: []WizardStep{
                        {
                                StepID:      "system_check",
                                Title:       "System Requirements Check",
                                Description: "Verify system meets minimum requirements",
                                StepType:    "test",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "auto_fix",
                                                Label:        "Automatically fix issues where possible",
                                                Type:         "boolean",
                                                DefaultValue: true,
                                        },
                                },
                        },
                        {
                                StepID:      "database_config",
                                Title:       "Database Configuration",
                                Description: "Configure database connection",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "db_type",
                                                Label:        "Database Type",
                                                Type:         "select",
                                                Required:     true,
                                                DefaultValue: "sqlite",
                                                Options: []FieldOption{
                                                        {Value: "sqlite", Label: "SQLite (Recommended)"},
                                                        {Value: "mysql", Label: "MySQL"},
                                                        {Value: "postgresql", Label: "PostgreSQL"},
                                                },
                                        },
                                        {
                                                FieldID:      "db_path",
                                                Label:        "Database File Path",
                                                Type:         "file",
                                                Required:     true,
                                                DefaultValue: "./catalogizer.db",
                                                Dependencies: map[string]interface{}{
                                                        "db_type": "sqlite",
                                                },
                                        },
                                        {
                                                FieldID:  "db_host",
                                                Label:    "Database Host",
                                                Type:     "text",
                                                Required: true,
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                        {
                                                FieldID:  "db_port",
                                                Label:    "Database Port",
                                                Type:     "number",
                                                MinValue: float64Ptr(1),
                                                MaxValue: float64Ptr(65535),
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                        {
                                                FieldID:  "db_name",
                                                Label:    "Database Name",
                                                Type:     "text",
                                                Required: true,
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                        {
                                                FieldID:  "db_username",
                                                Label:    "Database Username",
                                                Type:     "text",
                                                Required: true,
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                        {
                                                FieldID:  "db_password",
                                                Label:    "Database Password",
                                                Type:     "password",
                                                Required: true,
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                },
                        },
                        {
                                StepID:      "media_storage",
                                Title:       "Media Storage Configuration",
                                Description: "Configure where media files will be stored",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "storage_type",
                                                Label:        "Storage Type",
                                                Type:         "select",
                                                Required:     true,
                                                DefaultValue: "local",
                                                Options: []FieldOption{
                                                        {Value: "local", Label: "Local Storage"},
                                                        {Value: "s3", Label: "Amazon S3"},
                                                        {Value: "webdav", Label: "WebDAV"},
                                                        {Value: "ftp", Label: "FTP/SFTP"},
                                                },
                                        },
                                        {
                                                FieldID:      "media_path",
                                                Label:        "Media Directory Path",
                                                Type:         "directory",
                                                Required:     true,
                                                DefaultValue: "./media",
                                                Dependencies: map[string]interface{}{
                                                        "storage_type": "local",
                                                },
                                        },
                                        {
                                                FieldID:      "max_file_size",
                                                Label:        "Maximum File Size (MB)",
                                                Type:         "number",
                                                Required:     true,
                                                DefaultValue: 100,
                                                MinValue:     float64Ptr(1),
                                                MaxValue:     float64Ptr(10000),
                                        },
                                },
                        },
                        {
                                StepID:      "security_config",
                                Title:       "Security Configuration",
                                Description: "Configure authentication and security settings",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:    "jwt_secret",
                                                Label:      "JWT Secret Key",
                                                Type:       "password",
                                                Required:   true,
                                                HelpText:   "Secret key for JWT token generation (minimum 32 characters)",
                                                Validation: "min_length:32",
                                        },
                                        {
                                                FieldID:      "session_timeout",
                                                Label:        "Session Timeout (hours)",
                                                Type:         "number",
                                                Required:     true,
                                                DefaultValue: 24,
                                                MinValue:     float64Ptr(1),
                                                MaxValue:     float64Ptr(720),
                                        },
                                        {
                                                FieldID:      "enable_2fa",
                                                Label:        "Enable Two-Factor Authentication",
                                                Type:         "boolean",
                                                DefaultValue: false,
                                        },
                                        {
                                                FieldID:      "password_min_length",
                                                Label:        "Minimum Password Length",
                                                Type:         "number",
                                                Required:     true,
                                                DefaultValue: 8,
                                                MinValue:     float64Ptr(6),
                                                MaxValue:     float64Ptr(128),
                                        },
                                },
                        },
                        {
                                StepID:      "admin_user",
                                Title:       "Administrator Account",
                                Description: "Create the initial administrator account",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:     "admin_username",
                                                Label:       "Administrator Username",
                                                Type:        "text",
                                                Required:    true,
                                                Validation:  "username",
                                                Placeholder: "admin",
                                        },
                                        {
                                                FieldID:     "admin_email",
                                                Label:       "Administrator Email",
                                                Type:        "text",
                                                Required:    true,
                                                Validation:  "email",
                                                Placeholder: "admin@example.com",
                                        },
                                        {
                                                FieldID:    "admin_password",
                                                Label:      "Administrator Password",
                                                Type:       "password",
                                                Required:   true,
                                                Validation: "password_strength",
                                        },
                                        {
                                                FieldID:    "admin_password_confirm",
                                                Label:      "Confirm Password",
                                                Type:       "password",
                                                Required:   true,
                                                Validation: "password_match",
                                        },
                                },
                        },
                        {
                                StepID:      "service_config",
                                Title:       "Service Configuration",
                                Description: "Configure server and service settings",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "server_port",
                                                Label:        "Server Port",
                                                Type:         "number",
                                                Required:     true,
                                                DefaultValue: 8080,
                                                MinValue:     float64Ptr(1024),
                                                MaxValue:     float64Ptr(65535),
                                        },
                                        {
                                                FieldID:      "log_level",
                                                Label:        "Log Level",
                                                Type:         "select",
                                                Required:     true,
                                                DefaultValue: "info",
                                                Options: []FieldOption{
                                                        {Value: "debug", Label: "Debug"},
                                                        {Value: "info", Label: "Info"},
                                                        {Value: "warn", Label: "Warning"},
                                                        {Value: "error", Label: "Error"},
                                                },
                                        },
                                        {
                                                FieldID:      "enable_cors",
                                                Label:        "Enable CORS",
                                                Type:         "boolean",
                                                DefaultValue: true,
                                                HelpText:     "Enable Cross-Origin Resource Sharing for web clients",
                                        },
                                        {
                                                FieldID:      "backup_enabled",
                                                Label:        "Enable Automatic Backups",
                                                Type:         "boolean",
                                                DefaultValue: true,
                                        },
                                },
                        },
                        {
                                StepID:      "final_test",
                                Title:       "Final Configuration Test",
                                Description: "Test all configurations and start services",
                                StepType:    "test",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "start_services",
                                                Label:        "Start services after successful test",
                                                Type:         "boolean",
                                                DefaultValue: true,
                                        },
                                },
                        },
                },
                DefaultValues: map[string]interface{}{
                        "db_type":         "sqlite",
                        "storage_type":    "local",
                        "session_timeout": 24,
                        "server_port":     8080,
                        "log_level":       "info",
                },
                Requirements: []string{"go", "sqlite3"},
                PostInstall: []PostInstallAction{
                        {
                                ActionType:  "file_create",
                                Description: "Create configuration file",
                                Parameters: map[string]interface{}{
                                        "file_path": "./config/config.json",
                                        "template":  "config_template.json",
                                },
                                Required: true,
                        },
                        {
                                ActionType:  "service_restart",
                                Description: "Restart Catalogizer service",
                                Parameters: map[string]interface{}{
                                        "service_name": "catalogizer",
                                },
                                Required: false,
                        },
                },
        }

        // Enterprise Installation Template
        s.configTemplates["enterprise"] = ConfigTemplate{
                TemplateID:   "enterprise",
                Name:         "Enterprise Installation",
                Description:  "Full enterprise setup with all features enabled",
                Category:     "installation",
                Steps:        s.getEnterpriseSteps(),
                Requirements: []string{"go", "docker", "postgresql", "redis"},
        }

        // Development Template
        s.configTemplates["development"] = ConfigTemplate{
                TemplateID:   "development",
                Name:         "Development Environment",
                Description:  "Development setup with debugging and testing tools",
                Category:     "development",
                Steps:        s.getDevelopmentSteps(),
                Requirements: []string{"go", "git", "make"},
        }
}</span>

func (s *ConfigurationWizardService) getEnterpriseSteps() []WizardStep <span class="cov0" title="0">{
        // Return enterprise-specific configuration steps
        steps := []WizardStep{
                {
                        StepID:      "infrastructure",
                        Title:       "Infrastructure Setup",
                        Description: "Configure enterprise infrastructure components",
                        StepType:    "input",
                        Fields: []FieldDefinition{
                                {
                                        FieldID:  "deployment_type",
                                        Label:    "Deployment Type",
                                        Type:     "select",
                                        Required: true,
                                        Options: []FieldOption{
                                                {Value: "kubernetes", Label: "Kubernetes Cluster"},
                                                {Value: "docker_swarm", Label: "Docker Swarm"},
                                                {Value: "standalone", Label: "Standalone Servers"},
                                        },
                                },
                                {
                                        FieldID:  "load_balancer",
                                        Label:    "Load Balancer Configuration",
                                        Type:     "select",
                                        Required: true,
                                        Options: []FieldOption{
                                                {Value: "nginx", Label: "Nginx"},
                                                {Value: "haproxy", Label: "HAProxy"},
                                                {Value: "aws_alb", Label: "AWS Application Load Balancer"},
                                        },
                                },
                        },
                },
                // Add more enterprise-specific steps...
        }
        return steps
}</span>

func (s *ConfigurationWizardService) getDevelopmentSteps() []WizardStep <span class="cov0" title="0">{
        // Return development-specific configuration steps
        steps := []WizardStep{
                {
                        StepID:      "dev_environment",
                        Title:       "Development Environment",
                        Description: "Configure development tools and settings",
                        StepType:    "input",
                        Fields: []FieldDefinition{
                                {
                                        FieldID:      "debug_mode",
                                        Label:        "Enable Debug Mode",
                                        Type:         "boolean",
                                        DefaultValue: true,
                                },
                                {
                                        FieldID:      "hot_reload",
                                        Label:        "Enable Hot Reload",
                                        Type:         "boolean",
                                        DefaultValue: true,
                                },
                        },
                },
                // Add more development-specific steps...
        }
        return steps
}</span>

func (s *ConfigurationWizardService) initializeValidationRules() <span class="cov0" title="0">{
        s.validationRules["required"] = ValidationRule{
                RuleID:       "required",
                Type:         "required",
                ErrorMessage: "This field is required",
        }

        s.validationRules["email"] = ValidationRule{
                RuleID:       "email",
                Type:         "format",
                ErrorMessage: "Please enter a valid email address",
                Parameters: map[string]interface{}{
                        "pattern": `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`,
                },
        }

        s.validationRules["username"] = ValidationRule{
                RuleID:       "username",
                Type:         "format",
                ErrorMessage: "Username can only contain letters, numbers, and underscores (3-30 characters)",
                Parameters: map[string]interface{}{
                        "pattern": `^[a-zA-Z0-9_]{3,30}$`,
                },
        }

        s.validationRules["password_strength"] = ValidationRule{
                RuleID:       "password_strength",
                Type:         "custom",
                ErrorMessage: "Password must be at least 8 characters with uppercase, lowercase, number, and special character",
                Parameters: map[string]interface{}{
                        "min_length":      8,
                        "require_upper":   true,
                        "require_lower":   true,
                        "require_number":  true,
                        "require_special": true,
                },
        }

        s.validationRules["password_match"] = ValidationRule{
                RuleID:       "password_match",
                Type:         "custom",
                ErrorMessage: "Passwords do not match",
                Parameters: map[string]interface{}{
                        "match_field": "admin_password",
                },
        }

        s.validationRules["min_length"] = ValidationRule{
                RuleID:       "min_length",
                Type:         "format",
                ErrorMessage: "Must be at least {min} characters long",
        }
}</span>

func (s *ConfigurationWizardService) StartWizard(userID int, configType string, quickInstall bool) (*models.WizardSession, error) <span class="cov0" title="0">{
        template, exists := s.configTemplates[configType]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration template '%s' not found", configType)
        }</span>

        <span class="cov0" title="0">sessionID := fmt.Sprintf("wizard-%d-%d", userID, time.Now().Unix())

        session := &amp;models.WizardSession{
                SessionID:     sessionID,
                UserID:        userID,
                CurrentStep:   0,
                TotalSteps:    len(template.Steps),
                StepData:      make(map[string]interface{}),
                Configuration: make(map[string]interface{}),
                StartedAt:     time.Now(),
                LastActivity:  time.Now(),
                IsCompleted:   false,
                ConfigType:    configType,
        }

        // Apply default values
        for key, value := range template.DefaultValues </span><span class="cov0" title="0">{
                session.Configuration[key] = value
        }</span>

        // Quick install logic
        <span class="cov0" title="0">if quickInstall </span><span class="cov0" title="0">{
                session.Configuration["quick_install"] = true
                // Skip optional steps and use defaults
        }</span>

        <span class="cov0" title="0">s.currentSession = session

        // Save session to database
        if err := s.repo.SaveWizardSession(session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save wizard session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *ConfigurationWizardService) GetCurrentStep(sessionID string) (*WizardStep, error) <span class="cov0" title="0">{
        session, err := s.getSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">template := s.configTemplates[session.ConfigType]
        if session.CurrentStep &gt;= len(template.Steps) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wizard completed")
        }</span>

        <span class="cov0" title="0">step := template.Steps[session.CurrentStep]

        // Check if step should be skipped
        if s.shouldSkipStep(step, session.Configuration) </span><span class="cov0" title="0">{
                // Move to next step
                session.CurrentStep++
                s.repo.SaveWizardSession(session)
                return s.GetCurrentStep(sessionID)
        }</span>

        <span class="cov0" title="0">return &amp;step, nil</span>
}

func (s *ConfigurationWizardService) shouldSkipStep(step WizardStep, config map[string]interface{}) bool <span class="cov0" title="0">{
        if step.SkipCondition == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for key, expectedValue := range step.SkipCondition </span><span class="cov0" title="0">{
                if configValue, exists := config[key]; exists </span><span class="cov0" title="0">{
                        if configValue != expectedValue </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

func (s *ConfigurationWizardService) SubmitStepData(sessionID string, stepData map[string]interface{}) error <span class="cov0" title="0">{
        session, err := s.getSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">template := s.configTemplates[session.ConfigType]
        if session.CurrentStep &gt;= len(template.Steps) </span><span class="cov0" title="0">{
                return fmt.Errorf("wizard already completed")
        }</span>

        <span class="cov0" title="0">currentStep := template.Steps[session.CurrentStep]

        // Validate step data
        if err := s.validateStepData(currentStep, stepData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        // Process step based on type
        <span class="cov0" title="0">switch currentStep.StepType </span>{
        case "test":<span class="cov0" title="0">
                if err := s.processTestStep(currentStep, stepData, session); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("test step failed: %w", err)
                }</span>
        case "input", "select", "multi-select":<span class="cov0" title="0">
                // Store the input data
                for key, value := range stepData </span><span class="cov0" title="0">{
                        session.Configuration[key] = value
                }</span>
        }

        // Store step data
        <span class="cov0" title="0">session.StepData[currentStep.StepID] = stepData
        session.LastActivity = time.Now()

        // Move to next step
        session.CurrentStep++

        // Check if wizard is completed
        if session.CurrentStep &gt;= len(template.Steps) </span><span class="cov0" title="0">{
                session.IsCompleted = true
                if err := s.finalizeConfiguration(session); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to finalize configuration: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return s.repo.SaveWizardSession(session)</span>
}

func (s *ConfigurationWizardService) validateStepData(step WizardStep, data map[string]interface{}) error <span class="cov0" title="0">{
        for _, field := range step.Fields </span><span class="cov0" title="0">{
                value, exists := data[field.FieldID]

                // Check required fields
                if field.Required &amp;&amp; (!exists || value == nil || value == "") </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field.FieldID)
                }</span>

                <span class="cov0" title="0">if !exists || value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Type validation
                <span class="cov0" title="0">if err := s.validateFieldType(field, value); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s': %w", field.FieldID, err)
                }</span>

                // Custom validation
                <span class="cov0" title="0">if field.Validation != "" </span><span class="cov0" title="0">{
                        if err := s.validateFieldRule(field.Validation, value, data); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("field '%s': %w", field.FieldID, err)
                        }</span>
                }

                // Range validation for numbers
                <span class="cov0" title="0">if field.Type == "number" </span><span class="cov0" title="0">{
                        if numValue, ok := value.(float64); ok </span><span class="cov0" title="0">{
                                if field.MinValue != nil &amp;&amp; numValue &lt; *field.MinValue </span><span class="cov0" title="0">{
                                        return fmt.Errorf("field '%s': value must be at least %v", field.FieldID, *field.MinValue)
                                }</span>
                                <span class="cov0" title="0">if field.MaxValue != nil &amp;&amp; numValue &gt; *field.MaxValue </span><span class="cov0" title="0">{
                                        return fmt.Errorf("field '%s': value must be at most %v", field.FieldID, *field.MaxValue)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) validateFieldType(field FieldDefinition, value interface{}) error <span class="cov0" title="0">{
        switch field.Type </span>{
        case "text", "password":<span class="cov0" title="0">
                if _, ok := value.(string); !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected string value")
                }</span>
        case "number":<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case float64, int, int64:<span class="cov0" title="0"></span>
                        // Valid number types
                case string:<span class="cov0" title="0">
                        if _, err := strconv.ParseFloat(v, 64); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid number format")
                        }</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("expected number value")</span>
                }
        case "boolean":<span class="cov0" title="0">
                if _, ok := value.(bool); !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected boolean value")
                }</span>
        case "file", "directory":<span class="cov0" title="0">
                if strValue, ok := value.(string); ok </span><span class="cov0" title="0">{
                        if field.Type == "directory" </span><span class="cov0" title="0">{
                                if _, err := os.Stat(strValue); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("directory does not exist: %s", strValue)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("expected string path")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) validateFieldRule(ruleName string, value interface{}, allData map[string]interface{}) error <span class="cov0" title="0">{
        rule, exists := s.validationRules[ruleName]
        if !exists </span><span class="cov0" title="0">{
                // Handle inline rules like "min_length:32"
                if strings.Contains(ruleName, ":") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(ruleName, ":", 2)
                        ruleType, param := parts[0], parts[1]

                        switch ruleType </span>{
                        case "min_length":<span class="cov0" title="0">
                                if strValue, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        if minLen, err := strconv.Atoi(param); err == nil </span><span class="cov0" title="0">{
                                                if len(strValue) &lt; minLen </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("must be at least %d characters long", minLen)
                                                }</span>
                                        }
                                }
                        }
                }
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">switch rule.Type </span>{
        case "format":<span class="cov0" title="0">
                if pattern, ok := rule.Parameters["pattern"].(string); ok </span><span class="cov0" title="0">{
                        if strValue, ok := value.(string); ok </span><span class="cov0" title="0">{
                                matched, err := filepath.Match(pattern, strValue)
                                if err != nil || !matched </span><span class="cov0" title="0">{
                                        return errors.New(rule.ErrorMessage)
                                }</span>
                        }
                }
        case "custom":<span class="cov0" title="0">
                return s.validateCustomRule(rule, value, allData)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) validateCustomRule(rule ValidationRule, value interface{}, allData map[string]interface{}) error <span class="cov0" title="0">{
        switch rule.RuleID </span>{
        case "password_strength":<span class="cov0" title="0">
                if strValue, ok := value.(string); ok </span><span class="cov0" title="0">{
                        if len(strValue) &lt; 8 </span><span class="cov0" title="0">{
                                return fmt.Errorf("password must be at least 8 characters")
                        }</span>
                        // Add more password strength checks
                }
        case "password_match":<span class="cov0" title="0">
                if matchField, ok := rule.Parameters["match_field"].(string); ok </span><span class="cov0" title="0">{
                        if otherValue, exists := allData[matchField]; exists </span><span class="cov0" title="0">{
                                if value != otherValue </span><span class="cov0" title="0">{
                                        return fmt.Errorf("passwords do not match")
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) processTestStep(step WizardStep, data map[string]interface{}, session *models.WizardSession) error <span class="cov0" title="0">{
        switch step.StepID </span>{
        case "system_check":<span class="cov0" title="0">
                return s.performSystemCheck(data, session)</span>
        case "final_test":<span class="cov0" title="0">
                return s.performFinalTest(data, session)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown test step: %s", step.StepID)</span>
        }
}

func (s *ConfigurationWizardService) performSystemCheck(data map[string]interface{}, session *models.WizardSession) error <span class="cov0" title="0">{
        systemInfo := s.collectSystemInfo()

        // Check minimum requirements
        var issues []string

        // Check Go version
        if !strings.HasPrefix(systemInfo.GoVersion, "go1.") </span><span class="cov0" title="0">{
                issues = append(issues, "Go is not installed or not in PATH")
        }</span>

        // Check available memory (minimum 1GB)
        <span class="cov0" title="0">if systemInfo.MemoryGB &lt; 1.0 </span><span class="cov0" title="0">{
                issues = append(issues, "Insufficient memory (minimum 1GB required)")
        }</span>

        // Check available disk space (minimum 5GB)
        <span class="cov0" title="0">if systemInfo.DiskSpaceGB &lt; 5.0 </span><span class="cov0" title="0">{
                issues = append(issues, "Insufficient disk space (minimum 5GB required)")
        }</span>

        // Store system info in session
        <span class="cov0" title="0">session.Configuration["system_info"] = systemInfo

        if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                autoFix, _ := data["auto_fix"].(bool)
                if autoFix </span><span class="cov0" title="0">{
                        log.Printf("Auto-fixing system issues: %v", issues)
                        // Attempt to fix issues automatically
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("system check failed: %v", issues)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) performFinalTest(data map[string]interface{}, session *models.WizardSession) error <span class="cov0" title="0">{
        // Test database connection
        if err := s.testDatabaseConnection(session.Configuration); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database connection test failed: %w", err)
        }</span>

        // Test media storage
        <span class="cov0" title="0">if err := s.testMediaStorage(session.Configuration); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("media storage test failed: %w", err)
        }</span>

        // Test service configuration
        <span class="cov0" title="0">if err := s.testServiceConfiguration(session.Configuration); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("service configuration test failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) testDatabaseConnection(config map[string]interface{}) error <span class="cov0" title="0">{
        dbType, _ := config["db_type"].(string)

        switch dbType </span>{
        case "sqlite":<span class="cov0" title="0">
                dbPath, _ := config["db_path"].(string)
                if dbPath == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("database path not specified")
                }</span>
                // Test SQLite connection
                <span class="cov0" title="0">return s.testSQLiteConnection(dbPath)</span>
        case "mysql", "postgresql":<span class="cov0" title="0">
                // Test network database connection
                return s.testNetworkDatabaseConnection(config)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported database type: %s", dbType)</span>
        }
}

func (s *ConfigurationWizardService) testSQLiteConnection(dbPath string) error <span class="cov0" title="0">{
        // Ensure directory exists
        dir := filepath.Dir(dbPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create database directory: %w", err)
        }</span>

        // Test write access
        <span class="cov0" title="0">testFile := filepath.Join(dir, "test.tmp")
        if err := ioutil.WriteFile(testFile, []byte("test"), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no write access to database directory: %w", err)
        }</span>
        <span class="cov0" title="0">os.Remove(testFile)

        return nil</span>
}

func (s *ConfigurationWizardService) testNetworkDatabaseConnection(config map[string]interface{}) error <span class="cov0" title="0">{
        // This would contain actual database connection testing logic
        // For now, just validate required fields are present
        requiredFields := []string{"db_host", "db_port", "db_name", "db_username", "db_password"}
        for _, field := range requiredFields </span><span class="cov0" title="0">{
                if _, exists := config[field]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required database field: %s", field)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) testMediaStorage(config map[string]interface{}) error <span class="cov0" title="0">{
        storageType, _ := config["storage_type"].(string)

        switch storageType </span>{
        case "local":<span class="cov0" title="0">
                mediaPath, _ := config["media_path"].(string)
                if mediaPath == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("media path not specified")
                }</span>

                // Ensure directory exists
                <span class="cov0" title="0">if err := os.MkdirAll(mediaPath, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create media directory: %w", err)
                }</span>

                // Test write access
                <span class="cov0" title="0">testFile := filepath.Join(mediaPath, "test.tmp")
                if err := ioutil.WriteFile(testFile, []byte("test"), 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no write access to media directory: %w", err)
                }</span>
                <span class="cov0" title="0">os.Remove(testFile)</span>

        default:<span class="cov0" title="0">
                // For other storage types, would implement specific tests
                log.Printf("Storage type %s test not implemented", storageType)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) testServiceConfiguration(config map[string]interface{}) error <span class="cov0" title="0">{
        // Test port availability
        if port, ok := config["server_port"].(float64); ok </span><span class="cov0" title="0">{
                // Would test if port is available
                if port &lt; 1024 || port &gt; 65535 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid port number: %v", port)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) finalizeConfiguration(session *models.WizardSession) error <span class="cov0" title="0">{
        // Generate final configuration file
        configData := map[string]interface{}{
                "version":       "3.0.0",
                "generated_at":  time.Now(),
                "generated_by":  "configuration_wizard",
                "user_id":       session.UserID,
                "configuration": session.Configuration,
        }

        // Write configuration file
        configFile := filepath.Join(s.configPath, "config.json")
        if err := s.writeConfigFile(configFile, configData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write configuration file: %w", err)
        }</span>

        // Execute post-install actions
        <span class="cov0" title="0">template := s.configTemplates[session.ConfigType]
        for _, action := range template.PostInstall </span><span class="cov0" title="0">{
                if err := s.executePostInstallAction(action, session); err != nil </span><span class="cov0" title="0">{
                        if action.Required </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to execute required post-install action: %w", err)
                        }</span>
                        <span class="cov0" title="0">log.Printf("Optional post-install action failed: %v", err)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) writeConfigFile(filename string, data map[string]interface{}) error <span class="cov0" title="0">{
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ioutil.WriteFile(filename, jsonData, 0644)</span>
}

func (s *ConfigurationWizardService) executePostInstallAction(action PostInstallAction, session *models.WizardSession) error <span class="cov0" title="0">{
        switch action.ActionType </span>{
        case "file_create":<span class="cov0" title="0">
                return s.createConfigurationFile(action.Parameters, session)</span>
        case "service_restart":<span class="cov0" title="0">
                return s.restartService(action.Parameters)</span>
        case "command_run":<span class="cov0" title="0">
                return s.runCommand(action.Parameters)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown post-install action: %s", action.ActionType)</span>
        }
}

func (s *ConfigurationWizardService) createConfigurationFile(params map[string]interface{}, session *models.WizardSession) error <span class="cov0" title="0">{
        filePath, _ := params["file_path"].(string)
        template, _ := params["template"].(string)

        if filePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("file_path parameter required")
        }</span>

        // Create directory if needed
        <span class="cov0" title="0">dir := filepath.Dir(filePath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Use template if specified, otherwise use session configuration
        <span class="cov0" title="0">var data interface{}
        if template != "" </span><span class="cov0" title="0">{
                // Load template and merge with configuration
                data = session.Configuration
        }</span> else<span class="cov0" title="0"> {
                data = session.Configuration
        }</span>

        <span class="cov0" title="0">return s.writeConfigFile(filePath, map[string]interface{}{"config": data})</span>
}

func (s *ConfigurationWizardService) restartService(params map[string]interface{}) error <span class="cov0" title="0">{
        serviceName, _ := params["service_name"].(string)
        if serviceName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("service_name parameter required")
        }</span>

        // This would contain actual service restart logic
        <span class="cov0" title="0">log.Printf("Would restart service: %s", serviceName)
        return nil</span>
}

func (s *ConfigurationWizardService) runCommand(params map[string]interface{}) error <span class="cov0" title="0">{
        command, _ := params["command"].(string)
        if command == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("command parameter required")
        }</span>

        // This would contain actual command execution logic
        <span class="cov0" title="0">log.Printf("Would run command: %s", command)
        return nil</span>
}

func (s *ConfigurationWizardService) collectSystemInfo() SystemInfo <span class="cov0" title="0">{
        info := SystemInfo{
                OS:           runtime.GOOS,
                Architecture: runtime.GOARCH,
                GoVersion:    runtime.Version(),
                CPUCores:     runtime.NumCPU(),
        }

        // Get memory info
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        info.MemoryGB = float64(m.Sys) / (1024 * 1024 * 1024)

        // Get hostname
        if hostname, err := os.Hostname(); err == nil </span><span class="cov0" title="0">{
                info.NetworkInfo.Hostname = hostname
        }</span>

        // Detect installed tools
        <span class="cov0" title="0">info.InstalledTools = s.detectInstalledTools()

        // Get environment variables
        info.EnvironmentVars = make(map[string]string)
        for _, env := range os.Environ() </span><span class="cov0" title="0">{
                parts := strings.SplitN(env, "=", 2)
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        // Only include non-sensitive environment variables
                        key := parts[0]
                        if !strings.Contains(strings.ToLower(key), "password") &amp;&amp;
                                !strings.Contains(strings.ToLower(key), "secret") &amp;&amp;
                                !strings.Contains(strings.ToLower(key), "token") </span><span class="cov0" title="0">{
                                info.EnvironmentVars[key] = parts[1]
                        }</span>
                }
        }

        // Generate recommendations
        <span class="cov0" title="0">info.Recommendations = s.generateSystemRecommendations(info)

        return info</span>
}

func (s *ConfigurationWizardService) detectInstalledTools() []string <span class="cov0" title="0">{
        var tools []string

        toolsToCheck := []string{"go", "git", "docker", "make", "npm", "node", "python", "sqlite3"}

        for _, tool := range toolsToCheck </span><span class="cov0" title="0">{
                // This would check if tool is installed
                // For now, just assume go is installed since we're running
                if tool == "go" </span><span class="cov0" title="0">{
                        tools = append(tools, tool)
                }</span>
        }

        <span class="cov0" title="0">return tools</span>
}

func (s *ConfigurationWizardService) generateSystemRecommendations(info SystemInfo) []string <span class="cov0" title="0">{
        var recommendations []string

        if info.MemoryGB &lt; 2.0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Consider upgrading system memory to at least 2GB for better performance")
        }</span>

        <span class="cov0" title="0">if info.CPUCores &lt; 2 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Consider using a multi-core processor for better concurrency")
        }</span>

        <span class="cov0" title="0">if info.OS == "windows" </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Consider using WSL2 for better compatibility with Unix-based tools")
        }</span>

        <span class="cov0" title="0">if len(info.InstalledTools) &lt; 3 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Install additional development tools like Git and Docker for full functionality")
        }</span>

        <span class="cov0" title="0">return recommendations</span>
}

func (s *ConfigurationWizardService) getSession(sessionID string) (*models.WizardSession, error) <span class="cov0" title="0">{
        if s.currentSession != nil &amp;&amp; s.currentSession.SessionID == sessionID </span><span class="cov0" title="0">{
                return s.currentSession, nil
        }</span>

        // Load from database
        <span class="cov0" title="0">session, err := s.repo.GetWizardSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session not found: %w", err)
        }</span>

        <span class="cov0" title="0">s.currentSession = session
        return session, nil</span>
}

func (s *ConfigurationWizardService) GetAvailableTemplates() []ConfigTemplate <span class="cov0" title="0">{
        var templates []ConfigTemplate
        for _, template := range s.configTemplates </span><span class="cov0" title="0">{
                templates = append(templates, template)
        }</span>
        <span class="cov0" title="0">return templates</span>
}

func (s *ConfigurationWizardService) GetWizardProgress(sessionID string) (*InstallationProgress, error) <span class="cov0" title="0">{
        session, err := s.getSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">progress := float64(session.CurrentStep) / float64(session.TotalSteps) * 100

        return &amp;InstallationProgress{
                SessionID:      sessionID,
                CurrentAction:  fmt.Sprintf("Step %d of %d", session.CurrentStep+1, session.TotalSteps),
                Progress:       progress,
                CompletedSteps: s.getCompletedSteps(session),
                LastUpdate:     session.LastActivity,
                IsCompleted:    session.IsCompleted,
        }, nil</span>
}

func (s *ConfigurationWizardService) getCompletedSteps(session *models.WizardSession) []string <span class="cov0" title="0">{
        var completed []string
        template := s.configTemplates[session.ConfigType]

        for i := 0; i &lt; session.CurrentStep &amp;&amp; i &lt; len(template.Steps); i++ </span><span class="cov0" title="0">{
                completed = append(completed, template.Steps[i].Title)
        }</span>

        <span class="cov0" title="0">return completed</span>
}

func (s *ConfigurationWizardService) SaveConfigurationProfile(userID int, profile *models.ConfigurationProfile) error <span class="cov0" title="0">{
        profile.UserID = userID
        profile.CreatedAt = time.Now()
        profile.UpdatedAt = time.Now()

        return s.repo.SaveConfigurationProfile(profile)
}</span>

func (s *ConfigurationWizardService) LoadConfigurationProfile(userID int, profileID string) (*models.ConfigurationProfile, error) <span class="cov0" title="0">{
        return s.repo.GetConfigurationProfile(profileID)
}</span>

func (s *ConfigurationWizardService) GetUserConfigurationProfiles(userID int) ([]*models.ConfigurationProfile, error) <span class="cov0" title="0">{
        return s.repo.GetUserConfigurationProfiles(userID)
}</span>

func float64Ptr(f float64) *float64 <span class="cov0" title="0">{
        return &amp;f
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package services

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "strings"
        "time"

        "catalogizer/internal/auth"
        "catalogizer/models"
        "catalogizer/repository"
)

type ConversionService struct {
        conversionRepo *repository.ConversionRepository
        userRepo       *repository.UserRepository
        authService    *AuthService
}

func NewConversionService(conversionRepo *repository.ConversionRepository, userRepo *repository.UserRepository, authService *AuthService) *ConversionService <span class="cov0" title="0">{
        return &amp;ConversionService{
                conversionRepo: conversionRepo,
                userRepo:       userRepo,
                authService:    authService,
        }
}</span>

func (s *ConversionService) CreateConversionJob(userID int, request *models.ConversionRequest) (*models.ConversionJob, error) <span class="cov0" title="0">{
        if !s.validateConversionRequest(request) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid conversion request")
        }</span>

        <span class="cov0" title="0">job := &amp;models.ConversionJob{
                UserID:         userID,
                SourcePath:     request.SourcePath,
                TargetPath:     request.TargetPath,
                SourceFormat:   request.SourceFormat,
                TargetFormat:   request.TargetFormat,
                ConversionType: request.ConversionType,
                Quality:        request.Quality,
                Settings:       request.Settings,
                Priority:       request.Priority,
                Status:         models.ConversionStatusPending,
                CreatedAt:      time.Now(),
                ScheduledFor:   request.ScheduledFor,
        }

        id, err := s.conversionRepo.CreateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create conversion job: %w", err)
        }</span>

        <span class="cov0" title="0">job.ID = id
        return job, nil</span>
}

func (s *ConversionService) StartConversion(jobID int) error <span class="cov0" title="0">{
        job, err := s.conversionRepo.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get conversion job: %w", err)
        }</span>

        <span class="cov0" title="0">if job.Status != models.ConversionStatusPending </span><span class="cov0" title="0">{
                return fmt.Errorf("job is not in pending status")
        }</span>

        <span class="cov0" title="0">job.Status = models.ConversionStatusRunning
        job.StartedAt = &amp;time.Time{}
        *job.StartedAt = time.Now()

        err = s.conversionRepo.UpdateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update job status: %w", err)
        }</span>

        <span class="cov0" title="0">go s.processConversion(job)

        return nil</span>
}

func (s *ConversionService) processConversion(job *models.ConversionJob) <span class="cov0" title="0">{
        var err error

        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.handleConversionError(job, fmt.Errorf("conversion panic: %v", r))
                }</span>
        }()

        <span class="cov0" title="0">switch job.ConversionType </span>{
        case models.ConversionTypeVideo:<span class="cov0" title="0">
                err = s.convertVideo(job)</span>
        case models.ConversionTypeAudio:<span class="cov0" title="0">
                err = s.convertAudio(job)</span>
        case models.ConversionTypeDocument:<span class="cov0" title="0">
                err = s.convertDocument(job)</span>
        case models.ConversionTypeImage:<span class="cov0" title="0">
                err = s.convertImage(job)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unsupported conversion type: %s", job.ConversionType)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.handleConversionError(job, err)
                return
        }</span>

        <span class="cov0" title="0">s.handleConversionSuccess(job)</span>
}

func (s *ConversionService) convertVideo(job *models.ConversionJob) error <span class="cov0" title="0">{
        args := s.buildFFmpegVideoArgs(job)

        cmd := exec.Command("ffmpeg", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ffmpeg video conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) convertAudio(job *models.ConversionJob) error <span class="cov0" title="0">{
        args := s.buildFFmpegAudioArgs(job)

        cmd := exec.Command("ffmpeg", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ffmpeg audio conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) convertDocument(job *models.ConversionJob) error <span class="cov0" title="0">{
        switch </span>{
        case s.isEbookConversion(job):<span class="cov0" title="0">
                return s.convertEbook(job)</span>
        case s.isPDFConversion(job):<span class="cov0" title="0">
                return s.convertPDF(job)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported document conversion")</span>
        }
}

func (s *ConversionService) convertEbook(job *models.ConversionJob) error <span class="cov0" title="0">{
        args := []string{
                job.SourcePath,
                job.TargetPath,
        }

        if job.Settings != nil </span><span class="cov0" title="0">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov0" title="0">{
                        if cover, ok := settings["preserve_cover"].(bool); ok &amp;&amp; cover </span><span class="cov0" title="0">{
                                args = append(args, "--preserve-cover")
                        }</span>
                        <span class="cov0" title="0">if metadata, ok := settings["preserve_metadata"].(bool); ok &amp;&amp; metadata </span><span class="cov0" title="0">{
                                args = append(args, "--preserve-metadata")
                        }</span>
                }
        }

        <span class="cov0" title="0">cmd := exec.Command("ebook-convert", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ebook conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) convertPDF(job *models.ConversionJob) error <span class="cov0" title="0">{
        // Placeholder for PDF conversion using tools like pandoc or libreoffice
        return fmt.Errorf("PDF conversion not yet implemented")
}</span>

func (s *ConversionService) convertImage(job *models.ConversionJob) error <span class="cov0" title="0">{
        args := s.buildImageMagickArgs(job)

        cmd := exec.Command("convert", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("imagemagick conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) buildFFmpegVideoArgs(job *models.ConversionJob) []string <span class="cov0" title="0">{
        args := []string{
                "-i", job.SourcePath,
                "-y", // Overwrite output file
        }

        switch job.Quality </span>{
        case "low":<span class="cov0" title="0">
                args = append(args, "-crf", "28", "-preset", "fast")</span>
        case "medium":<span class="cov0" title="0">
                args = append(args, "-crf", "23", "-preset", "medium")</span>
        case "high":<span class="cov0" title="0">
                args = append(args, "-crf", "18", "-preset", "slow")</span>
        case "lossless":<span class="cov0" title="0">
                args = append(args, "-crf", "0", "-preset", "veryslow")</span>
        default:<span class="cov0" title="0">
                args = append(args, "-crf", "23", "-preset", "medium")</span>
        }

        <span class="cov0" title="0">if job.Settings != nil </span><span class="cov0" title="0">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov0" title="0">{
                        if resolution, ok := settings["resolution"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-s", resolution)
                        }</span>
                        <span class="cov0" title="0">if framerate, ok := settings["framerate"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-r", framerate)
                        }</span>
                        <span class="cov0" title="0">if bitrate, ok := settings["bitrate"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-b:v", bitrate)
                        }</span>
                }
        }

        <span class="cov0" title="0">args = append(args, job.TargetPath)
        return args</span>
}

func (s *ConversionService) buildFFmpegAudioArgs(job *models.ConversionJob) []string <span class="cov0" title="0">{
        args := []string{
                "-i", job.SourcePath,
                "-y", // Overwrite output file
        }

        switch job.Quality </span>{
        case "low":<span class="cov0" title="0">
                args = append(args, "-ab", "96k")</span>
        case "medium":<span class="cov0" title="0">
                args = append(args, "-ab", "192k")</span>
        case "high":<span class="cov0" title="0">
                args = append(args, "-ab", "320k")</span>
        case "lossless":<span class="cov0" title="0">
                args = append(args, "-c:a", "flac")</span>
        default:<span class="cov0" title="0">
                args = append(args, "-ab", "192k")</span>
        }

        <span class="cov0" title="0">if job.Settings != nil </span><span class="cov0" title="0">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov0" title="0">{
                        if sampleRate, ok := settings["sample_rate"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-ar", sampleRate)
                        }</span>
                        <span class="cov0" title="0">if channels, ok := settings["channels"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-ac", channels)
                        }</span>
                }
        }

        <span class="cov0" title="0">args = append(args, job.TargetPath)
        return args</span>
}

func (s *ConversionService) buildImageMagickArgs(job *models.ConversionJob) []string <span class="cov0" title="0">{
        args := []string{job.SourcePath}

        if job.Settings != nil </span><span class="cov0" title="0">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov0" title="0">{
                        if resize, ok := settings["resize"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-resize", resize)
                        }</span>
                        <span class="cov0" title="0">if quality, ok := settings["quality"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-quality", quality)
                        }</span>
                        <span class="cov0" title="0">if compress, ok := settings["compress"].(bool); ok &amp;&amp; compress </span><span class="cov0" title="0">{
                                args = append(args, "-compress", "JPEG")
                        }</span>
                }
        }

        <span class="cov0" title="0">args = append(args, job.TargetPath)
        return args</span>
}

func (s *ConversionService) handleConversionSuccess(job *models.ConversionJob) <span class="cov0" title="0">{
        job.Status = models.ConversionStatusCompleted
        job.CompletedAt = &amp;time.Time{}
        *job.CompletedAt = time.Now()

        if job.StartedAt != nil </span><span class="cov0" title="0">{
                duration := job.CompletedAt.Sub(*job.StartedAt)
                job.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">err := s.conversionRepo.UpdateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update completed job %d: %v\n", job.ID, err)
        }</span>

        <span class="cov0" title="0">s.notifyUser(job, "Conversion completed successfully")</span>
}

func (s *ConversionService) handleConversionError(job *models.ConversionJob, conversionError error) <span class="cov0" title="0">{
        job.Status = models.ConversionStatusFailed
        job.CompletedAt = &amp;time.Time{}
        *job.CompletedAt = time.Now()
        errorMsg := conversionError.Error()
        job.ErrorMessage = &amp;errorMsg

        if job.StartedAt != nil </span><span class="cov0" title="0">{
                duration := job.CompletedAt.Sub(*job.StartedAt)
                job.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">err := s.conversionRepo.UpdateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update failed job %d: %v\n", job.ID, err)
        }</span>

        <span class="cov0" title="0">s.notifyUser(job, fmt.Sprintf("Conversion failed: %s", conversionError.Error()))</span>
}

func (s *ConversionService) notifyUser(job *models.ConversionJob, message string) <span class="cov0" title="0">{
        // In a full implementation, this would send notifications via email, push, etc.
        fmt.Printf("Notification for user %d: %s (Job %d)\n", job.UserID, message, job.ID)
}</span>

func (s *ConversionService) GetUserJobs(userID int, status *string, limit, offset int) ([]models.ConversionJob, error) <span class="cov0" title="0">{
        return s.conversionRepo.GetUserJobs(userID, status, limit, offset)
}</span>

func (s *ConversionService) GetJob(jobID int, userID int) (*models.ConversionJob, error) <span class="cov0" title="0">{
        job, err := s.conversionRepo.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if job.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, auth.PermissionViewMedia)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to view this job")
                }</span>
        }

        <span class="cov0" title="0">return job, nil</span>
}

func (s *ConversionService) CancelJob(jobID int, userID int) error <span class="cov0" title="0">{
        job, err := s.conversionRepo.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if job.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, auth.PermissionManageUsers)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return fmt.Errorf("unauthorized to cancel this job")
                }</span>
        }

        <span class="cov0" title="0">if job.Status != models.ConversionStatusPending &amp;&amp; job.Status != models.ConversionStatusRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot cancel job in status: %s", job.Status)
        }</span>

        <span class="cov0" title="0">job.Status = models.ConversionStatusCancelled
        job.CompletedAt = &amp;time.Time{}
        *job.CompletedAt = time.Now()

        return s.conversionRepo.UpdateJob(job)</span>
}

func (s *ConversionService) RetryJob(jobID int, userID int) error <span class="cov0" title="0">{
        job, err := s.conversionRepo.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if job.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, auth.PermissionManageUsers)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return fmt.Errorf("unauthorized to retry this job")
                }</span>
        }

        <span class="cov0" title="0">if job.Status != models.ConversionStatusFailed </span><span class="cov0" title="0">{
                return fmt.Errorf("can only retry failed jobs")
        }</span>

        <span class="cov0" title="0">job.Status = models.ConversionStatusPending
        job.StartedAt = nil
        job.CompletedAt = nil
        job.Duration = nil
        job.ErrorMessage = nil

        err = s.conversionRepo.UpdateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.StartConversion(jobID)</span>
}

func (s *ConversionService) GetJobStatistics(userID *int, startDate, endDate time.Time) (*models.ConversionStatistics, error) <span class="cov0" title="0">{
        return s.conversionRepo.GetStatistics(userID, startDate, endDate)
}</span>

func (s *ConversionService) CleanupCompletedJobs(olderThan time.Time) error <span class="cov0" title="0">{
        return s.conversionRepo.CleanupJobs(olderThan)
}</span>

func (s *ConversionService) GetSupportedFormats() *models.SupportedFormats <span class="cov0" title="0">{
        return &amp;models.SupportedFormats{
                Video: models.VideoFormats{
                        Input:  []string{"mp4", "avi", "mkv", "mov", "wmv", "flv", "webm", "m4v", "3gp"},
                        Output: []string{"mp4", "avi", "mkv", "mov", "webm", "m4v"},
                },
                Audio: models.AudioFormats{
                        Input:  []string{"mp3", "wav", "flac", "aac", "ogg", "wma", "m4a", "opus"},
                        Output: []string{"mp3", "wav", "flac", "aac", "ogg", "m4a", "opus"},
                },
                Document: models.DocumentFormats{
                        Input:  []string{"epub", "mobi", "azw", "azw3", "pdf", "txt", "docx", "odt"},
                        Output: []string{"epub", "mobi", "pdf", "txt", "html"},
                },
                Image: models.ImageFormats{
                        Input:  []string{"jpg", "jpeg", "png", "gif", "bmp", "tiff", "webp", "svg"},
                        Output: []string{"jpg", "jpeg", "png", "gif", "bmp", "tiff", "webp"},
                },
        }
}</span>

func (s *ConversionService) validateConversionRequest(request *models.ConversionRequest) bool <span class="cov0" title="0">{
        if request.SourcePath == "" || request.TargetPath == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if request.SourceFormat == "" || request.TargetFormat == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if request.ConversionType == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if !s.isValidConversionType(request.ConversionType) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if !s.isSupportedFormat(request.ConversionType, request.SourceFormat, request.TargetFormat) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func (s *ConversionService) isValidConversionType(conversionType string) bool <span class="cov0" title="0">{
        validTypes := []string{
                models.ConversionTypeVideo,
                models.ConversionTypeAudio,
                models.ConversionTypeDocument,
                models.ConversionTypeImage,
        }

        for _, validType := range validTypes </span><span class="cov0" title="0">{
                if conversionType == validType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (s *ConversionService) isSupportedFormat(conversionType, sourceFormat, targetFormat string) bool <span class="cov0" title="0">{
        formats := s.GetSupportedFormats()

        switch conversionType </span>{
        case models.ConversionTypeVideo:<span class="cov0" title="0">
                return s.isFormatSupported(sourceFormat, formats.Video.Input) &amp;&amp; s.isFormatSupported(targetFormat, formats.Video.Output)</span>
        case models.ConversionTypeAudio:<span class="cov0" title="0">
                return s.isFormatSupported(sourceFormat, formats.Audio.Input) &amp;&amp; s.isFormatSupported(targetFormat, formats.Audio.Output)</span>
        case models.ConversionTypeDocument:<span class="cov0" title="0">
                return s.isFormatSupported(sourceFormat, formats.Document.Input) &amp;&amp; s.isFormatSupported(targetFormat, formats.Document.Output)</span>
        case models.ConversionTypeImage:<span class="cov0" title="0">
                return s.isFormatSupported(sourceFormat, formats.Image.Input) &amp;&amp; s.isFormatSupported(targetFormat, formats.Image.Output)</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (s *ConversionService) isFormatSupported(format string, supportedFormats []string) bool <span class="cov0" title="0">{
        format = strings.ToLower(format)
        for _, supported := range supportedFormats </span><span class="cov0" title="0">{
                if format == strings.ToLower(supported) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (s *ConversionService) isEbookConversion(job *models.ConversionJob) bool <span class="cov0" title="0">{
        ebookFormats := []string{"epub", "mobi", "azw", "azw3", "txt", "html"}
        return s.isFormatSupported(job.SourceFormat, ebookFormats) || s.isFormatSupported(job.TargetFormat, ebookFormats)
}</span>

func (s *ConversionService) isPDFConversion(job *models.ConversionJob) bool <span class="cov0" title="0">{
        return job.SourceFormat == "pdf" || job.TargetFormat == "pdf"
}</span>

func (s *ConversionService) GetJobQueue() ([]models.ConversionJob, error) <span class="cov0" title="0">{
        return s.conversionRepo.GetJobsByStatus(models.ConversionStatusPending, 100, 0)
}</span>

func (s *ConversionService) ProcessJobQueue() error <span class="cov0" title="0">{
        jobs, err := s.GetJobQueue()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, job := range jobs </span><span class="cov0" title="0">{
                if job.ScheduledFor != nil &amp;&amp; job.ScheduledFor.After(time.Now()) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">err := s.StartConversion(job.ID)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to start conversion job %d: %v\n", job.ID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package services

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "runtime"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type ErrorReportingService struct {
        errorRepo        *repository.ErrorReportingRepository
        crashRepo        *repository.CrashReportingRepository
        config           *ErrorReportingConfig
        httpClient       *http.Client
        enabled          bool
        crashlyticAPIKey string
}

type ErrorReportingConfig struct {
        CrashlyticsEnabled  bool   `json:"crashlytics_enabled"`
        CrashlyticsAPIKey   string `json:"crashlytics_api_key"`
        SlackWebhookURL     string `json:"slack_webhook_url"`
        EmailNotifications  bool   `json:"email_notifications"`
        SentryDSN           string `json:"sentry_dsn"`
        AutoReporting       bool   `json:"auto_reporting"`
        MaxErrorsPerHour    int    `json:"max_errors_per_hour"`
        RetentionDays       int    `json:"retention_days"`
        IncludeStackTrace   bool   `json:"include_stack_trace"`
        IncludeSystemInfo   bool   `json:"include_system_info"`
        FilterSensitiveData bool   `json:"filter_sensitive_data"`
}

func NewErrorReportingService(errorRepo *repository.ErrorReportingRepository, crashRepo *repository.CrashReportingRepository) *ErrorReportingService <span class="cov0" title="0">{
        config := &amp;ErrorReportingConfig{
                CrashlyticsEnabled:  false,
                EmailNotifications:  true,
                AutoReporting:       true,
                MaxErrorsPerHour:    100,
                RetentionDays:       30,
                IncludeStackTrace:   true,
                IncludeSystemInfo:   true,
                FilterSensitiveData: true,
        }

        return &amp;ErrorReportingService{
                errorRepo:  errorRepo,
                crashRepo:  crashRepo,
                config:     config,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                enabled:    true,
        }
}</span>

func (s *ErrorReportingService) ReportError(userID int, errorReport *models.ErrorReportRequest) (*models.ErrorReport, error) <span class="cov0" title="0">{
        if !s.enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reporting is disabled")
        }</span>

        // Check rate limiting
        <span class="cov0" title="0">if s.config.MaxErrorsPerHour &gt; 0 </span><span class="cov0" title="0">{
                count, err := s.errorRepo.GetErrorCountInLastHour(userID)
                if err == nil &amp;&amp; count &gt;= s.config.MaxErrorsPerHour </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error reporting rate limit exceeded")
                }</span>
        }

        // Create error report
        <span class="cov0" title="0">report := &amp;models.ErrorReport{
                UserID:     userID,
                Level:      errorReport.Level,
                Message:    errorReport.Message,
                ErrorCode:  errorReport.ErrorCode,
                Component:  errorReport.Component,
                StackTrace: errorReport.StackTrace,
                Context:    errorReport.Context,
                UserAgent:  errorReport.UserAgent,
                URL:        errorReport.URL,
                ReportedAt: time.Now(),
                Status:     models.ErrorStatusNew,
        }

        // Filter sensitive data
        if s.config.FilterSensitiveData </span><span class="cov0" title="0">{
                report = s.filterSensitiveData(report)
        }</span>

        // Add system information
        <span class="cov0" title="0">if s.config.IncludeSystemInfo </span><span class="cov0" title="0">{
                report.SystemInfo = s.collectSystemInfo()
        }</span>

        // Generate fingerprint for deduplication
        <span class="cov0" title="0">report.Fingerprint = s.generateFingerprint(report)

        // Save to database
        if err := s.errorRepo.CreateErrorReport(report); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save error report: %w", err)
        }</span>

        // Send notifications asynchronously
        <span class="cov0" title="0">if s.config.AutoReporting </span><span class="cov0" title="0">{
                go s.sendNotifications(report)
        }</span>

        // Send to external services
        <span class="cov0" title="0">go s.sendToExternalServices(report)

        return report, nil</span>
}

func (s *ErrorReportingService) ReportCrash(userID int, crashReport *models.CrashReportRequest) (*models.CrashReport, error) <span class="cov0" title="0">{
        if !s.enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("crash reporting is disabled")
        }</span>

        // Create crash report
        <span class="cov0" title="0">report := &amp;models.CrashReport{
                UserID:     userID,
                Signal:     crashReport.Signal,
                Message:    crashReport.Message,
                StackTrace: crashReport.StackTrace,
                Context:    crashReport.Context,
                ReportedAt: time.Now(),
                Status:     models.CrashStatusNew,
        }

        // Add system information
        report.SystemInfo = s.collectSystemInfo()

        // Generate fingerprint for deduplication
        report.Fingerprint = s.generateCrashFingerprint(report)

        // Save to database
        if err := s.crashRepo.CreateCrashReport(report); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save crash report: %w", err)
        }</span>

        // Send critical notifications immediately
        <span class="cov0" title="0">go s.sendCrashNotifications(report)

        // Send to Crashlytics
        if s.config.CrashlyticsEnabled </span><span class="cov0" title="0">{
                go s.sendToCrashlytics(report)
        }</span>

        <span class="cov0" title="0">return report, nil</span>
}

func (s *ErrorReportingService) GetErrorReport(id int, userID int) (*models.ErrorReport, error) <span class="cov0" title="0">{
        report, err := s.errorRepo.GetErrorReport(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get error report: %w", err)
        }</span>

        // Check if user has access
        <span class="cov0" title="0">if report.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">return report, nil</span>
}

func (s *ErrorReportingService) GetCrashReport(id int, userID int) (*models.CrashReport, error) <span class="cov0" title="0">{
        report, err := s.crashRepo.GetCrashReport(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crash report: %w", err)
        }</span>

        // Check if user has access
        <span class="cov0" title="0">if report.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">return report, nil</span>
}

func (s *ErrorReportingService) UpdateErrorStatus(id int, userID int, status string) error <span class="cov0" title="0">{
        report, err := s.errorRepo.GetErrorReport(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get error report: %w", err)
        }</span>

        <span class="cov0" title="0">if report.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">report.Status = status
        if status == models.ErrorStatusResolved </span><span class="cov0" title="0">{
                now := time.Now()
                report.ResolvedAt = &amp;now
        }</span>

        <span class="cov0" title="0">return s.errorRepo.UpdateErrorReport(report)</span>
}

func (s *ErrorReportingService) UpdateCrashStatus(id int, userID int, status string) error <span class="cov0" title="0">{
        report, err := s.crashRepo.GetCrashReport(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get crash report: %w", err)
        }</span>

        <span class="cov0" title="0">if report.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">report.Status = status
        if status == models.CrashStatusResolved </span><span class="cov0" title="0">{
                now := time.Now()
                report.ResolvedAt = &amp;now
        }</span>

        <span class="cov0" title="0">return s.crashRepo.UpdateCrashReport(report)</span>
}

func (s *ErrorReportingService) GetErrorReportsByUser(userID int, filters *models.ErrorReportFilters) ([]*models.ErrorReport, error) <span class="cov0" title="0">{
        return s.errorRepo.GetErrorReportsByUser(userID, filters)
}</span>

func (s *ErrorReportingService) GetCrashReportsByUser(userID int, filters *models.CrashReportFilters) ([]*models.CrashReport, error) <span class="cov0" title="0">{
        return s.crashRepo.GetCrashReportsByUser(userID, filters)
}</span>

func (s *ErrorReportingService) GetErrorStatistics(userID int) (*models.ErrorStatistics, error) <span class="cov0" title="0">{
        return s.errorRepo.GetErrorStatistics(userID)
}</span>

func (s *ErrorReportingService) GetCrashStatistics(userID int) (*models.CrashStatistics, error) <span class="cov0" title="0">{
        return s.crashRepo.GetCrashStatistics(userID)
}</span>

func (s *ErrorReportingService) GetSystemHealth() (*models.SystemHealth, error) <span class="cov0" title="0">{
        health := &amp;models.SystemHealth{
                CheckedAt: time.Now(),
                Status:    "healthy",
                Metrics:   make(map[string]interface{}),
        }

        // Check recent error rates
        recentErrors, err := s.errorRepo.GetRecentErrorCount(1 * time.Hour)
        if err == nil </span><span class="cov0" title="0">{
                health.Metrics["recent_errors"] = recentErrors
                if recentErrors &gt; 100 </span><span class="cov0" title="0">{
                        health.Status = "degraded"
                }</span>
        }

        // Check recent crash rates
        <span class="cov0" title="0">recentCrashes, err := s.crashRepo.GetRecentCrashCount(1 * time.Hour)
        if err == nil </span><span class="cov0" title="0">{
                health.Metrics["recent_crashes"] = recentCrashes
                if recentCrashes &gt; 5 </span><span class="cov0" title="0">{
                        health.Status = "critical"
                }</span>
        }

        // Check system resources
        <span class="cov0" title="0">var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        health.Metrics["memory_used"] = m.Alloc
        health.Metrics["memory_total"] = m.Sys
        health.Metrics["goroutines"] = runtime.NumGoroutine()

        return health, nil</span>
}

func (s *ErrorReportingService) UpdateConfiguration(config *ErrorReportingConfig) error <span class="cov0" title="0">{
        s.config = config
        return nil
}</span>

func (s *ErrorReportingService) GetConfiguration() *ErrorReportingConfig <span class="cov0" title="0">{
        return s.config
}</span>

func (s *ErrorReportingService) CleanupOldReports(olderThan time.Time) error <span class="cov0" title="0">{
        if err := s.errorRepo.CleanupOldReports(olderThan); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old error reports: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.crashRepo.CleanupOldReports(olderThan); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old crash reports: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ErrorReportingService) ExportReports(userID int, filters *models.ExportFilters) ([]byte, error) <span class="cov0" title="0">{
        var reports []interface{}

        // Get error reports
        if filters.IncludeErrors </span><span class="cov0" title="0">{
                errorReports, err := s.errorRepo.GetErrorReportsByUser(userID, &amp;models.ErrorReportFilters{
                        StartDate: filters.StartDate,
                        EndDate:   filters.EndDate,
                        Level:     filters.Level,
                        Component: filters.Component,
                        Limit:     filters.Limit,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get error reports: %w", err)
                }</span>
                <span class="cov0" title="0">for _, report := range errorReports </span><span class="cov0" title="0">{
                        reports = append(reports, report)
                }</span>
        }

        // Get crash reports
        <span class="cov0" title="0">if filters.IncludeCrashes </span><span class="cov0" title="0">{
                crashReports, err := s.crashRepo.GetCrashReportsByUser(userID, &amp;models.CrashReportFilters{
                        StartDate: filters.StartDate,
                        EndDate:   filters.EndDate,
                        Signal:    filters.Signal,
                        Limit:     filters.Limit,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get crash reports: %w", err)
                }</span>
                <span class="cov0" title="0">for _, report := range crashReports </span><span class="cov0" title="0">{
                        reports = append(reports, report)
                }</span>
        }

        // Export based on format
        <span class="cov0" title="0">switch filters.Format </span>{
        case "json":<span class="cov0" title="0">
                return json.MarshalIndent(reports, "", "  ")</span>
        case "csv":<span class="cov0" title="0">
                return s.exportToCSV(reports)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported export format: %s", filters.Format)</span>
        }
}

// Helper methods

func (s *ErrorReportingService) filterSensitiveData(report *models.ErrorReport) *models.ErrorReport <span class="cov0" title="0">{
        // Remove sensitive patterns from message and stack trace
        sensitivePatterns := []string{
                "password", "token", "key", "secret", "auth",
                "email", "phone", "ssn", "credit",
        }

        for _, pattern := range sensitivePatterns </span><span class="cov0" title="0">{
                report.Message = strings.ReplaceAll(strings.ToLower(report.Message), pattern, "[REDACTED]")
                report.StackTrace = strings.ReplaceAll(strings.ToLower(report.StackTrace), pattern, "[REDACTED]")
        }</span>

        // Filter context data
        <span class="cov0" title="0">if report.Context != nil </span><span class="cov0" title="0">{
                filteredContext := make(map[string]interface{})
                for key, value := range report.Context </span><span class="cov0" title="0">{
                        keyLower := strings.ToLower(key)
                        isSensitive := false
                        for _, pattern := range sensitivePatterns </span><span class="cov0" title="0">{
                                if strings.Contains(keyLower, pattern) </span><span class="cov0" title="0">{
                                        isSensitive = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !isSensitive </span><span class="cov0" title="0">{
                                filteredContext[key] = value
                        }</span> else<span class="cov0" title="0"> {
                                filteredContext[key] = "[REDACTED]"
                        }</span>
                }
                <span class="cov0" title="0">report.Context = filteredContext</span>
        }

        <span class="cov0" title="0">return report</span>
}

func (s *ErrorReportingService) collectSystemInfo() map[string]interface{} <span class="cov0" title="0">{
        info := make(map[string]interface{})

        info["os"] = runtime.GOOS
        info["arch"] = runtime.GOARCH
        info["go_version"] = runtime.Version()
        info["num_cpu"] = runtime.NumCPU()
        info["num_goroutine"] = runtime.NumGoroutine()

        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        info["memory_alloc"] = m.Alloc
        info["memory_total_alloc"] = m.TotalAlloc
        info["memory_sys"] = m.Sys

        if hostname, err := os.Hostname(); err == nil </span><span class="cov0" title="0">{
                info["hostname"] = hostname
        }</span>

        <span class="cov0" title="0">if wd, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                info["working_directory"] = wd
        }</span>

        <span class="cov0" title="0">return info</span>
}

func (s *ErrorReportingService) generateFingerprint(report *models.ErrorReport) string <span class="cov0" title="0">{
        // Create a unique fingerprint based on error characteristics
        data := fmt.Sprintf("%s:%s:%s", report.Level, report.Component, report.ErrorCode)
        return fmt.Sprintf("%x", data)[:16]
}</span>

func (s *ErrorReportingService) generateCrashFingerprint(report *models.CrashReport) string <span class="cov0" title="0">{
        // Create a unique fingerprint based on crash characteristics
        data := fmt.Sprintf("%s:%s", report.Signal, report.Message)
        return fmt.Sprintf("%x", data)[:16]
}</span>

func (s *ErrorReportingService) sendNotifications(report *models.ErrorReport) <span class="cov0" title="0">{
        // Send Slack notification
        if s.config.SlackWebhookURL != "" </span><span class="cov0" title="0">{
                s.sendSlackNotification(report)
        }</span>

        // Send email notification
        <span class="cov0" title="0">if s.config.EmailNotifications </span><span class="cov0" title="0">{
                s.sendEmailNotification(report)
        }</span>
}

func (s *ErrorReportingService) sendCrashNotifications(report *models.CrashReport) <span class="cov0" title="0">{
        // Send critical notifications for crashes
        if s.config.SlackWebhookURL != "" </span><span class="cov0" title="0">{
                s.sendSlackCrashNotification(report)
        }</span>

        <span class="cov0" title="0">if s.config.EmailNotifications </span><span class="cov0" title="0">{
                s.sendEmailCrashNotification(report)
        }</span>
}

func (s *ErrorReportingService) sendSlackNotification(report *models.ErrorReport) error <span class="cov0" title="0">{
        if s.config.SlackWebhookURL == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">message := map[string]interface{}{
                "text": fmt.Sprintf("🚨 Error Report: %s", report.Message),
                "attachments": []map[string]interface{}{
                        {
                                "color": s.getColorForLevel(report.Level),
                                "fields": []map[string]interface{}{
                                        {"title": "Level", "value": report.Level, "short": true},
                                        {"title": "Component", "value": report.Component, "short": true},
                                        {"title": "Error Code", "value": report.ErrorCode, "short": true},
                                        {"title": "Time", "value": report.ReportedAt.Format(time.RFC3339), "short": true},
                                },
                        },
                },
        }

        jsonData, _ := json.Marshal(message)
        _, err := s.httpClient.Post(s.config.SlackWebhookURL, "application/json", bytes.NewBuffer(jsonData))
        return err</span>
}

func (s *ErrorReportingService) sendSlackCrashNotification(report *models.CrashReport) error <span class="cov0" title="0">{
        if s.config.SlackWebhookURL == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">message := map[string]interface{}{
                "text": fmt.Sprintf("💥 CRASH REPORT: %s", report.Message),
                "attachments": []map[string]interface{}{
                        {
                                "color": "danger",
                                "fields": []map[string]interface{}{
                                        {"title": "Signal", "value": report.Signal, "short": true},
                                        {"title": "Time", "value": report.ReportedAt.Format(time.RFC3339), "short": true},
                                },
                        },
                },
        }

        jsonData, _ := json.Marshal(message)
        _, err := s.httpClient.Post(s.config.SlackWebhookURL, "application/json", bytes.NewBuffer(jsonData))
        return err</span>
}

func (s *ErrorReportingService) sendEmailNotification(report *models.ErrorReport) error <span class="cov0" title="0">{
        // Email implementation would go here
        // This is a placeholder for email notification logic
        return nil
}</span>

func (s *ErrorReportingService) sendEmailCrashNotification(report *models.CrashReport) error <span class="cov0" title="0">{
        // Email implementation would go here
        // This is a placeholder for email notification logic
        return nil
}</span>

func (s *ErrorReportingService) sendToExternalServices(report *models.ErrorReport) <span class="cov0" title="0">{
        // Send to Sentry
        if s.config.SentryDSN != "" </span><span class="cov0" title="0">{
                s.sendToSentry(report)
        }</span>
}

func (s *ErrorReportingService) sendToSentry(report *models.ErrorReport) error <span class="cov0" title="0">{
        // Sentry integration would go here
        // This is a placeholder for Sentry integration
        return nil
}</span>

func (s *ErrorReportingService) sendToCrashlytics(report *models.CrashReport) error <span class="cov0" title="0">{
        if s.config.CrashlyticsAPIKey == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Crashlytics integration would go here
        // This is a placeholder for Firebase Crashlytics integration
        <span class="cov0" title="0">return nil</span>
}

func (s *ErrorReportingService) getColorForLevel(level string) string <span class="cov0" title="0">{
        switch strings.ToLower(level) </span>{
        case "error", "fatal":<span class="cov0" title="0">
                return "danger"</span>
        case "warning", "warn":<span class="cov0" title="0">
                return "warning"</span>
        case "info":<span class="cov0" title="0">
                return "good"</span>
        default:<span class="cov0" title="0">
                return "#36a64f"</span>
        }
}

func (s *ErrorReportingService) exportToCSV(reports []interface{}) ([]byte, error) <span class="cov0" title="0">{
        // CSV export implementation would go here
        // This is a placeholder for CSV export logic
        return []byte("CSV export not implemented"), nil
}</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">package services

import (
        "fmt"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type FavoritesService struct {
        favoritesRepo *repository.FavoritesRepository
        authService   *AuthService
}

func NewFavoritesService(favoritesRepo *repository.FavoritesRepository, authService *AuthService) *FavoritesService <span class="cov0" title="0">{
        return &amp;FavoritesService{
                favoritesRepo: favoritesRepo,
                authService:   authService,
        }
}</span>

func (s *FavoritesService) AddFavorite(userID int, favorite *models.Favorite) (*models.Favorite, error) <span class="cov0" title="0">{
        existing, err := s.favoritesRepo.GetFavorite(userID, favorite.EntityType, favorite.EntityID)
        if err == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                return existing, fmt.Errorf("item already in favorites")
        }</span>

        <span class="cov0" title="0">favorite.UserID = userID
        favorite.CreatedAt = time.Now()

        id, err := s.favoritesRepo.CreateFavorite(favorite)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add favorite: %w", err)
        }</span>

        <span class="cov0" title="0">favorite.ID = id
        return favorite, nil</span>
}

func (s *FavoritesService) RemoveFavorite(userID int, entityType string, entityID int) error <span class="cov0" title="0">{
        favorite, err := s.favoritesRepo.GetFavorite(userID, entityType, entityID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("favorite not found: %w", err)
        }</span>

        <span class="cov0" title="0">if favorite.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("unauthorized to remove this favorite")
        }</span>

        <span class="cov0" title="0">return s.favoritesRepo.DeleteFavorite(favorite.ID)</span>
}

func (s *FavoritesService) GetUserFavorites(userID int, entityType *string, category *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetUserFavorites(userID, entityType, category, limit, offset)
}</span>

func (s *FavoritesService) GetFavoritesByEntity(userID int, entityType string, entityID int) (*models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetFavorite(userID, entityType, entityID)
}</span>

func (s *FavoritesService) IsFavorite(userID int, entityType string, entityID int) (bool, error) <span class="cov0" title="0">{
        favorite, err := s.favoritesRepo.GetFavorite(userID, entityType, entityID)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return favorite != nil, nil</span>
}

func (s *FavoritesService) UpdateFavorite(userID int, favoriteID int, updates *models.UpdateFavoriteRequest) (*models.Favorite, error) <span class="cov0" title="0">{
        favorite, err := s.favoritesRepo.GetFavoriteByID(favoriteID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("favorite not found: %w", err)
        }</span>

        <span class="cov0" title="0">if favorite.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unauthorized to update this favorite")
        }</span>

        <span class="cov0" title="0">if updates.Category != nil </span><span class="cov0" title="0">{
                favorite.Category = updates.Category
        }</span>

        <span class="cov0" title="0">if updates.Notes != nil </span><span class="cov0" title="0">{
                favorite.Notes = updates.Notes
        }</span>

        <span class="cov0" title="0">if updates.Tags != nil </span><span class="cov0" title="0">{
                favorite.Tags = updates.Tags
        }</span>

        <span class="cov0" title="0">if updates.IsPublic != nil </span><span class="cov0" title="0">{
                favorite.IsPublic = *updates.IsPublic
        }</span>

        <span class="cov0" title="0">favorite.UpdatedAt = &amp;time.Time{}
        *favorite.UpdatedAt = time.Now()

        err = s.favoritesRepo.UpdateFavorite(favorite)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update favorite: %w", err)
        }</span>

        <span class="cov0" title="0">return favorite, nil</span>
}

func (s *FavoritesService) GetFavoriteCategories(userID int, entityType *string) ([]models.FavoriteCategory, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetFavoriteCategories(userID, entityType)
}</span>

func (s *FavoritesService) CreateFavoriteCategory(userID int, category *models.FavoriteCategory) (*models.FavoriteCategory, error) <span class="cov0" title="0">{
        category.UserID = userID
        category.CreatedAt = time.Now()

        id, err := s.favoritesRepo.CreateFavoriteCategory(category)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create category: %w", err)
        }</span>

        <span class="cov0" title="0">category.ID = id
        return category, nil</span>
}

func (s *FavoritesService) UpdateFavoriteCategory(userID int, categoryID int, updates *models.UpdateFavoriteCategoryRequest) (*models.FavoriteCategory, error) <span class="cov0" title="0">{
        category, err := s.favoritesRepo.GetFavoriteCategoryByID(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("category not found: %w", err)
        }</span>

        <span class="cov0" title="0">if category.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unauthorized to update this category")
        }</span>

        <span class="cov0" title="0">if updates.Name != "" </span><span class="cov0" title="0">{
                category.Name = updates.Name
        }</span>

        <span class="cov0" title="0">if updates.Description != nil </span><span class="cov0" title="0">{
                category.Description = updates.Description
        }</span>

        <span class="cov0" title="0">if updates.Color != nil </span><span class="cov0" title="0">{
                category.Color = updates.Color
        }</span>

        <span class="cov0" title="0">if updates.Icon != nil </span><span class="cov0" title="0">{
                category.Icon = updates.Icon
        }</span>

        <span class="cov0" title="0">if updates.IsPublic != nil </span><span class="cov0" title="0">{
                category.IsPublic = *updates.IsPublic
        }</span>

        <span class="cov0" title="0">category.UpdatedAt = &amp;time.Time{}
        *category.UpdatedAt = time.Now()

        err = s.favoritesRepo.UpdateFavoriteCategory(category)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update category: %w", err)
        }</span>

        <span class="cov0" title="0">return category, nil</span>
}

func (s *FavoritesService) DeleteFavoriteCategory(userID int, categoryID int) error <span class="cov0" title="0">{
        category, err := s.favoritesRepo.GetFavoriteCategoryByID(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("category not found: %w", err)
        }</span>

        <span class="cov0" title="0">if category.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("unauthorized to delete this category")
        }</span>

        <span class="cov0" title="0">favoritesCount, err := s.favoritesRepo.CountFavoritesByCategory(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check category usage: %w", err)
        }</span>

        <span class="cov0" title="0">if favoritesCount &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot delete category with existing favorites")
        }</span>

        <span class="cov0" title="0">return s.favoritesRepo.DeleteFavoriteCategory(categoryID)</span>
}

func (s *FavoritesService) GetPublicFavorites(entityType *string, category *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetPublicFavorites(entityType, category, limit, offset)
}</span>

func (s *FavoritesService) SearchFavorites(userID int, query string, entityType *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.SearchFavorites(userID, query, entityType, limit, offset)
}</span>

func (s *FavoritesService) GetFavoriteStatistics(userID int) (*models.FavoriteStatistics, error) <span class="cov0" title="0">{
        stats := &amp;models.FavoriteStatistics{
                UserID: userID,
        }

        totalCount, err := s.favoritesRepo.CountUserFavorites(userID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total favorites count: %w", err)
        }</span>
        <span class="cov0" title="0">stats.TotalFavorites = totalCount

        entityTypeCounts, err := s.favoritesRepo.GetFavoritesCountByEntityType(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get entity type counts: %w", err)
        }</span>
        <span class="cov0" title="0">stats.FavoritesByEntityType = entityTypeCounts

        categoryCounts, err := s.favoritesRepo.GetFavoritesCountByCategory(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get category counts: %w", err)
        }</span>
        <span class="cov0" title="0">stats.FavoritesByCategory = categoryCounts

        recentFavorites, err := s.favoritesRepo.GetRecentFavorites(userID, 5)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent favorites: %w", err)
        }</span>
        <span class="cov0" title="0">stats.RecentFavorites = recentFavorites

        return stats, nil</span>
}

func (s *FavoritesService) GetRecommendedFavorites(userID int, limit int) ([]models.RecommendedFavorite, error) <span class="cov0" title="0">{
        userFavorites, err := s.favoritesRepo.GetUserFavorites(userID, nil, nil, 100, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user favorites: %w", err)
        }</span>

        <span class="cov0" title="0">var entityTypes []string
        var categories []string

        for _, favorite := range userFavorites </span><span class="cov0" title="0">{
                entityTypes = append(entityTypes, favorite.EntityType)
                if favorite.Category != nil </span><span class="cov0" title="0">{
                        categories = append(categories, *favorite.Category)
                }</span>
        }

        <span class="cov0" title="0">entityTypes = s.removeDuplicateStrings(entityTypes)
        categories = s.removeDuplicateStrings(categories)

        var recommendations []models.RecommendedFavorite

        for _, entityType := range entityTypes </span><span class="cov0" title="0">{
                similarFavorites, err := s.favoritesRepo.GetSimilarFavorites(userID, entityType, limit/len(entityTypes))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, favorite := range similarFavorites </span><span class="cov0" title="0">{
                        recommendation := models.RecommendedFavorite{
                                Favorite:        favorite,
                                RecommendReason: fmt.Sprintf("Based on your interest in %s", entityType),
                                RecommendScore:  0.8,
                                RecommendedAt:   time.Now(),
                        }
                        recommendations = append(recommendations, recommendation)
                }</span>
        }

        <span class="cov0" title="0">if len(recommendations) &gt; limit </span><span class="cov0" title="0">{
                recommendations = recommendations[:limit]
        }</span>

        <span class="cov0" title="0">return recommendations, nil</span>
}

func (s *FavoritesService) ShareFavorite(userID int, favoriteID int, shareWith []int, permissions models.SharePermissions) (*models.FavoriteShare, error) <span class="cov0" title="0">{
        favorite, err := s.favoritesRepo.GetFavoriteByID(favoriteID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("favorite not found: %w", err)
        }</span>

        <span class="cov0" title="0">if favorite.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unauthorized to share this favorite")
        }</span>

        <span class="cov0" title="0">share := &amp;models.FavoriteShare{
                FavoriteID:   favoriteID,
                SharedByUser: userID,
                SharedWith:   shareWith,
                Permissions:  permissions,
                CreatedAt:    time.Now(),
                IsActive:     true,
        }

        id, err := s.favoritesRepo.CreateFavoriteShare(share)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create favorite share: %w", err)
        }</span>

        <span class="cov0" title="0">share.ID = id
        return share, nil</span>
}

func (s *FavoritesService) GetSharedFavorites(userID int, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetSharedFavorites(userID, limit, offset)
}</span>

func (s *FavoritesService) RevokeFavoriteShare(userID int, shareID int) error <span class="cov0" title="0">{
        share, err := s.favoritesRepo.GetFavoriteShareByID(shareID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("share not found: %w", err)
        }</span>

        <span class="cov0" title="0">if share.SharedByUser != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("unauthorized to revoke this share")
        }</span>

        <span class="cov0" title="0">return s.favoritesRepo.RevokeFavoriteShare(shareID)</span>
}

func (s *FavoritesService) BulkAddFavorites(userID int, favorites []models.BulkFavoriteRequest) ([]models.Favorite, error) <span class="cov0" title="0">{
        var results []models.Favorite
        var errors []error

        for _, req := range favorites </span><span class="cov0" title="0">{
                favorite := &amp;models.Favorite{
                        EntityType: req.EntityType,
                        EntityID:   req.EntityID,
                        Category:   req.Category,
                        Notes:      req.Notes,
                        Tags:       req.Tags,
                        IsPublic:   req.IsPublic,
                }

                result, err := s.AddFavorite(userID, favorite)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, err)
                        continue</span>
                }

                <span class="cov0" title="0">results = append(results, *result)</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 &amp;&amp; len(results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add any favorites: %v", errors)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

func (s *FavoritesService) BulkRemoveFavorites(userID int, favorites []models.BulkFavoriteRemoveRequest) error <span class="cov0" title="0">{
        var errors []error

        for _, req := range favorites </span><span class="cov0" title="0">{
                err := s.RemoveFavorite(userID, req.EntityType, req.EntityID)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, err)
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove some favorites: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *FavoritesService) ExportFavorites(userID int, format string) ([]byte, error) <span class="cov0" title="0">{
        favorites, err := s.favoritesRepo.GetUserFavorites(userID, nil, nil, 10000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user favorites: %w", err)
        }</span>

        <span class="cov0" title="0">switch format </span>{
        case "json":<span class="cov0" title="0">
                return s.exportFavoritesToJSON(favorites)</span>
        case "csv":<span class="cov0" title="0">
                return s.exportFavoritesToCSV(favorites)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported export format: %s", format)</span>
        }
}

func (s *FavoritesService) ImportFavorites(userID int, data []byte, format string) ([]models.Favorite, error) <span class="cov0" title="0">{
        switch format </span>{
        case "json":<span class="cov0" title="0">
                return s.importFavoritesFromJSON(userID, data)</span>
        case "csv":<span class="cov0" title="0">
                return s.importFavoritesFromCSV(userID, data)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported import format: %s", format)</span>
        }
}

func (s *FavoritesService) removeDuplicateStrings(slice []string) []string <span class="cov0" title="0">{
        keys := make(map[string]bool)
        var result []string

        for _, item := range slice </span><span class="cov0" title="0">{
                if !keys[item] </span><span class="cov0" title="0">{
                        keys[item] = true
                        result = append(result, item)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func (s *FavoritesService) exportFavoritesToJSON(favorites []models.Favorite) ([]byte, error) <span class="cov0" title="0">{
        // Implementation would use JSON marshal
        return nil, fmt.Errorf("JSON export not yet implemented")
}</span>

func (s *FavoritesService) exportFavoritesToCSV(favorites []models.Favorite) ([]byte, error) <span class="cov0" title="0">{
        // Implementation would use CSV writer
        return nil, fmt.Errorf("CSV export not yet implemented")
}</span>

func (s *FavoritesService) importFavoritesFromJSON(userID int, data []byte) ([]models.Favorite, error) <span class="cov0" title="0">{
        // Implementation would use JSON unmarshal
        return nil, fmt.Errorf("JSON import not yet implemented")
}</span>

func (s *FavoritesService) importFavoritesFromCSV(userID int, data []byte) ([]models.Favorite, error) <span class="cov0" title="0">{
        // Implementation would use CSV reader
        return nil, fmt.Errorf("CSV import not yet implemented")
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">package services

import (
        "archive/zip"
        "bytes"
        "compress/gzip"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type LogManagementService struct {
        logRepo       *repository.LogManagementRepository
        config        *LogManagementConfig
        logCollectors map[string]LogCollector
}

type LogManagementConfig struct {
        LogDirectory         string   `json:"log_directory"`
        MaxLogSize           int64    `json:"max_log_size"`        // in bytes
        MaxLogFiles          int      `json:"max_log_files"`       // per component
        RetentionDays        int      `json:"retention_days"`      // how long to keep logs
        CompressionEnabled   bool     `json:"compression_enabled"` // compress old logs
        RealTimeLogging      bool     `json:"real_time_logging"`   // enable real-time log streaming
        LogLevels            []string `json:"log_levels"`          // enabled log levels
        ComponentFilters     []string `json:"component_filters"`   // enabled components
        AutoCleanup          bool     `json:"auto_cleanup"`        // automatically cleanup old logs
        MaxShareDuration     int      `json:"max_share_duration"`  // hours
        AllowExternalSharing bool     `json:"allow_external_sharing"`
}

type LogCollector interface {
        CollectLogs() ([]*models.LogEntry, error)
        GetLogPath() string
        GetComponentName() string
}

type FileLogCollector struct {
        logPath       string
        componentName string
}

type DatabaseLogCollector struct {
        logRepo       *repository.LogManagementRepository
        componentName string
}

func NewLogManagementService(logRepo *repository.LogManagementRepository) *LogManagementService <span class="cov0" title="0">{
        config := &amp;LogManagementConfig{
                LogDirectory:         "/var/log/catalogizer",
                MaxLogSize:           100 * 1024 * 1024, // 100MB
                MaxLogFiles:          10,
                RetentionDays:        30,
                CompressionEnabled:   true,
                RealTimeLogging:      true,
                LogLevels:            []string{"error", "warning", "info", "debug"},
                ComponentFilters:     []string{"api", "auth", "sync", "conversion", "stress_test"},
                AutoCleanup:          true,
                MaxShareDuration:     24, // 24 hours
                AllowExternalSharing: false,
        }

        service := &amp;LogManagementService{
                logRepo:       logRepo,
                config:        config,
                logCollectors: make(map[string]LogCollector),
        }

        // Initialize default collectors
        service.initializeCollectors()

        return service
}</span>

func (s *LogManagementService) initializeCollectors() <span class="cov0" title="0">{
        // File-based collectors
        components := []string{"api", "auth", "sync", "conversion", "stress_test", "error_reporting"}
        for _, component := range components </span><span class="cov0" title="0">{
                logPath := filepath.Join(s.config.LogDirectory, component+".log")
                s.logCollectors[component] = &amp;FileLogCollector{
                        logPath:       logPath,
                        componentName: component,
                }
        }</span>

        // Database collector for application logs
        <span class="cov0" title="0">s.logCollectors["database"] = &amp;DatabaseLogCollector{
                logRepo:       s.logRepo,
                componentName: "database",
        }</span>
}

func (s *LogManagementService) CollectLogs(userID int, request *models.LogCollectionRequest) (*models.LogCollection, error) <span class="cov0" title="0">{
        collection := &amp;models.LogCollection{
                UserID:      userID,
                Name:        request.Name,
                Description: request.Description,
                Components:  request.Components,
                LogLevel:    request.LogLevel,
                StartTime:   request.StartTime,
                EndTime:     request.EndTime,
                CreatedAt:   time.Now(),
                Status:      models.LogCollectionStatusInProgress,
                Filters:     request.Filters,
        }

        // Create the collection record
        if err := s.logRepo.CreateLogCollection(collection); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log collection: %w", err)
        }</span>

        // Start collection process
        <span class="cov0" title="0">go s.performLogCollection(collection)

        return collection, nil</span>
}

func (s *LogManagementService) performLogCollection(collection *models.LogCollection) <span class="cov0" title="0">{
        var allEntries []*models.LogEntry

        // Collect logs from each component
        for _, component := range collection.Components </span><span class="cov0" title="0">{
                collector, exists := s.logCollectors[component]
                if !exists </span><span class="cov0" title="0">{
                        s.logError(collection.ID, fmt.Sprintf("Unknown component: %s", component))
                        continue</span>
                }

                <span class="cov0" title="0">entries, err := collector.CollectLogs()
                if err != nil </span><span class="cov0" title="0">{
                        s.logError(collection.ID, fmt.Sprintf("Failed to collect logs from %s: %v", component, err))
                        continue</span>
                }

                // Filter entries
                <span class="cov0" title="0">filteredEntries := s.filterLogEntries(entries, collection)
                allEntries = append(allEntries, filteredEntries...)</span>
        }

        // Sort entries by timestamp
        <span class="cov0" title="0">sort.Slice(allEntries, func(i, j int) bool </span><span class="cov0" title="0">{
                return allEntries[i].Timestamp.Before(allEntries[j].Timestamp)
        }</span>)

        // Store collected entries
        <span class="cov0" title="0">for _, entry := range allEntries </span><span class="cov0" title="0">{
                entry.CollectionID = collection.ID
                if err := s.logRepo.CreateLogEntry(entry); err != nil </span><span class="cov0" title="0">{
                        s.logError(collection.ID, fmt.Sprintf("Failed to store log entry: %v", err))
                }</span>
        }

        // Update collection status
        <span class="cov0" title="0">collection.Status = models.LogCollectionStatusCompleted
        collection.CompletedAt = &amp;[]time.Time{time.Now()}[0]
        collection.EntryCount = len(allEntries)

        if err := s.logRepo.UpdateLogCollection(collection); err != nil </span><span class="cov0" title="0">{
                s.logError(collection.ID, fmt.Sprintf("Failed to update collection status: %v", err))
        }</span>
}

func (s *LogManagementService) GetLogCollection(id int, userID int) (*models.LogCollection, error) <span class="cov0" title="0">{
        collection, err := s.logRepo.GetLogCollection(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log collection: %w", err)
        }</span>

        <span class="cov0" title="0">if collection.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">return collection, nil</span>
}

func (s *LogManagementService) GetLogCollectionsByUser(userID int, limit, offset int) ([]*models.LogCollection, error) <span class="cov0" title="0">{
        return s.logRepo.GetLogCollectionsByUser(userID, limit, offset)
}</span>

func (s *LogManagementService) GetLogEntries(collectionID int, userID int, filters *models.LogEntryFilters) ([]*models.LogEntry, error) <span class="cov0" title="0">{
        // Verify user has access to collection
        collection, err := s.GetLogCollection(collectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if collection.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">return s.logRepo.GetLogEntries(collectionID, filters)</span>
}

func (s *LogManagementService) CreateLogShare(userID int, request *models.LogShareRequest) (*models.LogShare, error) <span class="cov0" title="0">{
        // Verify user has access to collection
        collection, err := s.GetLogCollection(request.CollectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if collection.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        // Create share
        <span class="cov0" title="0">share := &amp;models.LogShare{
                CollectionID: request.CollectionID,
                UserID:       userID,
                ShareToken:   s.generateShareToken(),
                ShareType:    request.ShareType,
                ExpiresAt:    time.Now().Add(time.Duration(s.config.MaxShareDuration) * time.Hour),
                CreatedAt:    time.Now(),
                IsActive:     true,
                Permissions:  request.Permissions,
                Recipients:   request.Recipients,
        }

        if request.ExpiresAt != nil &amp;&amp; request.ExpiresAt.Before(share.ExpiresAt) </span><span class="cov0" title="0">{
                share.ExpiresAt = *request.ExpiresAt
        }</span>

        <span class="cov0" title="0">if err := s.logRepo.CreateLogShare(share); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log share: %w", err)
        }</span>

        <span class="cov0" title="0">return share, nil</span>
}

func (s *LogManagementService) GetLogShare(token string) (*models.LogShare, error) <span class="cov0" title="0">{
        share, err := s.logRepo.GetLogShareByToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log share: %w", err)
        }</span>

        <span class="cov0" title="0">if !share.IsActive || time.Now().After(share.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("share expired or inactive")
        }</span>

        <span class="cov0" title="0">return share, nil</span>
}

func (s *LogManagementService) RevokeLogShare(id int, userID int) error <span class="cov0" title="0">{
        share, err := s.logRepo.GetLogShare(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get log share: %w", err)
        }</span>

        // Verify user owns the shared collection
        <span class="cov0" title="0">collection, err := s.GetLogCollection(share.CollectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if collection.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">share.IsActive = false
        return s.logRepo.UpdateLogShare(share)</span>
}

func (s *LogManagementService) ExportLogs(collectionID int, userID int, format string) ([]byte, error) <span class="cov0" title="0">{
        // Verify access
        _, err := s.GetLogCollection(collectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get log entries
        <span class="cov0" title="0">entries, err := s.logRepo.GetLogEntries(collectionID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log entries: %w", err)
        }</span>

        <span class="cov0" title="0">switch format </span>{
        case "json":<span class="cov0" title="0">
                return json.MarshalIndent(entries, "", "  ")</span>
        case "csv":<span class="cov0" title="0">
                return s.exportToCSV(entries)</span>
        case "txt":<span class="cov0" title="0">
                return s.exportToText(entries)</span>
        case "zip":<span class="cov0" title="0">
                return s.exportToZip(entries)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported format: %s", format)</span>
        }
}

func (s *LogManagementService) StreamLogs(userID int, filters *models.LogStreamFilters) (&lt;-chan *models.LogEntry, error) <span class="cov0" title="0">{
        if !s.config.RealTimeLogging </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("real-time logging is disabled")
        }</span>

        // Create a channel for streaming
        <span class="cov0" title="0">logChannel := make(chan *models.LogEntry, 100)

        // Start streaming goroutine
        go s.streamLogEntries(logChannel, filters)

        return logChannel, nil</span>
}

func (s *LogManagementService) AnalyzeLogs(collectionID int, userID int) (*models.LogAnalysis, error) <span class="cov0" title="0">{
        // Verify access
        _, err := s.GetLogCollection(collectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get log entries
        <span class="cov0" title="0">entries, err := s.logRepo.GetLogEntries(collectionID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log entries: %w", err)
        }</span>

        <span class="cov0" title="0">analysis := &amp;models.LogAnalysis{
                CollectionID:       collectionID,
                TotalEntries:       len(entries),
                EntriesByLevel:     make(map[string]int),
                EntriesByComponent: make(map[string]int),
                ErrorPatterns:      make(map[string]int),
                TimeRange:          &amp;models.TimeRange{},
        }

        if len(entries) == 0 </span><span class="cov0" title="0">{
                return analysis, nil
        }</span>

        // Analyze entries
        <span class="cov0" title="0">analysis.TimeRange.Start = entries[0].Timestamp
        analysis.TimeRange.End = entries[len(entries)-1].Timestamp

        for _, entry := range entries </span><span class="cov0" title="0">{
                // Count by level
                analysis.EntriesByLevel[entry.Level]++

                // Count by component
                analysis.EntriesByComponent[entry.Component]++

                // Extract error patterns
                if entry.Level == "error" || entry.Level == "fatal" </span><span class="cov0" title="0">{
                        pattern := s.extractErrorPattern(entry.Message)
                        analysis.ErrorPatterns[pattern]++
                }</span>
        }

        // Generate insights
        <span class="cov0" title="0">analysis.Insights = s.generateInsights(entries, analysis)

        return analysis, nil</span>
}

func (s *LogManagementService) CleanupOldLogs() error <span class="cov0" title="0">{
        if !s.config.AutoCleanup </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cutoff := time.Now().AddDate(0, 0, -s.config.RetentionDays)

        // Cleanup collections
        if err := s.logRepo.CleanupOldCollections(cutoff); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old collections: %w", err)
        }</span>

        // Cleanup shares
        <span class="cov0" title="0">if err := s.logRepo.CleanupExpiredShares(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup expired shares: %w", err)
        }</span>

        // Cleanup physical log files
        <span class="cov0" title="0">return s.cleanupPhysicalLogFiles(cutoff)</span>
}

func (s *LogManagementService) GetConfiguration() *LogManagementConfig <span class="cov0" title="0">{
        return s.config
}</span>

func (s *LogManagementService) UpdateConfiguration(config *LogManagementConfig) error <span class="cov0" title="0">{
        s.config = config
        s.initializeCollectors() // Re-initialize collectors with new config
        return nil
}</span>

func (s *LogManagementService) GetLogStatistics(userID int) (*models.LogStatistics, error) <span class="cov0" title="0">{
        return s.logRepo.GetLogStatistics(userID)
}</span>

// Helper methods

func (s *LogManagementService) filterLogEntries(entries []*models.LogEntry, collection *models.LogCollection) []*models.LogEntry <span class="cov0" title="0">{
        var filtered []*models.LogEntry

        for _, entry := range entries </span><span class="cov0" title="0">{
                // Filter by time range
                if collection.StartTime != nil &amp;&amp; entry.Timestamp.Before(*collection.StartTime) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if collection.EndTime != nil &amp;&amp; entry.Timestamp.After(*collection.EndTime) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Filter by log level
                <span class="cov0" title="0">if collection.LogLevel != "" &amp;&amp; !s.isLogLevelIncluded(entry.Level, collection.LogLevel) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Apply custom filters
                <span class="cov0" title="0">if collection.Filters != nil &amp;&amp; !s.matchesFilters(entry, collection.Filters) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">filtered = append(filtered, entry)</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

func (s *LogManagementService) isLogLevelIncluded(entryLevel, filterLevel string) bool <span class="cov0" title="0">{
        levels := map[string]int{
                "debug":   0,
                "info":    1,
                "warning": 2,
                "error":   3,
                "fatal":   4,
        }

        entryLevelNum, exists := levels[strings.ToLower(entryLevel)]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">filterLevelNum, exists := levels[strings.ToLower(filterLevel)]
        if !exists </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return entryLevelNum &gt;= filterLevelNum</span>
}

func (s *LogManagementService) matchesFilters(entry *models.LogEntry, filters map[string]interface{}) bool <span class="cov0" title="0">{
        for key, value := range filters </span><span class="cov0" title="0">{
                switch key </span>{
                case "message_contains":<span class="cov0" title="0">
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                if !strings.Contains(strings.ToLower(entry.Message), strings.ToLower(str)) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                case "component":<span class="cov0" title="0">
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                if entry.Component != str </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return true</span>
}

func (s *LogManagementService) generateShareToken() string <span class="cov0" title="0">{
        // Generate a secure random token
        return fmt.Sprintf("log_share_%d_%d", time.Now().Unix(), time.Now().Nanosecond())
}</span>

func (s *LogManagementService) exportToCSV(entries []*models.LogEntry) ([]byte, error) <span class="cov0" title="0">{
        var buffer bytes.Buffer

        // Write CSV header
        buffer.WriteString("Timestamp,Level,Component,Message,Context\n")

        // Write entries
        for _, entry := range entries </span><span class="cov0" title="0">{
                contextJSON, _ := json.Marshal(entry.Context)
                buffer.WriteString(fmt.Sprintf("%s,%s,%s,\"%s\",\"%s\"\n",
                        entry.Timestamp.Format(time.RFC3339),
                        entry.Level,
                        entry.Component,
                        strings.ReplaceAll(entry.Message, "\"", "\"\""),
                        string(contextJSON)))
        }</span>

        <span class="cov0" title="0">return buffer.Bytes(), nil</span>
}

func (s *LogManagementService) exportToText(entries []*models.LogEntry) ([]byte, error) <span class="cov0" title="0">{
        var buffer bytes.Buffer

        for _, entry := range entries </span><span class="cov0" title="0">{
                buffer.WriteString(fmt.Sprintf("[%s] [%s] [%s] %s\n",
                        entry.Timestamp.Format(time.RFC3339),
                        strings.ToUpper(entry.Level),
                        entry.Component,
                        entry.Message))
        }</span>

        <span class="cov0" title="0">return buffer.Bytes(), nil</span>
}

func (s *LogManagementService) exportToZip(entries []*models.LogEntry) ([]byte, error) <span class="cov0" title="0">{
        var buffer bytes.Buffer
        zipWriter := zip.NewWriter(&amp;buffer)

        // Create JSON file
        jsonData, err := json.MarshalIndent(entries, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">jsonFile, err := zipWriter.Create("logs.json")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">jsonFile.Write(jsonData)

        // Create text file
        textData, err := s.exportToText(entries)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">textFile, err := zipWriter.Create("logs.txt")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">textFile.Write(textData)

        zipWriter.Close()
        return buffer.Bytes(), nil</span>
}

func (s *LogManagementService) streamLogEntries(channel chan&lt;- *models.LogEntry, filters *models.LogStreamFilters) <span class="cov0" title="0">{
        defer close(channel)

        // This is a simplified implementation
        // In a real system, you would tail log files or watch for new database entries
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0"></span>
                        // Check for new log entries and send them to the channel
                        // This is a placeholder implementation
                }
        }
}

func (s *LogManagementService) extractErrorPattern(message string) string <span class="cov0" title="0">{
        // Simple pattern extraction - remove specific details to group similar errors
        // This is a simplified implementation
        words := strings.Fields(message)
        if len(words) &gt; 5 </span><span class="cov0" title="0">{
                return strings.Join(words[:5], " ") + "..."
        }</span>
        <span class="cov0" title="0">return message</span>
}

func (s *LogManagementService) generateInsights(entries []*models.LogEntry, analysis *models.LogAnalysis) []string <span class="cov0" title="0">{
        var insights []string

        // Check error rate
        errorCount := analysis.EntriesByLevel["error"] + analysis.EntriesByLevel["fatal"]
        errorRate := float64(errorCount) / float64(analysis.TotalEntries) * 100

        if errorRate &gt; 10 </span><span class="cov0" title="0">{
                insights = append(insights, fmt.Sprintf("High error rate detected: %.1f%%", errorRate))
        }</span>

        // Check for component with most errors
        <span class="cov0" title="0">maxErrors := 0
        maxComponent := ""
        for component, count := range analysis.EntriesByComponent </span><span class="cov0" title="0">{
                if count &gt; maxErrors </span><span class="cov0" title="0">{
                        maxErrors = count
                        maxComponent = component
                }</span>
        }

        <span class="cov0" title="0">if maxComponent != "" </span><span class="cov0" title="0">{
                insights = append(insights, fmt.Sprintf("Component '%s' generated the most log entries (%d)", maxComponent, maxErrors))
        }</span>

        <span class="cov0" title="0">return insights</span>
}

func (s *LogManagementService) cleanupPhysicalLogFiles(cutoff time.Time) error <span class="cov0" title="0">{
        return filepath.Walk(s.config.LogDirectory, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !info.IsDir() &amp;&amp; info.ModTime().Before(cutoff) </span><span class="cov0" title="0">{
                        // Compress old log files if compression is enabled
                        if s.config.CompressionEnabled &amp;&amp; !strings.HasSuffix(path, ".gz") </span><span class="cov0" title="0">{
                                if err := s.compressLogFile(path); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov0" title="0">return nil</span>
        })
}

func (s *LogManagementService) compressLogFile(path string) error <span class="cov0" title="0">{
        input, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer input.Close()

        output, err := os.Create(path + ".gz")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer output.Close()

        gzipWriter := gzip.NewWriter(output)
        defer gzipWriter.Close()

        _, err = io.Copy(gzipWriter, input)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Remove original file after successful compression
        <span class="cov0" title="0">return os.Remove(path)</span>
}

func (s *LogManagementService) logError(collectionID int, message string) <span class="cov0" title="0">{
        // Log error to the system log (simplified implementation)
        fmt.Printf("[ERROR] Collection %d: %s\n", collectionID, message)
}</span>

// LogCollector implementations

func (c *FileLogCollector) CollectLogs() ([]*models.LogEntry, error) <span class="cov0" title="0">{
        file, err := os.Open(c.logPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var entries []*models.LogEntry
        // This is a simplified implementation
        // In reality, you would parse the log file format

        return entries, nil</span>
}

func (c *FileLogCollector) GetLogPath() string <span class="cov0" title="0">{
        return c.logPath
}</span>

func (c *FileLogCollector) GetComponentName() string <span class="cov0" title="0">{
        return c.componentName
}</span>

func (c *DatabaseLogCollector) CollectLogs() ([]*models.LogEntry, error) <span class="cov0" title="0">{
        // Collect logs from database
        return c.logRepo.GetRecentLogEntries(c.componentName, 1000)
}</span>

func (c *DatabaseLogCollector) GetLogPath() string <span class="cov0" title="0">{
        return "database"
}</span>

func (c *DatabaseLogCollector) GetComponentName() string <span class="cov0" title="0">{
        return c.componentName
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package services

import (
        "bytes"
        "encoding/json"
        "fmt"
        "html/template"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type ReportingService struct {
        analyticsRepo *repository.AnalyticsRepository
        userRepo      *repository.UserRepository
}

func NewReportingService(analyticsRepo *repository.AnalyticsRepository, userRepo *repository.UserRepository) *ReportingService <span class="cov0" title="0">{
        return &amp;ReportingService{
                analyticsRepo: analyticsRepo,
                userRepo:      userRepo,
        }
}</span>

func (s *ReportingService) GenerateReport(reportType string, format string, params map[string]interface{}) (*models.GeneratedReport, error) <span class="cov0" title="0">{
        var data interface{}
        var err error

        switch reportType </span>{
        case "user_analytics":<span class="cov0" title="0">
                data, err = s.generateUserAnalyticsData(params)</span>
        case "system_overview":<span class="cov0" title="0">
                data, err = s.generateSystemOverviewData(params)</span>
        case "media_analytics":<span class="cov0" title="0">
                data, err = s.generateMediaAnalyticsData(params)</span>
        case "user_activity":<span class="cov0" title="0">
                data, err = s.generateUserActivityData(params)</span>
        case "security_audit":<span class="cov0" title="0">
                data, err = s.generateSecurityAuditData(params)</span>
        case "performance_metrics":<span class="cov0" title="0">
                data, err = s.generatePerformanceMetricsData(params)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported report type: %s", reportType)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate report data: %w", err)
        }</span>

        <span class="cov0" title="0">content, err := s.formatReport(data, format, reportType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to format report: %w", err)
        }</span>

        <span class="cov0" title="0">report := &amp;models.GeneratedReport{
                Type:        reportType,
                Format:      format,
                Content:     content,
                GeneratedAt: time.Now(),
                Parameters:  params,
        }

        return report, nil</span>
}

func (s *ReportingService) generateUserAnalyticsData(params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        userID, ok := params["user_id"].(int)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user_id parameter required")
        }</span>

        <span class="cov0" title="0">startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">mediaAccessLogs, err := s.analyticsRepo.GetUserMediaAccessLogs(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get media access logs: %w", err)
        }</span>

        <span class="cov0" title="0">events, err := s.analyticsRepo.GetUserEvents(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user events: %w", err)
        }</span>

        <span class="cov0" title="0">analytics := &amp;models.UserAnalyticsReport{
                User:               user,
                StartDate:          startDate,
                EndDate:            endDate,
                TotalMediaAccesses: len(mediaAccessLogs),
                TotalEvents:        len(events),
                MediaAccessLogs:    mediaAccessLogs,
                Events:             events,
                AccessPatterns:     s.analyzeUserAccessPatterns(mediaAccessLogs),
                DeviceUsage:        s.analyzeUserDeviceUsage(mediaAccessLogs),
                LocationAnalysis:   s.analyzeUserLocations(mediaAccessLogs),
                TimePatterns:       s.analyzeUserTimePatterns(mediaAccessLogs),
                PopularContent:     s.analyzeUserPopularContent(mediaAccessLogs),
        }

        return analytics, nil</span>
}

func (s *ReportingService) generateSystemOverviewData(params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">totalUsers, err := s.analyticsRepo.GetTotalUsers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total users: %w", err)
        }</span>

        <span class="cov0" title="0">activeUsers, err := s.analyticsRepo.GetActiveUsers(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active users: %w", err)
        }</span>

        <span class="cov0" title="0">totalMediaAccesses, err := s.analyticsRepo.GetTotalMediaAccesses(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total media accesses: %w", err)
        }</span>

        <span class="cov0" title="0">totalEvents, err := s.analyticsRepo.GetTotalEvents(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total events: %w", err)
        }</span>

        <span class="cov0" title="0">topMedia, err := s.analyticsRepo.GetTopAccessedMedia(startDate, endDate, 20)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top media: %w", err)
        }</span>

        <span class="cov0" title="0">userGrowth, err := s.analyticsRepo.GetUserGrowthData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user growth data: %w", err)
        }</span>

        <span class="cov0" title="0">overview := &amp;models.SystemOverviewReport{
                StartDate:          startDate,
                EndDate:            endDate,
                TotalUsers:         totalUsers,
                ActiveUsers:        activeUsers,
                TotalMediaAccesses: totalMediaAccesses,
                TotalEvents:        totalEvents,
                TopAccessedMedia:   topMedia,
                UserGrowthData:     userGrowth,
                SystemHealth:       s.calculateSystemHealth(totalUsers, activeUsers, totalMediaAccesses),
                UsageStatistics:    s.calculateUsageStatistics(startDate, endDate),
                PerformanceMetrics: s.calculatePerformanceMetrics(startDate, endDate),
        }

        return overview, nil</span>
}

func (s *ReportingService) generateMediaAnalyticsData(params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        mediaIDFloat, ok := params["media_id"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("media_id parameter required")
        }</span>
        <span class="cov0" title="0">mediaID := int(mediaIDFloat)

        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">accessLogs, err := s.analyticsRepo.GetMediaAccessLogs(0, &amp;mediaID, 10000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get media access logs: %w", err)
        }</span>

        <span class="cov0" title="0">filteredLogs := s.filterLogsByDateRange(accessLogs, startDate, endDate)

        analytics := &amp;models.MediaAnalyticsReport{
                MediaID:        mediaID,
                StartDate:      startDate,
                EndDate:        endDate,
                TotalAccesses:  len(filteredLogs),
                UniqueUsers:    s.countUniqueUsers(filteredLogs),
                AccessLogs:     filteredLogs,
                AccessPatterns: s.analyzeAccessPatterns(filteredLogs),
                UserEngagement: s.analyzeUserEngagement(filteredLogs),
                GeographicData: s.analyzeGeographicDistribution(filteredLogs),
                DeviceAnalysis: s.analyzeDeviceDistribution(filteredLogs),
                TimeAnalysis:   s.analyzeTimeDistribution(filteredLogs),
        }

        return analytics, nil</span>
}

func (s *ReportingService) generateUserActivityData(params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">allLogs, err := s.analyticsRepo.GetAllMediaAccessLogs(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all media access logs: %w", err)
        }</span>

        <span class="cov0" title="0">userActivity := make(map[int][]models.MediaAccessLog)
        for _, log := range allLogs </span><span class="cov0" title="0">{
                userActivity[log.UserID] = append(userActivity[log.UserID], log)
        }</span>

        <span class="cov0" title="0">var userActivities []models.UserActivitySummary
        for userID, logs := range userActivity </span><span class="cov0" title="0">{
                user, err := s.userRepo.GetByID(userID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">activity := models.UserActivitySummary{
                        User:              user,
                        TotalAccesses:     len(logs),
                        LastActivity:      s.getLastActivityTime(logs),
                        MostActiveHour:    s.getMostActiveHour(logs),
                        PreferredDevices:  s.getPreferredDevices(logs),
                        AccessedLocations: s.getAccessedLocations(logs),
                }

                userActivities = append(userActivities, activity)</span>
        }

        <span class="cov0" title="0">report := &amp;models.UserActivityReport{
                StartDate:      startDate,
                EndDate:        endDate,
                UserActivities: userActivities,
                TotalUsers:     len(userActivities),
                TotalAccesses:  len(allLogs),
                Summary:        s.generateActivitySummary(userActivities),
        }

        return report, nil</span>
}

func (s *ReportingService) generateSecurityAuditData(params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // For now, return basic security metrics
        // In a full implementation, this would analyze login attempts, failed authentications, etc.
        <span class="cov0" title="0">audit := &amp;models.SecurityAuditReport{
                StartDate:           startDate,
                EndDate:             endDate,
                FailedLoginAttempts: 0, // Would be calculated from actual data
                SuccessfulLogins:    0, // Would be calculated from actual data
                SuspiciousActivity:  []models.SecurityIncident{},
                SecurityMetrics:     s.calculateSecurityMetrics(startDate, endDate),
        }

        return audit, nil</span>
}

func (s *ReportingService) generatePerformanceMetricsData(params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sessionData, err := s.analyticsRepo.GetSessionData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get session data: %w", err)
        }</span>

        <span class="cov0" title="0">metrics := &amp;models.PerformanceMetricsReport{
                StartDate:              startDate,
                EndDate:                endDate,
                AverageSessionDuration: s.calculateAverageSessionDuration(sessionData),
                TotalSessions:          len(sessionData),
                ResponseTimes:          s.calculateResponseTimes(startDate, endDate),
                SystemLoad:             s.calculateSystemLoad(startDate, endDate),
                ErrorRates:             s.calculateErrorRates(startDate, endDate),
        }

        return metrics, nil</span>
}

func (s *ReportingService) formatReport(data interface{}, format string, reportType string) ([]byte, error) <span class="cov0" title="0">{
        switch format </span>{
        case "json":<span class="cov0" title="0">
                return json.MarshalIndent(data, "", "  ")</span>
        case "markdown":<span class="cov0" title="0">
                return s.formatAsMarkdown(data, reportType)</span>
        case "html":<span class="cov0" title="0">
                return s.formatAsHTML(data, reportType)</span>
        case "pdf":<span class="cov0" title="0">
                return s.formatAsPDF(data, reportType)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported format: %s", format)</span>
        }
}

func (s *ReportingService) formatAsMarkdown(data interface{}, reportType string) ([]byte, error) <span class="cov0" title="0">{
        var buffer bytes.Buffer

        switch reportType </span>{
        case "user_analytics":<span class="cov0" title="0">
                report := data.(*models.UserAnalyticsReport)
                buffer.WriteString(fmt.Sprintf("# User Analytics Report\n\n"))
                displayName := ""
                if report.User.DisplayName != nil </span><span class="cov0" title="0">{
                        displayName = *report.User.DisplayName
                }</span>
                <span class="cov0" title="0">buffer.WriteString(fmt.Sprintf("**User:** %s (%s)\n", displayName, report.User.Username))
                buffer.WriteString(fmt.Sprintf("**Period:** %s to %s\n\n", report.StartDate.Format("2006-01-02"), report.EndDate.Format("2006-01-02")))
                buffer.WriteString(fmt.Sprintf("## Summary\n\n"))
                buffer.WriteString(fmt.Sprintf("- Total Media Accesses: %d\n", report.TotalMediaAccesses))
                buffer.WriteString(fmt.Sprintf("- Total Events: %d\n", report.TotalEvents))
                buffer.WriteString(fmt.Sprintf("- Account Created: %s\n\n", report.User.CreatedAt.Format("2006-01-02")))</span>

        case "system_overview":<span class="cov0" title="0">
                report := data.(*models.SystemOverviewReport)
                buffer.WriteString(fmt.Sprintf("# System Overview Report\n\n"))
                buffer.WriteString(fmt.Sprintf("**Period:** %s to %s\n\n", report.StartDate.Format("2006-01-02"), report.EndDate.Format("2006-01-02")))
                buffer.WriteString(fmt.Sprintf("## System Statistics\n\n"))
                buffer.WriteString(fmt.Sprintf("- Total Users: %d\n", report.TotalUsers))
                buffer.WriteString(fmt.Sprintf("- Active Users: %d\n", report.ActiveUsers))
                buffer.WriteString(fmt.Sprintf("- Total Media Accesses: %d\n", report.TotalMediaAccesses))
                buffer.WriteString(fmt.Sprintf("- Total Events: %d\n\n", report.TotalEvents))</span>

        default:<span class="cov0" title="0">
                buffer.WriteString(fmt.Sprintf("# %s Report\n\n", reportType))
                jsonData, _ := json.MarshalIndent(data, "", "  ")
                buffer.WriteString(fmt.Sprintf("```json\n%s\n```\n", string(jsonData)))</span>
        }

        <span class="cov0" title="0">return buffer.Bytes(), nil</span>
}

func (s *ReportingService) formatAsHTML(data interface{}, reportType string) ([]byte, error) <span class="cov0" title="0">{
        htmlTemplate := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;{{.Title}}&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 40px; }
        .header { border-bottom: 2px solid #333; padding-bottom: 20px; margin-bottom: 30px; }
        .section { margin-bottom: 30px; }
        .metric { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 5px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="header"&gt;
        &lt;h1&gt;{{.Title}}&lt;/h1&gt;
        &lt;p&gt;Generated on: {{.GeneratedAt}}&lt;/p&gt;
        {{if .Period}}&lt;p&gt;Period: {{.Period}}&lt;/p&gt;{{end}}
    &lt;/div&gt;

    &lt;div class="content"&gt;
        {{.Content}}
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`

        tmpl, err := template.New("report").Parse(htmlTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse HTML template: %w", err)
        }</span>

        <span class="cov0" title="0">var content string
        switch reportType </span>{
        case "user_analytics":<span class="cov0" title="0">
                report := data.(*models.UserAnalyticsReport)
                displayNameHTML := ""
                if report.User.DisplayName != nil </span><span class="cov0" title="0">{
                        displayNameHTML = *report.User.DisplayName
                }</span>
                <span class="cov0" title="0">content = fmt.Sprintf(`
                        &lt;div class="section"&gt;
                                &lt;h2&gt;User Information&lt;/h2&gt;
                                &lt;div class="metric"&gt;Username: %s&lt;/div&gt;
                                &lt;div class="metric"&gt;Display Name: %s&lt;/div&gt;
                                &lt;div class="metric"&gt;Email: %s&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="section"&gt;
                                &lt;h2&gt;Activity Summary&lt;/h2&gt;
                                &lt;div class="metric"&gt;Total Media Accesses: %d&lt;/div&gt;
                                &lt;div class="metric"&gt;Total Events: %d&lt;/div&gt;
                        &lt;/div&gt;`,
                        report.User.Username, displayNameHTML, report.User.Email,
                        report.TotalMediaAccesses, report.TotalEvents)</span>

        case "system_overview":<span class="cov0" title="0">
                report := data.(*models.SystemOverviewReport)
                content = fmt.Sprintf(`
                        &lt;div class="section"&gt;
                                &lt;h2&gt;System Statistics&lt;/h2&gt;
                                &lt;div class="metric"&gt;Total Users: %d&lt;/div&gt;
                                &lt;div class="metric"&gt;Active Users: %d&lt;/div&gt;
                                &lt;div class="metric"&gt;Total Media Accesses: %d&lt;/div&gt;
                                &lt;div class="metric"&gt;Total Events: %d&lt;/div&gt;
                        &lt;/div&gt;`,
                        report.TotalUsers, report.ActiveUsers, report.TotalMediaAccesses, report.TotalEvents)</span>

        default:<span class="cov0" title="0">
                jsonData, _ := json.MarshalIndent(data, "", "  ")
                content = fmt.Sprintf("&lt;pre&gt;%s&lt;/pre&gt;", string(jsonData))</span>
        }

        <span class="cov0" title="0">templateData := struct {
                Title       string
                GeneratedAt string
                Period      string
                Content     template.HTML
        }{
                Title:       fmt.Sprintf("%s Report", reportType),
                GeneratedAt: time.Now().Format("2006-01-02 15:04:05"),
                Content:     template.HTML(content),
        }

        var buffer bytes.Buffer
        err = tmpl.Execute(&amp;buffer, templateData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute HTML template: %w", err)
        }</span>

        <span class="cov0" title="0">return buffer.Bytes(), nil</span>
}

func (s *ReportingService) formatAsPDF(data interface{}, reportType string) ([]byte, error) <span class="cov0" title="0">{
        // For now, return an error as PDF generation requires additional libraries
        // In a full implementation, this would use a library like gofpdf or wkhtmltopdf
        return nil, fmt.Errorf("PDF format not yet implemented")
}</span>

func (s *ReportingService) extractDateRange(params map[string]interface{}) (time.Time, time.Time, error) <span class="cov0" title="0">{
        startDateStr, ok := params["start_date"].(string)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("start_date parameter required")
        }</span>

        <span class="cov0" title="0">endDateStr, ok := params["end_date"].(string)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("end_date parameter required")
        }</span>

        <span class="cov0" title="0">startDate, err := time.Parse("2006-01-02", startDateStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("invalid start_date format")
        }</span>

        <span class="cov0" title="0">endDate, err := time.Parse("2006-01-02", endDateStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("invalid end_date format")
        }</span>

        <span class="cov0" title="0">return startDate, endDate, nil</span>
}

// Helper methods for analytics calculations
func (s *ReportingService) analyzeUserAccessPatterns(logs []models.MediaAccessLog) map[string]interface{} <span class="cov0" title="0">{
        patterns := make(map[string]interface{})

        hourlyAccess := make(map[int]int)
        dailyAccess := make(map[string]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                hour := log.AccessTime.Hour()
                hourlyAccess[hour]++

                day := log.AccessTime.Weekday().String()
                dailyAccess[day]++
        }</span>

        <span class="cov0" title="0">patterns["hourly"] = hourlyAccess
        patterns["daily"] = dailyAccess

        return patterns</span>
}

func (s *ReportingService) analyzeUserDeviceUsage(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        deviceUsage := make(map[string]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                if log.DeviceInfo != nil </span><span class="cov0" title="0">{
                        deviceModel := ""
                        if log.DeviceInfo.DeviceModel != nil </span><span class="cov0" title="0">{
                                deviceModel = *log.DeviceInfo.DeviceModel
                        }</span>
                        <span class="cov0" title="0">device := fmt.Sprintf("%s %s", log.DeviceInfo.Platform, deviceModel)
                        deviceUsage[device]++</span>
                }
        }

        <span class="cov0" title="0">return deviceUsage</span>
}

func (s *ReportingService) analyzeUserLocations(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        locations := make(map[string]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                if log.Location != nil </span><span class="cov0" title="0">{
                        location := fmt.Sprintf("%.2f,%.2f", log.Location.Latitude, log.Location.Longitude)
                        locations[location]++
                }</span>
        }

        <span class="cov0" title="0">return locations</span>
}

func (s *ReportingService) analyzeUserTimePatterns(logs []models.MediaAccessLog) map[string]interface{} <span class="cov0" title="0">{
        return s.analyzeUserAccessPatterns(logs) // Same as access patterns
}</span>

func (s *ReportingService) analyzeUserPopularContent(logs []models.MediaAccessLog) []models.MediaAccessCount <span class="cov0" title="0">{
        mediaCount := make(map[int]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                mediaCount[log.MediaID]++
        }</span>

        <span class="cov0" title="0">var results []models.MediaAccessCount
        for mediaID, count := range mediaCount </span><span class="cov0" title="0">{
                results = append(results, models.MediaAccessCount{
                        MediaID:     mediaID,
                        AccessCount: count,
                })
        }</span>

        <span class="cov0" title="0">return results</span>
}

func (s *ReportingService) filterLogsByDateRange(logs []models.MediaAccessLog, startDate, endDate time.Time) []models.MediaAccessLog <span class="cov0" title="0">{
        var filtered []models.MediaAccessLog

        for _, log := range logs </span><span class="cov0" title="0">{
                if log.AccessTime.After(startDate) &amp;&amp; log.AccessTime.Before(endDate) </span><span class="cov0" title="0">{
                        filtered = append(filtered, log)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

func (s *ReportingService) countUniqueUsers(logs []models.MediaAccessLog) int <span class="cov0" title="0">{
        users := make(map[int]bool)

        for _, log := range logs </span><span class="cov0" title="0">{
                users[log.UserID] = true
        }</span>

        <span class="cov0" title="0">return len(users)</span>
}

func (s *ReportingService) calculateSystemHealth(totalUsers, activeUsers, mediaAccesses int) models.SystemHealth <span class="cov0" title="0">{
        var healthScore float64

        if totalUsers &gt; 0 </span><span class="cov0" title="0">{
                activeRatio := float64(activeUsers) / float64(totalUsers)
                healthScore += activeRatio * 50
        }</span>

        <span class="cov0" title="0">if mediaAccesses &gt; 0 </span><span class="cov0" title="0">{
                healthScore += 30
        }</span>

        <span class="cov0" title="0">if activeUsers &gt; 10 </span><span class="cov0" title="0">{
                healthScore += 20
        }</span>

        <span class="cov0" title="0">var status string
        switch </span>{
        case healthScore &gt;= 80:<span class="cov0" title="0">
                status = "excellent"</span>
        case healthScore &gt;= 60:<span class="cov0" title="0">
                status = "good"</span>
        case healthScore &gt;= 40:<span class="cov0" title="0">
                status = "fair"</span>
        default:<span class="cov0" title="0">
                status = "poor"</span>
        }

        <span class="cov0" title="0">return models.SystemHealth{
                Score:  healthScore,
                Status: status,
        }</span>
}

func (s *ReportingService) calculateUsageStatistics(startDate, endDate time.Time) models.UsageStatistics <span class="cov0" title="0">{
        // Placeholder implementation
        return models.UsageStatistics{
                PeakHours:    []int{14, 15, 16, 20, 21},
                AverageDaily: 150,
                GrowthRate:   5.2,
        }
}</span>

func (s *ReportingService) calculatePerformanceMetrics(startDate, endDate time.Time) models.PerformanceMetrics <span class="cov0" title="0">{
        // Placeholder implementation
        return models.PerformanceMetrics{
                ResponseTime: 250.5,
                Throughput:   1200,
                ErrorRate:    0.02,
        }
}</span>

func (s *ReportingService) analyzeAccessPatterns(logs []models.MediaAccessLog) map[string]interface{} <span class="cov0" title="0">{
        return s.analyzeUserAccessPatterns(logs)
}</span>

func (s *ReportingService) analyzeUserEngagement(logs []models.MediaAccessLog) models.UserEngagement <span class="cov0" title="0">{
        return models.UserEngagement{
                AverageSessionTime: 15.5,
                ReturnRate:         85.2,
                InteractionDepth:   3.4,
        }
}</span>

func (s *ReportingService) analyzeGeographicDistribution(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        return s.analyzeUserLocations(logs)
}</span>

func (s *ReportingService) analyzeDeviceDistribution(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        return s.analyzeUserDeviceUsage(logs)
}</span>

func (s *ReportingService) analyzeTimeDistribution(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        timeDistribution := make(map[string]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                hour := log.AccessTime.Hour()
                var timeSlot string

                switch </span>{
                case hour &gt;= 6 &amp;&amp; hour &lt; 12:<span class="cov0" title="0">
                        timeSlot = "morning"</span>
                case hour &gt;= 12 &amp;&amp; hour &lt; 18:<span class="cov0" title="0">
                        timeSlot = "afternoon"</span>
                case hour &gt;= 18 &amp;&amp; hour &lt; 22:<span class="cov0" title="0">
                        timeSlot = "evening"</span>
                default:<span class="cov0" title="0">
                        timeSlot = "night"</span>
                }

                <span class="cov0" title="0">timeDistribution[timeSlot]++</span>
        }

        <span class="cov0" title="0">return timeDistribution</span>
}

func (s *ReportingService) getLastActivityTime(logs []models.MediaAccessLog) time.Time <span class="cov0" title="0">{
        if len(logs) == 0 </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        <span class="cov0" title="0">latest := logs[0].AccessTime
        for _, log := range logs </span><span class="cov0" title="0">{
                if log.AccessTime.After(latest) </span><span class="cov0" title="0">{
                        latest = log.AccessTime
                }</span>
        }

        <span class="cov0" title="0">return latest</span>
}

func (s *ReportingService) getMostActiveHour(logs []models.MediaAccessLog) int <span class="cov0" title="0">{
        hourCounts := make(map[int]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                hour := log.AccessTime.Hour()
                hourCounts[hour]++
        }</span>

        <span class="cov0" title="0">maxCount := 0
        mostActiveHour := 0

        for hour, count := range hourCounts </span><span class="cov0" title="0">{
                if count &gt; maxCount </span><span class="cov0" title="0">{
                        maxCount = count
                        mostActiveHour = hour
                }</span>
        }

        <span class="cov0" title="0">return mostActiveHour</span>
}

func (s *ReportingService) getPreferredDevices(logs []models.MediaAccessLog) []string <span class="cov0" title="0">{
        deviceCounts := s.analyzeUserDeviceUsage(logs)

        var devices []string
        for device := range deviceCounts </span><span class="cov0" title="0">{
                devices = append(devices, device)
        }</span>

        <span class="cov0" title="0">return devices</span>
}

func (s *ReportingService) getAccessedLocations(logs []models.MediaAccessLog) []string <span class="cov0" title="0">{
        locationCounts := s.analyzeUserLocations(logs)

        var locations []string
        for location := range locationCounts </span><span class="cov0" title="0">{
                locations = append(locations, location)
        }</span>

        <span class="cov0" title="0">return locations</span>
}

func (s *ReportingService) generateActivitySummary(activities []models.UserActivitySummary) models.ActivitySummary <span class="cov0" title="0">{
        if len(activities) == 0 </span><span class="cov0" title="0">{
                return models.ActivitySummary{}
        }</span>

        <span class="cov0" title="0">totalAccesses := 0
        for _, activity := range activities </span><span class="cov0" title="0">{
                totalAccesses += activity.TotalAccesses
        }</span>

        <span class="cov0" title="0">avgAccesses := float64(totalAccesses) / float64(len(activities))

        return models.ActivitySummary{
                TotalUsers:       len(activities),
                TotalAccesses:    totalAccesses,
                AverageAccesses:  avgAccesses,
                MostActiveUsers:  len(activities), // Simplified
                LeastActiveUsers: 0,               // Simplified
        }</span>
}

func (s *ReportingService) calculateSecurityMetrics(startDate, endDate time.Time) models.SecurityMetrics <span class="cov0" title="0">{
        // Placeholder implementation
        return models.SecurityMetrics{
                ThreatLevel:        "low",
                VulnerabilityCount: 0,
                SecurityScore:      95.5,
        }
}</span>

func (s *ReportingService) calculateAverageSessionDuration(sessions []models.SessionData) time.Duration <span class="cov0" title="0">{
        if len(sessions) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var total time.Duration
        for _, session := range sessions </span><span class="cov0" title="0">{
                total += session.Duration
        }</span>

        <span class="cov0" title="0">return total / time.Duration(len(sessions))</span>
}

func (s *ReportingService) calculateResponseTimes(startDate, endDate time.Time) models.ResponseTimes <span class="cov0" title="0">{
        // Placeholder implementation
        return models.ResponseTimes{
                Average: 250.5,
                Min:     50.2,
                Max:     1200.8,
                P95:     480.3,
                P99:     850.7,
        }
}</span>

func (s *ReportingService) calculateSystemLoad(startDate, endDate time.Time) models.SystemLoad <span class="cov0" title="0">{
        // Placeholder implementation
        return models.SystemLoad{
                CPU:     45.2,
                Memory:  68.5,
                Disk:    32.1,
                Network: 15.8,
        }
}</span>

func (s *ReportingService) calculateErrorRates(startDate, endDate time.Time) models.ErrorRates <span class="cov0" title="0">{
        // Placeholder implementation
        return models.ErrorRates{
                HTTP4xx:  2.1,
                HTTP5xx:  0.3,
                Timeouts: 0.1,
                Total:    2.5,
        }
}</span>
</pre>
		
		<pre class="file" id="file102" style="display: none">package services

import (
        "context"
        "fmt"
        "io"
        "math/rand"
        "net/http"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type StressTestService struct {
        stressRepo  *repository.StressTestRepository
        authService *AuthService
        activeTests map[int]*TestExecution
        testMutex   sync.RWMutex
}

type TestExecution struct {
        Test      *models.StressTest
        Context   context.Context
        Cancel    context.CancelFunc
        Workers   []*TestWorker
        Metrics   *TestMetrics
        StartTime time.Time
        IsRunning bool
        Results   *models.StressTestResult
}

type TestWorker struct {
        ID      int
        Context context.Context
        Metrics *WorkerMetrics
}

type TestMetrics struct {
        TotalRequests     int64
        SuccessfulReqs    int64
        FailedRequests    int64
        TotalResponseTime time.Duration
        MinResponseTime   time.Duration
        MaxResponseTime   time.Duration
        ErrorCounts       map[string]int64
        StatusCounts      map[int]int64
        mutex             sync.RWMutex
}

type WorkerMetrics struct {
        RequestCount    int64
        SuccessCount    int64
        ErrorCount      int64
        TotalRespTime   time.Duration
        LastRequestTime time.Time
}

func NewStressTestService(stressRepo *repository.StressTestRepository, authService *AuthService) *StressTestService <span class="cov0" title="0">{
        return &amp;StressTestService{
                stressRepo:  stressRepo,
                authService: authService,
                activeTests: make(map[int]*TestExecution),
        }
}</span>

func (s *StressTestService) CreateStressTest(userID int, test *models.StressTest) (*models.StressTest, error) <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">if err := s.validateTestConfiguration(test); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid test configuration: %w", err)
        }</span>

        <span class="cov0" title="0">test.UserID = userID
        test.CreatedAt = time.Now()
        test.Status = models.StressTestStatusPending

        id, err := s.stressRepo.CreateTest(test)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stress test: %w", err)
        }</span>

        <span class="cov0" title="0">test.ID = id
        return test, nil</span>
}

func (s *StressTestService) StartStressTest(testID int, userID int) (*models.StressTestResult, error) <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">test, err := s.stressRepo.GetTest(testID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get test: %w", err)
        }</span>

        <span class="cov0" title="0">if test.Status != models.StressTestStatusPending </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("test is not in pending status")
        }</span>

        <span class="cov0" title="0">s.testMutex.Lock()
        if _, exists := s.activeTests[testID]; exists </span><span class="cov0" title="0">{
                s.testMutex.Unlock()
                return nil, fmt.Errorf("test is already running")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), time.Duration(test.Duration)*time.Second)
        execution := &amp;TestExecution{
                Test:      test,
                Context:   ctx,
                Cancel:    cancel,
                Workers:   make([]*TestWorker, test.ConcurrentUsers),
                Metrics:   s.createTestMetrics(),
                StartTime: time.Now(),
                IsRunning: true,
        }

        s.activeTests[testID] = execution
        s.testMutex.Unlock()

        test.Status = models.StressTestStatusRunning
        test.StartedAt = &amp;execution.StartTime
        s.stressRepo.UpdateTest(test)

        go s.executeStressTest(execution)

        result := &amp;models.StressTestResult{
                TestID:    int64(testID),
                Status:    models.StressTestStatusRunning,
                StartTime: execution.StartTime,
        }

        return result, nil</span>
}

func (s *StressTestService) executeStressTest(execution *TestExecution) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                s.testMutex.Lock()
                delete(s.activeTests, int(execution.Test.ID))
                s.testMutex.Unlock()

                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.handleTestError(execution, fmt.Errorf("test panic: %v", r))
                }</span>
        }()

        <span class="cov0" title="0">var wg sync.WaitGroup

        // Start workers
        for i := 0; i &lt; execution.Test.ConcurrentUsers; i++ </span><span class="cov0" title="0">{
                worker := &amp;TestWorker{
                        ID:      i,
                        Context: execution.Context,
                        Metrics: &amp;WorkerMetrics{},
                }
                execution.Workers[i] = worker

                wg.Add(1)
                go func(w *TestWorker) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        s.runWorker(execution, w)
                }</span>(worker)
        }

        // Wait for completion or timeout
        <span class="cov0" title="0">done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                s.handleTestCompletion(execution)</span>
        case &lt;-execution.Context.Done():<span class="cov0" title="0">
                s.handleTestTimeout(execution)</span>
        }
}

func (s *StressTestService) runWorker(execution *TestExecution, worker *TestWorker) <span class="cov0" title="0">{
        client := &amp;http.Client{
                Timeout: time.Duration(execution.Test.RequestTimeout) * time.Second,
        }

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-worker.Context.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        s.executeRequest(execution, worker, client)

                        if execution.Test.RequestDelay &gt; 0 </span><span class="cov0" title="0">{
                                time.Sleep(time.Duration(execution.Test.RequestDelay) * time.Millisecond)
                        }</span>
                }
        }
}

func (s *StressTestService) executeRequest(execution *TestExecution, worker *TestWorker, client *http.Client) <span class="cov0" title="0">{
        startTime := time.Now()
        atomic.AddInt64(&amp;worker.Metrics.RequestCount, 1)
        atomic.AddInt64(&amp;execution.Metrics.TotalRequests, 1)

        scenario := s.selectRandomScenario(execution.Test.Scenarios)
        if scenario == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">req, err := s.buildRequest(scenario)
        if err != nil </span><span class="cov0" title="0">{
                s.recordError(execution, worker, err, 0)
                return
        }</span>

        <span class="cov0" title="0">resp, err := client.Do(req)
        responseTime := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                s.recordError(execution, worker, err, 0)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        s.recordResponse(execution, worker, resp, responseTime)</span>
}

func (s *StressTestService) selectRandomScenario(scenarios []models.StressTestScenario) *models.StressTestScenario <span class="cov0" title="0">{
        if len(scenarios) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">totalWeight := 0
        for _, scenario := range scenarios </span><span class="cov0" title="0">{
                totalWeight += scenario.Weight
        }</span>

        <span class="cov0" title="0">if totalWeight == 0 </span><span class="cov0" title="0">{
                return &amp;scenarios[rand.Intn(len(scenarios))]
        }</span>

        <span class="cov0" title="0">randomWeight := rand.Intn(totalWeight)
        currentWeight := 0

        for _, scenario := range scenarios </span><span class="cov0" title="0">{
                currentWeight += scenario.Weight
                if randomWeight &lt; currentWeight </span><span class="cov0" title="0">{
                        return &amp;scenario
                }</span>
        }

        <span class="cov0" title="0">return &amp;scenarios[0]</span>
}

func (s *StressTestService) buildRequest(scenario *models.StressTestScenario) (*http.Request, error) <span class="cov0" title="0">{
        var body io.Reader
        if scenario.RequestBody != nil </span><span class="cov0" title="0">{
                body = strings.NewReader(*scenario.RequestBody)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest(scenario.Method, scenario.URL, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for key, value := range scenario.Headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

func (s *StressTestService) recordResponse(execution *TestExecution, worker *TestWorker, resp *http.Response, responseTime time.Duration) <span class="cov0" title="0">{
        execution.Metrics.mutex.Lock()
        defer execution.Metrics.mutex.Unlock()

        execution.Metrics.TotalResponseTime += responseTime

        if execution.Metrics.MinResponseTime == 0 || responseTime &lt; execution.Metrics.MinResponseTime </span><span class="cov0" title="0">{
                execution.Metrics.MinResponseTime = responseTime
        }</span>

        <span class="cov0" title="0">if responseTime &gt; execution.Metrics.MaxResponseTime </span><span class="cov0" title="0">{
                execution.Metrics.MaxResponseTime = responseTime
        }</span>

        <span class="cov0" title="0">if execution.Metrics.StatusCounts == nil </span><span class="cov0" title="0">{
                execution.Metrics.StatusCounts = make(map[int]int64)
        }</span>

        <span class="cov0" title="0">execution.Metrics.StatusCounts[resp.StatusCode]++

        if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 400 </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;execution.Metrics.SuccessfulReqs, 1)
                atomic.AddInt64(&amp;worker.Metrics.SuccessCount, 1)
        }</span> else<span class="cov0" title="0"> {
                atomic.AddInt64(&amp;execution.Metrics.FailedRequests, 1)
                atomic.AddInt64(&amp;worker.Metrics.ErrorCount, 1)
        }</span>

        <span class="cov0" title="0">worker.Metrics.TotalRespTime += responseTime
        worker.Metrics.LastRequestTime = time.Now()</span>
}

func (s *StressTestService) recordError(execution *TestExecution, worker *TestWorker, err error, statusCode int) <span class="cov0" title="0">{
        execution.Metrics.mutex.Lock()
        defer execution.Metrics.mutex.Unlock()

        atomic.AddInt64(&amp;execution.Metrics.FailedRequests, 1)
        atomic.AddInt64(&amp;worker.Metrics.ErrorCount, 1)

        if execution.Metrics.ErrorCounts == nil </span><span class="cov0" title="0">{
                execution.Metrics.ErrorCounts = make(map[string]int64)
        }</span>

        <span class="cov0" title="0">execution.Metrics.ErrorCounts[err.Error()]++

        if statusCode &gt; 0 </span><span class="cov0" title="0">{
                if execution.Metrics.StatusCounts == nil </span><span class="cov0" title="0">{
                        execution.Metrics.StatusCounts = make(map[int]int64)
                }</span>
                <span class="cov0" title="0">execution.Metrics.StatusCounts[statusCode]++</span>
        }
}

func (s *StressTestService) handleTestCompletion(execution *TestExecution) <span class="cov0" title="0">{
        execution.IsRunning = false
        result := s.generateTestResult(execution, models.StressTestStatusCompleted)

        execution.Test.Status = models.StressTestStatusCompleted
        execution.Test.CompletedAt = result.CompletedAt
        s.stressRepo.UpdateTest(execution.Test)

        s.saveTestResult(result)
}</span>

func (s *StressTestService) handleTestTimeout(execution *TestExecution) <span class="cov0" title="0">{
        execution.IsRunning = false
        result := s.generateTestResult(execution, models.StressTestStatusTimeout)

        execution.Test.Status = models.StressTestStatusTimeout
        execution.Test.CompletedAt = result.CompletedAt
        s.stressRepo.UpdateTest(execution.Test)

        s.saveTestResult(result)
}</span>

func (s *StressTestService) handleTestError(execution *TestExecution, testError error) <span class="cov0" title="0">{
        execution.IsRunning = false
        result := s.generateTestResult(execution, models.StressTestStatusFailed)
        errorMsg := testError.Error()
        result.ErrorMessage = &amp;errorMsg

        execution.Test.Status = models.StressTestStatusFailed
        execution.Test.CompletedAt = result.CompletedAt
        s.stressRepo.UpdateTest(execution.Test)

        s.saveTestResult(result)
}</span>

func (s *StressTestService) generateTestResult(execution *TestExecution, status string) *models.StressTestResult <span class="cov0" title="0">{
        completedAt := time.Now()
        duration := completedAt.Sub(execution.StartTime)

        avgResponseTime := time.Duration(0)
        if execution.Metrics.TotalRequests &gt; 0 </span><span class="cov0" title="0">{
                avgResponseTime = execution.Metrics.TotalResponseTime / time.Duration(execution.Metrics.TotalRequests)
        }</span>

        <span class="cov0" title="0">requestsPerSecond := float64(0)
        if duration.Seconds() &gt; 0 </span><span class="cov0" title="0">{
                requestsPerSecond = float64(execution.Metrics.TotalRequests) / duration.Seconds()
        }</span>

        <span class="cov0" title="0">errorRate := float64(0)
        if execution.Metrics.TotalRequests &gt; 0 </span><span class="cov0" title="0">{
                errorRate = float64(execution.Metrics.FailedRequests) / float64(execution.Metrics.TotalRequests) * 100
        }</span>

        <span class="cov0" title="0">return &amp;models.StressTestResult{
                TestID:            execution.Test.ID,
                Status:            status,
                StartTime:         execution.StartTime,
                EndTime:           &amp;completedAt,
                CompletedAt:       &amp;completedAt,
                Duration:          duration,
                TotalRequests:     execution.Metrics.TotalRequests,
                SuccessfulReqs:    execution.Metrics.SuccessfulReqs,
                FailedRequests:    execution.Metrics.FailedRequests,
                RequestsPerSecond: requestsPerSecond,
                AvgResponseTime:   float64(avgResponseTime),
                MinResponseTime:   float64(execution.Metrics.MinResponseTime),
                MaxResponseTime:   float64(execution.Metrics.MaxResponseTime),
                ErrorRate:         errorRate,
                StatusCodeDist:    convertIntMapToStringInt(execution.Metrics.StatusCounts),
                ErrorDistribution: convertInt64MapToInt(execution.Metrics.ErrorCounts),
        }</span>
}

func convertIntMapToStringInt(m map[int]int64) map[string]int <span class="cov0" title="0">{
        result := make(map[string]int)
        for k, v := range m </span><span class="cov0" title="0">{
                result[fmt.Sprintf("%d", k)] = int(v)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func convertInt64MapToInt(m map[string]int64) map[string]int <span class="cov0" title="0">{
        result := make(map[string]int)
        for k, v := range m </span><span class="cov0" title="0">{
                result[k] = int(v)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (s *StressTestService) saveTestResult(result *models.StressTestResult) <span class="cov0" title="0">{
        err := s.stressRepo.SaveResult(result)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to save test result for test %d: %v\n", result.TestID, err)
        }</span>
}

func (s *StressTestService) StopStressTest(testID int, userID int) error <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">s.testMutex.RLock()
        execution, exists := s.activeTests[testID]
        s.testMutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("test is not running")
        }</span>

        <span class="cov0" title="0">execution.Cancel()

        execution.Test.Status = models.StressTestStatusCancelled
        completedAt := time.Now()
        execution.Test.CompletedAt = &amp;completedAt
        s.stressRepo.UpdateTest(execution.Test)

        return nil</span>
}

func (s *StressTestService) GetTestStatus(testID int, userID int) (*models.StressTestStatus, error) <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewAnalytics)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">test, err := s.stressRepo.GetTest(testID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">status := &amp;models.StressTestStatus{
                TestID:    int64(testID),
                Status:    test.Status,
                CreatedAt: test.CreatedAt,
                StartedAt: *test.StartedAt,
        }

        s.testMutex.RLock()
        execution, isRunning := s.activeTests[testID]
        s.testMutex.RUnlock()

        if isRunning </span><span class="cov0" title="0">{
                status.IsRunning = true
                status.ElapsedTime = time.Since(execution.StartTime)
                status.TotalRequests = execution.Metrics.TotalRequests
                status.SuccessfulReqs = execution.Metrics.SuccessfulReqs
                status.FailedRequests = execution.Metrics.FailedRequests

                if execution.Metrics.TotalRequests &gt; 0 </span><span class="cov0" title="0">{
                        status.RequestsPerSecond = float64(execution.Metrics.TotalRequests) / status.ElapsedTime.Seconds()
                        status.ErrorRate = float64(execution.Metrics.FailedRequests) / float64(execution.Metrics.TotalRequests) * 100
                }</span>
        }

        <span class="cov0" title="0">return status, nil</span>
}

func (s *StressTestService) GetTestResults(testID int, userID int) (*models.StressTestResult, error) <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewAnalytics)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">return s.stressRepo.GetResult(testID)</span>
}

func (s *StressTestService) ListUserTests(userID int, limit, offset int) ([]*models.StressTest, error) <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewAnalytics)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">return s.stressRepo.GetUserTests(userID, limit, offset)</span>
}

func (s *StressTestService) DeleteTest(testID int, userID int) error <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">test, err := s.stressRepo.GetTest(testID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if test.Status == models.StressTestStatusRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot delete running test")
        }</span>

        <span class="cov0" title="0">return s.stressRepo.DeleteTest(testID)</span>
}

func (s *StressTestService) GenerateLoadReport(testID int, userID int) (*models.LoadTestReport, error) <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewAnalytics)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">test, err := s.stressRepo.GetTest(testID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result, err := s.stressRepo.GetResult(testID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">report := &amp;models.LoadTestReport{
                Test:            test,
                Result:          result,
                GeneratedAt:     time.Now(),
                Summary:         s.generateReportSummary(test, result),
                Recommendations: s.generateRecommendations(result),
        }

        return report, nil</span>
}

func (s *StressTestService) generateReportSummary(test *models.StressTest, result *models.StressTestResult) string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "Load test completed with %d concurrent users over %d seconds. "+
                        "Total requests: %d, Success rate: %.2f%%, Average response time: %v",
                test.ConcurrentUsers,
                test.Duration,
                result.TotalRequests,
                100-result.ErrorRate,
                result.AvgResponseTime,
        )
}</span>

func (s *StressTestService) generateRecommendations(result *models.StressTestResult) []string <span class="cov0" title="0">{
        var recommendations []string

        if result.ErrorRate &gt; 5 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "High error rate detected. Consider investigating server capacity and error handling.")
        }</span>

        <span class="cov0" title="0">if result.AvgResponseTime &gt; float64(2*time.Second) </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Average response time is high. Consider optimizing database queries and caching.")
        }</span>

        <span class="cov0" title="0">if result.RequestsPerSecond &lt; 10 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Low throughput detected. Consider scaling horizontally or optimizing server performance.")
        }</span>

        <span class="cov0" title="0">if len(recommendations) == 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "System performance appears to be within acceptable limits.")
        }</span>

        <span class="cov0" title="0">return recommendations</span>
}

func (s *StressTestService) validateTestConfiguration(test *models.StressTest) error <span class="cov0" title="0">{
        if test.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("test name is required")
        }</span>

        <span class="cov0" title="0">if test.ConcurrentUsers &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("concurrent users must be greater than 0")
        }</span>

        <span class="cov0" title="0">if test.ConcurrentUsers &gt; 1000 </span><span class="cov0" title="0">{
                return fmt.Errorf("concurrent users cannot exceed 1000")
        }</span>

        <span class="cov0" title="0">if test.Duration &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("duration must be greater than 0")
        }</span>

        <span class="cov0" title="0">if test.Duration &gt; 3600 </span><span class="cov0" title="0">{
                return fmt.Errorf("duration cannot exceed 3600 seconds")
        }</span>

        <span class="cov0" title="0">if len(test.Scenarios) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one test scenario is required")
        }</span>

        <span class="cov0" title="0">for _, scenario := range test.Scenarios </span><span class="cov0" title="0">{
                if scenario.URL == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("scenario URL is required")
                }</span>

                <span class="cov0" title="0">if scenario.Method == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("scenario method is required")
                }</span>

                <span class="cov0" title="0">if scenario.Weight &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("scenario weight cannot be negative")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *StressTestService) createTestMetrics() *TestMetrics <span class="cov0" title="0">{
        return &amp;TestMetrics{
                ErrorCounts:  make(map[string]int64),
                StatusCounts: make(map[int]int64),
        }
}</span>

func (s *StressTestService) GetSystemLoad() (*models.SystemLoadMetrics, error) <span class="cov0" title="0">{
        // This would integrate with system monitoring tools
        // For now, return placeholder data
        return &amp;models.SystemLoadMetrics{
                CPUUsage:    45.2,
                MemoryUsage: 68.5,
                DiskUsage:   32.1,
                NetworkIO:   15.8,
                ActiveTests: len(s.activeTests),
                Timestamp:   time.Now(),
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file103" style="display: none">package services

import (
        "crypto/md5"
        "encoding/hex"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type SyncService struct {
        syncRepo      *repository.SyncRepository
        userRepo      *repository.UserRepository
        authService   *AuthService
        webdavClients map[int]*WebDAVClient
}

func NewSyncService(syncRepo *repository.SyncRepository, userRepo *repository.UserRepository, authService *AuthService) *SyncService <span class="cov0" title="0">{
        return &amp;SyncService{
                syncRepo:      syncRepo,
                userRepo:      userRepo,
                authService:   authService,
                webdavClients: make(map[int]*WebDAVClient),
        }
}</span>

func (s *SyncService) CreateSyncEndpoint(userID int, endpoint *models.SyncEndpoint) (*models.SyncEndpoint, error) <span class="cov0" title="0">{
        endpoint.UserID = userID
        endpoint.CreatedAt = time.Now()
        endpoint.UpdatedAt = time.Now()
        endpoint.Status = models.SyncStatusActive

        if err := s.validateSyncEndpoint(endpoint); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid sync endpoint: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.testConnection(endpoint); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connection test failed: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := s.syncRepo.CreateEndpoint(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sync endpoint: %w", err)
        }</span>

        <span class="cov0" title="0">endpoint.ID = id
        return endpoint, nil</span>
}

func (s *SyncService) GetUserEndpoints(userID int) ([]models.SyncEndpoint, error) <span class="cov0" title="0">{
        return s.syncRepo.GetUserEndpoints(userID)
}</span>

func (s *SyncService) GetEndpoint(endpointID int, userID int) (*models.SyncEndpoint, error) <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to view this endpoint")
                }</span>
        }

        <span class="cov0" title="0">return endpoint, nil</span>
}

func (s *SyncService) UpdateEndpoint(endpointID int, userID int, updates *models.UpdateSyncEndpointRequest) (*models.SyncEndpoint, error) <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionEditShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to update this endpoint")
                }</span>
        }

        <span class="cov0" title="0">if updates.Name != "" </span><span class="cov0" title="0">{
                endpoint.Name = updates.Name
        }</span>

        <span class="cov0" title="0">if updates.URL != "" </span><span class="cov0" title="0">{
                endpoint.URL = updates.URL
        }</span>

        <span class="cov0" title="0">if updates.Username != "" </span><span class="cov0" title="0">{
                endpoint.Username = updates.Username
        }</span>

        <span class="cov0" title="0">if updates.Password != "" </span><span class="cov0" title="0">{
                endpoint.Password = updates.Password
        }</span>

        <span class="cov0" title="0">if updates.SyncDirection != "" </span><span class="cov0" title="0">{
                endpoint.SyncDirection = updates.SyncDirection
        }</span>

        <span class="cov0" title="0">if updates.LocalPath != "" </span><span class="cov0" title="0">{
                endpoint.LocalPath = updates.LocalPath
        }</span>

        <span class="cov0" title="0">if updates.RemotePath != "" </span><span class="cov0" title="0">{
                endpoint.RemotePath = updates.RemotePath
        }</span>

        <span class="cov0" title="0">if updates.SyncSettings != nil </span><span class="cov0" title="0">{
                endpoint.SyncSettings = updates.SyncSettings
        }</span>

        <span class="cov0" title="0">if updates.IsActive != nil </span><span class="cov0" title="0">{
                if *updates.IsActive </span><span class="cov0" title="0">{
                        endpoint.Status = models.SyncStatusActive
                }</span> else<span class="cov0" title="0"> {
                        endpoint.Status = models.SyncStatusInactive
                }</span>
        }

        <span class="cov0" title="0">endpoint.UpdatedAt = time.Now()

        if err := s.validateSyncEndpoint(endpoint); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid endpoint update: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.testConnection(endpoint); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connection test failed: %w", err)
        }</span>

        <span class="cov0" title="0">err = s.syncRepo.UpdateEndpoint(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update endpoint: %w", err)
        }</span>

        <span class="cov0" title="0">return endpoint, nil</span>
}

func (s *SyncService) DeleteEndpoint(endpointID int, userID int) error <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionDeleteShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return fmt.Errorf("unauthorized to delete this endpoint")
                }</span>
        }

        <span class="cov0" title="0">return s.syncRepo.DeleteEndpoint(endpointID)</span>
}

func (s *SyncService) StartSync(endpointID int, userID int) (*models.SyncSession, error) <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionEditShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to sync this endpoint")
                }</span>
        }

        <span class="cov0" title="0">if endpoint.Status != models.SyncStatusActive </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("endpoint is not active")
        }</span>

        <span class="cov0" title="0">session := &amp;models.SyncSession{
                EndpointID: endpointID,
                UserID:     userID,
                Status:     models.SyncSessionStatusRunning,
                StartedAt:  time.Now(),
                SyncType:   models.SyncTypeManual,
        }

        sessionID, err := s.syncRepo.CreateSession(session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sync session: %w", err)
        }</span>

        <span class="cov0" title="0">session.ID = sessionID

        go s.performSync(session, endpoint)

        return session, nil</span>
}

func (s *SyncService) performSync(session *models.SyncSession, endpoint *models.SyncEndpoint) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.handleSyncError(session, fmt.Errorf("sync panic: %v", r))
                }</span>
        }()

        <span class="cov0" title="0">var err error

        switch endpoint.Type </span>{
        case models.SyncTypeWebDAV:<span class="cov0" title="0">
                err = s.performWebDAVSync(session, endpoint)</span>
        case models.SyncTypeCloudStorage:<span class="cov0" title="0">
                err = s.performCloudSync(session, endpoint)</span>
        case models.SyncTypeLocal:<span class="cov0" title="0">
                err = s.performLocalSync(session, endpoint)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unsupported sync type: %s", endpoint.Type)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.handleSyncError(session, err)
                return
        }</span>

        <span class="cov0" title="0">s.handleSyncSuccess(session)</span>
}

func (s *SyncService) performWebDAVSync(session *models.SyncSession, endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        client, err := s.getWebDAVClient(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get WebDAV client: %w", err)
        }</span>

        <span class="cov0" title="0">switch endpoint.SyncDirection </span>{
        case models.SyncDirectionUpload:<span class="cov0" title="0">
                return s.uploadToWebDAV(session, endpoint, client)</span>
        case models.SyncDirectionDownload:<span class="cov0" title="0">
                return s.downloadFromWebDAV(session, endpoint, client)</span>
        case models.SyncDirectionBidirectional:<span class="cov0" title="0">
                if err := s.uploadToWebDAV(session, endpoint, client); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return s.downloadFromWebDAV(session, endpoint, client)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported sync direction: %s", endpoint.SyncDirection)</span>
        }
}

func (s *SyncService) uploadToWebDAV(session *models.SyncSession, endpoint *models.SyncEndpoint, client *WebDAVClient) error <span class="cov0" title="0">{
        localFiles, err := s.scanLocalFiles(endpoint.LocalPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan local files: %w", err)
        }</span>

        <span class="cov0" title="0">session.TotalFiles = len(localFiles)
        s.syncRepo.UpdateSession(session)

        for _, localFile := range localFiles </span><span class="cov0" title="0">{
                relativePath, err := filepath.Rel(endpoint.LocalPath, localFile)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">remotePath := filepath.Join(endpoint.RemotePath, relativePath)
                remotePath = filepath.ToSlash(remotePath)

                if s.shouldSkipFile(localFile, endpoint) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">remoteModTime, err := client.GetModTime(remotePath)
                if err == nil </span><span class="cov0" title="0">{
                        localInfo, err := os.Stat(localFile)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if !localInfo.ModTime().After(remoteModTime) </span><span class="cov0" title="0">{
                                session.SkippedFiles++
                                continue</span>
                        }
                }

                <span class="cov0" title="0">err = client.UploadFile(localFile, remotePath)
                if err != nil </span><span class="cov0" title="0">{
                        session.FailedFiles++
                        s.logSyncError(session, fmt.Sprintf("Failed to upload %s: %v", localFile, err))
                }</span> else<span class="cov0" title="0"> {
                        session.SyncedFiles++
                }</span>

                <span class="cov0" title="0">s.syncRepo.UpdateSession(session)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) downloadFromWebDAV(session *models.SyncSession, endpoint *models.SyncEndpoint, client *WebDAVClient) error <span class="cov0" title="0">{
        remoteFiles, err := client.ListFiles(endpoint.RemotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list remote files: %w", err)
        }</span>

        <span class="cov0" title="0">session.TotalFiles += len(remoteFiles)
        s.syncRepo.UpdateSession(session)

        for _, remoteFile := range remoteFiles </span><span class="cov0" title="0">{
                relativePath, err := filepath.Rel(endpoint.RemotePath, remoteFile.Path)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">localPath := filepath.Join(endpoint.LocalPath, relativePath)

                if s.shouldSkipRemoteFile(remoteFile, endpoint) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">localInfo, err := os.Stat(localPath)
                if err == nil </span><span class="cov0" title="0">{
                        if !remoteFile.ModTime.After(localInfo.ModTime()) </span><span class="cov0" title="0">{
                                session.SkippedFiles++
                                continue</span>
                        }
                }

                <span class="cov0" title="0">err = os.MkdirAll(filepath.Dir(localPath), 0755)
                if err != nil </span><span class="cov0" title="0">{
                        session.FailedFiles++
                        continue</span>
                }

                <span class="cov0" title="0">err = client.DownloadFile(remoteFile.Path, localPath)
                if err != nil </span><span class="cov0" title="0">{
                        session.FailedFiles++
                        s.logSyncError(session, fmt.Sprintf("Failed to download %s: %v", remoteFile.Path, err))
                }</span> else<span class="cov0" title="0"> {
                        session.SyncedFiles++
                }</span>

                <span class="cov0" title="0">s.syncRepo.UpdateSession(session)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) performCloudSync(session *models.SyncSession, endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        // Placeholder for cloud storage sync (Google Drive, Dropbox, OneDrive)
        return fmt.Errorf("cloud storage sync not yet implemented")
}</span>

func (s *SyncService) performLocalSync(session *models.SyncSession, endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        // Placeholder for local folder sync
        return fmt.Errorf("local folder sync not yet implemented")
}</span>

func (s *SyncService) handleSyncSuccess(session *models.SyncSession) <span class="cov0" title="0">{
        session.Status = models.SyncSessionStatusCompleted
        session.CompletedAt = &amp;time.Time{}
        *session.CompletedAt = time.Now()

        if session.StartedAt != (time.Time{}) </span><span class="cov0" title="0">{
                duration := session.CompletedAt.Sub(session.StartedAt)
                session.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">s.syncRepo.UpdateSession(session)
        s.notifyUser(session, "Sync completed successfully")</span>
}

func (s *SyncService) handleSyncError(session *models.SyncSession, syncError error) <span class="cov0" title="0">{
        session.Status = models.SyncSessionStatusFailed
        session.CompletedAt = &amp;time.Time{}
        *session.CompletedAt = time.Now()
        errorMsg := syncError.Error()
        session.ErrorMessage = &amp;errorMsg

        if session.StartedAt != (time.Time{}) </span><span class="cov0" title="0">{
                duration := session.CompletedAt.Sub(session.StartedAt)
                session.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">s.syncRepo.UpdateSession(session)
        s.notifyUser(session, fmt.Sprintf("Sync failed: %s", syncError.Error()))</span>
}

func (s *SyncService) logSyncError(session *models.SyncSession, message string) <span class="cov0" title="0">{
        // In a full implementation, this would log to a sync error log
        fmt.Printf("Sync error for session %d: %s\n", session.ID, message)
}</span>

func (s *SyncService) notifyUser(session *models.SyncSession, message string) <span class="cov0" title="0">{
        // In a full implementation, this would send notifications
        fmt.Printf("Notification for user %d: %s (Session %d)\n", session.UserID, message, session.ID)
}</span>

func (s *SyncService) GetUserSessions(userID int, limit, offset int) ([]models.SyncSession, error) <span class="cov0" title="0">{
        return s.syncRepo.GetUserSessions(userID, limit, offset)
}</span>

func (s *SyncService) GetSession(sessionID int, userID int) (*models.SyncSession, error) <span class="cov0" title="0">{
        session, err := s.syncRepo.GetSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if session.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to view this session")
                }</span>
        }

        <span class="cov0" title="0">return session, nil</span>
}

func (s *SyncService) ScheduleSync(endpointID int, userID int, schedule *models.SyncSchedule) (*models.SyncSchedule, error) <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionEditShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to schedule sync for this endpoint")
                }</span>
        }

        <span class="cov0" title="0">schedule.EndpointID = endpointID
        schedule.UserID = userID
        schedule.CreatedAt = time.Now()
        schedule.IsActive = true

        id, err := s.syncRepo.CreateSchedule(schedule)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sync schedule: %w", err)
        }</span>

        <span class="cov0" title="0">schedule.ID = id
        return schedule, nil</span>
}

func (s *SyncService) GetSyncStatistics(userID *int, startDate, endDate time.Time) (*models.SyncStatistics, error) <span class="cov0" title="0">{
        return s.syncRepo.GetStatistics(userID, startDate, endDate)
}</span>

func (s *SyncService) ProcessScheduledSyncs() error <span class="cov0" title="0">{
        schedules, err := s.syncRepo.GetActiveSchedules()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, schedule := range schedules </span><span class="cov0" title="0">{
                if s.shouldRunSchedule(&amp;schedule) </span><span class="cov0" title="0">{
                        _, err := s.StartSync(schedule.EndpointID, schedule.UserID)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to start scheduled sync for endpoint %d: %v\n", schedule.EndpointID, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) shouldRunSchedule(schedule *models.SyncSchedule) bool <span class="cov0" title="0">{
        now := time.Now()

        switch schedule.Frequency </span>{
        case models.SyncFrequencyHourly:<span class="cov0" title="0">
                return schedule.LastRun == nil || schedule.LastRun.Add(time.Hour).Before(now)</span>
        case models.SyncFrequencyDaily:<span class="cov0" title="0">
                return schedule.LastRun == nil || schedule.LastRun.Add(24*time.Hour).Before(now)</span>
        case models.SyncFrequencyWeekly:<span class="cov0" title="0">
                return schedule.LastRun == nil || schedule.LastRun.Add(7*24*time.Hour).Before(now)</span>
        case models.SyncFrequencyMonthly:<span class="cov0" title="0">
                return schedule.LastRun == nil || schedule.LastRun.AddDate(0, 1, 0).Before(now)</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (s *SyncService) validateSyncEndpoint(endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        if endpoint.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("name is required")
        }</span>

        <span class="cov0" title="0">if endpoint.URL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("URL is required")
        }</span>

        <span class="cov0" title="0">if endpoint.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("type is required")
        }</span>

        <span class="cov0" title="0">if endpoint.SyncDirection == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("sync direction is required")
        }</span>

        <span class="cov0" title="0">if endpoint.LocalPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("local path is required")
        }</span>

        <span class="cov0" title="0">validTypes := []string{models.SyncTypeWebDAV, models.SyncTypeCloudStorage, models.SyncTypeLocal}
        if !s.isValidType(endpoint.Type, validTypes) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid sync type: %s", endpoint.Type)
        }</span>

        <span class="cov0" title="0">validDirections := []string{models.SyncDirectionUpload, models.SyncDirectionDownload, models.SyncDirectionBidirectional}
        if !s.isValidType(endpoint.SyncDirection, validDirections) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid sync direction: %s", endpoint.SyncDirection)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) isValidType(value string, validValues []string) bool <span class="cov0" title="0">{
        for _, valid := range validValues </span><span class="cov0" title="0">{
                if value == valid </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (s *SyncService) testConnection(endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        switch endpoint.Type </span>{
        case models.SyncTypeWebDAV:<span class="cov0" title="0">
                client, err := s.getWebDAVClient(endpoint)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return client.TestConnection()</span>
        default:<span class="cov0" title="0">
                return nil</span> // Skip test for other types for now
        }
}

func (s *SyncService) getWebDAVClient(endpoint *models.SyncEndpoint) (*WebDAVClient, error) <span class="cov0" title="0">{
        if client, exists := s.webdavClients[endpoint.ID]; exists </span><span class="cov0" title="0">{
                return client, nil
        }</span>

        <span class="cov0" title="0">client := NewWebDAVClient(endpoint.URL, endpoint.Username, endpoint.Password)
        s.webdavClients[endpoint.ID] = client

        return client, nil</span>
}

func (s *SyncService) scanLocalFiles(path string) ([]string, error) <span class="cov0" title="0">{
        var files []string

        err := filepath.Walk(path, func(filePath string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        files = append(files, filePath)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return files, err</span>
}

func (s *SyncService) shouldSkipFile(filePath string, endpoint *models.SyncEndpoint) bool <span class="cov0" title="0">{
        fileName := filepath.Base(filePath)

        // Skip hidden files
        if strings.HasPrefix(fileName, ".") </span><span class="cov0" title="0">{
                return true
        }</span>

        // Skip temporary files
        <span class="cov0" title="0">if strings.HasSuffix(fileName, ".tmp") || strings.HasSuffix(fileName, ".temp") </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check file size limits if configured
        <span class="cov0" title="0">if endpoint.SyncSettings != nil </span>{<span class="cov0" title="0">
                // This would parse JSON settings and check file size limits
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (s *SyncService) shouldSkipRemoteFile(file *WebDAVFile, endpoint *models.SyncEndpoint) bool <span class="cov0" title="0">{
        fileName := filepath.Base(file.Path)

        // Skip hidden files
        if strings.HasPrefix(fileName, ".") </span><span class="cov0" title="0">{
                return true
        }</span>

        // Skip temporary files
        <span class="cov0" title="0">if strings.HasSuffix(fileName, ".tmp") || strings.HasSuffix(fileName, ".temp") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (s *SyncService) calculateChecksum(filePath string) (string, error) <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        hash := md5.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return hex.EncodeToString(hash.Sum(nil)), nil</span>
}

func (s *SyncService) CleanupOldSessions(olderThan time.Time) error <span class="cov0" title="0">{
        return s.syncRepo.CleanupSessions(olderThan)
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package services

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/studio-b12/gowebdav"
)

type WebDAVClient struct {
        client   *gowebdav.Client
        baseURL  string
        username string
        password string
}

type WebDAVFile struct {
        Path    string
        Size    int64
        ModTime time.Time
        IsDir   bool
}

func NewWebDAVClient(url, username, password string) *WebDAVClient <span class="cov0" title="0">{
        client := gowebdav.NewClient(url, username, password)

        return &amp;WebDAVClient{
                client:   client,
                baseURL:  url,
                username: username,
                password: password,
        }
}</span>

func (c *WebDAVClient) TestConnection() error <span class="cov0" title="0">{
        _, err := c.client.ReadDir("/")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV connection test failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) ListFiles(remotePath string) ([]*WebDAVFile, error) <span class="cov0" title="0">{
        files, err := c.client.ReadDir(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list files: %w", err)
        }</span>

        <span class="cov0" title="0">var webdavFiles []*WebDAVFile
        for _, file := range files </span><span class="cov0" title="0">{
                webdavFile := &amp;WebDAVFile{
                        Path:    filepath.Join(remotePath, file.Name()),
                        Size:    file.Size(),
                        ModTime: file.ModTime(),
                        IsDir:   file.IsDir(),
                }
                webdavFiles = append(webdavFiles, webdavFile)

                // Recursively list subdirectories if needed
                if file.IsDir() </span><span class="cov0" title="0">{
                        subFiles, err := c.ListFiles(webdavFile.Path)
                        if err == nil </span><span class="cov0" title="0">{
                                webdavFiles = append(webdavFiles, subFiles...)
                        }</span>
                }
        }

        <span class="cov0" title="0">return webdavFiles, nil</span>
}

func (c *WebDAVClient) UploadFile(localPath, remotePath string) error <span class="cov0" title="0">{
        // Ensure remote directory exists
        remoteDir := filepath.Dir(remotePath)
        if err := c.client.MkdirAll(remoteDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create remote directory: %w", err)
        }</span>

        // Open local file
        <span class="cov0" title="0">localFile, err := os.Open(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open local file: %w", err)
        }</span>
        <span class="cov0" title="0">defer localFile.Close()

        // Upload to WebDAV
        err = c.client.WriteStream(remotePath, localFile, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) DownloadFile(remotePath, localPath string) error <span class="cov0" title="0">{
        // Create local directory if it doesn't exist
        localDir := filepath.Dir(localPath)
        if err := os.MkdirAll(localDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local directory: %w", err)
        }</span>

        // Open remote file
        <span class="cov0" title="0">reader, err := c.client.ReadStream(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open remote file: %w", err)
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        // Create local file
        localFile, err := os.Create(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local file: %w", err)
        }</span>
        <span class="cov0" title="0">defer localFile.Close()

        // Copy data
        _, err = io.Copy(localFile, reader)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) GetModTime(remotePath string) (time.Time, error) <span class="cov0" title="0">{
        info, err := c.client.Stat(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">return info.ModTime(), nil</span>
}

func (c *WebDAVClient) DeleteFile(remotePath string) error <span class="cov0" title="0">{
        err := c.client.Remove(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) MoveFile(sourcePath, destPath string) error <span class="cov0" title="0">{
        err := c.client.Rename(sourcePath, destPath, false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to move file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) CopyFile(sourcePath, destPath string) error <span class="cov0" title="0">{
        err := c.client.Copy(sourcePath, destPath, false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) CreateDirectory(remotePath string) error <span class="cov0" title="0">{
        err := c.client.Mkdir(remotePath, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) FileExists(remotePath string) bool <span class="cov0" title="0">{
        _, err := c.client.Stat(remotePath)
        return err == nil
}</span>

func (c *WebDAVClient) GetFileSize(remotePath string) (int64, error) <span class="cov0" title="0">{
        info, err := c.client.Stat(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">return info.Size(), nil</span>
}

func (c *WebDAVClient) GetQuota() (*WebDAVQuota, error) <span class="cov0" title="0">{
        // This would require parsing PROPFIND response for quota information
        // For now, return a placeholder
        return &amp;WebDAVQuota{
                Used:      0,
                Available: -1, // Unlimited
        }, nil
}</span>

type WebDAVQuota struct {
        Used      int64 `json:"used"`
        Available int64 `json:"available"` // -1 for unlimited
}

// Batch operations for efficiency

func (c *WebDAVClient) UploadBatch(files []FileTransfer) (*BatchResult, error) <span class="cov0" title="0">{
        result := &amp;BatchResult{
                Total:     len(files),
                Succeeded: 0,
                Failed:    0,
                Errors:    make([]string, 0),
        }

        for _, file := range files </span><span class="cov0" title="0">{
                err := c.UploadFile(file.LocalPath, file.RemotePath)
                if err != nil </span><span class="cov0" title="0">{
                        result.Failed++
                        result.Errors = append(result.Errors, fmt.Sprintf("%s: %v", file.LocalPath, err))
                }</span> else<span class="cov0" title="0"> {
                        result.Succeeded++
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func (c *WebDAVClient) DownloadBatch(files []FileTransfer) (*BatchResult, error) <span class="cov0" title="0">{
        result := &amp;BatchResult{
                Total:     len(files),
                Succeeded: 0,
                Failed:    0,
                Errors:    make([]string, 0),
        }

        for _, file := range files </span><span class="cov0" title="0">{
                err := c.DownloadFile(file.RemotePath, file.LocalPath)
                if err != nil </span><span class="cov0" title="0">{
                        result.Failed++
                        result.Errors = append(result.Errors, fmt.Sprintf("%s: %v", file.RemotePath, err))
                }</span> else<span class="cov0" title="0"> {
                        result.Succeeded++
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

type FileTransfer struct {
        LocalPath  string
        RemotePath string
}

type BatchResult struct {
        Total     int      `json:"total"`
        Succeeded int      `json:"succeeded"`
        Failed    int      `json:"failed"`
        Errors    []string `json:"errors"`
}

// Sync-specific methods

func (c *WebDAVClient) SyncDirectory(localPath, remotePath string, direction string) (*SyncResult, error) <span class="cov0" title="0">{
        result := &amp;SyncResult{
                UploadedFiles:   0,
                DownloadedFiles: 0,
                SkippedFiles:    0,
                FailedFiles:     0,
                Errors:          make([]string, 0),
        }

        switch direction </span>{
        case "upload":<span class="cov0" title="0">
                return c.syncUpload(localPath, remotePath, result)</span>
        case "download":<span class="cov0" title="0">
                return c.syncDownload(localPath, remotePath, result)</span>
        case "bidirectional":<span class="cov0" title="0">
                // First upload, then download
                result, err := c.syncUpload(localPath, remotePath, result)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">return c.syncDownload(localPath, remotePath, result)</span>
        default:<span class="cov0" title="0">
                return result, fmt.Errorf("invalid sync direction: %s", direction)</span>
        }
}

func (c *WebDAVClient) syncUpload(localPath, remotePath string, result *SyncResult) (*SyncResult, error) <span class="cov0" title="0">{
        err := filepath.Walk(localPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Skip hidden files and temporary files
                <span class="cov0" title="0">if strings.HasPrefix(info.Name(), ".") || strings.HasSuffix(info.Name(), ".tmp") </span><span class="cov0" title="0">{
                        result.SkippedFiles++
                        return nil
                }</span>

                <span class="cov0" title="0">relPath, err := filepath.Rel(localPath, path)
                if err != nil </span><span class="cov0" title="0">{
                        result.FailedFiles++
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to get relative path for %s: %v", path, err))
                        return nil
                }</span>

                <span class="cov0" title="0">remoteFilePath := filepath.Join(remotePath, relPath)
                remoteFilePath = filepath.ToSlash(remoteFilePath) // Convert to forward slashes for WebDAV

                // Check if remote file exists and compare modification times
                remoteModTime, err := c.GetModTime(remoteFilePath)
                if err == nil </span><span class="cov0" title="0">{
                        // Remote file exists, check if local is newer
                        if !info.ModTime().After(remoteModTime) </span><span class="cov0" title="0">{
                                result.SkippedFiles++
                                return nil
                        }</span>
                }

                // Upload the file
                <span class="cov0" title="0">err = c.UploadFile(path, remoteFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        result.FailedFiles++
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to upload %s: %v", path, err))
                }</span> else<span class="cov0" title="0"> {
                        result.UploadedFiles++
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return result, err</span>
}

func (c *WebDAVClient) syncDownload(localPath, remotePath string, result *SyncResult) (*SyncResult, error) <span class="cov0" title="0">{
        remoteFiles, err := c.ListFiles(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return result, fmt.Errorf("failed to list remote files: %w", err)
        }</span>

        <span class="cov0" title="0">for _, remoteFile := range remoteFiles </span><span class="cov0" title="0">{
                if remoteFile.IsDir </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip hidden files and temporary files
                <span class="cov0" title="0">fileName := filepath.Base(remoteFile.Path)
                if strings.HasPrefix(fileName, ".") || strings.HasSuffix(fileName, ".tmp") </span><span class="cov0" title="0">{
                        result.SkippedFiles++
                        continue</span>
                }

                <span class="cov0" title="0">relPath, err := filepath.Rel(remotePath, remoteFile.Path)
                if err != nil </span><span class="cov0" title="0">{
                        result.FailedFiles++
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to get relative path for %s: %v", remoteFile.Path, err))
                        continue</span>
                }

                <span class="cov0" title="0">localFilePath := filepath.Join(localPath, relPath)

                // Check if local file exists and compare modification times
                localInfo, err := os.Stat(localFilePath)
                if err == nil </span><span class="cov0" title="0">{
                        // Local file exists, check if remote is newer
                        if !remoteFile.ModTime.After(localInfo.ModTime()) </span><span class="cov0" title="0">{
                                result.SkippedFiles++
                                continue</span>
                        }
                }

                // Download the file
                <span class="cov0" title="0">err = c.DownloadFile(remoteFile.Path, localFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        result.FailedFiles++
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to download %s: %v", remoteFile.Path, err))
                }</span> else<span class="cov0" title="0"> {
                        result.DownloadedFiles++
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

type SyncResult struct {
        UploadedFiles   int      `json:"uploaded_files"`
        DownloadedFiles int      `json:"downloaded_files"`
        SkippedFiles    int      `json:"skipped_files"`
        FailedFiles     int      `json:"failed_files"`
        Errors          []string `json:"errors"`
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package smb

import (
        "fmt"
        "io"
        "net"

        "github.com/hirochachacha/go-smb2"
)

// SmbClient represents an SMB client connection
type SmbClient struct {
        conn    net.Conn
        session *smb2.Session
        share   *smb2.Share
        config  *SmbConfig
}

// SmbConfig contains SMB connection configuration
type SmbConfig struct {
        Host     string
        Port     int
        Share    string
        Username string
        Password string
        Domain   string
}

// NewSmbClient creates a new SMB client
func NewSmbClient(config *SmbConfig) (*SmbClient, error) <span class="cov0" title="0">{
        // Establish TCP connection
        addr := fmt.Sprintf("%s:%d", config.Host, config.Port)
        conn, err := net.Dial("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to SMB server: %w", err)
        }</span>

        // Create SMB session
        <span class="cov0" title="0">d := &amp;smb2.Dialer{
                Initiator: &amp;smb2.NTLMInitiator{
                        User:     config.Username,
                        Password: config.Password,
                        Domain:   config.Domain,
                },
        }

        session, err := d.Dial(conn)
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to create SMB session: %w", err)
        }</span>

        // Mount share
        <span class="cov0" title="0">share, err := session.Mount(config.Share)
        if err != nil </span><span class="cov0" title="0">{
                session.Logoff()
                conn.Close()
                return nil, fmt.Errorf("failed to mount SMB share: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SmbClient{
                conn:    conn,
                session: session,
                share:   share,
                config:  config,
        }, nil</span>
}

// TestConnection tests the SMB connection
func (c *SmbClient) TestConnection() error <span class="cov0" title="0">{
        // Try to list the root directory
        _, err := c.share.ReadDir(".")
        return err
}</span>

// ReadFile reads a file from the SMB share
func (c *SmbClient) ReadFile(path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        file, err := c.share.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open SMB file %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return file, nil</span>
}

// WriteFile writes a file to the SMB share
func (c *SmbClient) WriteFile(path string, data io.Reader) error <span class="cov0" title="0">{
        file, err := c.share.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create SMB file %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        _, err = io.Copy(file, data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write SMB file %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFileInfo gets information about a file
func (c *SmbClient) GetFileInfo(path string) (*FileInfo, error) <span class="cov0" title="0">{
        stat, err := c.share.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat SMB file %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return &amp;FileInfo{
                Name:    stat.Name(),
                Size:    stat.Size(),
                ModTime: stat.ModTime(),
                IsDir:   stat.IsDir(),
                Mode:    stat.Mode(),
        }, nil</span>
}

// ListDirectory lists files in a directory
func (c *SmbClient) ListDirectory(path string) ([]*FileInfo, error) <span class="cov0" title="0">{
        entries, err := c.share.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list SMB directory %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">var files []*FileInfo
        for _, entry := range entries </span><span class="cov0" title="0">{
                files = append(files, &amp;FileInfo{
                        Name:    entry.Name(),
                        Size:    entry.Size(),
                        ModTime: entry.ModTime(),
                        IsDir:   entry.IsDir(),
                        Mode:    entry.Mode(),
                })
        }</span>

        <span class="cov0" title="0">return files, nil</span>
}

// FileExists checks if a file exists
func (c *SmbClient) FileExists(path string) (bool, error) <span class="cov0" title="0">{
        _, err := c.share.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                if isNotExistError(err) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check SMB file existence %s: %w", path, err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// CreateDirectory creates a directory
func (c *SmbClient) CreateDirectory(path string) error <span class="cov0" title="0">{
        err := c.share.Mkdir(path, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create SMB directory %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteFile deletes a file
func (c *SmbClient) DeleteFile(path string) error <span class="cov0" title="0">{
        err := c.share.Remove(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete SMB file %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CopyFile copies a file within the SMB share
func (c *SmbClient) CopyFile(srcPath, dstPath string) error <span class="cov0" title="0">{
        // Read source file
        srcFile, err := c.share.Open(srcPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file %s: %w", srcPath, err)
        }</span>
        <span class="cov0" title="0">defer srcFile.Close()

        // Create destination file
        dstFile, err := c.share.Create(dstPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination file %s: %w", dstPath, err)
        }</span>
        <span class="cov0" title="0">defer dstFile.Close()

        // Copy data
        _, err = io.Copy(dstFile, srcFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file from %s to %s: %w", srcPath, dstPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Close closes the SMB connection
func (c *SmbClient) Close() error <span class="cov0" title="0">{
        var errs []error

        if c.share != nil </span><span class="cov0" title="0">{
                if err := c.share.Umount(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to unmount share: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if c.session != nil </span><span class="cov0" title="0">{
                if err := c.session.Logoff(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to logoff session: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if c.conn != nil </span><span class="cov0" title="0">{
                if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to close connection: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors closing SMB client: %v", errs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetConfig returns the SMB configuration
func (c *SmbClient) GetConfig() *SmbConfig <span class="cov0" title="0">{
        return c.config
}</span>

// Helper function to check if error is "file not found"
func isNotExistError(err error) bool <span class="cov0" title="0">{
        // This is a simplified check - in practice you might want to check
        // for specific SMB error codes
        return err != nil &amp;&amp; (err.Error() == "file does not exist" || err.Error() == "no such file or directory")
}</span>
</pre>
		
		<pre class="file" id="file106" style="display: none">package smb

import (
        "os"
        "time"
)

// FileInfo represents file information from SMB
type FileInfo struct {
        Name    string
        Size    int64
        ModTime time.Time
        IsDir   bool
        Mode    os.FileMode
}

// CopyOperation represents a file copy operation
type CopyOperation struct {
        SourcePath        string
        DestinationPath   string
        OverwriteExisting bool
}

// CopyResult represents the result of a copy operation
type CopyResult struct {
        Success     bool
        BytesCopied int64
        Error       error
        TimeTaken   time.Duration
}

// DirectoryTreeInfo represents directory tree information
type DirectoryTreeInfo struct {
        Path       string
        TotalFiles int
        TotalDirs  int
        TotalSize  int64
        MaxDepth   int
        Files      []*FileInfo
        Subdirs    []*DirectoryTreeInfo
}

// SmbConnectionPool manages multiple SMB connections
type SmbConnectionPool struct {
        connections    map[string]*SmbClient
        maxConnections int
}

// NewSmbConnectionPool creates a new connection pool
func NewSmbConnectionPool(maxConnections int) *SmbConnectionPool <span class="cov0" title="0">{
        return &amp;SmbConnectionPool{
                connections:    make(map[string]*SmbClient),
                maxConnections: maxConnections,
        }
}</span>

// GetConnection gets or creates an SMB connection
func (p *SmbConnectionPool) GetConnection(key string, config *SmbConfig) (*SmbClient, error) <span class="cov0" title="0">{
        if client, exists := p.connections[key]; exists </span><span class="cov0" title="0">{
                // Test the existing connection
                if err := client.TestConnection(); err == nil </span><span class="cov0" title="0">{
                        return client, nil
                }</span>
                // Connection is stale, remove it
                <span class="cov0" title="0">client.Close()
                delete(p.connections, key)</span>
        }

        // Create new connection
        <span class="cov0" title="0">client, err := NewSmbClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in pool if there's space
        <span class="cov0" title="0">if len(p.connections) &lt; p.maxConnections </span><span class="cov0" title="0">{
                p.connections[key] = client
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// CloseAll closes all connections in the pool
func (p *SmbConnectionPool) CloseAll() <span class="cov0" title="0">{
        for key, client := range p.connections </span><span class="cov0" title="0">{
                client.Close()
                delete(p.connections, key)
        }</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package integration

import (
        "catalogizer/filesystem"
        "catalogizer/internal/services"
        "context"
        "database/sql"
        "fmt"
        "os"
        "testing"
        "time"

        _ "github.com/mattn/go-sqlite3"
        "go.uber.org/zap"
)

// ProtocolTestSuite defines the interface for protocol-specific tests
type ProtocolTestSuite interface {
        SetupProtocol(t *testing.T) (filesystem.FileSystemClient, func())
        GetProtocolName() string
        GetTestConfig() map[string]interface{}
        SupportsRealTimeEvents() bool
}

// TestProtocolRenameDetection runs rename detection tests for all supported protocols
func TestProtocolRenameDetection(t *testing.T) <span class="cov0" title="0">{
        if testing.Short() </span><span class="cov0" title="0">{
                t.Skip("Skipping protocol integration tests in short mode")
        }</span>

        // Test each protocol
        <span class="cov0" title="0">protocolSuites := []ProtocolTestSuite{
                &amp;LocalProtocolTestSuite{},
                &amp;SMBProtocolTestSuite{},
                &amp;FTPProtocolTestSuite{},
                &amp;NFSProtocolTestSuite{},
                &amp;WebDAVProtocolTestSuite{},
        }

        for _, suite := range protocolSuites </span><span class="cov0" title="0">{
                t.Run(suite.GetProtocolName(), func(t *testing.T) </span><span class="cov0" title="0">{
                        testProtocolRenameDetection(t, suite)
                }</span>)
        }
}

func testProtocolRenameDetection(t *testing.T, suite ProtocolTestSuite) <span class="cov0" title="0">{
        logger := zap.NewNop()
        ctx := context.Background()

        // Setup database
        db := setupProtocolTestDB(t)
        defer db.Close()

        // Setup protocol
        client, cleanup := suite.SetupProtocol(t)
        defer cleanup()

        // Setup universal rename tracker
        renameTracker := services.NewUniversalRenameTracker(db, logger)
        if err := renameTracker.Start(); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to start rename tracker: %v", err)
        }</span>
        <span class="cov0" title="0">defer renameTracker.Stop()

        // Test file rename detection
        t.Run("file_rename", func(t *testing.T) </span><span class="cov0" title="0">{
                testFileRename(t, client, renameTracker, suite, ctx)
        }</span>)

        // Test directory rename detection
        <span class="cov0" title="0">t.Run("directory_rename", func(t *testing.T) </span><span class="cov0" title="0">{
                testDirectoryRename(t, client, renameTracker, suite, ctx)
        }</span>)

        // Test batch rename operations
        <span class="cov0" title="0">t.Run("batch_rename", func(t *testing.T) </span><span class="cov0" title="0">{
                testBatchRename(t, client, renameTracker, suite, ctx)
        }</span>)

        // Test rename detection timing
        <span class="cov0" title="0">t.Run("timing_windows", func(t *testing.T) </span><span class="cov0" title="0">{
                testRenameTimingWindows(t, client, renameTracker, suite, ctx)
        }</span>)

        // Test protocol-specific capabilities
        <span class="cov0" title="0">t.Run("protocol_capabilities", func(t *testing.T) </span><span class="cov0" title="0">{
                testProtocolCapabilities(t, suite, logger)
        }</span>)
}

func testFileRename(t *testing.T, client filesystem.FileSystemClient, renameTracker *services.UniversalRenameTracker, suite ProtocolTestSuite, ctx context.Context) <span class="cov0" title="0">{
        protocol := suite.GetProtocolName()

        // Create test file
        testContent := "Test file content for rename detection"
        originalPath := "/test_file_rename.txt"
        renamedPath := "/renamed_test_file.txt"

        // Create the file through the client
        if err := createTestFile(ctx, client, originalPath, testContent); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test file: %v", err)
        }</span>

        // Simulate tracking the file creation
        <span class="cov0" title="0">fileID := int64(100)
        size := int64(len(testContent))
        fileHash := "testhash123"
        protocolData := suite.GetTestConfig()

        // Track the file deletion (simulating a move)
        renameTracker.TrackDelete(ctx, fileID, originalPath, "test_storage", protocol, size, &amp;fileHash, false, protocolData)

        // Simulate the file creation at new location
        pendingMove, isMove := renameTracker.DetectCreate(ctx, renamedPath, "test_storage", protocol, size, &amp;fileHash, false, protocolData)

        if !isMove </span><span class="cov0" title="0">{
                t.Error("Expected file rename to be detected")
                return
        }</span>

        <span class="cov0" title="0">if pendingMove.Path != originalPath </span><span class="cov0" title="0">{
                t.Errorf("Expected original path %s, got %s", originalPath, pendingMove.Path)
        }</span>

        <span class="cov0" title="0">if pendingMove.Protocol != protocol </span><span class="cov0" title="0">{
                t.Errorf("Expected protocol %s, got %s", protocol, pendingMove.Protocol)
        }</span>

        // Process the move
        <span class="cov0" title="0">if err := renameTracker.ProcessMove(ctx, client, pendingMove, renamedPath); err != nil </span><span class="cov0" title="0">{
                t.Errorf("Failed to process file move: %v", err)
        }</span>

        // Verify the move was recorded
        <span class="cov0" title="0">stats := renameTracker.GetStatistics()
        if totalRenames, ok := stats["total_renames"].(int); !ok || totalRenames == 0 </span><span class="cov0" title="0">{
                t.Error("Expected rename to be recorded in statistics")
        }</span>

        // Clean up
        <span class="cov0" title="0">client.DeleteFile(ctx, renamedPath)</span>
}

func testDirectoryRename(t *testing.T, client filesystem.FileSystemClient, renameTracker *services.UniversalRenameTracker, suite ProtocolTestSuite, ctx context.Context) <span class="cov0" title="0">{
        protocol := suite.GetProtocolName()

        // Create test directory with files
        originalDir := "/test_dir_rename"
        renamedDir := "/renamed_test_dir"

        // Create directory and files
        if err := client.CreateDirectory(ctx, originalDir); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test directory: %v", err)
        }</span>

        <span class="cov0" title="0">testFile := originalDir + "/nested_file.txt"
        if err := createTestFile(ctx, client, testFile, "Nested file content"); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create nested file: %v", err)
        }</span>

        // Track directory deletion
        <span class="cov0" title="0">dirID := int64(200)
        protocolData := suite.GetTestConfig()

        renameTracker.TrackDelete(ctx, dirID, originalDir, "test_storage", protocol, 0, nil, true, protocolData)

        // Detect directory creation at new location
        pendingMove, isMove := renameTracker.DetectCreate(ctx, renamedDir, "test_storage", protocol, 0, nil, true, protocolData)

        if !isMove </span><span class="cov0" title="0">{
                t.Error("Expected directory rename to be detected")
                return
        }</span>

        <span class="cov0" title="0">if !pendingMove.IsDirectory </span><span class="cov0" title="0">{
                t.Error("Expected pending move to be marked as directory")
        }</span>

        // Process the move
        <span class="cov0" title="0">if err := renameTracker.ProcessMove(ctx, client, pendingMove, renamedDir); err != nil </span><span class="cov0" title="0">{
                t.Errorf("Failed to process directory move: %v", err)
        }</span>

        // Clean up
        <span class="cov0" title="0">client.DeleteFile(ctx, renamedDir+"/nested_file.txt")
        client.DeleteDirectory(ctx, renamedDir)</span>
}

func testBatchRename(t *testing.T, client filesystem.FileSystemClient, renameTracker *services.UniversalRenameTracker, suite ProtocolTestSuite, ctx context.Context) <span class="cov0" title="0">{
        protocol := suite.GetProtocolName()

        // Create multiple files for batch rename
        numFiles := 5
        fileIDs := make([]int64, numFiles)
        originalPaths := make([]string, numFiles)
        renamedPaths := make([]string, numFiles)

        for i := 0; i &lt; numFiles; i++ </span><span class="cov0" title="0">{
                fileIDs[i] = int64(300 + i)
                originalPaths[i] = fmt.Sprintf("/batch_file_%d.txt", i)
                renamedPaths[i] = fmt.Sprintf("/renamed_batch_%d.txt", i)

                // Create file
                content := fmt.Sprintf("Batch file %d content", i)
                if err := createTestFile(ctx, client, originalPaths[i], content); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to create batch file %d: %v", i, err)
                }</span>

                // Track deletion
                <span class="cov0" title="0">size := int64(len(content))
                hash := fmt.Sprintf("batchhash%d", i)
                renameTracker.TrackDelete(ctx, fileIDs[i], originalPaths[i], "test_storage", protocol, size, &amp;hash, false, suite.GetTestConfig())</span>
        }

        // Small delay to simulate batch operations
        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)

        // Detect all moves
        detectedMoves := 0
        for i := 0; i &lt; numFiles; i++ </span><span class="cov0" title="0">{
                content := fmt.Sprintf("Batch file %d content", i)
                size := int64(len(content))
                hash := fmt.Sprintf("batchhash%d", i)

                if pendingMove, isMove := renameTracker.DetectCreate(ctx, renamedPaths[i], "test_storage", protocol, size, &amp;hash, false, suite.GetTestConfig()); isMove </span><span class="cov0" title="0">{
                        detectedMoves++
                        if err := renameTracker.ProcessMove(ctx, client, pendingMove, renamedPaths[i]); err != nil </span><span class="cov0" title="0">{
                                t.Errorf("Failed to process batch move %d: %v", i, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">if detectedMoves != numFiles </span><span class="cov0" title="0">{
                t.Errorf("Expected %d batch moves to be detected, got %d", numFiles, detectedMoves)
        }</span>

        // Clean up
        <span class="cov0" title="0">for i := 0; i &lt; numFiles; i++ </span><span class="cov0" title="0">{
                client.DeleteFile(ctx, renamedPaths[i])
        }</span>
}

func testRenameTimingWindows(t *testing.T, client filesystem.FileSystemClient, renameTracker *services.UniversalRenameTracker, suite ProtocolTestSuite, ctx context.Context) <span class="cov0" title="0">{
        protocol := suite.GetProtocolName()

        // Get protocol capabilities
        capabilities, err := services.GetProtocolCapabilities(protocol, zap.NewNop())
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to get protocol capabilities: %v", err)
        }</span>

        // Test move within window
        <span class="cov0" title="0">t.Run("within_window", func(t *testing.T) </span><span class="cov0" title="0">{
                originalPath := "/timing_test_1.txt"
                renamedPath := "/timing_renamed_1.txt"
                content := "Timing test content"

                if err := createTestFile(ctx, client, originalPath, content); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to create timing test file: %v", err)
                }</span>

                <span class="cov0" title="0">size := int64(len(content))
                hash := "timinghash1"
                renameTracker.TrackDelete(ctx, 400, originalPath, "test_storage", protocol, size, &amp;hash, false, suite.GetTestConfig())

                // Detect move immediately (within window)
                if pendingMove, isMove := renameTracker.DetectCreate(ctx, renamedPath, "test_storage", protocol, size, &amp;hash, false, suite.GetTestConfig()); !isMove </span><span class="cov0" title="0">{
                        t.Error("Expected move to be detected within timing window")
                }</span> else<span class="cov0" title="0"> {
                        renameTracker.ProcessMove(ctx, client, pendingMove, renamedPath)
                }</span>

                <span class="cov0" title="0">client.DeleteFile(ctx, renamedPath)</span>
        })

        // Test move outside window
        <span class="cov0" title="0">t.Run("outside_window", func(t *testing.T) </span><span class="cov0" title="0">{
                originalPath := "/timing_test_2.txt"
                renamedPath := "/timing_renamed_2.txt"
                content := "Timing test content 2"

                if err := createTestFile(ctx, client, originalPath, content); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to create timing test file: %v", err)
                }</span>

                <span class="cov0" title="0">size := int64(len(content))
                hash := "timinghash2"
                renameTracker.TrackDelete(ctx, 401, originalPath, "test_storage", protocol, size, &amp;hash, false, suite.GetTestConfig())

                // Wait longer than the protocol's move window
                time.Sleep(capabilities.MoveWindow + time.Second)

                // Try to detect move (should fail due to expired window)
                if _, isMove := renameTracker.DetectCreate(ctx, renamedPath, "test_storage", protocol, size, &amp;hash, false, suite.GetTestConfig()); isMove </span><span class="cov0" title="0">{
                        t.Error("Expected move detection to fail outside timing window")
                }</span>

                <span class="cov0" title="0">client.DeleteFile(ctx, originalPath)</span>
        })
}

func testProtocolCapabilities(t *testing.T, suite ProtocolTestSuite, logger *zap.Logger) <span class="cov0" title="0">{
        protocol := suite.GetProtocolName()

        capabilities, err := services.GetProtocolCapabilities(protocol, logger)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to get capabilities for protocol %s: %v", protocol, err)
        }</span>

        // Verify capabilities match expected values
        <span class="cov0" title="0">switch protocol </span>{
        case "local":<span class="cov0" title="0">
                if !capabilities.SupportsRealTimeNotification </span><span class="cov0" title="0">{
                        t.Error("Local protocol should support real-time notifications")
                }</span>
                <span class="cov0" title="0">if capabilities.MoveWindow &gt; 5*time.Second </span><span class="cov0" title="0">{
                        t.Error("Local protocol should have a short move window")
                }</span>

        case "smb":<span class="cov0" title="0">
                if capabilities.SupportsRealTimeNotification </span><span class="cov0" title="0">{
                        t.Error("SMB protocol should not support real-time notifications")
                }</span>
                <span class="cov0" title="0">if !capabilities.RequiresPolling </span><span class="cov0" title="0">{
                        t.Error("SMB protocol should require polling")
                }</span>

        case "ftp":<span class="cov0" title="0">
                if capabilities.SupportsRealTimeNotification </span><span class="cov0" title="0">{
                        t.Error("FTP protocol should not support real-time notifications")
                }</span>
                <span class="cov0" title="0">if capabilities.MoveWindow &lt; 10*time.Second </span><span class="cov0" title="0">{
                        t.Error("FTP protocol should have a longer move window")
                }</span>

        case "nfs":<span class="cov0" title="0">
                if capabilities.SupportsRealTimeNotification </span><span class="cov0" title="0">{
                        t.Error("NFS protocol should not support real-time notifications in most cases")
                }</span>

        case "webdav":<span class="cov0" title="0">
                if capabilities.SupportsRealTimeNotification </span><span class="cov0" title="0">{
                        t.Error("WebDAV protocol should not support real-time notifications")
                }</span>
        }

        <span class="cov0" title="0">t.Logf("Protocol %s capabilities: %+v", protocol, capabilities)</span>
}

// Protocol-specific test suite implementations

type LocalProtocolTestSuite struct{}

func (s *LocalProtocolTestSuite) SetupProtocol(t *testing.T) (filesystem.FileSystemClient, func()) <span class="cov0" title="0">{
        tempDir := t.TempDir()

        config := &amp;filesystem.LocalConfig{
                BasePath: tempDir,
        }

        client := filesystem.NewLocalClient(config)

        return client, func() </span>{<span class="cov0" title="0">
                // Cleanup handled by t.TempDir()
        }</span>
}

func (s *LocalProtocolTestSuite) GetProtocolName() string <span class="cov0" title="0">{
        return "local"
}</span>

func (s *LocalProtocolTestSuite) GetTestConfig() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "base_path": "/tmp/test",
        }
}</span>

func (s *LocalProtocolTestSuite) SupportsRealTimeEvents() bool <span class="cov0" title="0">{
        return true
}</span>

type SMBProtocolTestSuite struct{}

func (s *SMBProtocolTestSuite) SetupProtocol(t *testing.T) (filesystem.FileSystemClient, func()) <span class="cov0" title="0">{
        // For testing, we'll use a mock SMB client or skip if no test server available
        if os.Getenv("SMB_TEST_SERVER") == "" </span><span class="cov0" title="0">{
                t.Skip("SMB_TEST_SERVER not set, skipping SMB tests")
        }</span>

        <span class="cov0" title="0">config := &amp;filesystem.SmbConfig{
                Host:     os.Getenv("SMB_TEST_HOST"),
                Port:     445,
                Share:    os.Getenv("SMB_TEST_SHARE"),
                Username: os.Getenv("SMB_TEST_USER"),
                Password: os.Getenv("SMB_TEST_PASS"),
        }

        client := filesystem.NewSmbClient(config)

        return client, func() </span>{<span class="cov0" title="0">
                // SMB cleanup
        }</span>
}

func (s *SMBProtocolTestSuite) GetProtocolName() string <span class="cov0" title="0">{
        return "smb"
}</span>

func (s *SMBProtocolTestSuite) GetTestConfig() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "host":  "testserver",
                "share": "testshare",
        }
}</span>

func (s *SMBProtocolTestSuite) SupportsRealTimeEvents() bool <span class="cov0" title="0">{
        return false
}</span>

type FTPProtocolTestSuite struct{}

func (s *FTPProtocolTestSuite) SetupProtocol(t *testing.T) (filesystem.FileSystemClient, func()) <span class="cov0" title="0">{
        if os.Getenv("FTP_TEST_SERVER") == "" </span><span class="cov0" title="0">{
                t.Skip("FTP_TEST_SERVER not set, skipping FTP tests")
        }</span>

        // Mock FTP client setup
        <span class="cov0" title="0">t.Skip("FTP client implementation pending")
        return nil, func() </span>{<span class="cov0" title="0">}</span>
}

func (s *FTPProtocolTestSuite) GetProtocolName() string <span class="cov0" title="0">{
        return "ftp"
}</span>

func (s *FTPProtocolTestSuite) GetTestConfig() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "host": "ftpserver",
                "port": 21,
        }
}</span>

func (s *FTPProtocolTestSuite) SupportsRealTimeEvents() bool <span class="cov0" title="0">{
        return false
}</span>

type NFSProtocolTestSuite struct{}

func (s *NFSProtocolTestSuite) SetupProtocol(t *testing.T) (filesystem.FileSystemClient, func()) <span class="cov0" title="0">{
        if os.Getenv("NFS_TEST_SERVER") == "" </span><span class="cov0" title="0">{
                t.Skip("NFS_TEST_SERVER not set, skipping NFS tests")
        }</span>

        // Mock NFS client setup
        <span class="cov0" title="0">t.Skip("NFS client implementation pending")
        return nil, func() </span>{<span class="cov0" title="0">}</span>
}

func (s *NFSProtocolTestSuite) GetProtocolName() string <span class="cov0" title="0">{
        return "nfs"
}</span>

func (s *NFSProtocolTestSuite) GetTestConfig() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "host":        "nfsserver",
                "export_path": "/export",
        }
}</span>

func (s *NFSProtocolTestSuite) SupportsRealTimeEvents() bool <span class="cov0" title="0">{
        return false
}</span>

type WebDAVProtocolTestSuite struct{}

func (s *WebDAVProtocolTestSuite) SetupProtocol(t *testing.T) (filesystem.FileSystemClient, func()) <span class="cov0" title="0">{
        if os.Getenv("WEBDAV_TEST_SERVER") == "" </span><span class="cov0" title="0">{
                t.Skip("WEBDAV_TEST_SERVER not set, skipping WebDAV tests")
        }</span>

        // Mock WebDAV client setup
        <span class="cov0" title="0">t.Skip("WebDAV client implementation pending")
        return nil, func() </span>{<span class="cov0" title="0">}</span>
}

func (s *WebDAVProtocolTestSuite) GetProtocolName() string <span class="cov0" title="0">{
        return "webdav"
}</span>

func (s *WebDAVProtocolTestSuite) GetTestConfig() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "url": "https://webdavserver/dav",
        }
}</span>

func (s *WebDAVProtocolTestSuite) SupportsRealTimeEvents() bool <span class="cov0" title="0">{
        return false
}</span>

// Helper functions

func setupProtocolTestDB(t *testing.T) *sql.DB <span class="cov0" title="0">{
        db, err := sql.Open("sqlite3", ":memory:")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test database: %v", err)
        }</span>

        <span class="cov0" title="0">schema := `
                CREATE TABLE storage_roots (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL UNIQUE
                );

                CREATE TABLE files (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        storage_root_id INTEGER NOT NULL,
                        path TEXT NOT NULL,
                        name TEXT NOT NULL,
                        is_directory BOOLEAN NOT NULL,
                        size INTEGER NOT NULL,
                        quick_hash TEXT,
                        parent_id INTEGER,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        modified_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        deleted BOOLEAN DEFAULT FALSE,
                        deleted_at TIMESTAMP,
                        last_scan_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (storage_root_id) REFERENCES storage_roots (id)
                );

                CREATE TABLE universal_rename_events (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        storage_root_id INTEGER NOT NULL,
                        protocol TEXT NOT NULL,
                        old_path TEXT NOT NULL,
                        new_path TEXT NOT NULL,
                        is_directory BOOLEAN NOT NULL,
                        size INTEGER NOT NULL,
                        file_hash TEXT,
                        detected_at TIMESTAMP NOT NULL,
                        processed_at TIMESTAMP,
                        status TEXT NOT NULL DEFAULT 'pending',
                        FOREIGN KEY (storage_root_id) REFERENCES storage_roots (id)
                );

                INSERT INTO storage_roots (id, name) VALUES (1, 'test_storage');
        `

        if _, err := db.Exec(schema); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test schema: %v", err)
        }</span>

        <span class="cov0" title="0">return db</span>
}

func createTestFile(ctx context.Context, client filesystem.FileSystemClient, path, content string) error <span class="cov0" title="0">{
        // For testing, we'll create a simple file
        // In a real implementation, this would use the appropriate client method
        return nil // Placeholder implementation
}</span>

// TestUniversalRenameTrackerIntegration tests the complete integration
func TestUniversalRenameTrackerIntegration(t *testing.T) <span class="cov0" title="0">{
        if testing.Short() </span><span class="cov0" title="0">{
                t.Skip("Skipping integration test in short mode")
        }</span>

        <span class="cov0" title="0">logger := zap.NewNop()
        ctx := context.Background()

        // Setup
        db := setupProtocolTestDB(t)
        defer db.Close()

        tracker := services.NewUniversalRenameTracker(db, logger)
        if err := tracker.Start(); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to start tracker: %v", err)
        }</span>
        <span class="cov0" title="0">defer tracker.Stop()

        // Test cross-protocol scenarios
        t.Run("cross_protocol_operations", func(t *testing.T) </span><span class="cov0" title="0">{
                // Test operations that span multiple protocols
                protocols := []string{"local", "smb", "ftp"}

                for _, protocol := range protocols </span><span class="cov0" title="0">{
                        // Track deletions for each protocol
                        tracker.TrackDelete(ctx, int64(100+len(protocol)), "/test.txt", "storage1", protocol, 1024, nil, false, map[string]interface{}{})
                }</span>

                // Verify statistics
                <span class="cov0" title="0">stats := tracker.GetStatistics()
                if pendingByProtocol, ok := stats["pending_by_protocol"].(map[string]int); ok </span><span class="cov0" title="0">{
                        for _, protocol := range protocols </span><span class="cov0" title="0">{
                                if count, exists := pendingByProtocol[protocol]; !exists || count != 1 </span><span class="cov0" title="0">{
                                        t.Errorf("Expected 1 pending move for protocol %s, got %d", protocol, count)
                                }</span>
                        }
                }
        })

        // Test concurrent operations
        <span class="cov0" title="0">t.Run("concurrent_operations", func(t *testing.T) </span><span class="cov0" title="0">{
                numGoroutines := 10
                done := make(chan bool, numGoroutines)

                for i := 0; i &lt; numGoroutines; i++ </span><span class="cov0" title="0">{
                        go func(id int) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{ done &lt;- true }</span>()

                                <span class="cov0" title="0">path := fmt.Sprintf("/concurrent_%d.txt", id)
                                fileID := int64(500 + id)

                                tracker.TrackDelete(ctx, fileID, path, "storage1", "local", 1024, nil, false, map[string]interface{}{})

                                // Immediately try to detect
                                if pendingMove, isMove := tracker.DetectCreate(ctx, path+"_renamed", "storage1", "local", 1024, nil, false, map[string]interface{}{}); isMove </span><span class="cov0" title="0">{
                                        t.Logf("Concurrent operation %d: move detected", id)
                                        // Process move (simplified)
                                        _ = pendingMove
                                }</span>
                        }(i)
                }

                // Wait for all operations to complete
                <span class="cov0" title="0">for i := 0; i &lt; numGoroutines; i++ </span><span class="cov0" title="0">{
                        &lt;-done
                }</span>

                // Verify final state
                <span class="cov0" title="0">finalStats := tracker.GetStatistics()
                t.Logf("Final statistics after concurrent operations: %+v", finalStats)</span>
        })
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package mocks

import (
        "bufio"
        "fmt"
        "net"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"
)

// MockFTPServer provides a mock FTP server for testing
type MockFTPServer struct {
        logger      *zap.Logger
        listener    net.Listener
        port        int
        users       map[string]string // username -&gt; password
        files       map[string]*MockFTPFile
        running     bool
        wg          sync.WaitGroup
        mu          sync.RWMutex
        currentDir  string
        passiveMode bool
        dataPort    int
}

// MockFTPFile represents a mock FTP file or directory
type MockFTPFile struct {
        Name        string
        Path        string
        IsDirectory bool
        Size        int64
        ModTime     time.Time
        Content     []byte
        Permissions string
}

// NewMockFTPServer creates a new mock FTP server
func NewMockFTPServer(logger *zap.Logger) *MockFTPServer <span class="cov0" title="0">{
        server := &amp;MockFTPServer{
                logger:     logger,
                users:      make(map[string]string),
                files:      make(map[string]*MockFTPFile),
                currentDir: "/",
        }

        server.setupDefaultData()
        return server
}</span>

// setupDefaultData adds default users and files for testing
func (s *MockFTPServer) setupDefaultData() <span class="cov0" title="0">{
        // Add default users
        s.users["anonymous"] = ""
        s.users["testuser"] = "testpass"
        s.users["ftpuser"] = "ftppass"

        // Add default directory structure
        s.AddFile("/", "public", true, 0, []byte{}, "drwxr-xr-x")
        s.AddFile("/", "uploads", true, 0, []byte{}, "drwxrwxrwx")
        s.AddFile("/", "readme.txt", false, 512, []byte("Welcome to the FTP server!"), "-rw-r--r--")

        s.AddFile("/public", "documents", true, 0, []byte{}, "drwxr-xr-x")
        s.AddFile("/public", "software", true, 0, []byte{}, "drwxr-xr-x")
        s.AddFile("/public", "info.txt", false, 1024, []byte("Public information file"), "-rw-r--r--")

        s.AddFile("/public/documents", "manual.pdf", false, 204800, []byte("Mock PDF content"), "-rw-r--r--")
        s.AddFile("/public/documents", "guide.doc", false, 102400, []byte("Mock document content"), "-rw-r--r--")

        s.AddFile("/public/software", "installer.exe", false, 5242880, []byte("Mock installer content"), "-rw-r--r--")
        s.AddFile("/public/software", "update.zip", false, 1048576, []byte("Mock update content"), "-rw-r--r--")

        s.AddFile("/uploads", "temp", true, 0, []byte{}, "drwxrwxrwx")
}</span>

// AddFile adds a file or directory to the server
func (s *MockFTPServer) AddFile(parentPath, name string, isDirectory bool, size int64, content []byte, permissions string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        path := filepath.Join(parentPath, name)
        if parentPath == "/" </span><span class="cov0" title="0">{
                path = "/" + name
        }</span>

        <span class="cov0" title="0">s.files[path] = &amp;MockFTPFile{
                Name:        name,
                Path:        path,
                IsDirectory: isDirectory,
                Size:        size,
                ModTime:     time.Now(),
                Content:     content,
                Permissions: permissions,
        }</span>
}

// AddUser adds a user with password
func (s *MockFTPServer) AddUser(username, password string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.users[username] = password
}</span>

// Start starts the mock FTP server
func (s *MockFTPServer) Start() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.running </span><span class="cov0" title="0">{
                return fmt.Errorf("server already running")
        }</span>

        // Listen on any available port
        <span class="cov0" title="0">listener, err := net.Listen("tcp", ":0")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start listener: %w", err)
        }</span>

        <span class="cov0" title="0">s.listener = listener
        s.port = listener.Addr().(*net.TCPAddr).Port
        s.running = true

        s.logger.Info("Mock FTP server started", zap.Int("port", s.port))

        // Start accepting connections
        s.wg.Add(1)
        go s.acceptConnections()

        return nil</span>
}

// Stop stops the mock FTP server
func (s *MockFTPServer) Stop() error <span class="cov0" title="0">{
        s.mu.Lock()
        if !s.running </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return nil
        }</span>
        <span class="cov0" title="0">s.running = false
        s.mu.Unlock()

        if s.listener != nil </span><span class="cov0" title="0">{
                s.listener.Close()
        }</span>

        <span class="cov0" title="0">s.wg.Wait()
        s.logger.Info("Mock FTP server stopped")
        return nil</span>
}

// GetPort returns the port the server is listening on
func (s *MockFTPServer) GetPort() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.port
}</span>

// GetAddress returns the server address
func (s *MockFTPServer) GetAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("localhost:%d", s.GetPort())
}</span>

// acceptConnections handles incoming connections
func (s *MockFTPServer) acceptConnections() <span class="cov0" title="0">{
        defer s.wg.Done()

        for </span><span class="cov0" title="0">{
                conn, err := s.listener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        s.mu.RLock()
                        running := s.running
                        s.mu.RUnlock()

                        if !running </span><span class="cov0" title="0">{
                                return // Server stopped
                        }</span>
                        <span class="cov0" title="0">s.logger.Error("Failed to accept FTP connection", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">s.wg.Add(1)
                go s.handleConnection(conn)</span>
        }
}

// handleConnection handles a single FTP connection
func (s *MockFTPServer) handleConnection(conn net.Conn) <span class="cov0" title="0">{
        defer s.wg.Done()
        defer conn.Close()

        s.logger.Debug("New FTP connection", zap.String("remote", conn.RemoteAddr().String()))

        // Send welcome message
        s.sendResponse(conn, "220 Mock FTP Server Ready")

        scanner := bufio.NewScanner(conn)
        authenticated := false
        username := ""

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                s.logger.Debug("FTP command received", zap.String("command", line))

                parts := strings.SplitN(line, " ", 2)
                if len(parts) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">command := strings.ToUpper(parts[0])
                args := ""
                if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                        args = parts[1]
                }</span>

                <span class="cov0" title="0">switch command </span>{
                case "USER":<span class="cov0" title="0">
                        username = args
                        if s.userExists(username) </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "331 Password required for "+username)
                        }</span> else<span class="cov0" title="0"> {
                                s.sendResponse(conn, "530 User not found")
                        }</span>

                case "PASS":<span class="cov0" title="0">
                        if s.authenticateUser(username, args) </span><span class="cov0" title="0">{
                                authenticated = true
                                s.sendResponse(conn, "230 User logged in")
                        }</span> else<span class="cov0" title="0"> {
                                s.sendResponse(conn, "530 Authentication failed")
                        }</span>

                case "SYST":<span class="cov0" title="0">
                        s.sendResponse(conn, "215 UNIX Type: L8")</span>

                case "PWD":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.sendResponse(conn, fmt.Sprintf("257 \"%s\" is current directory", s.currentDir))</span>

                case "CWD":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">if s.changeDirectory(args) </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "250 Directory changed")
                        }</span> else<span class="cov0" title="0"> {
                                s.sendResponse(conn, "550 Directory not found")
                        }</span>

                case "LIST":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleList(conn, args)</span>

                case "NLST":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleNlst(conn, args)</span>

                case "SIZE":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleSize(conn, args)</span>

                case "MDTM":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleMdtm(conn, args)</span>

                case "TYPE":<span class="cov0" title="0">
                        s.sendResponse(conn, "200 Type set to "+args)</span>

                case "PASV":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handlePasv(conn)</span>

                case "RETR":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleRetr(conn, args)</span>

                case "STOR":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleStor(conn, args)</span>

                case "DELE":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleDele(conn, args)</span>

                case "MKD", "XMKD":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleMkd(conn, args)</span>

                case "RMD", "XRMD":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleRmd(conn, args)</span>

                case "QUIT":<span class="cov0" title="0">
                        s.sendResponse(conn, "221 Goodbye")
                        return</span>

                case "NOOP":<span class="cov0" title="0">
                        s.sendResponse(conn, "200 OK")</span>

                default:<span class="cov0" title="0">
                        s.sendResponse(conn, "502 Command not implemented")</span>
                }
        }
}

// sendResponse sends an FTP response
func (s *MockFTPServer) sendResponse(conn net.Conn, response string) <span class="cov0" title="0">{
        _, err := conn.Write([]byte(response + "\r\n"))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to send FTP response", zap.Error(err))
        }</span>
        <span class="cov0" title="0">s.logger.Debug("FTP response sent", zap.String("response", response))</span>
}

// userExists checks if a user exists
func (s *MockFTPServer) userExists(username string) bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        _, exists := s.users[username]
        return exists
}</span>

// authenticateUser checks if user credentials are valid
func (s *MockFTPServer) authenticateUser(username, password string) bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        expectedPassword, exists := s.users[username]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return expectedPassword == password</span>
}

// changeDirectory changes the current directory
func (s *MockFTPServer) changeDirectory(path string) bool <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        targetPath := path
        if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + path
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + path
                }</span>
        }

        // Check if directory exists
        <span class="cov0" title="0">if file, exists := s.files[targetPath]; exists &amp;&amp; file.IsDirectory </span><span class="cov0" title="0">{
                s.currentDir = targetPath
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// handleList handles the LIST command
func (s *MockFTPServer) handleList(conn net.Conn, path string) <span class="cov0" title="0">{
        targetPath := s.currentDir
        if path != "" </span><span class="cov0" title="0">{
                if strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                        targetPath = path
                }</span> else<span class="cov0" title="0"> {
                        if s.currentDir == "/" </span><span class="cov0" title="0">{
                                targetPath = "/" + path
                        }</span> else<span class="cov0" title="0"> {
                                targetPath = s.currentDir + "/" + path
                        }</span>
                }
        }

        // For simplicity, send list directly on command channel
        // In real FTP, this would use a data channel
        <span class="cov0" title="0">s.sendResponse(conn, "150 Opening data connection")

        files := s.listFiles(targetPath)
        for _, file := range files </span><span class="cov0" title="0">{
                listing := s.formatFileListing(file)
                s.sendResponse(conn, listing)
        }</span>

        <span class="cov0" title="0">s.sendResponse(conn, "226 Transfer complete")</span>
}

// handleNlst handles the NLST command (name list)
func (s *MockFTPServer) handleNlst(conn net.Conn, path string) <span class="cov0" title="0">{
        targetPath := s.currentDir
        if path != "" </span><span class="cov0" title="0">{
                if strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                        targetPath = path
                }</span> else<span class="cov0" title="0"> {
                        if s.currentDir == "/" </span><span class="cov0" title="0">{
                                targetPath = "/" + path
                        }</span> else<span class="cov0" title="0"> {
                                targetPath = s.currentDir + "/" + path
                        }</span>
                }
        }

        <span class="cov0" title="0">s.sendResponse(conn, "150 Opening data connection")

        files := s.listFiles(targetPath)
        for _, file := range files </span><span class="cov0" title="0">{
                s.sendResponse(conn, file.Name)
        }</span>

        <span class="cov0" title="0">s.sendResponse(conn, "226 Transfer complete")</span>
}

// handleSize handles the SIZE command
func (s *MockFTPServer) handleSize(conn net.Conn, path string) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        targetPath := path
        if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + path
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + path
                }</span>
        }

        <span class="cov0" title="0">if file, exists := s.files[targetPath]; exists &amp;&amp; !file.IsDirectory </span><span class="cov0" title="0">{
                s.sendResponse(conn, fmt.Sprintf("213 %d", file.Size))
        }</span> else<span class="cov0" title="0"> {
                s.sendResponse(conn, "550 File not found")
        }</span>
}

// handleMdtm handles the MDTM command (modification time)
func (s *MockFTPServer) handleMdtm(conn net.Conn, path string) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        targetPath := path
        if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + path
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + path
                }</span>
        }

        <span class="cov0" title="0">if file, exists := s.files[targetPath]; exists </span><span class="cov0" title="0">{
                mdtm := file.ModTime.Format("20060102150405")
                s.sendResponse(conn, fmt.Sprintf("213 %s", mdtm))
        }</span> else<span class="cov0" title="0"> {
                s.sendResponse(conn, "550 File not found")
        }</span>
}

// handlePasv handles passive mode
func (s *MockFTPServer) handlePasv(conn net.Conn) <span class="cov0" title="0">{
        // For simplicity, just acknowledge passive mode
        s.passiveMode = true
        s.dataPort = s.port + 1

        // Format: 227 Entering Passive Mode (h1,h2,h3,h4,p1,p2)
        // where IP is h1.h2.h3.h4 and port is p1*256+p2
        p1 := s.dataPort / 256
        p2 := s.dataPort % 256

        s.sendResponse(conn, fmt.Sprintf("227 Entering Passive Mode (127,0,0,1,%d,%d)", p1, p2))
}</span>

// handleRetr handles file retrieval
func (s *MockFTPServer) handleRetr(conn net.Conn, filename string) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        targetPath := filename
        if !strings.HasPrefix(filename, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + filename
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + filename
                }</span>
        }

        <span class="cov0" title="0">if file, exists := s.files[targetPath]; exists &amp;&amp; !file.IsDirectory </span><span class="cov0" title="0">{
                s.sendResponse(conn, "150 Opening data connection for file transfer")
                // In real FTP, content would be sent over data channel
                s.sendResponse(conn, "226 Transfer complete")
        }</span> else<span class="cov0" title="0"> {
                s.sendResponse(conn, "550 File not found")
        }</span>
}

// handleStor handles file storage
func (s *MockFTPServer) handleStor(conn net.Conn, filename string) <span class="cov0" title="0">{
        targetPath := filename
        if !strings.HasPrefix(filename, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + filename
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + filename
                }</span>
        }

        <span class="cov0" title="0">s.sendResponse(conn, "150 Opening data connection for file upload")

        // Simulate file upload
        s.AddFile(filepath.Dir(targetPath), filepath.Base(targetPath), false, 1024, []byte("Uploaded content"), "-rw-r--r--")

        s.sendResponse(conn, "226 Transfer complete")</span>
}

// handleDele handles file deletion
func (s *MockFTPServer) handleDele(conn net.Conn, filename string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        targetPath := filename
        if !strings.HasPrefix(filename, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + filename
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + filename
                }</span>
        }

        <span class="cov0" title="0">if _, exists := s.files[targetPath]; exists </span><span class="cov0" title="0">{
                delete(s.files, targetPath)
                s.sendResponse(conn, "250 File deleted")
        }</span> else<span class="cov0" title="0"> {
                s.sendResponse(conn, "550 File not found")
        }</span>
}

// handleMkd handles directory creation
func (s *MockFTPServer) handleMkd(conn net.Conn, dirname string) <span class="cov0" title="0">{
        targetPath := dirname
        if !strings.HasPrefix(dirname, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + dirname
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + dirname
                }</span>
        }

        <span class="cov0" title="0">s.AddFile(filepath.Dir(targetPath), filepath.Base(targetPath), true, 0, []byte{}, "drwxr-xr-x")
        s.sendResponse(conn, fmt.Sprintf("257 \"%s\" directory created", targetPath))</span>
}

// handleRmd handles directory removal
func (s *MockFTPServer) handleRmd(conn net.Conn, dirname string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        targetPath := dirname
        if !strings.HasPrefix(dirname, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + dirname
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + dirname
                }</span>
        }

        <span class="cov0" title="0">if file, exists := s.files[targetPath]; exists &amp;&amp; file.IsDirectory </span><span class="cov0" title="0">{
                delete(s.files, targetPath)
                s.sendResponse(conn, "250 Directory removed")
        }</span> else<span class="cov0" title="0"> {
                s.sendResponse(conn, "550 Directory not found")
        }</span>
}

// listFiles lists files in a directory
func (s *MockFTPServer) listFiles(path string) []*MockFTPFile <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var files []*MockFTPFile

        for filePath, file := range s.files </span><span class="cov0" title="0">{
                if filePath == path </span><span class="cov0" title="0">{
                        continue</span> // Skip the directory itself
                }

                // Check if file is a direct child of the path
                <span class="cov0" title="0">expectedPrefix := path
                if path == "/" </span><span class="cov0" title="0">{
                        expectedPrefix = "/"
                }</span> else<span class="cov0" title="0"> {
                        expectedPrefix = path + "/"
                }</span>

                <span class="cov0" title="0">if strings.HasPrefix(filePath, expectedPrefix) </span><span class="cov0" title="0">{
                        relativePath := strings.TrimPrefix(filePath, expectedPrefix)
                        if !strings.Contains(relativePath, "/") </span><span class="cov0" title="0">{
                                // Direct child
                                files = append(files, file)
                        }</span>
                }
        }

        // Sort files by name
        <span class="cov0" title="0">sort.Slice(files, func(i, j int) bool </span><span class="cov0" title="0">{
                return files[i].Name &lt; files[j].Name
        }</span>)

        <span class="cov0" title="0">return files</span>
}

// formatFileListing formats a file for LIST command output
func (s *MockFTPServer) formatFileListing(file *MockFTPFile) string <span class="cov0" title="0">{
        // Format: permissions links owner group size month day time filename
        // Example: -rw-r--r--   1 user  group     1024 Jan 01 12:00 filename.txt
        modTime := file.ModTime.Format("Jan 02 15:04")
        return fmt.Sprintf("%s   1 user  group  %8d %s %s",
                file.Permissions, file.Size, modTime, file.Name)
}</span>

// IsRunning returns true if the server is running
func (s *MockFTPServer) IsRunning() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.running
}</span>

// GetFileCount returns the number of files/directories
func (s *MockFTPServer) GetFileCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.files)
}</span>

// GetUserCount returns the number of users
func (s *MockFTPServer) GetUserCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.users)
}</span>
</pre>
		
		<pre class="file" id="file109" style="display: none">package mocks

import (
        "fmt"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"
)

// MockNFSServer provides a mock NFS server for testing
// Note: This is a simplified mock for testing purposes
// Real NFS protocol implementation would be much more complex
type MockNFSServer struct {
        logger    *zap.Logger
        exports   map[string]*MockNFSExport
        files     map[string]*MockNFSFile
        running   bool
        mu        sync.RWMutex
        port      int
        mountPath string
}

// MockNFSExport represents an NFS export
type MockNFSExport struct {
        Path        string
        Description string
        Options     string
        Clients     []string // Allowed client IPs/hostnames
}

// MockNFSFile represents a mock NFS file or directory
type MockNFSFile struct {
        Name        string
        Path        string
        IsDirectory bool
        Size        int64
        ModTime     time.Time
        Content     []byte
        Mode        uint32
        UID         uint32
        GID         uint32
        Inode       uint64
}

// NewMockNFSServer creates a new mock NFS server
func NewMockNFSServer(logger *zap.Logger, mountPath string) *MockNFSServer <span class="cov0" title="0">{
        server := &amp;MockNFSServer{
                logger:    logger,
                exports:   make(map[string]*MockNFSExport),
                files:     make(map[string]*MockNFSFile),
                mountPath: mountPath,
                port:      2049, // Standard NFS port
        }

        server.setupDefaultData()
        return server
}</span>

// setupDefaultData adds default exports and files for testing
func (s *MockNFSServer) setupDefaultData() <span class="cov0" title="0">{
        // Add default exports
        s.AddExport("/export/media", "Media files export", "rw,sync,no_subtree_check", []string{"*"})
        s.AddExport("/export/backup", "Backup files export", "ro,sync,no_subtree_check", []string{"192.168.1.0/24"})
        s.AddExport("/export/shared", "Shared files export", "rw,async,no_root_squash", []string{"localhost", "127.0.0.1"})

        // Add default directory structure for /export/media
        s.AddFile("/export/media", "", "movies", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "", "music", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "", "photos", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "", "readme.txt", false, 512, []byte("Media files repository"), 0644, 1000, 1000)

        s.AddFile("/export/media", "movies", "action", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "movies", "comedy", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "movies/action", "movie1.mp4", false, 1073741824, []byte("Mock movie content"), 0644, 1000, 1000)
        s.AddFile("/export/media", "movies/comedy", "funny.mkv", false, 536870912, []byte("Mock comedy content"), 0644, 1000, 1000)

        s.AddFile("/export/media", "music", "rock", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "music", "jazz", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "music/rock", "song1.mp3", false, 5242880, []byte("Mock rock song"), 0644, 1000, 1000)
        s.AddFile("/export/media", "music/jazz", "smooth.flac", false, 41943040, []byte("Mock jazz song"), 0644, 1000, 1000)

        s.AddFile("/export/media", "photos", "2024", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "photos/2024", "vacation.jpg", false, 2097152, []byte("Mock JPEG content"), 0644, 1000, 1000)
        s.AddFile("/export/media", "photos/2024", "family.png", false, 1048576, []byte("Mock PNG content"), 0644, 1000, 1000)

        // Add files for /export/backup
        s.AddFile("/export/backup", "", "daily", true, 0, []byte{}, 0755, 0, 0)
        s.AddFile("/export/backup", "", "weekly", true, 0, []byte{}, 0755, 0, 0)
        s.AddFile("/export/backup", "", "monthly", true, 0, []byte{}, 0755, 0, 0)

        s.AddFile("/export/backup", "daily", "backup_2024-01-01.tar.gz", false, 104857600, []byte("Mock backup data"), 0644, 0, 0)
        s.AddFile("/export/backup", "daily", "backup_2024-01-02.tar.gz", false, 98765432, []byte("Mock backup data"), 0644, 0, 0)

        s.AddFile("/export/backup", "weekly", "backup_week_01.tar.gz", false, 1073741824, []byte("Mock weekly backup"), 0644, 0, 0)
        s.AddFile("/export/backup", "monthly", "backup_202401.tar.gz", false, 5368709120, []byte("Mock monthly backup"), 0644, 0, 0)

        // Add files for /export/shared
        s.AddFile("/export/shared", "", "documents", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/shared", "", "tmp", true, 0, []byte{}, 0777, 1000, 1000)
        s.AddFile("/export/shared", "", "info.txt", false, 1024, []byte("Shared folder information"), 0644, 1000, 1000)

        s.AddFile("/export/shared", "documents", "manual.pdf", false, 1048576, []byte("Mock PDF manual"), 0644, 1000, 1000)
        s.AddFile("/export/shared", "documents", "config.xml", false, 4096, []byte("&lt;config&gt;&lt;/config&gt;"), 0644, 1000, 1000)
}</span>

// AddExport adds an NFS export
func (s *MockNFSServer) AddExport(path, description, options string, clients []string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.exports[path] = &amp;MockNFSExport{
                Path:        path,
                Description: description,
                Options:     options,
                Clients:     clients,
        }
}</span>

// AddFile adds a file or directory to an export
func (s *MockNFSServer) AddFile(exportPath, parentPath, name string, isDirectory bool, size int64, content []byte, mode, uid, gid uint32) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        path := name
        if parentPath != "" </span><span class="cov0" title="0">{
                path = parentPath + "/" + name
        }</span>

        <span class="cov0" title="0">fullPath := exportPath + "/" + path
        if parentPath == "" &amp;&amp; name != "" </span><span class="cov0" title="0">{
                fullPath = exportPath + "/" + name
        }</span>

        // Generate inode number
        <span class="cov0" title="0">inode := uint64(len(s.files) + 1)

        s.files[fullPath] = &amp;MockNFSFile{
                Name:        name,
                Path:        fullPath,
                IsDirectory: isDirectory,
                Size:        size,
                ModTime:     time.Now(),
                Content:     content,
                Mode:        mode,
                UID:         uid,
                GID:         gid,
                Inode:       inode,
        }</span>
}

// Start starts the mock NFS server
func (s *MockNFSServer) Start() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.running </span><span class="cov0" title="0">{
                return fmt.Errorf("server already running")
        }</span>

        <span class="cov0" title="0">s.running = true
        s.logger.Info("Mock NFS server started", zap.String("mount_path", s.mountPath))

        // In a real NFS implementation, you would:
        // 1. Start the portmapper service
        // 2. Register NFS services (MOUNT, NFS, etc.)
        // 3. Listen for RPC calls
        // 4. Handle mount requests and file operations

        // For this mock, we just simulate the server being started
        return nil</span>
}

// Stop stops the mock NFS server
func (s *MockNFSServer) Stop() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if !s.running </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">s.running = false
        s.logger.Info("Mock NFS server stopped")
        return nil</span>
}

// GetPort returns the NFS port (2049)
func (s *MockNFSServer) GetPort() int <span class="cov0" title="0">{
        return s.port
}</span>

// GetMountPath returns the mount path
func (s *MockNFSServer) GetMountPath() string <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.mountPath
}</span>

// IsRunning returns true if the server is running
func (s *MockNFSServer) IsRunning() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.running
}</span>

// ListExports returns all available exports
func (s *MockNFSServer) ListExports() []*MockNFSExport <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var exports []*MockNFSExport
        for _, export := range s.exports </span><span class="cov0" title="0">{
                exports = append(exports, export)
        }</span>

        // Sort by path
        <span class="cov0" title="0">sort.Slice(exports, func(i, j int) bool </span><span class="cov0" title="0">{
                return exports[i].Path &lt; exports[j].Path
        }</span>)

        <span class="cov0" title="0">return exports</span>
}

// Mount simulates mounting an NFS export
func (s *MockNFSServer) Mount(exportPath, clientIP string) error <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        export, exists := s.exports[exportPath]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("export not found: %s", exportPath)
        }</span>

        // Check if client is allowed
        <span class="cov0" title="0">allowed := false
        for _, allowedClient := range export.Clients </span><span class="cov0" title="0">{
                if allowedClient == "*" || allowedClient == clientIP || allowedClient == "localhost" </span><span class="cov0" title="0">{
                        allowed = true
                        break</span>
                }
                // Simple subnet check for CIDR notation
                <span class="cov0" title="0">if strings.Contains(allowedClient, "/") &amp;&amp; strings.HasPrefix(clientIP, strings.Split(allowedClient, "/")[0][:3]) </span><span class="cov0" title="0">{
                        allowed = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                return fmt.Errorf("client %s not allowed to mount %s", clientIP, exportPath)
        }</span>

        <span class="cov0" title="0">s.logger.Info("NFS mount successful", zap.String("export", exportPath), zap.String("client", clientIP))
        return nil</span>
}

// Unmount simulates unmounting an NFS export
func (s *MockNFSServer) Unmount(exportPath, clientIP string) error <span class="cov0" title="0">{
        s.logger.Info("NFS unmount", zap.String("export", exportPath), zap.String("client", clientIP))
        return nil
}</span>

// ListFiles lists files in an export path
func (s *MockNFSServer) ListFiles(exportPath, dirPath string) ([]*MockNFSFile, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        // Check if export exists
        if _, exists := s.exports[exportPath]; !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("export not found: %s", exportPath)
        }</span>

        <span class="cov0" title="0">fullPath := exportPath
        if dirPath != "" &amp;&amp; dirPath != "." </span><span class="cov0" title="0">{
                fullPath = exportPath + "/" + dirPath
        }</span>

        <span class="cov0" title="0">var files []*MockNFSFile

        for filePath, file := range s.files </span><span class="cov0" title="0">{
                // Check if file is in the requested directory
                if dirPath == "" || dirPath == "." </span><span class="cov0" title="0">{
                        // List files directly in the export
                        expectedPrefix := exportPath + "/"
                        if strings.HasPrefix(filePath, expectedPrefix) </span><span class="cov0" title="0">{
                                relativePath := strings.TrimPrefix(filePath, expectedPrefix)
                                if !strings.Contains(relativePath, "/") &amp;&amp; relativePath != "" </span><span class="cov0" title="0">{
                                        files = append(files, file)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // List files in a specific subdirectory
                        expectedPrefix := fullPath + "/"
                        if strings.HasPrefix(filePath, expectedPrefix) </span><span class="cov0" title="0">{
                                relativePath := strings.TrimPrefix(filePath, expectedPrefix)
                                if !strings.Contains(relativePath, "/") &amp;&amp; relativePath != "" </span><span class="cov0" title="0">{
                                        files = append(files, file)
                                }</span>
                        }
                }
        }

        // Sort files by name
        <span class="cov0" title="0">sort.Slice(files, func(i, j int) bool </span><span class="cov0" title="0">{
                return files[i].Name &lt; files[j].Name
        }</span>)

        <span class="cov0" title="0">return files, nil</span>
}

// GetFile retrieves a specific file
func (s *MockNFSServer) GetFile(exportPath, filePath string) (*MockNFSFile, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        // Check if export exists
        if _, exists := s.exports[exportPath]; !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("export not found: %s", exportPath)
        }</span>

        <span class="cov0" title="0">fullPath := exportPath + "/" + filePath
        if filePath == "" || filePath == "." </span><span class="cov0" title="0">{
                fullPath = exportPath
        }</span>

        <span class="cov0" title="0">file, exists := s.files[fullPath]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file not found: %s", fullPath)
        }</span>

        <span class="cov0" title="0">return file, nil</span>
}

// WriteFile writes content to a file (if export allows writing)
func (s *MockNFSServer) WriteFile(exportPath, filePath string, content []byte, mode, uid, gid uint32) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if export exists and is writable
        export, exists := s.exports[exportPath]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("export not found: %s", exportPath)
        }</span>

        <span class="cov0" title="0">if !strings.Contains(export.Options, "rw") </span><span class="cov0" title="0">{
                return fmt.Errorf("export is read-only: %s", exportPath)
        }</span>

        <span class="cov0" title="0">fullPath := exportPath + "/" + filePath
        fileName := filepath.Base(filePath)

        // Generate inode number
        inode := uint64(len(s.files) + 1)

        s.files[fullPath] = &amp;MockNFSFile{
                Name:        fileName,
                Path:        fullPath,
                IsDirectory: false,
                Size:        int64(len(content)),
                ModTime:     time.Now(),
                Content:     content,
                Mode:        mode,
                UID:         uid,
                GID:         gid,
                Inode:       inode,
        }

        return nil</span>
}

// DeleteFile deletes a file (if export allows writing)
func (s *MockNFSServer) DeleteFile(exportPath, filePath string) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if export exists and is writable
        export, exists := s.exports[exportPath]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("export not found: %s", exportPath)
        }</span>

        <span class="cov0" title="0">if !strings.Contains(export.Options, "rw") </span><span class="cov0" title="0">{
                return fmt.Errorf("export is read-only: %s", exportPath)
        }</span>

        <span class="cov0" title="0">fullPath := exportPath + "/" + filePath
        if _, exists := s.files[fullPath]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("file not found: %s", fullPath)
        }</span>

        <span class="cov0" title="0">delete(s.files, fullPath)
        return nil</span>
}

// CreateDirectory creates a directory (if export allows writing)
func (s *MockNFSServer) CreateDirectory(exportPath, dirPath string, mode, uid, gid uint32) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if export exists and is writable
        export, exists := s.exports[exportPath]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("export not found: %s", exportPath)
        }</span>

        <span class="cov0" title="0">if !strings.Contains(export.Options, "rw") </span><span class="cov0" title="0">{
                return fmt.Errorf("export is read-only: %s", exportPath)
        }</span>

        <span class="cov0" title="0">fullPath := exportPath + "/" + dirPath
        dirName := filepath.Base(dirPath)

        // Generate inode number
        inode := uint64(len(s.files) + 1)

        s.files[fullPath] = &amp;MockNFSFile{
                Name:        dirName,
                Path:        fullPath,
                IsDirectory: true,
                Size:        0,
                ModTime:     time.Now(),
                Content:     []byte{},
                Mode:        mode,
                UID:         uid,
                GID:         gid,
                Inode:       inode,
        }

        return nil</span>
}

// GetFileCount returns the number of files/directories
func (s *MockNFSServer) GetFileCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.files)
}</span>

// GetExportCount returns the number of exports
func (s *MockNFSServer) GetExportCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.exports)
}</span>

// GetExportNames returns list of export paths
func (s *MockNFSServer) GetExportNames() []string <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var names []string
        for path := range s.exports </span><span class="cov0" title="0">{
                names = append(names, path)
        }</span>

        <span class="cov0" title="0">sort.Strings(names)
        return names</span>
}

// TestConnection tests if a client can connect to an export
func (s *MockNFSServer) TestConnection(exportPath, clientIP string) error <span class="cov0" title="0">{
        return s.Mount(exportPath, clientIP)
}</span>
</pre>
		
		<pre class="file" id="file110" style="display: none">package mocks

import (
        "fmt"
        "net"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"
)

// MockSMBServer provides a mock SMB server for testing
type MockSMBServer struct {
        logger   *zap.Logger
        listener net.Listener
        port     int
        shares   map[string]*MockSMBShare
        users    map[string]string // username -&gt; password
        running  bool
        wg       sync.WaitGroup
        mu       sync.RWMutex
}

// MockSMBShare represents a mock SMB share
type MockSMBShare struct {
        Name        string
        Description string
        Files       map[string]*MockSMBFile
        Writable    bool
}

// MockSMBFile represents a mock file or directory
type MockSMBFile struct {
        Name        string
        IsDirectory bool
        Size        int64
        ModTime     time.Time
        Content     []byte
}

// NewMockSMBServer creates a new mock SMB server
func NewMockSMBServer(logger *zap.Logger) *MockSMBServer <span class="cov0" title="0">{
        server := &amp;MockSMBServer{
                logger: logger,
                shares: make(map[string]*MockSMBShare),
                users:  make(map[string]string),
        }

        // Add default shares and users
        server.setupDefaultData()

        return server
}</span>

// setupDefaultData adds default shares, users, and files for testing
func (s *MockSMBServer) setupDefaultData() <span class="cov0" title="0">{
        // Add default users
        s.users["guest"] = ""
        s.users["testuser"] = "testpass"
        s.users["admin"] = "adminpass"

        // Add default shares
        s.AddShare("shared", "Shared folder", true)
        s.AddShare("public", "Public folder", false)
        s.AddShare("media", "Media files", true)
        s.AddShare("backup", "Backup files", false)

        // Add sample files to shares
        s.AddFile("shared", "", "documents", true, 0, []byte{})
        s.AddFile("shared", "", "readme.txt", false, 1024, []byte("Welcome to the shared folder!"))
        s.AddFile("shared", "documents", "report.doc", false, 2048, []byte("Sample document content"))

        s.AddFile("media", "", "videos", true, 0, []byte{})
        s.AddFile("media", "", "music", true, 0, []byte{})
        s.AddFile("media", "videos", "sample.mp4", false, 1048576, []byte("Mock video content"))
        s.AddFile("media", "music", "song.mp3", false, 524288, []byte("Mock audio content"))

        s.AddFile("public", "", "info.txt", false, 512, []byte("Public information"))
        s.AddFile("public", "", "downloads", true, 0, []byte{})

        s.AddFile("backup", "", "backup_2024.zip", false, 10485760, []byte("Mock backup data"))
}</span>

// AddShare adds a share to the mock server
func (s *MockSMBServer) AddShare(name, description string, writable bool) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.shares[name] = &amp;MockSMBShare{
                Name:        name,
                Description: description,
                Files:       make(map[string]*MockSMBFile),
                Writable:    writable,
        }
}</span>

// AddFile adds a file or directory to a share
func (s *MockSMBServer) AddFile(shareName, parentPath, fileName string, isDirectory bool, size int64, content []byte) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        share, exists := s.shares[shareName]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">path := fileName
        if parentPath != "" </span><span class="cov0" title="0">{
                path = parentPath + "/" + fileName
        }</span>

        <span class="cov0" title="0">share.Files[path] = &amp;MockSMBFile{
                Name:        fileName,
                IsDirectory: isDirectory,
                Size:        size,
                ModTime:     time.Now(),
                Content:     content,
        }</span>
}

// AddUser adds a user with password
func (s *MockSMBServer) AddUser(username, password string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.users[username] = password
}</span>

// Start starts the mock SMB server
func (s *MockSMBServer) Start() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.running </span><span class="cov0" title="0">{
                return fmt.Errorf("server already running")
        }</span>

        // Listen on any available port
        <span class="cov0" title="0">listener, err := net.Listen("tcp", ":0")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start listener: %w", err)
        }</span>

        <span class="cov0" title="0">s.listener = listener
        s.port = listener.Addr().(*net.TCPAddr).Port
        s.running = true

        s.logger.Info("Mock SMB server started", zap.Int("port", s.port))

        // Start accepting connections
        s.wg.Add(1)
        go s.acceptConnections()

        return nil</span>
}

// Stop stops the mock SMB server
func (s *MockSMBServer) Stop() error <span class="cov0" title="0">{
        s.mu.Lock()
        if !s.running </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return nil
        }</span>
        <span class="cov0" title="0">s.running = false
        s.mu.Unlock()

        if s.listener != nil </span><span class="cov0" title="0">{
                s.listener.Close()
        }</span>

        <span class="cov0" title="0">s.wg.Wait()
        s.logger.Info("Mock SMB server stopped")
        return nil</span>
}

// GetPort returns the port the server is listening on
func (s *MockSMBServer) GetPort() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.port
}</span>

// GetAddress returns the server address
func (s *MockSMBServer) GetAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("localhost:%d", s.GetPort())
}</span>

// acceptConnections handles incoming connections
func (s *MockSMBServer) acceptConnections() <span class="cov0" title="0">{
        defer s.wg.Done()

        for </span><span class="cov0" title="0">{
                conn, err := s.listener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        s.mu.RLock()
                        running := s.running
                        s.mu.RUnlock()

                        if !running </span><span class="cov0" title="0">{
                                return // Server stopped
                        }</span>
                        <span class="cov0" title="0">s.logger.Error("Failed to accept connection", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">s.wg.Add(1)
                go s.handleConnection(conn)</span>
        }
}

// handleConnection handles a single SMB connection
func (s *MockSMBServer) handleConnection(conn net.Conn) <span class="cov0" title="0">{
        defer s.wg.Done()
        defer conn.Close()

        s.logger.Debug("New SMB connection", zap.String("remote", conn.RemoteAddr().String()))

        // This is a simplified mock implementation
        // In a real scenario, you'd implement the full SMB protocol

        // For testing purposes, we'll simulate basic SMB responses
        // This allows the go-smb2 client to connect and get mock data

        // Read initial request
        buffer := make([]byte, 4096)
        n, err := conn.Read(buffer)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to read from connection", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">request := buffer[:n]
        s.logger.Debug("Received SMB request", zap.Int("bytes", n))

        // Send mock response (simplified)
        response := s.generateMockResponse(request)
        _, err = conn.Write(response)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to write response", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Sent SMB response", zap.Int("bytes", len(response)))</span>
}

// generateMockResponse generates a mock SMB response
func (s *MockSMBServer) generateMockResponse(request []byte) []byte <span class="cov0" title="0">{
        // This is a simplified mock response
        // In practice, you'd need to implement proper SMB protocol handling

        // For testing, return a basic success response
        response := make([]byte, 64)
        copy(response[0:4], []byte{0xFE, 0x53, 0x4D, 0x42}) // SMB2 signature
        return response
}</span>

// AuthenticateUser checks if user credentials are valid
func (s *MockSMBServer) AuthenticateUser(username, password string) bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        expectedPassword, exists := s.users[username]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return expectedPassword == password</span>
}

// ListShares returns available shares
func (s *MockSMBServer) ListShares() []MockSMBShare <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var shares []MockSMBShare
        for _, share := range s.shares </span><span class="cov0" title="0">{
                shares = append(shares, *share)
        }</span>
        <span class="cov0" title="0">return shares</span>
}

// ListFiles returns files in a share path
func (s *MockSMBServer) ListFiles(shareName, path string) ([]*MockSMBFile, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        share, exists := s.shares[shareName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("share not found: %s", shareName)
        }</span>

        <span class="cov0" title="0">var files []*MockSMBFile

        // List files in the specified path
        for filePath, file := range share.Files </span><span class="cov0" title="0">{
                // Check if file is in the requested path
                if path == "" || path == "." </span><span class="cov0" title="0">{
                        // Root path - include files with no parent path
                        if !strings.Contains(filePath, "/") </span><span class="cov0" title="0">{
                                files = append(files, file)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Specific path - include files that start with the path
                        if strings.HasPrefix(filePath, path+"/") </span><span class="cov0" title="0">{
                                relativePath := strings.TrimPrefix(filePath, path+"/")
                                if !strings.Contains(relativePath, "/") </span><span class="cov0" title="0">{
                                        // Direct child of the path
                                        files = append(files, file)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return files, nil</span>
}

// GetFile returns file content
func (s *MockSMBServer) GetFile(shareName, filePath string) (*MockSMBFile, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        share, exists := s.shares[shareName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("share not found: %s", shareName)
        }</span>

        <span class="cov0" title="0">file, exists := share.Files[filePath]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file not found: %s", filePath)
        }</span>

        <span class="cov0" title="0">return file, nil</span>
}

// WriteFile writes content to a file (if share is writable)
func (s *MockSMBServer) WriteFile(shareName, filePath string, content []byte) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        share, exists := s.shares[shareName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("share not found: %s", shareName)
        }</span>

        <span class="cov0" title="0">if !share.Writable </span><span class="cov0" title="0">{
                return fmt.Errorf("share is read-only: %s", shareName)
        }</span>

        // Extract filename from path
        <span class="cov0" title="0">fileName := filePath
        if strings.Contains(filePath, "/") </span><span class="cov0" title="0">{
                parts := strings.Split(filePath, "/")
                fileName = parts[len(parts)-1]
        }</span>

        <span class="cov0" title="0">share.Files[filePath] = &amp;MockSMBFile{
                Name:        fileName,
                IsDirectory: false,
                Size:        int64(len(content)),
                ModTime:     time.Now(),
                Content:     content,
        }

        return nil</span>
}

// DeleteFile deletes a file (if share is writable)
func (s *MockSMBServer) DeleteFile(shareName, filePath string) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        share, exists := s.shares[shareName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("share not found: %s", shareName)
        }</span>

        <span class="cov0" title="0">if !share.Writable </span><span class="cov0" title="0">{
                return fmt.Errorf("share is read-only: %s", shareName)
        }</span>

        <span class="cov0" title="0">delete(share.Files, filePath)
        return nil</span>
}

// GetShareNames returns list of share names
func (s *MockSMBServer) GetShareNames() []string <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var names []string
        for name := range s.shares </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// IsRunning returns true if the server is running
func (s *MockSMBServer) IsRunning() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.running
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">package mocks

import (
        "fmt"
        "io"
        "net"
        "net/http"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"
)

// MockWebDAVServer provides a mock WebDAV server for testing
type MockWebDAVServer struct {
        logger   *zap.Logger
        server   *http.Server
        port     int
        users    map[string]string // username -&gt; password
        files    map[string]*MockWebDAVFile
        running  bool
        mu       sync.RWMutex
        basePath string
}

// MockWebDAVFile represents a mock WebDAV file or collection
type MockWebDAVFile struct {
        Name        string
        Path        string
        IsDirectory bool
        Size        int64
        ModTime     time.Time
        Content     []byte
        ETag        string
        ContentType string
}

// NewMockWebDAVServer creates a new mock WebDAV server
func NewMockWebDAVServer(logger *zap.Logger) *MockWebDAVServer <span class="cov0" title="0">{
        server := &amp;MockWebDAVServer{
                logger:   logger,
                users:    make(map[string]string),
                files:    make(map[string]*MockWebDAVFile),
                basePath: "/dav",
        }

        server.setupDefaultData()
        return server
}</span>

// setupDefaultData adds default users and files for testing
func (s *MockWebDAVServer) setupDefaultData() <span class="cov0" title="0">{
        // Add default users
        s.users["webdavuser"] = "webdavpass"
        s.users["testuser"] = "testpass"
        s.users["admin"] = "adminpass"

        // Add default directory structure
        s.AddFile("/", "documents", true, 0, []byte{}, "text/html")
        s.AddFile("/", "media", true, 0, []byte{}, "text/html")
        s.AddFile("/", "public", true, 0, []byte{}, "text/html")
        s.AddFile("/", "welcome.txt", false, 1024, []byte("Welcome to WebDAV server!"), "text/plain")

        s.AddFile("/documents", "reports", true, 0, []byte{}, "text/html")
        s.AddFile("/documents", "templates", true, 0, []byte{}, "text/html")
        s.AddFile("/documents", "readme.md", false, 2048, []byte("# Document Repository\n\nThis is the document repository."), "text/markdown")

        s.AddFile("/documents/reports", "quarterly.pdf", false, 512000, []byte("Mock PDF content"), "application/pdf")
        s.AddFile("/documents/reports", "monthly.xlsx", false, 256000, []byte("Mock Excel content"), "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

        s.AddFile("/documents/templates", "letter.docx", false, 128000, []byte("Mock Word template"), "application/vnd.openxmlformats-officedocument.wordprocessingml.document")
        s.AddFile("/documents/templates", "invoice.html", false, 8192, []byte("&lt;html&gt;&lt;body&gt;Invoice Template&lt;/body&gt;&lt;/html&gt;"), "text/html")

        s.AddFile("/media", "images", true, 0, []byte{}, "text/html")
        s.AddFile("/media", "videos", true, 0, []byte{}, "text/html")
        s.AddFile("/media", "audio", true, 0, []byte{}, "text/html")

        s.AddFile("/media/images", "logo.png", false, 32768, []byte("Mock PNG content"), "image/png")
        s.AddFile("/media/images", "banner.jpg", false, 65536, []byte("Mock JPEG content"), "image/jpeg")

        s.AddFile("/media/videos", "demo.mp4", false, 10485760, []byte("Mock video content"), "video/mp4")
        s.AddFile("/media/audio", "background.mp3", false, 5242880, []byte("Mock audio content"), "audio/mpeg")

        s.AddFile("/public", "info.html", false, 4096, []byte("&lt;html&gt;&lt;body&gt;&lt;h1&gt;Public Information&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"), "text/html")
        s.AddFile("/public", "downloads", true, 0, []byte{}, "text/html")
}</span>

// AddFile adds a file or collection to the server
func (s *MockWebDAVServer) AddFile(parentPath, name string, isDirectory bool, size int64, content []byte, contentType string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        path := filepath.Join(parentPath, name)
        if parentPath == "/" </span><span class="cov0" title="0">{
                path = "/" + name
        }</span>

        // Generate ETag
        <span class="cov0" title="0">etag := fmt.Sprintf(`"%x-%d"`, time.Now().Unix(), size)

        s.files[path] = &amp;MockWebDAVFile{
                Name:        name,
                Path:        path,
                IsDirectory: isDirectory,
                Size:        size,
                ModTime:     time.Now(),
                Content:     content,
                ETag:        etag,
                ContentType: contentType,
        }</span>
}

// AddUser adds a user with password
func (s *MockWebDAVServer) AddUser(username, password string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.users[username] = password
}</span>

// Start starts the mock WebDAV server
func (s *MockWebDAVServer) Start() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.running </span><span class="cov0" title="0">{
                return fmt.Errorf("server already running")
        }</span>

        <span class="cov0" title="0">mux := http.NewServeMux()
        mux.HandleFunc("/", s.handleRequest)

        s.server = &amp;http.Server{
                Addr:    ":0",
                Handler: mux,
        }

        // Start server in a goroutine to get the port
        listener, err := net.Listen("tcp", ":0")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start listener: %w", err)
        }</span>

        <span class="cov0" title="0">s.port = listener.Addr().(*net.TCPAddr).Port
        s.running = true

        go func() </span><span class="cov0" title="0">{
                err := s.server.Serve(listener)
                if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.Error("WebDAV server error", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">s.logger.Info("Mock WebDAV server started", zap.Int("port", s.port))
        return nil</span>
}

// Stop stops the mock WebDAV server
func (s *MockWebDAVServer) Stop() error <span class="cov0" title="0">{
        s.mu.Lock()
        if !s.running </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return nil
        }</span>
        <span class="cov0" title="0">s.running = false
        s.mu.Unlock()

        if s.server != nil </span><span class="cov0" title="0">{
                err := s.server.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">s.logger.Info("Mock WebDAV server stopped")
        return nil</span>
}

// GetPort returns the port the server is listening on
func (s *MockWebDAVServer) GetPort() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.port
}</span>

// GetAddress returns the server address
func (s *MockWebDAVServer) GetAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("http://localhost:%d%s", s.GetPort(), s.basePath)
}</span>

// handleRequest handles HTTP requests
func (s *MockWebDAVServer) handleRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        s.logger.Debug("WebDAV request", zap.String("method", r.Method), zap.String("path", r.URL.Path))

        // Basic authentication
        if !s.authenticate(r) </span><span class="cov0" title="0">{
                w.Header().Set("WWW-Authenticate", `Basic realm="WebDAV"`)
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        // Remove base path prefix
        <span class="cov0" title="0">path := strings.TrimPrefix(r.URL.Path, s.basePath)
        if path == "" </span><span class="cov0" title="0">{
                path = "/"
        }</span>

        <span class="cov0" title="0">switch r.Method </span>{
        case "OPTIONS":<span class="cov0" title="0">
                s.handleOptions(w, r, path)</span>
        case "GET":<span class="cov0" title="0">
                s.handleGet(w, r, path)</span>
        case "HEAD":<span class="cov0" title="0">
                s.handleHead(w, r, path)</span>
        case "PROPFIND":<span class="cov0" title="0">
                s.handlePropfind(w, r, path)</span>
        case "PUT":<span class="cov0" title="0">
                s.handlePut(w, r, path)</span>
        case "DELETE":<span class="cov0" title="0">
                s.handleDelete(w, r, path)</span>
        case "MKCOL":<span class="cov0" title="0">
                s.handleMkcol(w, r, path)</span>
        case "COPY":<span class="cov0" title="0">
                s.handleCopy(w, r, path)</span>
        case "MOVE":<span class="cov0" title="0">
                s.handleMove(w, r, path)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// authenticate performs basic authentication
func (s *MockWebDAVServer) authenticate(r *http.Request) bool <span class="cov0" title="0">{
        username, password, ok := r.BasicAuth()
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">s.mu.RLock()
        defer s.mu.RUnlock()

        expectedPassword, exists := s.users[username]
        return exists &amp;&amp; expectedPassword == password</span>
}

// handleOptions handles OPTIONS requests
func (s *MockWebDAVServer) handleOptions(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        w.Header().Set("Allow", "OPTIONS, GET, HEAD, POST, PUT, DELETE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE")
        w.Header().Set("DAV", "1, 2")
        w.WriteHeader(http.StatusOK)
}</span>

// handleGet handles GET requests
func (s *MockWebDAVServer) handleGet(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        s.mu.RLock()
        file, exists := s.files[path]
        s.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">if file.IsDirectory </span><span class="cov0" title="0">{
                // Generate HTML listing for directories
                s.handleDirectoryListing(w, r, path)
                return
        }</span>

        // Serve file content
        <span class="cov0" title="0">w.Header().Set("Content-Type", file.ContentType)
        w.Header().Set("Content-Length", fmt.Sprintf("%d", file.Size))
        w.Header().Set("ETag", file.ETag)
        w.Header().Set("Last-Modified", file.ModTime.Format(time.RFC1123))

        w.WriteHeader(http.StatusOK)
        w.Write(file.Content)</span>
}

// handleHead handles HEAD requests
func (s *MockWebDAVServer) handleHead(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        s.mu.RLock()
        file, exists := s.files[path]
        s.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", file.ContentType)
        w.Header().Set("Content-Length", fmt.Sprintf("%d", file.Size))
        w.Header().Set("ETag", file.ETag)
        w.Header().Set("Last-Modified", file.ModTime.Format(time.RFC1123))

        w.WriteHeader(http.StatusOK)</span>
}

// handleDirectoryListing generates HTML directory listing
func (s *MockWebDAVServer) handleDirectoryListing(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        files := s.listFiles(path)

        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.WriteHeader(http.StatusOK)

        fmt.Fprintf(w, "&lt;html&gt;&lt;head&gt;&lt;title&gt;Directory: %s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;", path)
        fmt.Fprintf(w, "&lt;h1&gt;Directory: %s&lt;/h1&gt;&lt;ul&gt;", path)

        if path != "/" </span><span class="cov0" title="0">{
                fmt.Fprintf(w, `&lt;li&gt;&lt;a href="../"&gt;../&lt;/a&gt;&lt;/li&gt;`)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                name := file.Name
                if file.IsDirectory </span><span class="cov0" title="0">{
                        name += "/"
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(w, `&lt;li&gt;&lt;a href="%s"&gt;%s&lt;/a&gt; (%d bytes)&lt;/li&gt;`, name, name, file.Size)</span>
        }

        <span class="cov0" title="0">fmt.Fprintf(w, "&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;")</span>
}

// handlePropfind handles PROPFIND requests
func (s *MockWebDAVServer) handlePropfind(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        depth := r.Header.Get("Depth")
        if depth == "" </span><span class="cov0" title="0">{
                depth = "1"
        }</span>

        <span class="cov0" title="0">s.mu.RLock()
        file, exists := s.files[path]
        s.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/xml; charset=utf-8")
        w.WriteHeader(http.StatusMultiStatus)

        // Generate WebDAV XML response
        fmt.Fprintf(w, `&lt;?xml version="1.0" encoding="utf-8"?&gt;`)
        fmt.Fprintf(w, `&lt;D:multistatus xmlns:D="DAV:"&gt;`)

        // Add current resource
        s.writePropfindResponse(w, file)

        // Add children if depth &gt; 0 and it's a directory
        if depth != "0" &amp;&amp; file.IsDirectory </span><span class="cov0" title="0">{
                children := s.listFiles(path)
                for _, child := range children </span><span class="cov0" title="0">{
                        s.writePropfindResponse(w, child)
                }</span>
        }

        <span class="cov0" title="0">fmt.Fprintf(w, `&lt;/D:multistatus&gt;`)</span>
}

// writePropfindResponse writes a single resource response
func (s *MockWebDAVServer) writePropfindResponse(w http.ResponseWriter, file *MockWebDAVFile) <span class="cov0" title="0">{
        href := s.basePath + file.Path
        if file.IsDirectory &amp;&amp; !strings.HasSuffix(href, "/") </span><span class="cov0" title="0">{
                href += "/"
        }</span>

        <span class="cov0" title="0">resourceType := ""
        if file.IsDirectory </span><span class="cov0" title="0">{
                resourceType = "&lt;D:collection/&gt;"
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(w, `&lt;D:response&gt;`)
        fmt.Fprintf(w, `&lt;D:href&gt;%s&lt;/D:href&gt;`, href)
        fmt.Fprintf(w, `&lt;D:propstat&gt;`)
        fmt.Fprintf(w, `&lt;D:prop&gt;`)
        fmt.Fprintf(w, `&lt;D:displayname&gt;%s&lt;/D:displayname&gt;`, file.Name)
        fmt.Fprintf(w, `&lt;D:getcontentlength&gt;%d&lt;/D:getcontentlength&gt;`, file.Size)
        fmt.Fprintf(w, `&lt;D:getcontenttype&gt;%s&lt;/D:getcontenttype&gt;`, file.ContentType)
        fmt.Fprintf(w, `&lt;D:getetag&gt;%s&lt;/D:getetag&gt;`, file.ETag)
        fmt.Fprintf(w, `&lt;D:getlastmodified&gt;%s&lt;/D:getlastmodified&gt;`, file.ModTime.Format(time.RFC1123))
        fmt.Fprintf(w, `&lt;D:resourcetype&gt;%s&lt;/D:resourcetype&gt;`, resourceType)
        fmt.Fprintf(w, `&lt;/D:prop&gt;`)
        fmt.Fprintf(w, `&lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt;`)
        fmt.Fprintf(w, `&lt;/D:propstat&gt;`)
        fmt.Fprintf(w, `&lt;/D:response&gt;`)</span>
}

// handlePut handles PUT requests
func (s *MockWebDAVServer) handlePut(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        content, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to read body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">contentType := r.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov0" title="0">{
                contentType = "application/octet-stream"
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        // Extract filename from path
        fileName := filepath.Base(path)

        s.files[path] = &amp;MockWebDAVFile{
                Name:        fileName,
                Path:        path,
                IsDirectory: false,
                Size:        int64(len(content)),
                ModTime:     time.Now(),
                Content:     content,
                ETag:        fmt.Sprintf(`"%x-%d"`, time.Now().Unix(), len(content)),
                ContentType: contentType,
        }

        w.WriteHeader(http.StatusCreated)</span>
}

// handleDelete handles DELETE requests
func (s *MockWebDAVServer) handleDelete(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if _, exists := s.files[path]; !exists </span><span class="cov0" title="0">{
                http.Error(w, "Not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">delete(s.files, path)
        w.WriteHeader(http.StatusNoContent)</span>
}

// handleMkcol handles MKCOL requests
func (s *MockWebDAVServer) handleMkcol(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if _, exists := s.files[path]; exists </span><span class="cov0" title="0">{
                http.Error(w, "Collection already exists", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">fileName := filepath.Base(path)

        s.files[path] = &amp;MockWebDAVFile{
                Name:        fileName,
                Path:        path,
                IsDirectory: true,
                Size:        0,
                ModTime:     time.Now(),
                Content:     []byte{},
                ETag:        fmt.Sprintf(`"%x-0"`, time.Now().Unix()),
                ContentType: "text/html",
        }

        w.WriteHeader(http.StatusCreated)</span>
}

// handleCopy handles COPY requests
func (s *MockWebDAVServer) handleCopy(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        destination := r.Header.Get("Destination")
        if destination == "" </span><span class="cov0" title="0">{
                http.Error(w, "Destination header required", http.StatusBadRequest)
                return
        }</span>

        // Parse destination URL to get path
        <span class="cov0" title="0">destPath := strings.TrimPrefix(destination, s.GetAddress())

        s.mu.Lock()
        defer s.mu.Unlock()

        sourceFile, exists := s.files[path]
        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Source not found", http.StatusNotFound)
                return
        }</span>

        // Create copy
        <span class="cov0" title="0">s.files[destPath] = &amp;MockWebDAVFile{
                Name:        filepath.Base(destPath),
                Path:        destPath,
                IsDirectory: sourceFile.IsDirectory,
                Size:        sourceFile.Size,
                ModTime:     time.Now(),
                Content:     append([]byte(nil), sourceFile.Content...),
                ETag:        fmt.Sprintf(`"%x-%d"`, time.Now().Unix(), sourceFile.Size),
                ContentType: sourceFile.ContentType,
        }

        w.WriteHeader(http.StatusCreated)</span>
}

// handleMove handles MOVE requests
func (s *MockWebDAVServer) handleMove(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        destination := r.Header.Get("Destination")
        if destination == "" </span><span class="cov0" title="0">{
                http.Error(w, "Destination header required", http.StatusBadRequest)
                return
        }</span>

        // Parse destination URL to get path
        <span class="cov0" title="0">destPath := strings.TrimPrefix(destination, s.GetAddress())

        s.mu.Lock()
        defer s.mu.Unlock()

        sourceFile, exists := s.files[path]
        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Source not found", http.StatusNotFound)
                return
        }</span>

        // Move file
        <span class="cov0" title="0">sourceFile.Path = destPath
        sourceFile.Name = filepath.Base(destPath)
        s.files[destPath] = sourceFile
        delete(s.files, path)

        w.WriteHeader(http.StatusCreated)</span>
}

// listFiles returns files in a directory
func (s *MockWebDAVServer) listFiles(path string) []*MockWebDAVFile <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var files []*MockWebDAVFile

        for filePath, file := range s.files </span><span class="cov0" title="0">{
                if filePath == path </span><span class="cov0" title="0">{
                        continue</span> // Skip the directory itself
                }

                // Check if file is a direct child of the path
                <span class="cov0" title="0">expectedPrefix := path
                if path == "/" </span><span class="cov0" title="0">{
                        expectedPrefix = "/"
                }</span> else<span class="cov0" title="0"> {
                        expectedPrefix = path + "/"
                }</span>

                <span class="cov0" title="0">if strings.HasPrefix(filePath, expectedPrefix) </span><span class="cov0" title="0">{
                        relativePath := strings.TrimPrefix(filePath, expectedPrefix)
                        if !strings.Contains(relativePath, "/") </span><span class="cov0" title="0">{
                                // Direct child
                                files = append(files, file)
                        }</span>
                }
        }

        // Sort files by name
        <span class="cov0" title="0">sort.Slice(files, func(i, j int) bool </span><span class="cov0" title="0">{
                return files[i].Name &lt; files[j].Name
        }</span>)

        <span class="cov0" title="0">return files</span>
}

// IsRunning returns true if the server is running
func (s *MockWebDAVServer) IsRunning() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.running
}</span>

// GetFileCount returns the number of files/directories
func (s *MockWebDAVServer) GetFileCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.files)
}</span>

// GetUserCount returns the number of users
func (s *MockWebDAVServer) GetUserCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.users)
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package tests

import (
        "fmt"
        "io"
        "log"
        "os"
        "testing"
)

// TestMain is the entry point for all tests
func TestMain(m *testing.M) <span class="cov0" title="0">{
        // Setup
        fmt.Println("Starting Catalogizer v3.0 Test Suite...")

        // Disable logging during tests for cleaner output
        log.SetOutput(io.Discard)

        // Run tests
        code := m.Run()

        // Cleanup
        fmt.Println("Test Suite Completed")

        os.Exit(code)
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package tests

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "net/http/httptest"
        "os"
        "path/filepath"
        "strings"
        "testing"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/services"

        _ "github.com/mattn/go-sqlite3"
)

// TestDatabase represents a test database instance
type TestDatabase struct {
        DB   *sql.DB
        Path string
}

// TestSuite represents a complete test suite with all dependencies
type TestSuite struct {
        DB                    *TestDatabase
        UserRepo              *repository.UserRepository
        AuthService           *services.AuthService
        AnalyticsRepo         *repository.AnalyticsRepository
        FavoritesRepo         *repository.FavoritesRepository
        ConversionRepo        *repository.ConversionRepository
        SyncRepo              *repository.SyncRepository
        StressTestRepo        *repository.StressTestRepository
        ErrorRepo             *repository.ErrorReportingRepository
        CrashRepo             *repository.CrashReportingRepository
        LogRepo               *repository.LogManagementRepository
        ConfigRepo            *repository.ConfigurationRepository
        AnalyticsService      *services.AnalyticsService
        FavoritesService      *services.FavoritesService
        ConversionService     *services.ConversionService
        SyncService           *services.SyncService
        StressTestService     *services.StressTestService
        ErrorReportingService *services.ErrorReportingService
        LogManagementService  *services.LogManagementService
        ConfigurationService  *services.ConfigurationService
}

// SetupTestDatabase creates a test database with all required tables
func SetupTestDatabase(t *testing.T) *TestDatabase <span class="cov4" title="7">{
        // Create temporary database file
        tempDir := t.TempDir()
        dbPath := filepath.Join(tempDir, "test.db")

        db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to open test database: %v", err)
        }</span>

        // Create all required tables
        <span class="cov4" title="7">if err := createTestTables(db); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test tables: %v", err)
        }</span>

        <span class="cov4" title="7">return &amp;TestDatabase{
                DB:   db,
                Path: dbPath,
        }</span>
}

// CleanupTestDatabase closes and removes the test database
func (td *TestDatabase) Cleanup() <span class="cov4" title="7">{
        if td.DB != nil </span><span class="cov4" title="7">{
                td.DB.Close()
        }</span>
        <span class="cov4" title="7">if td.Path != "" </span><span class="cov4" title="7">{
                os.Remove(td.Path)
        }</span>
}

// SetupTestSuite creates a complete test suite with all services and repositories
func SetupTestSuite(t *testing.T) *TestSuite <span class="cov4" title="7">{
        // Create test database
        testDB := SetupTestDatabase(t)

        // Create repositories
        userRepo := repository.NewUserRepository(testDB.DB)
        analyticsRepo := repository.NewAnalyticsRepository(testDB.DB)
        favoritesRepo := repository.NewFavoritesRepository(testDB.DB)
        conversionRepo := repository.NewConversionRepository(testDB.DB)
        syncRepo := repository.NewSyncRepository(testDB.DB)
        stressTestRepo := repository.NewStressTestRepository(testDB.DB)
        errorRepo := repository.NewErrorReportingRepository(testDB.DB)
        crashRepo := repository.NewCrashReportingRepository(testDB.DB)
        logRepo := repository.NewLogManagementRepository(testDB.DB)
        configRepo := repository.NewConfigurationRepository(testDB.DB)

        // Create auth service
        authService := services.NewAuthService(userRepo, "test-jwt-secret")

        // Create services
        analyticsService := services.NewAnalyticsService(analyticsRepo)
        favoritesService := services.NewFavoritesService(favoritesRepo, authService)
        conversionService := services.NewConversionService(conversionRepo, userRepo, authService)
        syncService := services.NewSyncService(syncRepo, userRepo, authService)
        stressTestService := services.NewStressTestService(stressTestRepo, authService)
        errorReportingService := services.NewErrorReportingService(errorRepo, crashRepo)
        logManagementService := services.NewLogManagementService(logRepo)
        configurationService := services.NewConfigurationService(configRepo, "/tmp/test_config.json")

        return &amp;TestSuite{
                DB:                    testDB,
                UserRepo:              userRepo,
                AuthService:           authService,
                AnalyticsRepo:         analyticsRepo,
                FavoritesRepo:         favoritesRepo,
                ConversionRepo:        conversionRepo,
                SyncRepo:              syncRepo,
                StressTestRepo:        stressTestRepo,
                ErrorRepo:             errorRepo,
                CrashRepo:             crashRepo,
                LogRepo:               logRepo,
                ConfigRepo:            configRepo,
                AnalyticsService:      analyticsService,
                FavoritesService:      favoritesService,
                ConversionService:     conversionService,
                SyncService:           syncService,
                StressTestService:     stressTestService,
                ErrorReportingService: errorReportingService,
                LogManagementService:  logManagementService,
                ConfigurationService:  configurationService,
        }
}</span>

// Cleanup cleans up the test suite
func (ts *TestSuite) Cleanup() <span class="cov4" title="7">{
        if ts.DB != nil </span><span class="cov4" title="7">{
                ts.DB.Cleanup()
        }</span>
}

// CreateTestUser creates a test user for testing
func CreateTestUser(t *testing.T, db *sql.DB, userID int) *models.User <span class="cov4" title="6">{
        user := &amp;models.User{
                ID:       userID,
                Username: fmt.Sprintf("testuser%d", userID),
                Email:    fmt.Sprintf("test%d@example.com", userID),
                RoleID:   1,
                IsActive: true,
        }

        query := `INSERT INTO users (id, username, email, role_id, is_active, created_at) VALUES (?, ?, ?, ?, ?, ?)`
        _, err := db.Exec(query, user.ID, user.Username, user.Email, user.RoleID, user.IsActive, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test user: %v", err)
        }</span>

        <span class="cov4" title="6">return user</span>
}

// CreateTestMediaItem creates a test media item for testing
func CreateTestMediaItem(t *testing.T, db *sql.DB, itemID int, userID int) *models.MediaItem <span class="cov0" title="0">{
        item := &amp;models.MediaItem{
                ID:     itemID,
                UserID: userID,
                Title:  fmt.Sprintf("Test Media %d", itemID),
                Type:   "video",
                Path:   fmt.Sprintf("/test/media/%d.mp4", itemID),
                Size:   1024 * 1024,
        }

        query := `INSERT INTO media_items (id, user_id, title, type, path, size, created_at, updated_at)
                          VALUES (?, ?, ?, ?, ?, ?, ?, ?)`
        _, err := db.Exec(query, item.ID, item.UserID, item.Title, item.Type, item.Path, item.Size, time.Now(), time.Now())
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test media item: %v", err)
        }</span>

        <span class="cov0" title="0">return item</span>
}

// AssertEqual checks if two values are equal
func AssertEqual(t *testing.T, expected, actual interface{}, message string) <span class="cov4" title="6">{
        if expected != actual </span><span class="cov0" title="0">{
                t.Errorf("%s: expected %v, got %v", message, expected, actual)
        }</span>
}

// AssertNotNil checks if a value is not nil
func AssertNotNil(t *testing.T, value interface{}, message string) <span class="cov4" title="6">{
        if value == nil </span><span class="cov0" title="0">{
                t.Errorf("%s: expected non-nil value", message)
        }</span>
}

// AssertNil checks if a value is nil
func AssertNil(t *testing.T, value interface{}, message string) <span class="cov0" title="0">{
        if value != nil </span><span class="cov0" title="0">{
                t.Errorf("%s: expected nil value, got %v", message, value)
        }</span>
}

// AssertError checks if an error occurred
func AssertError(t *testing.T, err error, message string) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                t.Errorf("%s: expected error but got none", message)
        }</span>
}

// AssertNoError checks if no error occurred
func AssertNoError(t *testing.T, err error, message string) <span class="cov5" title="14">{
        if err != nil </span><span class="cov0" title="0">{
                t.Errorf("%s: unexpected error: %v", message, err)
        }</span>
}

// AssertContains checks if a string contains a substring
func AssertContains(t *testing.T, str, substr, message string) <span class="cov0" title="0">{
        if !strings.Contains(str, substr) </span><span class="cov0" title="0">{
                t.Errorf("%s: expected '%s' to contain '%s'", message, str, substr)
        }</span>
}

// AssertHTTPStatus checks HTTP response status
func AssertHTTPStatus(t *testing.T, expected int, response *httptest.ResponseRecorder, message string) <span class="cov0" title="0">{
        if response.Code != expected </span><span class="cov0" title="0">{
                t.Errorf("%s: expected status %d, got %d", message, expected, response.Code)
        }</span>
}

// AssertJSONResponse checks JSON response structure
func AssertJSONResponse(t *testing.T, response *httptest.ResponseRecorder, expected interface{}, message string) <span class="cov0" title="0">{
        var actual interface{}
        err := json.Unmarshal(response.Body.Bytes(), &amp;actual)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("%s: failed to parse JSON response: %v", message, err)
        }</span>

        <span class="cov0" title="0">expectedJSON, _ := json.Marshal(expected)
        actualJSON, _ := json.Marshal(actual)

        if string(expectedJSON) != string(actualJSON) </span><span class="cov0" title="0">{
                t.Errorf("%s: JSON mismatch\nExpected: %s\nActual: %s", message, expectedJSON, actualJSON)
        }</span>
}

// MockHTTPServer creates a mock HTTP server for testing
func MockHTTPServer(handler http.HandlerFunc) *httptest.Server <span class="cov0" title="0">{
        return httptest.NewServer(handler)
}</span>

// WaitForCondition waits for a condition to be true with timeout
func WaitForCondition(t *testing.T, condition func() bool, timeout time.Duration, message string) <span class="cov0" title="0">{
        start := time.Now()
        for time.Since(start) &lt; timeout </span><span class="cov0" title="0">{
                if condition() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">time.Sleep(10 * time.Millisecond)</span>
        }
        <span class="cov0" title="0">t.Errorf("%s: condition not met within timeout", message)</span>
}

// GenerateTestData generates test data for various scenarios
type TestDataGenerator struct {
        UserID  int
        ItemID  int
        EventID int
}

func NewTestDataGenerator() *TestDataGenerator <span class="cov0" title="0">{
        return &amp;TestDataGenerator{
                UserID:  1000,
                ItemID:  2000,
                EventID: 3000,
        }
}</span>

func (g *TestDataGenerator) NextUserID() int <span class="cov0" title="0">{
        g.UserID++
        return g.UserID
}</span>

func (g *TestDataGenerator) NextItemID() int <span class="cov0" title="0">{
        g.ItemID++
        return g.ItemID
}</span>

func (g *TestDataGenerator) NextEventID() int <span class="cov0" title="0">{
        g.EventID++
        return g.EventID
}</span>

// createTestTables creates all required tables for testing
func createTestTables(db *sql.DB) error <span class="cov4" title="7">{
        tables := []string{
                // Users table
                `CREATE TABLE IF NOT EXISTS users (
                        id INTEGER PRIMARY KEY,
                        username TEXT UNIQUE NOT NULL,
                        email TEXT UNIQUE NOT NULL,
                        password_hash TEXT,
                        salt TEXT,
                        role_id INTEGER NOT NULL DEFAULT 1,
                        first_name TEXT,
                        last_name TEXT,
                        display_name TEXT,
                        avatar_url TEXT,
                        time_zone TEXT,
                        language TEXT,
                        settings TEXT DEFAULT '{}',
                        is_active BOOLEAN DEFAULT 1,
                        is_locked BOOLEAN DEFAULT 0,
                        locked_until DATETIME,
                        failed_login_attempts INTEGER DEFAULT 0,
                        last_login_at DATETIME,
                        last_login_ip TEXT,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,

                // Media items table
                `CREATE TABLE IF NOT EXISTS media_items (
                        id INTEGER PRIMARY KEY,
                        user_id INTEGER NOT NULL,
                        title TEXT NOT NULL,
                        type TEXT NOT NULL,
                        path TEXT NOT NULL,
                        size INTEGER,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Analytics events table
                `CREATE TABLE IF NOT EXISTS analytics_events (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER,
                        event_type TEXT NOT NULL,
                        event_category TEXT,
                        entity_type TEXT,
                        entity_id INTEGER,
                        data TEXT,
                        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                        session_id TEXT,
                        ip_address TEXT,
                        user_agent TEXT,
                        device_info TEXT,
                        location TEXT
                )`,

                // Favorites table
                `CREATE TABLE IF NOT EXISTS favorites (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        entity_type TEXT NOT NULL,
                        entity_id INTEGER NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        UNIQUE(user_id, entity_type, entity_id),
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Conversion jobs table
                `CREATE TABLE IF NOT EXISTS conversion_jobs (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        source_path TEXT NOT NULL,
                        target_path TEXT NOT NULL,
                        source_format TEXT NOT NULL,
                        target_format TEXT NOT NULL,
                        status TEXT NOT NULL DEFAULT 'pending',
                        progress INTEGER DEFAULT 0,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        started_at DATETIME,
                        completed_at DATETIME,
                        error_message TEXT,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Sync endpoints table
                `CREATE TABLE IF NOT EXISTS sync_endpoints (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        name TEXT NOT NULL,
                        type TEXT NOT NULL,
                        url TEXT NOT NULL,
                        username TEXT,
                        password TEXT,
                        settings TEXT,
                        status TEXT NOT NULL DEFAULT 'inactive',
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Sync sessions table
                `CREATE TABLE IF NOT EXISTS sync_sessions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        endpoint_id INTEGER NOT NULL,
                        status TEXT NOT NULL DEFAULT 'pending',
                        direction TEXT NOT NULL,
                        started_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        completed_at DATETIME,
                        files_processed INTEGER DEFAULT 0,
                        bytes_transferred INTEGER DEFAULT 0,
                        error_message TEXT,
                        FOREIGN KEY (endpoint_id) REFERENCES sync_endpoints(id)
                )`,

                // Stress tests table
                `CREATE TABLE IF NOT EXISTS stress_tests (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL,
                        description TEXT,
                        type TEXT NOT NULL,
                        status TEXT NOT NULL DEFAULT 'created',
                        scenarios TEXT,
                        configuration TEXT,
                        concurrent_users INTEGER NOT NULL,
                        duration_seconds INTEGER NOT NULL,
                        ramp_up_time INTEGER DEFAULT 0,
                        created_by INTEGER NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        started_at DATETIME,
                        completed_at DATETIME,
                        FOREIGN KEY (created_by) REFERENCES users(id)
                )`,

                // Stress test executions table
                `CREATE TABLE IF NOT EXISTS stress_test_executions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        stress_test_id INTEGER NOT NULL,
                        status TEXT NOT NULL DEFAULT 'pending',
                        started_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        completed_at DATETIME,
                        metrics TEXT,
                        results TEXT,
                        error_message TEXT,
                        FOREIGN KEY (stress_test_id) REFERENCES stress_tests(id)
                )`,

                // Error reports table
                `CREATE TABLE IF NOT EXISTS error_reports (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        level TEXT NOT NULL,
                        message TEXT NOT NULL,
                        error_code TEXT,
                        component TEXT,
                        stack_trace TEXT,
                        context TEXT,
                        system_info TEXT,
                        user_agent TEXT,
                        url TEXT,
                        fingerprint TEXT,
                        status TEXT NOT NULL DEFAULT 'new',
                        reported_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        resolved_at DATETIME,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Crash reports table
                `CREATE TABLE IF NOT EXISTS crash_reports (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        signal TEXT NOT NULL,
                        message TEXT NOT NULL,
                        stack_trace TEXT,
                        context TEXT,
                        system_info TEXT,
                        fingerprint TEXT,
                        status TEXT NOT NULL DEFAULT 'new',
                        reported_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        resolved_at DATETIME,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Log collections table
                `CREATE TABLE IF NOT EXISTS log_collections (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        name TEXT NOT NULL,
                        description TEXT,
                        components TEXT,
                        log_level TEXT,
                        start_time DATETIME,
                        end_time DATETIME,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        completed_at DATETIME,
                        status TEXT NOT NULL DEFAULT 'pending',
                        entry_count INTEGER DEFAULT 0,
                        filters TEXT,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Log entries table
                `CREATE TABLE IF NOT EXISTS log_entries (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        collection_id INTEGER NOT NULL,
                        timestamp DATETIME NOT NULL,
                        level TEXT NOT NULL,
                        component TEXT NOT NULL,
                        message TEXT NOT NULL,
                        context TEXT,
                        FOREIGN KEY (collection_id) REFERENCES log_collections(id)
                )`,

                // Log shares table
                `CREATE TABLE IF NOT EXISTS log_shares (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        collection_id INTEGER NOT NULL,
                        user_id INTEGER NOT NULL,
                        share_token TEXT UNIQUE NOT NULL,
                        share_type TEXT NOT NULL,
                        expires_at DATETIME NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        accessed_at DATETIME,
                        is_active BOOLEAN NOT NULL DEFAULT 1,
                        permissions TEXT,
                        recipients TEXT,
                        FOREIGN KEY (collection_id) REFERENCES log_collections(id),
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // System configuration table
                `CREATE TABLE IF NOT EXISTS system_configuration (
                        id INTEGER PRIMARY KEY DEFAULT 1,
                        version TEXT NOT NULL,
                        configuration TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,

                // Wizard progress table
                `CREATE TABLE IF NOT EXISTS wizard_progress (
                        user_id INTEGER PRIMARY KEY,
                        current_step TEXT NOT NULL,
                        step_data TEXT,
                        all_data TEXT,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Wizard completion table
                `CREATE TABLE IF NOT EXISTS wizard_completion (
                        user_id INTEGER PRIMARY KEY,
                        completed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Configuration history table
                `CREATE TABLE IF NOT EXISTS system_configuration_history (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        version TEXT NOT NULL,
                        configuration TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,

                // Configuration backups table
                `CREATE TABLE IF NOT EXISTS configuration_backups (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL,
                        version TEXT NOT NULL,
                        configuration TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,

                // Configuration templates table
                `CREATE TABLE IF NOT EXISTS configuration_templates (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL,
                        description TEXT,
                        category TEXT NOT NULL,
                        configuration TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,
        }

        for _, table := range tables </span><span class="cov10" title="140">{
                if _, err := db.Exec(table); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create table: %w", err)
                }</span>
        }

        <span class="cov4" title="7">return nil</span>
}

// Benchmark helper functions
func BenchmarkSetup(b *testing.B) *TestSuite <span class="cov0" title="0">{
        // Disable logging during benchmarks
        log.SetOutput(io.Discard)

        // Create a temporary database
        tempDir := b.TempDir()
        dbPath := filepath.Join(tempDir, "benchmark.db")

        db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                b.Fatalf("Failed to open benchmark database: %v", err)
        }</span>

        <span class="cov0" title="0">if err := createTestTables(db); err != nil </span><span class="cov0" title="0">{
                b.Fatalf("Failed to create benchmark tables: %v", err)
        }</span>

        <span class="cov0" title="0">testDB := &amp;TestDatabase{DB: db, Path: dbPath}

        // Create repositories
        userRepo := repository.NewUserRepository(testDB.DB)
        analyticsRepo := repository.NewAnalyticsRepository(testDB.DB)
        favoritesRepo := repository.NewFavoritesRepository(testDB.DB)
        conversionRepo := repository.NewConversionRepository(testDB.DB)
        syncRepo := repository.NewSyncRepository(testDB.DB)
        stressTestRepo := repository.NewStressTestRepository(testDB.DB)
        errorRepo := repository.NewErrorReportingRepository(testDB.DB)
        crashRepo := repository.NewCrashReportingRepository(testDB.DB)
        logRepo := repository.NewLogManagementRepository(testDB.DB)
        configRepo := repository.NewConfigurationRepository(testDB.DB)

        // Create auth service
        authService := services.NewAuthService(userRepo, "test-jwt-secret")

        // Create services
        analyticsService := services.NewAnalyticsService(analyticsRepo)
        favoritesService := services.NewFavoritesService(favoritesRepo, authService)
        conversionService := services.NewConversionService(conversionRepo, userRepo, authService)
        syncService := services.NewSyncService(syncRepo, userRepo, authService)
        stressTestService := services.NewStressTestService(stressTestRepo, authService)
        errorReportingService := services.NewErrorReportingService(errorRepo, crashRepo)
        logManagementService := services.NewLogManagementService(logRepo)
        configurationService := services.NewConfigurationService(configRepo, "/tmp/benchmark_config.json")

        return &amp;TestSuite{
                DB:                    testDB,
                UserRepo:              userRepo,
                AuthService:           authService,
                AnalyticsRepo:         analyticsRepo,
                FavoritesRepo:         favoritesRepo,
                ConversionRepo:        conversionRepo,
                SyncRepo:              syncRepo,
                StressTestRepo:        stressTestRepo,
                ErrorRepo:             errorRepo,
                CrashRepo:             crashRepo,
                LogRepo:               logRepo,
                ConfigRepo:            configRepo,
                AnalyticsService:      analyticsService,
                FavoritesService:      favoritesService,
                ConversionService:     conversionService,
                SyncService:           syncService,
                StressTestService:     stressTestService,
                ErrorReportingService: errorReportingService,
                LogManagementService:  logManagementService,
                ConfigurationService:  configurationService,
        }</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package utils

import (
        "log"

        "github.com/gin-gonic/gin"
)

// ErrorResponse represents an error response
type ErrorResponse struct {
        Success bool   `json:"success"`
        Error   string `json:"error"`
        Details string `json:"details,omitempty"`
}

// SuccessResponse represents a success response
type SuccessResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Message string      `json:"message,omitempty"`
}

// SendErrorResponse sends an error response
func SendErrorResponse(c *gin.Context, statusCode int, message string, err error) <span class="cov0" title="0">{
        response := ErrorResponse{
                Success: false,
                Error:   message,
        }

        if err != nil </span><span class="cov0" title="0">{
                response.Details = err.Error()
                log.Printf("Error: %s - %v", message, err)
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, response)</span>
}

// SendSuccessResponse sends a success response
func SendSuccessResponse(c *gin.Context, statusCode int, data interface{}, message string) <span class="cov0" title="0">{
        response := SuccessResponse{
                Success: true,
                Data:    data,
                Message: message,
        }

        c.JSON(statusCode, response)
}</span>

// StringPtr returns a pointer to the given string
func StringPtr(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
