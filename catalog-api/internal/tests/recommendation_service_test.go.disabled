package tests

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"catalogizer/internal/models"
	"catalogizer/internal/services"
)

func TestRecommendationService_GetSimilarItems(t *testing.T) {
	ctx := context.Background()

	// Setup services
	mediaRecognitionService := services.NewMediaRecognitionService()
	duplicateDetectionService := services.NewDuplicateDetectionService()
	recommendationService := services.NewRecommendationService(
		mediaRecognitionService,
		duplicateDetectionService,
	)

	t.Run("movie recommendations", func(t *testing.T) {
		originalMovie := &models.MediaMetadata{
			Title:       "The Matrix",
			Year:        "1999",
			Genre:       "Science Fiction",
			Director:    "The Wachowskis",
			MediaType:   models.MediaTypeVideo,
			FilePath:    "/movies/The.Matrix.1999.mkv",
			Rating:      8.7,
			Confidence:  0.95,
		}

		req := &services.SimilarItemsRequest{
			MediaID:             "matrix_1999",
			MediaMetadata:       originalMovie,
			MaxLocalItems:       10,
			MaxExternalItems:    5,
			IncludeExternal:     true,
			SimilarityThreshold: 0.3,
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)
		require.NotNil(t, response)

		// Verify response structure
		assert.NotEmpty(t, response.LocalItems)
		assert.NotEmpty(t, response.ExternalItems)
		assert.True(t, response.TotalFound > 0)
		assert.False(t, response.GeneratedAt.IsZero())
		assert.NotEmpty(t, response.Algorithms)
		assert.NotNil(t, response.Performance)

		// Verify local items
		for _, item := range response.LocalItems {
			assert.NotEmpty(t, item.MediaID)
			assert.NotNil(t, item.MediaMetadata)
			assert.True(t, item.SimilarityScore >= req.SimilarityThreshold)
			assert.NotEmpty(t, item.SimilarityReasons)
			assert.NotEmpty(t, item.DetailLink)
			assert.True(t, item.IsOwned) // Local items are owned
		}

		// Verify external items
		for _, item := range response.ExternalItems {
			assert.NotEmpty(t, item.ExternalID)
			assert.NotEmpty(t, item.Title)
			assert.NotEmpty(t, item.Provider)
			assert.NotEmpty(t, item.ExternalLink)
			assert.True(t, item.SimilarityScore > 0)
			assert.NotEmpty(t, item.SimilarityReasons)
		}

		// Verify sorting (highest similarity first)
		for i := 1; i < len(response.LocalItems); i++ {
			assert.True(t, response.LocalItems[i-1].SimilarityScore >= response.LocalItems[i].SimilarityScore)
		}
		for i := 1; i < len(response.ExternalItems); i++ {
			assert.True(t, response.ExternalItems[i-1].SimilarityScore >= response.ExternalItems[i].SimilarityScore)
		}
	})

	t.Run("music recommendations", func(t *testing.T) {
		originalSong := &models.MediaMetadata{
			Title:       "Bohemian Rhapsody",
			Artist:      "Queen",
			Album:       "A Night at the Opera",
			Year:        "1975",
			Genre:       "Rock",
			MediaType:   models.MediaTypeAudio,
			FilePath:    "/music/Queen - Bohemian Rhapsody.mp3",
			Duration:    355,
			Confidence:  0.96,
		}

		req := &services.SimilarItemsRequest{
			MediaID:             "queen_bohemian_rhapsody",
			MediaMetadata:       originalSong,
			MaxLocalItems:       8,
			MaxExternalItems:    3,
			IncludeExternal:     true,
			SimilarityThreshold: 0.4,
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)
		require.NotNil(t, response)

		assert.NotEmpty(t, response.LocalItems)
		assert.True(t, len(response.LocalItems) <= req.MaxLocalItems)
		assert.True(t, len(response.ExternalItems) <= req.MaxExternalItems)

		// Verify music-specific recommendations
		foundSameArtist := false
		foundSameGenre := false
		for _, item := range response.LocalItems {
			if item.MediaMetadata.Artist == originalSong.Artist {
				foundSameArtist = true
			}
			if item.MediaMetadata.Genre == originalSong.Genre {
				foundSameGenre = true
			}
		}
		assert.True(t, foundSameArtist || foundSameGenre, "Should find similar artist or genre")
	})

	t.Run("book recommendations", func(t *testing.T) {
		originalBook := &models.MediaMetadata{
			Title:       "Harry Potter and the Philosopher's Stone",
			Author:      "J.K. Rowling",
			Year:        "1997",
			Genre:       "Fantasy",
			Publisher:   "Bloomsbury",
			MediaType:   models.MediaTypeBook,
			FilePath:    "/books/Harry Potter.pdf",
			Pages:       223,
			Confidence:  0.98,
		}

		req := &services.SimilarItemsRequest{
			MediaID:             "harry_potter_1",
			MediaMetadata:       originalBook,
			MaxLocalItems:       5,
			MaxExternalItems:    5,
			IncludeExternal:     true,
			SimilarityThreshold: 0.2,
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)
		require.NotNil(t, response)

		// Verify book-specific recommendations
		for _, item := range response.LocalItems {
			assert.Equal(t, models.MediaTypeBook, item.MediaMetadata.MediaType)
		}

		for _, item := range response.ExternalItems {
			// External book items should have relevant providers
			validProviders := []string{"Google Books", "Open Library"}
			found := false
			for _, provider := range validProviders {
				if item.Provider == provider {
					found = true
					break
				}
			}
			assert.True(t, found, "Book recommendations should come from book-specific providers")
		}
	})

	t.Run("filtered recommendations", func(t *testing.T) {
		originalMovie := &models.MediaMetadata{
			Title:       "The Dark Knight",
			Year:        "2008",
			Genre:       "Action",
			MediaType:   models.MediaTypeVideo,
			FilePath:    "/movies/dark_knight.mkv",
			Rating:      9.0,
			Confidence:  0.95,
		}

		filters := &services.RecommendationFilters{
			GenreFilter: []string{"Action"},
			YearRange: &services.YearRange{
				StartYear: 2000,
				EndYear:   2015,
			},
			RatingRange: &services.RatingRange{
				MinRating: 7.0,
				MaxRating: 10.0,
			},
			MinConfidence: 0.8,
		}

		req := &services.SimilarItemsRequest{
			MediaID:             "dark_knight",
			MediaMetadata:       originalMovie,
			MaxLocalItems:       10,
			SimilarityThreshold: 0.3,
			Filters:             filters,
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)

		// Verify all returned items pass filters
		for _, item := range response.LocalItems {
			assert.Contains(t, item.MediaMetadata.Genre, "Action")
			if item.MediaMetadata.Year != "" {
				// Year filtering would be verified in real implementation
			}
			if item.MediaMetadata.Rating > 0 {
				assert.True(t, item.MediaMetadata.Rating >= 7.0)
				assert.True(t, item.MediaMetadata.Rating <= 10.0)
			}
			assert.True(t, item.SimilarityScore >= 0.8)
		}
	})

	t.Run("no external recommendations when disabled", func(t *testing.T) {
		req := &services.SimilarItemsRequest{
			MediaID: "test_media",
			MediaMetadata: &models.MediaMetadata{
				Title:     "Test Movie",
				MediaType: models.MediaTypeVideo,
			},
			MaxLocalItems:   5,
			IncludeExternal: false,
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)

		assert.Empty(t, response.ExternalItems)
		assert.Equal(t, 0, response.Performance.ExternalItemsFound)
		assert.Equal(t, time.Duration(0), response.Performance.ExternalSearchTime)
	})

	t.Run("similarity threshold filtering", func(t *testing.T) {
		req := &services.SimilarItemsRequest{
			MediaID: "test_media",
			MediaMetadata: &models.MediaMetadata{
				Title:     "Test Movie",
				MediaType: models.MediaTypeVideo,
			},
			MaxLocalItems:       10,
			SimilarityThreshold: 0.9, // Very high threshold
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)

		// All returned items should meet the high threshold
		for _, item := range response.LocalItems {
			assert.True(t, item.SimilarityScore >= 0.9)
		}
	})
}

func TestRecommendationService_ExternalProviders(t *testing.T) {
	ctx := context.Background()

	// Start mock servers for external APIs
	mockServers := StartAllMockServers()
	defer func() {
		for _, server := range mockServers {
			server.Close()
		}
	}()

	mediaRecognitionService := services.NewMediaRecognitionService()
	duplicateDetectionService := services.NewDuplicateDetectionService()
	recommendationService := services.NewRecommendationService(
		mediaRecognitionService,
		duplicateDetectionService,
	)

	t.Run("TMDb movie recommendations", func(t *testing.T) {
		movieMetadata := &models.MediaMetadata{
			Title:     "Inception",
			Year:      "2010",
			Genre:     "Sci-Fi",
			MediaType: models.MediaTypeVideo,
		}

		req := &services.SimilarItemsRequest{
			MediaID:         "inception",
			MediaMetadata:   movieMetadata,
			MaxLocalItems:   0, // Only external
			MaxExternalItems: 5,
			IncludeExternal: true,
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)

		// Should have TMDb recommendations
		tmdbFound := false
		for _, item := range response.ExternalItems {
			if item.Provider == "TMDb" {
				tmdbFound = true
				assert.NotEmpty(t, item.Title)
				assert.NotEmpty(t, item.ExternalLink)
				assert.Contains(t, item.ExternalLink, "themoviedb.org")
				break
			}
		}
		assert.True(t, tmdbFound, "Should find TMDb recommendations")
	})

	t.Run("Last.fm music recommendations", func(t *testing.T) {
		musicMetadata := &models.MediaMetadata{
			Title:     "Imagine",
			Artist:    "John Lennon",
			Genre:     "Rock",
			MediaType: models.MediaTypeAudio,
		}

		req := &services.SimilarItemsRequest{
			MediaID:         "imagine",
			MediaMetadata:   musicMetadata,
			MaxLocalItems:   0,
			MaxExternalItems: 5,
			IncludeExternal: true,
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)

		// Should have Last.fm recommendations
		lastfmFound := false
		for _, item := range response.ExternalItems {
			if item.Provider == "Last.fm" {
				lastfmFound = true
				assert.NotEmpty(t, item.Title)
				assert.NotEmpty(t, item.ExternalLink)
				assert.Contains(t, item.ExternalLink, "last.fm")
				break
			}
		}
		assert.True(t, lastfmFound, "Should find Last.fm recommendations")
	})

	t.Run("Google Books recommendations", func(t *testing.T) {
		bookMetadata := &models.MediaMetadata{
			Title:     "1984",
			Author:    "George Orwell",
			Genre:     "Dystopian Fiction",
			MediaType: models.MediaTypeBook,
		}

		req := &services.SimilarItemsRequest{
			MediaID:         "1984",
			MediaMetadata:   bookMetadata,
			MaxLocalItems:   0,
			MaxExternalItems: 5,
			IncludeExternal: true,
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)

		// Should have Google Books recommendations
		googleFound := false
		for _, item := range response.ExternalItems {
			if item.Provider == "Google Books" {
				googleFound = true
				assert.NotEmpty(t, item.Title)
				assert.NotEmpty(t, item.ExternalLink)
				break
			}
		}
		assert.True(t, googleFound, "Should find Google Books recommendations")
	})

	t.Run("IGDB game recommendations", func(t *testing.T) {
		gameMetadata := &models.MediaMetadata{
			Title:     "The Witcher 3",
			Developer: "CD Projekt RED",
			Genre:     "RPG",
			MediaType: models.MediaTypeGame,
		}

		req := &services.SimilarItemsRequest{
			MediaID:         "witcher3",
			MediaMetadata:   gameMetadata,
			MaxLocalItems:   0,
			MaxExternalItems: 5,
			IncludeExternal: true,
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)

		// Should have IGDB or Steam recommendations
		gameProviderFound := false
		for _, item := range response.ExternalItems {
			if item.Provider == "IGDB" || item.Provider == "Steam" {
				gameProviderFound = true
				assert.NotEmpty(t, item.Title)
				assert.NotEmpty(t, item.ExternalLink)
				break
			}
		}
		assert.True(t, gameProviderFound, "Should find game recommendations")
	})
}

func TestRecommendationService_Performance(t *testing.T) {
	ctx := context.Background()

	mediaRecognitionService := services.NewMediaRecognitionService()
	duplicateDetectionService := services.NewDuplicateDetectionService()
	recommendationService := services.NewRecommendationService(
		mediaRecognitionService,
		duplicateDetectionService,
	)

	t.Run("performance metrics", func(t *testing.T) {
		req := &services.SimilarItemsRequest{
			MediaID: "test_performance",
			MediaMetadata: &models.MediaMetadata{
				Title:     "Performance Test",
				MediaType: models.MediaTypeVideo,
			},
			MaxLocalItems:   10,
			MaxExternalItems: 5,
			IncludeExternal: true,
		}

		start := time.Now()
		response, err := recommendationService.GetSimilarItems(ctx, req)
		totalDuration := time.Since(start)

		require.NoError(t, err)
		require.NotNil(t, response.Performance)

		// Verify performance metrics are captured
		assert.True(t, response.Performance.LocalSearchTime > 0)
		assert.True(t, response.Performance.TotalTime > 0)
		assert.True(t, response.Performance.TotalTime >= response.Performance.LocalSearchTime)
		assert.True(t, totalDuration >= response.Performance.TotalTime)

		// Performance should be reasonable
		assert.True(t, response.Performance.TotalTime < 10*time.Second)

		// Metrics should be consistent
		assert.Equal(t, len(response.LocalItems), response.Performance.LocalItemsFound)
		assert.Equal(t, len(response.ExternalItems), response.Performance.ExternalItemsFound)
	})

	t.Run("large dataset performance", func(t *testing.T) {
		req := &services.SimilarItemsRequest{
			MediaID: "large_dataset_test",
			MediaMetadata: &models.MediaMetadata{
				Title:     "Large Dataset Test",
				MediaType: models.MediaTypeVideo,
			},
			MaxLocalItems:       50, // Large number
			MaxExternalItems:    20,
			IncludeExternal:     true,
			SimilarityThreshold: 0.1, // Low threshold for more results
		}

		start := time.Now()
		response, err := recommendationService.GetSimilarItems(ctx, req)
		duration := time.Since(start)

		require.NoError(t, err)

		// Should complete within reasonable time even with large dataset
		assert.True(t, duration < 15*time.Second)

		// Should respect limits
		assert.True(t, len(response.LocalItems) <= req.MaxLocalItems)
		assert.True(t, len(response.ExternalItems) <= req.MaxExternalItems)
	})
}

func TestRecommendationService_EdgeCases(t *testing.T) {
	ctx := context.Background()

	mediaRecognitionService := services.NewMediaRecognitionService()
	duplicateDetectionService := services.NewDuplicateDetectionService()
	recommendationService := services.NewRecommendationService(
		mediaRecognitionService,
		duplicateDetectionService,
	)

	t.Run("empty media metadata", func(t *testing.T) {
		req := &services.SimilarItemsRequest{
			MediaID: "empty_metadata",
			MediaMetadata: &models.MediaMetadata{
				MediaType: models.MediaTypeVideo,
				// All other fields empty
			},
			MaxLocalItems: 5,
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)

		// Should handle gracefully and return some results
		assert.NotNil(t, response)
		assert.True(t, response.TotalFound >= 0)
	})

	t.Run("very high similarity threshold", func(t *testing.T) {
		req := &services.SimilarItemsRequest{
			MediaID: "high_threshold",
			MediaMetadata: &models.MediaMetadata{
				Title:     "High Threshold Test",
				MediaType: models.MediaTypeVideo,
			},
			MaxLocalItems:       10,
			SimilarityThreshold: 0.99, // Very high
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)

		// May return few or no results due to high threshold
		for _, item := range response.LocalItems {
			assert.True(t, item.SimilarityScore >= 0.99)
		}
	})

	t.Run("zero limits", func(t *testing.T) {
		req := &services.SimilarItemsRequest{
			MediaID: "zero_limits",
			MediaMetadata: &models.MediaMetadata{
				Title:     "Zero Limits Test",
				MediaType: models.MediaTypeVideo,
			},
			MaxLocalItems:    0,
			MaxExternalItems: 0,
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)

		// Should respect limits
		assert.Empty(t, response.LocalItems)
		assert.Empty(t, response.ExternalItems)
		assert.Equal(t, 0, response.TotalFound)
	})

	t.Run("unknown media type", func(t *testing.T) {
		req := &services.SimilarItemsRequest{
			MediaID: "unknown_type",
			MediaMetadata: &models.MediaMetadata{
				Title:     "Unknown Type Test",
				MediaType: "unknown_type",
			},
			MaxLocalItems:   5,
			IncludeExternal: true,
		}

		response, err := recommendationService.GetSimilarItems(ctx, req)
		require.NoError(t, err)

		// Should handle gracefully
		assert.NotNil(t, response)
	})

	t.Run("missing media metadata", func(t *testing.T) {
		req := &services.SimilarItemsRequest{
			MediaID:       "missing_metadata",
			MediaMetadata: nil, // Missing metadata
			MaxLocalItems: 5,
		}

		// Should handle missing metadata gracefully
		// In a real implementation, it might fetch metadata by MediaID
		response, err := recommendationService.GetSimilarItems(ctx, req)

		// The service should either return an error or handle gracefully
		if err != nil {
			assert.Contains(t, err.Error(), "metadata")
		} else {
			assert.NotNil(t, response)
		}
	})

	t.Run("concurrent requests", func(t *testing.T) {
		numGoroutines := 10
		results := make(chan error, numGoroutines)

		for i := 0; i < numGoroutines; i++ {
			go func(id int) {
				req := &services.SimilarItemsRequest{
					MediaID: fmt.Sprintf("concurrent_test_%d", id),
					MediaMetadata: &models.MediaMetadata{
						Title:     fmt.Sprintf("Concurrent Test %d", id),
						MediaType: models.MediaTypeVideo,
					},
					MaxLocalItems:   5,
					IncludeExternal: false, // Disable external to reduce complexity
				}

				_, err := recommendationService.GetSimilarItems(ctx, req)
				results <- err
			}(i)
		}

		// Collect results
		for i := 0; i < numGoroutines; i++ {
			err := <-results
			assert.NoError(t, err, "Concurrent request %d should not fail", i)
		}
	})
}

func TestRecommendationService_SimilarityAlgorithms(t *testing.T) {
	mediaRecognitionService := services.NewMediaRecognitionService()
	duplicateDetectionService := services.NewDuplicateDetectionService()
	recommendationService := services.NewRecommendationService(
		mediaRecognitionService,
		duplicateDetectionService,
	)

	t.Run("title similarity", func(t *testing.T) {
		original := &models.MediaMetadata{
			Title:     "The Dark Knight",
			MediaType: models.MediaTypeVideo,
		}

		candidates := []*models.MediaMetadata{
			{Title: "The Dark Knight Rises", MediaType: models.MediaTypeVideo},
			{Title: "Dark Knight", MediaType: models.MediaTypeVideo},
			{Title: "Batman Begins", MediaType: models.MediaTypeVideo},
			{Title: "Completely Different Movie", MediaType: models.MediaTypeVideo},
		}

		similarities := make([]float64, len(candidates))
		for i, candidate := range candidates {
			similarity, _ := recommendationService.calculateLocalSimilarity(original, candidate)
			similarities[i] = similarity
		}

		// Title similarities should be in expected order
		assert.True(t, similarities[1] > similarities[2]) // "Dark Knight" > "Batman Begins"
		assert.True(t, similarities[2] > similarities[3]) // "Batman Begins" > "Completely Different"
	})

	t.Run("genre matching", func(t *testing.T) {
		original := &models.MediaMetadata{
			Title:     "Action Movie",
			Genre:     "Action",
			MediaType: models.MediaTypeVideo,
		}

		sameGenre := &models.MediaMetadata{
			Title:     "Another Action Movie",
			Genre:     "Action",
			MediaType: models.MediaTypeVideo,
		}

		differentGenre := &models.MediaMetadata{
			Title:     "Romance Movie",
			Genre:     "Romance",
			MediaType: models.MediaTypeVideo,
		}

		sameSimilarity, sameReasons := recommendationService.calculateLocalSimilarity(original, sameGenre)
		diffSimilarity, diffReasons := recommendationService.calculateLocalSimilarity(original, differentGenre)

		assert.True(t, sameSimilarity > diffSimilarity)
		assert.Contains(t, sameReasons, "same_genre")
		assert.NotContains(t, diffReasons, "same_genre")
	})

	t.Run("year matching", func(t *testing.T) {
		original := &models.MediaMetadata{
			Title:     "Movie 1999",
			Year:      "1999",
			MediaType: models.MediaTypeVideo,
		}

		sameYear := &models.MediaMetadata{
			Title:     "Another 1999 Movie",
			Year:      "1999",
			MediaType: models.MediaTypeVideo,
		}

		differentYear := &models.MediaMetadata{
			Title:     "2020 Movie",
			Year:      "2020",
			MediaType: models.MediaTypeVideo,
		}

		sameSimilarity, sameReasons := recommendationService.calculateLocalSimilarity(original, sameYear)
		diffSimilarity, diffReasons := recommendationService.calculateLocalSimilarity(original, differentYear)

		assert.True(t, sameSimilarity > diffSimilarity)
		assert.Contains(t, sameReasons, "same_year")
		assert.NotContains(t, diffReasons, "same_year")
	})

	t.Run("artist/author matching", func(t *testing.T) {
		// Test music artist matching
		originalSong := &models.MediaMetadata{
			Title:     "Song 1",
			Artist:    "Artist Name",
			MediaType: models.MediaTypeAudio,
		}

		sameArtist := &models.MediaMetadata{
			Title:     "Song 2",
			Artist:    "Artist Name",
			MediaType: models.MediaTypeAudio,
		}

		sameSimilarity, sameReasons := recommendationService.calculateLocalSimilarity(originalSong, sameArtist)
		assert.Contains(t, sameReasons, "same_artist")

		// Test book author matching
		originalBook := &models.MediaMetadata{
			Title:     "Book 1",
			Author:    "Author Name",
			MediaType: models.MediaTypeBook,
		}

		sameAuthor := &models.MediaMetadata{
			Title:     "Book 2",
			Author:    "Author Name",
			MediaType: models.MediaTypeBook,
		}

		bookSimilarity, bookReasons := recommendationService.calculateLocalSimilarity(originalBook, sameAuthor)
		assert.Contains(t, bookReasons, "same_author")
		assert.True(t, bookSimilarity > 0.5)
	})

	t.Run("media type matching", func(t *testing.T) {
		original := &models.MediaMetadata{
			Title:     "Test Item",
			MediaType: models.MediaTypeVideo,
		}

		sameType := &models.MediaMetadata{
			Title:     "Another Video",
			MediaType: models.MediaTypeVideo,
		}

		differentType := &models.MediaMetadata{
			Title:     "Audio File",
			MediaType: models.MediaTypeAudio,
		}

		sameSimilarity, sameReasons := recommendationService.calculateLocalSimilarity(original, sameType)
		diffSimilarity, diffReasons := recommendationService.calculateLocalSimilarity(original, differentType)

		assert.True(t, sameSimilarity > diffSimilarity)
		assert.Contains(t, sameReasons, "same_media_type")
		assert.NotContains(t, diffReasons, "same_media_type")
	})
}

func BenchmarkRecommendationService(b *testing.B) {
	ctx := context.Background()

	mediaRecognitionService := services.NewMediaRecognitionService()
	duplicateDetectionService := services.NewDuplicateDetectionService()
	recommendationService := services.NewRecommendationService(
		mediaRecognitionService,
		duplicateDetectionService,
	)

	req := &services.SimilarItemsRequest{
		MediaID: "benchmark_test",
		MediaMetadata: &models.MediaMetadata{
			Title:     "Benchmark Movie",
			Year:      "2023",
			Genre:     "Action",
			MediaType: models.MediaTypeVideo,
		},
		MaxLocalItems:       10,
		MaxExternalItems:    5,
		IncludeExternal:     false, // Disable external for consistent benchmarking
		SimilarityThreshold: 0.3,
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := recommendationService.GetSimilarItems(ctx, req)
		if err != nil {
			b.Fatalf("Benchmark failed: %v", err)
		}
	}
}