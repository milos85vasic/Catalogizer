
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>services: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">catalogizer/services/analytics_service.go (54.5%)</option>
				
				<option value="file1">catalogizer/services/auth_service.go (27.2%)</option>
				
				<option value="file2">catalogizer/services/challenge_service.go (69.4%)</option>
				
				<option value="file3">catalogizer/services/configuration_service.go (65.2%)</option>
				
				<option value="file4">catalogizer/services/configuration_wizard_service.go (45.1%)</option>
				
				<option value="file5">catalogizer/services/conversion_service.go (21.3%)</option>
				
				<option value="file6">catalogizer/services/error_reporting_service.go (43.3%)</option>
				
				<option value="file7">catalogizer/services/favorites_service.go (14.1%)</option>
				
				<option value="file8">catalogizer/services/log_management_service.go (37.1%)</option>
				
				<option value="file9">catalogizer/services/reporting_service.go (30.5%)</option>
				
				<option value="file10">catalogizer/services/sync_service.go (12.6%)</option>
				
				<option value="file11">catalogizer/services/webdav_client.go (2.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package services

import (
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type AnalyticsService struct {
        analyticsRepo *repository.AnalyticsRepository
}

func NewAnalyticsService(analyticsRepo *repository.AnalyticsRepository) *AnalyticsService <span class="cov8" title="1">{
        return &amp;AnalyticsService{
                analyticsRepo: analyticsRepo,
        }
}</span>

func (s *AnalyticsService) LogMediaAccess(access *models.MediaAccessLog) error <span class="cov0" title="0">{
        return s.analyticsRepo.LogMediaAccess(access)
}</span>

func (s *AnalyticsService) LogEvent(event *models.AnalyticsEvent) error <span class="cov0" title="0">{
        return s.analyticsRepo.LogEvent(event)
}</span>

func (s *AnalyticsService) GetMediaAccessLogs(userID int, mediaID *int, limit, offset int) ([]models.MediaAccessLog, error) <span class="cov0" title="0">{
        return s.analyticsRepo.GetMediaAccessLogs(userID, mediaID, limit, offset)
}</span>

func (s *AnalyticsService) GetUserAnalytics(userID int, startDate, endDate time.Time) (*models.UserAnalytics, error) <span class="cov0" title="0">{
        logs, err := s.analyticsRepo.GetUserMediaAccessLogs(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">events, err := s.analyticsRepo.GetUserEvents(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">analytics := &amp;models.UserAnalytics{
                UserID:               userID,
                StartDate:            startDate,
                EndDate:              endDate,
                TotalMediaAccesses:   len(logs),
                TotalEvents:          len(events),
                UniqueMediaAccessed:  s.countUniqueMedia(logs),
                TotalPlaybackTime:    s.calculateTotalPlaybackTime(logs),
                MostAccessedMedia:    s.findMostAccessedMedia(logs),
                PreferredAccessTimes: s.analyzeAccessTimes(logs),
                DeviceUsage:          s.analyzeDeviceUsage(logs),
                LocationAnalysis:     s.analyzeLocations(logs),
        }

        return analytics, nil</span>
}

func (s *AnalyticsService) GetSystemAnalytics(startDate, endDate time.Time) (*models.SystemAnalytics, error) <span class="cov0" title="0">{
        totalUsers, err := s.analyticsRepo.GetTotalUsers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">activeUsers, err := s.analyticsRepo.GetActiveUsers(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">totalMediaAccesses, err := s.analyticsRepo.GetTotalMediaAccesses(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">totalEvents, err := s.analyticsRepo.GetTotalEvents(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">topMedia, err := s.analyticsRepo.GetTopAccessedMedia(startDate, endDate, 10)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">userGrowth, err := s.analyticsRepo.GetUserGrowthData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">analytics := &amp;models.SystemAnalytics{
                StartDate:              startDate,
                EndDate:                endDate,
                TotalUsers:             totalUsers,
                ActiveUsers:            activeUsers,
                TotalMediaAccesses:     totalMediaAccesses,
                TotalEvents:            totalEvents,
                TopAccessedMedia:       topMedia,
                UserGrowthData:         userGrowth,
                AverageSessionDuration: s.calculateAverageSessionDuration(startDate, endDate),
                PeakUsageHours:         s.analyzePeakUsageHours(startDate, endDate),
                PopularFileTypes:       s.analyzePopularFileTypes(startDate, endDate),
                GeographicDistribution: s.analyzeGeographicDistribution(startDate, endDate),
        }

        return analytics, nil</span>
}

func (s *AnalyticsService) GetMediaAnalytics(mediaID int, startDate, endDate time.Time) (*models.MediaAnalytics, error) <span class="cov0" title="0">{
        logs, err := s.analyticsRepo.GetMediaAccessLogs(0, &amp;mediaID, 1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filteredLogs := s.filterLogsByDate(logs, startDate, endDate)

        analytics := &amp;models.MediaAnalytics{
                MediaID:             mediaID,
                StartDate:           startDate,
                EndDate:             endDate,
                TotalAccesses:       len(filteredLogs),
                UniqueUsers:         s.countUniqueUsers(filteredLogs),
                TotalPlaybackTime:   s.calculateTotalPlaybackTime(filteredLogs),
                AveragePlaybackTime: s.calculateAveragePlaybackTime(filteredLogs),
                AccessPatterns:      s.analyzeAccessPatterns(filteredLogs),
                UserRetention:       s.calculateUserRetention(filteredLogs),
                PopularTimeRanges:   s.analyzePopularTimeRanges(filteredLogs),
                DevicePreferences:   s.analyzeDevicePreferences(filteredLogs),
        }

        return analytics, nil</span>
}

func (s *AnalyticsService) CreateReport(reportType string, params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov8" title="1">{
        switch reportType </span>{
        case "user_activity":<span class="cov0" title="0">
                return s.generateUserActivityReport(params)</span>
        case "media_popularity":<span class="cov0" title="0">
                return s.generateMediaPopularityReport(params)</span>
        case "system_overview":<span class="cov0" title="0">
                return s.generateSystemOverviewReport(params)</span>
        case "geographic_analysis":<span class="cov0" title="0">
                return s.generateGeographicAnalysisReport(params)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported report type: %s", reportType)</span>
        }
}

func (s *AnalyticsService) generateUserActivityReport(params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">systemAnalytics, err := s.GetSystemAnalytics(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "analytics": systemAnalytics,
                "summary": map[string]interface{}{
                        "period":         fmt.Sprintf("%s to %s", startDate.Format("2006-01-02"), endDate.Format("2006-01-02")),
                        "active_users":   systemAnalytics.ActiveUsers,
                        "total_accesses": systemAnalytics.TotalMediaAccesses,
                },
        }

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.AnalyticsReport{
                Type:      "user_activity",
                Data:      string(dataJSON),
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil</span>
}

func (s *AnalyticsService) generateMediaPopularityReport(params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">topMedia, err := s.analyticsRepo.GetTopAccessedMedia(startDate, endDate, 50)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "top_media": topMedia,
                "period":    fmt.Sprintf("%s to %s", startDate.Format("2006-01-02"), endDate.Format("2006-01-02")),
                "total":     len(topMedia),
        }

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.AnalyticsReport{
                Type:      "media_popularity",
                Data:      string(dataJSON),
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil</span>
}

func (s *AnalyticsService) generateSystemOverviewReport(params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">systemAnalytics, err := s.GetSystemAnalytics(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "system_analytics": systemAnalytics,
                "summary": map[string]interface{}{
                        "health_score":     s.calculateSystemHealthScore(systemAnalytics),
                        "growth_rate":      s.calculateGrowthRate(systemAnalytics.UserGrowthData),
                        "engagement_level": s.calculateEngagementLevel(systemAnalytics),
                },
        }

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.AnalyticsReport{
                Type:      "system_overview",
                Data:      string(dataJSON),
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil</span>
}

func (s *AnalyticsService) generateGeographicAnalysisReport(params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">geographicData, err := s.analyticsRepo.GetGeographicData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "geographic_distribution": geographicData,
                "period":                  fmt.Sprintf("%s to %s", startDate.Format("2006-01-02"), endDate.Format("2006-01-02")),
                "top_locations":           s.getTopLocations(geographicData, 10),
        }

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.AnalyticsReport{
                Type:      "geographic_analysis",
                Data:      string(dataJSON),
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil</span>
}

func (s *AnalyticsService) countUniqueMedia(logs []models.MediaAccessLog) int <span class="cov8" title="1">{
        mediaSet := make(map[int]bool)
        for _, log := range logs </span><span class="cov8" title="1">{
                mediaSet[log.MediaID] = true
        }</span>
        <span class="cov8" title="1">return len(mediaSet)</span>
}

func (s *AnalyticsService) countUniqueUsers(logs []models.MediaAccessLog) int <span class="cov8" title="1">{
        userSet := make(map[int]bool)
        for _, log := range logs </span><span class="cov8" title="1">{
                userSet[log.UserID] = true
        }</span>
        <span class="cov8" title="1">return len(userSet)</span>
}

func (s *AnalyticsService) calculateTotalPlaybackTime(logs []models.MediaAccessLog) time.Duration <span class="cov8" title="1">{
        var total time.Duration
        for _, log := range logs </span><span class="cov8" title="1">{
                if log.PlaybackDuration != nil </span><span class="cov8" title="1">{
                        total += *log.PlaybackDuration
                }</span>
        }
        <span class="cov8" title="1">return total</span>
}

func (s *AnalyticsService) calculateAveragePlaybackTime(logs []models.MediaAccessLog) time.Duration <span class="cov8" title="1">{
        total := s.calculateTotalPlaybackTime(logs)
        if len(logs) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return total / time.Duration(len(logs))</span>
}

func (s *AnalyticsService) findMostAccessedMedia(logs []models.MediaAccessLog) []models.MediaAccessCount <span class="cov8" title="1">{
        counts := make(map[int]int)
        for _, log := range logs </span><span class="cov8" title="1">{
                counts[log.MediaID]++
        }</span>

        <span class="cov8" title="1">var results []models.MediaAccessCount
        for mediaID, count := range counts </span><span class="cov8" title="1">{
                results = append(results, models.MediaAccessCount{
                        MediaID:     mediaID,
                        AccessCount: count,
                })
        }</span>

        <span class="cov8" title="1">return results</span>
}

func (s *AnalyticsService) analyzeAccessTimes(logs []models.MediaAccessLog) map[string]int <span class="cov8" title="1">{
        hourCounts := make(map[string]int)
        for _, log := range logs </span><span class="cov8" title="1">{
                hour := log.AccessTime.Format("15")
                hourCounts[hour]++
        }</span>
        <span class="cov8" title="1">return hourCounts</span>
}

func (s *AnalyticsService) analyzeDeviceUsage(logs []models.MediaAccessLog) map[string]int <span class="cov8" title="1">{
        deviceCounts := make(map[string]int)
        for _, log := range logs </span><span class="cov8" title="1">{
                if log.DeviceInfo != nil </span><span class="cov8" title="1">{
                        deviceModel := ""
                        if log.DeviceInfo.DeviceModel != nil </span><span class="cov8" title="1">{
                                deviceModel = *log.DeviceInfo.DeviceModel
                        }</span>
                        <span class="cov8" title="1">platform := ""
                        if log.DeviceInfo.Platform != nil </span><span class="cov8" title="1">{
                                platform = *log.DeviceInfo.Platform
                        }</span>
                        <span class="cov8" title="1">deviceType := fmt.Sprintf("%s %s", platform, deviceModel)
                        deviceCounts[deviceType]++</span>
                }
        }
        <span class="cov8" title="1">return deviceCounts</span>
}

func (s *AnalyticsService) analyzeLocations(logs []models.MediaAccessLog) map[string]int <span class="cov8" title="1">{
        locationCounts := make(map[string]int)
        for _, log := range logs </span><span class="cov8" title="1">{
                if log.Location != nil </span><span class="cov8" title="1">{
                        location := fmt.Sprintf("%.2f,%.2f", log.Location.Latitude, log.Location.Longitude)
                        locationCounts[location]++
                }</span>
        }
        <span class="cov8" title="1">return locationCounts</span>
}

func (s *AnalyticsService) filterLogsByDate(logs []models.MediaAccessLog, startDate, endDate time.Time) []models.MediaAccessLog <span class="cov8" title="1">{
        var filtered []models.MediaAccessLog
        for _, log := range logs </span><span class="cov8" title="1">{
                if log.AccessTime.After(startDate) &amp;&amp; log.AccessTime.Before(endDate) </span><span class="cov8" title="1">{
                        filtered = append(filtered, log)
                }</span>
        }
        <span class="cov8" title="1">return filtered</span>
}

func (s *AnalyticsService) analyzeAccessPatterns(logs []models.MediaAccessLog) map[string]interface{} <span class="cov8" title="1">{
        patterns := make(map[string]interface{})

        hourlyPatterns := s.analyzeAccessTimes(logs)
        dailyPatterns := make(map[string]int)

        for _, log := range logs </span><span class="cov8" title="1">{
                day := log.AccessTime.Weekday().String()
                dailyPatterns[day]++
        }</span>

        <span class="cov8" title="1">patterns["hourly"] = hourlyPatterns
        patterns["daily"] = dailyPatterns

        return patterns</span>
}

func (s *AnalyticsService) calculateUserRetention(logs []models.MediaAccessLog) float64 <span class="cov8" title="1">{
        if len(logs) &lt;= 1 </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        <span class="cov8" title="1">userFirstAccess := make(map[int]time.Time)
        userLastAccess := make(map[int]time.Time)

        for _, log := range logs </span><span class="cov8" title="1">{
                if first, exists := userFirstAccess[log.UserID]; !exists || log.AccessTime.Before(first) </span><span class="cov8" title="1">{
                        userFirstAccess[log.UserID] = log.AccessTime
                }</span>
                <span class="cov8" title="1">if last, exists := userLastAccess[log.UserID]; !exists || log.AccessTime.After(last) </span><span class="cov8" title="1">{
                        userLastAccess[log.UserID] = log.AccessTime
                }</span>
        }

        <span class="cov8" title="1">totalRetention := 0.0
        userCount := 0

        for userID, firstAccess := range userFirstAccess </span><span class="cov8" title="1">{
                lastAccess := userLastAccess[userID]
                retention := lastAccess.Sub(firstAccess).Hours() / 24.0
                totalRetention += retention
                userCount++
        }</span>

        <span class="cov8" title="1">if userCount == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov8" title="1">return totalRetention / float64(userCount)</span>
}

func (s *AnalyticsService) analyzePopularTimeRanges(logs []models.MediaAccessLog) map[string]int <span class="cov8" title="1">{
        timeRanges := make(map[string]int)

        for _, log := range logs </span><span class="cov8" title="1">{
                hour := log.AccessTime.Hour()
                var timeRange string

                switch </span>{
                case hour &gt;= 6 &amp;&amp; hour &lt; 12:<span class="cov8" title="1">
                        timeRange = "morning"</span>
                case hour &gt;= 12 &amp;&amp; hour &lt; 18:<span class="cov8" title="1">
                        timeRange = "afternoon"</span>
                case hour &gt;= 18 &amp;&amp; hour &lt; 22:<span class="cov8" title="1">
                        timeRange = "evening"</span>
                default:<span class="cov8" title="1">
                        timeRange = "night"</span>
                }

                <span class="cov8" title="1">timeRanges[timeRange]++</span>
        }

        <span class="cov8" title="1">return timeRanges</span>
}

func (s *AnalyticsService) analyzeDevicePreferences(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        return s.analyzeDeviceUsage(logs)
}</span>

func (s *AnalyticsService) calculateAverageSessionDuration(startDate, endDate time.Time) time.Duration <span class="cov0" title="0">{
        sessions, err := s.analyticsRepo.GetSessionData(startDate, endDate)
        if err != nil || len(sessions) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var totalDuration time.Duration
        for _, session := range sessions </span><span class="cov0" title="0">{
                totalDuration += session.Duration
        }</span>

        <span class="cov0" title="0">return totalDuration / time.Duration(len(sessions))</span>
}

func (s *AnalyticsService) analyzePeakUsageHours(startDate, endDate time.Time) map[string]int <span class="cov0" title="0">{
        logs, err := s.analyticsRepo.GetAllMediaAccessLogs(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]int)
        }</span>

        <span class="cov0" title="0">return s.analyzeAccessTimes(logs)</span>
}

func (s *AnalyticsService) analyzePopularFileTypes(startDate, endDate time.Time) map[string]int <span class="cov0" title="0">{
        fileTypes, err := s.analyticsRepo.GetFileTypeData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]int)
        }</span>

        <span class="cov0" title="0">return fileTypes</span>
}

func (s *AnalyticsService) analyzeGeographicDistribution(startDate, endDate time.Time) map[string]interface{} <span class="cov0" title="0">{
        geographicData, err := s.analyticsRepo.GetGeographicData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">return geographicData</span>
}

func (s *AnalyticsService) calculateSystemHealthScore(analytics *models.SystemAnalytics) float64 <span class="cov8" title="1">{
        score := 0.0

        if analytics.TotalUsers &gt; 0 </span><span class="cov8" title="1">{
                activeUserRatio := float64(analytics.ActiveUsers) / float64(analytics.TotalUsers)
                score += activeUserRatio * 40
        }</span>

        <span class="cov8" title="1">if analytics.TotalMediaAccesses &gt; 0 </span><span class="cov8" title="1">{
                score += 30
        }</span>

        <span class="cov8" title="1">if analytics.TotalEvents &gt; 0 </span><span class="cov8" title="1">{
                score += 20
        }</span>

        <span class="cov8" title="1">if analytics.AverageSessionDuration &gt; time.Minute*5 </span><span class="cov8" title="1">{
                score += 10
        }</span>

        <span class="cov8" title="1">return score</span>
}

func (s *AnalyticsService) calculateGrowthRate(growthData []models.UserGrowthPoint) float64 <span class="cov8" title="1">{
        if len(growthData) &lt; 2 </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        <span class="cov8" title="1">first := growthData[0]
        last := growthData[len(growthData)-1]

        if first.UserCount == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        <span class="cov8" title="1">return (float64(last.UserCount) - float64(first.UserCount)) / float64(first.UserCount) * 100</span>
}

func (s *AnalyticsService) calculateEngagementLevel(analytics *models.SystemAnalytics) string <span class="cov8" title="1">{
        if analytics.TotalUsers == 0 </span><span class="cov8" title="1">{
                return "low"
        }</span>

        <span class="cov8" title="1">accessesPerUser := float64(analytics.TotalMediaAccesses) / float64(analytics.TotalUsers)

        switch </span>{
        case accessesPerUser &gt;= 50:<span class="cov8" title="1">
                return "high"</span>
        case accessesPerUser &gt;= 20:<span class="cov8" title="1">
                return "medium"</span>
        default:<span class="cov8" title="1">
                return "low"</span>
        }
}

func (s *AnalyticsService) getTopLocations(geographicData map[string]interface{}, limit int) []map[string]interface{} <span class="cov8" title="1">{
        var locations []map[string]interface{}

        if locationsData, ok := geographicData["locations"].([]map[string]interface{}); ok </span><span class="cov8" title="1">{
                for i, location := range locationsData </span><span class="cov8" title="1">{
                        if i &gt;= limit </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">locations = append(locations, location)</span>
                }
        }

        <span class="cov8" title="1">return locations</span>
}

// TrackEvent tracks an analytics event
func (s *AnalyticsService) TrackEvent(userID int, event *models.AnalyticsEventRequest) error <span class="cov0" title="0">{
        // Convert AnalyticsEventRequest to AnalyticsEvent
        data, _ := json.Marshal(event)
        analyticsEvent := &amp;models.AnalyticsEvent{
                UserID:    userID,
                EventType: event.EventType,
                Data:      string(data),
                Timestamp: time.Now(),
        }
        return s.LogEvent(analyticsEvent)
}</span>

// GetEventsByUser gets events for a user with filters
func (s *AnalyticsService) GetEventsByUser(userID int, filters *models.AnalyticsFilters) ([]models.AnalyticsEvent, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        return []models.AnalyticsEvent{}, nil
}</span>

// GetAnalytics gets analytics data with filters
func (s *AnalyticsService) GetAnalytics(userID int, filters *models.AnalyticsFilters) (*models.AnalyticsData, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        return &amp;models.AnalyticsData{}, nil
}</span>

// GetDashboardMetrics gets dashboard metrics
func (s *AnalyticsService) GetDashboardMetrics(userID int) (*models.DashboardMetrics, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        return &amp;models.DashboardMetrics{}, nil
}</span>

// GetRealtimeMetrics gets realtime metrics
func (s *AnalyticsService) GetRealtimeMetrics(userID int) (*models.RealtimeMetrics, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        return &amp;models.RealtimeMetrics{}, nil
}</span>

// GenerateReport generates an analytics report
func (s *AnalyticsService) GenerateReport(userID int, request *models.ReportRequest) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        // Stub implementation for testing
        return &amp;models.AnalyticsReport{
                Type:      request.ReportType,
                Data:      "{}",
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil
}</span>

// CleanupOldEvents cleans up old events
func (s *AnalyticsService) CleanupOldEvents(daysOld int) error <span class="cov0" title="0">{
        // This is a simplified implementation
        return nil
}</span>

func (s *AnalyticsService) extractDateRange(params map[string]interface{}) (time.Time, time.Time, error) <span class="cov8" title="1">{
        startDateStr, ok := params["start_date"].(string)
        if !ok </span><span class="cov8" title="1">{
                return time.Time{}, time.Time{}, fmt.Errorf("start_date parameter required")
        }</span>

        <span class="cov8" title="1">endDateStr, ok := params["end_date"].(string)
        if !ok </span><span class="cov8" title="1">{
                return time.Time{}, time.Time{}, fmt.Errorf("end_date parameter required")
        }</span>

        <span class="cov8" title="1">startDate, err := time.Parse("2006-01-02", startDateStr)
        if err != nil </span><span class="cov8" title="1">{
                return time.Time{}, time.Time{}, fmt.Errorf("invalid start_date format")
        }</span>

        <span class="cov8" title="1">endDate, err := time.Parse("2006-01-02", endDateStr)
        if err != nil </span><span class="cov8" title="1">{
                return time.Time{}, time.Time{}, fmt.Errorf("invalid end_date format")
        }</span>

        <span class="cov8" title="1">return startDate, endDate, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package services

import (
        "crypto/rand"
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "errors"
        "fmt"
        "regexp"
        "strconv"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "golang.org/x/crypto/bcrypt"

        "catalogizer/models"
        "catalogizer/repository"
)

// AuthService handles authentication and authorization
type AuthService struct {
        userRepo   *repository.UserRepository
        jwtSecret  []byte
        jwtExpiry  time.Duration
        refreshExp time.Duration
}

// NewAuthService creates a new authentication service
func NewAuthService(userRepo *repository.UserRepository, jwtSecret string) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{
                userRepo:   userRepo,
                jwtSecret:  []byte(jwtSecret),
                jwtExpiry:  24 * time.Hour,     // 24 hours
                refreshExp: 7 * 24 * time.Hour, // 7 days
        }
}</span>

// JWTClaims represents the claims in our JWT tokens
type JWTClaims struct {
        UserID    int    `json:"user_id"`
        Username  string `json:"username"`
        RoleID    int    `json:"role_id"`
        SessionID string `json:"session_id"`
        jwt.RegisteredClaims
}

// AuthResult represents the result of authentication
type AuthResult struct {
        User         *models.User `json:"user"`
        SessionToken string       `json:"session_token"`
        RefreshToken string       `json:"refresh_token"`
        ExpiresAt    time.Time    `json:"expires_at"`
}

// Login authenticates a user and creates a session
func (s *AuthService) Login(req models.LoginRequest, ipAddress string, userAgent string) (*AuthResult, error) <span class="cov0" title="0">{
        // Find user by username or email
        user, err := s.userRepo.GetByUsernameOrEmail(req.Username)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid credentials")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        // Check if user can login
        <span class="cov0" title="0">if !user.CanLogin() </span><span class="cov0" title="0">{
                if user.IsLocked </span><span class="cov0" title="0">{
                        return nil, errors.New("account is temporarily locked")
                }</span>
                <span class="cov0" title="0">return nil, errors.New("account is disabled")</span>
        }

        // Verify password
        <span class="cov0" title="0">if !s.verifyPassword(req.Password, user.Salt, user.PasswordHash) </span><span class="cov0" title="0">{
                // Increment failed login attempts
                s.userRepo.IncrementFailedLoginAttempts(user.ID)
                return nil, errors.New("invalid credentials")
        }</span>

        // Reset failed login attempts on successful login
        <span class="cov0" title="0">s.userRepo.ResetFailedLoginAttempts(user.ID)

        // Create session
        session, err := s.createSession(user, req.DeviceInfo, ipAddress, userAgent, req.RememberMe)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create session: %w", err)
        }</span>

        // Update last login information
        <span class="cov0" title="0">s.userRepo.UpdateLastLogin(user.ID, ipAddress)

        // Load user role
        role, err := s.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user role: %w", err)
        }</span>
        <span class="cov0" title="0">user.Role = role

        // Generate JWT token
        token, err := s.generateJWT(user, session.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // Generate refresh token
        <span class="cov0" title="0">refreshToken, err := s.generateRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        // Update session with tokens
        <span class="cov0" title="0">err = s.userRepo.UpdateSessionTokens(session.ID, token, refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update session tokens: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;AuthResult{
                User:         user,
                SessionToken: token,
                RefreshToken: refreshToken,
                ExpiresAt:    session.ExpiresAt,
        }, nil</span>
}

// RefreshToken refreshes an authentication token
func (s *AuthService) RefreshToken(refreshToken string) (*AuthResult, error) <span class="cov0" title="0">{
        // Find session by refresh token
        session, err := s.userRepo.GetSessionByRefreshToken(refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid refresh token")
        }</span>

        // Check if session is still valid
        <span class="cov0" title="0">if !session.IsActive || session.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, errors.New("session expired")
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := s.userRepo.GetByID(session.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        // Check if user can still login
        <span class="cov0" title="0">if !user.CanLogin() </span><span class="cov0" title="0">{
                // Deactivate session
                s.userRepo.DeactivateSession(session.ID)
                return nil, errors.New("account is disabled")
        }</span>

        // Load user role
        <span class="cov0" title="0">role, err := s.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user role: %w", err)
        }</span>
        <span class="cov0" title="0">user.Role = role

        // Generate new JWT token
        newToken, err := s.generateJWT(user, session.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // Generate new refresh token
        <span class="cov0" title="0">newRefreshToken, err := s.generateRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        // Update session with new tokens and extend expiry
        <span class="cov0" title="0">newExpiry := time.Now().Add(s.refreshExp)
        err = s.userRepo.UpdateSessionTokensAndExpiry(session.ID, newToken, newRefreshToken, newExpiry)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update session: %w", err)
        }</span>

        // Update last activity
        <span class="cov0" title="0">s.userRepo.UpdateSessionActivity(session.ID)

        return &amp;AuthResult{
                User:         user,
                SessionToken: newToken,
                RefreshToken: newRefreshToken,
                ExpiresAt:    newExpiry,
        }, nil</span>
}

// Logout terminates a user session
func (s *AuthService) Logout(sessionToken string) error <span class="cov0" title="0">{
        claims, err := s.validateToken(sessionToken)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sessionID, _ := strconv.Atoi(claims.SessionID)
        return s.userRepo.DeactivateSession(sessionID)</span>
}

// LogoutAll terminates all sessions for a user
func (s *AuthService) LogoutAll(userID int) error <span class="cov0" title="0">{
        return s.userRepo.DeactivateAllUserSessions(userID)
}</span>

// ValidateToken validates a JWT token and returns the claims
func (s *AuthService) ValidateToken(tokenString string) (*JWTClaims, error) <span class="cov0" title="0">{
        return s.validateToken(tokenString)
}</span>

// GetCurrentUser gets the current user from a JWT token
func (s *AuthService) GetCurrentUser(tokenString string) (*models.User, error) <span class="cov0" title="0">{
        claims, err := s.validateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if session is still active
        <span class="cov0" title="0">session, err := s.userRepo.GetSession(claims.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("session not found")
        }</span>

        <span class="cov0" title="0">if !session.IsActive || session.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, errors.New("session expired")
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := s.userRepo.GetByID(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        // Load user role
        <span class="cov0" title="0">role, err := s.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user role: %w", err)
        }</span>
        <span class="cov0" title="0">user.Role = role

        // Update session activity
        sessionID, _ := strconv.Atoi(claims.SessionID)
        s.userRepo.UpdateSessionActivity(sessionID)

        return user, nil</span>
}

// ChangePassword changes a user's password
func (s *AuthService) ChangePassword(userID int, currentPassword, newPassword string) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>

        // Verify current password
        <span class="cov0" title="0">if !s.verifyPassword(currentPassword, user.Salt, user.PasswordHash) </span><span class="cov0" title="0">{
                return errors.New("current password is incorrect")
        }</span>

        // Generate new salt and hash
        <span class="cov0" title="0">salt, err := s.generateSalt()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov0" title="0">passwordHash, err := s.hashPassword(newPassword, salt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Update password
        <span class="cov0" title="0">err = s.userRepo.UpdatePassword(userID, passwordHash, salt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        // Deactivate all sessions except current one (force re-login on other devices)
        // This is a security best practice when password changes
        <span class="cov0" title="0">return s.userRepo.DeactivateAllUserSessions(userID)</span>
}

// ResetPassword resets a user's password (admin function)
func (s *AuthService) ResetPassword(userID int, newPassword string) error <span class="cov0" title="0">{
        // Generate new salt and hash
        salt, err := s.generateSalt()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov0" title="0">passwordHash, err := s.hashPassword(newPassword, salt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Update password
        <span class="cov0" title="0">err = s.userRepo.UpdatePassword(userID, passwordHash, salt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        // Deactivate all sessions (force re-login)
        <span class="cov0" title="0">return s.userRepo.DeactivateAllUserSessions(userID)</span>
}

// CheckPermission checks if a user has a specific permission
func (s *AuthService) CheckPermission(userID int, permission string) (bool, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">role, err := s.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get user role: %w", err)
        }</span>

        <span class="cov0" title="0">return role.Permissions.HasPermission(permission), nil</span>
}

// Private helper methods

func (s *AuthService) createSession(user *models.User, deviceInfo models.DeviceInfo, ipAddress, userAgent string, rememberMe bool) (*models.UserSession, error) <span class="cov0" title="0">{
        sessionToken, err := s.generateSessionToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set expiry based on remember me
        <span class="cov0" title="0">expiry := time.Now().Add(s.jwtExpiry)
        if rememberMe </span><span class="cov0" title="0">{
                expiry = time.Now().Add(s.refreshExp)
        }</span>

        <span class="cov0" title="0">session := &amp;models.UserSession{
                UserID:         user.ID,
                SessionToken:   sessionToken,
                DeviceInfo:     deviceInfo,
                IPAddress:      &amp;ipAddress,
                UserAgent:      &amp;userAgent,
                IsActive:       true,
                ExpiresAt:      expiry,
                CreatedAt:      time.Now(),
                LastActivityAt: time.Now(),
        }

        id, err := s.userRepo.CreateSession(session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">session.ID = id
        return session, nil</span>
}

func (s *AuthService) generateJWT(user *models.User, sessionID int) (string, error) <span class="cov8" title="1">{
        now := time.Now()
        claims := JWTClaims{
                UserID:    user.ID,
                Username:  user.Username,
                RoleID:    user.RoleID,
                SessionID: fmt.Sprintf("%d", sessionID),
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(now.Add(s.jwtExpiry)),
                        IssuedAt:  jwt.NewNumericDate(now),
                        Issuer:    "catalogizer",
                        Subject:   fmt.Sprintf("%d", user.ID),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(s.jwtSecret)
}</span>

func (s *AuthService) validateToken(tokenString string) (*JWTClaims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return s.jwtSecret, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if claims, ok := token.Claims.(*JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}

func (s *AuthService) generateSessionToken() (string, error) <span class="cov8" title="1">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(bytes), nil</span>
}

func (s *AuthService) generateRefreshToken() (string, error) <span class="cov8" title="1">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(bytes), nil</span>
}

func (s *AuthService) generateSalt() (string, error) <span class="cov8" title="1">{
        bytes := make([]byte, 16)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(bytes), nil</span>
}

func (s *AuthService) hashPassword(password, salt string) (string, error) <span class="cov8" title="1">{
        // Combine password and salt
        combined := password + salt

        // Use bcrypt for additional security
        hash, err := bcrypt.GenerateFromPassword([]byte(combined), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return string(hash), nil</span>
}

func (s *AuthService) verifyPassword(password, salt, hash string) bool <span class="cov8" title="1">{
        // Combine password and salt
        combined := password + salt

        // Compare with bcrypt
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(combined))
        return err == nil
}</span>

// Session management methods

// GetActiveSessions returns all active sessions for a user
func (s *AuthService) GetActiveSessions(userID int) ([]models.UserSession, error) <span class="cov0" title="0">{
        return s.userRepo.GetActiveUserSessions(userID)
}</span>

// DeactivateSession deactivates a specific session
func (s *AuthService) DeactivateSession(sessionID int) error <span class="cov0" title="0">{
        return s.userRepo.DeactivateSession(sessionID)
}</span>

// CleanupExpiredSessions removes expired sessions from the database
func (s *AuthService) CleanupExpiredSessions() error <span class="cov0" title="0">{
        return s.userRepo.CleanupExpiredSessions()
}</span>

// UpdateSessionActivity updates the last activity time for a session
func (s *AuthService) UpdateSessionActivity(sessionID int) error <span class="cov0" title="0">{
        return s.userRepo.UpdateSessionActivity(sessionID)
}</span>

// Security utilities

// GenerateSecureToken generates a cryptographically secure random token
func (s *AuthService) GenerateSecureToken(length int) (string, error) <span class="cov8" title="1">{
        bytes := make([]byte, length)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(bytes), nil</span>
}

// HashData creates a SHA-256 hash of the given data
func (s *AuthService) HashData(data string) string <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(data))
        return hex.EncodeToString(hash[:])
}</span>

// HashPasswordForUser hashes a password with a generated salt (public method for registration)
func (s *AuthService) HashPasswordForUser(password string) (passwordHash string, saltStr string, err error) <span class="cov8" title="1">{
        // Generate salt
        saltStr, err = s.generateSalt()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Hash password with salt
        <span class="cov8" title="1">hash, err := s.hashPassword(password, saltStr)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">return hash, saltStr, nil</span>
}

// ValidatePassword checks if a password meets security requirements
func (s *AuthService) ValidatePassword(password string) error <span class="cov8" title="1">{
        if len(password) &lt; 8 </span><span class="cov8" title="1">{
                return errors.New("password must be at least 8 characters long")
        }</span>
        <span class="cov8" title="1">if len(password) &gt; 128 </span><span class="cov8" title="1">{
                return errors.New("password must be at most 128 characters long")
        }</span>
        // At least one uppercase letter
        <span class="cov8" title="1">uppercase := regexp.MustCompile(`[A-Z]`)
        if !uppercase.MatchString(password) </span><span class="cov8" title="1">{
                return errors.New("password must contain at least one uppercase letter")
        }</span>
        // At least one lowercase letter
        <span class="cov8" title="1">lowercase := regexp.MustCompile(`[a-z]`)
        if !lowercase.MatchString(password) </span><span class="cov8" title="1">{
                return errors.New("password must contain at least one lowercase letter")
        }</span>
        // At least one digit
        <span class="cov8" title="1">digit := regexp.MustCompile(`[0-9]`)
        if !digit.MatchString(password) </span><span class="cov8" title="1">{
                return errors.New("password must contain at least one digit")
        }</span>
        // At least one special character (non-alphanumeric, printable)
        <span class="cov8" title="1">special := regexp.MustCompile(`[^a-zA-Z0-9]`)
        if !special.MatchString(password) </span><span class="cov8" title="1">{
                return errors.New("password must contain at least one special character")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Account security methods

// LockAccount locks a user account until the specified time
func (s *AuthService) LockAccount(userID int, lockUntil time.Time) error <span class="cov0" title="0">{
        return s.userRepo.LockAccount(userID, lockUntil)
}</span>

// UnlockAccount unlocks a user account
func (s *AuthService) UnlockAccount(userID int) error <span class="cov0" title="0">{
        return s.userRepo.UnlockAccount(userID)
}</span>

// CheckAccountLockout checks if an account should be locked due to failed attempts
func (s *AuthService) CheckAccountLockout(userID int) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Lock account if too many failed attempts
        <span class="cov0" title="0">maxAttempts := 5 // This should be configurable
        if user.FailedLoginAttempts &gt;= maxAttempts </span><span class="cov0" title="0">{
                lockDuration := 30 * time.Minute // This should be configurable
                lockUntil := time.Now().Add(lockDuration)
                return s.LockAccount(userID, lockUntil)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package services

import (
        "context"
        "fmt"
        "path/filepath"
        "sync"
        "time"

        "digital.vasic.challenges/pkg/challenge"
        "digital.vasic.challenges/pkg/registry"
        "digital.vasic.challenges/pkg/runner"
)

// ChallengeService manages challenge registration, execution,
// and result retrieval.
type ChallengeService struct {
        mu         sync.RWMutex
        registry   *registry.DefaultRegistry
        runner     *runner.DefaultRunner
        resultsDir string
        results    []*challenge.Result
}

// NewChallengeService creates a new challenge service with
// the given results directory.
func NewChallengeService(resultsDir string) *ChallengeService <span class="cov8" title="1">{
        reg := registry.NewRegistry()
        r := runner.NewRunner(
                runner.WithRegistry(reg),
                runner.WithTimeout(72*time.Hour),
                runner.WithStaleThreshold(5*time.Minute),
                runner.WithResultsDir(resultsDir),
        )
        return &amp;ChallengeService{
                registry:   reg,
                runner:     r,
                resultsDir: resultsDir,
        }
}</span>

// Registry returns the underlying challenge registry for
// external registration.
func (s *ChallengeService) Registry() *registry.DefaultRegistry <span class="cov8" title="1">{
        return s.registry
}</span>

// Register adds a challenge to the registry.
func (s *ChallengeService) Register(c challenge.Challenge) error <span class="cov8" title="1">{
        return s.registry.Register(c)
}</span>

// ListChallenges returns all registered challenges as
// summary items.
func (s *ChallengeService) ListChallenges() []ChallengeSummary <span class="cov8" title="1">{
        challenges := s.registry.List()
        summaries := make([]ChallengeSummary, len(challenges))
        for i, c := range challenges </span><span class="cov8" title="1">{
                deps := c.Dependencies()
                depStrings := make([]string, len(deps))
                for j, d := range deps </span><span class="cov8" title="1">{
                        depStrings[j] = string(d)
                }</span>
                <span class="cov8" title="1">summaries[i] = ChallengeSummary{
                        ID:           string(c.ID()),
                        Name:         c.Name(),
                        Description:  c.Description(),
                        Category:     c.Category(),
                        Dependencies: depStrings,
                }</span>
        }
        <span class="cov8" title="1">return summaries</span>
}

// RunChallenge executes a single challenge by ID.
func (s *ChallengeService) RunChallenge(
        ctx context.Context, id string,
) (*challenge.Result, error) <span class="cov8" title="1">{
        cfg := &amp;challenge.Config{
                ResultsDir: filepath.Join(
                        s.resultsDir, id,
                        time.Now().Format("20060102_150405"),
                ),
                Timeout: 72 * time.Hour,
                Verbose: true,
        }
        result, err := s.runner.Run(
                ctx, challenge.ID(id), cfg,
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("run challenge %s: %w", id, err)
        }</span>

        <span class="cov8" title="1">s.mu.Lock()
        s.results = append(s.results, result)
        s.mu.Unlock()

        return result, nil</span>
}

// RunAll executes all challenges in dependency order.
func (s *ChallengeService) RunAll(
        ctx context.Context,
) ([]*challenge.Result, error) <span class="cov8" title="1">{
        cfg := &amp;challenge.Config{
                ResultsDir: filepath.Join(
                        s.resultsDir, "all",
                        time.Now().Format("20060102_150405"),
                ),
                Timeout: 72 * time.Hour,
                Verbose: true,
        }
        results, err := s.runner.RunAll(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return results, fmt.Errorf("run all challenges: %w", err)
        }</span>

        <span class="cov8" title="1">s.mu.Lock()
        s.results = append(s.results, results...)
        s.mu.Unlock()

        return results, nil</span>
}

// RunByCategory executes all challenges in a category.
func (s *ChallengeService) RunByCategory(
        ctx context.Context, category string,
) ([]*challenge.Result, error) <span class="cov0" title="0">{
        challenges := s.registry.ListByCategory(category)
        if len(challenges) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(
                        "no challenges found for category: %s", category,
                )
        }</span>

        <span class="cov0" title="0">ids := make([]challenge.ID, len(challenges))
        for i, c := range challenges </span><span class="cov0" title="0">{
                ids[i] = c.ID()
        }</span>

        <span class="cov0" title="0">cfg := &amp;challenge.Config{
                ResultsDir: filepath.Join(
                        s.resultsDir, "category", category,
                        time.Now().Format("20060102_150405"),
                ),
                Timeout: 72 * time.Hour,
                Verbose: true,
        }
        results, err := s.runner.RunSequence(ctx, ids, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return results, fmt.Errorf(
                        "run category %s: %w", category, err,
                )
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        s.results = append(s.results, results...)
        s.mu.Unlock()

        return results, nil</span>
}

// GetResults returns all stored challenge results.
func (s *ChallengeService) GetResults() []*challenge.Result <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        out := make([]*challenge.Result, len(s.results))
        copy(out, s.results)
        return out
}</span>

// ChallengeSummary is a lightweight representation of a
// registered challenge.
type ChallengeSummary struct {
        ID           string   `json:"id"`
        Name         string   `json:"name"`
        Description  string   `json:"description"`
        Category     string   `json:"category"`
        Dependencies []string `json:"dependencies"`
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package services

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "reflect"
        "sort"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"

        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

type ConfigurationService struct {
        configRepo  *repository.ConfigurationRepository
        configPath  string
        config      *models.SystemConfiguration
        wizardSteps []*models.WizardStep
        validators  map[string]ConfigValidator
}

type ConfigValidator interface {
        Validate(value interface{}) error
}

type DatabaseValidator struct{}
type NetworkValidator struct{}
type PathValidator struct{}
type EmailValidator struct{}

func NewConfigurationService(configRepo *repository.ConfigurationRepository, configPath string) *ConfigurationService <span class="cov0" title="0">{
        service := &amp;ConfigurationService{
                configRepo: configRepo,
                configPath: configPath,
                validators: make(map[string]ConfigValidator),
        }

        // Register validators
        service.validators["database"] = &amp;DatabaseValidator{}
        service.validators["network"] = &amp;NetworkValidator{}
        service.validators["path"] = &amp;PathValidator{}
        service.validators["email"] = &amp;EmailValidator{}

        // Initialize wizard steps
        service.initializeWizardSteps()

        // Load current configuration
        service.loadConfiguration()

        return service
}</span>

func (s *ConfigurationService) initializeWizardSteps() <span class="cov8" title="1">{
        s.wizardSteps = []*models.WizardStep{
                {
                        ID:          "welcome",
                        Name:        "Welcome",
                        Description: "Welcome to Catalogizer Setup Wizard",
                        Type:        models.WizardStepTypeInfo,
                        Required:    true,
                        Order:       1,
                        Content: map[string]interface{}{
                                "title":   "Welcome to Catalogizer v3.0",
                                "message": "This wizard will help you configure your media cataloging system.",
                        },
                },
                {
                        ID:          "database",
                        Name:        "Database Configuration",
                        Description: "Configure your database connection",
                        Type:        models.WizardStepTypeForm,
                        Required:    true,
                        Order:       2,
                        Fields: []*models.WizardField{
                                {
                                        Name:         "database_type",
                                        Label:        "Database Type",
                                        Type:         "select",
                                        Required:     true,
                                        Options:      []string{"sqlite", "mysql", "postgresql"},
                                        DefaultValue: "sqlite",
                                },
                                {
                                        Name:         "database_host",
                                        Label:        "Database Host",
                                        Type:         "text",
                                        Required:     false,
                                        DefaultValue: "localhost",
                                        ShowWhen:     map[string]interface{}{"database_type": []string{"mysql", "postgresql"}},
                                },
                                {
                                        Name:         "database_port",
                                        Label:        "Database Port",
                                        Type:         "number",
                                        Required:     false,
                                        DefaultValue: 3306,
                                        ShowWhen:     map[string]interface{}{"database_type": []string{"mysql", "postgresql"}},
                                },
                                {
                                        Name:         "database_name",
                                        Label:        "Database Name",
                                        Type:         "text",
                                        Required:     true,
                                        DefaultValue: "catalogizer",
                                },
                                {
                                        Name:     "database_username",
                                        Label:    "Database Username",
                                        Type:     "text",
                                        Required: false,
                                        ShowWhen: map[string]interface{}{"database_type": []string{"mysql", "postgresql"}},
                                },
                                {
                                        Name:     "database_password",
                                        Label:    "Database Password",
                                        Type:     "password",
                                        Required: false,
                                        ShowWhen: map[string]interface{}{"database_type": []string{"mysql", "postgresql"}},
                                },
                        },
                        Validation: map[string]interface{}{
                                "validator": "database",
                        },
                },
                {
                        ID:          "storage",
                        Name:        "Storage Configuration",
                        Description: "Configure storage locations and settings",
                        Type:        models.WizardStepTypeForm,
                        Required:    true,
                        Order:       3,
                        Fields: []*models.WizardField{
                                {
                                        Name:         "media_directory",
                                        Label:        "Media Directory",
                                        Type:         "directory",
                                        Required:     true,
                                        DefaultValue: "/var/lib/catalogizer/media",
                                        Validation:   map[string]interface{}{"validator": "path"},
                                },
                                {
                                        Name:         "thumbnail_directory",
                                        Label:        "Thumbnail Directory",
                                        Type:         "directory",
                                        Required:     true,
                                        DefaultValue: "/var/lib/catalogizer/thumbnails",
                                        Validation:   map[string]interface{}{"validator": "path"},
                                },
                                {
                                        Name:         "temp_directory",
                                        Label:        "Temporary Directory",
                                        Type:         "directory",
                                        Required:     true,
                                        DefaultValue: "/tmp/catalogizer",
                                        Validation:   map[string]interface{}{"validator": "path"},
                                },
                                {
                                        Name:         "max_file_size",
                                        Label:        "Maximum File Size (MB)",
                                        Type:         "number",
                                        Required:     true,
                                        DefaultValue: 1000,
                                },
                                {
                                        Name:         "storage_quota",
                                        Label:        "Storage Quota (GB, 0 = unlimited)",
                                        Type:         "number",
                                        Required:     false,
                                        DefaultValue: 0,
                                },
                        },
                },
                {
                        ID:          "network",
                        Name:        "Network Configuration",
                        Description: "Configure network and API settings",
                        Type:        models.WizardStepTypeForm,
                        Required:    true,
                        Order:       4,
                        Fields: []*models.WizardField{
                                {
                                        Name:         "server_host",
                                        Label:        "Server Host",
                                        Type:         "text",
                                        Required:     true,
                                        DefaultValue: "0.0.0.0",
                                        Validation:   map[string]interface{}{"validator": "network"},
                                },
                                {
                                        Name:         "server_port",
                                        Label:        "Server Port",
                                        Type:         "number",
                                        Required:     true,
                                        DefaultValue: 8080,
                                        Validation:   map[string]interface{}{"validator": "network"},
                                },
                                {
                                        Name:         "enable_https",
                                        Label:        "Enable HTTPS",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: false,
                                },
                                {
                                        Name:     "ssl_cert_path",
                                        Label:    "SSL Certificate Path",
                                        Type:     "file",
                                        Required: false,
                                        ShowWhen: map[string]interface{}{"enable_https": true},
                                },
                                {
                                        Name:     "ssl_key_path",
                                        Label:    "SSL Private Key Path",
                                        Type:     "file",
                                        Required: false,
                                        ShowWhen: map[string]interface{}{"enable_https": true},
                                },
                                {
                                        Name:         "cors_origins",
                                        Label:        "CORS Allowed Origins",
                                        Type:         "text",
                                        Required:     false,
                                        DefaultValue: "*",
                                },
                        },
                },
                {
                        ID:          "authentication",
                        Name:        "Authentication Setup",
                        Description: "Configure authentication and security settings",
                        Type:        models.WizardStepTypeForm,
                        Required:    true,
                        Order:       5,
                        Fields: []*models.WizardField{
                                {
                                        Name:     "jwt_secret",
                                        Label:    "JWT Secret Key",
                                        Type:     "password",
                                        Required: true,
                                        Generate: true,
                                },
                                {
                                        Name:         "session_timeout",
                                        Label:        "Session Timeout (hours)",
                                        Type:         "number",
                                        Required:     true,
                                        DefaultValue: 24,
                                },
                                {
                                        Name:         "enable_registration",
                                        Label:        "Allow User Registration",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                                {
                                        Name:         "require_email_verification",
                                        Label:        "Require Email Verification",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: false,
                                },
                                {
                                        Name:       "admin_email",
                                        Label:      "Administrator Email",
                                        Type:       "email",
                                        Required:   true,
                                        Validation: map[string]interface{}{"validator": "email"},
                                },
                        },
                },
                {
                        ID:          "features",
                        Name:        "Feature Configuration",
                        Description: "Enable and configure advanced features",
                        Type:        models.WizardStepTypeForm,
                        Required:    false,
                        Order:       6,
                        Fields: []*models.WizardField{
                                {
                                        Name:         "enable_media_conversion",
                                        Label:        "Enable Media Format Conversion",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                                {
                                        Name:         "enable_webdav_sync",
                                        Label:        "Enable WebDAV Synchronization",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: false,
                                },
                                {
                                        Name:         "enable_error_reporting",
                                        Label:        "Enable Error Reporting",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                                {
                                        Name:         "enable_log_management",
                                        Label:        "Enable Log Management",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                        },
                },
                {
                        ID:          "external_services",
                        Name:        "External Services",
                        Description: "Configure integrations with external services",
                        Type:        models.WizardStepTypeForm,
                        Required:    false,
                        Order:       7,
                        Fields: []*models.WizardField{
                                {
                                        Name:     "smtp_host",
                                        Label:    "SMTP Host",
                                        Type:     "text",
                                        Required: false,
                                },
                                {
                                        Name:         "smtp_port",
                                        Label:        "SMTP Port",
                                        Type:         "number",
                                        Required:     false,
                                        DefaultValue: 587,
                                },
                                {
                                        Name:     "smtp_username",
                                        Label:    "SMTP Username",
                                        Type:     "text",
                                        Required: false,
                                },
                                {
                                        Name:     "smtp_password",
                                        Label:    "SMTP Password",
                                        Type:     "password",
                                        Required: false,
                                },
                                {
                                        Name:     "slack_webhook_url",
                                        Label:    "Slack Webhook URL",
                                        Type:     "text",
                                        Required: false,
                                },
                                {
                                        Name:         "enable_analytics",
                                        Label:        "Enable Analytics",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                        },
                },
                {
                        ID:          "summary",
                        Name:        "Configuration Summary",
                        Description: "Review your configuration before applying",
                        Type:        models.WizardStepTypeSummary,
                        Required:    true,
                        Order:       8,
                },
                {
                        ID:          "complete",
                        Name:        "Setup Complete",
                        Description: "Configuration has been applied successfully",
                        Type:        models.WizardStepTypeComplete,
                        Required:    true,
                        Order:       9,
                },
        }

        // Sort steps by order
        sort.Slice(s.wizardSteps, func(i, j int) bool </span><span class="cov8" title="1">{
                return s.wizardSteps[i].Order &lt; s.wizardSteps[j].Order
        }</span>)
}

func (s *ConfigurationService) GetWizardSteps() ([]*models.WizardStep, error) <span class="cov8" title="1">{
        return s.wizardSteps, nil
}</span>

func (s *ConfigurationService) GetWizardStep(stepID string) (*models.WizardStep, error) <span class="cov8" title="1">{
        for _, step := range s.wizardSteps </span><span class="cov8" title="1">{
                if step.ID == stepID </span><span class="cov8" title="1">{
                        return step, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, fmt.Errorf("wizard step not found: %s", stepID)</span>
}

func (s *ConfigurationService) ValidateWizardStep(stepID string, data map[string]interface{}) (*models.WizardStepValidation, error) <span class="cov8" title="1">{
        step, err := s.GetWizardStep(stepID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">validation := &amp;models.WizardStepValidation{
                StepID:   stepID,
                Valid:    true,
                Errors:   make(map[string]string),
                Warnings: make(map[string]string),
        }

        // Validate required fields
        for _, field := range step.Fields </span><span class="cov8" title="1">{
                value, exists := data[field.Name]

                if field.Required &amp;&amp; (!exists || s.isEmptyValue(value)) </span><span class="cov8" title="1">{
                        validation.Valid = false
                        validation.Errors[field.Name] = fmt.Sprintf("%s is required", field.Label)
                        continue</span>
                }

                // Validate field using validator
                <span class="cov8" title="1">if exists &amp;&amp; field.Validation != nil </span><span class="cov8" title="1">{
                        if validatorName, ok := field.Validation["validator"].(string); ok </span><span class="cov8" title="1">{
                                if validator, validatorExists := s.validators[validatorName]; validatorExists </span><span class="cov8" title="1">{
                                        if err := validator.Validate(value); err != nil </span><span class="cov8" title="1">{
                                                validation.Valid = false
                                                validation.Errors[field.Name] = err.Error()
                                        }</span>
                                }
                        }
                }
        }

        // Custom step validation
        <span class="cov8" title="1">if step.Validation != nil </span><span class="cov8" title="1">{
                if validatorName, ok := step.Validation["validator"].(string); ok </span><span class="cov8" title="1">{
                        if validator, exists := s.validators[validatorName]; exists </span><span class="cov8" title="1">{
                                if err := validator.Validate(data); err != nil </span><span class="cov0" title="0">{
                                        validation.Valid = false
                                        validation.Errors["_general"] = err.Error()
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return validation, nil</span>
}

func (s *ConfigurationService) SaveWizardProgress(userID int, stepID string, data map[string]interface{}) error <span class="cov0" title="0">{
        progress := &amp;models.WizardProgress{
                UserID:      userID,
                CurrentStep: stepID,
                StepData:    data,
                UpdatedAt:   time.Now(),
        }

        return s.configRepo.SaveWizardProgress(progress)
}</span>

func (s *ConfigurationService) GetWizardProgress(userID int) (*models.WizardProgress, error) <span class="cov0" title="0">{
        return s.configRepo.GetWizardProgress(userID)
}</span>

func (s *ConfigurationService) CompleteWizard(userID int, finalData map[string]interface{}) (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        // Generate the full configuration from wizard data
        config := s.generateConfiguration(finalData)

        // Validate the complete configuration
        if err := s.validateConfiguration(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        // Save configuration
        <span class="cov0" title="0">if err := s.SaveConfiguration(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save configuration: %w", err)
        }</span>

        // Mark wizard as completed
        <span class="cov0" title="0">if err := s.configRepo.MarkWizardCompleted(userID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to mark wizard as completed: %w", err)
        }</span>

        // Clean up wizard progress
        <span class="cov0" title="0">s.configRepo.DeleteWizardProgress(userID)

        return config, nil</span>
}

func (s *ConfigurationService) GetConfiguration() (*models.SystemConfiguration, error) <span class="cov8" title="1">{
        if s.config == nil </span><span class="cov0" title="0">{
                return s.loadConfiguration()
        }</span>
        <span class="cov8" title="1">return s.config, nil</span>
}

func (s *ConfigurationService) SaveConfiguration(config *models.SystemConfiguration) error <span class="cov8" title="1">{
        // Validate configuration
        if err := s.validateConfiguration(config); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        // Save to database
        <span class="cov0" title="0">if err := s.configRepo.SaveConfiguration(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration to database: %w", err)
        }</span>

        // Save to file
        <span class="cov0" title="0">if err := s.saveConfigurationFile(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration file: %w", err)
        }</span>

        <span class="cov0" title="0">s.config = config
        return nil</span>
}

func (s *ConfigurationService) UpdateConfiguration(updates map[string]interface{}) (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        config, err := s.GetConfiguration()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Apply updates using reflection
        <span class="cov0" title="0">configValue := reflect.ValueOf(config).Elem()
        for key, value := range updates </span><span class="cov0" title="0">{
                field := configValue.FieldByName(s.toCamelCase(key))
                if field.IsValid() &amp;&amp; field.CanSet() </span><span class="cov0" title="0">{
                        newValue := reflect.ValueOf(value)
                        if newValue.Type().ConvertibleTo(field.Type()) </span><span class="cov0" title="0">{
                                field.Set(newValue.Convert(field.Type()))
                        }</span>
                }
        }

        <span class="cov0" title="0">return config, s.SaveConfiguration(config)</span>
}

func (s *ConfigurationService) ResetConfiguration() error <span class="cov0" title="0">{
        // Create default configuration
        config := s.createDefaultConfiguration()

        return s.SaveConfiguration(config)
}</span>

func (s *ConfigurationService) ExportConfiguration() ([]byte, error) <span class="cov8" title="1">{
        config, err := s.GetConfiguration()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return json.MarshalIndent(config, "", "  ")</span>
}

func (s *ConfigurationService) ImportConfiguration(data []byte) (*models.SystemConfiguration, error) <span class="cov8" title="1">{
        var config models.SystemConfiguration
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse configuration: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.SaveConfiguration(&amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (s *ConfigurationService) GetConfigurationSchema() (*models.ConfigurationSchema, error) <span class="cov8" title="1">{
        return &amp;models.ConfigurationSchema{
                Version: "3.0.0",
                Sections: []*models.ConfigSection{
                        {
                                Name:        "Database",
                                Key:         "database",
                                Description: "Database configuration settings",
                                Fields:      s.getDatabaseFields(),
                        },
                        {
                                Name:        "Storage",
                                Key:         "storage",
                                Description: "Storage and file system settings",
                                Fields:      s.getStorageFields(),
                        },
                        {
                                Name:        "Network",
                                Key:         "network",
                                Description: "Network and API settings",
                                Fields:      s.getNetworkFields(),
                        },
                        {
                                Name:        "Authentication",
                                Key:         "authentication",
                                Description: "Authentication and security settings",
                                Fields:      s.getAuthenticationFields(),
                        },
                        {
                                Name:        "Features",
                                Key:         "features",
                                Description: "Feature toggles and advanced settings",
                                Fields:      s.getFeatureFields(),
                        },
                },
        }, nil
}</span>

func (s *ConfigurationService) TestConfiguration(config *models.SystemConfiguration) (*models.ConfigurationTest, error) <span class="cov8" title="1">{
        test := &amp;models.ConfigurationTest{
                TestedAt: time.Now(),
                Results:  make(map[string]*models.TestResult),
        }

        // Test database connection
        test.Results["database"] = s.testDatabaseConnection(config)

        // Test storage paths
        test.Results["storage"] = s.testStoragePaths(config)

        // Test network configuration
        test.Results["network"] = s.testNetworkConfiguration(config)

        // Test external services
        test.Results["external_services"] = s.testExternalServices(config)

        // Calculate overall status
        test.OverallStatus = "passed"
        for _, result := range test.Results </span><span class="cov8" title="1">{
                if result.Status == "failed" </span><span class="cov0" title="0">{
                        test.OverallStatus = "failed"
                        break</span>
                } else<span class="cov8" title="1"> if result.Status == "warning" &amp;&amp; test.OverallStatus == "passed" </span><span class="cov8" title="1">{
                        test.OverallStatus = "warning"
                }</span>
        }

        <span class="cov8" title="1">return test, nil</span>
}

// Helper methods

func (s *ConfigurationService) loadConfiguration() (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        // Try to load from database first
        config, err := s.configRepo.GetConfiguration()
        if err == nil </span><span class="cov0" title="0">{
                s.config = config
                return config, nil
        }</span>

        // Try to load from file
        <span class="cov0" title="0">if _, err := os.Stat(s.configPath); err == nil </span><span class="cov0" title="0">{
                config, err := s.loadConfigurationFile()
                if err == nil </span><span class="cov0" title="0">{
                        s.config = config
                        return config, nil
                }</span>
        }

        // Create default configuration
        <span class="cov0" title="0">config = s.createDefaultConfiguration()
        s.config = config
        return config, nil</span>
}

func (s *ConfigurationService) loadConfigurationFile() (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(s.configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var config models.SystemConfiguration
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (s *ConfigurationService) saveConfigurationFile(config *models.SystemConfiguration) error <span class="cov0" title="0">{
        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(s.configPath), 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(s.configPath, data, 0644)</span>
}

func (s *ConfigurationService) createDefaultConfiguration() *models.SystemConfiguration <span class="cov8" title="1">{
        return &amp;models.SystemConfiguration{
                Version:   "3.0.0",
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Database: &amp;models.DatabaseConfig{
                        Type: "sqlite",
                        Name: "catalogizer.db",
                },
                Storage: &amp;models.StorageConfig{
                        MediaDirectory:     "/var/lib/catalogizer/media",
                        ThumbnailDirectory: "/var/lib/catalogizer/thumbnails",
                        TempDirectory:      "/tmp/catalogizer",
                        MaxFileSize:        1000 * 1024 * 1024, // 1GB
                },
                Network: &amp;models.NetworkConfig{
                        Host: "0.0.0.0",
                        Port: 8080,
                        CORS: &amp;models.CORSConfig{
                                AllowedOrigins: []string{"*"},
                        },
                },
                Authentication: &amp;models.AuthenticationConfig{
                        SessionTimeout:           24 * time.Hour,
                        EnableRegistration:       true,
                        RequireEmailVerification: false,
                },
                Features: &amp;models.FeatureConfig{
                        MediaConversion: true,
                        ErrorReporting:  true,
                        LogManagement:   true,
                },
        }
}</span>

func (s *ConfigurationService) generateConfiguration(wizardData map[string]interface{}) *models.SystemConfiguration <span class="cov8" title="1">{
        config := s.createDefaultConfiguration()

        // Apply wizard data to configuration
        // This is a simplified implementation
        for key, value := range wizardData </span><span class="cov8" title="1">{
                switch key </span>{
                case "database_type":<span class="cov8" title="1">
                        if s, ok := value.(string); ok </span><span class="cov8" title="1">{
                                config.Database.Type = s
                        }</span>
                case "database_host":<span class="cov8" title="1">
                        if s, ok := value.(string); ok </span><span class="cov8" title="1">{
                                config.Database.Host = s
                        }</span>
                case "database_port":<span class="cov8" title="1">
                        if port, ok := value.(float64); ok </span><span class="cov8" title="1">{
                                config.Database.Port = int(port)
                        }</span>
                case "database_name":<span class="cov8" title="1">
                        if s, ok := value.(string); ok </span><span class="cov8" title="1">{
                                config.Database.Name = s
                        }</span>
                case "database_username":<span class="cov8" title="1">
                        if s, ok := value.(string); ok </span><span class="cov8" title="1">{
                                config.Database.Username = s
                        }</span>
                case "database_password":<span class="cov8" title="1">
                        if s, ok := value.(string); ok </span><span class="cov8" title="1">{
                                config.Database.Password = s
                        }</span>
                case "media_directory":<span class="cov8" title="1">
                        if s, ok := value.(string); ok </span><span class="cov8" title="1">{
                                config.Storage.MediaDirectory = s
                        }</span>
                case "thumbnail_directory":<span class="cov8" title="1">
                        if s, ok := value.(string); ok </span><span class="cov8" title="1">{
                                config.Storage.ThumbnailDirectory = s
                        }</span>
                case "temp_directory":<span class="cov8" title="1">
                        if s, ok := value.(string); ok </span><span class="cov8" title="1">{
                                config.Storage.TempDirectory = s
                        }</span>
                case "server_host":<span class="cov8" title="1">
                        if s, ok := value.(string); ok </span><span class="cov8" title="1">{
                                config.Network.Host = s
                        }</span>
                case "server_port":<span class="cov8" title="1">
                        if port, ok := value.(float64); ok </span><span class="cov8" title="1">{
                                config.Network.Port = int(port)
                        }</span>
                case "enable_https":<span class="cov8" title="1">
                        if b, ok := value.(bool); ok </span><span class="cov8" title="1">{
                                config.Network.HTTPS = &amp;models.HTTPSConfig{
                                        Enabled: b,
                                }
                        }</span>
                }
        }

        <span class="cov8" title="1">config.UpdatedAt = time.Now()
        return config</span>
}

func (s *ConfigurationService) validateConfiguration(config *models.SystemConfiguration) error <span class="cov8" title="1">{
        // Basic validation
        if config.Database == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("database configuration is required")
        }</span>

        <span class="cov8" title="1">if config.Storage == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("storage configuration is required")
        }</span>

        <span class="cov8" title="1">if config.Network == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("network configuration is required")
        }</span>

        // Validate database configuration
        <span class="cov8" title="1">if config.Database.Type == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("database type is required")
        }</span>

        // Validate storage paths
        <span class="cov8" title="1">if config.Storage.MediaDirectory == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("media directory is required")
        }</span>

        // Validate network configuration
        <span class="cov8" title="1">if config.Network.Port &lt;= 0 || config.Network.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid network port: %d", config.Network.Port)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *ConfigurationService) isEmptyValue(value interface{}) bool <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                return strings.TrimSpace(v) == ""</span>
        case []string:<span class="cov8" title="1">
                return len(v) == 0</span>
        case map[string]interface{}:<span class="cov8" title="1">
                return len(v) == 0</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func (s *ConfigurationService) toCamelCase(str string) string <span class="cov8" title="1">{
        parts := strings.Split(str, "_")
        for i := range parts </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        parts[i] = cases.Title(language.Und, cases.NoLower).String(parts[i])
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(parts, "")</span>
}

func (s *ConfigurationService) getDatabaseFields() []*models.ConfigField <span class="cov8" title="1">{
        return []*models.ConfigField{
                {Name: "type", Label: "Database Type", Type: "select", Required: true},
                {Name: "host", Label: "Host", Type: "text", Required: false},
                {Name: "port", Label: "Port", Type: "number", Required: false},
                {Name: "name", Label: "Database Name", Type: "text", Required: true},
                {Name: "username", Label: "Username", Type: "text", Required: false},
                {Name: "password", Label: "Password", Type: "password", Required: false},
        }
}</span>

func (s *ConfigurationService) getStorageFields() []*models.ConfigField <span class="cov8" title="1">{
        return []*models.ConfigField{
                {Name: "media_directory", Label: "Media Directory", Type: "directory", Required: true},
                {Name: "thumbnail_directory", Label: "Thumbnail Directory", Type: "directory", Required: true},
                {Name: "temp_directory", Label: "Temporary Directory", Type: "directory", Required: true},
                {Name: "max_file_size", Label: "Max File Size (MB)", Type: "number", Required: true},
        }
}</span>

func (s *ConfigurationService) getNetworkFields() []*models.ConfigField <span class="cov8" title="1">{
        return []*models.ConfigField{
                {Name: "host", Label: "Host", Type: "text", Required: true},
                {Name: "port", Label: "Port", Type: "number", Required: true},
                {Name: "enable_https", Label: "Enable HTTPS", Type: "checkbox", Required: false},
        }
}</span>

func (s *ConfigurationService) getAuthenticationFields() []*models.ConfigField <span class="cov8" title="1">{
        return []*models.ConfigField{
                {Name: "jwt_secret", Label: "JWT Secret", Type: "password", Required: true},
                {Name: "session_timeout", Label: "Session Timeout (hours)", Type: "number", Required: true},
                {Name: "enable_registration", Label: "Enable Registration", Type: "checkbox", Required: false},
        }
}</span>

func (s *ConfigurationService) getFeatureFields() []*models.ConfigField <span class="cov8" title="1">{
        return []*models.ConfigField{
                {Name: "media_conversion", Label: "Media Conversion", Type: "checkbox", Required: false},
                {Name: "error_reporting", Label: "Error Reporting", Type: "checkbox", Required: false},
                {Name: "log_management", Label: "Log Management", Type: "checkbox", Required: false},
        }
}</span>

func (s *ConfigurationService) testDatabaseConnection(config *models.SystemConfiguration) *models.TestResult <span class="cov8" title="1">{
        // Simplified test implementation
        return &amp;models.TestResult{
                Status:  "passed",
                Message: "Database connection test passed",
        }
}</span>

func (s *ConfigurationService) testStoragePaths(config *models.SystemConfiguration) *models.TestResult <span class="cov8" title="1">{
        // Test if storage directories are accessible
        paths := []string{
                config.Storage.MediaDirectory,
                config.Storage.ThumbnailDirectory,
                config.Storage.TempDirectory,
        }

        for _, path := range paths </span><span class="cov8" title="1">{
                if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return &amp;models.TestResult{
                                Status:  "warning",
                                Message: fmt.Sprintf("Directory does not exist: %s", path),
                        }
                }</span>
        }

        <span class="cov8" title="1">return &amp;models.TestResult{
                Status:  "passed",
                Message: "All storage paths are accessible",
        }</span>
}

func (s *ConfigurationService) testNetworkConfiguration(config *models.SystemConfiguration) *models.TestResult <span class="cov8" title="1">{
        // Simplified network test
        if config.Network.Port &lt; 1024 &amp;&amp; os.Getuid() != 0 </span><span class="cov8" title="1">{
                return &amp;models.TestResult{
                        Status:  "warning",
                        Message: "Port below 1024 requires root privileges",
                }
        }</span>

        <span class="cov8" title="1">return &amp;models.TestResult{
                Status:  "passed",
                Message: "Network configuration is valid",
        }</span>
}

func (s *ConfigurationService) testExternalServices(config *models.SystemConfiguration) *models.TestResult <span class="cov8" title="1">{
        // Test external service connections
        return &amp;models.TestResult{
                Status:  "passed",
                Message: "External services test passed",
        }
}</span>

// Validator implementations

func (v *DatabaseValidator) Validate(value interface{}) error <span class="cov8" title="1">{
        // Database validation logic
        return nil
}</span>

func (v *NetworkValidator) Validate(value interface{}) error <span class="cov8" title="1">{
        // Network validation logic
        return nil
}</span>

func (v *PathValidator) Validate(value interface{}) error <span class="cov8" title="1">{
        // Path validation logic
        if path, ok := value.(string); ok </span><span class="cov8" title="1">{
                if !filepath.IsAbs(path) </span><span class="cov8" title="1">{
                        return fmt.Errorf("path must be absolute")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (v *EmailValidator) Validate(value interface{}) error <span class="cov8" title="1">{
        // Email validation logic
        if email, ok := value.(string); ok </span><span class="cov8" title="1">{
                if !strings.Contains(email, "@") </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid email format")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package services

import (
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type ConfigurationWizardService struct {
        repo            *repository.ConfigurationRepository
        configPath      string
        backupPath      string
        templatesPath   string
        currentSession  *models.WizardSession
        validationRules map[string]ValidationRule
        configTemplates map[string]ConfigTemplate
}

// models.WizardSession is defined in models package

type WizardStep struct {
        StepID          string                 `json:"step_id"`
        Title           string                 `json:"title"`
        Description     string                 `json:"description"`
        StepType        string                 `json:"step_type"` // input, select, multi-select, file-upload, test
        Fields          []FieldDefinition      `json:"fields"`
        Dependencies    []string               `json:"dependencies"`
        ValidationRules []string               `json:"validation_rules"`
        HelpText        string                 `json:"help_text"`
        IsOptional      bool                   `json:"is_optional"`
        SkipCondition   map[string]interface{} `json:"skip_condition,omitempty"`
}

type FieldDefinition struct {
        FieldID      string                 `json:"field_id"`
        Label        string                 `json:"label"`
        Type         string                 `json:"type"` // text, password, number, boolean, select, file, directory
        Required     bool                   `json:"required"`
        DefaultValue interface{}            `json:"default_value,omitempty"`
        Options      []FieldOption          `json:"options,omitempty"`
        Validation   string                 `json:"validation,omitempty"`
        HelpText     string                 `json:"help_text,omitempty"`
        Placeholder  string                 `json:"placeholder,omitempty"`
        MinValue     *float64               `json:"min_value,omitempty"`
        MaxValue     *float64               `json:"max_value,omitempty"`
        Pattern      string                 `json:"pattern,omitempty"`
        Dependencies map[string]interface{} `json:"dependencies,omitempty"`
}

type FieldOption struct {
        Value       string `json:"value"`
        Label       string `json:"label"`
        Description string `json:"description,omitempty"`
}

type ValidationRule struct {
        RuleID       string                 `json:"rule_id"`
        Type         string                 `json:"type"` // required, format, range, custom
        ErrorMessage string                 `json:"error_message"`
        Parameters   map[string]interface{} `json:"parameters,omitempty"`
}

type ConfigTemplate struct {
        TemplateID    string                 `json:"template_id"`
        Name          string                 `json:"name"`
        Description   string                 `json:"description"`
        Category      string                 `json:"category"`
        Steps         []WizardStep           `json:"steps"`
        DefaultValues map[string]interface{} `json:"default_values"`
        Requirements  []string               `json:"requirements"`
        PostInstall   []PostInstallAction    `json:"post_install_actions"`
}

type PostInstallAction struct {
        ActionType  string                 `json:"action_type"` // service_restart, file_create, command_run, validation
        Description string                 `json:"description"`
        Parameters  map[string]interface{} `json:"parameters"`
        Required    bool                   `json:"required"`
}

// ConfigurationProfile is defined in models package

type SystemInfo struct {
        OS              string            `json:"os"`
        Architecture    string            `json:"architecture"`
        GoVersion       string            `json:"go_version"`
        CPUCores        int               `json:"cpu_cores"`
        MemoryGB        float64           `json:"memory_gb"`
        DiskSpaceGB     float64           `json:"disk_space_gb"`
        NetworkInfo     NetworkInfo       `json:"network_info"`
        InstalledTools  []string          `json:"installed_tools"`
        EnvironmentVars map[string]string `json:"environment_vars"`
        Recommendations []string          `json:"recommendations"`
}

type NetworkInfo struct {
        Hostname    string   `json:"hostname"`
        IPAddresses []string `json:"ip_addresses"`
        DNSServers  []string `json:"dns_servers"`
        HasInternet bool     `json:"has_internet"`
}

type InstallationRequest struct {
        ConfigType     string                 `json:"config_type"`
        QuickInstall   bool                   `json:"quick_install"`
        CustomConfig   map[string]interface{} `json:"custom_config,omitempty"`
        SkipTests      bool                   `json:"skip_tests"`
        BackupExisting bool                   `json:"backup_existing"`
}

type InstallationProgress struct {
        SessionID      string    `json:"session_id"`
        CurrentAction  string    `json:"current_action"`
        Progress       float64   `json:"progress"`
        CompletedSteps []string  `json:"completed_steps"`
        FailedSteps    []string  `json:"failed_steps"`
        EstimatedTime  string    `json:"estimated_time"`
        LastUpdate     time.Time `json:"last_update"`
        IsCompleted    bool      `json:"is_completed"`
        HasErrors      bool      `json:"has_errors"`
        ErrorMessage   string    `json:"error_message,omitempty"`
}

func NewConfigurationWizardService(repo *repository.ConfigurationRepository) *ConfigurationWizardService <span class="cov8" title="1">{
        configPath := os.Getenv("CONFIG_PATH")
        if configPath == "" </span><span class="cov8" title="1">{
                configPath = "./config"
        }</span>

        <span class="cov8" title="1">service := &amp;ConfigurationWizardService{
                repo:            repo,
                configPath:      configPath,
                backupPath:      filepath.Join(configPath, "backups"),
                templatesPath:   filepath.Join(configPath, "templates"),
                validationRules: make(map[string]ValidationRule),
                configTemplates: make(map[string]ConfigTemplate),
        }

        // Initialize default templates and validation rules
        service.initializeDefaultTemplates()
        service.initializeValidationRules()

        // Ensure directories exist
        os.MkdirAll(service.configPath, 0755)
        os.MkdirAll(service.backupPath, 0755)
        os.MkdirAll(service.templatesPath, 0755)

        return service</span>
}

func (s *ConfigurationWizardService) initializeDefaultTemplates() <span class="cov8" title="1">{
        // Basic Installation Template
        s.configTemplates["basic"] = ConfigTemplate{
                TemplateID:  "basic",
                Name:        "Basic Installation",
                Description: "Quick setup for basic Catalogizer functionality",
                Category:    "installation",
                Steps: []WizardStep{
                        {
                                StepID:      "system_check",
                                Title:       "System Requirements Check",
                                Description: "Verify system meets minimum requirements",
                                StepType:    "test",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "auto_fix",
                                                Label:        "Automatically fix issues where possible",
                                                Type:         "boolean",
                                                DefaultValue: true,
                                        },
                                },
                        },
                        {
                                StepID:      "database_config",
                                Title:       "Database Configuration",
                                Description: "Configure database connection",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "db_type",
                                                Label:        "Database Type",
                                                Type:         "select",
                                                Required:     true,
                                                DefaultValue: "sqlite",
                                                Options: []FieldOption{
                                                        {Value: "sqlite", Label: "SQLite (Recommended)"},
                                                        {Value: "mysql", Label: "MySQL"},
                                                        {Value: "postgresql", Label: "PostgreSQL"},
                                                },
                                        },
                                        {
                                                FieldID:      "db_path",
                                                Label:        "Database File Path",
                                                Type:         "file",
                                                Required:     true,
                                                DefaultValue: "./catalogizer.db",
                                                Dependencies: map[string]interface{}{
                                                        "db_type": "sqlite",
                                                },
                                        },
                                        {
                                                FieldID:  "db_host",
                                                Label:    "Database Host",
                                                Type:     "text",
                                                Required: true,
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                        {
                                                FieldID:  "db_port",
                                                Label:    "Database Port",
                                                Type:     "number",
                                                MinValue: float64Ptr(1),
                                                MaxValue: float64Ptr(65535),
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                        {
                                                FieldID:  "db_name",
                                                Label:    "Database Name",
                                                Type:     "text",
                                                Required: true,
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                        {
                                                FieldID:  "db_username",
                                                Label:    "Database Username",
                                                Type:     "text",
                                                Required: true,
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                        {
                                                FieldID:  "db_password",
                                                Label:    "Database Password",
                                                Type:     "password",
                                                Required: true,
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                },
                        },
                        {
                                StepID:      "media_storage",
                                Title:       "Media Storage Configuration",
                                Description: "Configure where media files will be stored",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "storage_type",
                                                Label:        "Storage Type",
                                                Type:         "select",
                                                Required:     true,
                                                DefaultValue: "local",
                                                Options: []FieldOption{
                                                        {Value: "local", Label: "Local Storage"},
                                                        {Value: "s3", Label: "Amazon S3"},
                                                        {Value: "webdav", Label: "WebDAV"},
                                                        {Value: "ftp", Label: "FTP/SFTP"},
                                                },
                                        },
                                        {
                                                FieldID:      "media_path",
                                                Label:        "Media Directory Path",
                                                Type:         "directory",
                                                Required:     true,
                                                DefaultValue: "./media",
                                                Dependencies: map[string]interface{}{
                                                        "storage_type": "local",
                                                },
                                        },
                                        {
                                                FieldID:      "max_file_size",
                                                Label:        "Maximum File Size (MB)",
                                                Type:         "number",
                                                Required:     true,
                                                DefaultValue: 100,
                                                MinValue:     float64Ptr(1),
                                                MaxValue:     float64Ptr(10000),
                                        },
                                },
                        },
                        {
                                StepID:      "security_config",
                                Title:       "Security Configuration",
                                Description: "Configure authentication and security settings",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:    "jwt_secret",
                                                Label:      "JWT Secret Key",
                                                Type:       "password",
                                                Required:   true,
                                                HelpText:   "Secret key for JWT token generation (minimum 32 characters)",
                                                Validation: "min_length:32",
                                        },
                                        {
                                                FieldID:      "session_timeout",
                                                Label:        "Session Timeout (hours)",
                                                Type:         "number",
                                                Required:     true,
                                                DefaultValue: 24,
                                                MinValue:     float64Ptr(1),
                                                MaxValue:     float64Ptr(720),
                                        },
                                        {
                                                FieldID:      "enable_2fa",
                                                Label:        "Enable Two-Factor Authentication",
                                                Type:         "boolean",
                                                DefaultValue: false,
                                        },
                                        {
                                                FieldID:      "password_min_length",
                                                Label:        "Minimum Password Length",
                                                Type:         "number",
                                                Required:     true,
                                                DefaultValue: 8,
                                                MinValue:     float64Ptr(6),
                                                MaxValue:     float64Ptr(128),
                                        },
                                },
                        },
                        {
                                StepID:      "admin_user",
                                Title:       "Administrator Account",
                                Description: "Create the initial administrator account",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:     "admin_username",
                                                Label:       "Administrator Username",
                                                Type:        "text",
                                                Required:    true,
                                                Validation:  "username",
                                                Placeholder: "admin",
                                        },
                                        {
                                                FieldID:     "admin_email",
                                                Label:       "Administrator Email",
                                                Type:        "text",
                                                Required:    true,
                                                Validation:  "email",
                                                Placeholder: "admin@example.com",
                                        },
                                        {
                                                FieldID:    "admin_password",
                                                Label:      "Administrator Password",
                                                Type:       "password",
                                                Required:   true,
                                                Validation: "password_strength",
                                        },
                                        {
                                                FieldID:    "admin_password_confirm",
                                                Label:      "Confirm Password",
                                                Type:       "password",
                                                Required:   true,
                                                Validation: "password_match",
                                        },
                                },
                        },
                        {
                                StepID:      "service_config",
                                Title:       "Service Configuration",
                                Description: "Configure server and service settings",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "server_port",
                                                Label:        "Server Port",
                                                Type:         "number",
                                                Required:     true,
                                                DefaultValue: 8080,
                                                MinValue:     float64Ptr(1024),
                                                MaxValue:     float64Ptr(65535),
                                        },
                                        {
                                                FieldID:      "log_level",
                                                Label:        "Log Level",
                                                Type:         "select",
                                                Required:     true,
                                                DefaultValue: "info",
                                                Options: []FieldOption{
                                                        {Value: "debug", Label: "Debug"},
                                                        {Value: "info", Label: "Info"},
                                                        {Value: "warn", Label: "Warning"},
                                                        {Value: "error", Label: "Error"},
                                                },
                                        },
                                        {
                                                FieldID:      "enable_cors",
                                                Label:        "Enable CORS",
                                                Type:         "boolean",
                                                DefaultValue: true,
                                                HelpText:     "Enable Cross-Origin Resource Sharing for web clients",
                                        },
                                        {
                                                FieldID:      "backup_enabled",
                                                Label:        "Enable Automatic Backups",
                                                Type:         "boolean",
                                                DefaultValue: true,
                                        },
                                },
                        },
                        {
                                StepID:      "final_test",
                                Title:       "Final Configuration Test",
                                Description: "Test all configurations and start services",
                                StepType:    "test",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "start_services",
                                                Label:        "Start services after successful test",
                                                Type:         "boolean",
                                                DefaultValue: true,
                                        },
                                },
                        },
                },
                DefaultValues: map[string]interface{}{
                        "db_type":         "sqlite",
                        "storage_type":    "local",
                        "session_timeout": 24,
                        "server_port":     8080,
                        "log_level":       "info",
                },
                Requirements: []string{"go", "sqlite3"},
                PostInstall: []PostInstallAction{
                        {
                                ActionType:  "file_create",
                                Description: "Create configuration file",
                                Parameters: map[string]interface{}{
                                        "file_path": "./config/config.json",
                                        "template":  "config_template.json",
                                },
                                Required: true,
                        },
                        {
                                ActionType:  "service_restart",
                                Description: "Restart Catalogizer service",
                                Parameters: map[string]interface{}{
                                        "service_name": "catalogizer",
                                },
                                Required: false,
                        },
                },
        }

        // Enterprise Installation Template
        s.configTemplates["enterprise"] = ConfigTemplate{
                TemplateID:   "enterprise",
                Name:         "Enterprise Installation",
                Description:  "Full enterprise setup with all features enabled",
                Category:     "installation",
                Steps:        s.getEnterpriseSteps(),
                Requirements: []string{"go", "docker", "postgresql", "redis"},
        }

        // Development Template
        s.configTemplates["development"] = ConfigTemplate{
                TemplateID:   "development",
                Name:         "Development Environment",
                Description:  "Development setup with debugging and testing tools",
                Category:     "development",
                Steps:        s.getDevelopmentSteps(),
                Requirements: []string{"go", "git", "make"},
        }
}</span>

func (s *ConfigurationWizardService) getEnterpriseSteps() []WizardStep <span class="cov8" title="1">{
        // Return enterprise-specific configuration steps
        steps := []WizardStep{
                {
                        StepID:      "infrastructure",
                        Title:       "Infrastructure Setup",
                        Description: "Configure enterprise infrastructure components",
                        StepType:    "input",
                        Fields: []FieldDefinition{
                                {
                                        FieldID:  "deployment_type",
                                        Label:    "Deployment Type",
                                        Type:     "select",
                                        Required: true,
                                        Options: []FieldOption{
                                                {Value: "kubernetes", Label: "Kubernetes Cluster"},
                                                {Value: "docker_swarm", Label: "Docker Swarm"},
                                                {Value: "standalone", Label: "Standalone Servers"},
                                        },
                                },
                                {
                                        FieldID:  "load_balancer",
                                        Label:    "Load Balancer Configuration",
                                        Type:     "select",
                                        Required: true,
                                        Options: []FieldOption{
                                                {Value: "nginx", Label: "Nginx"},
                                                {Value: "haproxy", Label: "HAProxy"},
                                                {Value: "aws_alb", Label: "AWS Application Load Balancer"},
                                        },
                                },
                        },
                },
                // Add more enterprise-specific steps...
        }
        return steps
}</span>

func (s *ConfigurationWizardService) getDevelopmentSteps() []WizardStep <span class="cov8" title="1">{
        // Return development-specific configuration steps
        steps := []WizardStep{
                {
                        StepID:      "dev_environment",
                        Title:       "Development Environment",
                        Description: "Configure development tools and settings",
                        StepType:    "input",
                        Fields: []FieldDefinition{
                                {
                                        FieldID:      "debug_mode",
                                        Label:        "Enable Debug Mode",
                                        Type:         "boolean",
                                        DefaultValue: true,
                                },
                                {
                                        FieldID:      "hot_reload",
                                        Label:        "Enable Hot Reload",
                                        Type:         "boolean",
                                        DefaultValue: true,
                                },
                        },
                },
                // Add more development-specific steps...
        }
        return steps
}</span>

func (s *ConfigurationWizardService) initializeValidationRules() <span class="cov8" title="1">{
        s.validationRules["required"] = ValidationRule{
                RuleID:       "required",
                Type:         "required",
                ErrorMessage: "This field is required",
        }

        s.validationRules["email"] = ValidationRule{
                RuleID:       "email",
                Type:         "format",
                ErrorMessage: "Please enter a valid email address",
                Parameters: map[string]interface{}{
                        "pattern": `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`,
                },
        }

        s.validationRules["username"] = ValidationRule{
                RuleID:       "username",
                Type:         "format",
                ErrorMessage: "Username can only contain letters, numbers, and underscores (3-30 characters)",
                Parameters: map[string]interface{}{
                        "pattern": `^[a-zA-Z0-9_]{3,30}$`,
                },
        }

        s.validationRules["password_strength"] = ValidationRule{
                RuleID:       "password_strength",
                Type:         "custom",
                ErrorMessage: "Password must be at least 8 characters with uppercase, lowercase, number, and special character",
                Parameters: map[string]interface{}{
                        "min_length":      8,
                        "require_upper":   true,
                        "require_lower":   true,
                        "require_number":  true,
                        "require_special": true,
                },
        }

        s.validationRules["password_match"] = ValidationRule{
                RuleID:       "password_match",
                Type:         "custom",
                ErrorMessage: "Passwords do not match",
                Parameters: map[string]interface{}{
                        "match_field": "admin_password",
                },
        }

        s.validationRules["min_length"] = ValidationRule{
                RuleID:       "min_length",
                Type:         "format",
                ErrorMessage: "Must be at least {min} characters long",
        }
}</span>

func (s *ConfigurationWizardService) StartWizard(userID int, configType string, quickInstall bool) (*models.WizardSession, error) <span class="cov0" title="0">{
        template, exists := s.configTemplates[configType]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration template '%s' not found", configType)
        }</span>

        <span class="cov0" title="0">sessionID := fmt.Sprintf("wizard-%d-%d", userID, time.Now().Unix())

        session := &amp;models.WizardSession{
                SessionID:     sessionID,
                UserID:        userID,
                CurrentStep:   0,
                TotalSteps:    len(template.Steps),
                StepData:      make(map[string]interface{}),
                Configuration: make(map[string]interface{}),
                StartedAt:     time.Now(),
                LastActivity:  time.Now(),
                IsCompleted:   false,
                ConfigType:    configType,
        }

        // Apply default values
        for key, value := range template.DefaultValues </span><span class="cov0" title="0">{
                session.Configuration[key] = value
        }</span>

        // Quick install logic
        <span class="cov0" title="0">if quickInstall </span><span class="cov0" title="0">{
                session.Configuration["quick_install"] = true
                // Skip optional steps and use defaults
        }</span>

        <span class="cov0" title="0">s.currentSession = session

        // Save session to database
        if err := s.repo.SaveWizardSession(session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save wizard session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *ConfigurationWizardService) GetCurrentStep(sessionID string) (*WizardStep, error) <span class="cov0" title="0">{
        session, err := s.getSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">template := s.configTemplates[session.ConfigType]
        if session.CurrentStep &gt;= len(template.Steps) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wizard completed")
        }</span>

        <span class="cov0" title="0">step := template.Steps[session.CurrentStep]

        // Check if step should be skipped
        if s.shouldSkipStep(step, session.Configuration) </span><span class="cov0" title="0">{
                // Move to next step
                session.CurrentStep++
                s.repo.SaveWizardSession(session)
                return s.GetCurrentStep(sessionID)
        }</span>

        <span class="cov0" title="0">return &amp;step, nil</span>
}

func (s *ConfigurationWizardService) shouldSkipStep(step WizardStep, config map[string]interface{}) bool <span class="cov8" title="1">{
        if step.SkipCondition == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for key, expectedValue := range step.SkipCondition </span><span class="cov8" title="1">{
                if configValue, exists := config[key]; exists </span><span class="cov8" title="1">{
                        if configValue != expectedValue </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

func (s *ConfigurationWizardService) SubmitStepData(sessionID string, stepData map[string]interface{}) error <span class="cov0" title="0">{
        session, err := s.getSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">template := s.configTemplates[session.ConfigType]
        if session.CurrentStep &gt;= len(template.Steps) </span><span class="cov0" title="0">{
                return fmt.Errorf("wizard already completed")
        }</span>

        <span class="cov0" title="0">currentStep := template.Steps[session.CurrentStep]

        // Validate step data
        if err := s.validateStepData(currentStep, stepData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        // Process step based on type
        <span class="cov0" title="0">switch currentStep.StepType </span>{
        case "test":<span class="cov0" title="0">
                if err := s.processTestStep(currentStep, stepData, session); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("test step failed: %w", err)
                }</span>
        case "input", "select", "multi-select":<span class="cov0" title="0">
                // Store the input data
                for key, value := range stepData </span><span class="cov0" title="0">{
                        session.Configuration[key] = value
                }</span>
        }

        // Store step data
        <span class="cov0" title="0">session.StepData[currentStep.StepID] = stepData
        session.LastActivity = time.Now()

        // Move to next step
        session.CurrentStep++

        // Check if wizard is completed
        if session.CurrentStep &gt;= len(template.Steps) </span><span class="cov0" title="0">{
                session.IsCompleted = true
                if err := s.finalizeConfiguration(session); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to finalize configuration: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return s.repo.SaveWizardSession(session)</span>
}

func (s *ConfigurationWizardService) validateStepData(step WizardStep, data map[string]interface{}) error <span class="cov8" title="1">{
        for _, field := range step.Fields </span><span class="cov8" title="1">{
                value, exists := data[field.FieldID]

                // Check required fields
                if field.Required &amp;&amp; (!exists || value == nil || value == "") </span><span class="cov8" title="1">{
                        return fmt.Errorf("field '%s' is required", field.FieldID)
                }</span>

                <span class="cov8" title="1">if !exists || value == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Type validation
                <span class="cov8" title="1">if err := s.validateFieldType(field, value); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("field '%s': %w", field.FieldID, err)
                }</span>

                // Custom validation
                <span class="cov8" title="1">if field.Validation != "" </span><span class="cov8" title="1">{
                        if err := s.validateFieldRule(field.Validation, value, data); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("field '%s': %w", field.FieldID, err)
                        }</span>
                }

                // Range validation for numbers
                <span class="cov8" title="1">if field.Type == "number" </span><span class="cov8" title="1">{
                        if numValue, ok := value.(float64); ok </span><span class="cov8" title="1">{
                                if field.MinValue != nil &amp;&amp; numValue &lt; *field.MinValue </span><span class="cov8" title="1">{
                                        return fmt.Errorf("field '%s': value must be at least %v", field.FieldID, *field.MinValue)
                                }</span>
                                <span class="cov8" title="1">if field.MaxValue != nil &amp;&amp; numValue &gt; *field.MaxValue </span><span class="cov8" title="1">{
                                        return fmt.Errorf("field '%s': value must be at most %v", field.FieldID, *field.MaxValue)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *ConfigurationWizardService) validateFieldType(field FieldDefinition, value interface{}) error <span class="cov8" title="1">{
        switch field.Type </span>{
        case "text", "password":<span class="cov8" title="1">
                if _, ok := value.(string); !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("expected string value")
                }</span>
        case "number":<span class="cov8" title="1">
                switch v := value.(type) </span>{
                case float64, int, int64:<span class="cov8" title="1"></span>
                        // Valid number types
                case string:<span class="cov8" title="1">
                        if _, err := strconv.ParseFloat(v, 64); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid number format")
                        }</span>
                default:<span class="cov8" title="1">
                        return fmt.Errorf("expected number value")</span>
                }
        case "boolean":<span class="cov8" title="1">
                if _, ok := value.(bool); !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("expected boolean value")
                }</span>
        case "file", "directory":<span class="cov8" title="1">
                if strValue, ok := value.(string); ok </span><span class="cov8" title="1">{
                        if field.Type == "directory" </span><span class="cov8" title="1">{
                                if _, err := os.Stat(strValue); err != nil </span><span class="cov8" title="1">{
                                        return fmt.Errorf("directory does not exist: %s", strValue)
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        return fmt.Errorf("expected string path")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *ConfigurationWizardService) validateFieldRule(ruleName string, value interface{}, allData map[string]interface{}) error <span class="cov8" title="1">{
        rule, exists := s.validationRules[ruleName]
        if !exists </span><span class="cov8" title="1">{
                // Handle inline rules like "min_length:32"
                if strings.Contains(ruleName, ":") </span><span class="cov8" title="1">{
                        parts := strings.SplitN(ruleName, ":", 2)
                        ruleType, param := parts[0], parts[1]

                        switch ruleType </span>{
                        case "min_length":<span class="cov8" title="1">
                                if strValue, ok := value.(string); ok </span><span class="cov8" title="1">{
                                        if minLen, err := strconv.Atoi(param); err == nil </span><span class="cov8" title="1">{
                                                if len(strValue) &lt; minLen </span><span class="cov8" title="1">{
                                                        return fmt.Errorf("must be at least %d characters long", minLen)
                                                }</span>
                                        }
                                }
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">switch rule.Type </span>{
        case "format":<span class="cov8" title="1">
                if pattern, ok := rule.Parameters["pattern"].(string); ok </span><span class="cov8" title="1">{
                        if strValue, ok := value.(string); ok </span><span class="cov8" title="1">{
                                matched, err := filepath.Match(pattern, strValue)
                                if err != nil || !matched </span><span class="cov8" title="1">{
                                        return errors.New(rule.ErrorMessage)
                                }</span>
                        }
                }
        case "custom":<span class="cov8" title="1">
                return s.validateCustomRule(rule, value, allData)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *ConfigurationWizardService) validateCustomRule(rule ValidationRule, value interface{}, allData map[string]interface{}) error <span class="cov8" title="1">{
        switch rule.RuleID </span>{
        case "password_strength":<span class="cov8" title="1">
                if strValue, ok := value.(string); ok </span><span class="cov8" title="1">{
                        if len(strValue) &lt; 8 </span><span class="cov8" title="1">{
                                return fmt.Errorf("password must be at least 8 characters")
                        }</span>
                        // Add more password strength checks
                }
        case "password_match":<span class="cov8" title="1">
                if matchField, ok := rule.Parameters["match_field"].(string); ok </span><span class="cov8" title="1">{
                        if otherValue, exists := allData[matchField]; exists </span><span class="cov8" title="1">{
                                if value != otherValue </span><span class="cov8" title="1">{
                                        return fmt.Errorf("passwords do not match")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *ConfigurationWizardService) processTestStep(step WizardStep, data map[string]interface{}, session *models.WizardSession) error <span class="cov0" title="0">{
        switch step.StepID </span>{
        case "system_check":<span class="cov0" title="0">
                return s.performSystemCheck(data, session)</span>
        case "final_test":<span class="cov0" title="0">
                return s.performFinalTest(data, session)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown test step: %s", step.StepID)</span>
        }
}

func (s *ConfigurationWizardService) performSystemCheck(data map[string]interface{}, session *models.WizardSession) error <span class="cov0" title="0">{
        systemInfo := s.collectSystemInfo()

        // Check minimum requirements
        var issues []string

        // Check Go version
        if !strings.HasPrefix(systemInfo.GoVersion, "go1.") </span><span class="cov0" title="0">{
                issues = append(issues, "Go is not installed or not in PATH")
        }</span>

        // Check available memory (minimum 1GB)
        <span class="cov0" title="0">if systemInfo.MemoryGB &lt; 1.0 </span><span class="cov0" title="0">{
                issues = append(issues, "Insufficient memory (minimum 1GB required)")
        }</span>

        // Check available disk space (minimum 5GB)
        <span class="cov0" title="0">if systemInfo.DiskSpaceGB &lt; 5.0 </span><span class="cov0" title="0">{
                issues = append(issues, "Insufficient disk space (minimum 5GB required)")
        }</span>

        // Store system info in session
        <span class="cov0" title="0">session.Configuration["system_info"] = systemInfo

        if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                autoFix, _ := data["auto_fix"].(bool)
                if autoFix </span><span class="cov0" title="0">{
                        log.Printf("Auto-fixing system issues: %v", issues)
                        // Attempt to fix issues automatically
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("system check failed: %v", issues)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) performFinalTest(data map[string]interface{}, session *models.WizardSession) error <span class="cov0" title="0">{
        // Test database connection
        if err := s.testDatabaseConnection(session.Configuration); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database connection test failed: %w", err)
        }</span>

        // Test media storage
        <span class="cov0" title="0">if err := s.testMediaStorage(session.Configuration); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("media storage test failed: %w", err)
        }</span>

        // Test service configuration
        <span class="cov0" title="0">if err := s.testServiceConfiguration(session.Configuration); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("service configuration test failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) testDatabaseConnection(config map[string]interface{}) error <span class="cov0" title="0">{
        dbType, _ := config["db_type"].(string)

        switch dbType </span>{
        case "sqlite":<span class="cov0" title="0">
                dbPath, _ := config["db_path"].(string)
                if dbPath == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("database path not specified")
                }</span>
                // Test SQLite connection
                <span class="cov0" title="0">return s.testSQLiteConnection(dbPath)</span>
        case "mysql", "postgresql":<span class="cov0" title="0">
                // Test network database connection
                return s.testNetworkDatabaseConnection(config)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported database type: %s", dbType)</span>
        }
}

func (s *ConfigurationWizardService) testSQLiteConnection(dbPath string) error <span class="cov0" title="0">{
        // Ensure directory exists
        dir := filepath.Dir(dbPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create database directory: %w", err)
        }</span>

        // Test write access
        <span class="cov0" title="0">testFile := filepath.Join(dir, "test.tmp")
        if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no write access to database directory: %w", err)
        }</span>
        <span class="cov0" title="0">os.Remove(testFile)

        return nil</span>
}

func (s *ConfigurationWizardService) testNetworkDatabaseConnection(config map[string]interface{}) error <span class="cov0" title="0">{
        // This would contain actual database connection testing logic
        // For now, just validate required fields are present
        requiredFields := []string{"db_host", "db_port", "db_name", "db_username", "db_password"}
        for _, field := range requiredFields </span><span class="cov0" title="0">{
                if _, exists := config[field]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required database field: %s", field)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) testMediaStorage(config map[string]interface{}) error <span class="cov0" title="0">{
        storageType, _ := config["storage_type"].(string)

        switch storageType </span>{
        case "local":<span class="cov0" title="0">
                mediaPath, _ := config["media_path"].(string)
                if mediaPath == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("media path not specified")
                }</span>

                // Ensure directory exists
                <span class="cov0" title="0">if err := os.MkdirAll(mediaPath, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create media directory: %w", err)
                }</span>

                // Test write access
                <span class="cov0" title="0">testFile := filepath.Join(mediaPath, "test.tmp")
                if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no write access to media directory: %w", err)
                }</span>
                <span class="cov0" title="0">os.Remove(testFile)</span>

        default:<span class="cov0" title="0">
                // For other storage types, would implement specific tests
                log.Printf("Storage type %s test not implemented", storageType)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) testServiceConfiguration(config map[string]interface{}) error <span class="cov0" title="0">{
        // Test port availability
        if port, ok := config["server_port"].(float64); ok </span><span class="cov0" title="0">{
                // Would test if port is available
                if port &lt; 1024 || port &gt; 65535 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid port number: %v", port)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) finalizeConfiguration(session *models.WizardSession) error <span class="cov0" title="0">{
        // Generate final configuration file
        configData := map[string]interface{}{
                "version":       "3.0.0",
                "generated_at":  time.Now(),
                "generated_by":  "configuration_wizard",
                "user_id":       session.UserID,
                "configuration": session.Configuration,
        }

        // Write configuration file
        configFile := filepath.Join(s.configPath, "config.json")
        if err := s.writeConfigFile(configFile, configData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write configuration file: %w", err)
        }</span>

        // Execute post-install actions
        <span class="cov0" title="0">template := s.configTemplates[session.ConfigType]
        for _, action := range template.PostInstall </span><span class="cov0" title="0">{
                if err := s.executePostInstallAction(action, session); err != nil </span><span class="cov0" title="0">{
                        if action.Required </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to execute required post-install action: %w", err)
                        }</span>
                        <span class="cov0" title="0">log.Printf("Optional post-install action failed: %v", err)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) writeConfigFile(filename string, data map[string]interface{}) error <span class="cov0" title="0">{
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(filename, jsonData, 0644)</span>
}

func (s *ConfigurationWizardService) executePostInstallAction(action PostInstallAction, session *models.WizardSession) error <span class="cov0" title="0">{
        switch action.ActionType </span>{
        case "file_create":<span class="cov0" title="0">
                return s.createConfigurationFile(action.Parameters, session)</span>
        case "service_restart":<span class="cov0" title="0">
                return s.restartService(action.Parameters)</span>
        case "command_run":<span class="cov0" title="0">
                return s.runCommand(action.Parameters)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown post-install action: %s", action.ActionType)</span>
        }
}

func (s *ConfigurationWizardService) createConfigurationFile(params map[string]interface{}, session *models.WizardSession) error <span class="cov0" title="0">{
        filePath, _ := params["file_path"].(string)
        template, _ := params["template"].(string)

        if filePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("file_path parameter required")
        }</span>

        // Create directory if needed
        <span class="cov0" title="0">dir := filepath.Dir(filePath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Use template if specified, otherwise use session configuration
        <span class="cov0" title="0">var data interface{}
        if template != "" </span><span class="cov0" title="0">{
                // Load template and merge with configuration
                data = session.Configuration
        }</span> else<span class="cov0" title="0"> {
                data = session.Configuration
        }</span>

        <span class="cov0" title="0">return s.writeConfigFile(filePath, map[string]interface{}{"config": data})</span>
}

func (s *ConfigurationWizardService) restartService(params map[string]interface{}) error <span class="cov0" title="0">{
        serviceName, _ := params["service_name"].(string)
        if serviceName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("service_name parameter required")
        }</span>

        // This would contain actual service restart logic
        <span class="cov0" title="0">log.Printf("Would restart service: %s", serviceName)
        return nil</span>
}

func (s *ConfigurationWizardService) runCommand(params map[string]interface{}) error <span class="cov0" title="0">{
        command, _ := params["command"].(string)
        if command == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("command parameter required")
        }</span>

        // This would contain actual command execution logic
        <span class="cov0" title="0">log.Printf("Would run command: %s", command)
        return nil</span>
}

func (s *ConfigurationWizardService) collectSystemInfo() SystemInfo <span class="cov8" title="1">{
        info := SystemInfo{
                OS:           runtime.GOOS,
                Architecture: runtime.GOARCH,
                GoVersion:    runtime.Version(),
                CPUCores:     runtime.NumCPU(),
        }

        // Get memory info
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        info.MemoryGB = float64(m.Sys) / (1024 * 1024 * 1024)

        // Get hostname
        if hostname, err := os.Hostname(); err == nil </span><span class="cov8" title="1">{
                info.NetworkInfo.Hostname = hostname
        }</span>

        // Detect installed tools
        <span class="cov8" title="1">info.InstalledTools = s.detectInstalledTools()

        // Get environment variables
        info.EnvironmentVars = make(map[string]string)
        for _, env := range os.Environ() </span><span class="cov8" title="1">{
                parts := strings.SplitN(env, "=", 2)
                if len(parts) == 2 </span><span class="cov8" title="1">{
                        // Only include non-sensitive environment variables
                        key := parts[0]
                        if !strings.Contains(strings.ToLower(key), "password") &amp;&amp;
                                !strings.Contains(strings.ToLower(key), "secret") &amp;&amp;
                                !strings.Contains(strings.ToLower(key), "token") </span><span class="cov8" title="1">{
                                info.EnvironmentVars[key] = parts[1]
                        }</span>
                }
        }

        // Generate recommendations
        <span class="cov8" title="1">info.Recommendations = s.generateSystemRecommendations(info)

        return info</span>
}

func (s *ConfigurationWizardService) detectInstalledTools() []string <span class="cov8" title="1">{
        var tools []string

        toolsToCheck := []string{"go", "git", "docker", "make", "npm", "node", "python", "sqlite3"}

        for _, tool := range toolsToCheck </span><span class="cov8" title="1">{
                // This would check if tool is installed
                // For now, just assume go is installed since we're running
                if tool == "go" </span><span class="cov8" title="1">{
                        tools = append(tools, tool)
                }</span>
        }

        <span class="cov8" title="1">return tools</span>
}

func (s *ConfigurationWizardService) generateSystemRecommendations(info SystemInfo) []string <span class="cov8" title="1">{
        var recommendations []string

        if info.MemoryGB &lt; 2.0 </span><span class="cov8" title="1">{
                recommendations = append(recommendations, "Consider upgrading system memory to at least 2GB for better performance")
        }</span>

        <span class="cov8" title="1">if info.CPUCores &lt; 2 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Consider using a multi-core processor for better concurrency")
        }</span>

        <span class="cov8" title="1">if info.OS == "windows" </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Consider using WSL2 for better compatibility with Unix-based tools")
        }</span>

        <span class="cov8" title="1">if len(info.InstalledTools) &lt; 3 </span><span class="cov8" title="1">{
                recommendations = append(recommendations, "Install additional development tools like Git and Docker for full functionality")
        }</span>

        <span class="cov8" title="1">return recommendations</span>
}

func (s *ConfigurationWizardService) getSession(sessionID string) (*models.WizardSession, error) <span class="cov8" title="1">{
        if s.currentSession != nil &amp;&amp; s.currentSession.SessionID == sessionID </span><span class="cov8" title="1">{
                return s.currentSession, nil
        }</span>

        // Load from database
        <span class="cov0" title="0">session, err := s.repo.GetWizardSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session not found: %w", err)
        }</span>

        <span class="cov0" title="0">s.currentSession = session
        return session, nil</span>
}

func (s *ConfigurationWizardService) GetAvailableTemplates() []ConfigTemplate <span class="cov8" title="1">{
        var templates []ConfigTemplate
        for _, template := range s.configTemplates </span><span class="cov8" title="1">{
                templates = append(templates, template)
        }</span>
        <span class="cov8" title="1">return templates</span>
}

func (s *ConfigurationWizardService) GetWizardProgress(sessionID string) (*InstallationProgress, error) <span class="cov8" title="1">{
        session, err := s.getSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">progress := float64(session.CurrentStep) / float64(session.TotalSteps) * 100

        return &amp;InstallationProgress{
                SessionID:      sessionID,
                CurrentAction:  fmt.Sprintf("Step %d of %d", session.CurrentStep+1, session.TotalSteps),
                Progress:       progress,
                CompletedSteps: s.getCompletedSteps(session),
                LastUpdate:     session.LastActivity,
                IsCompleted:    session.IsCompleted,
        }, nil</span>
}

func (s *ConfigurationWizardService) getCompletedSteps(session *models.WizardSession) []string <span class="cov8" title="1">{
        var completed []string
        template := s.configTemplates[session.ConfigType]

        for i := 0; i &lt; session.CurrentStep &amp;&amp; i &lt; len(template.Steps); i++ </span><span class="cov8" title="1">{
                completed = append(completed, template.Steps[i].Title)
        }</span>

        <span class="cov8" title="1">return completed</span>
}

func (s *ConfigurationWizardService) SaveConfigurationProfile(userID int, profile *models.ConfigurationProfile) error <span class="cov0" title="0">{
        profile.UserID = userID
        profile.CreatedAt = time.Now()
        profile.UpdatedAt = time.Now()

        return s.repo.SaveConfigurationProfile(profile)
}</span>

func (s *ConfigurationWizardService) LoadConfigurationProfile(userID int, profileID string) (*models.ConfigurationProfile, error) <span class="cov0" title="0">{
        return s.repo.GetConfigurationProfile(profileID)
}</span>

func (s *ConfigurationWizardService) GetUserConfigurationProfiles(userID int) ([]*models.ConfigurationProfile, error) <span class="cov0" title="0">{
        return s.repo.GetUserConfigurationProfiles(userID)
}</span>

func float64Ptr(f float64) *float64 <span class="cov8" title="1">{
        return &amp;f
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package services

import (
        "encoding/json"
        "fmt"
        "image/jpeg"
        "image/png"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "catalogizer/internal/auth"
        "catalogizer/models"
        "catalogizer/repository"

        "github.com/gen2brain/go-fitz"
        "github.com/unidoc/unipdf/v3/extractor"
        "github.com/unidoc/unipdf/v3/model"
)

type ConversionService struct {
        conversionRepo *repository.ConversionRepository
        userRepo       *repository.UserRepository
        authService    *AuthService
}

func NewConversionService(conversionRepo *repository.ConversionRepository, userRepo *repository.UserRepository, authService *AuthService) *ConversionService <span class="cov8" title="1">{
        return &amp;ConversionService{
                conversionRepo: conversionRepo,
                userRepo:       userRepo,
                authService:    authService,
        }
}</span>

func (s *ConversionService) CreateConversionJob(userID int, request *models.ConversionRequest) (*models.ConversionJob, error) <span class="cov0" title="0">{
        if !s.validateConversionRequest(request) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid conversion request")
        }</span>

        <span class="cov0" title="0">job := &amp;models.ConversionJob{
                UserID:         userID,
                SourcePath:     request.SourcePath,
                TargetPath:     request.TargetPath,
                SourceFormat:   request.SourceFormat,
                TargetFormat:   request.TargetFormat,
                ConversionType: request.ConversionType,
                Quality:        request.Quality,
                Settings:       request.Settings,
                Priority:       request.Priority,
                Status:         models.ConversionStatusPending,
                CreatedAt:      time.Now(),
                ScheduledFor:   request.ScheduledFor,
        }

        id, err := s.conversionRepo.CreateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create conversion job: %w", err)
        }</span>

        <span class="cov0" title="0">job.ID = id
        return job, nil</span>
}

func (s *ConversionService) StartConversion(jobID int) error <span class="cov0" title="0">{
        job, err := s.conversionRepo.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get conversion job: %w", err)
        }</span>

        <span class="cov0" title="0">if job.Status != models.ConversionStatusPending </span><span class="cov0" title="0">{
                return fmt.Errorf("job is not in pending status")
        }</span>

        <span class="cov0" title="0">job.Status = models.ConversionStatusRunning
        job.StartedAt = &amp;time.Time{}
        *job.StartedAt = time.Now()

        err = s.conversionRepo.UpdateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update job status: %w", err)
        }</span>

        <span class="cov0" title="0">go s.processConversion(job)

        return nil</span>
}

func (s *ConversionService) processConversion(job *models.ConversionJob) <span class="cov0" title="0">{
        var err error

        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.handleConversionError(job, fmt.Errorf("conversion panic: %v", r))
                }</span>
        }()

        <span class="cov0" title="0">switch job.ConversionType </span>{
        case models.ConversionTypeVideo:<span class="cov0" title="0">
                err = s.convertVideo(job)</span>
        case models.ConversionTypeAudio:<span class="cov0" title="0">
                err = s.convertAudio(job)</span>
        case models.ConversionTypeDocument:<span class="cov0" title="0">
                err = s.convertDocument(job)</span>
        case models.ConversionTypeImage:<span class="cov0" title="0">
                err = s.convertImage(job)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unsupported conversion type: %s", job.ConversionType)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.handleConversionError(job, err)
                return
        }</span>

        <span class="cov0" title="0">s.handleConversionSuccess(job)</span>
}

func (s *ConversionService) convertVideo(job *models.ConversionJob) error <span class="cov0" title="0">{
        args := s.buildFFmpegVideoArgs(job)

        cmd := exec.Command("ffmpeg", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ffmpeg video conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) convertAudio(job *models.ConversionJob) error <span class="cov0" title="0">{
        args := s.buildFFmpegAudioArgs(job)

        cmd := exec.Command("ffmpeg", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ffmpeg audio conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) convertDocument(job *models.ConversionJob) error <span class="cov0" title="0">{
        switch </span>{
        case s.isEbookConversion(job):<span class="cov0" title="0">
                return s.convertEbook(job)</span>
        case s.isPDFConversion(job):<span class="cov0" title="0">
                return s.convertPDF(job)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported document conversion")</span>
        }
}

func (s *ConversionService) convertEbook(job *models.ConversionJob) error <span class="cov0" title="0">{
        args := []string{
                job.SourcePath,
                job.TargetPath,
        }

        if job.Settings != nil </span><span class="cov0" title="0">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov0" title="0">{
                        if cover, ok := settings["preserve_cover"].(bool); ok &amp;&amp; cover </span><span class="cov0" title="0">{
                                args = append(args, "--preserve-cover")
                        }</span>
                        <span class="cov0" title="0">if metadata, ok := settings["preserve_metadata"].(bool); ok &amp;&amp; metadata </span><span class="cov0" title="0">{
                                args = append(args, "--preserve-metadata")
                        }</span>
                }
        }

        <span class="cov0" title="0">cmd := exec.Command("ebook-convert", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ebook conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) convertPDF(job *models.ConversionJob) error <span class="cov0" title="0">{
        // Determine target format and use appropriate conversion method
        ext := strings.ToLower(filepath.Ext(job.TargetPath))
        targetFormat := strings.TrimPrefix(ext, ".")

        switch targetFormat </span>{
        case "jpg", "jpeg", "png", "bmp", "tiff", "gif":<span class="cov0" title="0">
                return s.convertPDFToImage(job, targetFormat)</span>
        case "txt", "text":<span class="cov0" title="0">
                return s.convertPDFToText(job)</span>
        case "html":<span class="cov0" title="0">
                return s.convertPDFToHTML(job)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported PDF conversion target format: %s", targetFormat)</span>
        }
}

// convertPDFToImage converts PDF pages to images using go-fitz library
func (s *ConversionService) convertPDFToImage(job *models.ConversionJob, format string) error <span class="cov0" title="0">{
        doc, err := fitz.New(job.SourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open PDF: %w", err)
        }</span>
        <span class="cov0" title="0">defer doc.Close()

        // Get total page count
        totalPages := doc.NumPage()

        // Parse settings to determine which pages to convert
        settings := make(map[string]interface{})
        if job.Settings != nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span>{<span class="cov0" title="0">
                        // Settings parsed successfully
                }</span>
        }

        // Determine page range
        <span class="cov0" title="0">startPage := 0
        endPage := totalPages

        if page, ok := settings["page"].(int); ok &amp;&amp; page &gt;= 0 &amp;&amp; page &lt; totalPages </span><span class="cov0" title="0">{
                // Single page
                startPage = page
                endPage = page + 1
        }</span> else<span class="cov0" title="0"> if start, ok := settings["start_page"].(int); ok &amp;&amp; start &gt;= 0 </span><span class="cov0" title="0">{
                startPage = start
                if end, ok := settings["end_page"].(int); ok &amp;&amp; end &gt; start &amp;&amp; end &lt;= totalPages </span><span class="cov0" title="0">{
                        endPage = end
                }</span>
        }

        // Determine DPI for quality (default 150)
        <span class="cov0" title="0">dpi := 150
        if dpiVal, ok := settings["dpi"].(int); ok &amp;&amp; dpiVal &gt; 0 </span><span class="cov0" title="0">{
                dpi = dpiVal
        }</span>

        // Convert each page
        <span class="cov0" title="0">for i := startPage; i &lt; endPage; i++ </span><span class="cov0" title="0">{
                img, err := doc.ImageDPI(i, float64(dpi))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to render page %d: %w", i+1, err)
                }</span>

                // Determine output file path
                <span class="cov0" title="0">outputPath := job.TargetPath
                if totalPages &gt; 1 </span><span class="cov0" title="0">{
                        // Add page number to filename for multi-page PDFs
                        dir := filepath.Dir(outputPath)
                        name := filepath.Base(outputPath)
                        ext := filepath.Ext(outputPath)
                        nameWithoutExt := strings.TrimSuffix(name, ext)
                        outputPath = filepath.Join(dir, fmt.Sprintf("%s_page_%d%s", nameWithoutExt, i+1, ext))
                }</span>

                // Create output file
                <span class="cov0" title="0">file, err := os.Create(outputPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create output file: %w", err)
                }</span>
                <span class="cov0" title="0">defer file.Close()

                // Encode based on format
                switch format </span>{
                case "jpg", "jpeg":<span class="cov0" title="0">
                        err = jpeg.Encode(file, img, &amp;jpeg.Options{Quality: 85})</span>
                case "png":<span class="cov0" title="0">
                        err = png.Encode(file, img)</span>
                default:<span class="cov0" title="0">
                        // For other formats, use ImageMagick as fallback
                        return s.convertPDFWithImageMagick(job, format)</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encode image: %w", err)
                }</span>

                // If this was a single page conversion, break
                <span class="cov0" title="0">if totalPages == 1 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// convertPDFToText converts PDF to plain text using unipdf
func (s *ConversionService) convertPDFToText(job *models.ConversionJob) error <span class="cov0" title="0">{
        file, err := os.Open(job.SourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open PDF: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        pdfReader, err := model.NewPdfReader(file)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create PDF reader: %w", err)
        }</span>

        // Parse settings
        <span class="cov0" title="0">settings := make(map[string]interface{})
        if job.Settings != nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span>{<span class="cov0" title="0">
                        // Settings parsed successfully
                }</span>
        }

        // Determine page range
        <span class="cov0" title="0">totalPages, err := pdfReader.GetNumPages()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get total pages: %w", err)
        }</span>
        <span class="cov0" title="0">startPage := 1
        endPage := totalPages

        if page, ok := settings["page"].(int); ok &amp;&amp; page &gt; 0 &amp;&amp; page &lt;= totalPages </span><span class="cov0" title="0">{
                startPage = page
                endPage = page
        }</span> else<span class="cov0" title="0"> if start, ok := settings["start_page"].(int); ok &amp;&amp; start &gt; 0 </span><span class="cov0" title="0">{
                startPage = start
                if end, ok := settings["end_page"].(int); ok &amp;&amp; end &gt;= start &amp;&amp; end &lt;= totalPages </span><span class="cov0" title="0">{
                        endPage = end
                }</span>
        }

        // Create output file
        <span class="cov0" title="0">outputFile, err := os.Create(job.TargetPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output file: %w", err)
        }</span>
        <span class="cov0" title="0">defer outputFile.Close()

        // Extract text from pages
        for i := startPage; i &lt;= endPage; i++ </span><span class="cov0" title="0">{
                page, err := pdfReader.GetPage(i)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get page %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">extractor, err := extractor.New(page)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create extractor for page %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">content, err := extractor.ExtractText()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to extract text from page %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">if _, err := outputFile.WriteString(content); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write text to file: %w", err)
                }</span>

                // Add page separator for multi-page PDFs
                <span class="cov0" title="0">if i &lt; endPage </span><span class="cov0" title="0">{
                        if _, err := outputFile.WriteString(fmt.Sprintf("\n\n--- Page %d ---\n\n", i+1)); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write page separator: %w", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// convertPDFToHTML converts PDF to HTML using external tools
func (s *ConversionService) convertPDFToHTML(job *models.ConversionJob) error <span class="cov0" title="0">{
        // Try pandoc first for HTML conversion
        args := []string{
                "-f", "pdf",
                "-t", "html",
                "-o", job.TargetPath,
                job.SourcePath,
        }

        cmd := exec.Command("pandoc", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Fallback to LibreOffice if pandoc is not available
        <span class="cov0" title="0">args = []string{
                "--headless",
                "--convert-to", "html",
                "--outdir", filepath.Dir(job.TargetPath),
                job.SourcePath,
        }

        cmd = exec.Command("libreoffice", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err = cmd.Run()
        if err == nil </span><span class="cov0" title="0">{
                // LibreOffice might create a different filename, rename if needed
                libreOutput := strings.TrimSuffix(job.SourcePath, filepath.Ext(job.SourcePath)) + ".html"
                if _, err := os.Stat(libreOutput); err == nil </span><span class="cov0" title="0">{
                        if libreOutput != job.TargetPath </span><span class="cov0" title="0">{
                                if err := os.Rename(libreOutput, job.TargetPath); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Warning: Failed to rename LibreOffice output: %v\n", err)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return nil</span>
        }

        // Last resort: try to convert PDF to text then wrap in HTML
        <span class="cov0" title="0">tempTextFile := job.TargetPath + ".tmp.txt"
        err = s.convertPDFToText(&amp;models.ConversionJob{
                SourcePath: job.SourcePath,
                TargetPath: tempTextFile,
                Settings:   job.Settings,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to convert PDF to text for HTML conversion: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempTextFile)

        // Read the text content
        content, err := os.ReadFile(tempTextFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read temp text file: %w", err)
        }</span>

        // Create basic HTML
        <span class="cov0" title="0">htmlContent := fmt.Sprintf(`&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;%s&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        pre { white-space: pre-wrap; word-wrap: break-word; }
        .page-break { page-break-before: always; border-top: 2px solid #ccc; margin-top: 20px; padding-top: 20px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;%s&lt;/h1&gt;
    &lt;pre&gt;%s&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;`, filepath.Base(job.SourcePath), filepath.Base(job.SourcePath), string(content))

        // Write HTML file
        return os.WriteFile(job.TargetPath, []byte(htmlContent), 0644)</span>
}

// convertPDFWithImageMagick converts PDF to image formats not directly supported by go-fitz
func (s *ConversionService) convertPDFWithImageMagick(job *models.ConversionJob, format string) error <span class="cov0" title="0">{
        args := []string{
                "-density", "150", // DPI
                job.SourcePath,
        }

        // Parse settings for quality options
        if job.Settings != nil </span><span class="cov0" title="0">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov0" title="0">{
                        if dpi, ok := settings["dpi"].(int); ok &amp;&amp; dpi &gt; 0 </span><span class="cov0" title="0">{
                                args[1] = fmt.Sprintf("%d", dpi)
                        }</span>
                        <span class="cov0" title="0">if quality, ok := settings["quality"].(int); ok &amp;&amp; quality &gt; 0 </span><span class="cov0" title="0">{
                                args = append(args, "-quality", fmt.Sprintf("%d", quality))
                        }</span>
                }
        }

        <span class="cov0" title="0">args = append(args, job.TargetPath)

        cmd := exec.Command("convert", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("imagemagick PDF conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) convertImage(job *models.ConversionJob) error <span class="cov0" title="0">{
        args := s.buildImageMagickArgs(job)

        cmd := exec.Command("convert", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("imagemagick conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) buildFFmpegVideoArgs(job *models.ConversionJob) []string <span class="cov8" title="1">{
        args := []string{
                "-i", job.SourcePath,
                "-y", // Overwrite output file
        }

        switch job.Quality </span>{
        case "low":<span class="cov8" title="1">
                args = append(args, "-crf", "28", "-preset", "fast")</span>
        case "medium":<span class="cov8" title="1">
                args = append(args, "-crf", "23", "-preset", "medium")</span>
        case "high":<span class="cov8" title="1">
                args = append(args, "-crf", "18", "-preset", "slow")</span>
        case "lossless":<span class="cov8" title="1">
                args = append(args, "-crf", "0", "-preset", "veryslow")</span>
        default:<span class="cov8" title="1">
                args = append(args, "-crf", "23", "-preset", "medium")</span>
        }

        <span class="cov8" title="1">if job.Settings != nil </span><span class="cov8" title="1">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov8" title="1">{
                        if resolution, ok := settings["resolution"].(string); ok </span><span class="cov8" title="1">{
                                args = append(args, "-s", resolution)
                        }</span>
                        <span class="cov8" title="1">if framerate, ok := settings["framerate"].(string); ok </span><span class="cov8" title="1">{
                                args = append(args, "-r", framerate)
                        }</span>
                        <span class="cov8" title="1">if bitrate, ok := settings["bitrate"].(string); ok </span><span class="cov8" title="1">{
                                args = append(args, "-b:v", bitrate)
                        }</span>
                }
        }

        <span class="cov8" title="1">args = append(args, job.TargetPath)
        return args</span>
}

func (s *ConversionService) buildFFmpegAudioArgs(job *models.ConversionJob) []string <span class="cov8" title="1">{
        args := []string{
                "-i", job.SourcePath,
                "-y", // Overwrite output file
        }

        switch job.Quality </span>{
        case "low":<span class="cov8" title="1">
                args = append(args, "-ab", "96k")</span>
        case "medium":<span class="cov8" title="1">
                args = append(args, "-ab", "192k")</span>
        case "high":<span class="cov8" title="1">
                args = append(args, "-ab", "320k")</span>
        case "lossless":<span class="cov8" title="1">
                args = append(args, "-c:a", "flac")</span>
        default:<span class="cov8" title="1">
                args = append(args, "-ab", "192k")</span>
        }

        <span class="cov8" title="1">if job.Settings != nil </span><span class="cov8" title="1">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov8" title="1">{
                        if sampleRate, ok := settings["sample_rate"].(string); ok </span><span class="cov8" title="1">{
                                args = append(args, "-ar", sampleRate)
                        }</span>
                        <span class="cov8" title="1">if channels, ok := settings["channels"].(string); ok </span><span class="cov8" title="1">{
                                args = append(args, "-ac", channels)
                        }</span>
                }
        }

        <span class="cov8" title="1">args = append(args, job.TargetPath)
        return args</span>
}

func (s *ConversionService) buildImageMagickArgs(job *models.ConversionJob) []string <span class="cov8" title="1">{
        args := []string{job.SourcePath}

        if job.Settings != nil </span><span class="cov8" title="1">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov8" title="1">{
                        if resize, ok := settings["resize"].(string); ok </span><span class="cov8" title="1">{
                                args = append(args, "-resize", resize)
                        }</span>
                        <span class="cov8" title="1">if quality, ok := settings["quality"].(string); ok </span><span class="cov8" title="1">{
                                args = append(args, "-quality", quality)
                        }</span>
                        <span class="cov8" title="1">if compress, ok := settings["compress"].(bool); ok &amp;&amp; compress </span><span class="cov8" title="1">{
                                args = append(args, "-compress", "JPEG")
                        }</span>
                }
        }

        <span class="cov8" title="1">args = append(args, job.TargetPath)
        return args</span>
}

func (s *ConversionService) handleConversionSuccess(job *models.ConversionJob) <span class="cov0" title="0">{
        job.Status = models.ConversionStatusCompleted
        job.CompletedAt = &amp;time.Time{}
        *job.CompletedAt = time.Now()

        if job.StartedAt != nil </span><span class="cov0" title="0">{
                duration := job.CompletedAt.Sub(*job.StartedAt)
                job.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">err := s.conversionRepo.UpdateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update completed job %d: %v\n", job.ID, err)
        }</span>

        <span class="cov0" title="0">s.notifyUser(job, "Conversion completed successfully")</span>
}

func (s *ConversionService) handleConversionError(job *models.ConversionJob, conversionError error) <span class="cov0" title="0">{
        job.Status = models.ConversionStatusFailed
        job.CompletedAt = &amp;time.Time{}
        *job.CompletedAt = time.Now()
        errorMsg := conversionError.Error()
        job.ErrorMessage = &amp;errorMsg

        if job.StartedAt != nil </span><span class="cov0" title="0">{
                duration := job.CompletedAt.Sub(*job.StartedAt)
                job.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">err := s.conversionRepo.UpdateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update failed job %d: %v\n", job.ID, err)
        }</span>

        <span class="cov0" title="0">s.notifyUser(job, fmt.Sprintf("Conversion failed: %s", conversionError.Error()))</span>
}

func (s *ConversionService) notifyUser(job *models.ConversionJob, message string) <span class="cov0" title="0">{
        // In a full implementation, this would send notifications via email, push, etc.
        fmt.Printf("Notification for user %d: %s (Job %d)\n", job.UserID, message, job.ID)
}</span>

func (s *ConversionService) GetUserJobs(userID int, status *string, limit, offset int) ([]models.ConversionJob, error) <span class="cov0" title="0">{
        return s.conversionRepo.GetUserJobs(userID, status, limit, offset)
}</span>

func (s *ConversionService) GetJob(jobID int, userID int) (*models.ConversionJob, error) <span class="cov0" title="0">{
        job, err := s.conversionRepo.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if job.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, auth.PermissionViewMedia)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to view this job")
                }</span>
        }

        <span class="cov0" title="0">return job, nil</span>
}

func (s *ConversionService) CancelJob(jobID int, userID int) error <span class="cov0" title="0">{
        job, err := s.conversionRepo.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if job.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, auth.PermissionManageUsers)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return fmt.Errorf("unauthorized to cancel this job")
                }</span>
        }

        <span class="cov0" title="0">if job.Status != models.ConversionStatusPending &amp;&amp; job.Status != models.ConversionStatusRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot cancel job in status: %s", job.Status)
        }</span>

        <span class="cov0" title="0">job.Status = models.ConversionStatusCancelled
        job.CompletedAt = &amp;time.Time{}
        *job.CompletedAt = time.Now()

        return s.conversionRepo.UpdateJob(job)</span>
}

func (s *ConversionService) RetryJob(jobID int, userID int) error <span class="cov0" title="0">{
        job, err := s.conversionRepo.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if job.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, auth.PermissionManageUsers)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return fmt.Errorf("unauthorized to retry this job")
                }</span>
        }

        <span class="cov0" title="0">if job.Status != models.ConversionStatusFailed </span><span class="cov0" title="0">{
                return fmt.Errorf("can only retry failed jobs")
        }</span>

        <span class="cov0" title="0">job.Status = models.ConversionStatusPending
        job.StartedAt = nil
        job.CompletedAt = nil
        job.Duration = nil
        job.ErrorMessage = nil

        err = s.conversionRepo.UpdateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.StartConversion(jobID)</span>
}

func (s *ConversionService) GetJobStatistics(userID *int, startDate, endDate time.Time) (*models.ConversionStatistics, error) <span class="cov0" title="0">{
        return s.conversionRepo.GetStatistics(userID, startDate, endDate)
}</span>

func (s *ConversionService) CleanupCompletedJobs(olderThan time.Time) error <span class="cov0" title="0">{
        return s.conversionRepo.CleanupJobs(olderThan)
}</span>

func (s *ConversionService) GetSupportedFormats() *models.SupportedFormats <span class="cov8" title="1">{
        return &amp;models.SupportedFormats{
                Video: models.VideoFormats{
                        Input:  []string{"mp4", "avi", "mkv", "mov", "wmv", "flv", "webm", "m4v", "3gp"},
                        Output: []string{"mp4", "avi", "mkv", "mov", "webm", "m4v"},
                },
                Audio: models.AudioFormats{
                        Input:  []string{"mp3", "wav", "flac", "aac", "ogg", "wma", "m4a", "opus"},
                        Output: []string{"mp3", "wav", "flac", "aac", "ogg", "m4a", "opus"},
                },
                Document: models.DocumentFormats{
                        Input:  []string{"epub", "mobi", "azw", "azw3", "pdf", "txt", "docx", "odt"},
                        Output: []string{"epub", "mobi", "pdf", "txt", "html"},
                },
                Image: models.ImageFormats{
                        Input:  []string{"jpg", "jpeg", "png", "gif", "bmp", "tiff", "webp", "svg"},
                        Output: []string{"jpg", "jpeg", "png", "gif", "bmp", "tiff", "webp"},
                },
        }
}</span>

func (s *ConversionService) validateConversionRequest(request *models.ConversionRequest) bool <span class="cov8" title="1">{
        if request.SourcePath == "" || request.TargetPath == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if request.SourceFormat == "" || request.TargetFormat == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if request.ConversionType == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if !s.isValidConversionType(request.ConversionType) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if !s.isSupportedFormat(request.ConversionType, request.SourceFormat, request.TargetFormat) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (s *ConversionService) isValidConversionType(conversionType string) bool <span class="cov8" title="1">{
        validTypes := []string{
                models.ConversionTypeVideo,
                models.ConversionTypeAudio,
                models.ConversionTypeDocument,
                models.ConversionTypeImage,
        }

        for _, validType := range validTypes </span><span class="cov8" title="1">{
                if conversionType == validType </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (s *ConversionService) isSupportedFormat(conversionType, sourceFormat, targetFormat string) bool <span class="cov8" title="1">{
        formats := s.GetSupportedFormats()

        switch conversionType </span>{
        case models.ConversionTypeVideo:<span class="cov8" title="1">
                return s.isFormatSupported(sourceFormat, formats.Video.Input) &amp;&amp; s.isFormatSupported(targetFormat, formats.Video.Output)</span>
        case models.ConversionTypeAudio:<span class="cov8" title="1">
                return s.isFormatSupported(sourceFormat, formats.Audio.Input) &amp;&amp; s.isFormatSupported(targetFormat, formats.Audio.Output)</span>
        case models.ConversionTypeDocument:<span class="cov8" title="1">
                return s.isFormatSupported(sourceFormat, formats.Document.Input) &amp;&amp; s.isFormatSupported(targetFormat, formats.Document.Output)</span>
        case models.ConversionTypeImage:<span class="cov8" title="1">
                return s.isFormatSupported(sourceFormat, formats.Image.Input) &amp;&amp; s.isFormatSupported(targetFormat, formats.Image.Output)</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (s *ConversionService) isFormatSupported(format string, supportedFormats []string) bool <span class="cov8" title="1">{
        format = strings.ToLower(format)
        for _, supported := range supportedFormats </span><span class="cov8" title="1">{
                if format == strings.ToLower(supported) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (s *ConversionService) isEbookConversion(job *models.ConversionJob) bool <span class="cov8" title="1">{
        ebookFormats := []string{"epub", "mobi", "azw", "azw3", "txt", "html"}
        return s.isFormatSupported(job.SourceFormat, ebookFormats) || s.isFormatSupported(job.TargetFormat, ebookFormats)
}</span>

func (s *ConversionService) isPDFConversion(job *models.ConversionJob) bool <span class="cov8" title="1">{
        return job.SourceFormat == "pdf" || job.TargetFormat == "pdf"
}</span>

func (s *ConversionService) GetJobQueue() ([]models.ConversionJob, error) <span class="cov0" title="0">{
        return s.conversionRepo.GetJobsByStatus(models.ConversionStatusPending, 100, 0)
}</span>

func (s *ConversionService) ProcessJobQueue() error <span class="cov0" title="0">{
        jobs, err := s.GetJobQueue()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, job := range jobs </span><span class="cov0" title="0">{
                if job.ScheduledFor != nil &amp;&amp; job.ScheduledFor.After(time.Now()) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">err := s.StartConversion(job.ID)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to start conversion job %d: %v\n", job.ID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package services

import (
        "bytes"
        "encoding/csv"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "runtime"
        "strconv"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type ErrorReportingService struct {
        errorRepo        *repository.ErrorReportingRepository
        crashRepo        *repository.CrashReportingRepository
        config           *ErrorReportingConfig
        httpClient       *http.Client
        enabled          bool
        crashlyticAPIKey string
}

type ErrorReportingConfig struct {
        CrashlyticsEnabled  bool   `json:"crashlytics_enabled"`
        CrashlyticsAPIKey   string `json:"crashlytics_api_key"`
        SlackWebhookURL     string `json:"slack_webhook_url"`
        EmailNotifications  bool   `json:"email_notifications"`
        SentryDSN           string `json:"sentry_dsn"`
        AutoReporting       bool   `json:"auto_reporting"`
        MaxErrorsPerHour    int    `json:"max_errors_per_hour"`
        RetentionDays       int    `json:"retention_days"`
        IncludeStackTrace   bool   `json:"include_stack_trace"`
        IncludeSystemInfo   bool   `json:"include_system_info"`
        FilterSensitiveData bool   `json:"filter_sensitive_data"`
}

func NewErrorReportingService(errorRepo *repository.ErrorReportingRepository, crashRepo *repository.CrashReportingRepository) *ErrorReportingService <span class="cov8" title="1">{
        config := &amp;ErrorReportingConfig{
                CrashlyticsEnabled:  false,
                EmailNotifications:  true,
                AutoReporting:       true,
                MaxErrorsPerHour:    100,
                RetentionDays:       30,
                IncludeStackTrace:   true,
                IncludeSystemInfo:   true,
                FilterSensitiveData: true,
        }

        return &amp;ErrorReportingService{
                errorRepo:  errorRepo,
                crashRepo:  crashRepo,
                config:     config,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                enabled:    true,
        }
}</span>

func (s *ErrorReportingService) ReportError(userID int, errorReport *models.ErrorReportRequest) (*models.ErrorReport, error) <span class="cov8" title="1">{
        if !s.enabled </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error reporting is disabled")
        }</span>

        // Check rate limiting
        <span class="cov0" title="0">if s.config.MaxErrorsPerHour &gt; 0 </span><span class="cov0" title="0">{
                count, err := s.errorRepo.GetErrorCountInLastHour(userID)
                if err == nil &amp;&amp; count &gt;= s.config.MaxErrorsPerHour </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error reporting rate limit exceeded")
                }</span>
        }

        // Create error report
        <span class="cov0" title="0">report := &amp;models.ErrorReport{
                UserID:     userID,
                Level:      errorReport.Level,
                Message:    errorReport.Message,
                ErrorCode:  errorReport.ErrorCode,
                Component:  errorReport.Component,
                StackTrace: errorReport.StackTrace,
                Context:    errorReport.Context,
                UserAgent:  errorReport.UserAgent,
                URL:        errorReport.URL,
                ReportedAt: time.Now(),
                Status:     models.ErrorStatusNew,
        }

        // Filter sensitive data
        if s.config.FilterSensitiveData </span><span class="cov0" title="0">{
                report = s.filterSensitiveData(report)
        }</span>

        // Add system information
        <span class="cov0" title="0">if s.config.IncludeSystemInfo </span><span class="cov0" title="0">{
                report.SystemInfo = s.collectSystemInfo()
        }</span>

        // Generate fingerprint for deduplication
        <span class="cov0" title="0">report.Fingerprint = s.generateFingerprint(report)

        // Save to database
        if err := s.errorRepo.CreateErrorReport(report); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save error report: %w", err)
        }</span>

        // Send notifications asynchronously
        <span class="cov0" title="0">if s.config.AutoReporting </span><span class="cov0" title="0">{
                go s.sendNotifications(report)
        }</span>

        // Send to external services
        <span class="cov0" title="0">go s.sendToExternalServices(report)

        return report, nil</span>
}

func (s *ErrorReportingService) ReportCrash(userID int, crashReport *models.CrashReportRequest) (*models.CrashReport, error) <span class="cov8" title="1">{
        if !s.enabled </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("crash reporting is disabled")
        }</span>

        // Create crash report
        <span class="cov0" title="0">report := &amp;models.CrashReport{
                UserID:     userID,
                Signal:     crashReport.Signal,
                Message:    crashReport.Message,
                StackTrace: crashReport.StackTrace,
                Context:    crashReport.Context,
                ReportedAt: time.Now(),
                Status:     models.CrashStatusNew,
        }

        // Add system information
        report.SystemInfo = s.collectSystemInfo()

        // Generate fingerprint for deduplication
        report.Fingerprint = s.generateCrashFingerprint(report)

        // Save to database
        if err := s.crashRepo.CreateCrashReport(report); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save crash report: %w", err)
        }</span>

        // Send critical notifications immediately
        <span class="cov0" title="0">go s.sendCrashNotifications(report)

        // Send to Crashlytics
        if s.config.CrashlyticsEnabled </span><span class="cov0" title="0">{
                go s.sendToCrashlytics(report)
        }</span>

        <span class="cov0" title="0">return report, nil</span>
}

func (s *ErrorReportingService) GetErrorReport(id int, userID int) (*models.ErrorReport, error) <span class="cov0" title="0">{
        report, err := s.errorRepo.GetErrorReport(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get error report: %w", err)
        }</span>

        // Check if user has access
        <span class="cov0" title="0">if report.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">return report, nil</span>
}

func (s *ErrorReportingService) GetCrashReport(id int, userID int) (*models.CrashReport, error) <span class="cov0" title="0">{
        report, err := s.crashRepo.GetCrashReport(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crash report: %w", err)
        }</span>

        // Check if user has access
        <span class="cov0" title="0">if report.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">return report, nil</span>
}

func (s *ErrorReportingService) UpdateErrorStatus(id int, userID int, status string) error <span class="cov0" title="0">{
        report, err := s.errorRepo.GetErrorReport(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get error report: %w", err)
        }</span>

        <span class="cov0" title="0">if report.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">report.Status = status
        if status == models.ErrorStatusResolved </span><span class="cov0" title="0">{
                now := time.Now()
                report.ResolvedAt = &amp;now
        }</span>

        <span class="cov0" title="0">return s.errorRepo.UpdateErrorReport(report)</span>
}

func (s *ErrorReportingService) UpdateCrashStatus(id int, userID int, status string) error <span class="cov0" title="0">{
        report, err := s.crashRepo.GetCrashReport(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get crash report: %w", err)
        }</span>

        <span class="cov0" title="0">if report.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">report.Status = status
        if status == models.CrashStatusResolved </span><span class="cov0" title="0">{
                now := time.Now()
                report.ResolvedAt = &amp;now
        }</span>

        <span class="cov0" title="0">return s.crashRepo.UpdateCrashReport(report)</span>
}

func (s *ErrorReportingService) GetErrorReportsByUser(userID int, filters *models.ErrorReportFilters) ([]*models.ErrorReport, error) <span class="cov0" title="0">{
        return s.errorRepo.GetErrorReportsByUser(userID, filters)
}</span>

func (s *ErrorReportingService) GetCrashReportsByUser(userID int, filters *models.CrashReportFilters) ([]*models.CrashReport, error) <span class="cov0" title="0">{
        return s.crashRepo.GetCrashReportsByUser(userID, filters)
}</span>

func (s *ErrorReportingService) GetErrorStatistics(userID int) (*models.ErrorStatistics, error) <span class="cov0" title="0">{
        return s.errorRepo.GetErrorStatistics(userID)
}</span>

func (s *ErrorReportingService) GetCrashStatistics(userID int) (*models.CrashStatistics, error) <span class="cov0" title="0">{
        return s.crashRepo.GetCrashStatistics(userID)
}</span>

func (s *ErrorReportingService) GetSystemHealth() (*models.SystemHealth, error) <span class="cov0" title="0">{
        health := &amp;models.SystemHealth{
                CheckedAt: time.Now(),
                Status:    "healthy",
                Metrics:   make(map[string]interface{}),
        }

        // Check recent error rates
        recentErrors, err := s.errorRepo.GetRecentErrorCount(1 * time.Hour)
        if err == nil </span><span class="cov0" title="0">{
                health.Metrics["recent_errors"] = recentErrors
                if recentErrors &gt; 100 </span><span class="cov0" title="0">{
                        health.Status = "degraded"
                }</span>
        }

        // Check recent crash rates
        <span class="cov0" title="0">recentCrashes, err := s.crashRepo.GetRecentCrashCount(1 * time.Hour)
        if err == nil </span><span class="cov0" title="0">{
                health.Metrics["recent_crashes"] = recentCrashes
                if recentCrashes &gt; 5 </span><span class="cov0" title="0">{
                        health.Status = "critical"
                }</span>
        }

        // Check system resources
        <span class="cov0" title="0">var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        health.Metrics["memory_used"] = m.Alloc
        health.Metrics["memory_total"] = m.Sys
        health.Metrics["goroutines"] = runtime.NumGoroutine()

        return health, nil</span>
}

func (s *ErrorReportingService) UpdateConfiguration(config *ErrorReportingConfig) error <span class="cov8" title="1">{
        s.config = config
        return nil
}</span>

func (s *ErrorReportingService) GetConfiguration() *ErrorReportingConfig <span class="cov8" title="1">{
        return s.config
}</span>

func (s *ErrorReportingService) CleanupOldReports(olderThan time.Time) error <span class="cov0" title="0">{
        if err := s.errorRepo.CleanupOldReports(olderThan); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old error reports: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.crashRepo.CleanupOldReports(olderThan); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old crash reports: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ErrorReportingService) ExportReports(userID int, filters *models.ExportFilters) ([]byte, error) <span class="cov0" title="0">{
        var reports []interface{}

        // Get error reports
        if filters.IncludeErrors </span><span class="cov0" title="0">{
                errorReports, err := s.errorRepo.GetErrorReportsByUser(userID, &amp;models.ErrorReportFilters{
                        StartDate: filters.StartDate,
                        EndDate:   filters.EndDate,
                        Level:     filters.Level,
                        Component: filters.Component,
                        Limit:     filters.Limit,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get error reports: %w", err)
                }</span>
                <span class="cov0" title="0">for _, report := range errorReports </span><span class="cov0" title="0">{
                        reports = append(reports, report)
                }</span>
        }

        // Get crash reports
        <span class="cov0" title="0">if filters.IncludeCrashes </span><span class="cov0" title="0">{
                crashReports, err := s.crashRepo.GetCrashReportsByUser(userID, &amp;models.CrashReportFilters{
                        StartDate: filters.StartDate,
                        EndDate:   filters.EndDate,
                        Signal:    filters.Signal,
                        Limit:     filters.Limit,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get crash reports: %w", err)
                }</span>
                <span class="cov0" title="0">for _, report := range crashReports </span><span class="cov0" title="0">{
                        reports = append(reports, report)
                }</span>
        }

        // Export based on format
        <span class="cov0" title="0">switch filters.Format </span>{
        case "json":<span class="cov0" title="0">
                return json.MarshalIndent(reports, "", "  ")</span>
        case "csv":<span class="cov0" title="0">
                return s.exportToCSV(reports)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported export format: %s", filters.Format)</span>
        }
}

// Helper methods

func (s *ErrorReportingService) filterSensitiveData(report *models.ErrorReport) *models.ErrorReport <span class="cov8" title="1">{
        // Remove sensitive patterns from message and stack trace
        sensitivePatterns := []string{
                "password", "token", "key", "secret", "auth",
                "email", "phone", "ssn", "credit",
        }

        for _, pattern := range sensitivePatterns </span><span class="cov8" title="1">{
                report.Message = strings.ReplaceAll(strings.ToLower(report.Message), pattern, "[REDACTED]")
                report.StackTrace = strings.ReplaceAll(strings.ToLower(report.StackTrace), pattern, "[REDACTED]")
        }</span>

        // Filter context data
        <span class="cov8" title="1">if report.Context != nil </span><span class="cov8" title="1">{
                filteredContext := make(map[string]interface{})
                for key, value := range report.Context </span><span class="cov8" title="1">{
                        keyLower := strings.ToLower(key)
                        isSensitive := false
                        for _, pattern := range sensitivePatterns </span><span class="cov8" title="1">{
                                if strings.Contains(keyLower, pattern) </span><span class="cov8" title="1">{
                                        isSensitive = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !isSensitive </span><span class="cov8" title="1">{
                                filteredContext[key] = value
                        }</span> else<span class="cov8" title="1"> {
                                filteredContext[key] = "[REDACTED]"
                        }</span>
                }
                <span class="cov8" title="1">report.Context = filteredContext</span>
        }

        <span class="cov8" title="1">return report</span>
}

func (s *ErrorReportingService) collectSystemInfo() map[string]interface{} <span class="cov8" title="1">{
        info := make(map[string]interface{})

        info["os"] = runtime.GOOS
        info["arch"] = runtime.GOARCH
        info["go_version"] = runtime.Version()
        info["num_cpu"] = runtime.NumCPU()
        info["num_goroutine"] = runtime.NumGoroutine()

        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        info["memory_alloc"] = m.Alloc
        info["memory_total_alloc"] = m.TotalAlloc
        info["memory_sys"] = m.Sys

        if hostname, err := os.Hostname(); err == nil </span><span class="cov8" title="1">{
                info["hostname"] = hostname
        }</span>

        <span class="cov8" title="1">if wd, err := os.Getwd(); err == nil </span><span class="cov8" title="1">{
                info["working_directory"] = wd
        }</span>

        <span class="cov8" title="1">return info</span>
}

func (s *ErrorReportingService) generateFingerprint(report *models.ErrorReport) string <span class="cov8" title="1">{
        // Create a unique fingerprint based on error characteristics
        data := fmt.Sprintf("%s:%s:%s", report.Level, report.Component, report.ErrorCode)
        return fmt.Sprintf("%x", data)[:16]
}</span>

func (s *ErrorReportingService) generateCrashFingerprint(report *models.CrashReport) string <span class="cov8" title="1">{
        // Create a unique fingerprint based on crash characteristics
        data := fmt.Sprintf("%s:%s", report.Signal, report.Message)
        return fmt.Sprintf("%x", data)[:16]
}</span>

func (s *ErrorReportingService) sendNotifications(report *models.ErrorReport) <span class="cov0" title="0">{
        // Send Slack notification
        if s.config.SlackWebhookURL != "" </span><span class="cov0" title="0">{
                s.sendSlackNotification(report)
        }</span>

        // Send email notification
        <span class="cov0" title="0">if s.config.EmailNotifications </span><span class="cov0" title="0">{
                s.sendEmailNotification(report)
        }</span>
}

func (s *ErrorReportingService) sendCrashNotifications(report *models.CrashReport) <span class="cov0" title="0">{
        // Send critical notifications for crashes
        if s.config.SlackWebhookURL != "" </span><span class="cov0" title="0">{
                s.sendSlackCrashNotification(report)
        }</span>

        <span class="cov0" title="0">if s.config.EmailNotifications </span><span class="cov0" title="0">{
                s.sendEmailCrashNotification(report)
        }</span>
}

func (s *ErrorReportingService) sendSlackNotification(report *models.ErrorReport) error <span class="cov8" title="1">{
        if s.config.SlackWebhookURL == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">message := map[string]interface{}{
                "text": fmt.Sprintf(" Error Report: %s", report.Message),
                "attachments": []map[string]interface{}{
                        {
                                "color": s.getColorForLevel(report.Level),
                                "fields": []map[string]interface{}{
                                        {"title": "Level", "value": report.Level, "short": true},
                                        {"title": "Component", "value": report.Component, "short": true},
                                        {"title": "Error Code", "value": report.ErrorCode, "short": true},
                                        {"title": "Time", "value": report.ReportedAt.Format(time.RFC3339), "short": true},
                                },
                        },
                },
        }

        jsonData, _ := json.Marshal(message)
        _, err := s.httpClient.Post(s.config.SlackWebhookURL, "application/json", bytes.NewBuffer(jsonData))
        return err</span>
}

func (s *ErrorReportingService) sendSlackCrashNotification(report *models.CrashReport) error <span class="cov8" title="1">{
        if s.config.SlackWebhookURL == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">message := map[string]interface{}{
                "text": fmt.Sprintf(" CRASH REPORT: %s", report.Message),
                "attachments": []map[string]interface{}{
                        {
                                "color": "danger",
                                "fields": []map[string]interface{}{
                                        {"title": "Signal", "value": report.Signal, "short": true},
                                        {"title": "Time", "value": report.ReportedAt.Format(time.RFC3339), "short": true},
                                },
                        },
                },
        }

        jsonData, _ := json.Marshal(message)
        _, err := s.httpClient.Post(s.config.SlackWebhookURL, "application/json", bytes.NewBuffer(jsonData))
        return err</span>
}

func (s *ErrorReportingService) sendEmailNotification(report *models.ErrorReport) error <span class="cov0" title="0">{
        // Email implementation would go here
        // This is a placeholder for email notification logic
        return nil
}</span>

func (s *ErrorReportingService) sendEmailCrashNotification(report *models.CrashReport) error <span class="cov0" title="0">{
        // Email implementation would go here
        // This is a placeholder for email notification logic
        return nil
}</span>

func (s *ErrorReportingService) sendToExternalServices(report *models.ErrorReport) <span class="cov0" title="0">{
        // Send to Sentry
        if s.config.SentryDSN != "" </span><span class="cov0" title="0">{
                s.sendToSentry(report)
        }</span>
}

func (s *ErrorReportingService) sendToSentry(report *models.ErrorReport) error <span class="cov0" title="0">{
        // Sentry integration would go here
        // This is a placeholder for Sentry integration
        return nil
}</span>

func (s *ErrorReportingService) sendToCrashlytics(report *models.CrashReport) error <span class="cov0" title="0">{
        if s.config.CrashlyticsAPIKey == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Crashlytics integration would go here
        // This is a placeholder for Firebase Crashlytics integration
        <span class="cov0" title="0">return nil</span>
}

func (s *ErrorReportingService) getColorForLevel(level string) string <span class="cov8" title="1">{
        switch strings.ToLower(level) </span>{
        case "error", "fatal":<span class="cov8" title="1">
                return "danger"</span>
        case "warning", "warn":<span class="cov8" title="1">
                return "warning"</span>
        case "info":<span class="cov8" title="1">
                return "good"</span>
        default:<span class="cov8" title="1">
                return "#36a64f"</span>
        }
}

func (s *ErrorReportingService) exportToCSV(reports []interface{}) ([]byte, error) <span class="cov8" title="1">{
        if len(reports) == 0 </span><span class="cov8" title="1">{
                return []byte(""), nil
        }</span>

        <span class="cov8" title="1">var buf bytes.Buffer
        writer := csv.NewWriter(&amp;buf)

        // Determine report type and write appropriate header
        firstReport := reports[0]

        switch firstReport.(type) </span>{
        case *models.ErrorReport:<span class="cov8" title="1">
                // Write header for error reports
                header := []string{
                        "ID", "User ID", "Level", "Message", "Error Code", "Component",
                        "Stack Trace", "User Agent", "URL", "Fingerprint", "Status",
                        "Reported At", "Resolved At",
                }
                if err := writer.Write(header); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write CSV header: %w", err)
                }</span>

                // Write error report data
                <span class="cov8" title="1">for _, r := range reports </span><span class="cov8" title="1">{
                        errorReport, ok := r.(*models.ErrorReport)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">resolvedAt := ""
                        if errorReport.ResolvedAt != nil </span><span class="cov8" title="1">{
                                resolvedAt = errorReport.ResolvedAt.Format(time.RFC3339)
                        }</span>

                        // Escape special characters in text fields
                        <span class="cov8" title="1">row := []string{
                                strconv.Itoa(errorReport.ID),
                                strconv.Itoa(errorReport.UserID),
                                errorReport.Level,
                                escapeCSVField(errorReport.Message),
                                errorReport.ErrorCode,
                                errorReport.Component,
                                escapeCSVField(errorReport.StackTrace),
                                errorReport.UserAgent,
                                errorReport.URL,
                                errorReport.Fingerprint,
                                errorReport.Status,
                                errorReport.ReportedAt.Format(time.RFC3339),
                                resolvedAt,
                        }
                        if err := writer.Write(row); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to write CSV row: %w", err)
                        }</span>
                }

        case *models.CrashReport:<span class="cov8" title="1">
                // Write header for crash reports
                header := []string{
                        "ID", "User ID", "Signal", "Message", "Stack Trace",
                        "Fingerprint", "Status", "Reported At", "Resolved At",
                }
                if err := writer.Write(header); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write CSV header: %w", err)
                }</span>

                // Write crash report data
                <span class="cov8" title="1">for _, r := range reports </span><span class="cov8" title="1">{
                        crashReport, ok := r.(*models.CrashReport)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">resolvedAt := ""
                        if crashReport.ResolvedAt != nil </span><span class="cov0" title="0">{
                                resolvedAt = crashReport.ResolvedAt.Format(time.RFC3339)
                        }</span>

                        <span class="cov8" title="1">row := []string{
                                strconv.Itoa(crashReport.ID),
                                strconv.Itoa(crashReport.UserID),
                                crashReport.Signal,
                                escapeCSVField(crashReport.Message),
                                escapeCSVField(crashReport.StackTrace),
                                crashReport.Fingerprint,
                                crashReport.Status,
                                crashReport.ReportedAt.Format(time.RFC3339),
                                resolvedAt,
                        }
                        if err := writer.Write(row); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to write CSV row: %w", err)
                        }</span>
                }

        default:<span class="cov8" title="1">
                // Handle mixed report types - use a combined format
                header := []string{
                        "Type", "ID", "User ID", "Level/Signal", "Message", "Error Code", "Component",
                        "Stack Trace", "User Agent", "URL", "Fingerprint", "Status",
                        "Reported At", "Resolved At",
                }
                if err := writer.Write(header); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write CSV header: %w", err)
                }</span>

                <span class="cov8" title="1">for _, r := range reports </span><span class="cov8" title="1">{
                        var row []string

                        switch report := r.(type) </span>{
                        case *models.ErrorReport:<span class="cov8" title="1">
                                resolvedAt := ""
                                if report.ResolvedAt != nil </span><span class="cov8" title="1">{
                                        resolvedAt = report.ResolvedAt.Format(time.RFC3339)
                                }</span>
                                <span class="cov8" title="1">row = []string{
                                        "error",
                                        strconv.Itoa(report.ID),
                                        strconv.Itoa(report.UserID),
                                        report.Level,
                                        escapeCSVField(report.Message),
                                        report.ErrorCode,
                                        report.Component,
                                        escapeCSVField(report.StackTrace),
                                        report.UserAgent,
                                        report.URL,
                                        report.Fingerprint,
                                        report.Status,
                                        report.ReportedAt.Format(time.RFC3339),
                                        resolvedAt,
                                }</span>
                        case *models.CrashReport:<span class="cov8" title="1">
                                resolvedAt := ""
                                if report.ResolvedAt != nil </span><span class="cov0" title="0">{
                                        resolvedAt = report.ResolvedAt.Format(time.RFC3339)
                                }</span>
                                <span class="cov8" title="1">row = []string{
                                        "crash",
                                        strconv.Itoa(report.ID),
                                        strconv.Itoa(report.UserID),
                                        report.Signal,
                                        escapeCSVField(report.Message),
                                        "", // Error Code (N/A for crash)
                                        "", // Component (N/A for crash)
                                        escapeCSVField(report.StackTrace),
                                        "", // User Agent (N/A for crash)
                                        "", // URL (N/A for crash)
                                        report.Fingerprint,
                                        report.Status,
                                        report.ReportedAt.Format(time.RFC3339),
                                        resolvedAt,
                                }</span>
                        default:<span class="cov8" title="1">
                                continue</span>
                        }

                        <span class="cov8" title="1">if err := writer.Write(row); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to write CSV row: %w", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">writer.Flush()
        if err := writer.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CSV writer error: %w", err)
        }</span>

        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// escapeCSVField handles special characters in CSV fields
// Newlines and other control characters are replaced with spaces to ensure valid CSV
func escapeCSVField(s string) string <span class="cov8" title="1">{
        // Replace newlines with spaces (CSV spec allows this within quoted fields,
        // but many parsers have issues with it)
        s = strings.ReplaceAll(s, "\r\n", " ")
        s = strings.ReplaceAll(s, "\n", " ")
        s = strings.ReplaceAll(s, "\r", " ")
        // Replace tabs with spaces
        s = strings.ReplaceAll(s, "\t", " ")
        return s
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package services

import (
        "bytes"
        "encoding/csv"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type FavoritesService struct {
        favoritesRepo *repository.FavoritesRepository
        authService   *AuthService
}

func NewFavoritesService(favoritesRepo *repository.FavoritesRepository, authService *AuthService) *FavoritesService <span class="cov8" title="1">{
        return &amp;FavoritesService{
                favoritesRepo: favoritesRepo,
                authService:   authService,
        }
}</span>

func (s *FavoritesService) AddFavorite(userID int, favorite *models.Favorite) (*models.Favorite, error) <span class="cov0" title="0">{
        existing, err := s.favoritesRepo.GetFavorite(userID, favorite.EntityType, favorite.EntityID)
        if err == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                return existing, fmt.Errorf("item already in favorites")
        }</span>

        <span class="cov0" title="0">favorite.UserID = userID
        favorite.CreatedAt = time.Now()

        id, err := s.favoritesRepo.CreateFavorite(favorite)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add favorite: %w", err)
        }</span>

        <span class="cov0" title="0">favorite.ID = id
        return favorite, nil</span>
}

func (s *FavoritesService) RemoveFavorite(userID int, entityType string, entityID int) error <span class="cov0" title="0">{
        favorite, err := s.favoritesRepo.GetFavorite(userID, entityType, entityID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("favorite not found: %w", err)
        }</span>

        <span class="cov0" title="0">if favorite.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("unauthorized to remove this favorite")
        }</span>

        <span class="cov0" title="0">return s.favoritesRepo.DeleteFavorite(favorite.ID)</span>
}

func (s *FavoritesService) GetUserFavorites(userID int, entityType *string, category *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetUserFavorites(userID, entityType, category, limit, offset)
}</span>

func (s *FavoritesService) GetFavoritesByEntity(userID int, entityType string, entityID int) (*models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetFavorite(userID, entityType, entityID)
}</span>

func (s *FavoritesService) IsFavorite(userID int, entityType string, entityID int) (bool, error) <span class="cov0" title="0">{
        favorite, err := s.favoritesRepo.GetFavorite(userID, entityType, entityID)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return favorite != nil, nil</span>
}

func (s *FavoritesService) UpdateFavorite(userID int, favoriteID int, updates *models.UpdateFavoriteRequest) (*models.Favorite, error) <span class="cov0" title="0">{
        favorite, err := s.favoritesRepo.GetFavoriteByID(favoriteID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("favorite not found: %w", err)
        }</span>

        <span class="cov0" title="0">if favorite.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unauthorized to update this favorite")
        }</span>

        <span class="cov0" title="0">if updates.Category != nil </span><span class="cov0" title="0">{
                favorite.Category = updates.Category
        }</span>

        <span class="cov0" title="0">if updates.Notes != nil </span><span class="cov0" title="0">{
                favorite.Notes = updates.Notes
        }</span>

        <span class="cov0" title="0">if updates.Tags != nil </span><span class="cov0" title="0">{
                favorite.Tags = updates.Tags
        }</span>

        <span class="cov0" title="0">if updates.IsPublic != nil </span><span class="cov0" title="0">{
                favorite.IsPublic = *updates.IsPublic
        }</span>

        <span class="cov0" title="0">favorite.UpdatedAt = &amp;time.Time{}
        *favorite.UpdatedAt = time.Now()

        err = s.favoritesRepo.UpdateFavorite(favorite)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update favorite: %w", err)
        }</span>

        <span class="cov0" title="0">return favorite, nil</span>
}

func (s *FavoritesService) GetFavoriteCategories(userID int, entityType *string) ([]models.FavoriteCategory, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetFavoriteCategories(userID, entityType)
}</span>

func (s *FavoritesService) CreateFavoriteCategory(userID int, category *models.FavoriteCategory) (*models.FavoriteCategory, error) <span class="cov0" title="0">{
        category.UserID = userID
        category.CreatedAt = time.Now()

        id, err := s.favoritesRepo.CreateFavoriteCategory(category)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create category: %w", err)
        }</span>

        <span class="cov0" title="0">category.ID = id
        return category, nil</span>
}

func (s *FavoritesService) UpdateFavoriteCategory(userID int, categoryID int, updates *models.UpdateFavoriteCategoryRequest) (*models.FavoriteCategory, error) <span class="cov0" title="0">{
        category, err := s.favoritesRepo.GetFavoriteCategoryByID(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("category not found: %w", err)
        }</span>

        <span class="cov0" title="0">if category.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unauthorized to update this category")
        }</span>

        <span class="cov0" title="0">if updates.Name != "" </span><span class="cov0" title="0">{
                category.Name = updates.Name
        }</span>

        <span class="cov0" title="0">if updates.Description != nil </span><span class="cov0" title="0">{
                category.Description = updates.Description
        }</span>

        <span class="cov0" title="0">if updates.Color != nil </span><span class="cov0" title="0">{
                category.Color = updates.Color
        }</span>

        <span class="cov0" title="0">if updates.Icon != nil </span><span class="cov0" title="0">{
                category.Icon = updates.Icon
        }</span>

        <span class="cov0" title="0">if updates.IsPublic != nil </span><span class="cov0" title="0">{
                category.IsPublic = *updates.IsPublic
        }</span>

        <span class="cov0" title="0">category.UpdatedAt = &amp;time.Time{}
        *category.UpdatedAt = time.Now()

        err = s.favoritesRepo.UpdateFavoriteCategory(category)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update category: %w", err)
        }</span>

        <span class="cov0" title="0">return category, nil</span>
}

func (s *FavoritesService) DeleteFavoriteCategory(userID int, categoryID int) error <span class="cov0" title="0">{
        category, err := s.favoritesRepo.GetFavoriteCategoryByID(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("category not found: %w", err)
        }</span>

        <span class="cov0" title="0">if category.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("unauthorized to delete this category")
        }</span>

        <span class="cov0" title="0">favoritesCount, err := s.favoritesRepo.CountFavoritesByCategory(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check category usage: %w", err)
        }</span>

        <span class="cov0" title="0">if favoritesCount &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot delete category with existing favorites")
        }</span>

        <span class="cov0" title="0">return s.favoritesRepo.DeleteFavoriteCategory(categoryID)</span>
}

func (s *FavoritesService) GetPublicFavorites(entityType *string, category *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetPublicFavorites(entityType, category, limit, offset)
}</span>

func (s *FavoritesService) SearchFavorites(userID int, query string, entityType *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.SearchFavorites(userID, query, entityType, limit, offset)
}</span>

func (s *FavoritesService) GetFavoriteStatistics(userID int) (*models.FavoriteStatistics, error) <span class="cov0" title="0">{
        stats := &amp;models.FavoriteStatistics{
                UserID: userID,
        }

        totalCount, err := s.favoritesRepo.CountUserFavorites(userID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total favorites count: %w", err)
        }</span>
        <span class="cov0" title="0">stats.TotalFavorites = totalCount

        entityTypeCounts, err := s.favoritesRepo.GetFavoritesCountByEntityType(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get entity type counts: %w", err)
        }</span>
        <span class="cov0" title="0">stats.FavoritesByEntityType = entityTypeCounts

        categoryCounts, err := s.favoritesRepo.GetFavoritesCountByCategory(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get category counts: %w", err)
        }</span>
        <span class="cov0" title="0">stats.FavoritesByCategory = categoryCounts

        recentFavorites, err := s.favoritesRepo.GetRecentFavorites(userID, 5)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent favorites: %w", err)
        }</span>
        <span class="cov0" title="0">stats.RecentFavorites = recentFavorites

        return stats, nil</span>
}

func (s *FavoritesService) GetRecommendedFavorites(userID int, limit int) ([]models.RecommendedFavorite, error) <span class="cov0" title="0">{
        userFavorites, err := s.favoritesRepo.GetUserFavorites(userID, nil, nil, 100, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user favorites: %w", err)
        }</span>

        <span class="cov0" title="0">var entityTypes []string

        for _, favorite := range userFavorites </span><span class="cov0" title="0">{
                entityTypes = append(entityTypes, favorite.EntityType)
        }</span>

        <span class="cov0" title="0">entityTypes = s.removeDuplicateStrings(entityTypes)

        var recommendations []models.RecommendedFavorite

        for _, entityType := range entityTypes </span><span class="cov0" title="0">{
                similarFavorites, err := s.favoritesRepo.GetSimilarFavorites(userID, entityType, limit/len(entityTypes))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, favorite := range similarFavorites </span><span class="cov0" title="0">{
                        recommendation := models.RecommendedFavorite{
                                Favorite:        favorite,
                                RecommendReason: fmt.Sprintf("Based on your interest in %s", entityType),
                                RecommendScore:  0.8,
                                RecommendedAt:   time.Now(),
                        }
                        recommendations = append(recommendations, recommendation)
                }</span>
        }

        <span class="cov0" title="0">if len(recommendations) &gt; limit </span><span class="cov0" title="0">{
                recommendations = recommendations[:limit]
        }</span>

        <span class="cov0" title="0">return recommendations, nil</span>
}

func (s *FavoritesService) ShareFavorite(userID int, favoriteID int, shareWith []int, permissions models.SharePermissions) (*models.FavoriteShare, error) <span class="cov0" title="0">{
        favorite, err := s.favoritesRepo.GetFavoriteByID(favoriteID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("favorite not found: %w", err)
        }</span>

        <span class="cov0" title="0">if favorite.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unauthorized to share this favorite")
        }</span>

        <span class="cov0" title="0">share := &amp;models.FavoriteShare{
                FavoriteID:   favoriteID,
                SharedByUser: userID,
                SharedWith:   shareWith,
                Permissions:  permissions,
                CreatedAt:    time.Now(),
                IsActive:     true,
        }

        id, err := s.favoritesRepo.CreateFavoriteShare(share)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create favorite share: %w", err)
        }</span>

        <span class="cov0" title="0">share.ID = id
        return share, nil</span>
}

func (s *FavoritesService) GetSharedFavorites(userID int, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetSharedFavorites(userID, limit, offset)
}</span>

func (s *FavoritesService) RevokeFavoriteShare(userID int, shareID int) error <span class="cov0" title="0">{
        share, err := s.favoritesRepo.GetFavoriteShareByID(shareID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("share not found: %w", err)
        }</span>

        <span class="cov0" title="0">if share.SharedByUser != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("unauthorized to revoke this share")
        }</span>

        <span class="cov0" title="0">return s.favoritesRepo.RevokeFavoriteShare(shareID)</span>
}

func (s *FavoritesService) BulkAddFavorites(userID int, favorites []models.BulkFavoriteRequest) ([]models.Favorite, error) <span class="cov0" title="0">{
        var results []models.Favorite
        var errors []error

        for _, req := range favorites </span><span class="cov0" title="0">{
                favorite := &amp;models.Favorite{
                        EntityType: req.EntityType,
                        EntityID:   req.EntityID,
                        Category:   req.Category,
                        Notes:      req.Notes,
                        Tags:       req.Tags,
                        IsPublic:   req.IsPublic,
                }

                result, err := s.AddFavorite(userID, favorite)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, err)
                        continue</span>
                }

                <span class="cov0" title="0">results = append(results, *result)</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 &amp;&amp; len(results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add any favorites: %v", errors)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

func (s *FavoritesService) BulkRemoveFavorites(userID int, favorites []models.BulkFavoriteRemoveRequest) error <span class="cov0" title="0">{
        var errors []error

        for _, req := range favorites </span><span class="cov0" title="0">{
                err := s.RemoveFavorite(userID, req.EntityType, req.EntityID)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, err)
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove some favorites: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *FavoritesService) ExportFavorites(userID int, format string) ([]byte, error) <span class="cov0" title="0">{
        favorites, err := s.favoritesRepo.GetUserFavorites(userID, nil, nil, 10000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user favorites: %w", err)
        }</span>

        <span class="cov0" title="0">switch format </span>{
        case "json":<span class="cov0" title="0">
                return s.exportFavoritesToJSON(favorites)</span>
        case "csv":<span class="cov0" title="0">
                return s.exportFavoritesToCSV(favorites)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported export format: %s", format)</span>
        }
}

func (s *FavoritesService) ImportFavorites(userID int, data []byte, format string) ([]models.Favorite, error) <span class="cov8" title="1">{
        switch format </span>{
        case "json":<span class="cov8" title="1">
                return s.importFavoritesFromJSON(userID, data)</span>
        case "csv":<span class="cov0" title="0">
                return s.importFavoritesFromCSV(userID, data)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported import format: %s", format)</span>
        }
}

func (s *FavoritesService) removeDuplicateStrings(slice []string) []string <span class="cov8" title="1">{
        keys := make(map[string]bool)
        var result []string

        for _, item := range slice </span><span class="cov8" title="1">{
                if !keys[item] </span><span class="cov8" title="1">{
                        keys[item] = true
                        result = append(result, item)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

func (s *FavoritesService) exportFavoritesToJSON(favorites []models.Favorite) ([]byte, error) <span class="cov8" title="1">{
        // Create export structure with metadata
        export := struct {
                Version    string                   `json:"version"`
                ExportedAt time.Time                `json:"exported_at"`
                Count      int                      `json:"count"`
                Favorites  []models.Favorite        `json:"favorites"`
                Categories []map[string]interface{} `json:"categories,omitempty"`
        }{
                Version:    "1.0",
                ExportedAt: time.Now(),
                Count:      len(favorites),
                Favorites:  favorites,
        }

        // Marshal to JSON
        data, err := json.MarshalIndent(export, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal favorites to JSON: %w", err)
        }</span>

        <span class="cov8" title="1">return data, nil</span>
}

func (s *FavoritesService) exportFavoritesToCSV(favorites []models.Favorite) ([]byte, error) <span class="cov8" title="1">{
        // Create CSV writer
        buffer := &amp;bytes.Buffer{}
        writer := csv.NewWriter(buffer)

        // Write header
        headers := []string{
                "ID", "UserID", "EntityType", "EntityID", "Category", "Notes",
                "Tags", "IsPublic", "CreatedAt", "UpdatedAt",
        }
        if err := writer.Write(headers); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write CSV headers: %w", err)
        }</span>

        // Write data rows
        <span class="cov8" title="1">for _, favorite := range favorites </span><span class="cov8" title="1">{
                // Handle nullable fields
                category := ""
                if favorite.Category != nil </span><span class="cov8" title="1">{
                        category = *favorite.Category
                }</span>

                <span class="cov8" title="1">notes := ""
                if favorite.Notes != nil </span><span class="cov8" title="1">{
                        notes = *favorite.Notes
                }</span>

                <span class="cov8" title="1">tags := ""
                if favorite.Tags != nil </span><span class="cov0" title="0">{
                        tags = fmt.Sprintf("%v", *favorite.Tags)
                }</span>

                <span class="cov8" title="1">updatedAt := ""
                if favorite.UpdatedAt != nil </span><span class="cov0" title="0">{
                        updatedAt = favorite.UpdatedAt.Format(time.RFC3339)
                }</span>

                <span class="cov8" title="1">record := []string{
                        fmt.Sprintf("%d", favorite.ID),
                        fmt.Sprintf("%d", favorite.UserID),
                        favorite.EntityType,
                        fmt.Sprintf("%d", favorite.EntityID),
                        category,
                        notes,
                        tags,
                        fmt.Sprintf("%t", favorite.IsPublic),
                        favorite.CreatedAt.Format(time.RFC3339),
                        updatedAt,
                }

                if err := writer.Write(record); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write CSV record: %w", err)
                }</span>
        }

        // Flush writer
        <span class="cov8" title="1">writer.Flush()
        if err := writer.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CSV writer error: %w", err)
        }</span>

        <span class="cov8" title="1">return buffer.Bytes(), nil</span>
}

func (s *FavoritesService) importFavoritesFromJSON(userID int, data []byte) ([]models.Favorite, error) <span class="cov8" title="1">{
        // Parse import data
        var importData struct {
                Version    string            `json:"version"`
                ExportedAt time.Time         `json:"exported_at"`
                Count      int               `json:"count"`
                Favorites  []models.Favorite `json:"favorites"`
        }

        if err := json.Unmarshal(data, &amp;importData); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse JSON data: %w", err)
        }</span>

        <span class="cov0" title="0">if len(importData.Favorites) == 0 </span><span class="cov0" title="0">{
                return []models.Favorite{}, nil
        }</span>

        // Process each favorite
        <span class="cov0" title="0">var importedFavorites []models.Favorite
        var errors []error

        for _, fav := range importData.Favorites </span><span class="cov0" title="0">{
                // Create new favorite with current user ID
                newFavorite := &amp;models.Favorite{
                        UserID:     userID, // Override with current user
                        EntityType: fav.EntityType,
                        EntityID:   fav.EntityID,
                        Category:   fav.Category,
                        Notes:      fav.Notes,
                        Tags:       fav.Tags,
                        IsPublic:   fav.IsPublic,
                }

                // Try to add favorite (will skip duplicates)
                result, err := s.AddFavorite(userID, newFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to import favorite %s %d: %w", fav.EntityType, fav.EntityID, err))
                        continue</span>
                }

                <span class="cov0" title="0">importedFavorites = append(importedFavorites, *result)</span>
        }

        // If all failed, return error
        <span class="cov0" title="0">if len(importedFavorites) == 0 &amp;&amp; len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to import any favorites: %v", errors)
        }</span>

        <span class="cov0" title="0">return importedFavorites, nil</span>
}

func (s *FavoritesService) importFavoritesFromCSV(userID int, data []byte) ([]models.Favorite, error) <span class="cov0" title="0">{
        // Parse CSV data
        reader := csv.NewReader(bytes.NewReader(data))

        // Read header
        headers, err := reader.Read()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read CSV headers: %w", err)
        }</span>

        // Validate headers (basic check)
        <span class="cov0" title="0">if len(headers) &lt; 9 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid CSV format: expected at least 9 columns, got %d", len(headers))
        }</span>

        // Read all records
        <span class="cov0" title="0">records, err := reader.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read CSV records: %w", err)
        }</span>

        <span class="cov0" title="0">var importedFavorites []models.Favorite
        var errors []error

        for i, record := range records </span><span class="cov0" title="0">{
                if len(record) &lt; 9 </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("record %d: insufficient columns", i+1))
                        continue</span>
                }

                // Parse entity type and ID
                <span class="cov0" title="0">entityType := record[2]
                entityIDStr := record[3]

                var entityID int
                if _, err := fmt.Sscanf(entityIDStr, "%d", &amp;entityID); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("record %d: invalid entity ID: %s", i+1, entityIDStr))
                        continue</span>
                }

                // Parse optional fields
                <span class="cov0" title="0">var category *string
                if record[4] != "" </span><span class="cov0" title="0">{
                        category = &amp;record[4]
                }</span>

                <span class="cov0" title="0">var notes *string
                if record[5] != "" </span><span class="cov0" title="0">{
                        notes = &amp;record[5]
                }</span>

                <span class="cov0" title="0">var tags *[]string
                if record[6] != "" </span><span class="cov0" title="0">{
                        // Simple comma-separated tags parsing
                        tagList := strings.Split(record[6], ",")
                        for i := range tagList </span><span class="cov0" title="0">{
                                tagList[i] = strings.TrimSpace(tagList[i])
                        }</span>
                        <span class="cov0" title="0">tags = &amp;tagList</span>
                }

                <span class="cov0" title="0">var isPublic bool
                if record[7] != "" </span><span class="cov0" title="0">{
                        if _, err := fmt.Sscanf(record[7], "%t", &amp;isPublic); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Errorf("record %d: invalid is_public value: %s", i+1, record[7]))
                                continue</span>
                        }
                }

                // Create favorite
                <span class="cov0" title="0">favorite := &amp;models.Favorite{
                        UserID:     userID,
                        EntityType: entityType,
                        EntityID:   entityID,
                        Category:   category,
                        Notes:      notes,
                        Tags:       tags,
                        IsPublic:   isPublic,
                }

                // Add favorite
                result, err := s.AddFavorite(userID, favorite)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("record %d: failed to add favorite: %w", i+1, err))
                        continue</span>
                }

                <span class="cov0" title="0">importedFavorites = append(importedFavorites, *result)</span>
        }

        // If all failed, return error
        <span class="cov0" title="0">if len(importedFavorites) == 0 &amp;&amp; len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to import any favorites: %v", errors)
        }</span>

        <span class="cov0" title="0">return importedFavorites, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package services

import (
        "archive/zip"
        "bytes"
        "compress/gzip"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type LogManagementService struct {
        logRepo       *repository.LogManagementRepository
        config        *LogManagementConfig
        logCollectors map[string]LogCollector
}

type LogManagementConfig struct {
        LogDirectory         string   `json:"log_directory"`
        MaxLogSize           int64    `json:"max_log_size"`        // in bytes
        MaxLogFiles          int      `json:"max_log_files"`       // per component
        RetentionDays        int      `json:"retention_days"`      // how long to keep logs
        CompressionEnabled   bool     `json:"compression_enabled"` // compress old logs
        RealTimeLogging      bool     `json:"real_time_logging"`   // enable real-time log streaming
        LogLevels            []string `json:"log_levels"`          // enabled log levels
        ComponentFilters     []string `json:"component_filters"`   // enabled components
        AutoCleanup          bool     `json:"auto_cleanup"`        // automatically cleanup old logs
        MaxShareDuration     int      `json:"max_share_duration"`  // hours
        AllowExternalSharing bool     `json:"allow_external_sharing"`
}

type LogCollector interface {
        CollectLogs() ([]*models.LogEntry, error)
        GetLogPath() string
        GetComponentName() string
}

type FileLogCollector struct {
        logPath       string
        componentName string
}

type DatabaseLogCollector struct {
        logRepo       *repository.LogManagementRepository
        componentName string
}

func NewLogManagementService(logRepo *repository.LogManagementRepository) *LogManagementService <span class="cov8" title="1">{
        config := &amp;LogManagementConfig{
                LogDirectory:         "/var/log/catalogizer",
                MaxLogSize:           100 * 1024 * 1024, // 100MB
                MaxLogFiles:          10,
                RetentionDays:        30,
                CompressionEnabled:   true,
                RealTimeLogging:      true,
                LogLevels:            []string{"error", "warning", "info", "debug"},
                ComponentFilters:     []string{"api", "auth", "sync", "conversion", "stress_test"},
                AutoCleanup:          true,
                MaxShareDuration:     24, // 24 hours
                AllowExternalSharing: false,
        }

        service := &amp;LogManagementService{
                logRepo:       logRepo,
                config:        config,
                logCollectors: make(map[string]LogCollector),
        }

        // Initialize default collectors
        service.initializeCollectors()

        return service
}</span>

func (s *LogManagementService) initializeCollectors() <span class="cov8" title="1">{
        // File-based collectors
        components := []string{"api", "auth", "sync", "conversion", "stress_test", "error_reporting"}
        for _, component := range components </span><span class="cov8" title="1">{
                logPath := filepath.Join(s.config.LogDirectory, component+".log")
                s.logCollectors[component] = &amp;FileLogCollector{
                        logPath:       logPath,
                        componentName: component,
                }
        }</span>

        // Database collector for application logs
        <span class="cov8" title="1">s.logCollectors["database"] = &amp;DatabaseLogCollector{
                logRepo:       s.logRepo,
                componentName: "database",
        }</span>
}

func (s *LogManagementService) CollectLogs(userID int, request *models.LogCollectionRequest) (*models.LogCollection, error) <span class="cov0" title="0">{
        collection := &amp;models.LogCollection{
                UserID:      userID,
                Name:        request.Name,
                Description: request.Description,
                Components:  request.Components,
                LogLevel:    request.LogLevel,
                StartTime:   request.StartTime,
                EndTime:     request.EndTime,
                CreatedAt:   time.Now(),
                Status:      models.LogCollectionStatusInProgress,
                Filters:     request.Filters,
        }

        // Create the collection record
        if err := s.logRepo.CreateLogCollection(collection); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log collection: %w", err)
        }</span>

        // Start collection process
        <span class="cov0" title="0">go s.performLogCollection(collection)

        return collection, nil</span>
}

func (s *LogManagementService) performLogCollection(collection *models.LogCollection) <span class="cov0" title="0">{
        var allEntries []*models.LogEntry

        // Collect logs from each component
        for _, component := range collection.Components </span><span class="cov0" title="0">{
                collector, exists := s.logCollectors[component]
                if !exists </span><span class="cov0" title="0">{
                        s.logError(collection.ID, fmt.Sprintf("Unknown component: %s", component))
                        continue</span>
                }

                <span class="cov0" title="0">entries, err := collector.CollectLogs()
                if err != nil </span><span class="cov0" title="0">{
                        s.logError(collection.ID, fmt.Sprintf("Failed to collect logs from %s: %v", component, err))
                        continue</span>
                }

                // Filter entries
                <span class="cov0" title="0">filteredEntries := s.filterLogEntries(entries, collection)
                allEntries = append(allEntries, filteredEntries...)</span>
        }

        // Sort entries by timestamp
        <span class="cov0" title="0">sort.Slice(allEntries, func(i, j int) bool </span><span class="cov0" title="0">{
                return allEntries[i].Timestamp.Before(allEntries[j].Timestamp)
        }</span>)

        // Store collected entries
        <span class="cov0" title="0">for _, entry := range allEntries </span><span class="cov0" title="0">{
                entry.CollectionID = collection.ID
                if err := s.logRepo.CreateLogEntry(entry); err != nil </span><span class="cov0" title="0">{
                        s.logError(collection.ID, fmt.Sprintf("Failed to store log entry: %v", err))
                }</span>
        }

        // Update collection status
        <span class="cov0" title="0">collection.Status = models.LogCollectionStatusCompleted
        collection.CompletedAt = &amp;[]time.Time{time.Now()}[0]
        collection.EntryCount = len(allEntries)

        if err := s.logRepo.UpdateLogCollection(collection); err != nil </span><span class="cov0" title="0">{
                s.logError(collection.ID, fmt.Sprintf("Failed to update collection status: %v", err))
        }</span>
}

func (s *LogManagementService) GetLogCollection(id int, userID int) (*models.LogCollection, error) <span class="cov0" title="0">{
        collection, err := s.logRepo.GetLogCollection(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log collection: %w", err)
        }</span>

        <span class="cov0" title="0">if collection.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">return collection, nil</span>
}

func (s *LogManagementService) GetLogCollectionsByUser(userID int, limit, offset int) ([]*models.LogCollection, error) <span class="cov0" title="0">{
        return s.logRepo.GetLogCollectionsByUser(userID, limit, offset)
}</span>

func (s *LogManagementService) GetLogEntries(collectionID int, userID int, filters *models.LogEntryFilters) ([]*models.LogEntry, error) <span class="cov0" title="0">{
        // Verify user has access to collection
        collection, err := s.GetLogCollection(collectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if collection.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">return s.logRepo.GetLogEntries(collectionID, filters)</span>
}

func (s *LogManagementService) CreateLogShare(userID int, request *models.LogShareRequest) (*models.LogShare, error) <span class="cov0" title="0">{
        // Verify user has access to collection
        collection, err := s.GetLogCollection(request.CollectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if collection.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        // Create share
        <span class="cov0" title="0">share := &amp;models.LogShare{
                CollectionID: request.CollectionID,
                UserID:       userID,
                ShareToken:   s.generateShareToken(),
                ShareType:    request.ShareType,
                ExpiresAt:    time.Now().Add(time.Duration(s.config.MaxShareDuration) * time.Hour),
                CreatedAt:    time.Now(),
                IsActive:     true,
                Permissions:  request.Permissions,
                Recipients:   request.Recipients,
        }

        if request.ExpiresAt != nil &amp;&amp; request.ExpiresAt.Before(share.ExpiresAt) </span><span class="cov0" title="0">{
                share.ExpiresAt = *request.ExpiresAt
        }</span>

        <span class="cov0" title="0">if err := s.logRepo.CreateLogShare(share); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log share: %w", err)
        }</span>

        <span class="cov0" title="0">return share, nil</span>
}

func (s *LogManagementService) GetLogShare(token string) (*models.LogShare, error) <span class="cov0" title="0">{
        share, err := s.logRepo.GetLogShareByToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log share: %w", err)
        }</span>

        <span class="cov0" title="0">if !share.IsActive || time.Now().After(share.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("share expired or inactive")
        }</span>

        <span class="cov0" title="0">return share, nil</span>
}

func (s *LogManagementService) RevokeLogShare(id int, userID int) error <span class="cov0" title="0">{
        share, err := s.logRepo.GetLogShare(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get log share: %w", err)
        }</span>

        // Verify user owns the shared collection
        <span class="cov0" title="0">collection, err := s.GetLogCollection(share.CollectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if collection.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">share.IsActive = false
        return s.logRepo.UpdateLogShare(share)</span>
}

func (s *LogManagementService) ExportLogs(collectionID int, userID int, format string) ([]byte, error) <span class="cov0" title="0">{
        // Verify access
        _, err := s.GetLogCollection(collectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get log entries
        <span class="cov0" title="0">entries, err := s.logRepo.GetLogEntries(collectionID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log entries: %w", err)
        }</span>

        <span class="cov0" title="0">switch format </span>{
        case "json":<span class="cov0" title="0">
                return json.MarshalIndent(entries, "", "  ")</span>
        case "csv":<span class="cov0" title="0">
                return s.exportToCSV(entries)</span>
        case "txt":<span class="cov0" title="0">
                return s.exportToText(entries)</span>
        case "zip":<span class="cov0" title="0">
                return s.exportToZip(entries)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported format: %s", format)</span>
        }
}

func (s *LogManagementService) StreamLogs(userID int, filters *models.LogStreamFilters) (&lt;-chan *models.LogEntry, error) <span class="cov0" title="0">{
        if !s.config.RealTimeLogging </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("real-time logging is disabled")
        }</span>

        // Create a channel for streaming
        <span class="cov0" title="0">logChannel := make(chan *models.LogEntry, 100)

        // Start streaming goroutine
        go s.streamLogEntries(logChannel, filters)

        return logChannel, nil</span>
}

func (s *LogManagementService) AnalyzeLogs(collectionID int, userID int) (*models.LogAnalysis, error) <span class="cov0" title="0">{
        // Verify access
        _, err := s.GetLogCollection(collectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get log entries
        <span class="cov0" title="0">entries, err := s.logRepo.GetLogEntries(collectionID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log entries: %w", err)
        }</span>

        <span class="cov0" title="0">analysis := &amp;models.LogAnalysis{
                CollectionID:       collectionID,
                TotalEntries:       len(entries),
                EntriesByLevel:     make(map[string]int),
                EntriesByComponent: make(map[string]int),
                ErrorPatterns:      make(map[string]int),
                TimeRange:          &amp;models.TimeRange{},
        }

        if len(entries) == 0 </span><span class="cov0" title="0">{
                return analysis, nil
        }</span>

        // Analyze entries
        <span class="cov0" title="0">analysis.TimeRange.Start = entries[0].Timestamp
        analysis.TimeRange.End = entries[len(entries)-1].Timestamp

        for _, entry := range entries </span><span class="cov0" title="0">{
                // Count by level
                analysis.EntriesByLevel[entry.Level]++

                // Count by component
                analysis.EntriesByComponent[entry.Component]++

                // Extract error patterns
                if entry.Level == "error" || entry.Level == "fatal" </span><span class="cov0" title="0">{
                        pattern := s.extractErrorPattern(entry.Message)
                        analysis.ErrorPatterns[pattern]++
                }</span>
        }

        // Generate insights
        <span class="cov0" title="0">analysis.Insights = s.generateInsights(entries, analysis)

        return analysis, nil</span>
}

func (s *LogManagementService) CleanupOldLogs() error <span class="cov0" title="0">{
        if !s.config.AutoCleanup </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cutoff := time.Now().AddDate(0, 0, -s.config.RetentionDays)

        // Cleanup collections
        if err := s.logRepo.CleanupOldCollections(cutoff); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old collections: %w", err)
        }</span>

        // Cleanup shares
        <span class="cov0" title="0">if err := s.logRepo.CleanupExpiredShares(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup expired shares: %w", err)
        }</span>

        // Cleanup physical log files
        <span class="cov0" title="0">return s.cleanupPhysicalLogFiles(cutoff)</span>
}

func (s *LogManagementService) GetConfiguration() *LogManagementConfig <span class="cov8" title="1">{
        return s.config
}</span>

func (s *LogManagementService) UpdateConfiguration(config *LogManagementConfig) error <span class="cov8" title="1">{
        s.config = config
        s.initializeCollectors() // Re-initialize collectors with new config
        return nil
}</span>

func (s *LogManagementService) GetLogStatistics(userID int) (*models.LogStatistics, error) <span class="cov0" title="0">{
        return s.logRepo.GetLogStatistics(userID)
}</span>

// Helper methods

func (s *LogManagementService) filterLogEntries(entries []*models.LogEntry, collection *models.LogCollection) []*models.LogEntry <span class="cov8" title="1">{
        var filtered []*models.LogEntry

        for _, entry := range entries </span><span class="cov8" title="1">{
                // Filter by time range
                if collection.StartTime != nil &amp;&amp; entry.Timestamp.Before(*collection.StartTime) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if collection.EndTime != nil &amp;&amp; entry.Timestamp.After(*collection.EndTime) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Filter by log level
                <span class="cov8" title="1">if collection.LogLevel != "" &amp;&amp; !s.isLogLevelIncluded(entry.Level, collection.LogLevel) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Apply custom filters
                <span class="cov8" title="1">if collection.Filters != nil &amp;&amp; !s.matchesFilters(entry, collection.Filters) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">filtered = append(filtered, entry)</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

func (s *LogManagementService) isLogLevelIncluded(entryLevel, filterLevel string) bool <span class="cov8" title="1">{
        levels := map[string]int{
                "debug":   0,
                "info":    1,
                "warning": 2,
                "error":   3,
                "fatal":   4,
        }

        entryLevelNum, exists := levels[strings.ToLower(entryLevel)]
        if !exists </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">filterLevelNum, exists := levels[strings.ToLower(filterLevel)]
        if !exists </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return entryLevelNum &gt;= filterLevelNum</span>
}

func (s *LogManagementService) matchesFilters(entry *models.LogEntry, filters map[string]interface{}) bool <span class="cov8" title="1">{
        for key, value := range filters </span><span class="cov8" title="1">{
                switch key </span>{
                case "message_contains":<span class="cov8" title="1">
                        if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                                if !strings.Contains(strings.ToLower(entry.Message), strings.ToLower(str)) </span><span class="cov8" title="1">{
                                        return false
                                }</span>
                        }
                case "component":<span class="cov8" title="1">
                        if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                                if entry.Component != str </span><span class="cov8" title="1">{
                                        return false
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return true</span>
}

func (s *LogManagementService) generateShareToken() string <span class="cov8" title="1">{
        // Generate a secure random token
        return fmt.Sprintf("log_share_%d_%d", time.Now().Unix(), time.Now().Nanosecond())
}</span>

func (s *LogManagementService) exportToCSV(entries []*models.LogEntry) ([]byte, error) <span class="cov8" title="1">{
        var buffer bytes.Buffer

        // Write CSV header
        buffer.WriteString("Timestamp,Level,Component,Message,Context\n")

        // Write entries
        for _, entry := range entries </span><span class="cov8" title="1">{
                contextJSON, _ := json.Marshal(entry.Context)
                buffer.WriteString(fmt.Sprintf("%s,%s,%s,\"%s\",\"%s\"\n",
                        entry.Timestamp.Format(time.RFC3339),
                        entry.Level,
                        entry.Component,
                        strings.ReplaceAll(entry.Message, "\"", "\"\""),
                        string(contextJSON)))
        }</span>

        <span class="cov8" title="1">return buffer.Bytes(), nil</span>
}

func (s *LogManagementService) exportToText(entries []*models.LogEntry) ([]byte, error) <span class="cov8" title="1">{
        var buffer bytes.Buffer

        for _, entry := range entries </span><span class="cov8" title="1">{
                buffer.WriteString(fmt.Sprintf("[%s] [%s] [%s] %s\n",
                        entry.Timestamp.Format(time.RFC3339),
                        strings.ToUpper(entry.Level),
                        entry.Component,
                        entry.Message))
        }</span>

        <span class="cov8" title="1">return buffer.Bytes(), nil</span>
}

func (s *LogManagementService) exportToZip(entries []*models.LogEntry) ([]byte, error) <span class="cov8" title="1">{
        var buffer bytes.Buffer
        zipWriter := zip.NewWriter(&amp;buffer)

        // Create JSON file
        jsonData, err := json.MarshalIndent(entries, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">jsonFile, err := zipWriter.Create("logs.json")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">jsonFile.Write(jsonData)

        // Create text file
        textData, err := s.exportToText(entries)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">textFile, err := zipWriter.Create("logs.txt")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">textFile.Write(textData)

        zipWriter.Close()
        return buffer.Bytes(), nil</span>
}

func (s *LogManagementService) streamLogEntries(channel chan&lt;- *models.LogEntry, filters *models.LogStreamFilters) <span class="cov0" title="0">{
        defer close(channel)

        // This is a simplified implementation
        // In a real system, you would tail log files or watch for new database entries
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()

        for range ticker.C </span>{<span class="cov0" title="0">
                // Check for new log entries and send them to the channel
                // This is a placeholder implementation
        }</span>
}

func (s *LogManagementService) extractErrorPattern(message string) string <span class="cov8" title="1">{
        // Simple pattern extraction - remove specific details to group similar errors
        // This is a simplified implementation
        words := strings.Fields(message)
        if len(words) &gt; 5 </span><span class="cov8" title="1">{
                return strings.Join(words[:5], " ") + "..."
        }</span>
        <span class="cov8" title="1">return message</span>
}

func (s *LogManagementService) generateInsights(entries []*models.LogEntry, analysis *models.LogAnalysis) []string <span class="cov8" title="1">{
        var insights []string

        // Check error rate
        errorCount := analysis.EntriesByLevel["error"] + analysis.EntriesByLevel["fatal"]
        errorRate := float64(errorCount) / float64(analysis.TotalEntries) * 100

        if errorRate &gt; 10 </span><span class="cov8" title="1">{
                insights = append(insights, fmt.Sprintf("High error rate detected: %.1f%%", errorRate))
        }</span>

        // Check for component with most errors
        <span class="cov8" title="1">maxErrors := 0
        maxComponent := ""
        for component, count := range analysis.EntriesByComponent </span><span class="cov8" title="1">{
                if count &gt; maxErrors </span><span class="cov8" title="1">{
                        maxErrors = count
                        maxComponent = component
                }</span>
        }

        <span class="cov8" title="1">if maxComponent != "" </span><span class="cov8" title="1">{
                insights = append(insights, fmt.Sprintf("Component '%s' generated the most log entries (%d)", maxComponent, maxErrors))
        }</span>

        <span class="cov8" title="1">return insights</span>
}

func (s *LogManagementService) cleanupPhysicalLogFiles(cutoff time.Time) error <span class="cov0" title="0">{
        return filepath.Walk(s.config.LogDirectory, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !info.IsDir() &amp;&amp; info.ModTime().Before(cutoff) </span><span class="cov0" title="0">{
                        // Compress old log files if compression is enabled
                        if s.config.CompressionEnabled &amp;&amp; !strings.HasSuffix(path, ".gz") </span><span class="cov0" title="0">{
                                if err := s.compressLogFile(path); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov0" title="0">return nil</span>
        })
}

func (s *LogManagementService) compressLogFile(path string) error <span class="cov0" title="0">{
        input, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer input.Close()

        output, err := os.Create(path + ".gz")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer output.Close()

        gzipWriter := gzip.NewWriter(output)
        defer gzipWriter.Close()

        _, err = io.Copy(gzipWriter, input)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Remove original file after successful compression
        <span class="cov0" title="0">return os.Remove(path)</span>
}

func (s *LogManagementService) logError(collectionID int, message string) <span class="cov0" title="0">{
        // Log error to the system log (simplified implementation)
        fmt.Printf("[ERROR] Collection %d: %s\n", collectionID, message)
}</span>

// LogCollector implementations

func (c *FileLogCollector) CollectLogs() ([]*models.LogEntry, error) <span class="cov0" title="0">{
        file, err := os.Open(c.logPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var entries []*models.LogEntry
        // This is a simplified implementation
        // In reality, you would parse the log file format

        return entries, nil</span>
}

func (c *FileLogCollector) GetLogPath() string <span class="cov8" title="1">{
        return c.logPath
}</span>

func (c *FileLogCollector) GetComponentName() string <span class="cov8" title="1">{
        return c.componentName
}</span>

func (c *DatabaseLogCollector) CollectLogs() ([]*models.LogEntry, error) <span class="cov0" title="0">{
        // Collect logs from database
        return c.logRepo.GetRecentLogEntries(c.componentName, 1000)
}</span>

func (c *DatabaseLogCollector) GetLogPath() string <span class="cov8" title="1">{
        return "database"
}</span>

func (c *DatabaseLogCollector) GetComponentName() string <span class="cov8" title="1">{
        return c.componentName
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package services

import (
        "bytes"
        "encoding/json"
        "fmt"
        "html/template"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"

        "github.com/unidoc/unipdf/v3/creator"
        "github.com/unidoc/unipdf/v3/model"
)

type ReportingService struct {
        analyticsRepo *repository.AnalyticsRepository
        userRepo      *repository.UserRepository
}

func NewReportingService(analyticsRepo *repository.AnalyticsRepository, userRepo *repository.UserRepository) *ReportingService <span class="cov8" title="1">{
        return &amp;ReportingService{
                analyticsRepo: analyticsRepo,
                userRepo:      userRepo,
        }
}</span>

func (s *ReportingService) GenerateReport(reportType string, format string, params map[string]interface{}) (*models.GeneratedReport, error) <span class="cov8" title="1">{
        var data interface{}
        var err error

        switch reportType </span>{
        case "user_analytics":<span class="cov8" title="1">
                data, err = s.generateUserAnalyticsData(params)</span>
        case "system_overview":<span class="cov8" title="1">
                data, err = s.generateSystemOverviewData(params)</span>
        case "media_analytics":<span class="cov8" title="1">
                data, err = s.generateMediaAnalyticsData(params)</span>
        case "user_activity":<span class="cov0" title="0">
                data, err = s.generateUserActivityData(params)</span>
        case "security_audit":<span class="cov8" title="1">
                data, err = s.generateSecurityAuditData(params)</span>
        case "performance_metrics":<span class="cov8" title="1">
                data, err = s.generatePerformanceMetricsData(params)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported report type: %s", reportType)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to generate report data: %w", err)
        }</span>

        <span class="cov0" title="0">content, err := s.formatReport(data, format, reportType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to format report: %w", err)
        }</span>

        <span class="cov0" title="0">report := &amp;models.GeneratedReport{
                Type:        reportType,
                Format:      format,
                Content:     content,
                GeneratedAt: time.Now(),
                Parameters:  params,
        }

        return report, nil</span>
}

func (s *ReportingService) generateUserAnalyticsData(params map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        userID, ok := params["user_id"].(int)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("user_id parameter required")
        }</span>

        <span class="cov8" title="1">startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">mediaAccessLogs, err := s.analyticsRepo.GetUserMediaAccessLogs(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get media access logs: %w", err)
        }</span>

        <span class="cov0" title="0">events, err := s.analyticsRepo.GetUserEvents(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user events: %w", err)
        }</span>

        <span class="cov0" title="0">analytics := &amp;models.UserAnalyticsReport{
                User:               user,
                StartDate:          startDate,
                EndDate:            endDate,
                TotalMediaAccesses: len(mediaAccessLogs),
                TotalEvents:        len(events),
                MediaAccessLogs:    mediaAccessLogs,
                Events:             events,
                AccessPatterns:     s.analyzeUserAccessPatterns(mediaAccessLogs),
                DeviceUsage:        s.analyzeUserDeviceUsage(mediaAccessLogs),
                LocationAnalysis:   s.analyzeUserLocations(mediaAccessLogs),
                TimePatterns:       s.analyzeUserTimePatterns(mediaAccessLogs),
                PopularContent:     s.analyzeUserPopularContent(mediaAccessLogs),
        }

        return analytics, nil</span>
}

func (s *ReportingService) generateSystemOverviewData(params map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">totalUsers, err := s.analyticsRepo.GetTotalUsers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total users: %w", err)
        }</span>

        <span class="cov0" title="0">activeUsers, err := s.analyticsRepo.GetActiveUsers(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active users: %w", err)
        }</span>

        <span class="cov0" title="0">totalMediaAccesses, err := s.analyticsRepo.GetTotalMediaAccesses(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total media accesses: %w", err)
        }</span>

        <span class="cov0" title="0">totalEvents, err := s.analyticsRepo.GetTotalEvents(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total events: %w", err)
        }</span>

        <span class="cov0" title="0">topMedia, err := s.analyticsRepo.GetTopAccessedMedia(startDate, endDate, 20)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top media: %w", err)
        }</span>

        <span class="cov0" title="0">userGrowth, err := s.analyticsRepo.GetUserGrowthData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user growth data: %w", err)
        }</span>

        <span class="cov0" title="0">overview := &amp;models.SystemOverviewReport{
                StartDate:          startDate,
                EndDate:            endDate,
                TotalUsers:         totalUsers,
                ActiveUsers:        activeUsers,
                TotalMediaAccesses: totalMediaAccesses,
                TotalEvents:        totalEvents,
                TopAccessedMedia:   topMedia,
                UserGrowthData:     userGrowth,
                SystemHealth:       s.calculateSystemHealth(totalUsers, activeUsers, totalMediaAccesses),
                UsageStatistics:    s.calculateUsageStatistics(startDate, endDate),
                PerformanceMetrics: s.calculatePerformanceMetrics(startDate, endDate),
        }

        return overview, nil</span>
}

func (s *ReportingService) generateMediaAnalyticsData(params map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        mediaIDFloat, ok := params["media_id"].(float64)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("media_id parameter required")
        }</span>
        <span class="cov0" title="0">mediaID := int(mediaIDFloat)

        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">accessLogs, err := s.analyticsRepo.GetMediaAccessLogs(0, &amp;mediaID, 10000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get media access logs: %w", err)
        }</span>

        <span class="cov0" title="0">filteredLogs := s.filterLogsByDateRange(accessLogs, startDate, endDate)

        analytics := &amp;models.MediaAnalyticsReport{
                MediaID:        mediaID,
                StartDate:      startDate,
                EndDate:        endDate,
                TotalAccesses:  len(filteredLogs),
                UniqueUsers:    s.countUniqueUsers(filteredLogs),
                AccessLogs:     filteredLogs,
                AccessPatterns: s.analyzeAccessPatterns(filteredLogs),
                UserEngagement: s.analyzeUserEngagement(filteredLogs),
                GeographicData: s.analyzeGeographicDistribution(filteredLogs),
                DeviceAnalysis: s.analyzeDeviceDistribution(filteredLogs),
                TimeAnalysis:   s.analyzeTimeDistribution(filteredLogs),
        }

        return analytics, nil</span>
}

func (s *ReportingService) generateUserActivityData(params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">allLogs, err := s.analyticsRepo.GetAllMediaAccessLogs(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all media access logs: %w", err)
        }</span>

        <span class="cov0" title="0">userActivity := make(map[int][]models.MediaAccessLog)
        for _, log := range allLogs </span><span class="cov0" title="0">{
                userActivity[log.UserID] = append(userActivity[log.UserID], log)
        }</span>

        <span class="cov0" title="0">var userActivities []models.UserActivitySummary
        for userID, logs := range userActivity </span><span class="cov0" title="0">{
                user, err := s.userRepo.GetByID(userID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">activity := models.UserActivitySummary{
                        User:              user,
                        TotalAccesses:     len(logs),
                        LastActivity:      s.getLastActivityTime(logs),
                        MostActiveHour:    s.getMostActiveHour(logs),
                        PreferredDevices:  s.getPreferredDevices(logs),
                        AccessedLocations: s.getAccessedLocations(logs),
                }

                userActivities = append(userActivities, activity)</span>
        }

        <span class="cov0" title="0">report := &amp;models.UserActivityReport{
                StartDate:      startDate,
                EndDate:        endDate,
                UserActivities: userActivities,
                TotalUsers:     len(userActivities),
                TotalAccesses:  len(allLogs),
                Summary:        s.generateActivitySummary(userActivities),
        }

        return report, nil</span>
}

func (s *ReportingService) generateSecurityAuditData(params map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // For now, return basic security metrics
        // In a full implementation, this would analyze login attempts, failed authentications, etc.
        <span class="cov0" title="0">audit := &amp;models.SecurityAuditReport{
                StartDate:           startDate,
                EndDate:             endDate,
                FailedLoginAttempts: 0, // Would be calculated from actual data
                SuccessfulLogins:    0, // Would be calculated from actual data
                SuspiciousActivity:  []models.SecurityIncident{},
                SecurityMetrics:     s.calculateSecurityMetrics(startDate, endDate),
        }

        return audit, nil</span>
}

func (s *ReportingService) generatePerformanceMetricsData(params map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sessionData, err := s.analyticsRepo.GetSessionData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get session data: %w", err)
        }</span>

        <span class="cov0" title="0">metrics := &amp;models.PerformanceMetricsReport{
                StartDate:              startDate,
                EndDate:                endDate,
                AverageSessionDuration: s.calculateAverageSessionDuration(sessionData),
                TotalSessions:          len(sessionData),
                ResponseTimes:          s.calculateResponseTimes(startDate, endDate),
                SystemLoad:             s.calculateSystemLoad(startDate, endDate),
                ErrorRates:             s.calculateErrorRates(startDate, endDate),
        }

        return metrics, nil</span>
}

func (s *ReportingService) formatReport(data interface{}, format string, reportType string) ([]byte, error) <span class="cov8" title="1">{
        switch format </span>{
        case "json":<span class="cov8" title="1">
                return json.MarshalIndent(data, "", "  ")</span>
        case "markdown":<span class="cov0" title="0">
                return s.formatAsMarkdown(data, reportType)</span>
        case "html":<span class="cov0" title="0">
                return s.formatAsHTML(data, reportType)</span>
        case "pdf":<span class="cov0" title="0">
                return s.formatAsPDF(data, reportType)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported format: %s", format)</span>
        }
}

func (s *ReportingService) formatAsMarkdown(data interface{}, reportType string) ([]byte, error) <span class="cov0" title="0">{
        var buffer bytes.Buffer

        switch reportType </span>{
        case "user_analytics":<span class="cov0" title="0">
                report := data.(*models.UserAnalyticsReport)
                buffer.WriteString("# User Analytics Report\n\n")
                displayName := ""
                if report.User.DisplayName != nil </span><span class="cov0" title="0">{
                        displayName = *report.User.DisplayName
                }</span>
                <span class="cov0" title="0">buffer.WriteString(fmt.Sprintf("**User:** %s (%s)\n", displayName, report.User.Username))
                buffer.WriteString(fmt.Sprintf("**Period:** %s to %s\n\n", report.StartDate.Format("2006-01-02"), report.EndDate.Format("2006-01-02")))
                buffer.WriteString("## Summary\n\n")
                buffer.WriteString(fmt.Sprintf("- Total Media Accesses: %d\n", report.TotalMediaAccesses))
                buffer.WriteString(fmt.Sprintf("- Total Events: %d\n", report.TotalEvents))
                buffer.WriteString(fmt.Sprintf("- Account Created: %s\n\n", report.User.CreatedAt.Format("2006-01-02")))</span>

        case "system_overview":<span class="cov0" title="0">
                report := data.(*models.SystemOverviewReport)
                buffer.WriteString("# System Overview Report\n\n")
                buffer.WriteString(fmt.Sprintf("**Period:** %s to %s\n\n", report.StartDate.Format("2006-01-02"), report.EndDate.Format("2006-01-02")))
                buffer.WriteString("## System Statistics\n\n")
                buffer.WriteString(fmt.Sprintf("- Total Users: %d\n", report.TotalUsers))
                buffer.WriteString(fmt.Sprintf("- Active Users: %d\n", report.ActiveUsers))
                buffer.WriteString(fmt.Sprintf("- Total Media Accesses: %d\n", report.TotalMediaAccesses))
                buffer.WriteString(fmt.Sprintf("- Total Events: %d\n\n", report.TotalEvents))</span>

        default:<span class="cov0" title="0">
                buffer.WriteString(fmt.Sprintf("# %s Report\n\n", reportType))
                jsonData, _ := json.MarshalIndent(data, "", "  ")
                buffer.WriteString(fmt.Sprintf("```json\n%s\n```\n", string(jsonData)))</span>
        }

        <span class="cov0" title="0">return buffer.Bytes(), nil</span>
}

func (s *ReportingService) formatAsHTML(data interface{}, reportType string) ([]byte, error) <span class="cov0" title="0">{
        htmlTemplate := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;{{.Title}}&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 40px; }
        .header { border-bottom: 2px solid #333; padding-bottom: 20px; margin-bottom: 30px; }
        .section { margin-bottom: 30px; }
        .metric { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 5px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="header"&gt;
        &lt;h1&gt;{{.Title}}&lt;/h1&gt;
        &lt;p&gt;Generated on: {{.GeneratedAt}}&lt;/p&gt;
        {{if .Period}}&lt;p&gt;Period: {{.Period}}&lt;/p&gt;{{end}}
    &lt;/div&gt;

    &lt;div class="content"&gt;
        {{.Content}}
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`

        tmpl, err := template.New("report").Parse(htmlTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse HTML template: %w", err)
        }</span>

        <span class="cov0" title="0">var content string
        switch reportType </span>{
        case "user_analytics":<span class="cov0" title="0">
                report := data.(*models.UserAnalyticsReport)
                displayNameHTML := ""
                if report.User.DisplayName != nil </span><span class="cov0" title="0">{
                        displayNameHTML = *report.User.DisplayName
                }</span>
                <span class="cov0" title="0">content = fmt.Sprintf(`
                        &lt;div class="section"&gt;
                                &lt;h2&gt;User Information&lt;/h2&gt;
                                &lt;div class="metric"&gt;Username: %s&lt;/div&gt;
                                &lt;div class="metric"&gt;Display Name: %s&lt;/div&gt;
                                &lt;div class="metric"&gt;Email: %s&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="section"&gt;
                                &lt;h2&gt;Activity Summary&lt;/h2&gt;
                                &lt;div class="metric"&gt;Total Media Accesses: %d&lt;/div&gt;
                                &lt;div class="metric"&gt;Total Events: %d&lt;/div&gt;
                        &lt;/div&gt;`,
                        report.User.Username, displayNameHTML, report.User.Email,
                        report.TotalMediaAccesses, report.TotalEvents)</span>

        case "system_overview":<span class="cov0" title="0">
                report := data.(*models.SystemOverviewReport)
                content = fmt.Sprintf(`
                        &lt;div class="section"&gt;
                                &lt;h2&gt;System Statistics&lt;/h2&gt;
                                &lt;div class="metric"&gt;Total Users: %d&lt;/div&gt;
                                &lt;div class="metric"&gt;Active Users: %d&lt;/div&gt;
                                &lt;div class="metric"&gt;Total Media Accesses: %d&lt;/div&gt;
                                &lt;div class="metric"&gt;Total Events: %d&lt;/div&gt;
                        &lt;/div&gt;`,
                        report.TotalUsers, report.ActiveUsers, report.TotalMediaAccesses, report.TotalEvents)</span>

        default:<span class="cov0" title="0">
                jsonData, _ := json.MarshalIndent(data, "", "  ")
                content = fmt.Sprintf("&lt;pre&gt;%s&lt;/pre&gt;", string(jsonData))</span>
        }

        <span class="cov0" title="0">templateData := struct {
                Title       string
                GeneratedAt string
                Period      string
                Content     template.HTML
        }{
                Title:       fmt.Sprintf("%s Report", reportType),
                GeneratedAt: time.Now().Format("2006-01-02 15:04:05"),
                Content:     template.HTML(content),
        }

        var buffer bytes.Buffer
        err = tmpl.Execute(&amp;buffer, templateData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute HTML template: %w", err)
        }</span>

        <span class="cov0" title="0">return buffer.Bytes(), nil</span>
}

func (s *ReportingService) formatAsPDF(data interface{}, reportType string) ([]byte, error) <span class="cov0" title="0">{
        // Create new PDF creator
        c := creator.New()
        page := model.NewPdfPage()
        if err := c.AddPage(page); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add page: %w", err)
        }</span>

        // Load standard fonts
        <span class="cov0" title="0">arialBold, err := model.NewStandard14Font(model.HelveticaBoldName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load Arial Bold font: %w", err)
        }</span>
        <span class="cov0" title="0">arialItalic, err := model.NewStandard14Font(model.HelveticaObliqueName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load Arial Italic font: %w", err)
        }</span>
        <span class="cov0" title="0">courier, err := model.NewStandard14Font(model.CourierName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load Courier font: %w", err)
        }</span>

        // Helper to create paragraph
        <span class="cov0" title="0">createParagraph := func(text string, font *model.PdfFont, fontSize float64, x, y float64) error </span><span class="cov0" title="0">{
                para := &amp;creator.Paragraph{}
                para.SetText(text)
                para.SetFont(font)
                para.SetFontSize(fontSize)
                para.SetColor(creator.ColorBlack)
                para.SetPos(x, y)
                return c.Draw(para)
        }</span>

        // Set title
        <span class="cov0" title="0">if err := createParagraph(
                fmt.Sprintf("%s Report", strings.Replace(reportType, "_", " ", -1)),
                arialBold, 16, 50, 50,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw title: %w", err)
        }</span>

        // Add generation timestamp
        <span class="cov0" title="0">if err := createParagraph(
                fmt.Sprintf("Generated: %s", time.Now().Format("2006-01-02 15:04:05")),
                arialItalic, 10, 50, 70,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw timestamp: %w", err)
        }</span>

        // Format content based on report type
        <span class="cov0" title="0">switch reportType </span>{
        case "user_analytics":<span class="cov0" title="0">
                return s.formatUserAnalyticsPDF(c, data, arialBold, arialItalic, courier)</span>
        case "system_overview":<span class="cov0" title="0">
                return s.formatSystemOverviewPDF(c, data, arialBold, arialItalic, courier)</span>
        case "media_analytics":<span class="cov0" title="0">
                return s.formatMediaAnalyticsPDF(c, data, arialBold, arialItalic, courier)</span>
        case "user_activity":<span class="cov0" title="0">
                return s.formatUserActivityPDF(c, data, arialBold, arialItalic, courier)</span>
        case "security_audit":<span class="cov0" title="0">
                return s.formatSecurityAuditPDF(c, data, arialBold, arialItalic, courier)</span>
        case "performance_metrics":<span class="cov0" title="0">
                return s.formatPerformanceMetricsPDF(c, data, arialBold, arialItalic, courier)</span>
        default:<span class="cov0" title="0">
                // Fallback to JSON representation
                jsonData, err := json.MarshalIndent(data, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal data for PDF: %w", err)
                }</span>

                // Split JSON into lines and add to PDF
                <span class="cov0" title="0">lines := strings.Split(string(jsonData), "\n")
                y := 90.0
                for _, line := range lines </span><span class="cov0" title="0">{
                        // Truncate long lines to fit page
                        if len(line) &gt; 80 </span><span class="cov0" title="0">{
                                for i := 0; i &lt; len(line); i += 80 </span><span class="cov0" title="0">{
                                        end := i + 80
                                        if end &gt; len(line) </span><span class="cov0" title="0">{
                                                end = len(line)
                                        }</span>
                                        <span class="cov0" title="0">if err := createParagraph(line[i:end], courier, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("failed to draw JSON line: %w", err)
                                        }</span>
                                        <span class="cov0" title="0">y += 12</span>
                                }
                        } else<span class="cov0" title="0"> {
                                if err := createParagraph(line, courier, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to draw JSON line: %w", err)
                                }</span>
                                <span class="cov0" title="0">y += 12</span>
                        }
                }

                // Output PDF to bytes
                <span class="cov0" title="0">var buf bytes.Buffer
                if err := c.Write(&amp;buf); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate PDF: %w", err)
                }</span>
                <span class="cov0" title="0">return buf.Bytes(), nil</span>
        }
}

// Helper methods for specific report types
func (s *ReportingService) formatUserAnalyticsPDF(c *creator.Creator, data interface{}, arialBold, arialItalic, courier *model.PdfFont) ([]byte, error) <span class="cov0" title="0">{
        report := data.(*models.UserAnalyticsReport)

        // Helper to create paragraph
        createParagraph := func(text string, font *model.PdfFont, fontSize float64, x, y float64) error </span><span class="cov0" title="0">{
                para := &amp;creator.Paragraph{}
                para.SetText(text)
                para.SetFont(font)
                para.SetFontSize(fontSize)
                para.SetColor(creator.ColorBlack)
                para.SetPos(x, y)
                return c.Draw(para)
        }</span>

        <span class="cov0" title="0">y := 90.0

        // User Information heading
        if err := createParagraph("User Information", arialBold, 12, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw heading: %w", err)
        }</span>
        <span class="cov0" title="0">y += 15

        // User details
        if err := createParagraph(fmt.Sprintf("User ID: %d", report.User.ID), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw user id: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12
        if err := createParagraph(fmt.Sprintf("Username: %s", report.User.Username), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw username: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12
        if err := createParagraph(fmt.Sprintf("Email: %s", report.User.Email), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw email: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12
        if err := createParagraph(fmt.Sprintf("Period: %s to %s",
                report.StartDate.Format("2006-01-02"),
                report.EndDate.Format("2006-01-02")), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw period: %w", err)
        }</span>
        <span class="cov0" title="0">y += 20

        // Summary Statistics heading
        if err := createParagraph("Summary Statistics", arialBold, 12, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw summary heading: %w", err)
        }</span>
        <span class="cov0" title="0">y += 15

        // Statistics
        if err := createParagraph(fmt.Sprintf("Total Media Accesses: %d", report.TotalMediaAccesses), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw total media accesses: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12
        if err := createParagraph(fmt.Sprintf("Total Events: %d", report.TotalEvents), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw total events: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12
        if err := createParagraph(fmt.Sprintf("Access Logs: %d", len(report.MediaAccessLogs)), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw access logs: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12
        if err := createParagraph(fmt.Sprintf("User Events: %d", len(report.Events)), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw user events: %w", err)
        }</span>

        // Output PDF to bytes
        <span class="cov0" title="0">var buf bytes.Buffer
        if err := c.Write(&amp;buf); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate PDF: %w", err)
        }</span>
        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func (s *ReportingService) formatSystemOverviewPDF(c *creator.Creator, data interface{}, arialBold, arialItalic, courier *model.PdfFont) ([]byte, error) <span class="cov0" title="0">{
        report := data.(*models.SystemOverviewReport)

        // Helper to create paragraph
        createParagraph := func(text string, font *model.PdfFont, fontSize float64, x, y float64) error </span><span class="cov0" title="0">{
                para := &amp;creator.Paragraph{}
                para.SetText(text)
                para.SetFont(font)
                para.SetFontSize(fontSize)
                para.SetColor(creator.ColorBlack)
                para.SetPos(x, y)
                return c.Draw(para)
        }</span>

        <span class="cov0" title="0">y := 90.0

        // System Statistics heading
        if err := createParagraph("System Statistics", arialBold, 12, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw heading: %w", err)
        }</span>
        <span class="cov0" title="0">y += 15

        // Statistics
        if err := createParagraph(fmt.Sprintf("Total Users: %d", report.TotalUsers), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw total users: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12
        if err := createParagraph(fmt.Sprintf("Active Users: %d", report.ActiveUsers), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw active users: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12
        if err := createParagraph(fmt.Sprintf("Total Media Accesses: %d", report.TotalMediaAccesses), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw total media accesses: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12
        if err := createParagraph(fmt.Sprintf("Total Events: %d", report.TotalEvents), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw total events: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12
        if err := createParagraph(fmt.Sprintf("Report Period: %s to %s",
                report.StartDate.Format("2006-01-02"),
                report.EndDate.Format("2006-01-02")), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw report period: %w", err)
        }</span>

        // Output PDF to bytes
        <span class="cov0" title="0">var buf bytes.Buffer
        if err := c.Write(&amp;buf); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate PDF: %w", err)
        }</span>
        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func (s *ReportingService) formatMediaAnalyticsPDF(c *creator.Creator, data interface{}, arialBold, arialItalic, courier *model.PdfFont) ([]byte, error) <span class="cov0" title="0">{
        // Helper to create paragraph
        createParagraph := func(text string, font *model.PdfFont, fontSize float64, x, y float64) error </span><span class="cov0" title="0">{
                para := &amp;creator.Paragraph{}
                para.SetText(text)
                para.SetFont(font)
                para.SetFontSize(fontSize)
                para.SetColor(creator.ColorBlack)
                para.SetPos(x, y)
                return c.Draw(para)
        }</span>

        <span class="cov0" title="0">y := 90.0

        // Media Analytics heading
        if err := createParagraph("Media Analytics", arialBold, 12, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw heading: %w", err)
        }</span>
        <span class="cov0" title="0">y += 15

        // Description
        if err := createParagraph("Media statistics and analytics data", arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw description: %w", err)
        }</span>
        <span class="cov0" title="0">y += 15

        // Add JSON data for now (can be enhanced later)
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal media analytics data: %w", err)
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(jsonData), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if len(line) &gt; 100 </span><span class="cov0" title="0">{
                        line = line[:100] + "..."
                }</span>
                <span class="cov0" title="0">if err := createParagraph(line, courier, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to draw JSON line: %w", err)
                }</span>
                <span class="cov0" title="0">y += 12</span>
        }

        // Output PDF to bytes
        <span class="cov0" title="0">var buf bytes.Buffer
        if err := c.Write(&amp;buf); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate PDF: %w", err)
        }</span>
        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func (s *ReportingService) formatUserActivityPDF(c *creator.Creator, data interface{}, arialBold, arialItalic, courier *model.PdfFont) ([]byte, error) <span class="cov0" title="0">{
        // Helper to create paragraph
        createParagraph := func(text string, font *model.PdfFont, fontSize float64, x, y float64) error </span><span class="cov0" title="0">{
                para := &amp;creator.Paragraph{}
                para.SetText(text)
                para.SetFont(font)
                para.SetFontSize(fontSize)
                para.SetColor(creator.ColorBlack)
                para.SetPos(x, y)
                return c.Draw(para)
        }</span>

        <span class="cov0" title="0">y := 90.0

        // User Activity Report heading
        if err := createParagraph("User Activity Report", arialBold, 12, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw heading: %w", err)
        }</span>
        <span class="cov0" title="0">y += 15

        // Description
        if err := createParagraph("User activity logs and events", arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw description: %w", err)
        }</span>
        <span class="cov0" title="0">y += 15

        // Add summary information
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal user activity data: %w", err)
        }</span>

        <span class="cov0" title="0">text := string(jsonData)
        if len(text) &gt; 3000 </span><span class="cov0" title="0">{ // Limit text to reasonable size
                text = text[:3000] + "...[truncated]"
        }</span>

        <span class="cov0" title="0">lines := strings.Split(text, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if len(line) &gt; 100 </span><span class="cov0" title="0">{
                        line = line[:100] + "..."
                }</span>
                <span class="cov0" title="0">if err := createParagraph(line, courier, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to draw JSON line: %w", err)
                }</span>
                <span class="cov0" title="0">y += 12</span>
        }

        // Output PDF to bytes
        <span class="cov0" title="0">var buf bytes.Buffer
        if err := c.Write(&amp;buf); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate PDF: %w", err)
        }</span>
        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func (s *ReportingService) formatSecurityAuditPDF(c *creator.Creator, data interface{}, arialBold, arialItalic, courier *model.PdfFont) ([]byte, error) <span class="cov0" title="0">{
        // Helper to create paragraph
        createParagraph := func(text string, font *model.PdfFont, fontSize float64, x, y float64) error </span><span class="cov0" title="0">{
                para := &amp;creator.Paragraph{}
                para.SetText(text)
                para.SetFont(font)
                para.SetFontSize(fontSize)
                para.SetColor(creator.ColorBlack)
                para.SetPos(x, y)
                return c.Draw(para)
        }</span>

        <span class="cov0" title="0">y := 90.0

        // Security Audit Report heading
        if err := createParagraph("Security Audit Report", arialBold, 12, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw heading: %w", err)
        }</span>
        <span class="cov0" title="0">y += 15

        // Subheading
        if err := createParagraph("Security Events and Audit Information", arialBold, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw subheading: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12

        // Description
        if err := createParagraph("This report contains security audit information", arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw description: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12

        // Generation timestamp
        if err := createParagraph(fmt.Sprintf("Generated on: %s", time.Now().Format("2006-01-02 15:04:05")), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw timestamp: %w", err)
        }</span>
        <span class="cov0" title="0">y += 15

        // Add audit data as formatted JSON
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal security audit data: %w", err)
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(jsonData), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if len(line) &gt; 95 </span><span class="cov0" title="0">{
                        line = line[:95] + "..."
                }</span>
                <span class="cov0" title="0">if err := createParagraph(line, courier, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to draw JSON line: %w", err)
                }</span>
                <span class="cov0" title="0">y += 12</span>
        }

        // Output PDF to bytes
        <span class="cov0" title="0">var buf bytes.Buffer
        if err := c.Write(&amp;buf); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate PDF: %w", err)
        }</span>
        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func (s *ReportingService) formatPerformanceMetricsPDF(c *creator.Creator, data interface{}, arialBold, arialItalic, courier *model.PdfFont) ([]byte, error) <span class="cov0" title="0">{
        // Helper to create paragraph
        createParagraph := func(text string, font *model.PdfFont, fontSize float64, x, y float64) error </span><span class="cov0" title="0">{
                para := &amp;creator.Paragraph{}
                para.SetText(text)
                para.SetFont(font)
                para.SetFontSize(fontSize)
                para.SetColor(creator.ColorBlack)
                para.SetPos(x, y)
                return c.Draw(para)
        }</span>

        <span class="cov0" title="0">y := 90.0

        // Performance Metrics Report heading
        if err := createParagraph("Performance Metrics Report", arialBold, 12, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw heading: %w", err)
        }</span>
        <span class="cov0" title="0">y += 15

        // Subheading
        if err := createParagraph("System Performance Metrics", arialBold, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw subheading: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12

        // Description
        if err := createParagraph("This report contains performance metrics for the system", arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw description: %w", err)
        }</span>
        <span class="cov0" title="0">y += 12

        // Generation timestamp
        if err := createParagraph(fmt.Sprintf("Generated on: %s", time.Now().Format("2006-01-02 15:04:05")), arialItalic, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to draw timestamp: %w", err)
        }</span>
        <span class="cov0" title="0">y += 15

        // Add performance data as formatted JSON
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal performance metrics data: %w", err)
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(jsonData), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if len(line) &gt; 95 </span><span class="cov0" title="0">{
                        line = line[:95] + "..."
                }</span>
                <span class="cov0" title="0">if err := createParagraph(line, courier, 10, 50, y); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to draw JSON line: %w", err)
                }</span>
                <span class="cov0" title="0">y += 12</span>
        }

        // Output PDF to bytes
        <span class="cov0" title="0">var buf bytes.Buffer
        if err := c.Write(&amp;buf); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate PDF: %w", err)
        }</span>
        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func (s *ReportingService) extractDateRange(params map[string]interface{}) (time.Time, time.Time, error) <span class="cov8" title="1">{
        startDateStr, ok := params["start_date"].(string)
        if !ok </span><span class="cov8" title="1">{
                return time.Time{}, time.Time{}, fmt.Errorf("start_date parameter required")
        }</span>

        <span class="cov8" title="1">endDateStr, ok := params["end_date"].(string)
        if !ok </span><span class="cov8" title="1">{
                return time.Time{}, time.Time{}, fmt.Errorf("end_date parameter required")
        }</span>

        <span class="cov8" title="1">startDate, err := time.Parse("2006-01-02", startDateStr)
        if err != nil </span><span class="cov8" title="1">{
                return time.Time{}, time.Time{}, fmt.Errorf("invalid start_date format")
        }</span>

        <span class="cov8" title="1">endDate, err := time.Parse("2006-01-02", endDateStr)
        if err != nil </span><span class="cov8" title="1">{
                return time.Time{}, time.Time{}, fmt.Errorf("invalid end_date format")
        }</span>

        <span class="cov8" title="1">return startDate, endDate, nil</span>
}

// Helper methods for analytics calculations
func (s *ReportingService) analyzeUserAccessPatterns(logs []models.MediaAccessLog) map[string]interface{} <span class="cov8" title="1">{
        patterns := make(map[string]interface{})

        hourlyAccess := make(map[int]int)
        dailyAccess := make(map[string]int)

        for _, log := range logs </span><span class="cov8" title="1">{
                hour := log.AccessTime.Hour()
                hourlyAccess[hour]++

                day := log.AccessTime.Weekday().String()
                dailyAccess[day]++
        }</span>

        <span class="cov8" title="1">patterns["hourly"] = hourlyAccess
        patterns["daily"] = dailyAccess

        return patterns</span>
}

func (s *ReportingService) analyzeUserDeviceUsage(logs []models.MediaAccessLog) map[string]int <span class="cov8" title="1">{
        deviceUsage := make(map[string]int)

        for _, log := range logs </span><span class="cov8" title="1">{
                if log.DeviceInfo != nil </span><span class="cov8" title="1">{
                        deviceModel := ""
                        if log.DeviceInfo.DeviceModel != nil </span><span class="cov8" title="1">{
                                deviceModel = *log.DeviceInfo.DeviceModel
                        }</span>
                        <span class="cov8" title="1">platform := ""
                        if log.DeviceInfo.Platform != nil </span><span class="cov8" title="1">{
                                platform = *log.DeviceInfo.Platform
                        }</span>
                        <span class="cov8" title="1">device := fmt.Sprintf("%s %s", platform, deviceModel)
                        deviceUsage[device]++</span>
                }
        }

        <span class="cov8" title="1">return deviceUsage</span>
}

func (s *ReportingService) analyzeUserLocations(logs []models.MediaAccessLog) map[string]int <span class="cov8" title="1">{
        locations := make(map[string]int)

        for _, log := range logs </span><span class="cov8" title="1">{
                if log.Location != nil </span><span class="cov8" title="1">{
                        location := fmt.Sprintf("%.2f,%.2f", log.Location.Latitude, log.Location.Longitude)
                        locations[location]++
                }</span>
        }

        <span class="cov8" title="1">return locations</span>
}

func (s *ReportingService) analyzeUserTimePatterns(logs []models.MediaAccessLog) map[string]interface{} <span class="cov8" title="1">{
        return s.analyzeUserAccessPatterns(logs) // Same as access patterns
}</span>

func (s *ReportingService) analyzeUserPopularContent(logs []models.MediaAccessLog) []models.MediaAccessCount <span class="cov8" title="1">{
        mediaCount := make(map[int]int)

        for _, log := range logs </span><span class="cov8" title="1">{
                mediaCount[log.MediaID]++
        }</span>

        <span class="cov8" title="1">var results []models.MediaAccessCount
        for mediaID, count := range mediaCount </span><span class="cov8" title="1">{
                results = append(results, models.MediaAccessCount{
                        MediaID:     mediaID,
                        AccessCount: count,
                })
        }</span>

        <span class="cov8" title="1">return results</span>
}

func (s *ReportingService) filterLogsByDateRange(logs []models.MediaAccessLog, startDate, endDate time.Time) []models.MediaAccessLog <span class="cov8" title="1">{
        var filtered []models.MediaAccessLog

        for _, log := range logs </span><span class="cov8" title="1">{
                if log.AccessTime.After(startDate) &amp;&amp; log.AccessTime.Before(endDate) </span><span class="cov8" title="1">{
                        filtered = append(filtered, log)
                }</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

func (s *ReportingService) countUniqueUsers(logs []models.MediaAccessLog) int <span class="cov8" title="1">{
        users := make(map[int]bool)

        for _, log := range logs </span><span class="cov8" title="1">{
                users[log.UserID] = true
        }</span>

        <span class="cov8" title="1">return len(users)</span>
}

func (s *ReportingService) calculateSystemHealth(totalUsers, activeUsers, mediaAccesses int) models.SystemHealth <span class="cov8" title="1">{
        var healthScore float64

        if totalUsers &gt; 0 </span><span class="cov8" title="1">{
                activeRatio := float64(activeUsers) / float64(totalUsers)
                healthScore += activeRatio * 50
        }</span>

        <span class="cov8" title="1">if mediaAccesses &gt; 0 </span><span class="cov8" title="1">{
                healthScore += 30
        }</span>

        <span class="cov8" title="1">if activeUsers &gt; 10 </span><span class="cov8" title="1">{
                healthScore += 20
        }</span>

        <span class="cov8" title="1">var status string
        switch </span>{
        case healthScore &gt;= 80:<span class="cov8" title="1">
                status = "excellent"</span>
        case healthScore &gt;= 60:<span class="cov8" title="1">
                status = "good"</span>
        case healthScore &gt;= 40:<span class="cov0" title="0">
                status = "fair"</span>
        default:<span class="cov8" title="1">
                status = "poor"</span>
        }

        <span class="cov8" title="1">return models.SystemHealth{
                Score:  healthScore,
                Status: status,
        }</span>
}

func (s *ReportingService) calculateUsageStatistics(startDate, endDate time.Time) models.UsageStatistics <span class="cov8" title="1">{
        // Placeholder implementation
        return models.UsageStatistics{
                PeakHours:    []int{14, 15, 16, 20, 21},
                AverageDaily: 150,
                GrowthRate:   5.2,
        }
}</span>

func (s *ReportingService) calculatePerformanceMetrics(startDate, endDate time.Time) models.PerformanceMetrics <span class="cov8" title="1">{
        // Placeholder implementation
        return models.PerformanceMetrics{
                ResponseTime: 250.5,
                Throughput:   1200,
                ErrorRate:    0.02,
        }
}</span>

func (s *ReportingService) analyzeAccessPatterns(logs []models.MediaAccessLog) map[string]interface{} <span class="cov8" title="1">{
        return s.analyzeUserAccessPatterns(logs)
}</span>

func (s *ReportingService) analyzeUserEngagement(logs []models.MediaAccessLog) models.UserEngagement <span class="cov8" title="1">{
        return models.UserEngagement{
                AverageSessionTime: 15.5,
                ReturnRate:         85.2,
                InteractionDepth:   3.4,
        }
}</span>

func (s *ReportingService) analyzeGeographicDistribution(logs []models.MediaAccessLog) map[string]int <span class="cov8" title="1">{
        return s.analyzeUserLocations(logs)
}</span>

func (s *ReportingService) analyzeDeviceDistribution(logs []models.MediaAccessLog) map[string]int <span class="cov8" title="1">{
        return s.analyzeUserDeviceUsage(logs)
}</span>

func (s *ReportingService) analyzeTimeDistribution(logs []models.MediaAccessLog) map[string]int <span class="cov8" title="1">{
        timeDistribution := make(map[string]int)

        for _, log := range logs </span><span class="cov8" title="1">{
                hour := log.AccessTime.Hour()
                var timeSlot string

                switch </span>{
                case hour &gt;= 6 &amp;&amp; hour &lt; 12:<span class="cov8" title="1">
                        timeSlot = "morning"</span>
                case hour &gt;= 12 &amp;&amp; hour &lt; 18:<span class="cov8" title="1">
                        timeSlot = "afternoon"</span>
                case hour &gt;= 18 &amp;&amp; hour &lt; 22:<span class="cov8" title="1">
                        timeSlot = "evening"</span>
                default:<span class="cov0" title="0">
                        timeSlot = "night"</span>
                }

                <span class="cov8" title="1">timeDistribution[timeSlot]++</span>
        }

        <span class="cov8" title="1">return timeDistribution</span>
}

func (s *ReportingService) getLastActivityTime(logs []models.MediaAccessLog) time.Time <span class="cov8" title="1">{
        if len(logs) == 0 </span><span class="cov8" title="1">{
                return time.Time{}
        }</span>

        <span class="cov8" title="1">latest := logs[0].AccessTime
        for _, log := range logs </span><span class="cov8" title="1">{
                if log.AccessTime.After(latest) </span><span class="cov8" title="1">{
                        latest = log.AccessTime
                }</span>
        }

        <span class="cov8" title="1">return latest</span>
}

func (s *ReportingService) getMostActiveHour(logs []models.MediaAccessLog) int <span class="cov8" title="1">{
        hourCounts := make(map[int]int)

        for _, log := range logs </span><span class="cov8" title="1">{
                hour := log.AccessTime.Hour()
                hourCounts[hour]++
        }</span>

        <span class="cov8" title="1">maxCount := 0
        mostActiveHour := 0

        for hour, count := range hourCounts </span><span class="cov8" title="1">{
                if count &gt; maxCount </span><span class="cov8" title="1">{
                        maxCount = count
                        mostActiveHour = hour
                }</span>
        }

        <span class="cov8" title="1">return mostActiveHour</span>
}

func (s *ReportingService) getPreferredDevices(logs []models.MediaAccessLog) []string <span class="cov8" title="1">{
        deviceCounts := s.analyzeUserDeviceUsage(logs)

        var devices []string
        for device := range deviceCounts </span><span class="cov8" title="1">{
                devices = append(devices, device)
        }</span>

        <span class="cov8" title="1">return devices</span>
}

func (s *ReportingService) getAccessedLocations(logs []models.MediaAccessLog) []string <span class="cov8" title="1">{
        locationCounts := s.analyzeUserLocations(logs)

        var locations []string
        for location := range locationCounts </span><span class="cov8" title="1">{
                locations = append(locations, location)
        }</span>

        <span class="cov8" title="1">return locations</span>
}

func (s *ReportingService) generateActivitySummary(activities []models.UserActivitySummary) models.ActivitySummary <span class="cov8" title="1">{
        if len(activities) == 0 </span><span class="cov8" title="1">{
                return models.ActivitySummary{}
        }</span>

        <span class="cov8" title="1">totalAccesses := 0
        for _, activity := range activities </span><span class="cov8" title="1">{
                totalAccesses += activity.TotalAccesses
        }</span>

        <span class="cov8" title="1">avgAccesses := float64(totalAccesses) / float64(len(activities))

        return models.ActivitySummary{
                TotalUsers:       len(activities),
                TotalAccesses:    totalAccesses,
                AverageAccesses:  avgAccesses,
                MostActiveUsers:  len(activities), // Simplified
                LeastActiveUsers: 0,               // Simplified
        }</span>
}

func (s *ReportingService) calculateSecurityMetrics(startDate, endDate time.Time) models.SecurityMetrics <span class="cov8" title="1">{
        // Placeholder implementation
        return models.SecurityMetrics{
                ThreatLevel:        "low",
                VulnerabilityCount: 0,
                SecurityScore:      95.5,
        }
}</span>

func (s *ReportingService) calculateAverageSessionDuration(sessions []models.SessionData) time.Duration <span class="cov8" title="1">{
        if len(sessions) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">var total time.Duration
        for _, session := range sessions </span><span class="cov8" title="1">{
                total += session.Duration
        }</span>

        <span class="cov8" title="1">return total / time.Duration(len(sessions))</span>
}

func (s *ReportingService) calculateResponseTimes(startDate, endDate time.Time) models.ResponseTimes <span class="cov8" title="1">{
        // Placeholder implementation
        return models.ResponseTimes{
                Average: 250.5,
                Min:     50.2,
                Max:     1200.8,
                P95:     480.3,
                P99:     850.7,
        }
}</span>

func (s *ReportingService) calculateSystemLoad(startDate, endDate time.Time) models.SystemLoad <span class="cov8" title="1">{
        // Placeholder implementation
        return models.SystemLoad{
                CPU:     45.2,
                Memory:  68.5,
                Disk:    32.1,
                Network: 15.8,
        }
}</span>

func (s *ReportingService) calculateErrorRates(startDate, endDate time.Time) models.ErrorRates <span class="cov8" title="1">{
        // Placeholder implementation
        return models.ErrorRates{
                HTTP4xx:  2.1,
                HTTP5xx:  0.3,
                Timeouts: 0.1,
                Total:    2.5,
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"

        "cloud.google.com/go/storage"
        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "google.golang.org/api/option"
)

type SyncService struct {
        syncRepo      *repository.SyncRepository
        userRepo      *repository.UserRepository
        authService   *AuthService
        webdavClients map[int]*WebDAVClient
}

func NewSyncService(syncRepo *repository.SyncRepository, userRepo *repository.UserRepository, authService *AuthService) *SyncService <span class="cov8" title="1">{
        return &amp;SyncService{
                syncRepo:      syncRepo,
                userRepo:      userRepo,
                authService:   authService,
                webdavClients: make(map[int]*WebDAVClient),
        }
}</span>

func (s *SyncService) CreateSyncEndpoint(userID int, endpoint *models.SyncEndpoint) (*models.SyncEndpoint, error) <span class="cov0" title="0">{
        endpoint.UserID = userID
        endpoint.CreatedAt = time.Now()
        endpoint.UpdatedAt = time.Now()
        endpoint.Status = models.SyncStatusActive

        if err := s.validateSyncEndpoint(endpoint); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid sync endpoint: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.testConnection(endpoint); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connection test failed: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := s.syncRepo.CreateEndpoint(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sync endpoint: %w", err)
        }</span>

        <span class="cov0" title="0">endpoint.ID = id
        return endpoint, nil</span>
}

func (s *SyncService) GetUserEndpoints(userID int) ([]models.SyncEndpoint, error) <span class="cov0" title="0">{
        return s.syncRepo.GetUserEndpoints(userID)
}</span>

func (s *SyncService) GetEndpoint(endpointID int, userID int) (*models.SyncEndpoint, error) <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to view this endpoint")
                }</span>
        }

        <span class="cov0" title="0">return endpoint, nil</span>
}

func (s *SyncService) UpdateEndpoint(endpointID int, userID int, updates *models.UpdateSyncEndpointRequest) (*models.SyncEndpoint, error) <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionEditShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to update this endpoint")
                }</span>
        }

        <span class="cov0" title="0">if updates.Name != "" </span><span class="cov0" title="0">{
                endpoint.Name = updates.Name
        }</span>

        <span class="cov0" title="0">if updates.URL != "" </span><span class="cov0" title="0">{
                endpoint.URL = updates.URL
        }</span>

        <span class="cov0" title="0">if updates.Username != "" </span><span class="cov0" title="0">{
                endpoint.Username = updates.Username
        }</span>

        <span class="cov0" title="0">if updates.Password != "" </span><span class="cov0" title="0">{
                endpoint.Password = updates.Password
        }</span>

        <span class="cov0" title="0">if updates.SyncDirection != "" </span><span class="cov0" title="0">{
                endpoint.SyncDirection = updates.SyncDirection
        }</span>

        <span class="cov0" title="0">if updates.LocalPath != "" </span><span class="cov0" title="0">{
                endpoint.LocalPath = updates.LocalPath
        }</span>

        <span class="cov0" title="0">if updates.RemotePath != "" </span><span class="cov0" title="0">{
                endpoint.RemotePath = updates.RemotePath
        }</span>

        <span class="cov0" title="0">if updates.SyncSettings != nil </span><span class="cov0" title="0">{
                endpoint.SyncSettings = updates.SyncSettings
        }</span>

        <span class="cov0" title="0">if updates.IsActive != nil </span><span class="cov0" title="0">{
                if *updates.IsActive </span><span class="cov0" title="0">{
                        endpoint.Status = models.SyncStatusActive
                }</span> else<span class="cov0" title="0"> {
                        endpoint.Status = models.SyncStatusInactive
                }</span>
        }

        <span class="cov0" title="0">endpoint.UpdatedAt = time.Now()

        if err := s.validateSyncEndpoint(endpoint); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid endpoint update: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.testConnection(endpoint); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connection test failed: %w", err)
        }</span>

        <span class="cov0" title="0">err = s.syncRepo.UpdateEndpoint(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update endpoint: %w", err)
        }</span>

        <span class="cov0" title="0">return endpoint, nil</span>
}

func (s *SyncService) DeleteEndpoint(endpointID int, userID int) error <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionDeleteShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return fmt.Errorf("unauthorized to delete this endpoint")
                }</span>
        }

        <span class="cov0" title="0">return s.syncRepo.DeleteEndpoint(endpointID)</span>
}

func (s *SyncService) StartSync(endpointID int, userID int) (*models.SyncSession, error) <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionEditShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to sync this endpoint")
                }</span>
        }

        <span class="cov0" title="0">if endpoint.Status != models.SyncStatusActive </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("endpoint is not active")
        }</span>

        <span class="cov0" title="0">session := &amp;models.SyncSession{
                EndpointID: endpointID,
                UserID:     userID,
                Status:     models.SyncSessionStatusRunning,
                StartedAt:  time.Now(),
                SyncType:   models.SyncTypeManual,
        }

        sessionID, err := s.syncRepo.CreateSession(session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sync session: %w", err)
        }</span>

        <span class="cov0" title="0">session.ID = sessionID

        go s.performSync(session, endpoint)

        return session, nil</span>
}

func (s *SyncService) performSync(session *models.SyncSession, endpoint *models.SyncEndpoint) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.handleSyncError(session, fmt.Errorf("sync panic: %v", r))
                }</span>
        }()

        <span class="cov0" title="0">var err error

        switch endpoint.Type </span>{
        case models.SyncTypeWebDAV:<span class="cov0" title="0">
                err = s.performWebDAVSync(session, endpoint)</span>
        case models.SyncTypeCloudStorage:<span class="cov0" title="0">
                err = s.performCloudSync(session, endpoint)</span>
        case models.SyncTypeLocal:<span class="cov0" title="0">
                err = s.performLocalSync(session, endpoint)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unsupported sync type: %s", endpoint.Type)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.handleSyncError(session, err)
                return
        }</span>

        <span class="cov0" title="0">s.handleSyncSuccess(session)</span>
}

func (s *SyncService) performWebDAVSync(session *models.SyncSession, endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        client, err := s.getWebDAVClient(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get WebDAV client: %w", err)
        }</span>

        <span class="cov0" title="0">switch endpoint.SyncDirection </span>{
        case models.SyncDirectionUpload:<span class="cov0" title="0">
                return s.uploadToWebDAV(session, endpoint, client)</span>
        case models.SyncDirectionDownload:<span class="cov0" title="0">
                return s.downloadFromWebDAV(session, endpoint, client)</span>
        case models.SyncDirectionBidirectional:<span class="cov0" title="0">
                if err := s.uploadToWebDAV(session, endpoint, client); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return s.downloadFromWebDAV(session, endpoint, client)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported sync direction: %s", endpoint.SyncDirection)</span>
        }
}

func (s *SyncService) uploadToWebDAV(session *models.SyncSession, endpoint *models.SyncEndpoint, client *WebDAVClient) error <span class="cov0" title="0">{
        localFiles, err := s.scanLocalFiles(endpoint.LocalPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan local files: %w", err)
        }</span>

        <span class="cov0" title="0">session.TotalFiles = len(localFiles)
        s.syncRepo.UpdateSession(session)

        for _, localFile := range localFiles </span><span class="cov0" title="0">{
                relativePath, err := filepath.Rel(endpoint.LocalPath, localFile)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">remotePath := filepath.Join(endpoint.RemotePath, relativePath)
                remotePath = filepath.ToSlash(remotePath)

                if s.shouldSkipFile(localFile, endpoint) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">remoteModTime, err := client.GetModTime(remotePath)
                if err == nil </span><span class="cov0" title="0">{
                        localInfo, err := os.Stat(localFile)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if !localInfo.ModTime().After(remoteModTime) </span><span class="cov0" title="0">{
                                session.SkippedFiles++
                                continue</span>
                        }
                }

                <span class="cov0" title="0">err = client.UploadFile(localFile, remotePath)
                if err != nil </span><span class="cov0" title="0">{
                        session.FailedFiles++
                        s.logSyncError(session, fmt.Sprintf("Failed to upload %s: %v", localFile, err))
                }</span> else<span class="cov0" title="0"> {
                        session.SyncedFiles++
                }</span>

                <span class="cov0" title="0">s.syncRepo.UpdateSession(session)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) downloadFromWebDAV(session *models.SyncSession, endpoint *models.SyncEndpoint, client *WebDAVClient) error <span class="cov0" title="0">{
        remoteFiles, err := client.ListFiles(endpoint.RemotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list remote files: %w", err)
        }</span>

        <span class="cov0" title="0">session.TotalFiles += len(remoteFiles)
        s.syncRepo.UpdateSession(session)

        for _, remoteFile := range remoteFiles </span><span class="cov0" title="0">{
                relativePath, err := filepath.Rel(endpoint.RemotePath, remoteFile.Path)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">localPath := filepath.Join(endpoint.LocalPath, relativePath)

                if s.shouldSkipRemoteFile(remoteFile, endpoint) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">localInfo, err := os.Stat(localPath)
                if err == nil </span><span class="cov0" title="0">{
                        if !remoteFile.ModTime.After(localInfo.ModTime()) </span><span class="cov0" title="0">{
                                session.SkippedFiles++
                                continue</span>
                        }
                }

                <span class="cov0" title="0">err = os.MkdirAll(filepath.Dir(localPath), 0755)
                if err != nil </span><span class="cov0" title="0">{
                        session.FailedFiles++
                        continue</span>
                }

                <span class="cov0" title="0">err = client.DownloadFile(remoteFile.Path, localPath)
                if err != nil </span><span class="cov0" title="0">{
                        session.FailedFiles++
                        s.logSyncError(session, fmt.Sprintf("Failed to download %s: %v", remoteFile.Path, err))
                }</span> else<span class="cov0" title="0"> {
                        session.SyncedFiles++
                }</span>

                <span class="cov0" title="0">s.syncRepo.UpdateSession(session)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) performCloudSync(session *models.SyncSession, endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        ctx := context.Background()

        switch endpoint.Type </span>{
        case "s3":<span class="cov0" title="0">
                return s.performS3Sync(ctx, session, endpoint)</span>
        case "google_drive":<span class="cov0" title="0">
                return s.performGoogleCloudStorageSync(ctx, session, endpoint)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported cloud storage type: %s", endpoint.Type)</span>
        }
}

// performS3Sync syncs files with Amazon S3
func (s *SyncService) performS3Sync(ctx context.Context, session *models.SyncSession, endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        // Parse configuration
        syncConfig := make(map[string]interface{})
        if endpoint.SyncSettings != nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(*endpoint.SyncSettings), &amp;syncConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse S3 config: %w", err)
                }</span>
        }

        // Extract S3 configuration
        <span class="cov0" title="0">bucket, ok := syncConfig["bucket"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("S3 bucket not specified")
        }</span>

        <span class="cov0" title="0">region, _ := syncConfig["region"].(string)
        if region == "" </span><span class="cov0" title="0">{
                region = "us-east-1"
        }</span>

        <span class="cov0" title="0">accessKey, ok := syncConfig["access_key"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("S3 access key not specified")
        }</span>

        <span class="cov0" title="0">secretKey, ok := syncConfig["secret_key"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("S3 secret key not specified")
        }</span>

        // Create AWS configuration
        <span class="cov0" title="0">awsCfg, err := config.LoadDefaultConfig(ctx,
                config.WithRegion(region),
                config.WithCredentialsProvider(aws.CredentialsProviderFunc(func(ctx context.Context) (aws.Credentials, error) </span><span class="cov0" title="0">{
                        return aws.Credentials{
                                AccessKeyID:     accessKey,
                                SecretAccessKey: secretKey,
                        }, nil
                }</span>)),
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create AWS config: %w", err)
        }</span>

        // Create S3 client
        <span class="cov0" title="0">client := s3.NewFromConfig(awsCfg)

        // Get source directory from sync settings
        sourceDir, ok := syncConfig["source_directory"].(string)
        if !ok </span><span class="cov0" title="0">{
                // Fallback to local path
                sourceDir = endpoint.LocalPath
                if sourceDir == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("source directory not specified")
                }</span>
        }

        // Walk through source directory and upload files
        <span class="cov0" title="0">err = filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip directories
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Calculate relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(sourceDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to calculate relative path: %w", err)
                }</span>

                // Convert to forward slashes for S3
                <span class="cov0" title="0">s3Key := filepath.ToSlash(relPath)

                // Open file
                file, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open file %s: %w", path, err)
                }</span>
                <span class="cov0" title="0">defer file.Close()

                // Upload to S3
                _, err = client.PutObject(ctx, &amp;s3.PutObjectInput{
                        Bucket: aws.String(bucket),
                        Key:    aws.String(s3Key),
                        Body:   file,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to upload %s to S3: %w", s3Key, err)
                }</span>

                // Update sync session progress
                <span class="cov0" title="0">s.updateSyncProgress(session, fmt.Sprintf("Uploaded: %s", s3Key))

                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("S3 sync failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// performGoogleCloudStorageSync syncs files with Google Cloud Storage
func (s *SyncService) performGoogleCloudStorageSync(ctx context.Context, session *models.SyncSession, endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        // Parse configuration
        syncConfig := make(map[string]interface{})
        if endpoint.SyncSettings != nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(*endpoint.SyncSettings), &amp;syncConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse Google Cloud Storage config: %w", err)
                }</span>
        }

        // Extract GCS configuration
        <span class="cov0" title="0">bucket, ok := syncConfig["bucket"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("GCS bucket not specified")
        }</span>

        <span class="cov0" title="0">credentialsFile, _ := syncConfig["credentials_file"].(string)

        // Create GCS client
        var client *storage.Client
        var err error

        if credentialsFile != "" </span><span class="cov0" title="0">{
                // Use credentials file for GCS authentication
                // Note: option.WithCredentialsFile is deprecated; migrate to cloud.google.com/go/auth
                // when upgrading Google Cloud dependencies
                client, err = storage.NewClient(ctx, option.WithCredentialsFile(credentialsFile))
        }</span> else<span class="cov0" title="0"> {
                // Use default credentials
                client, err = storage.NewClient(ctx)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create GCS client: %w", err)
        }</span>
        <span class="cov0" title="0">defer client.Close()

        // Get source directory from sync settings
        sourceDir, ok := syncConfig["source_directory"].(string)
        if !ok </span><span class="cov0" title="0">{
                // Fallback to local path
                sourceDir = endpoint.LocalPath
                if sourceDir == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("source directory not specified")
                }</span>
        }

        // Walk through source directory and upload files
        <span class="cov0" title="0">err = filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip directories
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Calculate relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(sourceDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to calculate relative path: %w", err)
                }</span>

                // Convert to forward slashes for GCS
                <span class="cov0" title="0">gcsObject := filepath.ToSlash(relPath)

                // Open file
                file, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open file %s: %w", path, err)
                }</span>
                <span class="cov0" title="0">defer file.Close()

                // Create GCS object writer
                wc := client.Bucket(bucket).Object(gcsObject).NewWriter(ctx)
                defer wc.Close()

                // Copy file to GCS
                _, err = io.Copy(wc, file)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to upload %s to GCS: %w", gcsObject, err)
                }</span>

                // Close writer to complete upload
                <span class="cov0" title="0">if err := wc.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to complete upload of %s to GCS: %w", gcsObject, err)
                }</span>

                // Update sync session progress
                <span class="cov0" title="0">s.updateSyncProgress(session, fmt.Sprintf("Uploaded: %s", gcsObject))

                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("google cloud storage sync failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) performLocalSync(session *models.SyncSession, endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        // Parse configuration
        syncConfig := make(map[string]interface{})
        if endpoint.SyncSettings != nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(*endpoint.SyncSettings), &amp;syncConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse local sync config: %w", err)
                }</span>
        }

        // Get source directory from sync settings or endpoint local path
        <span class="cov0" title="0">sourceDir, ok := syncConfig["source_directory"].(string)
        if !ok </span><span class="cov0" title="0">{
                sourceDir = endpoint.LocalPath
                if sourceDir == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("source directory not specified")
                }</span>
        }

        // Get destination directory
        <span class="cov0" title="0">destDir, ok := syncConfig["destination_directory"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("destination directory not specified")
        }</span>

        // Get sync mode (optional)
        <span class="cov0" title="0">syncMode := "mirror" // default
        if mode, ok := syncConfig["sync_mode"].(string); ok </span><span class="cov0" title="0">{
                syncMode = mode
        }</span>

        // Verify source directory exists
        <span class="cov0" title="0">sourceInfo, err := os.Stat(sourceDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("source directory does not exist: %w", err)
        }</span>
        <span class="cov0" title="0">if !sourceInfo.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("source path is not a directory")
        }</span>

        // Create destination directory if it doesn't exist
        <span class="cov0" title="0">if err := os.MkdirAll(destDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Perform sync based on mode
        <span class="cov0" title="0">switch syncMode </span>{
        case "mirror":<span class="cov0" title="0">
                err = s.performMirrorSync(sourceDir, destDir, session)</span>
        case "incremental":<span class="cov0" title="0">
                err = s.performIncrementalSync(sourceDir, destDir, session)</span>
        case "bidirectional":<span class="cov0" title="0">
                err = s.performBidirectionalSync(sourceDir, destDir, session)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported sync mode: %s", syncMode)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("local sync failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// performMirrorSync creates exact copy of source in destination
func (s *SyncService) performMirrorSync(sourceDir, destDir string, session *models.SyncSession) error <span class="cov0" title="0">{
        // Walk through source directory
        err := filepath.Walk(sourceDir, func(sourcePath string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Calculate relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(sourceDir, sourcePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to calculate relative path: %w", err)
                }</span>

                // Build destination path
                <span class="cov0" title="0">destPath := filepath.Join(destDir, relPath)

                // Handle directories
                if info.IsDir() </span><span class="cov0" title="0">{
                        // Create destination directory
                        if err := os.MkdirAll(destPath, info.Mode()); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", destPath, err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                // Handle files
                // Check if file needs to be copied
                <span class="cov0" title="0">destInfo, err := os.Stat(destPath)
                if err == nil </span><span class="cov0" title="0">{
                        // Compare modification times
                        if !info.ModTime().After(destInfo.ModTime()) </span><span class="cov0" title="0">{
                                // Source is not newer, skip
                                return nil
                        }</span>

                        // Compare file sizes
                        <span class="cov0" title="0">if info.Size() == destInfo.Size() &amp;&amp; info.ModTime().Equal(destInfo.ModTime()) </span><span class="cov0" title="0">{
                                // Files are identical, skip
                                return nil
                        }</span>
                }

                // Copy file
                <span class="cov0" title="0">if err := s.copyFile(sourcePath, destPath, info.Mode()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to copy file %s to %s: %w", sourcePath, destPath, err)
                }</span>

                // Update sync session progress
                <span class="cov0" title="0">s.updateSyncProgress(session, fmt.Sprintf("Synced: %s", relPath))

                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mirror sync failed: %w", err)
        }</span>

        // Remove files in destination that don't exist in source
        <span class="cov0" title="0">err = s.cleanupDestination(sourceDir, destDir, session)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup destination: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// performIncrementalSync only copies newer or missing files
func (s *SyncService) performIncrementalSync(sourceDir, destDir string, session *models.SyncSession) error <span class="cov0" title="0">{
        // Walk through source directory
        err := filepath.Walk(sourceDir, func(sourcePath string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip directories for incremental sync
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Calculate relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(sourceDir, sourcePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to calculate relative path: %w", err)
                }</span>

                // Build destination path
                <span class="cov0" title="0">destPath := filepath.Join(destDir, relPath)

                // Check if destination exists
                destInfo, err := os.Stat(destPath)
                if err == nil </span><span class="cov0" title="0">{
                        // File exists, check if source is newer
                        if !info.ModTime().After(destInfo.ModTime()) </span><span class="cov0" title="0">{
                                // Source is not newer, skip
                                return nil
                        }</span>
                }

                // Copy file
                <span class="cov0" title="0">if err := s.copyFile(sourcePath, destPath, info.Mode()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to copy file %s to %s: %w", sourcePath, destPath, err)
                }</span>

                // Update sync session progress
                <span class="cov0" title="0">s.updateSyncProgress(session, fmt.Sprintf("Incrementally synced: %s", relPath))

                return nil</span>
        })

        <span class="cov0" title="0">return err</span>
}

// performBidirectionalSync syncs in both directions
func (s *SyncService) performBidirectionalSync(sourceDir, destDir string, session *models.SyncSession) error <span class="cov0" title="0">{
        // For bidirectional sync, we perform incremental sync in both directions
        // First sync source to destination
        if err := s.performIncrementalSync(sourceDir, destDir, session); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("source to destination sync failed: %w", err)
        }</span>

        // Then sync destination to source
        <span class="cov0" title="0">if err := s.performIncrementalSync(destDir, sourceDir, session); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("destination to source sync failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// copyFile copies a file with proper permissions
func (s *SyncService) copyFile(src, dst string, mode os.FileMode) error <span class="cov0" title="0">{
        // Ensure destination directory exists
        if err := os.MkdirAll(filepath.Dir(dst), 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Open source file
        <span class="cov0" title="0">sourceFile, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sourceFile.Close()

        // Create destination file
        destFile, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, mode)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer destFile.Close()

        // Copy file content
        _, err = io.Copy(destFile, sourceFile)
        return err</span>
}

// cleanupDestination removes files in destination that don't exist in source
func (s *SyncService) cleanupDestination(sourceDir, destDir string, session *models.SyncSession) error <span class="cov0" title="0">{
        // Walk through destination directory
        return filepath.Walk(destDir, func(destPath string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Calculate relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(destDir, destPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to calculate relative path: %w", err)
                }</span>

                // Build corresponding source path
                <span class="cov0" title="0">sourcePath := filepath.Join(sourceDir, relPath)

                // Check if corresponding source file exists
                _, err = os.Stat(sourcePath)
                if err != nil </span><span class="cov0" title="0">{
                        // Source file doesn't exist, remove destination file
                        if info.IsDir() </span><span class="cov0" title="0">{
                                // Remove directory if it's empty
                                if err := os.Remove(destPath); err != nil </span><span class="cov0" title="0">{
                                        // Directory not empty, skip
                                        return nil
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Remove file
                                if err := os.Remove(destPath); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to remove %s: %w", destPath, err)
                                }</span>
                        }

                        // Update sync session progress
                        <span class="cov0" title="0">s.updateSyncProgress(session, fmt.Sprintf("Removed: %s", relPath))</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

func (s *SyncService) handleSyncSuccess(session *models.SyncSession) <span class="cov0" title="0">{
        session.Status = models.SyncSessionStatusCompleted
        session.CompletedAt = &amp;time.Time{}
        *session.CompletedAt = time.Now()

        if session.StartedAt != (time.Time{}) </span><span class="cov0" title="0">{
                duration := session.CompletedAt.Sub(session.StartedAt)
                session.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">s.syncRepo.UpdateSession(session)
        s.notifyUser(session, "Sync completed successfully")</span>
}

func (s *SyncService) handleSyncError(session *models.SyncSession, syncError error) <span class="cov0" title="0">{
        session.Status = models.SyncSessionStatusFailed
        session.CompletedAt = &amp;time.Time{}
        *session.CompletedAt = time.Now()
        errorMsg := syncError.Error()
        session.ErrorMessage = &amp;errorMsg

        if session.StartedAt != (time.Time{}) </span><span class="cov0" title="0">{
                duration := session.CompletedAt.Sub(session.StartedAt)
                session.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">s.syncRepo.UpdateSession(session)
        s.notifyUser(session, fmt.Sprintf("Sync failed: %s", syncError.Error()))</span>
}

func (s *SyncService) updateSyncProgress(session *models.SyncSession, message string) <span class="cov0" title="0">{
        // In a full implementation, this would update the session with current progress
        // For now, we just log the progress update
        fmt.Printf("Sync progress for session %d: %s\n", session.ID, message)
}</span>

func (s *SyncService) logSyncError(session *models.SyncSession, message string) <span class="cov0" title="0">{
        // In a full implementation, this would log to a sync error log
        fmt.Printf("Sync error for session %d: %s\n", session.ID, message)
}</span>

func (s *SyncService) notifyUser(session *models.SyncSession, message string) <span class="cov0" title="0">{
        // In a full implementation, this would send notifications
        fmt.Printf("Notification for user %d: %s (Session %d)\n", session.UserID, message, session.ID)
}</span>

func (s *SyncService) GetUserSessions(userID int, limit, offset int) ([]models.SyncSession, error) <span class="cov0" title="0">{
        return s.syncRepo.GetUserSessions(userID, limit, offset)
}</span>

func (s *SyncService) GetSession(sessionID int, userID int) (*models.SyncSession, error) <span class="cov0" title="0">{
        session, err := s.syncRepo.GetSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if session.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to view this session")
                }</span>
        }

        <span class="cov0" title="0">return session, nil</span>
}

func (s *SyncService) ScheduleSync(endpointID int, userID int, schedule *models.SyncSchedule) (*models.SyncSchedule, error) <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionEditShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to schedule sync for this endpoint")
                }</span>
        }

        <span class="cov0" title="0">schedule.EndpointID = endpointID
        schedule.UserID = userID
        schedule.CreatedAt = time.Now()
        schedule.IsActive = true

        id, err := s.syncRepo.CreateSchedule(schedule)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sync schedule: %w", err)
        }</span>

        <span class="cov0" title="0">schedule.ID = id
        return schedule, nil</span>
}

func (s *SyncService) GetSyncStatistics(userID *int, startDate, endDate time.Time) (*models.SyncStatistics, error) <span class="cov0" title="0">{
        return s.syncRepo.GetStatistics(userID, startDate, endDate)
}</span>

func (s *SyncService) ProcessScheduledSyncs() error <span class="cov0" title="0">{
        schedules, err := s.syncRepo.GetActiveSchedules()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, schedule := range schedules </span><span class="cov0" title="0">{
                if s.shouldRunSchedule(&amp;schedule) </span><span class="cov0" title="0">{
                        _, err := s.StartSync(schedule.EndpointID, schedule.UserID)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to start scheduled sync for endpoint %d: %v\n", schedule.EndpointID, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) shouldRunSchedule(schedule *models.SyncSchedule) bool <span class="cov8" title="1">{
        now := time.Now()

        switch schedule.Frequency </span>{
        case models.SyncFrequencyHourly:<span class="cov8" title="1">
                return schedule.LastRun == nil || schedule.LastRun.Add(time.Hour).Before(now)</span>
        case models.SyncFrequencyDaily:<span class="cov8" title="1">
                return schedule.LastRun == nil || schedule.LastRun.Add(24*time.Hour).Before(now)</span>
        case models.SyncFrequencyWeekly:<span class="cov8" title="1">
                return schedule.LastRun == nil || schedule.LastRun.Add(7*24*time.Hour).Before(now)</span>
        case models.SyncFrequencyMonthly:<span class="cov8" title="1">
                return schedule.LastRun == nil || schedule.LastRun.AddDate(0, 1, 0).Before(now)</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func (s *SyncService) validateSyncEndpoint(endpoint *models.SyncEndpoint) error <span class="cov8" title="1">{
        if endpoint.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("name is required")
        }</span>

        <span class="cov8" title="1">if endpoint.URL == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("URL is required")
        }</span>

        <span class="cov8" title="1">if endpoint.Type == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("type is required")
        }</span>

        <span class="cov8" title="1">if endpoint.SyncDirection == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("sync direction is required")
        }</span>

        <span class="cov8" title="1">if endpoint.LocalPath == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("local path is required")
        }</span>

        <span class="cov8" title="1">validTypes := []string{models.SyncTypeWebDAV, models.SyncTypeCloudStorage, models.SyncTypeLocal}
        if !s.isValidType(endpoint.Type, validTypes) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid sync type: %s", endpoint.Type)
        }</span>

        <span class="cov8" title="1">validDirections := []string{models.SyncDirectionUpload, models.SyncDirectionDownload, models.SyncDirectionBidirectional}
        if !s.isValidType(endpoint.SyncDirection, validDirections) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid sync direction: %s", endpoint.SyncDirection)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *SyncService) isValidType(value string, validValues []string) bool <span class="cov8" title="1">{
        for _, valid := range validValues </span><span class="cov8" title="1">{
                if value == valid </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (s *SyncService) testConnection(endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        switch endpoint.Type </span>{
        case models.SyncTypeWebDAV:<span class="cov0" title="0">
                client, err := s.getWebDAVClient(endpoint)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return client.TestConnection()</span>
        default:<span class="cov0" title="0">
                return nil</span> // Skip test for other types for now
        }
}

func (s *SyncService) getWebDAVClient(endpoint *models.SyncEndpoint) (*WebDAVClient, error) <span class="cov8" title="1">{
        if client, exists := s.webdavClients[endpoint.ID]; exists </span><span class="cov8" title="1">{
                return client, nil
        }</span>

        <span class="cov8" title="1">client := NewWebDAVClient(endpoint.URL, endpoint.Username, endpoint.Password)
        s.webdavClients[endpoint.ID] = client

        return client, nil</span>
}

func (s *SyncService) scanLocalFiles(path string) ([]string, error) <span class="cov8" title="1">{
        var files []string

        err := filepath.Walk(path, func(filePath string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                        files = append(files, filePath)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">return files, err</span>
}

func (s *SyncService) shouldSkipFile(filePath string, endpoint *models.SyncEndpoint) bool <span class="cov8" title="1">{
        fileName := filepath.Base(filePath)

        // Skip hidden files
        if strings.HasPrefix(fileName, ".") </span><span class="cov8" title="1">{
                return true
        }</span>

        // Skip temporary files
        <span class="cov8" title="1">if strings.HasSuffix(fileName, ".tmp") || strings.HasSuffix(fileName, ".temp") </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check file size limits if configured
        <span class="cov8" title="1">if endpoint.SyncSettings != nil </span>{<span class="cov0" title="0">
                // This would parse JSON settings and check file size limits
        }</span>

        <span class="cov8" title="1">return false</span>
}

func (s *SyncService) shouldSkipRemoteFile(file *WebDAVFile, endpoint *models.SyncEndpoint) bool <span class="cov8" title="1">{
        fileName := filepath.Base(file.Path)

        // Skip hidden files
        if strings.HasPrefix(fileName, ".") </span><span class="cov8" title="1">{
                return true
        }</span>

        // Skip temporary files
        <span class="cov8" title="1">if strings.HasSuffix(fileName, ".tmp") || strings.HasSuffix(fileName, ".temp") </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

func (s *SyncService) calculateChecksum(filePath string) (string, error) <span class="cov8" title="1">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        hash := md5.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return hex.EncodeToString(hash.Sum(nil)), nil</span>
}

func (s *SyncService) CleanupOldSessions(olderThan time.Time) error <span class="cov0" title="0">{
        return s.syncRepo.CleanupSessions(olderThan)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package services

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/studio-b12/gowebdav"
)

type WebDAVClient struct {
        client   *gowebdav.Client
        baseURL  string
        username string
        password string
}

type WebDAVFile struct {
        Path    string
        Size    int64
        ModTime time.Time
        IsDir   bool
}

func NewWebDAVClient(url, username, password string) *WebDAVClient <span class="cov8" title="1">{
        client := gowebdav.NewClient(url, username, password)

        return &amp;WebDAVClient{
                client:   client,
                baseURL:  url,
                username: username,
                password: password,
        }
}</span>

func (c *WebDAVClient) TestConnection() error <span class="cov0" title="0">{
        _, err := c.client.ReadDir("/")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV connection test failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) ListFiles(remotePath string) ([]*WebDAVFile, error) <span class="cov0" title="0">{
        files, err := c.client.ReadDir(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list files: %w", err)
        }</span>

        <span class="cov0" title="0">var webdavFiles []*WebDAVFile
        for _, file := range files </span><span class="cov0" title="0">{
                webdavFile := &amp;WebDAVFile{
                        Path:    filepath.Join(remotePath, file.Name()),
                        Size:    file.Size(),
                        ModTime: file.ModTime(),
                        IsDir:   file.IsDir(),
                }
                webdavFiles = append(webdavFiles, webdavFile)

                // Recursively list subdirectories if needed
                if file.IsDir() </span><span class="cov0" title="0">{
                        subFiles, err := c.ListFiles(webdavFile.Path)
                        if err == nil </span><span class="cov0" title="0">{
                                webdavFiles = append(webdavFiles, subFiles...)
                        }</span>
                }
        }

        <span class="cov0" title="0">return webdavFiles, nil</span>
}

func (c *WebDAVClient) UploadFile(localPath, remotePath string) error <span class="cov0" title="0">{
        // Ensure remote directory exists
        remoteDir := filepath.Dir(remotePath)
        if err := c.client.MkdirAll(remoteDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create remote directory: %w", err)
        }</span>

        // Open local file
        <span class="cov0" title="0">localFile, err := os.Open(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open local file: %w", err)
        }</span>
        <span class="cov0" title="0">defer localFile.Close()

        // Upload to WebDAV
        err = c.client.WriteStream(remotePath, localFile, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) DownloadFile(remotePath, localPath string) error <span class="cov0" title="0">{
        // Create local directory if it doesn't exist
        localDir := filepath.Dir(localPath)
        if err := os.MkdirAll(localDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local directory: %w", err)
        }</span>

        // Open remote file
        <span class="cov0" title="0">reader, err := c.client.ReadStream(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open remote file: %w", err)
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        // Create local file
        localFile, err := os.Create(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local file: %w", err)
        }</span>
        <span class="cov0" title="0">defer localFile.Close()

        // Copy data
        _, err = io.Copy(localFile, reader)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) GetModTime(remotePath string) (time.Time, error) <span class="cov0" title="0">{
        info, err := c.client.Stat(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">return info.ModTime(), nil</span>
}

func (c *WebDAVClient) DeleteFile(remotePath string) error <span class="cov0" title="0">{
        err := c.client.Remove(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) MoveFile(sourcePath, destPath string) error <span class="cov0" title="0">{
        err := c.client.Rename(sourcePath, destPath, false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to move file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) CopyFile(sourcePath, destPath string) error <span class="cov0" title="0">{
        err := c.client.Copy(sourcePath, destPath, false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) CreateDirectory(remotePath string) error <span class="cov0" title="0">{
        err := c.client.Mkdir(remotePath, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) FileExists(remotePath string) bool <span class="cov0" title="0">{
        _, err := c.client.Stat(remotePath)
        return err == nil
}</span>

func (c *WebDAVClient) GetFileSize(remotePath string) (int64, error) <span class="cov0" title="0">{
        info, err := c.client.Stat(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">return info.Size(), nil</span>
}

func (c *WebDAVClient) GetQuota() (*WebDAVQuota, error) <span class="cov8" title="1">{
        // This would require parsing PROPFIND response for quota information
        // For now, return a placeholder
        return &amp;WebDAVQuota{
                Used:      0,
                Available: -1, // Unlimited
        }, nil
}</span>

type WebDAVQuota struct {
        Used      int64 `json:"used"`
        Available int64 `json:"available"` // -1 for unlimited
}

// Batch operations for efficiency

func (c *WebDAVClient) UploadBatch(files []FileTransfer) (*BatchResult, error) <span class="cov0" title="0">{
        result := &amp;BatchResult{
                Total:     len(files),
                Succeeded: 0,
                Failed:    0,
                Errors:    make([]string, 0),
        }

        for _, file := range files </span><span class="cov0" title="0">{
                err := c.UploadFile(file.LocalPath, file.RemotePath)
                if err != nil </span><span class="cov0" title="0">{
                        result.Failed++
                        result.Errors = append(result.Errors, fmt.Sprintf("%s: %v", file.LocalPath, err))
                }</span> else<span class="cov0" title="0"> {
                        result.Succeeded++
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func (c *WebDAVClient) DownloadBatch(files []FileTransfer) (*BatchResult, error) <span class="cov0" title="0">{
        result := &amp;BatchResult{
                Total:     len(files),
                Succeeded: 0,
                Failed:    0,
                Errors:    make([]string, 0),
        }

        for _, file := range files </span><span class="cov0" title="0">{
                err := c.DownloadFile(file.RemotePath, file.LocalPath)
                if err != nil </span><span class="cov0" title="0">{
                        result.Failed++
                        result.Errors = append(result.Errors, fmt.Sprintf("%s: %v", file.RemotePath, err))
                }</span> else<span class="cov0" title="0"> {
                        result.Succeeded++
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

type FileTransfer struct {
        LocalPath  string
        RemotePath string
}

type BatchResult struct {
        Total     int      `json:"total"`
        Succeeded int      `json:"succeeded"`
        Failed    int      `json:"failed"`
        Errors    []string `json:"errors"`
}

// Sync-specific methods

func (c *WebDAVClient) SyncDirectory(localPath, remotePath string, direction string) (*SyncResult, error) <span class="cov0" title="0">{
        result := &amp;SyncResult{
                UploadedFiles:   0,
                DownloadedFiles: 0,
                SkippedFiles:    0,
                FailedFiles:     0,
                Errors:          make([]string, 0),
        }

        switch direction </span>{
        case "upload":<span class="cov0" title="0">
                return c.syncUpload(localPath, remotePath, result)</span>
        case "download":<span class="cov0" title="0">
                return c.syncDownload(localPath, remotePath, result)</span>
        case "bidirectional":<span class="cov0" title="0">
                // First upload, then download
                result, err := c.syncUpload(localPath, remotePath, result)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">return c.syncDownload(localPath, remotePath, result)</span>
        default:<span class="cov0" title="0">
                return result, fmt.Errorf("invalid sync direction: %s", direction)</span>
        }
}

func (c *WebDAVClient) syncUpload(localPath, remotePath string, result *SyncResult) (*SyncResult, error) <span class="cov0" title="0">{
        err := filepath.Walk(localPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Skip hidden files and temporary files
                <span class="cov0" title="0">if strings.HasPrefix(info.Name(), ".") || strings.HasSuffix(info.Name(), ".tmp") </span><span class="cov0" title="0">{
                        result.SkippedFiles++
                        return nil
                }</span>

                <span class="cov0" title="0">relPath, err := filepath.Rel(localPath, path)
                if err != nil </span><span class="cov0" title="0">{
                        result.FailedFiles++
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to get relative path for %s: %v", path, err))
                        return nil
                }</span>

                <span class="cov0" title="0">remoteFilePath := filepath.Join(remotePath, relPath)
                remoteFilePath = filepath.ToSlash(remoteFilePath) // Convert to forward slashes for WebDAV

                // Check if remote file exists and compare modification times
                remoteModTime, err := c.GetModTime(remoteFilePath)
                if err == nil </span><span class="cov0" title="0">{
                        // Remote file exists, check if local is newer
                        if !info.ModTime().After(remoteModTime) </span><span class="cov0" title="0">{
                                result.SkippedFiles++
                                return nil
                        }</span>
                }

                // Upload the file
                <span class="cov0" title="0">err = c.UploadFile(path, remoteFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        result.FailedFiles++
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to upload %s: %v", path, err))
                }</span> else<span class="cov0" title="0"> {
                        result.UploadedFiles++
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return result, err</span>
}

func (c *WebDAVClient) syncDownload(localPath, remotePath string, result *SyncResult) (*SyncResult, error) <span class="cov0" title="0">{
        remoteFiles, err := c.ListFiles(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return result, fmt.Errorf("failed to list remote files: %w", err)
        }</span>

        <span class="cov0" title="0">for _, remoteFile := range remoteFiles </span><span class="cov0" title="0">{
                if remoteFile.IsDir </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip hidden files and temporary files
                <span class="cov0" title="0">fileName := filepath.Base(remoteFile.Path)
                if strings.HasPrefix(fileName, ".") || strings.HasSuffix(fileName, ".tmp") </span><span class="cov0" title="0">{
                        result.SkippedFiles++
                        continue</span>
                }

                <span class="cov0" title="0">relPath, err := filepath.Rel(remotePath, remoteFile.Path)
                if err != nil </span><span class="cov0" title="0">{
                        result.FailedFiles++
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to get relative path for %s: %v", remoteFile.Path, err))
                        continue</span>
                }

                <span class="cov0" title="0">localFilePath := filepath.Join(localPath, relPath)

                // Check if local file exists and compare modification times
                localInfo, err := os.Stat(localFilePath)
                if err == nil </span><span class="cov0" title="0">{
                        // Local file exists, check if remote is newer
                        if !remoteFile.ModTime.After(localInfo.ModTime()) </span><span class="cov0" title="0">{
                                result.SkippedFiles++
                                continue</span>
                        }
                }

                // Download the file
                <span class="cov0" title="0">err = c.DownloadFile(remoteFile.Path, localFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        result.FailedFiles++
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to download %s: %v", remoteFile.Path, err))
                }</span> else<span class="cov0" title="0"> {
                        result.DownloadedFiles++
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

type SyncResult struct {
        UploadedFiles   int      `json:"uploaded_files"`
        DownloadedFiles int      `json:"downloaded_files"`
        SkippedFiles    int      `json:"skipped_files"`
        FailedFiles     int      `json:"failed_files"`
        Errors          []string `json:"errors"`
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
