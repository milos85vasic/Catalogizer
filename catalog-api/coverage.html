
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">catalogizer/config/config.go (0.0%)</option>
				
				<option value="file1">catalogizer/database/connection.go (0.0%)</option>
				
				<option value="file2">catalogizer/database/migrations.go (0.0%)</option>
				
				<option value="file3">catalogizer/filesystem/factory.go (81.5%)</option>
				
				<option value="file4">catalogizer/filesystem/ftp_client.go (1.6%)</option>
				
				<option value="file5">catalogizer/filesystem/local_client.go (47.7%)</option>
				
				<option value="file6">catalogizer/filesystem/nfs_client_darwin.go (2.5%)</option>
				
				<option value="file7">catalogizer/filesystem/smb_client.go (11.7%)</option>
				
				<option value="file8">catalogizer/filesystem/webdav_client.go (2.3%)</option>
				
				<option value="file9">catalogizer/handlers/auth_handler.go (57.5%)</option>
				
				<option value="file10">catalogizer/handlers/browse.go (8.4%)</option>
				
				<option value="file11">catalogizer/handlers/configuration_handler.go (0.0%)</option>
				
				<option value="file12">catalogizer/handlers/conversion_handler.go (0.0%)</option>
				
				<option value="file13">catalogizer/handlers/copy.go (9.1%)</option>
				
				<option value="file14">catalogizer/handlers/download.go (10.9%)</option>
				
				<option value="file15">catalogizer/handlers/error_reporting_handler.go (0.0%)</option>
				
				<option value="file16">catalogizer/handlers/log_management_handler.go (0.0%)</option>
				
				<option value="file17">catalogizer/handlers/role_handler.go (0.0%)</option>
				
				<option value="file18">catalogizer/handlers/search.go (20.6%)</option>
				
				<option value="file19">catalogizer/handlers/stats.go (1.1%)</option>
				
				<option value="file20">catalogizer/handlers/stress_test_handler.go (0.0%)</option>
				
				<option value="file21">catalogizer/handlers/user_handler.go (0.0%)</option>
				
				<option value="file22">catalogizer/internal/auth/middleware.go (0.0%)</option>
				
				<option value="file23">catalogizer/internal/auth/models.go (0.0%)</option>
				
				<option value="file24">catalogizer/internal/auth/service.go (0.0%)</option>
				
				<option value="file25">catalogizer/internal/config/config.go (0.0%)</option>
				
				<option value="file26">catalogizer/internal/handlers/auth.go (0.0%)</option>
				
				<option value="file27">catalogizer/internal/handlers/catalog.go (59.4%)</option>
				
				<option value="file28">catalogizer/internal/handlers/copy.go (10.4%)</option>
				
				<option value="file29">catalogizer/internal/handlers/download.go (0.0%)</option>
				
				<option value="file30">catalogizer/internal/handlers/localization_handlers.go (0.0%)</option>
				
				<option value="file31">catalogizer/internal/handlers/media.go (0.0%)</option>
				
				<option value="file32">catalogizer/internal/handlers/media_player_handlers.go (0.0%)</option>
				
				<option value="file33">catalogizer/internal/handlers/recommendation_handler.go (0.0%)</option>
				
				<option value="file34">catalogizer/internal/handlers/smb.go (0.0%)</option>
				
				<option value="file35">catalogizer/internal/handlers/smb_discovery.go (0.0%)</option>
				
				<option value="file36">catalogizer/internal/media/analyzer/analyzer.go (0.0%)</option>
				
				<option value="file37">catalogizer/internal/media/database/database.go (0.0%)</option>
				
				<option value="file38">catalogizer/internal/media/detector/engine.go (0.0%)</option>
				
				<option value="file39">catalogizer/internal/media/manager.go (0.0%)</option>
				
				<option value="file40">catalogizer/internal/media/models/media.go (0.0%)</option>
				
				<option value="file41">catalogizer/internal/media/providers/providers.go (0.0%)</option>
				
				<option value="file42">catalogizer/internal/media/realtime/enhanced_watcher.go (4.3%)</option>
				
				<option value="file43">catalogizer/internal/media/realtime/watcher.go (0.0%)</option>
				
				<option value="file44">catalogizer/internal/middleware/middleware.go (0.0%)</option>
				
				<option value="file45">catalogizer/internal/recovery/circuit_breaker.go (0.0%)</option>
				
				<option value="file46">catalogizer/internal/recovery/retry.go (0.0%)</option>
				
				<option value="file47">catalogizer/internal/services/book_recognition_provider.go (0.0%)</option>
				
				<option value="file48">catalogizer/internal/services/cache_service.go (0.0%)</option>
				
				<option value="file49">catalogizer/internal/services/catalog.go (67.6%)</option>
				
				<option value="file50">catalogizer/internal/services/cover_art_service.go (0.0%)</option>
				
				<option value="file51">catalogizer/internal/services/deep_linking_service.go (0.0%)</option>
				
				<option value="file52">catalogizer/internal/services/duplicate_detection_service.go (0.0%)</option>
				
				<option value="file53">catalogizer/internal/services/game_software_recognition_provider.go (0.0%)</option>
				
				<option value="file54">catalogizer/internal/services/localization_service.go (0.0%)</option>
				
				<option value="file55">catalogizer/internal/services/lyrics_service.go (0.0%)</option>
				
				<option value="file56">catalogizer/internal/services/media_player_service.go (0.0%)</option>
				
				<option value="file57">catalogizer/internal/services/media_recognition_service.go (0.0%)</option>
				
				<option value="file58">catalogizer/internal/services/movie_recognition_provider.go (0.0%)</option>
				
				<option value="file59">catalogizer/internal/services/music_player_service.go (0.0%)</option>
				
				<option value="file60">catalogizer/internal/services/music_recognition_provider.go (0.0%)</option>
				
				<option value="file61">catalogizer/internal/services/playback_position_service.go (0.0%)</option>
				
				<option value="file62">catalogizer/internal/services/playlist_service.go (0.0%)</option>
				
				<option value="file63">catalogizer/internal/services/protocol_handlers.go (0.0%)</option>
				
				<option value="file64">catalogizer/internal/services/reader_service.go (0.0%)</option>
				
				<option value="file65">catalogizer/internal/services/recommendation_service.go (0.0%)</option>
				
				<option value="file66">catalogizer/internal/services/rename_tracker.go (84.0%)</option>
				
				<option value="file67">catalogizer/internal/services/smb.go (0.0%)</option>
				
				<option value="file68">catalogizer/internal/services/smb_discovery.go (13.7%)</option>
				
				<option value="file69">catalogizer/internal/services/subtitle_service.go (0.0%)</option>
				
				<option value="file70">catalogizer/internal/services/translation_service.go (0.0%)</option>
				
				<option value="file71">catalogizer/internal/services/universal_rename_tracker.go (0.0%)</option>
				
				<option value="file72">catalogizer/internal/services/universal_scanner.go (0.0%)</option>
				
				<option value="file73">catalogizer/internal/services/video_player_service.go (0.0%)</option>
				
				<option value="file74">catalogizer/internal/smb/resilience.go (0.0%)</option>
				
				<option value="file75">catalogizer/internal/tests/dup_working.go (0.0%)</option>
				
				<option value="file76">catalogizer/internal/tests/media_recognition_mock_servers.go (0.0%)</option>
				
				<option value="file77">catalogizer/internal/tests/mock_servers.go (0.0%)</option>
				
				<option value="file78">catalogizer/main.go (0.0%)</option>
				
				<option value="file79">catalogizer/middleware/auth.go (0.0%)</option>
				
				<option value="file80">catalogizer/middleware/request.go (0.0%)</option>
				
				<option value="file81">catalogizer/models/user.go (0.0%)</option>
				
				<option value="file82">catalogizer/repository/analytics_repository.go (0.0%)</option>
				
				<option value="file83">catalogizer/repository/configuration_repository.go (0.0%)</option>
				
				<option value="file84">catalogizer/repository/conversion_repository.go (0.0%)</option>
				
				<option value="file85">catalogizer/repository/crash_reporting_repository.go (0.0%)</option>
				
				<option value="file86">catalogizer/repository/error_reporting_repository.go (0.0%)</option>
				
				<option value="file87">catalogizer/repository/favorites_repository.go (0.0%)</option>
				
				<option value="file88">catalogizer/repository/file_repository.go (0.0%)</option>
				
				<option value="file89">catalogizer/repository/log_management_repository.go (0.0%)</option>
				
				<option value="file90">catalogizer/repository/stats_repository.go (0.0%)</option>
				
				<option value="file91">catalogizer/repository/stress_test_repository.go (0.0%)</option>
				
				<option value="file92">catalogizer/repository/sync_repository.go (0.0%)</option>
				
				<option value="file93">catalogizer/repository/user_repository.go (0.0%)</option>
				
				<option value="file94">catalogizer/services/analytics_service.go (0.0%)</option>
				
				<option value="file95">catalogizer/services/auth_service.go (0.0%)</option>
				
				<option value="file96">catalogizer/services/configuration_service.go (0.0%)</option>
				
				<option value="file97">catalogizer/services/configuration_wizard_service.go (0.0%)</option>
				
				<option value="file98">catalogizer/services/conversion_service.go (0.0%)</option>
				
				<option value="file99">catalogizer/services/error_reporting_service.go (0.0%)</option>
				
				<option value="file100">catalogizer/services/favorites_service.go (0.0%)</option>
				
				<option value="file101">catalogizer/services/log_management_service.go (0.0%)</option>
				
				<option value="file102">catalogizer/services/reporting_service.go (0.0%)</option>
				
				<option value="file103">catalogizer/services/stress_test_service.go (0.0%)</option>
				
				<option value="file104">catalogizer/services/sync_service.go (0.0%)</option>
				
				<option value="file105">catalogizer/services/webdav_client.go (0.0%)</option>
				
				<option value="file106">catalogizer/smb/client.go (0.0%)</option>
				
				<option value="file107">catalogizer/smb/types.go (0.0%)</option>
				
				<option value="file108">catalogizer/tests/integration/protocol_rename_tests.go (0.0%)</option>
				
				<option value="file109">catalogizer/tests/mocks/ftp_mock_server.go (0.0%)</option>
				
				<option value="file110">catalogizer/tests/mocks/nfs_mock_server.go (0.0%)</option>
				
				<option value="file111">catalogizer/tests/mocks/smb_mock_server.go (0.0%)</option>
				
				<option value="file112">catalogizer/tests/mocks/webdav_mock_server.go (0.0%)</option>
				
				<option value="file113">catalogizer/tests/test_main.go (0.0%)</option>
				
				<option value="file114">catalogizer/tests/test_utils.go (38.5%)</option>
				
				<option value="file115">catalogizer/utils/response.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
)

// Config represents the API configuration
type Config struct {
        Server   ServerConfig   `json:"server"`
        Database DatabaseConfig `json:"database"`
        Auth     AuthConfig     `json:"auth"`
        Catalog  CatalogConfig  `json:"catalog"`
        Storage  StorageConfig  `json:"storage"`
        Logging  LoggingConfig  `json:"logging"`
}

// ServerConfig contains server-related configuration
type ServerConfig struct {
        Host         string `json:"host"`
        Port         int    `json:"port"`
        ReadTimeout  int    `json:"read_timeout"`
        WriteTimeout int    `json:"write_timeout"`
        IdleTimeout  int    `json:"idle_timeout"`
        EnableCORS   bool   `json:"enable_cors"`
        EnableHTTPS  bool   `json:"enable_https"`
        CertFile     string `json:"cert_file,omitempty"`
        KeyFile      string `json:"key_file,omitempty"`
}

// DatabaseConfig contains database connection configuration
type DatabaseConfig struct {
        Path               string `json:"path"`
        MaxOpenConnections int    `json:"max_open_connections"`
        MaxIdleConnections int    `json:"max_idle_connections"`
        ConnMaxLifetime    int    `json:"conn_max_lifetime"`
        ConnMaxIdleTime    int    `json:"conn_max_idle_time"`
        EnableWAL          bool   `json:"enable_wal"`
        CacheSize          int    `json:"cache_size"`
        BusyTimeout        int    `json:"busy_timeout"`
}

// AuthConfig contains authentication configuration
type AuthConfig struct {
        JWTSecret          string `json:"jwt_secret"`
        JWTExpirationHours int    `json:"jwt_expiration_hours"`
        EnableAuth         bool   `json:"enable_auth"`
        AdminUsername      string `json:"admin_username"`
        AdminPassword      string `json:"admin_password"`
}

// CatalogConfig contains catalog-specific configuration
type CatalogConfig struct {
        DefaultPageSize      int      `json:"default_page_size"`
        MaxPageSize          int      `json:"max_page_size"`
        EnableCache          bool     `json:"enable_cache"`
        CacheTTLMinutes      int      `json:"cache_ttl_minutes"`
        MaxConcurrentScans   int      `json:"max_concurrent_scans"`
        DownloadChunkSize    int      `json:"download_chunk_size"`
        MaxArchiveSize       int64    `json:"max_archive_size"`
        AllowedDownloadTypes []string `json:"allowed_download_types"`
        TempDir              string   `json:"temp_dir"`
}

// LoggingConfig contains logging configuration
type LoggingConfig struct {
        Level      string `json:"level"`
        Format     string `json:"format"`
        Output     string `json:"output"`
        MaxSize    int    `json:"max_size"`
        MaxBackups int    `json:"max_backups"`
        MaxAge     int    `json:"max_age"`
        Compress   bool   `json:"compress"`
}

// StorageConfig contains storage configuration for multiple protocols
type StorageConfig struct {
        Roots []StorageRootConfig `json:"roots"`
}

// StorageRootConfig represents configuration for a single storage root
type StorageRootConfig struct {
        ID                       string                 `json:"id"`
        Name                     string                 `json:"name"`
        Protocol                 string                 `json:"protocol"` // smb, ftp, nfs, webdav, local
        Enabled                  bool                   `json:"enabled"`
        MaxDepth                 int                    `json:"max_depth"`
        EnableDuplicateDetection bool                   `json:"enable_duplicate_detection"`
        EnableMetadataExtraction bool                   `json:"enable_metadata_extraction"`
        IncludePatterns          []string               `json:"include_patterns,omitempty"`
        ExcludePatterns          []string               `json:"exclude_patterns,omitempty"`
        Settings                 map[string]interface{} `json:"settings"` // Protocol-specific settings
}

// LoadConfig loads configuration from file or creates default
func LoadConfig(configPath string) (*Config, error) <span class="cov0" title="0">{
        config := getDefaultConfig()

        // Check if config file exists
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Create default config file
                if err := saveConfig(config, configPath); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create default config: %w", err)
                }</span>
                <span class="cov0" title="0">return config, nil</span>
        }

        // Load existing config
        <span class="cov0" title="0">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(data, config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Validate configuration
        <span class="cov0" title="0">if err := validateConfig(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// getDefaultConfig returns default configuration
func getDefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Server: ServerConfig{
                        Host:         "localhost",
                        Port:         8080,
                        ReadTimeout:  30,
                        WriteTimeout: 30,
                        IdleTimeout:  120,
                        EnableCORS:   true,
                        EnableHTTPS:  false,
                },
                Database: DatabaseConfig{
                        Path:               "./catalog.db",
                        MaxOpenConnections: 25,
                        MaxIdleConnections: 5,
                        ConnMaxLifetime:    300,
                        ConnMaxIdleTime:    60,
                        EnableWAL:          true,
                        CacheSize:          -2000,
                        BusyTimeout:        5000,
                },
                Auth: AuthConfig{
                        JWTSecret:          "change-this-secret-in-production",
                        JWTExpirationHours: 24,
                        EnableAuth:         false,
                        AdminUsername:      "admin",
                        AdminPassword:      "admin123",
                },
                Catalog: CatalogConfig{
                        DefaultPageSize:      100,
                        MaxPageSize:          1000,
                        EnableCache:          true,
                        CacheTTLMinutes:      15,
                        MaxConcurrentScans:   3,
                        DownloadChunkSize:    1024 * 1024,            // 1MB
                        MaxArchiveSize:       1024 * 1024 * 1024 * 5, // 5GB
                        AllowedDownloadTypes: []string{"*"},
                        TempDir:              "/tmp/catalog-api",
                },
                Storage: StorageConfig{
                        Roots: []StorageRootConfig{
                                {
                                        ID:                       "local-example",
                                        Name:                     "Local Files",
                                        Protocol:                 "local",
                                        Enabled:                  true,
                                        MaxDepth:                 10,
                                        EnableDuplicateDetection: true,
                                        EnableMetadataExtraction: true,
                                        Settings: map[string]interface{}{
                                                "base_path": "/tmp/catalog-data",
                                        },
                                },
                        },
                },
                Logging: LoggingConfig{
                        Level:      "info",
                        Format:     "json",
                        Output:     "stdout",
                        MaxSize:    100,
                        MaxBackups: 3,
                        MaxAge:     28,
                        Compress:   true,
                },
        }
}</span>

// validateConfig validates the configuration
func validateConfig(config *Config) error <span class="cov0" title="0">{
        if config.Server.Port &lt;= 0 || config.Server.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid server port: %d", config.Server.Port)
        }</span>

        <span class="cov0" title="0">if config.Database.Path == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database path cannot be empty")
        }</span>

        <span class="cov0" title="0">if config.Auth.EnableAuth &amp;&amp; config.Auth.JWTSecret == "change-this-secret-in-production" </span><span class="cov0" title="0">{
                return fmt.Errorf("JWT secret must be changed in production")
        }</span>

        <span class="cov0" title="0">if config.Catalog.DefaultPageSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("default page size must be positive")
        }</span>

        <span class="cov0" title="0">if config.Catalog.MaxPageSize &lt; config.Catalog.DefaultPageSize </span><span class="cov0" title="0">{
                return fmt.Errorf("max page size must be &gt;= default page size")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// saveConfig saves configuration to file
func saveConfig(config *Config, configPath string) error <span class="cov0" title="0">{
        // Create directory if it doesn't exist
        dir := filepath.Dir(configPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        <span class="cov0" title="0">data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(configPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDatabaseURL returns the database connection URL
func (c *Config) GetDatabaseURL() string <span class="cov0" title="0">{
        params := "?_busy_timeout=5000&amp;_journal_mode=WAL&amp;_synchronous=NORMAL&amp;_foreign_keys=1"
        if c.Database.EnableWAL </span><span class="cov0" title="0">{
                params += "&amp;_wal_autocheckpoint=1000"
        }</span>
        <span class="cov0" title="0">if c.Database.CacheSize != 0 </span><span class="cov0" title="0">{
                params += fmt.Sprintf("&amp;_cache_size=%d", c.Database.CacheSize)
        }</span>
        <span class="cov0" title="0">return c.Database.Path + params</span>
}

// GetServerAddress returns the server address
func (c *Config) GetServerAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.Server.Host, c.Server.Port)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "catalogizer/config"
        _ "github.com/mattn/go-sqlite3"
)

// DB represents the database connection
type DB struct {
        *sql.DB
        config *config.DatabaseConfig
}

// NewConnection creates a new database connection
func NewConnection(cfg *config.DatabaseConfig) (*DB, error) <span class="cov0" title="0">{
        // Build connection string with parameters
        connStr := cfg.Path + "?_busy_timeout=5000&amp;_journal_mode=WAL&amp;_synchronous=NORMAL&amp;_foreign_keys=1"

        if cfg.EnableWAL </span><span class="cov0" title="0">{
                connStr += "&amp;_wal_autocheckpoint=1000"
        }</span>

        <span class="cov0" title="0">if cfg.CacheSize != 0 </span><span class="cov0" title="0">{
                connStr += fmt.Sprintf("&amp;_cache_size=%d", cfg.CacheSize)
        }</span>

        // Open database connection
        <span class="cov0" title="0">sqlDB, err := sql.Open("sqlite3", connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(cfg.MaxOpenConnections)
        sqlDB.SetMaxIdleConns(cfg.MaxIdleConnections)
        sqlDB.SetConnMaxLifetime(time.Duration(cfg.ConnMaxLifetime) * time.Second)
        sqlDB.SetConnMaxIdleTime(time.Duration(cfg.ConnMaxIdleTime) * time.Second)

        // Test connection
        if err := sqlDB.Ping(); err != nil </span><span class="cov0" title="0">{
                sqlDB.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">db := &amp;DB{
                DB:     sqlDB,
                config: cfg,
        }

        return db, nil</span>
}

// HealthCheck performs a database health check
func (db *DB) HealthCheck() error <span class="cov0" title="0">{
        ctx, cancel := db.createContext()
        defer cancel()

        return db.PingContext(ctx)
}</span>

// GetStats returns database connection statistics
func (db *DB) GetStats() sql.DBStats <span class="cov0" title="0">{
        return db.Stats()
}</span>

// createContext creates a context with timeout
func (db *DB) createContext() (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        timeout := time.Duration(db.config.BusyTimeout) * time.Millisecond
        return context.WithTimeout(context.Background(), timeout)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "context"
        "fmt"
)

// RunMigrations runs database migrations
func (db *DB) RunMigrations(ctx context.Context) error <span class="cov0" title="0">{
        // Create migrations table if it doesn't exist
        if err := db.createMigrationsTable(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrations table: %w", err)
        }</span>

        // Run migrations
        <span class="cov0" title="0">migrations := []Migration{
                {
                        Version: 1,
                        Name:    "create_initial_tables",
                        Up:      db.createInitialTables,
                },
                {
                        Version: 2,
                        Name:    "migrate_smb_to_storage_roots",
                        Up:      db.migrateSMBToStorageRoots,
                },
        }

        for _, migration := range migrations </span><span class="cov0" title="0">{
                if err := db.runMigration(ctx, migration); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to run migration %s: %w", migration.Name, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Migration represents a database migration
type Migration struct {
        Version int
        Name    string
        Up      func(context.Context) error
}

// createMigrationsTable creates the migrations tracking table
func (db *DB) createMigrationsTable(ctx context.Context) error <span class="cov0" title="0">{
        query := `
                CREATE TABLE IF NOT EXISTS migrations (
                        version INTEGER PRIMARY KEY,
                        name TEXT NOT NULL,
                        applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
        `
        _, err := db.ExecContext(ctx, query)
        return err
}</span>

// runMigration runs a single migration if it hasn't been applied
func (db *DB) runMigration(ctx context.Context, migration Migration) error <span class="cov0" title="0">{
        // Check if migration has already been applied
        var count int
        err := db.QueryRowContext(ctx, "SELECT COUNT(*) FROM migrations WHERE version = ?", migration.Version).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                return nil // Migration already applied
        }</span>

        // Run migration
        <span class="cov0" title="0">if err := migration.Up(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Record migration as applied
        <span class="cov0" title="0">_, err = db.ExecContext(ctx, "INSERT INTO migrations (version, name) VALUES (?, ?)", migration.Version, migration.Name)
        return err</span>
}

// createInitialTables creates the initial database schema
func (db *DB) createInitialTables(ctx context.Context) error <span class="cov0" title="0">{
        queries := []string{
                // Storage roots table (replaces smb_roots)
                `CREATE TABLE IF NOT EXISTS storage_roots (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL UNIQUE,
                        protocol TEXT NOT NULL,
                        host TEXT,
                        port INTEGER,
                        path TEXT,
                        username TEXT,
                        password TEXT,
                        domain TEXT,
                        mount_point TEXT,
                        options TEXT,
                        url TEXT,
                        enabled BOOLEAN DEFAULT 1,
                        max_depth INTEGER DEFAULT 10,
                        enable_duplicate_detection BOOLEAN DEFAULT 1,
                        enable_metadata_extraction BOOLEAN DEFAULT 1,
                        include_patterns TEXT,
                        exclude_patterns TEXT,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        last_scan_at DATETIME
                )`,

                // Files table
                `CREATE TABLE IF NOT EXISTS files (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        storage_root_id INTEGER NOT NULL,
                        path TEXT NOT NULL,
                        name TEXT NOT NULL,
                        extension TEXT,
                        mime_type TEXT,
                        file_type TEXT,
                        size INTEGER NOT NULL,
                        is_directory BOOLEAN DEFAULT 0,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        modified_at DATETIME NOT NULL,
                        accessed_at DATETIME,
                        deleted BOOLEAN DEFAULT 0,
                        deleted_at DATETIME,
                        last_scan_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        last_verified_at DATETIME,
                        md5 TEXT,
                        sha256 TEXT,
                        sha1 TEXT,
                        blake3 TEXT,
                        quick_hash TEXT,
                        is_duplicate BOOLEAN DEFAULT 0,
                        duplicate_group_id INTEGER,
                        parent_id INTEGER,
                        FOREIGN KEY (storage_root_id) REFERENCES storage_roots(id),
                        FOREIGN KEY (parent_id) REFERENCES files(id),
                        FOREIGN KEY (duplicate_group_id) REFERENCES duplicate_groups(id)
                )`,

                // File metadata table
                `CREATE TABLE IF NOT EXISTS file_metadata (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        file_id INTEGER NOT NULL,
                        key TEXT NOT NULL,
                        value TEXT NOT NULL,
                        data_type TEXT DEFAULT 'string',
                        FOREIGN KEY (file_id) REFERENCES files(id) ON DELETE CASCADE
                )`,

                // Duplicate groups table
                `CREATE TABLE IF NOT EXISTS duplicate_groups (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        file_count INTEGER DEFAULT 0,
                        total_size INTEGER DEFAULT 0,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,

                // Virtual paths table
                `CREATE TABLE IF NOT EXISTS virtual_paths (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        path TEXT NOT NULL UNIQUE,
                        target_type TEXT NOT NULL,
                        target_id INTEGER NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,

                // Scan history table
                `CREATE TABLE IF NOT EXISTS scan_history (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        storage_root_id INTEGER NOT NULL,
                        scan_type TEXT NOT NULL,
                        status TEXT NOT NULL,
                        start_time DATETIME NOT NULL,
                        end_time DATETIME,
                        files_processed INTEGER DEFAULT 0,
                        files_added INTEGER DEFAULT 0,
                        files_updated INTEGER DEFAULT 0,
                        files_deleted INTEGER DEFAULT 0,
                        error_count INTEGER DEFAULT 0,
                        error_message TEXT,
                        FOREIGN KEY (storage_root_id) REFERENCES storage_roots(id)
                )`,

                // Indexes for performance
                `CREATE INDEX IF NOT EXISTS idx_files_storage_root_path ON files(storage_root_id, path)`,
                `CREATE INDEX IF NOT EXISTS idx_files_parent_id ON files(parent_id)`,
                `CREATE INDEX IF NOT EXISTS idx_files_duplicate_group ON files(duplicate_group_id)`,
                `CREATE INDEX IF NOT EXISTS idx_files_deleted ON files(deleted)`,
                `CREATE INDEX IF NOT EXISTS idx_file_metadata_file_id ON file_metadata(file_id)`,
                `CREATE INDEX IF NOT EXISTS idx_scan_history_storage_root ON scan_history(storage_root_id)`,
        }

        for _, query := range queries </span><span class="cov0" title="0">{
                if _, err := db.ExecContext(ctx, query); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute query: %s, error: %w", query, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// migrateSMBToStorageRoots migrates existing SMB root data to the new storage roots format
func (db *DB) migrateSMBToStorageRoots(ctx context.Context) error <span class="cov0" title="0">{
        // Check if old smb_roots table exists
        var exists int
        err := db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='smb_roots'").Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if exists == 0 </span><span class="cov0" title="0">{
                return nil // No old table to migrate
        }</span>

        // Migrate SMB roots to storage roots
        <span class="cov0" title="0">query := `
                INSERT INTO storage_roots (
                        name, protocol, host, port, path, username, password, domain,
                        enabled, max_depth, enable_duplicate_detection, enable_metadata_extraction,
                        include_patterns, exclude_patterns, created_at, updated_at, last_scan_at
                )
                SELECT
                        name, 'smb', host, port, share, username, password, domain,
                        enabled, max_depth, enable_duplicate_detection, enable_metadata_extraction,
                        include_patterns, exclude_patterns, created_at, updated_at, last_scan_at
                FROM smb_roots
                WHERE NOT EXISTS (
                        SELECT 1 FROM storage_roots WHERE name = smb_roots.name AND protocol = 'smb'
                )
        `

        if _, err := db.ExecContext(ctx, query); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to migrate SMB roots: %w", err)
        }</span>

        // Update files table to use storage_root_id instead of smb_root_id
        <span class="cov0" title="0">updateQuery := `
                UPDATE files
                SET storage_root_id = (
                        SELECT sr.id
                        FROM storage_roots sr
                        JOIN smb_roots old_sr ON sr.name = old_sr.name AND sr.protocol = 'smb'
                        WHERE files.smb_root_id = old_sr.id
                )
                WHERE storage_root_id IS NULL OR storage_root_id = 0
        `

        if _, err := db.ExecContext(ctx, updateQuery); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update files storage_root_id: %w", err)
        }</span>

        // Update scan_history table
        <span class="cov0" title="0">scanUpdateQuery := `
                UPDATE scan_history
                SET storage_root_id = (
                        SELECT sr.id
                        FROM storage_roots sr
                        JOIN smb_roots old_sr ON sr.name = old_sr.name AND sr.protocol = 'smb'
                        WHERE scan_history.smb_root_id = old_sr.id
                )
                WHERE storage_root_id IS NULL OR storage_root_id = 0
        `

        if _, err := db.ExecContext(ctx, scanUpdateQuery); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update scan_history storage_root_id: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package filesystem

import (
        "fmt"
)

// DefaultClientFactory implements ClientFactory for all supported protocols
type DefaultClientFactory struct{}

// NewDefaultClientFactory creates a new default client factory
func NewDefaultClientFactory() *DefaultClientFactory <span class="cov3" title="2">{
        return &amp;DefaultClientFactory{}
}</span>

// CreateClient creates a filesystem client based on the storage configuration
func (f *DefaultClientFactory) CreateClient(config *StorageConfig) (FileSystemClient, error) <span class="cov6" title="6">{
        switch config.Protocol </span>{
        case "smb":<span class="cov1" title="1">
                smbConfig := &amp;SmbConfig{
                        Host:     getStringSetting(config.Settings, "host", ""),
                        Port:     getIntSetting(config.Settings, "port", 445),
                        Share:    getStringSetting(config.Settings, "share", ""),
                        Username: getStringSetting(config.Settings, "username", ""),
                        Password: getStringSetting(config.Settings, "password", ""),
                        Domain:   getStringSetting(config.Settings, "domain", "WORKGROUP"),
                }
                return NewSmbClient(smbConfig), nil</span>

        case "ftp":<span class="cov1" title="1">
                ftpConfig := &amp;FTPConfig{
                        Host:     getStringSetting(config.Settings, "host", ""),
                        Port:     getIntSetting(config.Settings, "port", 21),
                        Username: getStringSetting(config.Settings, "username", ""),
                        Password: getStringSetting(config.Settings, "password", ""),
                        Path:     getStringSetting(config.Settings, "path", ""),
                }
                return NewFTPClient(ftpConfig), nil</span>

        case "nfs":<span class="cov1" title="1">
                nfsConfig := &amp;NFSConfig{
                        Host:       getStringSetting(config.Settings, "host", ""),
                        Path:       getStringSetting(config.Settings, "path", ""),
                        MountPoint: getStringSetting(config.Settings, "mount_point", ""),
                        Options:    getStringSetting(config.Settings, "options", "vers=3"),
                }
                client, err := NewNFSClient(*nfsConfig)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to create NFS client: %w", err)
                }</span>
                <span class="cov0" title="0">return client, nil</span>

        case "webdav":<span class="cov1" title="1">
                webdavConfig := &amp;WebDAVConfig{
                        URL:      getStringSetting(config.Settings, "url", ""),
                        Username: getStringSetting(config.Settings, "username", ""),
                        Password: getStringSetting(config.Settings, "password", ""),
                        Path:     getStringSetting(config.Settings, "path", ""),
                }
                return NewWebDAVClient(webdavConfig), nil</span>

        case "local":<span class="cov1" title="1">
                localConfig := &amp;LocalConfig{
                        BasePath: getStringSetting(config.Settings, "base_path", ""),
                }
                return NewLocalClient(localConfig), nil</span>

        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported protocol: %s", config.Protocol)</span>
        }
}

// SupportedProtocols returns the list of supported protocols
func (f *DefaultClientFactory) SupportedProtocols() []string <span class="cov1" title="1">{
        return []string{"smb", "ftp", "nfs", "webdav", "local"}
}</span>

// Helper functions to extract settings
func getStringSetting(settings map[string]interface{}, key, defaultValue string) string <span class="cov10" title="18">{
        if val, ok := settings[key]; ok </span><span class="cov10" title="18">{
                if str, ok := val.(string); ok </span><span class="cov10" title="18">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getIntSetting(settings map[string]interface{}, key string, defaultValue int) int <span class="cov3" title="2">{
        if val, ok := settings[key]; ok </span><span class="cov3" title="2">{
                if num, ok := val.(int); ok </span><span class="cov3" title="2">{
                        return num
                }</span>
                <span class="cov0" title="0">if floatNum, ok := val.(float64); ok </span><span class="cov0" title="0">{
                        return int(floatNum)
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package filesystem

import (
        "context"
        "fmt"
        "io"
        "path/filepath"
        "time"

        "github.com/jlaffaye/ftp"
)

// FTPConfig contains FTP connection configuration
type FTPConfig struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Username string `json:"username"`
        Password string `json:"password"`
        Path     string `json:"path"` // Base path on the FTP server
}

// FTPClient implements FileSystemClient for FTP protocol
type FTPClient struct {
        config    *FTPConfig
        client    *ftp.ServerConn
        connected bool
}

// NewFTPClient creates a new FTP client
func NewFTPClient(config *FTPConfig) *FTPClient <span class="cov8" title="1">{
        return &amp;FTPClient{
                config:    config,
                connected: false,
        }
}</span>

// Connect establishes the FTP connection
func (c *FTPClient) Connect(ctx context.Context) error <span class="cov0" title="0">{
        addr := fmt.Sprintf("%s:%d", c.config.Host, c.config.Port)

        client, err := ftp.Dial(addr, ftp.DialWithTimeout(30*time.Second))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to FTP server: %w", err)
        }</span>

        <span class="cov0" title="0">err = client.Login(c.config.Username, c.config.Password)
        if err != nil </span><span class="cov0" title="0">{
                client.Quit()
                return fmt.Errorf("failed to login to FTP server: %w", err)
        }</span>

        // Change to base directory if specified
        <span class="cov0" title="0">if c.config.Path != "" </span><span class="cov0" title="0">{
                err = client.ChangeDir(c.config.Path)
                if err != nil </span><span class="cov0" title="0">{
                        client.Quit()
                        return fmt.Errorf("failed to change to base directory %s: %w", c.config.Path, err)
                }</span>
        }

        <span class="cov0" title="0">c.client = client
        c.connected = true
        return nil</span>
}

// Disconnect closes the FTP connection
func (c *FTPClient) Disconnect(ctx context.Context) error <span class="cov0" title="0">{
        if c.client != nil </span><span class="cov0" title="0">{
                err := c.client.Quit()
                c.client = nil
                c.connected = false
                return err
        }</span>
        <span class="cov0" title="0">c.connected = false
        return nil</span>
}

// IsConnected returns true if the client is connected
func (c *FTPClient) IsConnected() bool <span class="cov0" title="0">{
        return c.connected &amp;&amp; c.client != nil
}</span>

// TestConnection tests the FTP connection
func (c *FTPClient) TestConnection(ctx context.Context) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">_, err := c.client.CurrentDir()
        return err</span>
}

// resolvePath resolves a relative path within the FTP base directory
func (c *FTPClient) resolvePath(path string) string <span class="cov0" title="0">{
        if c.config.Path != "" </span><span class="cov0" title="0">{
                return c.config.Path + "/" + path
        }</span>
        <span class="cov0" title="0">return path</span>
}

// ReadFile reads a file from the FTP server
func (c *FTPClient) ReadFile(ctx context.Context, path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        resp, err := c.client.Retr(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to retrieve FTP file %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

// WriteFile writes a file to the FTP server
func (c *FTPClient) WriteFile(ctx context.Context, path string, data io.Reader) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)

        // Ensure the directory exists
        dir := filepath.Dir(fullPath)
        if dir != "." &amp;&amp; dir != "/" </span><span class="cov0" title="0">{
                err := c.client.MakeDir(dir)
                if err != nil </span>{<span class="cov0" title="0">
                        // Ignore error if directory already exists
                        // FTP doesn't have a standard way to check if directory exists
                }</span>
        }

        <span class="cov0" title="0">err := c.client.Stor(fullPath, data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store FTP file %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetFileInfo gets information about a file
func (c *FTPClient) GetFileInfo(ctx context.Context, path string) (*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)

        // Try to get file size
        size, err := c.client.FileSize(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get FTP file info %s: %w", fullPath, err)
        }</span>

        // Get modification time - fallback since ModTime might not be available
        <span class="cov0" title="0">modTime := time.Now() // Default fallback

        // Check if it's a directory by trying to list it
        _, err = c.client.List(fullPath)
        isDir := err == nil

        return &amp;FileInfo{
                Name:    filepath.Base(path),
                Size:    size,
                ModTime: modTime,
                IsDir:   isDir,
                Mode:    0644, // Default mode, FTP doesn't provide mode info
                Path:    path,
        }, nil</span>
}

// ListDirectory lists files in a directory
func (c *FTPClient) ListDirectory(ctx context.Context, path string) ([]*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)

        entries, err := c.client.List(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list FTP directory %s: %w", fullPath, err)
        }</span>

        <span class="cov0" title="0">var files []*FileInfo
        for _, entry := range entries </span><span class="cov0" title="0">{
                files = append(files, &amp;FileInfo{
                        Name:    entry.Name,
                        Size:    int64(entry.Size),
                        ModTime: entry.Time,
                        IsDir:   entry.Type == ftp.EntryTypeFolder,
                        Mode:    0644, // Default mode
                        Path:    path + "/" + entry.Name,
                })
        }</span>

        <span class="cov0" title="0">return files, nil</span>
}

// FileExists checks if a file exists
func (c *FTPClient) FileExists(ctx context.Context, path string) (bool, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return false, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)

        // Try to get file size - if it succeeds, file exists
        _, err := c.client.FileSize(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                // Try to list the file's directory to see if it exists
                dir := filepath.Dir(fullPath)
                name := filepath.Base(fullPath)
                entries, err := c.client.List(dir)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to check FTP file existence %s: %w", fullPath, err)
                }</span>
                <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                        if entry.Name == name </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                }
                <span class="cov0" title="0">return false, nil</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// CreateDirectory creates a directory
func (c *FTPClient) CreateDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := c.client.MakeDir(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create FTP directory %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteDirectory deletes a directory
func (c *FTPClient) DeleteDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := c.client.RemoveDir(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete FTP directory %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteFile deletes a file
func (c *FTPClient) DeleteFile(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := c.client.Delete(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete FTP file %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CopyFile copies a file on the FTP server
func (c *FTPClient) CopyFile(ctx context.Context, srcPath, dstPath string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        // FTP doesn't have a native copy command, so we need to download and upload
        <span class="cov0" title="0">srcFullPath := c.resolvePath(srcPath)
        dstFullPath := c.resolvePath(dstPath)

        // Read source file
        resp, err := c.client.Retr(srcFullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retrieve source file %s: %w", srcFullPath, err)
        }</span>
        <span class="cov0" title="0">defer resp.Close()

        // Ensure destination directory exists
        dstDir := filepath.Dir(dstFullPath)
        if dstDir != "." &amp;&amp; dstDir != "/" </span><span class="cov0" title="0">{
                c.client.MakeDir(dstDir) // Ignore error if directory exists
        }</span>

        // Write to destination
        <span class="cov0" title="0">err = c.client.Stor(dstFullPath, resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store destination file %s: %w", dstFullPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetProtocol returns the protocol name
func (c *FTPClient) GetProtocol() string <span class="cov8" title="1">{
        return "ftp"
}</span>

// GetConfig returns the FTP configuration
func (c *FTPClient) GetConfig() interface{} <span class="cov0" title="0">{
        return c.config
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package filesystem

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
)

// LocalConfig contains local filesystem configuration
type LocalConfig struct {
        BasePath string `json:"base_path"` // Base directory path
}

// LocalClient implements FileSystemClient for local filesystem
type LocalClient struct {
        config    *LocalConfig
        basePath  string
        connected bool
}

// NewLocalClient creates a new local filesystem client
func NewLocalClient(config *LocalConfig) *LocalClient <span class="cov10" title="9">{
        return &amp;LocalClient{
                config:    config,
                basePath:  config.BasePath,
                connected: false,
        }
}</span>

// Connect establishes the connection (for local filesystem, this just validates the path)
func (c *LocalClient) Connect(ctx context.Context) error <span class="cov8" title="7">{
        // Validate that the base path exists and is accessible
        info, err := os.Stat(c.basePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to access base path %s: %w", c.basePath, err)
        }</span>
        <span class="cov8" title="7">if !info.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("base path %s is not a directory", c.basePath)
        }</span>
        <span class="cov8" title="7">c.connected = true
        return nil</span>
}

// Disconnect closes the connection (no-op for local filesystem)
func (c *LocalClient) Disconnect(ctx context.Context) error <span class="cov8" title="7">{
        c.connected = false
        return nil
}</span>

// IsConnected returns true if the client is connected
func (c *LocalClient) IsConnected() bool <span class="cov10" title="9">{
        return c.connected
}</span>

// TestConnection tests the connection
func (c *LocalClient) TestConnection(ctx context.Context) error <span class="cov1" title="1">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov1" title="1">_, err := os.Stat(c.basePath)
        return err</span>
}

// resolvePath resolves a relative path to an absolute path within the base directory
func (c *LocalClient) resolvePath(path string) string <span class="cov8" title="6">{
        // Clean the path and prevent directory traversal
        cleanPath := filepath.Clean(path)
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                // Prevent directory traversal attacks
                cleanPath = strings.ReplaceAll(cleanPath, "..", "")
        }</span>
        <span class="cov8" title="6">return filepath.Join(c.basePath, cleanPath)</span>
}

// ReadFile reads a file from the local filesystem
func (c *LocalClient) ReadFile(ctx context.Context, path string) (io.ReadCloser, error) <span class="cov1" title="1">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov1" title="1">fullPath := c.resolvePath(path)
        file, err := os.Open(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open local file %s: %w", fullPath, err)
        }</span>
        <span class="cov1" title="1">return file, nil</span>
}

// WriteFile writes a file to the local filesystem
func (c *LocalClient) WriteFile(ctx context.Context, path string, data io.Reader) error <span class="cov1" title="1">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov1" title="1">fullPath := c.resolvePath(path)

        // Ensure the directory exists
        dir := filepath.Dir(fullPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory %s: %w", dir, err)
        }</span>

        <span class="cov1" title="1">file, err := os.Create(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local file %s: %w", fullPath, err)
        }</span>
        <span class="cov1" title="1">defer file.Close()

        _, err = io.Copy(file, data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write local file %s: %w", fullPath, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetFileInfo gets information about a file
func (c *LocalClient) GetFileInfo(ctx context.Context, path string) (*FileInfo, error) <span class="cov1" title="1">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov1" title="1">fullPath := c.resolvePath(path)
        stat, err := os.Stat(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat local file %s: %w", fullPath, err)
        }</span>

        <span class="cov1" title="1">return &amp;FileInfo{
                Name:    stat.Name(),
                Size:    stat.Size(),
                ModTime: stat.ModTime(),
                IsDir:   stat.IsDir(),
                Mode:    stat.Mode(),
                Path:    path,
        }, nil</span>
}

// ListDirectory lists files in a directory
func (c *LocalClient) ListDirectory(ctx context.Context, path string) ([]*FileInfo, error) <span class="cov1" title="1">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov1" title="1">fullPath := c.resolvePath(path)
        entries, err := os.ReadDir(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list local directory %s: %w", fullPath, err)
        }</span>

        <span class="cov1" title="1">var files []*FileInfo
        for _, entry := range entries </span><span class="cov3" title="2">{
                info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip files we can't get info for
                }
                <span class="cov3" title="2">files = append(files, &amp;FileInfo{
                        Name:    entry.Name(),
                        Size:    info.Size(),
                        ModTime: info.ModTime(),
                        IsDir:   entry.IsDir(),
                        Mode:    info.Mode(),
                        Path:    filepath.Join(path, entry.Name()),
                })</span>
        }

        <span class="cov1" title="1">return files, nil</span>
}

// FileExists checks if a file exists
func (c *LocalClient) FileExists(ctx context.Context, path string) (bool, error) <span class="cov3" title="2">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return false, fmt.Errorf("not connected")
        }</span>
        <span class="cov3" title="2">fullPath := c.resolvePath(path)
        _, err := os.Stat(fullPath)
        if err != nil </span><span class="cov1" title="1">{
                if os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check local file existence %s: %w", fullPath, err)</span>
        }
        <span class="cov1" title="1">return true, nil</span>
}

// CreateDirectory creates a directory
func (c *LocalClient) CreateDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := os.MkdirAll(fullPath, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local directory %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteDirectory deletes a directory
func (c *LocalClient) DeleteDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := os.RemoveAll(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete local directory %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteFile deletes a file
func (c *LocalClient) DeleteFile(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">fullPath := c.resolvePath(path)
        err := os.Remove(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete local file %s: %w", fullPath, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CopyFile copies a file within the local filesystem
func (c *LocalClient) CopyFile(ctx context.Context, srcPath, dstPath string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">srcFullPath := c.resolvePath(srcPath)
        dstFullPath := c.resolvePath(dstPath)

        // Ensure destination directory exists
        dstDir := filepath.Dir(dstFullPath)
        if err := os.MkdirAll(dstDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination directory %s: %w", dstDir, err)
        }</span>

        // Open source file
        <span class="cov0" title="0">srcFile, err := os.Open(srcFullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file %s: %w", srcFullPath, err)
        }</span>
        <span class="cov0" title="0">defer srcFile.Close()

        // Create destination file
        dstFile, err := os.Create(dstFullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination file %s: %w", dstFullPath, err)
        }</span>
        <span class="cov0" title="0">defer dstFile.Close()

        // Copy data
        _, err = io.Copy(dstFile, srcFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file from %s to %s: %w", srcFullPath, dstFullPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetProtocol returns the protocol name
func (c *LocalClient) GetProtocol() string <span class="cov3" title="2">{
        return "local"
}</span>

// GetConfig returns the local configuration
func (c *LocalClient) GetConfig() interface{} <span class="cov0" title="0">{
        return c.config
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">//go:build darwin
// +build darwin

package filesystem

import (
        "context"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "time"
)

// NFSConfig contains NFS connection configuration
type NFSConfig struct {
        Host       string `json:"host"`
        Path       string `json:"path"`        // Export path on NFS server
        MountPoint string `json:"mount_point"` // Local mount point
        Options    string `json:"options"`     // Mount options
}

// NFSClient for macOS using mount command and basic file operations
type NFSClient struct {
        config   NFSConfig
        mountPoint string
        connected bool
        mounted   bool
}

func NewNFSClient(config NFSConfig) (*NFSClient, error) <span class="cov8" title="1">{
        if config.MountPoint == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mount point is required")
        }</span>
        
        // Create mount point directory if it doesn't exist
        <span class="cov8" title="1">if err := os.MkdirAll(config.MountPoint, 0755); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create mount point: %w", err)
        }</span>
        
        <span class="cov0" title="0">return &amp;NFSClient{
                config:     config,
                mountPoint: config.MountPoint,
        }, nil</span>
}

func (c *NFSClient) Connect(ctx context.Context) error <span class="cov0" title="0">{
        // Check if already mounted
        if c.mounted &amp;&amp; c.connected </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Build mount command for macOS
        <span class="cov0" title="0">options := c.config.Options
        if options == "" </span><span class="cov0" title="0">{
                options = "resvport,soft,intr,tcp"
        }</span>
        
        // Build mount source path
        <span class="cov0" title="0">source := fmt.Sprintf("%s:%s", c.config.Host, c.config.Path)
        
        // Create mount command
        args := []string{
                "-t", "nfs",
                "-o", options,
                source,
                c.mountPoint,
        }
        
        cmd := exec.CommandContext(ctx, "mount", args...)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NFS mount failed: %w, output: %s", err, string(output))
        }</span>
        
        // Verify mount is active
        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond) // Small delay for mount to settle
        
        if _, err := os.Stat(c.mountPoint); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mount point not accessible after mount: %w", err)
        }</span>
        
        <span class="cov0" title="0">c.mounted = true
        c.connected = true
        
        return nil</span>
}

func (c *NFSClient) Disconnect(ctx context.Context) error <span class="cov0" title="0">{
        if !c.mounted </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Unmount using system command
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "umount", c.mountPoint)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                // Try forced unmount if normal unmount fails
                forceCmd := exec.CommandContext(ctx, "umount", "-f", c.mountPoint)
                forceOutput, forceErr := forceCmd.CombinedOutput()
                if forceErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unmount failed: %w (force: %w), output: %s, force output: %s", 
                                err, forceErr, string(output), string(forceOutput))
                }</span>
        }
        
        <span class="cov0" title="0">c.connected = false
        c.mounted = false
        return nil</span>
}

func (c *NFSClient) TestConnection(ctx context.Context) error <span class="cov0" title="0">{
        if !c.connected || !c.mounted </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected or not mounted")
        }</span>
        
        // Test by checking mount point accessibility
        <span class="cov0" title="0">info, err := os.Stat(c.mountPoint)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mount point not accessible: %w", err)
        }</span>
        
        <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("mount point is not a directory")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func (c *NFSClient) ListDirectory(ctx context.Context, path string) ([]*FileInfo, error) <span class="cov0" title="0">{
        if !c.connected </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        
        <span class="cov0" title="0">fullPath := filepath.Join(c.mountPoint, path)
        
        entries, err := os.ReadDir(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read directory: %w", err)
        }</span>
        
        <span class="cov0" title="0">var files []*FileInfo
        for _, entry := range entries </span><span class="cov0" title="0">{
                info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip entries with permission errors
                }
                
                <span class="cov0" title="0">fileInfo := &amp;FileInfo{
                        Name:    entry.Name(),
                        Size:    info.Size(),
                        ModTime: info.ModTime(),
                        IsDir:   info.IsDir(),
                        Path:    path,
                }
                files = append(files, fileInfo)</span>
        }
        
        <span class="cov0" title="0">return files, nil</span>
}

func (c *NFSClient) GetFileInfo(ctx context.Context, path string) (*FileInfo, error) <span class="cov0" title="0">{
        if !c.connected </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        
        <span class="cov0" title="0">fullPath := filepath.Join(c.mountPoint, path)
        
        info, err := os.Stat(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file info: %w", err)
        }</span>
        
        <span class="cov0" title="0">return &amp;FileInfo{
                Name:    filepath.Base(path),
                Size:    info.Size(),
                ModTime: info.ModTime(),
                IsDir:   info.IsDir(),
                Path:    path,
        }, nil</span>
}

func (c *NFSClient) CreateDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.connected </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        
        <span class="cov0" title="0">fullPath := filepath.Join(c.mountPoint, path)
        return os.MkdirAll(fullPath, 0755)</span>
}

func (c *NFSClient) DeleteDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.connected </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        
        <span class="cov0" title="0">fullPath := filepath.Join(c.mountPoint, path)
        return os.RemoveAll(fullPath)</span>
}

func (c *NFSClient) DeleteFile(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.connected </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        
        <span class="cov0" title="0">fullPath := filepath.Join(c.mountPoint, path)
        return os.Remove(fullPath)</span>
}

func (c *NFSClient) CopyFile(ctx context.Context, src, dst string) error <span class="cov0" title="0">{
        if !c.connected </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        
        <span class="cov0" title="0">srcPath := filepath.Join(c.mountPoint, src)
        dstPath := filepath.Join(c.mountPoint, dst)
        
        // Simple file copy using system commands for better performance
        cmd := exec.CommandContext(ctx, "cp", srcPath, dstPath)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("copy failed: %w, output: %s", err, string(output))
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func (c *NFSClient) MoveFile(ctx context.Context, src, dst string) error <span class="cov0" title="0">{
        if !c.connected </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        
        <span class="cov0" title="0">srcPath := filepath.Join(c.mountPoint, src)
        dstPath := filepath.Join(c.mountPoint, dst)
        
        // Use system move command
        cmd := exec.CommandContext(ctx, "mv", srcPath, dstPath)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("move failed: %w, output: %s", err, string(output))
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func (c *NFSClient) ReadFile(ctx context.Context, path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        if !c.connected </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        
        <span class="cov0" title="0">fullPath := filepath.Join(c.mountPoint, path)
        return os.Open(fullPath)</span>
}

func (c *NFSClient) WriteFile(ctx context.Context, path string, data io.Reader) error <span class="cov0" title="0">{
        if !c.connected </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        
        <span class="cov0" title="0">fullPath := filepath.Join(c.mountPoint, path)
        file, err := os.Create(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()
        
        _, err = io.Copy(file, data)
        return err</span>
}

func (c *NFSClient) FileExists(ctx context.Context, path string) (bool, error) <span class="cov0" title="0">{
        if !c.connected </span><span class="cov0" title="0">{
                return false, fmt.Errorf("not connected")
        }</span>
        
        <span class="cov0" title="0">fullPath := filepath.Join(c.mountPoint, path)
        _, err := os.Stat(fullPath)
        if err == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return false, err</span>
}

func (c *NFSClient) IsConnected() bool <span class="cov0" title="0">{
        return c.connected &amp;&amp; c.mounted
}</span>

func (c *NFSClient) GetRootPath() string <span class="cov0" title="0">{
        return c.mountPoint
}</span>

func (c *NFSClient) GetProtocol() string <span class="cov0" title="0">{
        return "nfs"
}</span>

func (c *NFSClient) GetConfig() interface{} <span class="cov0" title="0">{
        return c.config
}</pre>
		
		<pre class="file" id="file7" style="display: none">package filesystem

import (
        "context"
        "fmt"
        "io"
        "net"

        "github.com/hirochachacha/go-smb2"
)

// SmbConfig contains SMB connection configuration
type SmbConfig struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Share    string `json:"share"`
        Username string `json:"username"`
        Password string `json:"password"`
        Domain   string `json:"domain"`
}

// SmbClient implements FileSystemClient for SMB protocol
type SmbClient struct {
        conn    net.Conn
        session *smb2.Session
        share   *smb2.Share
        config  *SmbConfig
}

// NewSmbClient creates a new SMB client
func NewSmbClient(config *SmbConfig) *SmbClient <span class="cov10" title="4">{
        return &amp;SmbClient{
                config: config,
        }
}</span>

// Connect establishes the SMB connection
func (c *SmbClient) Connect(ctx context.Context) error <span class="cov1" title="1">{
        // Establish TCP connection
        addr := fmt.Sprintf("%s:%d", c.config.Host, c.config.Port)
        conn, err := net.Dial("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to SMB server: %w", err)
        }</span>

        // Create SMB session
        <span class="cov1" title="1">d := &amp;smb2.Dialer{
                Initiator: &amp;smb2.NTLMInitiator{
                        User:     c.config.Username,
                        Password: c.config.Password,
                        Domain:   c.config.Domain,
                },
        }

        session, err := d.Dial(conn)
        if err != nil </span><span class="cov1" title="1">{
                conn.Close()
                return fmt.Errorf("failed to create SMB session: %w", err)
        }</span>

        // Mount share
        <span class="cov0" title="0">share, err := session.Mount(c.config.Share)
        if err != nil </span><span class="cov0" title="0">{
                session.Logoff()
                conn.Close()
                return fmt.Errorf("failed to mount SMB share: %w", err)
        }</span>

        <span class="cov0" title="0">c.conn = conn
        c.session = session
        c.share = share
        return nil</span>
}

// Disconnect closes the SMB connection
func (c *SmbClient) Disconnect(ctx context.Context) error <span class="cov0" title="0">{
        var errs []error

        if c.share != nil </span><span class="cov0" title="0">{
                if err := c.share.Umount(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to unmount share: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if c.session != nil </span><span class="cov0" title="0">{
                if err := c.session.Logoff(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to logoff session: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if c.conn != nil </span><span class="cov0" title="0">{
                if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to close connection: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors closing SMB client: %v", errs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsConnected returns true if the client is connected
func (c *SmbClient) IsConnected() bool <span class="cov8" title="3">{
        return c.share != nil &amp;&amp; c.session != nil &amp;&amp; c.conn != nil
}</span>

// TestConnection tests the SMB connection
func (c *SmbClient) TestConnection(ctx context.Context) error <span class="cov1" title="1">{
        if !c.IsConnected() </span><span class="cov1" title="1">{
                return fmt.Errorf("not connected")
        }</span>
        // Try to list the root directory
        <span class="cov0" title="0">_, err := c.share.ReadDir(".")
        return err</span>
}

// ReadFile reads a file from the SMB share
func (c *SmbClient) ReadFile(ctx context.Context, path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">file, err := c.share.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open SMB file %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return file, nil</span>
}

// WriteFile writes a file to the SMB share
func (c *SmbClient) WriteFile(ctx context.Context, path string, data io.Reader) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">file, err := c.share.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create SMB file %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        _, err = io.Copy(file, data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write SMB file %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFileInfo gets information about a file
func (c *SmbClient) GetFileInfo(ctx context.Context, path string) (*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">stat, err := c.share.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat SMB file %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return &amp;FileInfo{
                Name:    stat.Name(),
                Size:    stat.Size(),
                ModTime: stat.ModTime(),
                IsDir:   stat.IsDir(),
                Mode:    stat.Mode(),
                Path:    path,
        }, nil</span>
}

// ListDirectory lists files in a directory
func (c *SmbClient) ListDirectory(ctx context.Context, path string) ([]*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">entries, err := c.share.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list SMB directory %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">var files []*FileInfo
        for _, entry := range entries </span><span class="cov0" title="0">{
                files = append(files, &amp;FileInfo{
                        Name:    entry.Name(),
                        Size:    entry.Size(),
                        ModTime: entry.ModTime(),
                        IsDir:   entry.IsDir(),
                        Mode:    entry.Mode(),
                        Path:    path + "/" + entry.Name(),
                })
        }</span>

        <span class="cov0" title="0">return files, nil</span>
}

// FileExists checks if a file exists
func (c *SmbClient) FileExists(ctx context.Context, path string) (bool, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return false, fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">_, err := c.share.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                if isNotExistError(err) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check SMB file existence %s: %w", path, err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// CreateDirectory creates a directory
func (c *SmbClient) CreateDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">err := c.share.Mkdir(path, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create SMB directory %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteDirectory deletes a directory
func (c *SmbClient) DeleteDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">err := c.share.Remove(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete SMB directory %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteFile deletes a file
func (c *SmbClient) DeleteFile(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">err := c.share.Remove(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete SMB file %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CopyFile copies a file within the SMB share
func (c *SmbClient) CopyFile(ctx context.Context, srcPath, dstPath string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        // Read source file
        <span class="cov0" title="0">srcFile, err := c.share.Open(srcPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file %s: %w", srcPath, err)
        }</span>
        <span class="cov0" title="0">defer srcFile.Close()

        // Create destination file
        dstFile, err := c.share.Create(dstPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination file %s: %w", dstPath, err)
        }</span>
        <span class="cov0" title="0">defer dstFile.Close()

        // Copy data
        _, err = io.Copy(dstFile, srcFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file from %s to %s: %w", srcPath, dstPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetProtocol returns the protocol name
func (c *SmbClient) GetProtocol() string <span class="cov5" title="2">{
        return "smb"
}</span>

// GetConfig returns the SMB configuration
func (c *SmbClient) GetConfig() interface{} <span class="cov0" title="0">{
        return c.config
}</span>

// Helper function to check if error is "file not found"
func isNotExistError(err error) bool <span class="cov0" title="0">{
        // This is a simplified check - in practice you might want to check
        // for specific SMB error codes
        return err != nil &amp;&amp; (err.Error() == "file does not exist" || err.Error() == "no such file or directory")
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package filesystem

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "path/filepath"
        "strconv"
        "strings"
        "time"
)

// WebDAVConfig contains WebDAV connection configuration
type WebDAVConfig struct {
        URL      string `json:"url"`
        Username string `json:"username"`
        Password string `json:"password"`
        Path     string `json:"path"` // Base path on the WebDAV server
}

// WebDAVClient implements FileSystemClient for WebDAV protocol
type WebDAVClient struct {
        config    *WebDAVConfig
        client    *http.Client
        baseURL   *url.URL
        connected bool
}

// NewWebDAVClient creates a new WebDAV client
func NewWebDAVClient(config *WebDAVConfig) *WebDAVClient <span class="cov8" title="1">{
        baseURL, _ := url.Parse(config.URL)
        if config.Path != "" &amp;&amp; config.Path != "/" </span><span class="cov0" title="0">{
                baseURL.Path = config.Path
        }</span>

        <span class="cov8" title="1">return &amp;WebDAVClient{
                config:  config,
                client:  &amp;http.Client{Timeout: 30 * time.Second},
                baseURL: baseURL,
        }</span>
}

// Connect establishes the WebDAV connection
func (c *WebDAVClient) Connect(ctx context.Context) error <span class="cov0" title="0">{
        // Test the connection with a PROPFIND request
        req, err := http.NewRequestWithContext(ctx, "PROPFIND", c.baseURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create PROPFIND request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Depth", "0")

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to WebDAV server: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusMultiStatus &amp;&amp; resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV server returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">c.connected = true
        return nil</span>
}

// Disconnect closes the WebDAV connection
func (c *WebDAVClient) Disconnect(ctx context.Context) error <span class="cov0" title="0">{
        c.connected = false
        return nil
}</span>

// IsConnected returns true if the client is connected
func (c *WebDAVClient) IsConnected() bool <span class="cov0" title="0">{
        return c.connected
}</span>

// TestConnection tests the WebDAV connection
func (c *WebDAVClient) TestConnection(ctx context.Context) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>
        <span class="cov0" title="0">return c.Connect(ctx)</span> // Re-test connection
}

// resolveURL resolves a relative path to a full WebDAV URL
func (c *WebDAVClient) resolveURL(path string) string <span class="cov0" title="0">{
        // Clean the path and prevent directory traversal
        cleanPath := filepath.Clean(path)
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                // Prevent directory traversal attacks
                cleanPath = strings.ReplaceAll(cleanPath, "..", "")
        }</span>

        <span class="cov0" title="0">u := *c.baseURL
        u.Path = filepath.Join(u.Path, cleanPath)
        return u.String()</span>
}

// ReadFile reads a file from the WebDAV server
func (c *WebDAVClient) ReadFile(ctx context.Context, path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "GET", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GET request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to retrieve WebDAV file %s: %w", fullURL, err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                resp.Body.Close()
                return nil, fmt.Errorf("WebDAV server returned status %d for file %s", resp.StatusCode, fullURL)
        }</span>

        <span class="cov0" title="0">return resp.Body, nil</span>
}

// WriteFile writes a file to the WebDAV server
func (c *WebDAVClient) WriteFile(ctx context.Context, path string, data io.Reader) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "PUT", fullURL, data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create PUT request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload WebDAV file %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV server returned status %d for file %s", resp.StatusCode, fullURL)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFileInfo gets information about a file
func (c *WebDAVClient) GetFileInfo(ctx context.Context, path string) (*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "HEAD", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HEAD request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get WebDAV file info %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("WebDAV server returned status %d for file %s", resp.StatusCode, fullURL)
        }</span>

        // Parse content length
        <span class="cov0" title="0">size := int64(0)
        if cl := resp.Header.Get("Content-Length"); cl != "" </span><span class="cov0" title="0">{
                if s, err := strconv.ParseInt(cl, 10, 64); err == nil </span><span class="cov0" title="0">{
                        size = s
                }</span>
        }

        // Parse last modified
        <span class="cov0" title="0">modTime := time.Now()
        if lm := resp.Header.Get("Last-Modified"); lm != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse(time.RFC1123, lm); err == nil </span><span class="cov0" title="0">{
                        modTime = t
                }</span>
        }

        // Check if it's a directory (simplified check)
        <span class="cov0" title="0">isDir := strings.HasSuffix(path, "/") || resp.Header.Get("Content-Type") == "httpd/unix-directory"

        return &amp;FileInfo{
                Name:    filepath.Base(path),
                Size:    size,
                ModTime: modTime,
                IsDir:   isDir,
                Mode:    0644, // Default mode
                Path:    path,
        }, nil</span>
}

// ListDirectory lists files in a directory
func (c *WebDAVClient) ListDirectory(ctx context.Context, path string) ([]*FileInfo, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "PROPFIND", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create PROPFIND request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Depth", "1")

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list WebDAV directory %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusMultiStatus </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("WebDAV server returned status %d for directory %s", resp.StatusCode, fullURL)
        }</span>

        // Parse XML response (simplified - in production you'd use proper XML parsing)
        // For now, return empty list as PROPFIND parsing is complex
        <span class="cov0" title="0">return []*FileInfo{}, nil</span>
}

// FileExists checks if a file exists
func (c *WebDAVClient) FileExists(ctx context.Context, path string) (bool, error) <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return false, fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "HEAD", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to create HEAD request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check WebDAV file existence %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        return resp.StatusCode == http.StatusOK, nil</span>
}

// CreateDirectory creates a directory
func (c *WebDAVClient) CreateDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "MKCOL", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MKCOL request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create WebDAV directory %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV server returned status %d for directory %s", resp.StatusCode, fullURL)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteDirectory deletes a directory
func (c *WebDAVClient) DeleteDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "DELETE", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create DELETE request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete WebDAV directory %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV server returned status %d for directory %s", resp.StatusCode, fullURL)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteFile deletes a file
func (c *WebDAVClient) DeleteFile(ctx context.Context, path string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">fullURL := c.resolveURL(path)
        req, err := http.NewRequestWithContext(ctx, "DELETE", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create DELETE request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete WebDAV file %s: %w", fullURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV server returned status %d for file %s", resp.StatusCode, fullURL)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CopyFile copies a file on the WebDAV server
func (c *WebDAVClient) CopyFile(ctx context.Context, srcPath, dstPath string) error <span class="cov0" title="0">{
        if !c.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">srcURL := c.resolveURL(srcPath)
        dstURL := c.resolveURL(dstPath)

        req, err := http.NewRequestWithContext(ctx, "COPY", srcURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create COPY request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.config.Username != "" </span><span class="cov0" title="0">{
                req.SetBasicAuth(c.config.Username, c.config.Password)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Destination", dstURL)

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy WebDAV file from %s to %s: %w", srcURL, dstURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV server returned status %d for copy operation", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetProtocol returns the protocol name
func (c *WebDAVClient) GetProtocol() string <span class="cov8" title="1">{
        return "webdav"
}</span>

// GetConfig returns the WebDAV configuration
func (c *WebDAVClient) GetConfig() interface{} <span class="cov0" title="0">{
        return c.config
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "strings"

        "catalogizer/models"
        "catalogizer/services"
)

type AuthHandler struct {
        authService *services.AuthService
}

func NewAuthHandler(authService *services.AuthService) *AuthHandler <span class="cov10" title="29">{
        return &amp;AuthHandler{
                authService: authService,
        }
}</span>

func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov2" title="2">{
        if r.Method != http.MethodPost </span><span class="cov1" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov1" title="1">var req models.LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">ipAddress := getClientIP(r)
        userAgent := r.Header.Get("User-Agent")

        result, err := h.authService.Login(req, ipAddress, userAgent)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(result)</span>
}

func (h *AuthHandler) RefreshToken(w http.ResponseWriter, r *http.Request) <span class="cov2" title="2">{
        if r.Method != http.MethodPost </span><span class="cov1" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov1" title="1">var req struct {
                RefreshToken string `json:"refresh_token"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">result, err := h.authService.RefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(result)</span>
}

func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) <span class="cov3" title="3">{
        if r.Method != http.MethodPost </span><span class="cov1" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov2" title="2">token := extractToken(r)
        if token == "" </span><span class="cov2" title="2">{
                http.Error(w, "Authorization token required", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">err := h.authService.Logout(token)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Logged out successfully"})</span>
}

func (h *AuthHandler) LogoutAll(w http.ResponseWriter, r *http.Request) <span class="cov2" title="2">{
        if r.Method != http.MethodPost </span><span class="cov1" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov1" title="1">user, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov1" title="1">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">err = h.authService.LogoutAll(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "All sessions terminated"})</span>
}

func (h *AuthHandler) GetCurrentUser(w http.ResponseWriter, r *http.Request) <span class="cov2" title="2">{
        if r.Method != http.MethodGet </span><span class="cov1" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov1" title="1">user, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov1" title="1">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">user.PasswordHash = ""
        user.Salt = ""

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)</span>
}

func (h *AuthHandler) ChangePassword(w http.ResponseWriter, r *http.Request) <span class="cov3" title="3">{
        if r.Method != http.MethodPost </span><span class="cov1" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov2" title="2">user, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov2" title="2">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                CurrentPassword string `json:"current_password"`
                NewPassword     string `json:"new_password"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.authService.ValidatePassword(req.NewPassword); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.authService.ChangePassword(user.ID, req.CurrentPassword, req.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Password changed successfully"})</span>
}

func (h *AuthHandler) GetActiveSessions(w http.ResponseWriter, r *http.Request) <span class="cov2" title="2">{
        if r.Method != http.MethodGet </span><span class="cov1" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov1" title="1">user, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov1" title="1">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">sessions, err := h.authService.GetActiveSessions(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">for i := range sessions </span><span class="cov0" title="0">{
                sessions[i].SessionToken = ""
                sessions[i].RefreshToken = nil
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(sessions)</span>
}

func (h *AuthHandler) DeactivateSession(w http.ResponseWriter, r *http.Request) <span class="cov4" title="4">{
        if r.Method != http.MethodPost </span><span class="cov1" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov3" title="3">_, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov3" title="3">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">sessionIDStr := r.URL.Query().Get("session_id")
        if sessionIDStr == "" </span><span class="cov0" title="0">{
                http.Error(w, "Session ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">sessionID, err := strconv.Atoi(sessionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid session ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.authService.DeactivateSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Session deactivated"})</span>
}

func (h *AuthHandler) ValidateToken(w http.ResponseWriter, r *http.Request) <span class="cov3" title="3">{
        if r.Method != http.MethodPost </span><span class="cov1" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov2" title="2">token := extractToken(r)
        if token == "" </span><span class="cov1" title="1">{
                http.Error(w, "Authorization token required", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov1" title="1">claims, err := h.authService.ValidateToken(token)
        if err != nil </span><span class="cov1" title="1">{
                http.Error(w, "Invalid token", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "valid":      true,
                "user_id":    claims.UserID,
                "username":   claims.Username,
                "role_id":    claims.RoleID,
                "session_id": claims.SessionID,
                "expires_at": claims.ExpiresAt,
        })</span>
}

func (h *AuthHandler) getCurrentUser(r *http.Request) (*models.User, error) <span class="cov6" title="8">{
        token := extractToken(r)
        if token == "" </span><span class="cov5" title="5">{
                return nil, models.ErrUnauthorized
        }</span>

        <span class="cov3" title="3">return h.authService.GetCurrentUser(token)</span>
}

func extractToken(r *http.Request) string <span class="cov8" title="15">{
        bearerToken := r.Header.Get("Authorization")
        if bearerToken == "" </span><span class="cov6" title="8">{
                return ""
        }</span>

        <span class="cov6" title="7">parts := strings.Split(bearerToken, " ")
        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov2" title="2">{
                return ""
        }</span>

        <span class="cov5" title="5">return parts[1]</span>
}

func getClientIP(r *http.Request) string <span class="cov3" title="3">{
        ip := r.Header.Get("X-Real-IP")
        if ip == "" </span><span class="cov2" title="2">{
                ip = r.Header.Get("X-Forwarded-For")
                if ip != "" </span><span class="cov1" title="1">{
                        parts := strings.Split(ip, ",")
                        ip = strings.TrimSpace(parts[0])
                }</span>
        }
        <span class="cov3" title="3">if ip == "" </span><span class="cov1" title="1">{
                ip = r.RemoteAddr
                if strings.Contains(ip, ":") </span><span class="cov1" title="1">{
                        parts := strings.Split(ip, ":")
                        if len(parts) &gt; 0 </span><span class="cov1" title="1">{
                                ip = parts[0]
                        }</span>
                }
        }
        <span class="cov3" title="3">return ip</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/utils"

        "github.com/gin-gonic/gin"
)

// BrowseHandler handles browse operations
type BrowseHandler struct {
        fileRepo *repository.FileRepository
}

// NewBrowseHandler creates a new browse handler
func NewBrowseHandler(fileRepo *repository.FileRepository) *BrowseHandler <span class="cov10" title="12">{
        return &amp;BrowseHandler{
                fileRepo: fileRepo,
        }
}</span>

// GetStorageRoots godoc
// @Summary Get all storage roots
// @Description Retrieve all configured storage roots
// @Tags browse
// @Accept json
// @Produce json
// @Success 200 {array} models.StorageRoot
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/browse/roots [get]
func (h *BrowseHandler) GetStorageRoots(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        roots, err := h.fileRepo.GetStorageRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get storage roots", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    roots,
        })</span>
}

// BrowseDirectory godoc
// @Summary Browse directory contents
// @Description Get files and directories within a specific path
// @Tags browse
// @Accept json
// @Produce json
// @Param storage_root path string true "Storage root name"
// @Param path query string false "Directory path" default("/")
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(100)
// @Param sort_by query string false "Sort field (name, size, modified_at, created_at, path, extension)" default("name")
// @Param sort_order query string false "Sort order (asc, desc)" default("asc")
// @Success 200 {object} models.SearchResult
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/browse/{storage_root} [get]
func (h *BrowseHandler) BrowseDirectory(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        storageRoot := c.Param("storage_root")
        if storageRoot == "" </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Storage root name is required", nil)
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">path := c.DefaultQuery("path", "/")
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "100"))
        sortBy := c.DefaultQuery("sort_by", "name")
        sortOrder := c.DefaultQuery("sort_order", "asc")

        // Validate pagination
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit &lt; 1 || limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        // Validate sort parameters
        <span class="cov0" title="0">validSortFields := map[string]bool{
                "name":        true,
                "size":        true,
                "modified_at": true,
                "created_at":  true,
                "path":        true,
                "extension":   true,
        }
        if !validSortFields[sortBy] </span><span class="cov0" title="0">{
                sortBy = "name"
        }</span>

        <span class="cov0" title="0">if sortOrder != "asc" &amp;&amp; sortOrder != "desc" </span><span class="cov0" title="0">{
                sortOrder = "asc"
        }</span>

        <span class="cov0" title="0">pagination := models.PaginationOptions{
                Page:  page,
                Limit: limit,
        }

        sort := models.SortOptions{
                Field: sortBy,
                Order: sortOrder,
        }

        result, err := h.fileRepo.GetDirectoryContents(ctx, storageRoot, path, pagination, sort)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to browse directory", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// GetFileInfo godoc
// @Summary Get file information
// @Description Get detailed information about a specific file
// @Tags browse
// @Accept json
// @Produce json
// @Param id path int true "File ID"
// @Success 200 {object} models.FileWithMetadata
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/browse/file/{id} [get]
func (h *BrowseHandler) GetFileInfo(c *gin.Context) <span class="cov4" title="3">{
        ctx := c.Request.Context()

        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov4" title="3">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid file ID", nil)
                return
        }</span>

        <span class="cov0" title="0">file, err := h.fileRepo.GetFileByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "file not found" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusNotFound, "File not found", nil)
                        return
                }</span>
                <span class="cov0" title="0">utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get file info", err)
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    file,
        })</span>
}

// GetDirectorySizes godoc
// @Summary Get directories sorted by size
// @Description Retrieve directories sorted by their total size
// @Tags browse
// @Accept json
// @Produce json
// @Param storage_root path string true "Storage root name"
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(50)
// @Param ascending query bool false "Sort in ascending order" default(false)
// @Success 200 {array} models.DirectoryInfo
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/browse/{storage_root}/sizes [get]
func (h *BrowseHandler) GetDirectorySizes(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        storageRoot := c.Param("storage_root")
        if storageRoot == "" </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Storage root name is required", nil)
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
        ascending, _ := strconv.ParseBool(c.DefaultQuery("ascending", "false"))

        // Validate pagination
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit &lt; 1 || limit &gt; 500 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">pagination := models.PaginationOptions{
                Page:  page,
                Limit: limit,
        }

        directories, err := h.fileRepo.GetDirectoriesSortedBySize(ctx, storageRoot, pagination, ascending)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get directory sizes", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    directories,
        })</span>
}

// GetDirectoryDuplicates godoc
// @Summary Get directories sorted by duplicate count
// @Description Retrieve directories sorted by their number of duplicate files
// @Tags browse
// @Accept json
// @Produce json
// @Param storage_root path string true "Storage root name"
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(50)
// @Param ascending query bool false "Sort in ascending order" default(false)
// @Success 200 {array} models.DirectoryInfo
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/browse/{storage_root}/duplicates [get]
func (h *BrowseHandler) GetDirectoryDuplicates(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        storageRoot := c.Param("storage_root")
        if storageRoot == "" </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Storage root name is required", nil)
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
        ascending, _ := strconv.ParseBool(c.DefaultQuery("ascending", "false"))

        // Validate pagination
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit &lt; 1 || limit &gt; 500 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">pagination := models.PaginationOptions{
                Page:  page,
                Limit: limit,
        }

        directories, err := h.fileRepo.GetDirectoriesSortedByDuplicates(ctx, storageRoot, pagination, ascending)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get directory duplicates", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    directories,
        })</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"

        "catalogizer/models"
        "catalogizer/services"

        "github.com/gorilla/mux"
)

type ConfigurationHandler struct {
        configurationService *services.ConfigurationService
        authService          *services.AuthService
}

func NewConfigurationHandler(configurationService *services.ConfigurationService, authService *services.AuthService) *ConfigurationHandler <span class="cov0" title="0">{
        return &amp;ConfigurationHandler{
                configurationService: configurationService,
                authService:          authService,
        }
}</span>

// Wizard endpoints

func (h *ConfigurationHandler) GetWizardStep(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        stepID := vars["step_id"]

        step, err := h.configurationService.GetWizardStep(stepID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(step)</span>
}

func (h *ConfigurationHandler) ValidateWizardStep(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        stepID := vars["step_id"]

        var data map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;data); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">validation, err := h.configurationService.ValidateWizardStep(stepID, data)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(validation)</span>
}

func (h *ConfigurationHandler) SaveWizardProgress(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        stepID := vars["step_id"]

        var finalData map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;finalData); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.configurationService.SaveWizardProgress(userID, stepID, finalData)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "message": "Progress saved successfully",
        })</span>
}

func (h *ConfigurationHandler) GetWizardProgress(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        progress, err := h.configurationService.GetWizardProgress(userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(progress)</span>
}

func (h *ConfigurationHandler) CompleteWizard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        var finalData map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;finalData); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">config, err := h.configurationService.CompleteWizard(userID, finalData)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "message":       "Wizard completed successfully",
                "configuration": config,
        })</span>
}

// Configuration endpoints

func (h *ConfigurationHandler) GetConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemConfig)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">schema, err := h.configurationService.GetConfigurationSchema()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(schema)</span>
}

func (h *ConfigurationHandler) TestConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        //         // This would test the configuration through the service

        // This would test the configuration through the service
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "message": "Configuration tested successfully",
        })</span>
}

func (h *ConfigurationHandler) DeleteBackup(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        _, err := strconv.Atoi(vars["backup_id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid backup ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        // This would delete the backup through the service
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "message": "Backup deleted successfully",
        })</span>
}

// Health check endpoint

func (h *ConfigurationHandler) GetSystemStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemConfig)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">status := map[string]interface{}{
                "status":  "healthy",
                "version": "3.0.0",
                "uptime":  "24h 30m",
                "components": map[string]string{
                        "database":         "healthy",
                        "storage":          "healthy",
                        "authentication":   "healthy",
                        "media_conversion": "healthy",
                        "sync":             "healthy",
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(status)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/services"
)

type ConversionHandler struct {
        conversionService *services.ConversionService
        authService       *services.AuthService
}

func NewConversionHandler(conversionService *services.ConversionService, authService *services.AuthService) *ConversionHandler <span class="cov0" title="0">{
        return &amp;ConversionHandler{
                conversionService: conversionService,
                authService:       authService,
        }
}</span>

func (h *ConversionHandler) CreateJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionMediaUpload)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var req models.ConversionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">job, err := h.conversionService.CreateConversionJob(currentUser.ID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(job)</span>
}

func (h *ConversionHandler) GetJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">jobIDStr := strings.TrimPrefix(r.URL.Path, "/api/conversion/jobs/")
        jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">job, err := h.conversionService.GetJob(jobID, currentUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "unauthorized") </span><span class="cov0" title="0">{
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        http.Error(w, "Job not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to get job", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(job)</span>
}

func (h *ConversionHandler) ListUserJobs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">status := r.URL.Query().Get("status")
        var statusPtr *string
        if status != "" </span><span class="cov0" title="0">{
                statusPtr = &amp;status
        }</span>

        <span class="cov0" title="0">limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")

        limit := 50
        offset := 0

        if limitStr != "" </span><span class="cov0" title="0">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 &amp;&amp; parsedLimit &lt;= 100 </span><span class="cov0" title="0">{
                        limit = parsedLimit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if parsedOffset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; parsedOffset &gt;= 0 </span><span class="cov0" title="0">{
                        offset = parsedOffset
                }</span>
        }

        <span class="cov0" title="0">jobs, err := h.conversionService.GetUserJobs(currentUser.ID, statusPtr, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get jobs", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "jobs":   jobs,
                "limit":  limit,
                "offset": offset,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

func (h *ConversionHandler) StartJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserManage)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">jobIDStr := strings.TrimPrefix(r.URL.Path, "/api/conversion/jobs/")
        jobIDStr = strings.TrimSuffix(jobIDStr, "/start")
        jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.conversionService.StartConversion(jobID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Job started successfully"})</span>
}

func (h *ConversionHandler) CancelJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">jobIDStr := strings.TrimPrefix(r.URL.Path, "/api/conversion/jobs/")
        jobIDStr = strings.TrimSuffix(jobIDStr, "/cancel")
        jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.conversionService.CancelJob(jobID, currentUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "unauthorized") </span><span class="cov0" title="0">{
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, err.Error(), http.StatusBadRequest)
                return</span>
        }

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Job cancelled successfully"})</span>
}

func (h *ConversionHandler) RetryJob(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">jobIDStr := strings.TrimPrefix(r.URL.Path, "/api/conversion/jobs/")
        jobIDStr = strings.TrimSuffix(jobIDStr, "/retry")
        jobID, err := strconv.Atoi(jobIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid job ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.conversionService.RetryJob(jobID, currentUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "unauthorized") </span><span class="cov0" title="0">{
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, err.Error(), http.StatusBadRequest)
                return</span>
        }

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Job restarted successfully"})</span>
}

func (h *ConversionHandler) GetSupportedFormats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">formats := h.conversionService.GetSupportedFormats()

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(formats)</span>
}

func (h *ConversionHandler) GetStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">startDateStr := r.URL.Query().Get("start_date")
        endDateStr := r.URL.Query().Get("end_date")
        userIDStr := r.URL.Query().Get("user_id")

        var startDate, endDate time.Time
        var userID *int

        if startDateStr != "" </span><span class="cov0" title="0">{
                if parsed, err := time.Parse("2006-01-02", startDateStr); err == nil </span><span class="cov0" title="0">{
                        startDate = parsed
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Invalid start_date format", http.StatusBadRequest)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                startDate = time.Now().AddDate(0, -1, 0) // Default to last month
        }</span>

        <span class="cov0" title="0">if endDateStr != "" </span><span class="cov0" title="0">{
                if parsed, err := time.Parse("2006-01-02", endDateStr); err == nil </span><span class="cov0" title="0">{
                        endDate = parsed
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Invalid end_date format", http.StatusBadRequest)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                endDate = time.Now()
        }</span>

        <span class="cov0" title="0">if userIDStr != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(userIDStr); err == nil </span><span class="cov0" title="0">{
                        if parsed != currentUser.ID </span><span class="cov0" title="0">{
                                hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionAnalyticsView)
                                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                                        http.Error(w, "Insufficient permissions", http.StatusForbidden)
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">userID = &amp;parsed</span>
                } else<span class="cov0" title="0"> {
                        http.Error(w, "Invalid user_id format", http.StatusBadRequest)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                userID = &amp;currentUser.ID
        }</span>

        <span class="cov0" title="0">stats, err := h.conversionService.GetJobStatistics(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get statistics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

func (h *ConversionHandler) ProcessQueue(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">err = h.conversionService.ProcessJobQueue()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to process queue", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Queue processing started"})</span>
}

func (h *ConversionHandler) GetQueue(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionAnalyticsView)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">jobs, err := h.conversionService.GetJobQueue()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get queue", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "queue": jobs,
                "count": len(jobs),
        })</span>
}

func (h *ConversionHandler) CleanupJobs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">daysStr := r.URL.Query().Get("days")
        days := 30 // Default to 30 days

        if daysStr != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(daysStr); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov0" title="0">{
                        days = parsed
                }</span>
        }

        <span class="cov0" title="0">olderThan := time.Now().AddDate(0, 0, -days)

        err = h.conversionService.CleanupCompletedJobs(olderThan)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to cleanup jobs", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Cleanup completed successfully"})</span>
}

func (h *ConversionHandler) getCurrentUser(r *http.Request) (*models.User, error) <span class="cov0" title="0">{
        token := extractToken(r)
        if token == "" </span><span class="cov0" title="0">{
                return nil, models.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return h.authService.GetCurrentUser(token)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/smb"
        "catalogizer/utils"

        "github.com/gin-gonic/gin"
)

// CopyHandler handles file copy operations
type CopyHandler struct {
        fileRepo *repository.FileRepository
        smbPool  *smb.SmbConnectionPool
        tempDir  string
}

// NewCopyHandler creates a new copy handler
func NewCopyHandler(fileRepo *repository.FileRepository, tempDir string) *CopyHandler <span class="cov10" title="16">{
        return &amp;CopyHandler{
                fileRepo: fileRepo,
                smbPool:  smb.NewSmbConnectionPool(10),
                tempDir:  tempDir,
        }
}</span>

// CopyToSmb godoc
// @Summary Copy file/directory to SMB location
// @Description Copy a file or directory from one SMB location to another
// @Tags copy
// @Accept json
// @Produce json
// @Param body body SmbCopyRequest true "Copy request"
// @Success 200 {object} CopyResponse
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/copy/smb [post]
func (h *CopyHandler) CopyToSmb(c *gin.Context) <span class="cov5" title="4">{
        ctx := c.Request.Context()

        var req SmbCopyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov5" title="4">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validateSmbCopyRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid copy request", err)
                return
        }</span>

        // Get source file information
        <span class="cov0" title="0">sourceFile, err := h.fileRepo.GetFileByID(ctx, req.SourceFileID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "file not found" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusNotFound, "Source file not found", err)
                        return
                }</span>
                <span class="cov0" title="0">utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get source file info", err)
                return</span>
        }

        // Get storage roots
        <span class="cov0" title="0">storageRoots, err := h.fileRepo.GetStorageRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get storage roots", err)
                return
        }</span>

        // Find source and destination storage roots
        <span class="cov0" title="0">var sourceStorageRoot, destStorageRoot *models.StorageRoot
        for _, root := range storageRoots </span><span class="cov0" title="0">{
                if root.ID == sourceFile.StorageRootID </span><span class="cov0" title="0">{
                        sourceStorageRoot = &amp;root
                }</span>
                <span class="cov0" title="0">if root.Name == req.DestinationSmbRoot </span><span class="cov0" title="0">{
                        destStorageRoot = &amp;root
                }</span>
        }

        <span class="cov0" title="0">if sourceStorageRoot == nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "Source storage root not found", nil)
                return
        }</span>
        <span class="cov0" title="0">if destStorageRoot == nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "Destination storage root not found", nil)
                return
        }</span>

        // Create SMB connections
        <span class="cov0" title="0">sourceSmbClient, err := h.createSmbClient(sourceStorageRoot)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to connect to source SMB", err)
                return
        }</span>

        <span class="cov0" title="0">destSmbClient, err := h.createSmbClient(destStorageRoot)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to connect to destination SMB", err)
                return
        }</span>

        // Perform copy operation
        <span class="cov0" title="0">startTime := time.Now()
        var result CopyResponse

        if sourceFile.IsDirectory </span><span class="cov0" title="0">{
                result, err = h.copyDirectoryToSmb(ctx, sourceSmbClient, destSmbClient, sourceFile.Path, req.DestinationPath, req.OverwriteExisting)
        }</span> else<span class="cov0" title="0"> {
                result, err = h.copyFileToSmb(ctx, sourceSmbClient, destSmbClient, sourceFile.Path, req.DestinationPath, req.OverwriteExisting)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Copy operation failed", err)
                return
        }</span>

        <span class="cov0" title="0">result.TimeTaken = time.Since(startTime)
        result.Success = true

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// CopyToLocal godoc
// @Summary Copy file/directory to local computer
// @Description Copy a file or directory from SMB to local computer
// @Tags copy
// @Accept json
// @Produce json
// @Param body body LocalCopyRequest true "Copy request"
// @Success 200 {object} CopyResponse
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/copy/local [post]
func (h *CopyHandler) CopyToLocal(c *gin.Context) <span class="cov4" title="3">{
        ctx := c.Request.Context()

        var req LocalCopyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov4" title="3">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        // Validate request
        <span class="cov0" title="0">if err := h.validateLocalCopyRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid copy request", err)
                return
        }</span>

        // Get source file information
        <span class="cov0" title="0">sourceFile, err := h.fileRepo.GetFileByID(ctx, req.SourceFileID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "file not found" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusNotFound, "Source file not found", err)
                        return
                }</span>
                <span class="cov0" title="0">utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get source file info", err)
                return</span>
        }

        // Get SMB roots
        <span class="cov0" title="0">smbRoots, err := h.fileRepo.GetStorageRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get SMB roots", err)
                return
        }</span>

        // Find source SMB root
        <span class="cov0" title="0">var sourceSmbRoot *models.StorageRoot
        for _, root := range smbRoots </span><span class="cov0" title="0">{
                if root.ID == sourceFile.StorageRootID </span><span class="cov0" title="0">{
                        sourceSmbRoot = &amp;root
                        break</span>
                }
        }

        <span class="cov0" title="0">if sourceSmbRoot == nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "Source SMB root not found", nil)
                return
        }</span>

        // Create SMB connection
        <span class="cov0" title="0">sourceSmbClient, err := h.createSmbClient(sourceSmbRoot)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to connect to source SMB", err)
                return
        }</span>

        // Perform copy operation
        <span class="cov0" title="0">startTime := time.Now()
        var result CopyResponse

        if sourceFile.IsDirectory </span><span class="cov0" title="0">{
                result, err = h.copyDirectoryToLocal(ctx, sourceSmbClient, sourceFile.Path, req.DestinationPath, req.OverwriteExisting)
        }</span> else<span class="cov0" title="0"> {
                result, err = h.copyFileToLocal(ctx, sourceSmbClient, sourceFile.Path, req.DestinationPath, req.OverwriteExisting)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Copy operation failed", err)
                return
        }</span>

        <span class="cov0" title="0">result.TimeTaken = time.Since(startTime)
        result.Success = true

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// CopyFromLocal godoc
// @Summary Copy file/directory from local computer to SMB
// @Description Copy a file or directory from local computer to SMB location
// @Tags copy
// @Accept multipart/form-data
// @Produce json
// @Param destination_smb_root formData string true "Destination SMB root name"
// @Param destination_path formData string true "Destination path on SMB"
// @Param overwrite_existing formData bool false "Overwrite existing files" default(false)
// @Param file formData file true "File to upload"
// @Success 200 {object} CopyResponse
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/copy/upload [post]
func (h *CopyHandler) CopyFromLocal(c *gin.Context) <span class="cov3" title="2">{
        ctx := c.Request.Context()

        // Parse form data
        destSmbRootName := c.PostForm("destination_smb_root")
        destPath := c.PostForm("destination_path")
        overwriteStr := c.DefaultPostForm("overwrite_existing", "false")
        overwrite := overwriteStr == "true"

        if destSmbRootName == "" || destPath == "" </span><span class="cov1" title="1">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "destination_smb_root and destination_path are required", nil)
                return
        }</span>

        // Get uploaded file
        <span class="cov1" title="1">file, header, err := c.Request.FormFile("file")
        if err != nil </span><span class="cov1" title="1">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Failed to get uploaded file", err)
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Get SMB roots
        smbRoots, err := h.fileRepo.GetStorageRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get SMB roots", err)
                return
        }</span>

        // Find destination SMB root
        <span class="cov0" title="0">var destSmbRoot *models.StorageRoot
        for _, root := range smbRoots </span><span class="cov0" title="0">{
                if root.Name == destSmbRootName </span><span class="cov0" title="0">{
                        destSmbRoot = &amp;root
                        break</span>
                }
        }

        <span class="cov0" title="0">if destSmbRoot == nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "Destination SMB root not found", nil)
                return
        }</span>

        // Create SMB connection
        <span class="cov0" title="0">destSmbClient, err := h.createSmbClient(destSmbRoot)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to connect to destination SMB", err)
                return
        }</span>

        // Perform upload
        <span class="cov0" title="0">startTime := time.Now()
        fullDestPath := filepath.Join(destPath, header.Filename)

        // Check if file exists and overwrite policy
        if exists, err := destSmbClient.FileExists(fullDestPath); err == nil &amp;&amp; exists &amp;&amp; !overwrite </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusConflict, "File already exists and overwrite is disabled", nil)
                return
        }</span>

        // Copy file
        <span class="cov0" title="0">err = destSmbClient.WriteFile(fullDestPath, file)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to copy file to SMB", err)
                return
        }</span>

        <span class="cov0" title="0">result := CopyResponse{
                Success:     true,
                BytesCopied: header.Size,
                FilesCount:  1,
                TimeTaken:   time.Since(startTime),
                SourcePath:  header.Filename,
                DestPath:    fullDestPath,
        }

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// Helper methods

func (h *CopyHandler) createSmbClient(storageRoot *models.StorageRoot) (*smb.SmbClient, error) <span class="cov0" title="0">{
        host := ""
        if storageRoot.Host != nil </span><span class="cov0" title="0">{
                host = *storageRoot.Host
        }</span>
        <span class="cov0" title="0">port := 445
        if storageRoot.Port != nil </span><span class="cov0" title="0">{
                port = *storageRoot.Port
        }</span>
        <span class="cov0" title="0">share := ""
        if storageRoot.Path != nil </span><span class="cov0" title="0">{
                share = *storageRoot.Path
        }</span>
        <span class="cov0" title="0">username := ""
        if storageRoot.Username != nil </span><span class="cov0" title="0">{
                username = *storageRoot.Username
        }</span>
        <span class="cov0" title="0">domain := ""
        if storageRoot.Domain != nil </span><span class="cov0" title="0">{
                domain = *storageRoot.Domain
        }</span>

        <span class="cov0" title="0">smbConfig := &amp;smb.SmbConfig{
                Host:     host,
                Port:     port,
                Share:    share,
                Username: username,
                Domain:   domain,
        }

        connectionKey := fmt.Sprintf("%s:%d:%s:%s", host, port, share, username)
        return h.smbPool.GetConnection(connectionKey, smbConfig)</span>
}

func (h *CopyHandler) copyFileToSmb(ctx context.Context, sourceSmbClient, destSmbClient *smb.SmbClient, sourcePath, destPath string, overwrite bool) (CopyResponse, error) <span class="cov0" title="0">{
        // Check if destination exists
        if exists, err := destSmbClient.FileExists(destPath); err == nil &amp;&amp; exists &amp;&amp; !overwrite </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("destination file exists and overwrite is disabled")
        }</span>

        // Read source file
        <span class="cov0" title="0">sourceReader, err := sourceSmbClient.ReadFile(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to read source file: %w", err)
        }</span>
        <span class="cov0" title="0">defer sourceReader.Close()

        // Write to destination
        err = destSmbClient.WriteFile(destPath, sourceReader)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to write destination file: %w", err)
        }</span>

        // Get file info for size
        <span class="cov0" title="0">sourceInfo, err := sourceSmbClient.GetFileInfo(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to get source file info: %w", err)
        }</span>

        <span class="cov0" title="0">return CopyResponse{
                BytesCopied: sourceInfo.Size,
                FilesCount:  1,
                SourcePath:  sourcePath,
                DestPath:    destPath,
        }, nil</span>
}

func (h *CopyHandler) copyDirectoryToSmb(ctx context.Context, sourceSmbClient, destSmbClient *smb.SmbClient, sourcePath, destPath string, overwrite bool) (CopyResponse, error) <span class="cov0" title="0">{
        var totalBytes int64
        var filesCount int

        // Create destination directory
        err := destSmbClient.CreateDirectory(destPath)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Recursively copy contents
        <span class="cov0" title="0">err = h.copyDirectoryContentsToSmb(ctx, sourceSmbClient, destSmbClient, sourcePath, destPath, overwrite, &amp;totalBytes, &amp;filesCount)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, err
        }</span>

        <span class="cov0" title="0">return CopyResponse{
                BytesCopied: totalBytes,
                FilesCount:  filesCount,
                SourcePath:  sourcePath,
                DestPath:    destPath,
        }, nil</span>
}

func (h *CopyHandler) copyDirectoryContentsToSmb(ctx context.Context, sourceSmbClient, destSmbClient *smb.SmbClient, sourcePath, destPath string, overwrite bool, totalBytes *int64, filesCount *int) error <span class="cov0" title="0">{
        files, err := sourceSmbClient.ListDirectory(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list directory %s: %w", sourcePath, err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>

                <span class="cov0" title="0">sourceFilePath := filepath.Join(sourcePath, file.Name)
                destFilePath := filepath.Join(destPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        // Create subdirectory
                        err := destSmbClient.CreateDirectory(destFilePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", destFilePath, err)
                        }</span>

                        // Recursively copy subdirectory
                        <span class="cov0" title="0">err = h.copyDirectoryContentsToSmb(ctx, sourceSmbClient, destSmbClient, sourceFilePath, destFilePath, overwrite, totalBytes, filesCount)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Copy file
                        result, err := h.copyFileToSmb(ctx, sourceSmbClient, destSmbClient, sourceFilePath, destFilePath, overwrite)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">*totalBytes += result.BytesCopied
                        *filesCount += result.FilesCount</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (h *CopyHandler) copyFileToLocal(ctx context.Context, sourceSmbClient *smb.SmbClient, sourcePath, destPath string, overwrite bool) (CopyResponse, error) <span class="cov0" title="0">{
        // Check if destination exists
        if _, err := os.Stat(destPath); err == nil &amp;&amp; !overwrite </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("destination file exists and overwrite is disabled")
        }</span>

        // Ensure destination directory exists
        <span class="cov0" title="0">destDir := filepath.Dir(destPath)
        if err := os.MkdirAll(destDir, 0755); err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Read source file
        <span class="cov0" title="0">sourceReader, err := sourceSmbClient.ReadFile(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to read source file: %w", err)
        }</span>
        <span class="cov0" title="0">defer sourceReader.Close()

        // Create destination file
        destFile, err := os.Create(destPath)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to create destination file: %w", err)
        }</span>
        <span class="cov0" title="0">defer destFile.Close()

        // Copy data
        bytesCopied, err := io.Copy(destFile, sourceReader)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to copy file data: %w", err)
        }</span>

        <span class="cov0" title="0">return CopyResponse{
                BytesCopied: bytesCopied,
                FilesCount:  1,
                SourcePath:  sourcePath,
                DestPath:    destPath,
        }, nil</span>
}

func (h *CopyHandler) copyDirectoryToLocal(ctx context.Context, sourceSmbClient *smb.SmbClient, sourcePath, destPath string, overwrite bool) (CopyResponse, error) <span class="cov0" title="0">{
        var totalBytes int64
        var filesCount int

        // Create destination directory
        if err := os.MkdirAll(destPath, 0755); err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Recursively copy contents
        <span class="cov0" title="0">err := h.copyDirectoryContentsToLocal(ctx, sourceSmbClient, sourcePath, destPath, overwrite, &amp;totalBytes, &amp;filesCount)
        if err != nil </span><span class="cov0" title="0">{
                return CopyResponse{}, err
        }</span>

        <span class="cov0" title="0">return CopyResponse{
                BytesCopied: totalBytes,
                FilesCount:  filesCount,
                SourcePath:  sourcePath,
                DestPath:    destPath,
        }, nil</span>
}

func (h *CopyHandler) copyDirectoryContentsToLocal(ctx context.Context, sourceSmbClient *smb.SmbClient, sourcePath, destPath string, overwrite bool, totalBytes *int64, filesCount *int) error <span class="cov0" title="0">{
        files, err := sourceSmbClient.ListDirectory(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list directory %s: %w", sourcePath, err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>

                <span class="cov0" title="0">sourceFilePath := filepath.Join(sourcePath, file.Name)
                destFilePath := filepath.Join(destPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        // Create subdirectory
                        if err := os.MkdirAll(destFilePath, 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", destFilePath, err)
                        }</span>

                        // Recursively copy subdirectory
                        <span class="cov0" title="0">err = h.copyDirectoryContentsToLocal(ctx, sourceSmbClient, sourceFilePath, destFilePath, overwrite, totalBytes, filesCount)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Copy file
                        result, err := h.copyFileToLocal(ctx, sourceSmbClient, sourceFilePath, destFilePath, overwrite)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">*totalBytes += result.BytesCopied
                        *filesCount += result.FilesCount</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (h *CopyHandler) validateSmbCopyRequest(req *SmbCopyRequest) error <span class="cov0" title="0">{
        if req.SourceFileID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("source_file_id is required")
        }</span>
        <span class="cov0" title="0">if req.DestinationSmbRoot == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("destination_smb_root is required")
        }</span>
        <span class="cov0" title="0">if req.DestinationPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("destination_path is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *CopyHandler) validateLocalCopyRequest(req *LocalCopyRequest) error <span class="cov0" title="0">{
        if req.SourceFileID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("source_file_id is required")
        }</span>
        <span class="cov0" title="0">if req.DestinationPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("destination_path is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request/Response types

type SmbCopyRequest struct {
        SourceFileID       int64  `json:"source_file_id" binding:"required"`
        DestinationSmbRoot string `json:"destination_smb_root" binding:"required"`
        DestinationPath    string `json:"destination_path" binding:"required"`
        OverwriteExisting  bool   `json:"overwrite_existing"`
}

type LocalCopyRequest struct {
        SourceFileID      int64  `json:"source_file_id" binding:"required"`
        DestinationPath   string `json:"destination_path" binding:"required"`
        OverwriteExisting bool   `json:"overwrite_existing"`
}

type CopyResponse struct {
        Success     bool          `json:"success"`
        BytesCopied int64         `json:"bytes_copied"`
        FilesCount  int           `json:"files_count"`
        TimeTaken   time.Duration `json:"time_taken"`
        SourcePath  string        `json:"source_path"`
        DestPath    string        `json:"dest_path"`
}

// Close closes the copy handler and its resources
func (h *CopyHandler) Close() <span class="cov0" title="0">{
        h.smbPool.CloseAll()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "archive/zip"
        "context"
        "fmt"
        "io"
        "net/http"
        "path/filepath"
        "strconv"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/smb"
        "catalogizer/utils"

        "github.com/gin-gonic/gin"
)

// DownloadHandler handles file download operations
type DownloadHandler struct {
        fileRepo       *repository.FileRepository
        smbPool        *smb.SmbConnectionPool
        tempDir        string
        maxArchiveSize int64
        chunkSize      int
}

// NewDownloadHandler creates a new download handler
func NewDownloadHandler(fileRepo *repository.FileRepository, tempDir string, maxArchiveSize int64, chunkSize int) *DownloadHandler <span class="cov10" title="16">{
        return &amp;DownloadHandler{
                fileRepo:       fileRepo,
                smbPool:        smb.NewSmbConnectionPool(10), // Max 10 concurrent SMB connections
                tempDir:        tempDir,
                maxArchiveSize: maxArchiveSize,
                chunkSize:      chunkSize,
        }
}</span>

// DownloadFile godoc
// @Summary Download a file
// @Description Download a specific file by ID with streaming support
// @Tags download
// @Produce application/octet-stream
// @Param id path int true "File ID"
// @Param inline query bool false "Display inline instead of download" default(false)
// @Success 200 {file} binary
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/download/file/{id} [get]
func (h *DownloadHandler) DownloadFile(c *gin.Context) <span class="cov6" title="6">{
        ctx := c.Request.Context()

        // Parse file ID
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov6" title="6">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid file ID", err)
                return
        }</span>

        // Get file information
        <span class="cov0" title="0">file, err := h.fileRepo.GetFileByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "file not found" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusNotFound, "File not found", err)
                        return
                }</span>
                <span class="cov0" title="0">utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get file info", err)
                return</span>
        }

        // Check if it's a directory
        <span class="cov0" title="0">if file.IsDirectory </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Cannot download directory as file. Use directory download endpoint", nil)
                return
        }</span>

        // Check if file is deleted
        <span class="cov0" title="0">if file.Deleted </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "File has been deleted", nil)
                return
        }</span>

        // Get SMB root information
        <span class="cov0" title="0">smbRoots, err := h.fileRepo.GetStorageRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get SMB root info", err)
                return
        }</span>

        <span class="cov0" title="0">var smbRoot *models.StorageRoot
        for _, root := range smbRoots </span><span class="cov0" title="0">{
                if root.ID == file.StorageRootID </span><span class="cov0" title="0">{
                        smbRoot = &amp;root
                        break</span>
                }
        }

        <span class="cov0" title="0">if smbRoot == nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "SMB root not found", nil)
                return
        }</span>

        // Create SMB connection
        <span class="cov0" title="0">host := ""
        if smbRoot.Host != nil </span><span class="cov0" title="0">{
                host = *smbRoot.Host
        }</span>
        <span class="cov0" title="0">port := 445
        if smbRoot.Port != nil </span><span class="cov0" title="0">{
                port = *smbRoot.Port
        }</span>
        <span class="cov0" title="0">share := ""
        if smbRoot.Path != nil </span><span class="cov0" title="0">{
                share = *smbRoot.Path
        }</span>
        <span class="cov0" title="0">username := ""
        if smbRoot.Username != nil </span><span class="cov0" title="0">{
                username = *smbRoot.Username
        }</span>
        <span class="cov0" title="0">domain := ""
        if smbRoot.Domain != nil </span><span class="cov0" title="0">{
                domain = *smbRoot.Domain
        }</span>

        <span class="cov0" title="0">smbConfig := &amp;smb.SmbConfig{
                Host:     host,
                Port:     port,
                Share:    share,
                Username: username,
                Domain:   domain,
        }

        connectionKey := fmt.Sprintf("%s:%d:%s:%s", host, port, share, username)
        smbClient, err := h.smbPool.GetConnection(connectionKey, smbConfig)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to connect to SMB share", err)
                return
        }</span>

        // Open file for reading
        <span class="cov0" title="0">reader, err := smbClient.ReadFile(file.Path)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to open file", err)
                return
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        // Set headers
        inline := c.Query("inline") == "true"
        disposition := "attachment"
        if inline </span><span class="cov0" title="0">{
                disposition = "inline"
        }</span>

        <span class="cov0" title="0">c.Header("Content-Disposition", fmt.Sprintf(`%s; filename="%s"`, disposition, file.Name))
        c.Header("Content-Length", strconv.FormatInt(file.Size, 10))

        // Set content type based on file extension
        if file.MimeType != nil &amp;&amp; *file.MimeType != "" </span><span class="cov0" title="0">{
                c.Header("Content-Type", *file.MimeType)
        }</span> else<span class="cov0" title="0"> {
                c.Header("Content-Type", "application/octet-stream")
        }</span>

        // Stream file content
        <span class="cov0" title="0">c.Stream(func(w io.Writer) bool </span><span class="cov0" title="0">{
                buffer := make([]byte, h.chunkSize)
                n, err := reader.Read(buffer)
                if err != nil </span><span class="cov0" title="0">{
                        if err != io.EOF </span><span class="cov0" title="0">{
                                c.Header("X-Download-Error", err.Error())
                        }</span>
                        <span class="cov0" title="0">return false</span>
                }
                <span class="cov0" title="0">_, writeErr := w.Write(buffer[:n])
                return writeErr == nil</span>
        })
}

// DownloadDirectory godoc
// @Summary Download directory as ZIP
// @Description Download a directory and its contents as a ZIP archive
// @Tags download
// @Produce application/zip
// @Param smb_root path string true "SMB root name"
// @Param path query string true "Directory path"
// @Param recursive query bool false "Include subdirectories recursively" default(true)
// @Param max_depth query int false "Maximum recursion depth" default(-1)
// @Success 200 {file} binary
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/download/directory/{smb_root} [get]
func (h *DownloadHandler) DownloadDirectory(c *gin.Context) <span class="cov3" title="2">{
        ctx := c.Request.Context()

        smbRootName := c.Param("smb_root")
        dirPath := c.Query("path")
        recursive := c.DefaultQuery("recursive", "true") == "true"
        maxDepth, _ := strconv.Atoi(c.DefaultQuery("max_depth", "-1"))

        if dirPath == "" </span><span class="cov3" title="2">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Directory path is required", nil)
                return
        }</span>

        // Get SMB root information
        <span class="cov0" title="0">smbRoots, err := h.fileRepo.GetStorageRoots(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get SMB root info", err)
                return
        }</span>

        <span class="cov0" title="0">var smbRoot *models.StorageRoot
        for _, root := range smbRoots </span><span class="cov0" title="0">{
                if root.Name == smbRootName </span><span class="cov0" title="0">{
                        smbRoot = &amp;root
                        break</span>
                }
        }

        <span class="cov0" title="0">if smbRoot == nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "SMB root not found", nil)
                return
        }</span>

        // Create SMB connection
        <span class="cov0" title="0">host := ""
        if smbRoot.Host != nil </span><span class="cov0" title="0">{
                host = *smbRoot.Host
        }</span>
        <span class="cov0" title="0">port := 445
        if smbRoot.Port != nil </span><span class="cov0" title="0">{
                port = *smbRoot.Port
        }</span>
        <span class="cov0" title="0">share := ""
        if smbRoot.Path != nil </span><span class="cov0" title="0">{
                share = *smbRoot.Path
        }</span>
        <span class="cov0" title="0">username := ""
        if smbRoot.Username != nil </span><span class="cov0" title="0">{
                username = *smbRoot.Username
        }</span>
        <span class="cov0" title="0">domain := ""
        if smbRoot.Domain != nil </span><span class="cov0" title="0">{
                domain = *smbRoot.Domain
        }</span>

        <span class="cov0" title="0">smbConfig := &amp;smb.SmbConfig{
                Host:     host,
                Port:     port,
                Share:    share,
                Username: username,
                Domain:   domain,
        }

        connectionKey := fmt.Sprintf("%s:%d:%s:%s", host, port, share, username)
        smbClient, err := h.smbPool.GetConnection(connectionKey, smbConfig)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to connect to SMB share", err)
                return
        }</span>

        // Check if directory exists
        <span class="cov0" title="0">fileInfo, err := smbClient.GetFileInfo(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusNotFound, "Directory not found", err)
                return
        }</span>

        <span class="cov0" title="0">if !fileInfo.IsDir </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Path is not a directory", nil)
                return
        }</span>

        // Set headers for ZIP download
        <span class="cov0" title="0">dirName := filepath.Base(dirPath)
        if dirName == "." || dirName == "/" </span><span class="cov0" title="0">{
                dirName = "root"
        }</span>
        <span class="cov0" title="0">c.Header("Content-Type", "application/zip")
        c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s.zip"`, dirName))

        // Stream ZIP creation
        c.Stream(func(w io.Writer) bool </span><span class="cov0" title="0">{
                return h.createZipStream(ctx, w, smbClient, dirPath, recursive, maxDepth, 0)
        }</span>)
}

// createZipStream creates a ZIP archive and streams it to the writer
func (h *DownloadHandler) createZipStream(ctx context.Context, w io.Writer, smbClient *smb.SmbClient, basePath string, recursive bool, maxDepth, currentDepth int) bool <span class="cov0" title="0">{
        zipWriter := zip.NewWriter(w)
        defer zipWriter.Close()

        var totalSize int64
        err := h.addDirectoryToZip(ctx, zipWriter, smbClient, basePath, "", recursive, maxDepth, currentDepth, &amp;totalSize)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// addDirectoryToZip recursively adds directory contents to ZIP
func (h *DownloadHandler) addDirectoryToZip(ctx context.Context, zipWriter *zip.Writer, smbClient *smb.SmbClient, smbPath, zipPath string, recursive bool, maxDepth, currentDepth int, totalSize *int64) error <span class="cov0" title="0">{
        // Check context cancellation
        if ctx.Err() != nil </span><span class="cov0" title="0">{
                return ctx.Err()
        }</span>

        // Check depth limit
        <span class="cov0" title="0">if maxDepth &gt;= 0 &amp;&amp; currentDepth &gt;= maxDepth </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check size limit
        <span class="cov0" title="0">if *totalSize &gt; h.maxArchiveSize </span><span class="cov0" title="0">{
                return fmt.Errorf("archive size limit exceeded")
        }</span>

        // List directory contents
        <span class="cov0" title="0">files, err := smbClient.ListDirectory(smbPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list directory %s: %w", smbPath, err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                fullSmbPath := filepath.Join(smbPath, file.Name)
                fullZipPath := filepath.Join(zipPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        // Add directory entry
                        dirHeader := &amp;zip.FileHeader{
                                Name:     fullZipPath + "/",
                                Method:   zip.Store,
                                Modified: file.ModTime,
                        }
                        _, err := zipWriter.CreateHeader(dirHeader)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory entry %s: %w", fullZipPath, err)
                        }</span>

                        // Recursively add subdirectory if enabled
                        <span class="cov0" title="0">if recursive </span><span class="cov0" title="0">{
                                err = h.addDirectoryToZip(ctx, zipWriter, smbClient, fullSmbPath, fullZipPath, recursive, maxDepth, currentDepth+1, totalSize)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Add file
                        *totalSize += file.Size
                        if *totalSize &gt; h.maxArchiveSize </span><span class="cov0" title="0">{
                                return fmt.Errorf("archive size limit exceeded")
                        }</span>

                        <span class="cov0" title="0">fileHeader := &amp;zip.FileHeader{
                                Name:     fullZipPath,
                                Method:   zip.Deflate,
                                Modified: file.ModTime,
                        }

                        fileWriter, err := zipWriter.CreateHeader(fileHeader)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create file entry %s: %w", fullZipPath, err)
                        }</span>

                        // Read and copy file content
                        <span class="cov0" title="0">fileReader, err := smbClient.ReadFile(fullSmbPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to read file %s: %w", fullSmbPath, err)
                        }</span>

                        <span class="cov0" title="0">_, err = io.Copy(fileWriter, fileReader)
                        fileReader.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to copy file %s: %w", fullSmbPath, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetDownloadInfo godoc
// @Summary Get download information
// @Description Get information about a file or directory before downloading
// @Tags download
// @Accept json
// @Produce json
// @Param id path int true "File ID"
// @Success 200 {object} DownloadInfo
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/download/info/{id} [get]
func (h *DownloadHandler) GetDownloadInfo(c *gin.Context) <span class="cov5" title="4">{
        ctx := c.Request.Context()

        // Parse file ID
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov5" title="4">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid file ID", err)
                return
        }</span>

        // Get file information
        <span class="cov0" title="0">file, err := h.fileRepo.GetFileByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "file not found" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusNotFound, "File not found", err)
                        return
                }</span>
                <span class="cov0" title="0">utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get file info", err)
                return</span>
        }

        <span class="cov0" title="0">info := DownloadInfo{
                FileID:      file.ID,
                Name:        file.Name,
                Path:        file.Path,
                Size:        file.Size,
                IsDirectory: file.IsDirectory,
                MimeType:    file.MimeType,
                Extension:   file.Extension,
                ModifiedAt:  file.ModifiedAt,
                Deleted:     file.Deleted,
        }

        if file.IsDirectory </span><span class="cov0" title="0">{
                // For directories, we might want to calculate total size
                // This is a simplified version - in practice you might want to cache this
                info.EstimatedArchiveSize = file.Size // Placeholder
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    info,
        })</span>
}

// DownloadInfo represents download information
type DownloadInfo struct {
        FileID               int64     `json:"file_id"`
        Name                 string    `json:"name"`
        Path                 string    `json:"path"`
        Size                 int64     `json:"size"`
        IsDirectory          bool      `json:"is_directory"`
        MimeType             *string   `json:"mime_type"`
        Extension            *string   `json:"extension"`
        ModifiedAt           time.Time `json:"modified_at"`
        Deleted              bool      `json:"deleted"`
        EstimatedArchiveSize int64     `json:"estimated_archive_size,omitempty"`
}

// Close closes the download handler and its resources
func (h *DownloadHandler) Close() <span class="cov0" title="0">{
        h.smbPool.CloseAll()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "time"

        "catalogizer/models"
        "catalogizer/services"

        "github.com/gorilla/mux"
)

type ErrorReportingHandler struct {
        errorReportingService *services.ErrorReportingService
        authService           *services.AuthService
}

func NewErrorReportingHandler(errorReportingService *services.ErrorReportingService, authService *services.AuthService) *ErrorReportingHandler <span class="cov0" title="0">{
        return &amp;ErrorReportingHandler{
                errorReportingService: errorReportingService,
                authService:           authService,
        }
}</span>

func (h *ErrorReportingHandler) ReportError(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportCreate)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request models.ErrorReportRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">report, err := h.errorReportingService.ReportError(userID, &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(report)</span>
}

func (h *ErrorReportingHandler) ReportCrash(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportCreate)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request models.CrashReportRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">report, err := h.errorReportingService.ReportCrash(userID, &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(report)</span>
}

func (h *ErrorReportingHandler) GetErrorReport(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        reportID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid report ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">report, err := h.errorReportingService.GetErrorReport(reportID, userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(report)</span>
}

func (h *ErrorReportingHandler) GetCrashReport(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        reportID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid report ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">report, err := h.errorReportingService.GetCrashReport(reportID, userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(report)</span>
}

func (h *ErrorReportingHandler) ListErrorReports(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">filters := h.parseErrorReportFilters(r)
        reports, err := h.errorReportingService.GetErrorReportsByUser(userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "reports": reports,
                "filters": filters,
        })</span>
}

func (h *ErrorReportingHandler) ListCrashReports(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">filters := h.parseCrashReportFilters(r)
        reports, err := h.errorReportingService.GetCrashReportsByUser(userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "reports": reports,
                "filters": filters,
        })</span>
}

func (h *ErrorReportingHandler) UpdateErrorStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        reportID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid report ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportCreate)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request struct {
                Status string `json:"status"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.errorReportingService.UpdateErrorStatus(reportID, userID, request.Status)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *ErrorReportingHandler) UpdateCrashStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        reportID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid report ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportCreate)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request struct {
                Status string `json:"status"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.errorReportingService.UpdateCrashStatus(reportID, userID, request.Status)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *ErrorReportingHandler) GetErrorStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.errorReportingService.GetErrorStatistics(userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

func (h *ErrorReportingHandler) GetCrashStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.errorReportingService.GetCrashStatistics(userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

func (h *ErrorReportingHandler) GetSystemHealth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">health, err := h.errorReportingService.GetSystemHealth()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(health)</span>
}

func (h *ErrorReportingHandler) UpdateConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var config services.ErrorReportingConfig
        if err := json.NewDecoder(r.Body).Decode(&amp;config); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.errorReportingService.UpdateConfiguration(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "message": "Configuration updated successfully",
        })</span>
}

func (h *ErrorReportingHandler) GetConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">config := h.errorReportingService.GetConfiguration()

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(config)</span>
}

func (h *ErrorReportingHandler) CleanupOldReports(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request struct {
                DaysOld int `json:"days_old"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if request.DaysOld &lt;= 0 </span><span class="cov0" title="0">{
                request.DaysOld = 30 // Default to 30 days
        }</span>

        <span class="cov0" title="0">olderThan := time.Now().AddDate(0, 0, -request.DaysOld)
        err = h.errorReportingService.CleanupOldReports(olderThan)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "message": "Cleanup completed successfully",
        })</span>
}

func (h *ErrorReportingHandler) ExportReports(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionReportView)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">filters := h.parseExportFilters(r)
        data, err := h.errorReportingService.ExportReports(userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Set appropriate content type and headers
        <span class="cov0" title="0">switch filters.Format </span>{
        case "json":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "application/json")
                w.Header().Set("Content-Disposition", "attachment; filename=error_reports.json")</span>
        case "csv":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "text/csv")
                w.Header().Set("Content-Disposition", "attachment; filename=error_reports.csv")</span>
        default:<span class="cov0" title="0">
                w.Header().Set("Content-Type", "application/octet-stream")
                w.Header().Set("Content-Disposition", "attachment; filename=error_reports.txt")</span>
        }

        <span class="cov0" title="0">w.Write(data)</span>
}

// Helper methods

func (h *ErrorReportingHandler) parseErrorReportFilters(r *http.Request) *models.ErrorReportFilters <span class="cov0" title="0">{
        filters := &amp;models.ErrorReportFilters{}

        if level := r.URL.Query().Get("level"); level != "" </span><span class="cov0" title="0">{
                filters.Level = level
        }</span>

        <span class="cov0" title="0">if component := r.URL.Query().Get("component"); component != "" </span><span class="cov0" title="0">{
                filters.Component = component
        }</span>

        <span class="cov0" title="0">if status := r.URL.Query().Get("status"); status != "" </span><span class="cov0" title="0">{
                filters.Status = status
        }</span>

        <span class="cov0" title="0">if startDate := r.URL.Query().Get("start_date"); startDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", startDate); err == nil </span><span class="cov0" title="0">{
                        filters.StartDate = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if endDate := r.URL.Query().Get("end_date"); endDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", endDate); err == nil </span><span class="cov0" title="0">{
                        filters.EndDate = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limit &gt; 0 </span><span class="cov0" title="0">{
                        filters.Limit = limit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if offset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; offset &gt;= 0 </span><span class="cov0" title="0">{
                        filters.Offset = offset
                }</span>
        }

        <span class="cov0" title="0">return filters</span>
}

func (h *ErrorReportingHandler) parseCrashReportFilters(r *http.Request) *models.CrashReportFilters <span class="cov0" title="0">{
        filters := &amp;models.CrashReportFilters{}

        if signal := r.URL.Query().Get("signal"); signal != "" </span><span class="cov0" title="0">{
                filters.Signal = signal
        }</span>

        <span class="cov0" title="0">if status := r.URL.Query().Get("status"); status != "" </span><span class="cov0" title="0">{
                filters.Status = status
        }</span>

        <span class="cov0" title="0">if startDate := r.URL.Query().Get("start_date"); startDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", startDate); err == nil </span><span class="cov0" title="0">{
                        filters.StartDate = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if endDate := r.URL.Query().Get("end_date"); endDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", endDate); err == nil </span><span class="cov0" title="0">{
                        filters.EndDate = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limit &gt; 0 </span><span class="cov0" title="0">{
                        filters.Limit = limit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if offset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; offset &gt;= 0 </span><span class="cov0" title="0">{
                        filters.Offset = offset
                }</span>
        }

        <span class="cov0" title="0">return filters</span>
}

func (h *ErrorReportingHandler) parseExportFilters(r *http.Request) *models.ExportFilters <span class="cov0" title="0">{
        filters := &amp;models.ExportFilters{
                Format:         "json", // Default format
                IncludeErrors:  true,   // Default to include errors
                IncludeCrashes: true,   // Default to include crashes
        }

        if format := r.URL.Query().Get("format"); format != "" </span><span class="cov0" title="0">{
                filters.Format = format
        }</span>

        <span class="cov0" title="0">if level := r.URL.Query().Get("level"); level != "" </span><span class="cov0" title="0">{
                filters.Level = level
        }</span>

        <span class="cov0" title="0">if component := r.URL.Query().Get("component"); component != "" </span><span class="cov0" title="0">{
                filters.Component = component
        }</span>

        <span class="cov0" title="0">if signal := r.URL.Query().Get("signal"); signal != "" </span><span class="cov0" title="0">{
                filters.Signal = signal
        }</span>

        <span class="cov0" title="0">if startDate := r.URL.Query().Get("start_date"); startDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", startDate); err == nil </span><span class="cov0" title="0">{
                        filters.StartDate = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if endDate := r.URL.Query().Get("end_date"); endDate != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse("2006-01-02", endDate); err == nil </span><span class="cov0" title="0">{
                        filters.EndDate = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limit &gt; 0 </span><span class="cov0" title="0">{
                        filters.Limit = limit
                }</span>
        }

        <span class="cov0" title="0">if includeErrors := r.URL.Query().Get("include_errors"); includeErrors == "false" </span><span class="cov0" title="0">{
                filters.IncludeErrors = false
        }</span>

        <span class="cov0" title="0">if includeCrashes := r.URL.Query().Get("include_crashes"); includeCrashes == "false" </span><span class="cov0" title="0">{
                filters.IncludeCrashes = false
        }</span>

        <span class="cov0" title="0">return filters</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "time"

        "catalogizer/models"
        "catalogizer/services"

        "github.com/gorilla/mux"
)

type LogManagementHandler struct {
        logManagementService *services.LogManagementService
        authService          *services.AuthService
}

func NewLogManagementHandler(logManagementService *services.LogManagementService, authService *services.AuthService) *LogManagementHandler <span class="cov0" title="0">{
        return &amp;LogManagementHandler{
                logManagementService: logManagementService,
                authService:          authService,
        }
}</span>

func (h *LogManagementHandler) CreateLogCollection(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request models.LogCollectionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">collection, err := h.logManagementService.CollectLogs(userID, &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(collection)</span>
}

func (h *LogManagementHandler) GetLogCollection(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        collectionID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid collection ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">collection, err := h.logManagementService.GetLogCollection(collectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(collection)</span>
}

func (h *LogManagementHandler) ListLogCollections(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")

        limit := 20 // Default limit
        offset := 0 // Default offset

        if limitStr != "" </span><span class="cov0" title="0">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 </span><span class="cov0" title="0">{
                        limit = parsedLimit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if parsedOffset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; parsedOffset &gt;= 0 </span><span class="cov0" title="0">{
                        offset = parsedOffset
                }</span>
        }

        <span class="cov0" title="0">collections, err := h.logManagementService.GetLogCollectionsByUser(userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "collections": collections,
                "limit":       limit,
                "offset":      offset,
        })</span>
}

func (h *LogManagementHandler) GetLogEntries(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        collectionID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid collection ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">filters := h.parseLogEntryFilters(r)
        entries, err := h.logManagementService.GetLogEntries(collectionID, userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "entries": entries,
                "filters": filters,
        })</span>
}

func (h *LogManagementHandler) CreateLogShare(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var request models.LogShareRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">share, err := h.logManagementService.CreateLogShare(userID, &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(share)</span>
}

func (h *LogManagementHandler) GetLogShare(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        token := vars["token"]

        share, err := h.logManagementService.GetLogShare(token)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        // Get the collection
        <span class="cov0" title="0">collection, err := h.logManagementService.GetLogCollection(share.CollectionID, share.UserID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        // Check permissions
        <span class="cov0" title="0">canRead := false
        for _, permission := range share.Permissions </span><span class="cov0" title="0">{
                if permission == "read" </span><span class="cov0" title="0">{
                        canRead = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !canRead </span><span class="cov0" title="0">{
                http.Error(w, "Access denied", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "share":      share,
                "collection": collection,
        })</span>
}

func (h *LogManagementHandler) RevokeLogShare(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        shareID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid share ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">err = h.logManagementService.RevokeLogShare(shareID, userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *LogManagementHandler) ExportLogs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        collectionID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid collection ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">format := r.URL.Query().Get("format")
        if format == "" </span><span class="cov0" title="0">{
                format = "json" // Default format
        }</span>

        <span class="cov0" title="0">data, err := h.logManagementService.ExportLogs(collectionID, userID, format)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Set appropriate content type and headers
        <span class="cov0" title="0">switch format </span>{
        case "json":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "application/json")
                w.Header().Set("Content-Disposition", "attachment; filename=logs.json")</span>
        case "csv":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "text/csv")
                w.Header().Set("Content-Disposition", "attachment; filename=logs.csv")</span>
        case "txt":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "text/plain")
                w.Header().Set("Content-Disposition", "attachment; filename=logs.txt")</span>
        case "zip":<span class="cov0" title="0">
                w.Header().Set("Content-Type", "application/zip")
                w.Header().Set("Content-Disposition", "attachment; filename=logs.zip")</span>
        default:<span class="cov0" title="0">
                w.Header().Set("Content-Type", "application/octet-stream")
                w.Header().Set("Content-Disposition", "attachment; filename=logs.bin")</span>
        }

        <span class="cov0" title="0">w.Write(data)</span>
}

func (h *LogManagementHandler) StreamLogs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        // Parse stream filters
        <span class="cov0" title="0">filters := h.parseLogStreamFilters(r)

        // Setup Server-Sent Events
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        w.Header().Set("Access-Control-Allow-Origin", "*")

        // Get log stream
        logChannel, err := h.logManagementService.StreamLogs(userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Stream logs to client
        <span class="cov0" title="0">flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Streaming not supported", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case entry, ok := &lt;-logChannel:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">data, err := json.Marshal(entry)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">w.Write([]byte("data: "))
                        w.Write(data)
                        w.Write([]byte("\n\n"))
                        flusher.Flush()</span>

                case &lt;-r.Context().Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (h *LogManagementHandler) AnalyzeLogs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)
        vars := mux.Vars(r)
        collectionID, err := strconv.Atoi(vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid collection ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">analysis, err := h.logManagementService.AnalyzeLogs(collectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(analysis)</span>
}

func (h *LogManagementHandler) GetLogStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.logManagementService.GetLogStatistics(userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

func (h *LogManagementHandler) GetConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">config := h.logManagementService.GetConfiguration()

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(config)</span>
}

func (h *LogManagementHandler) UpdateConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var config services.LogManagementConfig
        if err := json.NewDecoder(r.Body).Decode(&amp;config); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.logManagementService.UpdateConfiguration(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "message": "Configuration updated successfully",
        })</span>
}

func (h *LogManagementHandler) CleanupOldLogs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">err = h.logManagementService.CleanupOldLogs()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "message": "Cleanup completed successfully",
        })</span>
}

// Helper methods

func (h *LogManagementHandler) parseLogEntryFilters(r *http.Request) *models.LogEntryFilters <span class="cov0" title="0">{
        filters := &amp;models.LogEntryFilters{}

        if level := r.URL.Query().Get("level"); level != "" </span><span class="cov0" title="0">{
                filters.Level = level
        }</span>

        <span class="cov0" title="0">if component := r.URL.Query().Get("component"); component != "" </span><span class="cov0" title="0">{
                filters.Component = component
        }</span>

        <span class="cov0" title="0">if search := r.URL.Query().Get("search"); search != "" </span><span class="cov0" title="0">{
                filters.Search = search
        }</span>

        <span class="cov0" title="0">if startTime := r.URL.Query().Get("start_time"); startTime != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse(time.RFC3339, startTime); err == nil </span><span class="cov0" title="0">{
                        filters.StartTime = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if endTime := r.URL.Query().Get("end_time"); endTime != "" </span><span class="cov0" title="0">{
                if date, err := time.Parse(time.RFC3339, endTime); err == nil </span><span class="cov0" title="0">{
                        filters.EndTime = &amp;date
                }</span>
        }

        <span class="cov0" title="0">if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limit &gt; 0 </span><span class="cov0" title="0">{
                        filters.Limit = limit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if offset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; offset &gt;= 0 </span><span class="cov0" title="0">{
                        filters.Offset = offset
                }</span>
        }

        <span class="cov0" title="0">return filters</span>
}

func (h *LogManagementHandler) parseLogStreamFilters(r *http.Request) *models.LogStreamFilters <span class="cov0" title="0">{
        filters := &amp;models.LogStreamFilters{}

        if level := r.URL.Query().Get("level"); level != "" </span><span class="cov0" title="0">{
                filters.Level = level
        }</span>

        <span class="cov0" title="0">if component := r.URL.Query().Get("component"); component != "" </span><span class="cov0" title="0">{
                filters.Component = component
        }</span>

        <span class="cov0" title="0">if search := r.URL.Query().Get("search"); search != "" </span><span class="cov0" title="0">{
                filters.Search = search
        }</span>

        <span class="cov0" title="0">return filters</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "strings"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/services"
)

type RoleHandler struct {
        userRepo    *repository.UserRepository
        authService *services.AuthService
}

func NewRoleHandler(userRepo *repository.UserRepository, authService *services.AuthService) *RoleHandler <span class="cov0" title="0">{
        return &amp;RoleHandler{
                userRepo:    userRepo,
                authService: authService,
        }
}</span>

func (h *RoleHandler) CreateRole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateRoleRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">role := &amp;models.Role{
                Name:        req.Name,
                Description: req.Description,
                Permissions: req.Permissions,
                IsSystem:    false,
        }

        id, err := h.userRepo.CreateRole(role)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "UNIQUE constraint failed") </span><span class="cov0" title="0">{
                        http.Error(w, "Role name already exists", http.StatusConflict)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to create role", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">role.ID = id

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(role)</span>
}

func (h *RoleHandler) GetRole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">roleIDStr := strings.TrimPrefix(r.URL.Path, "/api/roles/")
        roleID, err := strconv.Atoi(roleIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid role ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">role, err := h.userRepo.GetRole(roleID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        http.Error(w, "Role not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to get role", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(role)</span>
}

func (h *RoleHandler) UpdateRole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPut </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">roleIDStr := strings.TrimPrefix(r.URL.Path, "/api/roles/")
        roleID, err := strconv.Atoi(roleIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid role ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateRoleRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">role := &amp;models.Role{
                ID:          roleID,
                Name:        *req.Name,
                Description: req.Description,
                Permissions: req.Permissions,
        }

        err = h.userRepo.UpdateRole(role)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "system role") </span><span class="cov0" title="0">{
                        http.Error(w, "Role not found or is system role", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "UNIQUE constraint failed") </span><span class="cov0" title="0">{
                        http.Error(w, "Role name already exists", http.StatusConflict)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to update role", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">updatedRole, err := h.userRepo.GetRole(roleID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get updated role", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(updatedRole)</span>
}

func (h *RoleHandler) DeleteRole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodDelete </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">roleIDStr := strings.TrimPrefix(r.URL.Path, "/api/roles/")
        roleID, err := strconv.Atoi(roleIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid role ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.userRepo.DeleteRole(roleID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") || strings.Contains(err.Error(), "system role") </span><span class="cov0" title="0">{
                        http.Error(w, "Role not found or is system role", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "assigned to users") </span><span class="cov0" title="0">{
                        http.Error(w, "Cannot delete role that is assigned to users", http.StatusConflict)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to delete role", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *RoleHandler) ListRoles(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">roles, err := h.userRepo.ListRoles()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to list roles", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(roles)</span>
}

func (h *RoleHandler) GetPermissions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">permissions := map[string]interface{}{
                "user_management": map[string]string{
                        "create_user":  models.PermissionUserCreate,
                        "view_user":    models.PermissionUserView,
                        "edit_user":    models.PermissionUserUpdate,
                        "delete_user":  models.PermissionUserDelete,
                        "manage_users": models.PermissionUserManage,
                },
                "role_management": map[string]string{
                        "view_roles":   models.PermissionSystemAdmin,
                        "manage_roles": models.PermissionSystemAdmin,
                },
                "media_management": map[string]string{
                        "view_media":   models.PermissionMediaView,
                        "upload_media": models.PermissionMediaUpload,
                        "edit_media":   models.PermissionMediaEdit,
                        "delete_media": models.PermissionMediaDelete,
                },
                "share_management": map[string]string{
                        "view_shares":   models.PermissionShareView,
                        "create_shares": models.PermissionShareCreate,
                        "edit_shares":   models.PermissionShareEdit,
                        "delete_shares": models.PermissionShareDelete,
                },
                "system": map[string]string{
                        "system_admin":    models.PermissionSystemAdmin,
                        "view_analytics":  models.PermissionAnalyticsView,
                        "export_data":     models.PermissionAnalyticsExport,
                        "manage_settings": models.PermissionSystemConfig,
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(permissions)</span>
}

func (h *RoleHandler) getCurrentUser(r *http.Request) (*models.User, error) <span class="cov0" title="0">{
        token := extractToken(r)
        if token == "" </span><span class="cov0" title="0">{
                return nil, models.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return h.authService.GetCurrentUser(token)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handlers

import (
        "net/http"
        "strconv"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/utils"

        "github.com/gin-gonic/gin"
)

// SearchHandler handles search operations
type SearchHandler struct {
        fileRepo *repository.FileRepository
}

// NewSearchHandler creates a new search handler
func NewSearchHandler(fileRepo *repository.FileRepository) *SearchHandler <span class="cov7" title="11">{
        return &amp;SearchHandler{
                fileRepo: fileRepo,
        }
}</span>

// SearchFiles godoc
// @Summary Search files
// @Description Perform advanced file search with filters and sorting
// @Tags search
// @Accept json
// @Produce json
// @Param q query string false "Search query (searches in filename and path)"
// @Param path query string false "Path filter (partial match)"
// @Param name query string false "Name filter (partial match)"
// @Param extension query string false "File extension filter (exact match)"
// @Param file_type query string false "File type filter (exact match)"
// @Param mime_type query string false "MIME type filter (exact match)"
// @Param smb_roots query string false "SMB roots filter (comma-separated list)"
// @Param min_size query int false "Minimum file size in bytes"
// @Param max_size query int false "Maximum file size in bytes"
// @Param modified_after query string false "Modified after date (RFC3339 format)"
// @Param modified_before query string false "Modified before date (RFC3339 format)"
// @Param include_deleted query bool false "Include deleted files" default(false)
// @Param only_duplicates query bool false "Only show duplicate files" default(false)
// @Param exclude_duplicates query bool false "Exclude duplicate files" default(false)
// @Param include_directories query bool false "Include directories" default(true)
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(100)
// @Param sort_by query string false "Sort field (name, size, modified_at, created_at, path, extension)" default("name")
// @Param sort_order query string false "Sort order (asc, desc)" default("asc")
// @Success 200 {object} models.SearchResult
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/search [get]
func (h *SearchHandler) SearchFiles(c *gin.Context) <span class="cov6" title="7">{
        ctx := c.Request.Context()

        // Parse search filters
        filter := models.SearchFilter{
                Query:              c.Query("q"),
                Path:               c.Query("path"),
                Name:               c.Query("name"),
                Extension:          c.Query("extension"),
                FileType:           c.Query("file_type"),
                MimeType:           c.Query("mime_type"),
                IncludeDeleted:     parseBool(c.Query("include_deleted"), false),
                OnlyDuplicates:     parseBool(c.Query("only_duplicates"), false),
                ExcludeDuplicates:  parseBool(c.Query("exclude_duplicates"), false),
                IncludeDirectories: parseBool(c.Query("include_directories"), true),
        }

        // Parse SMB roots filter
        if smbRootsStr := c.Query("smb_roots"); smbRootsStr != "" </span><span class="cov0" title="0">{
                filter.StorageRoots = strings.Split(smbRootsStr, ",")
                // Trim whitespace from each root name
                for i := range filter.StorageRoots </span><span class="cov0" title="0">{
                        filter.StorageRoots[i] = strings.TrimSpace(filter.StorageRoots[i])
                }</span>
        }

        // Parse size filters
        <span class="cov6" title="7">if minSizeStr := c.Query("min_size"); minSizeStr != "" </span><span class="cov0" title="0">{
                if minSize, err := strconv.ParseInt(minSizeStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        filter.MinSize = &amp;minSize
                }</span>
        }
        <span class="cov6" title="7">if maxSizeStr := c.Query("max_size"); maxSizeStr != "" </span><span class="cov0" title="0">{
                if maxSize, err := strconv.ParseInt(maxSizeStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        filter.MaxSize = &amp;maxSize
                }</span>
        }

        // Parse date filters
        <span class="cov6" title="7">if modifiedAfterStr := c.Query("modified_after"); modifiedAfterStr != "" </span><span class="cov5" title="6">{
                if modifiedAfter, err := time.Parse(time.RFC3339, modifiedAfterStr); err == nil </span><span class="cov0" title="0">{
                        filter.ModifiedAfter = &amp;modifiedAfter
                }</span> else<span class="cov5" title="6"> {
                        utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid modified_after date format. Use RFC3339 format", err)
                        return
                }</span>
        }
        <span class="cov1" title="1">if modifiedBeforeStr := c.Query("modified_before"); modifiedBeforeStr != "" </span><span class="cov1" title="1">{
                if modifiedBefore, err := time.Parse(time.RFC3339, modifiedBeforeStr); err == nil </span><span class="cov0" title="0">{
                        filter.ModifiedBefore = &amp;modifiedBefore
                }</span> else<span class="cov1" title="1"> {
                        utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid modified_before date format. Use RFC3339 format", err)
                        return
                }</span>
        }

        // Parse pagination
        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "100"))
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit &lt; 1 || limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">pagination := models.PaginationOptions{
                Page:  page,
                Limit: limit,
        }

        // Parse sorting
        sortBy := c.DefaultQuery("sort_by", "name")
        sortOrder := c.DefaultQuery("sort_order", "asc")

        validSortFields := map[string]bool{
                "name":        true,
                "size":        true,
                "modified_at": true,
                "created_at":  true,
                "path":        true,
                "extension":   true,
        }
        if !validSortFields[sortBy] </span><span class="cov0" title="0">{
                sortBy = "name"
        }</span>
        <span class="cov0" title="0">if sortOrder != "asc" &amp;&amp; sortOrder != "desc" </span><span class="cov0" title="0">{
                sortOrder = "asc"
        }</span>

        <span class="cov0" title="0">sort := models.SortOptions{
                Field: sortBy,
                Order: sortOrder,
        }

        // Perform search
        result, err := h.fileRepo.SearchFiles(ctx, filter, pagination, sort)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Search failed", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// SearchDuplicates godoc
// @Summary Search duplicate files
// @Description Find duplicate files across all SMB roots or within specific roots
// @Tags search
// @Accept json
// @Produce json
// @Param smb_roots query string false "SMB roots filter (comma-separated list)"
// @Param min_size query int false "Minimum file size in bytes"
// @Param max_size query int false "Maximum file size in bytes"
// @Param file_type query string false "File type filter"
// @Param extension query string false "File extension filter"
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(100)
// @Param sort_by query string false "Sort field (name, size, modified_at, path)" default("name")
// @Param sort_order query string false "Sort order (asc, desc)" default("asc")
// @Success 200 {object} models.SearchResult
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/search/duplicates [get]
func (h *SearchHandler) SearchDuplicates(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        // Create search filter for duplicates only
        filter := models.SearchFilter{
                OnlyDuplicates:     true,
                IncludeDirectories: false, // Duplicates only apply to files
                FileType:           c.Query("file_type"),
                Extension:          c.Query("extension"),
        }

        // Parse SMB roots filter
        if smbRootsStr := c.Query("smb_roots"); smbRootsStr != "" </span><span class="cov0" title="0">{
                filter.StorageRoots = strings.Split(smbRootsStr, ",")
                for i := range filter.StorageRoots </span><span class="cov0" title="0">{
                        filter.StorageRoots[i] = strings.TrimSpace(filter.StorageRoots[i])
                }</span>
        }

        // Parse size filters
        <span class="cov0" title="0">if minSizeStr := c.Query("min_size"); minSizeStr != "" </span><span class="cov0" title="0">{
                if minSize, err := strconv.ParseInt(minSizeStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        filter.MinSize = &amp;minSize
                }</span>
        }
        <span class="cov0" title="0">if maxSizeStr := c.Query("max_size"); maxSizeStr != "" </span><span class="cov0" title="0">{
                if maxSize, err := strconv.ParseInt(maxSizeStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        filter.MaxSize = &amp;maxSize
                }</span>
        }

        // Parse pagination
        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "100"))
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit &lt; 1 || limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">pagination := models.PaginationOptions{
                Page:  page,
                Limit: limit,
        }

        // Parse sorting
        sortBy := c.DefaultQuery("sort_by", "name")
        sortOrder := c.DefaultQuery("sort_order", "asc")

        validSortFields := map[string]bool{
                "name":        true,
                "size":        true,
                "modified_at": true,
                "path":        true,
        }
        if !validSortFields[sortBy] </span><span class="cov0" title="0">{
                sortBy = "name"
        }</span>
        <span class="cov0" title="0">if sortOrder != "asc" &amp;&amp; sortOrder != "desc" </span><span class="cov0" title="0">{
                sortOrder = "asc"
        }</span>

        <span class="cov0" title="0">sort := models.SortOptions{
                Field: sortBy,
                Order: sortOrder,
        }

        // Perform search
        result, err := h.fileRepo.SearchFiles(ctx, filter, pagination, sort)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Duplicate search failed", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// AdvancedSearch godoc
// @Summary Advanced search with POST body
// @Description Perform advanced file search using POST body for complex filters
// @Tags search
// @Accept json
// @Produce json
// @Param body body SearchRequest true "Search request"
// @Success 200 {object} models.SearchResult
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/search/advanced [post]
func (h *SearchHandler) AdvancedSearch(c *gin.Context) <span class="cov1" title="1">{
        ctx := c.Request.Context()

        var req SearchRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        // Validate pagination
        <span class="cov0" title="0">if req.Page &lt; 1 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.Limit &lt; 1 || req.Limit &gt; 1000 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate sorting
        <span class="cov0" title="0">validSortFields := map[string]bool{
                "name":        true,
                "size":        true,
                "modified_at": true,
                "created_at":  true,
                "path":        true,
                "extension":   true,
        }
        if !validSortFields[req.SortBy] </span><span class="cov0" title="0">{
                req.SortBy = "name"
        }</span>
        <span class="cov0" title="0">if req.SortOrder != "asc" &amp;&amp; req.SortOrder != "desc" </span><span class="cov0" title="0">{
                req.SortOrder = "asc"
        }</span>

        <span class="cov0" title="0">pagination := models.PaginationOptions{
                Page:  req.Page,
                Limit: req.Limit,
        }

        sort := models.SortOptions{
                Field: req.SortBy,
                Order: req.SortOrder,
        }

        // Perform search
        result, err := h.fileRepo.SearchFiles(ctx, req.Filter, pagination, sort)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Advanced search failed", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    result,
        })</span>
}

// SearchRequest represents the request body for advanced search
type SearchRequest struct {
        Filter    models.SearchFilter `json:"filter"`
        Page      int                 `json:"page"`
        Limit     int                 `json:"limit"`
        SortBy    string              `json:"sort_by"`
        SortOrder string              `json:"sort_order"`
}

// Helper function to parse boolean query parameters
func parseBool(value string, defaultValue bool) bool <span class="cov10" title="28">{
        if value == "" </span><span class="cov10" title="28">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">result, err := strconv.ParseBool(value)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "catalogizer/internal/models"
        "catalogizer/repository"
        "catalogizer/utils"

        "github.com/gin-gonic/gin"
)

// StatsHandler handles statistics and analytics operations
type StatsHandler struct {
        fileRepo  *repository.FileRepository
        statsRepo *repository.StatsRepository
}

// NewStatsHandler creates a new stats handler
func NewStatsHandler(fileRepo *repository.FileRepository, statsRepo *repository.StatsRepository) *StatsHandler <span class="cov10" title="9">{
        return &amp;StatsHandler{
                fileRepo:  fileRepo,
                statsRepo: statsRepo,
        }
}</span>

// GetOverallStats godoc
// @Summary Get overall catalog statistics
// @Description Get comprehensive statistics about the entire catalog
// @Tags stats
// @Accept json
// @Produce json
// @Success 200 {object} OverallStats
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/overall [get]
func (h *StatsHandler) GetOverallStats(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        stats, err := h.statsRepo.GetOverallStats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get overall stats", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    stats,
        })</span>
}

// GetSmbRootStats godoc
// @Summary Get SMB root statistics
// @Description Get statistics for a specific SMB root
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root path string true "SMB root name"
// @Success 200 {object} SmbRootStats
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 404 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/smb/{smb_root} [get]
func (h *StatsHandler) GetSmbRootStats(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Param("smb_root")
        if smbRootName == "" </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "SMB root name is required", nil)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.statsRepo.GetStorageRootStats(ctx, smbRootName)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "smb root not found" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusNotFound, "SMB root not found", err)
                        return
                }</span>
                <span class="cov0" title="0">utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get SMB root stats", err)
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    stats,
        })</span>
}

// GetFileTypeStats godoc
// @Summary Get file type statistics
// @Description Get statistics about different file types across all or specific SMB roots
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root query string false "SMB root name filter"
// @Param limit query int false "Maximum number of results" default(50)
// @Success 200 {array} FileTypeStats
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/filetypes [get]
func (h *StatsHandler) GetFileTypeStats(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Query("smb_root")
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))

        if limit &lt;= 0 || limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">stats, err := h.statsRepo.GetFileTypeStats(ctx, smbRootName, limit)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get file type stats", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    stats,
        })</span>
}

// GetSizeDistribution godoc
// @Summary Get file size distribution
// @Description Get statistics about file size distribution
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root query string false "SMB root name filter"
// @Success 200 {object} SizeDistribution
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/sizes [get]
func (h *StatsHandler) GetSizeDistribution(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Query("smb_root")

        distribution, err := h.statsRepo.GetSizeDistribution(ctx, smbRootName)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get size distribution", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    distribution,
        })</span>
}

// GetDuplicateStats godoc
// @Summary Get duplicate file statistics
// @Description Get statistics about duplicate files
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root query string false "SMB root name filter"
// @Success 200 {object} DuplicateStats
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/duplicates [get]
func (h *StatsHandler) GetDuplicateStats(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Query("smb_root")

        stats, err := h.statsRepo.GetDuplicateStats(ctx, smbRootName)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get duplicate stats", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    stats,
        })</span>
}

// GetTopDuplicateGroups godoc
// @Summary Get top duplicate groups
// @Description Get the largest duplicate groups by file count or total size
// @Tags stats
// @Accept json
// @Produce json
// @Param sort_by query string false "Sort by: count or size" default("count")
// @Param limit query int false "Maximum number of results" default(20)
// @Param smb_root query string false "SMB root name filter"
// @Success 200 {array} DuplicateGroupStats
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/duplicates/groups [get]
func (h *StatsHandler) GetTopDuplicateGroups(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        sortBy := c.DefaultQuery("sort_by", "count")
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        smbRootName := c.Query("smb_root")

        if sortBy != "count" &amp;&amp; sortBy != "size" </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusBadRequest, "sort_by must be 'count' or 'size'", nil)
                return
        }</span>

        <span class="cov0" title="0">if limit &lt;= 0 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">groups, err := h.statsRepo.GetTopDuplicateGroups(ctx, sortBy, limit, smbRootName)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get top duplicate groups", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    groups,
        })</span>
}

// GetAccessPatterns godoc
// @Summary Get file access patterns
// @Description Get statistics about file access patterns over time
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root query string false "SMB root name filter"
// @Param days query int false "Number of days to analyze" default(30)
// @Success 200 {object} AccessPatterns
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/access [get]
func (h *StatsHandler) GetAccessPatterns(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Query("smb_root")
        days, _ := strconv.Atoi(c.DefaultQuery("days", "30"))

        if days &lt;= 0 || days &gt; 365 </span><span class="cov0" title="0">{
                days = 30
        }</span>

        <span class="cov0" title="0">patterns, err := h.statsRepo.GetAccessPatterns(ctx, smbRootName, days)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get access patterns", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    patterns,
        })</span>
}

// GetGrowthTrends godoc
// @Summary Get storage growth trends
// @Description Get statistics about storage growth over time
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root query string false "SMB root name filter"
// @Param months query int false "Number of months to analyze" default(12)
// @Success 200 {object} GrowthTrends
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/growth [get]
func (h *StatsHandler) GetGrowthTrends(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Query("smb_root")
        months, _ := strconv.Atoi(c.DefaultQuery("months", "12"))

        if months &lt;= 0 || months &gt; 60 </span><span class="cov0" title="0">{
                months = 12
        }</span>

        <span class="cov0" title="0">trends, err := h.statsRepo.GetGrowthTrends(ctx, smbRootName, months)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get growth trends", err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    trends,
        })</span>
}

// GetScanHistory godoc
// @Summary Get scan history
// @Description Get history of scan operations
// @Tags stats
// @Accept json
// @Produce json
// @Param smb_root query string false "SMB root name filter"
// @Param limit query int false "Maximum number of results" default(50)
// @Param offset query int false "Number of results to skip" default(0)
// @Success 200 {object} ScanHistoryResponse
// @Failure 400 {object} utils.SendErrorResponse
// @Failure 500 {object} utils.SendErrorResponse
// @Router /api/stats/scans [get]
func (h *StatsHandler) GetScanHistory(c *gin.Context) <span class="cov0" title="0">{
        ctx := c.Request.Context()

        smbRootName := c.Query("smb_root")
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        if limit &lt;= 0 || limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">history, totalCount, err := h.statsRepo.GetScanHistory(ctx, smbRootName, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendErrorResponse(c, http.StatusInternalServerError, "Failed to get scan history", err)
                return
        }</span>

        <span class="cov0" title="0">response := ScanHistoryResponse{
                Scans:      history,
                TotalCount: totalCount,
                Limit:      limit,
                Offset:     offset,
        }

        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    response,
        })</span>
}

// Response types for statistics endpoints
type ScanHistoryResponse struct {
        Scans      []models.ScanHistoryItem `json:"scans"`
        TotalCount int64                    `json:"total_count"`
        Limit      int                      `json:"limit"`
        Offset     int                      `json:"offset"`
}

// These types would typically be defined in a separate stats models package
type OverallStats struct {
        TotalFiles         int64 `json:"total_files"`
        TotalDirectories   int64 `json:"total_directories"`
        TotalSize          int64 `json:"total_size"`
        TotalDuplicates    int64 `json:"total_duplicates"`
        DuplicateGroups    int64 `json:"duplicate_groups"`
        StorageRootsCount  int64 `json:"storage_roots_count"`
        ActiveStorageRoots int64 `json:"active_storage_roots"`
        LastScanTime       int64 `json:"last_scan_time"`
}

type StorageRootStats struct {
        Name             string `json:"name"`
        TotalFiles       int64  `json:"total_files"`
        TotalDirectories int64  `json:"total_directories"`
        TotalSize        int64  `json:"total_size"`
        DuplicateFiles   int64  `json:"duplicate_files"`
        DuplicateGroups  int64  `json:"duplicate_groups"`
        LastScanTime     int64  `json:"last_scan_time"`
        IsOnline         bool   `json:"is_online"`
}

type FileTypeStats struct {
        FileType    string `json:"file_type"`
        Extension   string `json:"extension"`
        Count       int64  `json:"count"`
        TotalSize   int64  `json:"total_size"`
        AverageSize int64  `json:"average_size"`
}

type SizeDistribution struct {
        Tiny    int64 `json:"tiny"`    // &lt; 1KB
        Small   int64 `json:"small"`   // 1KB - 1MB
        Medium  int64 `json:"medium"`  // 1MB - 10MB
        Large   int64 `json:"large"`   // 10MB - 100MB
        Huge    int64 `json:"huge"`    // 100MB - 1GB
        Massive int64 `json:"massive"` // &gt; 1GB
}

type DuplicateStats struct {
        TotalDuplicates       int64   `json:"total_duplicates"`
        DuplicateGroups       int64   `json:"duplicate_groups"`
        WastedSpace           int64   `json:"wasted_space"`
        LargestDuplicateGroup int     `json:"largest_duplicate_group"`
        AverageGroupSize      float64 `json:"average_group_size"`
}

type DuplicateGroupStats struct {
        GroupID     int64  `json:"group_id"`
        FileCount   int    `json:"file_count"`
        TotalSize   int64  `json:"total_size"`
        WastedSpace int64  `json:"wasted_space"`
        SamplePath  string `json:"sample_path"`
}

type AccessPatterns struct {
        RecentlyAccessed   int64    `json:"recently_accessed"`
        NeverAccessed      int64    `json:"never_accessed"`
        AccessFrequency    []int64  `json:"access_frequency"` // Daily access counts
        PopularExtensions  []string `json:"popular_extensions"`
        PopularDirectories []string `json:"popular_directories"`
}

type GrowthTrends struct {
        MonthlyGrowth   []MonthlyGrowth `json:"monthly_growth"`
        TotalGrowthRate float64         `json:"total_growth_rate"`
        FileGrowthRate  float64         `json:"file_growth_rate"`
        SizeGrowthRate  float64         `json:"size_growth_rate"`
}

type MonthlyGrowth struct {
        Month      string `json:"month"`
        FilesAdded int64  `json:"files_added"`
        SizeAdded  int64  `json:"size_added"`
        TotalFiles int64  `json:"total_files"`
        TotalSize  int64  `json:"total_size"`
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "catalogizer/models"
        "catalogizer/services"
)

type StressTestHandler struct {
        stressTestService *services.StressTestService
        authService       *services.AuthService
}

func NewStressTestHandler(stressTestService *services.StressTestService, authService *services.AuthService) *StressTestHandler <span class="cov0" title="0">{
        return &amp;StressTestHandler{
                stressTestService: stressTestService,
                authService:       authService,
        }
}</span>

// CreateStressTest creates a new stress test
func (h *StressTestHandler) CreateStressTest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Stress test creation not implemented"})</span>
}

// GetStressTest gets a stress test by ID
func (h *StressTestHandler) GetStressTest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get stress test not implemented"})</span>
}

// UpdateStressTest updates a stress test
func (h *StressTestHandler) UpdateStressTest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Update stress test not implemented"})</span>
}

// DeleteStressTest deletes a stress test
func (h *StressTestHandler) DeleteStressTest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Delete stress test not implemented"})</span>
}

// ListStressTests lists stress tests for a user
func (h *StressTestHandler) ListStressTests(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "List stress tests not implemented"})</span>
}

// StartStressTest starts a stress test
func (h *StressTestHandler) StartStressTest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Start stress test not implemented"})</span>
}

// StopStressTest stops a stress test
func (h *StressTestHandler) StopStressTest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Stop stress test not implemented"})</span>
}

// GetStressTestStatus gets the status of a stress test
func (h *StressTestHandler) GetStressTestStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get stress test status not implemented"})</span>
}

// GetStressTestResults gets the results of a stress test
func (h *StressTestHandler) GetStressTestResults(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get stress test results not implemented"})</span>
}

// GetStressTestExecution gets a specific execution
func (h *StressTestHandler) GetStressTestExecution(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get stress test execution not implemented"})</span>
}

// GetStressTestExecutions gets executions for a test
func (h *StressTestHandler) GetStressTestExecutions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get stress test executions not implemented"})</span>
}

// GetStressTestStatistics gets statistics for a test
func (h *StressTestHandler) GetStressTestStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get stress test statistics not implemented"})</span>
}

// GetSystemMetrics gets system metrics
func (h *StressTestHandler) GetSystemMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get system metrics not implemented"})</span>
}

// CleanupOldExecutions cleans up old executions
func (h *StressTestHandler) CleanupOldExecutions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Cleanup old executions not implemented"})</span>
}

// GetTestPresets gets test presets
func (h *StressTestHandler) GetTestPresets(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Get test presets not implemented"})</span>
}

// ValidateScenario validates a test scenario
func (h *StressTestHandler) ValidateScenario(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := r.Context().Value("user_id").(int)

        hasPermission, err := h.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil || !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"message": "Validate scenario not implemented"})</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/services"
)

type UserHandler struct {
        userRepo    *repository.UserRepository
        authService *services.AuthService
}

func NewUserHandler(userRepo *repository.UserRepository, authService *services.AuthService) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userRepo:    userRepo,
                authService: authService,
        }
}</span>

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserCreate)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.authService.ValidatePassword(req.Password); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">salt, err := h.authService.GenerateSecureToken(16)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate salt", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">passwordHash, err := h.hashPassword(req.Password, salt)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to hash password", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">isActive := true
        if req.IsActive != nil </span><span class="cov0" title="0">{
                isActive = *req.IsActive
        }</span>

        <span class="cov0" title="0">user := &amp;models.User{
                Username:     req.Username,
                Email:        req.Email,
                PasswordHash: passwordHash,
                Salt:         salt,
                RoleID:       req.RoleID,
                FirstName:    req.FirstName,
                LastName:     req.LastName,
                DisplayName:  req.DisplayName,
                TimeZone:     req.TimeZone,
                Language:     req.Language,
                IsActive:     isActive,
        }

        id, err := h.userRepo.Create(user)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "UNIQUE constraint failed") </span><span class="cov0" title="0">{
                        http.Error(w, "Username or email already exists", http.StatusConflict)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to create user", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">user.ID = id
        user.PasswordHash = ""
        user.Salt = ""

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(user)</span>
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strings.TrimPrefix(r.URL.Path, "/api/users/")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if currentUser.ID != userID </span><span class="cov0" title="0">{
                hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserView)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                        http.Error(w, "Insufficient permissions", http.StatusForbidden)
                        return
                }</span>
        }

        <span class="cov0" title="0">user, err := h.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        http.Error(w, "User not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to get user", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">role, err := h.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get user role", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">user.Role = role

        user.PasswordHash = ""
        user.Salt = ""

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)</span>
}

func (h *UserHandler) UpdateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPut </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strings.TrimPrefix(r.URL.Path, "/api/users/")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if currentUser.ID != userID </span><span class="cov0" title="0">{
                hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserUpdate)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                        http.Error(w, "Insufficient permissions", http.StatusForbidden)
                        return
                }</span>
        }

        <span class="cov0" title="0">var req models.UpdateUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        http.Error(w, "User not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to get user", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">if req.Username != nil </span><span class="cov0" title="0">{
                user.Username = *req.Username
        }</span>
        <span class="cov0" title="0">if req.Email != nil </span><span class="cov0" title="0">{
                user.Email = *req.Email
        }</span>
        <span class="cov0" title="0">if req.FirstName != nil </span><span class="cov0" title="0">{
                user.FirstName = req.FirstName
        }</span>
        <span class="cov0" title="0">if req.LastName != nil </span><span class="cov0" title="0">{
                user.LastName = req.LastName
        }</span>
        <span class="cov0" title="0">if req.DisplayName != nil </span><span class="cov0" title="0">{
                user.DisplayName = req.DisplayName
        }</span>
        <span class="cov0" title="0">if req.AvatarURL != nil </span><span class="cov0" title="0">{
                user.AvatarURL = req.AvatarURL
        }</span>
        <span class="cov0" title="0">if req.TimeZone != nil </span><span class="cov0" title="0">{
                user.TimeZone = req.TimeZone
        }</span>
        <span class="cov0" title="0">if req.Language != nil </span><span class="cov0" title="0">{
                user.Language = req.Language
        }</span>

        <span class="cov0" title="0">if currentUser.ID != userID </span><span class="cov0" title="0">{
                hasAdminPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserManage)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">if hasAdminPermission </span><span class="cov0" title="0">{
                        if req.RoleID != nil </span><span class="cov0" title="0">{
                                user.RoleID = *req.RoleID
                        }</span>
                        <span class="cov0" title="0">if req.IsActive != nil </span><span class="cov0" title="0">{
                                user.IsActive = *req.IsActive
                        }</span>
                }
        }

        // Handle Settings update
        <span class="cov0" title="0">if req.Settings != nil </span><span class="cov0" title="0">{
                // Marshal settings to JSON string
                settingsJSON, err := json.Marshal(req.Settings)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to marshal settings", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">user.Settings = string(settingsJSON)</span>
        }

        <span class="cov0" title="0">err = h.userRepo.Update(user)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "UNIQUE constraint failed") </span><span class="cov0" title="0">{
                        http.Error(w, "Username or email already exists", http.StatusConflict)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, "Failed to update user", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">role, err := h.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get user role", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">user.Role = role

        user.PasswordHash = ""
        user.Salt = ""

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)</span>
}

func (h *UserHandler) DeleteUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodDelete </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserDelete)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strings.TrimPrefix(r.URL.Path, "/api/users/")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if currentUser.ID == userID </span><span class="cov0" title="0">{
                http.Error(w, "Cannot delete your own account", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.userRepo.Delete(userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to delete user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *UserHandler) ListUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserView)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")

        limit := 50
        offset := 0

        if limitStr != "" </span><span class="cov0" title="0">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 &amp;&amp; parsedLimit &lt;= 100 </span><span class="cov0" title="0">{
                        limit = parsedLimit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if parsedOffset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; parsedOffset &gt;= 0 </span><span class="cov0" title="0">{
                        offset = parsedOffset
                }</span>
        }

        <span class="cov0" title="0">users, err := h.userRepo.List(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to list users", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">for i := range users </span><span class="cov0" title="0">{
                users[i].PasswordHash = ""
                users[i].Salt = ""

                role, err := h.userRepo.GetRole(users[i].RoleID)
                if err == nil </span><span class="cov0" title="0">{
                        users[i].Role = role
                }</span>
        }

        <span class="cov0" title="0">totalCount, err := h.userRepo.Count()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get user count", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "users":       users,
                "total_count": totalCount,
                "limit":       limit,
                "offset":      offset,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

func (h *UserHandler) ResetPassword(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserManage)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strings.TrimPrefix(r.URL.Path, "/api/users/")
        userIDStr = strings.TrimSuffix(userIDStr, "/reset-password")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                NewPassword string `json:"new_password"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.authService.ValidatePassword(req.NewPassword); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.authService.ResetPassword(userID, req.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Password reset successfully"})</span>
}

func (h *UserHandler) LockAccount(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserManage)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strings.TrimPrefix(r.URL.Path, "/api/users/")
        userIDStr = strings.TrimSuffix(userIDStr, "/lock")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if currentUser.ID == userID </span><span class="cov0" title="0">{
                http.Error(w, "Cannot lock your own account", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                LockUntil string `json:"lock_until"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">lockUntil, err := parseTime(req.LockUntil)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid lock_until format", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.authService.LockAccount(userID, lockUntil)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Account locked successfully"})</span>
}

func (h *UserHandler) UnlockAccount(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">currentUser, err := h.getCurrentUser(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">hasPermission, err := h.authService.CheckPermission(currentUser.ID, models.PermissionUserManage)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to check permissions", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                http.Error(w, "Insufficient permissions", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := strings.TrimPrefix(r.URL.Path, "/api/users/")
        userIDStr = strings.TrimSuffix(userIDStr, "/unlock")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.authService.UnlockAccount(userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Account unlocked successfully"})</span>
}

func (h *UserHandler) getCurrentUser(r *http.Request) (*models.User, error) <span class="cov0" title="0">{
        token := extractToken(r)
        if token == "" </span><span class="cov0" title="0">{
                return nil, models.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">return h.authService.GetCurrentUser(token)</span>
}

func (h *UserHandler) hashPassword(password, salt string) (string, error) <span class="cov0" title="0">{
        combined := password + salt
        hash := h.authService.HashData(combined)
        return hash, nil
}</span>

func parseTime(timeStr string) (time.Time, error) <span class="cov0" title="0">{
        return time.Parse(time.RFC3339, timeStr)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package auth

import (
        "fmt"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// AuthMiddleware handles JWT authentication
type AuthMiddleware struct {
        authService *AuthService
        logger      *zap.Logger
}

// NewAuthMiddleware creates a new auth middleware
func NewAuthMiddleware(authService *AuthService, logger *zap.Logger) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                authService: authService,
                logger:      logger,
        }
}</span>

// RequireAuth middleware that requires authentication
func (m *AuthMiddleware) RequireAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                token := m.extractToken(c)
                if token == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing or invalid authorization header"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">user, err := m.authService.ValidateToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.Debug("Token validation failed", zap.Error(err))
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
                        c.Abort()
                        return
                }</span>

                // Set user in context
                <span class="cov0" title="0">c.Set("user", user)
                c.Set("user_id", user.ID)
                c.Set("username", user.Username)
                c.Set("role", user.Role)
                c.Set("permissions", user.Permissions)

                c.Next()</span>
        }
}

// RequirePermission middleware that requires specific permission
func (m *AuthMiddleware) RequirePermission(permission string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                user, exists := c.Get("user")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">userObj, ok := user.(*User)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid user context"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if !userObj.HasPermission(permission) &amp;&amp; !userObj.IsAdmin() </span><span class="cov0" title="0">{
                        m.logger.Debug("Permission denied",
                                zap.String("username", userObj.Username),
                                zap.String("required_permission", permission))
                        c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireRole middleware that requires specific role
func (m *AuthMiddleware) RequireRole(roles ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                user, exists := c.Get("user")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">userObj, ok := user.(*User)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid user context"})
                        c.Abort()
                        return
                }</span>

                // Check if user has any of the required roles
                <span class="cov0" title="0">hasRole := false
                for _, role := range roles </span><span class="cov0" title="0">{
                        if userObj.Role == role </span><span class="cov0" title="0">{
                                hasRole = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !hasRole &amp;&amp; !userObj.IsAdmin() </span><span class="cov0" title="0">{
                        m.logger.Debug("Role access denied",
                                zap.String("username", userObj.Username),
                                zap.String("user_role", userObj.Role),
                                zap.Strings("required_roles", roles))
                        c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient role privileges"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireResourceAccess middleware for resource-action based permissions
func (m *AuthMiddleware) RequireResourceAccess(resource, action string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                user, exists := c.Get("user")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">userObj, ok := user.(*User)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid user context"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if !userObj.CanAccess(resource, action) </span><span class="cov0" title="0">{
                        m.logger.Debug("Resource access denied",
                                zap.String("username", userObj.Username),
                                zap.String("resource", resource),
                                zap.String("action", action))
                        c.JSON(http.StatusForbidden, gin.H{
                                "error":    "Access denied to resource",
                                "resource": resource,
                                "action":   action,
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// OptionalAuth middleware that extracts user if token is present but doesn't require it
func (m *AuthMiddleware) OptionalAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                token := m.extractToken(c)
                if token != "" </span><span class="cov0" title="0">{
                        user, err := m.authService.ValidateToken(token)
                        if err == nil </span><span class="cov0" title="0">{
                                // Set user in context if token is valid
                                c.Set("user", user)
                                c.Set("user_id", user.ID)
                                c.Set("username", user.Username)
                                c.Set("role", user.Role)
                                c.Set("permissions", user.Permissions)
                        }</span>
                }
                <span class="cov0" title="0">c.Next()</span>
        }
}

// AdminOnly middleware that requires admin role
func (m *AuthMiddleware) AdminOnly() gin.HandlerFunc <span class="cov0" title="0">{
        return m.RequireRole(RoleAdmin)
}</span>

// ModeratorOrAdmin middleware that requires moderator or admin role
func (m *AuthMiddleware) ModeratorOrAdmin() gin.HandlerFunc <span class="cov0" title="0">{
        return m.RequireRole(RoleModerator, RoleAdmin)
}</span>

// extractToken extracts JWT token from Authorization header
func (m *AuthMiddleware) extractToken(c *gin.Context) string <span class="cov0" title="0">{
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Check for Bearer token
        <span class="cov0" title="0">if strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                return strings.TrimPrefix(authHeader, "Bearer ")
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// GetCurrentUser helper function to get current user from context
func GetCurrentUser(c *gin.Context) (*User, bool) <span class="cov0" title="0">{
        user, exists := c.Get("user")
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">userObj, ok := user.(*User)
        return userObj, ok</span>
}

// GetCurrentUserID helper function to get current user ID from context
func GetCurrentUserID(c *gin.Context) (int64, bool) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov0" title="0">id, ok := userID.(int64)
        return id, ok</span>
}

// HasPermission helper function to check if current user has permission
func HasPermission(c *gin.Context, permission string) bool <span class="cov0" title="0">{
        user, exists := GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return user.HasPermission(permission) || user.IsAdmin()</span>
}

// IsAdmin helper function to check if current user is admin
func IsAdmin(c *gin.Context) bool <span class="cov0" title="0">{
        user, exists := GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return user.IsAdmin()</span>
}

// CanAccessResource helper function to check resource access
func CanAccessResource(c *gin.Context, resource, action string) bool <span class="cov0" title="0">{
        user, exists := GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return user.CanAccess(resource, action)</span>
}

// LogUserActivity logs user activity for audit purposes
func (m *AuthMiddleware) LogUserActivity() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                // Log after request completion
                user, exists := GetCurrentUser(c)
                if exists </span><span class="cov0" title="0">{
                        m.logger.Info("User activity",
                                zap.String("username", user.Username),
                                zap.String("method", c.Request.Method),
                                zap.String("path", c.Request.URL.Path),
                                zap.Int("status", c.Writer.Status()),
                                zap.String("ip", c.ClientIP()),
                                zap.String("user_agent", c.Request.UserAgent()),
                        )
                }</span>
        }
}

// RateLimitByUser implements per-user rate limiting with sliding window algorithm
func (m *AuthMiddleware) RateLimitByUser(requests int, window string) gin.HandlerFunc <span class="cov0" title="0">{
        // Parse window duration
        windowDuration, err := time.ParseDuration(window)
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Error("Invalid rate limit window", zap.String("window", window), zap.Error(err))
                windowDuration = time.Minute // Default to 1 minute
        }</span>

        // In-memory rate limiter (can be upgraded to Redis for distributed systems)
        <span class="cov0" title="0">type rateLimitEntry struct {
                timestamps []time.Time
                mu         sync.Mutex
        }

        rateLimiters := &amp;sync.Map{}

        return func(c *gin.Context) </span><span class="cov0" title="0">{
                user, exists := GetCurrentUser(c)
                if !exists </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Get or create rate limiter for this user
                <span class="cov0" title="0">key := fmt.Sprintf("ratelimit:%d", user.ID)
                val, _ := rateLimiters.LoadOrStore(key, &amp;rateLimitEntry{
                        timestamps: make([]time.Time, 0, requests),
                })
                entry := val.(*rateLimitEntry)

                entry.mu.Lock()
                defer entry.mu.Unlock()

                now := time.Now()
                cutoff := now.Add(-windowDuration)

                // Remove timestamps outside the window
                validTimestamps := make([]time.Time, 0, len(entry.timestamps))
                for _, ts := range entry.timestamps </span><span class="cov0" title="0">{
                        if ts.After(cutoff) </span><span class="cov0" title="0">{
                                validTimestamps = append(validTimestamps, ts)
                        }</span>
                }
                <span class="cov0" title="0">entry.timestamps = validTimestamps

                // Check if rate limit exceeded
                if len(entry.timestamps) &gt;= requests </span><span class="cov0" title="0">{
                        m.logger.Warn("Rate limit exceeded",
                                zap.String("username", user.Username),
                                zap.Int64("user_id", user.ID),
                                zap.Int("requests", len(entry.timestamps)),
                                zap.Int("limit", requests),
                                zap.String("window", window),
                        )
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": "Rate limit exceeded. Please try again later.",
                                "retry_after": windowDuration.Seconds(),
                        })
                        c.Abort()
                        return
                }</span>

                // Add current request timestamp
                <span class="cov0" title="0">entry.timestamps = append(entry.timestamps, now)

                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package auth

import (
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// User represents a system user
type User struct {
        ID           int64      `json:"id" db:"id"`
        Username     string     `json:"username" db:"username"`
        Email        string     `json:"email" db:"email"`
        PasswordHash string     `json:"-" db:"password_hash"`
        FirstName    string     `json:"first_name" db:"first_name"`
        LastName     string     `json:"last_name" db:"last_name"`
        Role         string     `json:"role" db:"role"`
        IsActive     bool       `json:"is_active" db:"is_active"`
        LastLogin    *time.Time `json:"last_login,omitempty" db:"last_login"`
        CreatedAt    time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt    time.Time  `json:"updated_at" db:"updated_at"`
        Permissions  []string   `json:"permissions,omitempty"`
}

// Role represents user roles
type Role struct {
        ID          int64     `json:"id" db:"id"`
        Name        string    `json:"name" db:"name"`
        Description string    `json:"description" db:"description"`
        Permissions []string  `json:"permissions" db:"permissions"`
        CreatedAt   time.Time `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time `json:"updated_at" db:"updated_at"`
}

// Session represents user sessions
type Session struct {
        ID        string    `json:"id" db:"id"`
        UserID    int64     `json:"user_id" db:"user_id"`
        Token     string    `json:"token" db:"token"`
        ExpiresAt time.Time `json:"expires_at" db:"expires_at"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
        IPAddress string    `json:"ip_address" db:"ip_address"`
        UserAgent string    `json:"user_agent" db:"user_agent"`
}

// LoginRequest represents login request payload
type LoginRequest struct {
        Username string `json:"username" binding:"required"`
        Password string `json:"password" binding:"required"`
}

// LoginResponse represents login response
type LoginResponse struct {
        User         User   `json:"user"`
        Token        string `json:"token"`
        RefreshToken string `json:"refresh_token"`
        ExpiresIn    int64  `json:"expires_in"`
}

// RegisterRequest represents registration request
type RegisterRequest struct {
        Username  string `json:"username" binding:"required,min=3,max=50"`
        Email     string `json:"email" binding:"required,email"`
        Password  string `json:"password" binding:"required,min=8"`
        FirstName string `json:"first_name" binding:"required"`
        LastName  string `json:"last_name" binding:"required"`
}

// UpdateUserRequest represents user update request
type UpdateUserRequest struct {
        FirstName *string `json:"first_name,omitempty"`
        LastName  *string `json:"last_name,omitempty"`
        Email     *string `json:"email,omitempty"`
        Role      *string `json:"role,omitempty"`
        IsActive  *bool   `json:"is_active,omitempty"`
}

// ChangePasswordRequest represents password change request
type ChangePasswordRequest struct {
        CurrentPassword string `json:"current_password" binding:"required"`
        NewPassword     string `json:"new_password" binding:"required,min=8"`
}

// Permission represents system permissions
type Permission struct {
        ID          int64  `json:"id" db:"id"`
        Name        string `json:"name" db:"name"`
        Resource    string `json:"resource" db:"resource"`
        Action      string `json:"action" db:"action"`
        Description string `json:"description" db:"description"`
}

// Claims represents JWT claims
type Claims struct {
        UserID      int64    `json:"user_id"`
        Username    string   `json:"username"`
        Role        string   `json:"role"`
        Permissions []string `json:"permissions"`
        Type        string   `json:"type"` // access or refresh
        IssuedAt    int64    `json:"iat"`
        ExpiresAt   int64    `json:"exp"`
}

// JWT Claims interface implementation
func (c Claims) Valid() error <span class="cov0" title="0">{
        if time.Now().Unix() &gt; c.ExpiresAt </span><span class="cov0" title="0">{
                return fmt.Errorf("token expired")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c Claims) GetExpirationTime() (*jwt.NumericDate, error) <span class="cov0" title="0">{
        return jwt.NewNumericDate(time.Unix(c.ExpiresAt, 0)), nil
}</span>

func (c Claims) GetIssuedAt() (*jwt.NumericDate, error) <span class="cov0" title="0">{
        return jwt.NewNumericDate(time.Unix(c.IssuedAt, 0)), nil
}</span>

func (c Claims) GetNotBefore() (*jwt.NumericDate, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (c Claims) GetIssuer() (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (c Claims) GetSubject() (string, error) <span class="cov0" title="0">{
        return c.Username, nil
}</span>

func (c Claims) GetAudience() (jwt.ClaimStrings, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

// Standard permissions
const (
        // Media permissions
        PermissionReadMedia   = "read:media"
        PermissionWriteMedia  = "write:media"
        PermissionDeleteMedia = "delete:media"
        PermissionViewMedia   = "view:media"

        // Catalog permissions
        PermissionReadCatalog   = "read:catalog"
        PermissionWriteCatalog  = "write:catalog"
        PermissionDeleteCatalog = "delete:catalog"

        // Analysis permissions
        PermissionTriggerAnalysis = "trigger:analysis"
        PermissionViewAnalysis    = "view:analysis"

        // Admin permissions
        PermissionManageUsers = "manage:users"
        PermissionManageRoles = "manage:roles"
        PermissionViewLogs    = "view:logs"
        PermissionSystemAdmin = "admin:system"

        // API permissions
        PermissionAPIAccess = "access:api"
        PermissionAPIWrite  = "write:api"
)

// Standard roles
const (
        RoleAdmin     = "admin"
        RoleModerator = "moderator"
        RoleUser      = "user"
        RoleViewer    = "viewer"
)

// GetRolePermissions returns default permissions for each role
func GetRolePermissions(role string) []string <span class="cov0" title="0">{
        switch role </span>{
        case RoleAdmin:<span class="cov0" title="0">
                return []string{
                        PermissionReadMedia, PermissionWriteMedia, PermissionDeleteMedia,
                        PermissionReadCatalog, PermissionWriteCatalog, PermissionDeleteCatalog,
                        PermissionTriggerAnalysis, PermissionViewAnalysis,
                        PermissionManageUsers, PermissionManageRoles, PermissionViewLogs,
                        PermissionSystemAdmin, PermissionAPIAccess, PermissionAPIWrite,
                }</span>
        case RoleModerator:<span class="cov0" title="0">
                return []string{
                        PermissionReadMedia, PermissionWriteMedia,
                        PermissionReadCatalog, PermissionWriteCatalog,
                        PermissionTriggerAnalysis, PermissionViewAnalysis,
                        PermissionAPIAccess, PermissionAPIWrite,
                }</span>
        case RoleUser:<span class="cov0" title="0">
                return []string{
                        PermissionReadMedia, PermissionWriteMedia,
                        PermissionReadCatalog, PermissionWriteCatalog,
                        PermissionViewAnalysis, PermissionAPIAccess,
                }</span>
        case RoleViewer:<span class="cov0" title="0">
                return []string{
                        PermissionReadMedia, PermissionReadCatalog,
                        PermissionViewAnalysis, PermissionAPIAccess,
                }</span>
        default:<span class="cov0" title="0">
                return []string{PermissionAPIAccess}</span>
        }
}

// HasPermission checks if user has specific permission
func (u *User) HasPermission(permission string) bool <span class="cov0" title="0">{
        for _, p := range u.Permissions </span><span class="cov0" title="0">{
                if p == permission </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsAdmin checks if user is admin
func (u *User) IsAdmin() bool <span class="cov0" title="0">{
        return u.Role == RoleAdmin
}</span>

// CanAccess checks if user can access a resource with specific action
func (u *User) CanAccess(resource, action string) bool <span class="cov0" title="0">{
        permission := action + ":" + resource
        return u.HasPermission(permission) || u.HasPermission(PermissionSystemAdmin)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package auth

import (
        "crypto/rand"
        "database/sql"
        "encoding/hex"
        "fmt"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "go.uber.org/zap"
        "golang.org/x/crypto/bcrypt"
)

// AuthService handles authentication operations
type AuthService struct {
        db        *sql.DB
        jwtSecret []byte
        logger    *zap.Logger
        tokenTTL  time.Duration
}

// NewAuthService creates a new authentication service
func NewAuthService(db *sql.DB, jwtSecret string, logger *zap.Logger) *AuthService <span class="cov0" title="0">{
        return &amp;AuthService{
                db:        db,
                jwtSecret: []byte(jwtSecret),
                logger:    logger,
                tokenTTL:  24 * time.Hour, // 24 hours
        }
}</span>

// Initialize creates the authentication tables and default admin user
func (s *AuthService) Initialize() error <span class="cov0" title="0">{
        // Create tables
        if err := s.createTables(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create auth tables: %w", err)
        }</span>

        // Create default admin user if none exists
        <span class="cov0" title="0">if err := s.createDefaultAdmin(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create default admin: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Authentication system initialized")
        return nil</span>
}

// createTables creates authentication-related tables
func (s *AuthService) createTables() error <span class="cov0" title="0">{
        schema := `
        -- Users table
        CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT NOT NULL UNIQUE,
                email TEXT NOT NULL UNIQUE,
                password_hash TEXT NOT NULL,
                first_name TEXT NOT NULL,
                last_name TEXT NOT NULL,
                role TEXT NOT NULL DEFAULT 'user',
                is_active BOOLEAN NOT NULL DEFAULT true,
                last_login DATETIME,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        -- Roles table
        CREATE TABLE IF NOT EXISTS roles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                description TEXT,
                permissions TEXT, -- JSON array
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        -- Sessions table
        CREATE TABLE IF NOT EXISTS sessions (
                id TEXT PRIMARY KEY,
                user_id INTEGER NOT NULL,
                token TEXT NOT NULL UNIQUE,
                expires_at DATETIME NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                ip_address TEXT,
                user_agent TEXT,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        );

        -- Permissions table
        CREATE TABLE IF NOT EXISTS permissions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                resource TEXT NOT NULL,
                action TEXT NOT NULL,
                description TEXT
        );

        -- User permissions (for custom permissions beyond role)
        CREATE TABLE IF NOT EXISTS user_permissions (
                user_id INTEGER NOT NULL,
                permission_id INTEGER NOT NULL,
                granted_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                granted_by INTEGER,
                PRIMARY KEY (user_id, permission_id),
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE,
                FOREIGN KEY (granted_by) REFERENCES users(id)
        );

        -- Audit log for authentication events
        CREATE TABLE IF NOT EXISTS auth_audit_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                event_type TEXT NOT NULL, -- login, logout, failed_login, password_change, etc.
                ip_address TEXT,
                user_agent TEXT,
                details TEXT, -- JSON
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id)
        );

        -- Indexes
        CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
        CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
        CREATE INDEX IF NOT EXISTS idx_users_role ON users(role);
        CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON sessions(user_id);
        CREATE INDEX IF NOT EXISTS idx_sessions_token ON sessions(token);
        CREATE INDEX IF NOT EXISTS idx_sessions_expires_at ON sessions(expires_at);
        CREATE INDEX IF NOT EXISTS idx_auth_audit_user_id ON auth_audit_log(user_id);
        CREATE INDEX IF NOT EXISTS idx_auth_audit_event_type ON auth_audit_log(event_type);
        CREATE INDEX IF NOT EXISTS idx_auth_audit_created_at ON auth_audit_log(created_at);

        -- Insert default roles
        INSERT OR IGNORE INTO roles (name, description, permissions) VALUES
        ('admin', 'System Administrator', '["admin:system", "manage:users", "manage:roles", "read:media", "write:media", "delete:media", "read:catalog", "write:catalog", "delete:catalog", "trigger:analysis", "view:analysis", "view:logs", "access:api", "write:api"]'),
        ('moderator', 'Content Moderator', '["read:media", "write:media", "read:catalog", "write:catalog", "trigger:analysis", "view:analysis", "access:api", "write:api"]'),
        ('user', 'Regular User', '["read:media", "write:media", "read:catalog", "write:catalog", "view:analysis", "access:api"]'),
        ('viewer', 'Read-only Viewer', '["read:media", "read:catalog", "view:analysis", "access:api"]');

        -- Insert default permissions
        INSERT OR IGNORE INTO permissions (name, resource, action, description) VALUES
        ('read:media', 'media', 'read', 'View media items and metadata'),
        ('write:media', 'media', 'write', 'Create and update media items'),
        ('delete:media', 'media', 'delete', 'Delete media items'),
        ('read:catalog', 'catalog', 'read', 'Browse file catalog'),
        ('write:catalog', 'catalog', 'write', 'Modify file catalog'),
        ('delete:catalog', 'catalog', 'delete', 'Delete from catalog'),
        ('trigger:analysis', 'analysis', 'trigger', 'Start media analysis'),
        ('view:analysis', 'analysis', 'view', 'View analysis results'),
        ('manage:users', 'users', 'manage', 'Create, update, delete users'),
        ('manage:roles', 'roles', 'manage', 'Create, update, delete roles'),
        ('view:logs', 'logs', 'view', 'View system logs'),
        ('admin:system', 'system', 'admin', 'Full system administration'),
        ('access:api', 'api', 'access', 'Access API endpoints'),
        ('write:api', 'api', 'write', 'Modify data via API');
        `

        _, err := s.db.Exec(schema)
        return err
}</span>

// createDefaultAdmin creates a default admin user if none exists
func (s *AuthService) createDefaultAdmin() error <span class="cov0" title="0">{
        // Check if any admin users exist
        var count int
        err := s.db.QueryRow("SELECT COUNT(*) FROM users WHERE role = 'admin'").Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                s.logger.Info("Admin user already exists")
                return nil
        }</span>

        // Create default admin user
        <span class="cov0" title="0">passwordHash, err := bcrypt.GenerateFromPassword([]byte("admin123"), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO users (username, email, password_hash, first_name, last_name, role, is_active)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err = s.db.Exec(query, "admin", "admin@catalogizer.local", string(passwordHash), "System", "Administrator", "admin", true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info("Default admin user created",
                zap.String("username", "admin"),
                zap.String("password", "admin123"))

        return nil</span>
}

// Login authenticates a user and returns a token
func (s *AuthService) Login(username, password, ipAddress, userAgent string) (*LoginResponse, error) <span class="cov0" title="0">{
        // Get user by username or email
        user, err := s.getUserByUsernameOrEmail(username)
        if err != nil </span><span class="cov0" title="0">{
                s.logAuthEvent(0, "failed_login", ipAddress, userAgent, fmt.Sprintf("user not found: %s", username))
                return nil, fmt.Errorf("invalid credentials")
        }</span>

        // Check if user is active
        <span class="cov0" title="0">if !user.IsActive </span><span class="cov0" title="0">{
                s.logAuthEvent(user.ID, "failed_login_inactive", ipAddress, userAgent, "account disabled")
                return nil, fmt.Errorf("account is disabled")
        }</span>

        // Verify password
        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password)); err != nil </span><span class="cov0" title="0">{
                s.logAuthEvent(user.ID, "failed_login", ipAddress, userAgent, "invalid password")
                return nil, fmt.Errorf("invalid credentials")
        }</span>

        // Load user permissions
        <span class="cov0" title="0">user.Permissions = GetRolePermissions(user.Role)

        // Generate tokens
        accessToken, err := s.generateToken(user, "access")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate access token: %w", err)
        }</span>

        <span class="cov0" title="0">refreshToken, err := s.generateToken(user, "refresh")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        // Create session
        <span class="cov0" title="0">sessionID, err := s.createSession(user.ID, accessToken, ipAddress, userAgent)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create session", zap.Error(err))
        }</span>

        // Update last login
        <span class="cov0" title="0">_, err = s.db.Exec("UPDATE users SET last_login = ? WHERE id = ?", time.Now(), user.ID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update last login", zap.Error(err))
        }</span>

        <span class="cov0" title="0">s.logAuthEvent(user.ID, "login_success", ipAddress, userAgent, fmt.Sprintf("session: %s", sessionID))

        return &amp;LoginResponse{
                User:         *user,
                Token:        accessToken,
                RefreshToken: refreshToken,
                ExpiresIn:    int64(s.tokenTTL.Seconds()),
        }, nil</span>
}

// Logout invalidates a user session
func (s *AuthService) Logout(token string) error <span class="cov0" title="0">{
        // Delete session
        _, err := s.db.Exec("DELETE FROM sessions WHERE token = ?", token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete session: %w", err)
        }</span>

        // Parse token to get user ID for logging
        <span class="cov0" title="0">claims, err := s.validateToken(token)
        if err == nil </span><span class="cov0" title="0">{
                s.logAuthEvent(claims.UserID, "logout", "", "", "")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateToken validates a JWT token and returns user information
func (s *AuthService) ValidateToken(tokenString string) (*User, error) <span class="cov0" title="0">{
        claims, err := s.validateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if session exists and is valid
        <span class="cov0" title="0">var sessionExists bool
        err = s.db.QueryRow("SELECT EXISTS(SELECT 1 FROM sessions WHERE token = ? AND expires_at &gt; ?)",
                tokenString, time.Now()).Scan(&amp;sessionExists)
        if err != nil || !sessionExists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session expired or invalid")
        }</span>

        // Get current user data
        <span class="cov0" title="0">user, err := s.GetUserByID(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// GetUserByID retrieves a user by ID
func (s *AuthService) GetUserByID(userID int64) (*User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, first_name, last_name, role, is_active, last_login, created_at, updated_at
                FROM users WHERE id = ?
        `

        user := &amp;User{}
        err := s.db.QueryRow(query, userID).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash,
                &amp;user.FirstName, &amp;user.LastName, &amp;user.Role, &amp;user.IsActive,
                &amp;user.LastLogin, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Load permissions
        <span class="cov0" title="0">user.Permissions = GetRolePermissions(user.Role)

        return user, nil</span>
}

// CreateUser creates a new user
func (s *AuthService) CreateUser(req *RegisterRequest) (*User, error) <span class="cov0" title="0">{
        // Check if username or email already exists
        var exists bool
        err := s.db.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE username = ? OR email = ?)",
                req.Username, req.Email).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("username or email already exists")
        }</span>

        // Hash password
        <span class="cov0" title="0">passwordHash, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Insert user
        <span class="cov0" title="0">query := `
                INSERT INTO users (username, email, password_hash, first_name, last_name, role, is_active)
                VALUES (?, ?, ?, ?, ?, 'user', true)
        `

        result, err := s.db.Exec(query, req.Username, req.Email, string(passwordHash), req.FirstName, req.LastName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">userID, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GetUserByID(userID)</span>
}

// Helper methods

func (s *AuthService) getUserByUsernameOrEmail(identifier string) (*User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, first_name, last_name, role, is_active, last_login, created_at, updated_at
                FROM users WHERE username = ? OR email = ?
        `

        user := &amp;User{}
        err := s.db.QueryRow(query, identifier, identifier).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash,
                &amp;user.FirstName, &amp;user.LastName, &amp;user.Role, &amp;user.IsActive,
                &amp;user.LastLogin, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        return user, err
}</span>

func (s *AuthService) generateToken(user *User, tokenType string) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        var expiresAt time.Time

        if tokenType == "refresh" </span><span class="cov0" title="0">{
                expiresAt = now.Add(7 * 24 * time.Hour) // 7 days for refresh tokens
        }</span> else<span class="cov0" title="0"> {
                expiresAt = now.Add(s.tokenTTL)
        }</span>

        <span class="cov0" title="0">claims := Claims{
                UserID:      user.ID,
                Username:    user.Username,
                Role:        user.Role,
                Permissions: user.Permissions,
                Type:        tokenType,
                IssuedAt:    now.Unix(),
                ExpiresAt:   expiresAt.Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(s.jwtSecret)</span>
}

func (s *AuthService) validateToken(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return s.jwtSecret, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid token")</span>
}

func (s *AuthService) createSession(userID int64, token, ipAddress, userAgent string) (string, error) <span class="cov0" title="0">{
        sessionID, err := generateRandomString(32)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">expiresAt := time.Now().Add(s.tokenTTL)

        query := `
                INSERT INTO sessions (id, user_id, token, expires_at, ip_address, user_agent)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = s.db.Exec(query, sessionID, userID, token, expiresAt, ipAddress, userAgent)
        return sessionID, err</span>
}

func (s *AuthService) logAuthEvent(userID int64, eventType, ipAddress, userAgent, details string) <span class="cov0" title="0">{
        query := `
                INSERT INTO auth_audit_log (user_id, event_type, ip_address, user_agent, details)
                VALUES (?, ?, ?, ?, ?)
        `

        _, err := s.db.Exec(query, userID, eventType, ipAddress, userAgent, details)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to log auth event", zap.Error(err))
        }</span>
}

func generateRandomString(length int) (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, length)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

// Additional methods for user management...

// UpdateUser updates user information
func (s *AuthService) UpdateUser(userID int64, req *UpdateUserRequest) (*User, error) <span class="cov0" title="0">{
        var setParts []string
        var args []interface{}

        if req.FirstName != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "first_name = ?")
                args = append(args, *req.FirstName)
        }</span>
        <span class="cov0" title="0">if req.LastName != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "last_name = ?")
                args = append(args, *req.LastName)
        }</span>
        <span class="cov0" title="0">if req.Email != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "email = ?")
                args = append(args, *req.Email)
        }</span>
        <span class="cov0" title="0">if req.Role != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "role = ?")
                args = append(args, *req.Role)
        }</span>
        <span class="cov0" title="0">if req.IsActive != nil </span><span class="cov0" title="0">{
                setParts = append(setParts, "is_active = ?")
                args = append(args, *req.IsActive)
        }</span>

        <span class="cov0" title="0">if len(setParts) == 0 </span><span class="cov0" title="0">{
                return s.GetUserByID(userID)
        }</span>

        <span class="cov0" title="0">setParts = append(setParts, "updated_at = ?")
        args = append(args, time.Now())
        args = append(args, userID)

        query := fmt.Sprintf("UPDATE users SET %s WHERE id = ?", strings.Join(setParts, ", "))
        _, err := s.db.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">return s.GetUserByID(userID)</span>
}

// ChangePassword changes user password
func (s *AuthService) ChangePassword(userID int64, currentPassword, newPassword string) error <span class="cov0" title="0">{
        user, err := s.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Verify current password
        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(currentPassword)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("current password is incorrect")
        }</span>

        // Hash new password
        <span class="cov0" title="0">newPasswordHash, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash new password: %w", err)
        }</span>

        // Update password
        <span class="cov0" title="0">_, err = s.db.Exec("UPDATE users SET password_hash = ?, updated_at = ? WHERE id = ?",
                string(newPasswordHash), time.Now(), userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        <span class="cov0" title="0">s.logAuthEvent(userID, "password_changed", "", "", "")
        return nil</span>
}

// ListUsers returns paginated list of users
func (s *AuthService) ListUsers(limit, offset int) ([]User, int64, error) <span class="cov0" title="0">{
        // Get total count
        var total int64
        err := s.db.QueryRow("SELECT COUNT(*) FROM users").Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get users
        <span class="cov0" title="0">query := `
                SELECT id, username, email, first_name, last_name, role, is_active, last_login, created_at, updated_at
                FROM users
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := s.db.Query(query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []User
        for rows.Next() </span><span class="cov0" title="0">{
                var user User
                err := rows.Scan(
                        &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.FirstName, &amp;user.LastName,
                        &amp;user.Role, &amp;user.IsActive, &amp;user.LastLogin, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">user.Permissions = GetRolePermissions(user.Role)
                users = append(users, user)</span>
        }

        <span class="cov0" title="0">return users, total, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
)

type Config struct {
        Server   ServerConfig   `json:"server"`
        Database DatabaseConfig `json:"database"`
        SMB      SMBConfig      `json:"smb"`
        Auth     AuthConfig     `json:"auth"`
        Logging  LoggingConfig  `json:"logging"`
        Catalog  CatalogConfig  `json:"catalog"`
}

type ServerConfig struct {
        Host         string `json:"host"`
        Port         string `json:"port"`
        ReadTimeout  int    `json:"read_timeout"`
        WriteTimeout int    `json:"write_timeout"`
        IdleTimeout  int    `json:"idle_timeout"`
        EnableCORS   bool   `json:"enable_cors"`
        EnableHTTPS  bool   `json:"enable_https"`
        CertFile     string `json:"cert_file"`
        KeyFile      string `json:"key_file"`
}

type DatabaseConfig struct {
        Driver   string `json:"driver"`
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Database string `json:"database"`
        Username string `json:"username"`
        Password string `json:"password"`
        SSLMode  string `json:"ssl_mode"`
}

type SMBConfig struct {
        Hosts     []SMBHost `json:"hosts"`
        Timeout   int       `json:"timeout"`
        ChunkSize int       `json:"chunk_size"`
}

type SMBHost struct {
        Name     string `json:"name"`
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Share    string `json:"share"`
        Username string `json:"username"`
        Password string `json:"password"`
        Domain   string `json:"domain"`
}

type AuthConfig struct {
        EnableAuth bool   `json:"enable_auth"`
        JWTSecret  string `json:"jwt_secret"`
}

type LoggingConfig struct {
        Level  string `json:"level"`
        Format string `json:"format"`
}

type CatalogConfig struct {
        TempDir           string `json:"temp_dir"`
        MaxArchiveSize    int64  `json:"max_archive_size"`
        DownloadChunkSize int    `json:"download_chunk_size"`
}

func Load() (*Config, error) <span class="cov0" title="0">{
        configPath := os.Getenv("CATALOG_CONFIG_PATH")
        if configPath == "" </span><span class="cov0" title="0">{
                configPath = "config.json"
        }</span>

        <span class="cov0" title="0">return LoadFromFile(configPath)</span>
}

func LoadFromFile(path string) (*Config, error) <span class="cov0" title="0">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open config file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var config Config
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := config.validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (c *Config) validate() error <span class="cov0" title="0">{
        if c.Server.Port == "" </span><span class="cov0" title="0">{
                c.Server.Port = "8080"
        }</span>
        <span class="cov0" title="0">if c.Server.Host == "" </span><span class="cov0" title="0">{
                c.Server.Host = "localhost"
        }</span>
        <span class="cov0" title="0">if c.Server.ReadTimeout == 0 </span><span class="cov0" title="0">{
                c.Server.ReadTimeout = 30
        }</span>
        <span class="cov0" title="0">if c.Server.WriteTimeout == 0 </span><span class="cov0" title="0">{
                c.Server.WriteTimeout = 30
        }</span>
        <span class="cov0" title="0">if c.Server.IdleTimeout == 0 </span><span class="cov0" title="0">{
                c.Server.IdleTimeout = 60
        }</span>

        <span class="cov0" title="0">if c.Catalog.TempDir == "" </span><span class="cov0" title="0">{
                c.Catalog.TempDir = "/tmp"
        }</span>
        <span class="cov0" title="0">if c.Catalog.MaxArchiveSize == 0 </span><span class="cov0" title="0">{
                c.Catalog.MaxArchiveSize = 1024 * 1024 * 1024 // 1GB
        }</span>
        <span class="cov0" title="0">if c.Catalog.DownloadChunkSize == 0 </span><span class="cov0" title="0">{
                c.Catalog.DownloadChunkSize = 1024 * 1024 // 1MB
        }</span>

        <span class="cov0" title="0">if c.SMB.Timeout == 0 </span><span class="cov0" title="0">{
                c.SMB.Timeout = 30
        }</span>
        <span class="cov0" title="0">if c.SMB.ChunkSize == 0 </span><span class="cov0" title="0">{
                c.SMB.ChunkSize = 1024 * 1024 // 1MB
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Config) GetServerAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", c.Server.Host, c.Server.Port)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package handlers

import (
        "catalogizer/internal/auth"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// AuthHandler handles authentication endpoints
type AuthHandler struct {
        authService *auth.AuthService
        logger      *zap.Logger
}

// NewAuthHandler creates a new auth handler
func NewAuthHandler(authService *auth.AuthService, logger *zap.Logger) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                authService: authService,
                logger:      logger,
        }
}</span>

// @Summary User login
// @Description Authenticate user and return JWT token
// @Tags auth
// @Accept json
// @Produce json
// @Param request body auth.LoginRequest true "Login credentials"
// @Success 200 {object} auth.LoginResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/login [post]
func (h *AuthHandler) Login(c *gin.Context) <span class="cov0" title="0">{
        var req auth.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">response, err := h.authService.Login(
                req.Username,
                req.Password,
                c.ClientIP(),
                c.Request.UserAgent(),
        )
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Debug("Login failed",
                        zap.String("username", req.Username),
                        zap.String("ip", c.ClientIP()),
                        zap.Error(err))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("User logged in successfully",
                zap.String("username", response.User.Username),
                zap.String("ip", c.ClientIP()))

        c.JSON(http.StatusOK, response)</span>
}

// @Summary User logout
// @Description Invalidate user session
// @Tags auth
// @Security BearerAuth
// @Success 200 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/logout [post]
func (h *AuthHandler) Logout(c *gin.Context) <span class="cov0" title="0">{
        // Extract token from header
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing authorization header"})
                return
        }</span>

        <span class="cov0" title="0">token := authHeader[7:] // Remove "Bearer " prefix
        if err := h.authService.Logout(token); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Logout failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Logout failed"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Logged out successfully"})</span>
}

// @Summary User registration
// @Description Register a new user account
// @Tags auth
// @Accept json
// @Produce json
// @Param request body auth.RegisterRequest true "Registration details"
// @Success 201 {object} auth.User
// @Failure 400 {object} map[string]string
// @Failure 409 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/register [post]
func (h *AuthHandler) Register(c *gin.Context) <span class="cov0" title="0">{
        var req auth.RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.authService.CreateUser(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Debug("Registration failed",
                        zap.String("username", req.Username),
                        zap.String("email", req.Email),
                        zap.Error(err))

                if err.Error() == "username or email already exists" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Username or email already exists"})
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Registration failed"})
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">h.logger.Info("User registered successfully",
                zap.String("username", user.Username),
                zap.String("email", user.Email))

        c.JSON(http.StatusCreated, user)</span>
}

// @Summary Get current user profile
// @Description Get authenticated user's profile information
// @Tags auth
// @Security BearerAuth
// @Produce json
// @Success 200 {object} auth.User
// @Failure 401 {object} map[string]string
// @Router /api/v1/auth/profile [get]
func (h *AuthHandler) GetProfile(c *gin.Context) <span class="cov0" title="0">{
        user, exists := auth.GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}

// @Summary Update user profile
// @Description Update authenticated user's profile information
// @Tags auth
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param request body auth.UpdateUserRequest true "Profile updates"
// @Success 200 {object} auth.User
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/profile [put]
func (h *AuthHandler) UpdateProfile(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := auth.GetCurrentUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">var req auth.UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        // Users can only update their own non-privileged fields
        <span class="cov0" title="0">safeReq := &amp;auth.UpdateUserRequest{
                FirstName: req.FirstName,
                LastName:  req.LastName,
                Email:     req.Email,
        }

        user, err := h.authService.UpdateUser(userID, safeReq)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Profile update failed",
                        zap.Int64("user_id", userID),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Profile update failed"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}

// @Summary Change password
// @Description Change user's password
// @Tags auth
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param request body auth.ChangePasswordRequest true "Password change request"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/change-password [post]
func (h *AuthHandler) ChangePassword(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := auth.GetCurrentUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">var req auth.ChangePasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">err := h.authService.ChangePassword(userID, req.CurrentPassword, req.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Debug("Password change failed",
                        zap.Int64("user_id", userID),
                        zap.Error(err))

                if err.Error() == "current password is incorrect" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Current password is incorrect"})
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Password change failed"})
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Password changed successfully"})</span>
}

// Admin endpoints

// @Summary List all users
// @Description Get paginated list of all users (admin only)
// @Tags auth
// @Security BearerAuth
// @Param limit query int false "Number of users per page" default(20)
// @Param offset query int false "Offset for pagination" default(0)
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/auth/admin/users [get]
func (h *AuthHandler) ListUsers(c *gin.Context) <span class="cov0" title="0">{
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100 // Cap at 100
        }</span>

        <span class="cov0" title="0">users, total, err := h.authService.ListUsers(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to list users", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve users"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "users":  users,
                "total":  total,
                "limit":  limit,
                "offset": offset,
        })</span>
}

// @Summary Get user by ID
// @Description Get specific user information (admin only)
// @Tags auth
// @Security BearerAuth
// @Param id path int true "User ID"
// @Produce json
// @Success 200 {object} auth.User
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/auth/admin/users/{id} [get]
func (h *AuthHandler) GetUser(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        userID, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.authService.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Debug("User not found", zap.Int64("user_id", userID))
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}

// @Summary Update user
// @Description Update user information (admin only)
// @Tags auth
// @Security BearerAuth
// @Accept json
// @Param id path int true "User ID"
// @Param request body auth.UpdateUserRequest true "User updates"
// @Produce json
// @Success 200 {object} auth.User
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/auth/admin/users/{id} [put]
func (h *AuthHandler) UpdateUser(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        userID, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">var req auth.UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.authService.UpdateUser(userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update user",
                        zap.Int64("user_id", userID),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user"})
                return
        }</span>

        // Log the admin action
        <span class="cov0" title="0">currentUser, _ := auth.GetCurrentUser(c)
        h.logger.Info("User updated by admin",
                zap.Int64("target_user_id", userID),
                zap.String("admin_username", currentUser.Username))

        c.JSON(http.StatusOK, user)</span>
}

// @Summary Get authentication status
// @Description Check if user is authenticated and return user info
// @Tags auth
// @Security BearerAuth
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Router /api/v1/auth/status [get]
func (h *AuthHandler) GetAuthStatus(c *gin.Context) <span class="cov0" title="0">{
        user, exists := auth.GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "authenticated": false,
                        "error":         "Not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "authenticated": true,
                "user":          user,
                "permissions":   user.Permissions,
        })</span>
}

// @Summary Get user permissions
// @Description Get current user's permissions
// @Tags auth
// @Security BearerAuth
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Router /api/v1/auth/permissions [get]
func (h *AuthHandler) GetPermissions(c *gin.Context) <span class="cov0" title="0">{
        user, exists := auth.GetCurrentUser(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "role":        user.Role,
                "permissions": user.Permissions,
                "is_admin":    user.IsAdmin(),
        })</span>
}

// @Summary Get system initialization status
// @Description Check if system has been initialized with admin user
// @Tags auth
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Router /api/v1/auth/init-status [get]
func (h *AuthHandler) GetInitStatus(c *gin.Context) <span class="cov0" title="0">{
        // Check if any admin users exist
        users, _, err := h.authService.ListUsers(1, 0)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check initialization status"})
                return
        }</span>

        <span class="cov0" title="0">hasAdmin := false
        for _, user := range users </span><span class="cov0" title="0">{
                if user.Role == auth.RoleAdmin </span><span class="cov0" title="0">{
                        hasAdmin = true
                        break</span>
                }
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "initialized": hasAdmin,
                "has_admin":   hasAdmin,
                "user_count":  len(users),
        })</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package handlers

import (
        "catalogizer/internal/models"
        "catalogizer/internal/services"
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type CatalogHandler struct {
        catalogService services.CatalogServiceInterface
        smbService     services.SMBServiceInterface
        logger         *zap.Logger
}

func NewCatalogHandler(catalogService services.CatalogServiceInterface, smbService services.SMBServiceInterface, logger *zap.Logger) *CatalogHandler <span class="cov10" title="11">{
        return &amp;CatalogHandler{
                catalogService: catalogService,
                smbService:     smbService,
                logger:         logger,
        }
}</span>

// @Summary List root directories
// @Description Get list of available SMB root directories
// @Tags catalog
// @Produce json
// @Success 200 {array} string
// @Failure 500 {object} map[string]string
// @Router /api/v1/catalog [get]
func (h *CatalogHandler) ListRoot(c *gin.Context) <span class="cov1" title="1">{
        roots, err := h.catalogService.GetSMBRoots()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get SMB roots", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get SMB roots"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"roots": roots})</span>
}

// @Summary List files in path
// @Description Get list of files and directories in the specified path
// @Tags catalog
// @Param path path string true "Path to browse"
// @Param sort_by query string false "Sort by field (name, size, modified)" default(name)
// @Param sort_order query string false "Sort order (asc, desc)" default(asc)
// @Param limit query int false "Limit number of results" default(100)
// @Param offset query int false "Offset for pagination" default(0)
// @Produce json
// @Success 200 {array} models.FileInfo
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/catalog/{path} [get]
func (h *CatalogHandler) ListPath(c *gin.Context) <span class="cov3" title="2">{
        path := c.Param("path")
        if path == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Path is required"})
                return
        }</span>

        // Clean the path (remove leading slash if present)
        <span class="cov3" title="2">if strings.HasPrefix(path, "/") </span><span class="cov3" title="2">{
                path = path[1:]
        }</span>

        <span class="cov3" title="2">sortBy := c.DefaultQuery("sort_by", "name")
        sortOrder := c.DefaultQuery("sort_order", "asc")
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "100"))
        offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

        files, err := h.catalogService.ListPath(path, sortBy, sortOrder, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to list path", zap.String("path", path), zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list directory"})
                return
        }</span>

        <span class="cov3" title="2">c.JSON(http.StatusOK, gin.H{
                "files":  files,
                "count":  len(files),
                "limit":  limit,
                "offset": offset,
        })</span>
}

// @Summary Get file information
// @Description Get detailed information about a specific file or directory
// @Tags catalog
// @Param path path string true "Path to file/directory"
// @Produce json
// @Success 200 {object} models.FileInfo
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/catalog-info/{path} [get]
func (h *CatalogHandler) GetFileInfo(c *gin.Context) <span class="cov3" title="2">{
        path := c.Param("path")
        if path == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Path is required"})
                return
        }</span>

        // Clean the path
        <span class="cov3" title="2">if strings.HasPrefix(path, "/") </span><span class="cov3" title="2">{
                path = path[1:]
        }</span>

        // Try to get file info by path or ID
        <span class="cov3" title="2">fileInfo, err := h.catalogService.GetFileInfo(path)
        if err != nil </span><span class="cov1" title="1">{
                if err.Error() == "sql: no rows in result set" </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "File not found"})
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("Failed to get file info", zap.String("path", path), zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get file information"})
                return</span>
        }

        <span class="cov1" title="1">if fileInfo == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "File not found"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, fileInfo)</span>
}

// @Summary Search files
// @Description Search for files and directories based on various criteria
// @Tags search
// @Param query query string false "Search query (filename)"
// @Param path query string false "Path filter"
// @Param extension query string false "File extension filter"
// @Param mime_type query string false "MIME type filter"
// @Param min_size query int false "Minimum file size"
// @Param max_size query int false "Maximum file size"
// @Param smb_roots query string false "Comma-separated list of SMB roots"
// @Param is_directory query bool false "Filter by directory status"
// @Param sort_by query string false "Sort by field" default(name)
// @Param sort_order query string false "Sort order" default(asc)
// @Param limit query int false "Limit results" default(100)
// @Param offset query int false "Offset for pagination" default(0)
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/search [get]
func (h *CatalogHandler) Search(c *gin.Context) <span class="cov5" title="3">{
        var req models.SearchRequest

        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid search parameters"})
                return
        }</span>

        <span class="cov5" title="3">if req.Query == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Search query is required"})
                return
        }</span>

        // Set defaults
        <span class="cov3" title="2">if req.Limit == 0 </span><span class="cov1" title="1">{
                req.Limit = 100
        }</span>
        <span class="cov3" title="2">if req.SortBy == "" </span><span class="cov3" title="2">{
                req.SortBy = "name"
        }</span>
        <span class="cov3" title="2">if req.SortOrder == "" </span><span class="cov3" title="2">{
                req.SortOrder = "asc"
        }</span>

        // Parse SMB roots if provided as comma-separated string
        <span class="cov3" title="2">smbRootsStr := c.Query("smb_roots")
        if smbRootsStr != "" </span><span class="cov0" title="0">{
                req.SmbRoots = strings.Split(smbRootsStr, ",")
        }</span>

        <span class="cov3" title="2">files, total, err := h.catalogService.SearchFiles(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to search files", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Search failed"})
                return
        }</span>

        <span class="cov3" title="2">c.JSON(http.StatusOK, gin.H{
                "files":  files,
                "total":  total,
                "count":  len(files),
                "limit":  req.Limit,
                "offset": req.Offset,
        })</span>
}

// @Summary Search duplicate files
// @Description Find groups of duplicate files
// @Tags search
// @Param smb_root query string false "SMB root to search in"
// @Param min_count query int false "Minimum number of duplicates" default(2)
// @Param limit query int false "Limit number of groups" default(50)
// @Produce json
// @Success 200 {array} models.DuplicateGroup
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/search/duplicates [get]
func (h *CatalogHandler) SearchDuplicates(c *gin.Context) <span class="cov1" title="1">{
        smbRoot := c.DefaultQuery("smb_root", "")
        minCount, _ := strconv.Atoi(c.DefaultQuery("min_count", "2"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))

        if smbRoot == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "SMB root is required"})
                return
        }</span>

        <span class="cov1" title="1">groups, err := h.catalogService.GetDuplicateGroups(smbRoot, minCount, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get duplicate groups", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to find duplicates"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{
                "groups": groups,
                "count":  len(groups),
        })</span>
}

// @Summary Get directories sorted by size
// @Description Get directories sorted by their total size
// @Tags stats
// @Param smb_root query string true "SMB root to analyze"
// @Param limit query int false "Limit number of results" default(50)
// @Produce json
// @Success 200 {array} models.DirectoryStats
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/stats/directories/by-size [get]
func (h *CatalogHandler) GetDirectoriesBySize(c *gin.Context) <span class="cov1" title="1">{
        smbRoot := c.Query("smb_root")
        if smbRoot == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "SMB root is required"})
                return
        }</span>

        <span class="cov1" title="1">limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))

        stats, err := h.catalogService.GetDirectoriesBySize(smbRoot, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get directories by size", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get directory statistics"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{
                "directories": stats,
                "count":       len(stats),
        })</span>
}

// @Summary Get duplicate count statistics
// @Description Get statistics about duplicate files
// @Tags stats
// @Param smb_root query string false "SMB root to analyze"
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 500 {object} map[string]string
// @Router /api/v1/stats/duplicates/count [get]
func (h *CatalogHandler) GetDuplicatesCount(c *gin.Context) <span class="cov1" title="1">{
        smbRoot := c.DefaultQuery("smb_root", "")

        groups, err := h.catalogService.GetDuplicateGroups(smbRoot, 2, 1000)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get duplicate statistics", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get duplicate statistics"})
                return
        }</span>

        <span class="cov1" title="1">var totalDuplicates int64
        var totalWastedSpace int64
        var groupCount int

        for _, group := range groups </span><span class="cov0" title="0">{
                if group.Count &gt; 1 </span><span class="cov0" title="0">{
                        groupCount++
                        totalDuplicates += int64(group.Count - 1) // Don't count the original
                        totalWastedSpace += int64(group.Count-1) * group.Size
                }</span>
        }

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{
                "duplicate_groups":   groupCount,
                "total_duplicates":   totalDuplicates,
                "total_wasted_space": totalWastedSpace,
                "smb_root":           smbRoot,
        })</span>
}

// Placeholder implementations for other endpoints
// Delegated to specialized handlers
func (h *CatalogHandler) DownloadFile(c *gin.Context) <span class="cov0" title="0">{
        // Delegate to DownloadHandler
        c.JSON(http.StatusSeeOther, gin.H{"redirect": "/api/v1/download/file/" + c.Param("path")})
}</span>

func (h *CatalogHandler) DownloadArchive(c *gin.Context) <span class="cov0" title="0">{
        // Delegate to DownloadHandler
        c.JSON(http.StatusSeeOther, gin.H{"redirect": "/api/v1/download/archive"})
}</span>

func (h *CatalogHandler) CopyToSMB(c *gin.Context) <span class="cov0" title="0">{
        // Delegate to CopyHandler
        c.JSON(http.StatusSeeOther, gin.H{"redirect": "/api/v1/copy/smb"})
}</span>

func (h *CatalogHandler) CopyFromSMB(c *gin.Context) <span class="cov0" title="0">{
        // Delegate to CopyHandler
        c.JSON(http.StatusSeeOther, gin.H{"redirect": "/api/v1/copy/local"})
}</span>

func (h *CatalogHandler) ListSMBPath(c *gin.Context) <span class="cov0" title="0">{
        // Delegate to CopyHandler
        c.JSON(http.StatusSeeOther, gin.H{"redirect": "/api/v1/smb/list/" + c.Param("path")})
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package handlers

import (
        "catalogizer/internal/models"
        "catalogizer/internal/services"
        "net/http"
        "os"
        "path/filepath"
        "strings"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type CopyHandler struct {
        catalogService *services.CatalogService
        smbService     *services.SMBService
        tempDir        string
        logger         *zap.Logger
}

func NewCopyHandler(catalogService *services.CatalogService, smbService *services.SMBService, tempDir string, logger *zap.Logger) *CopyHandler <span class="cov1" title="1">{
        return &amp;CopyHandler{
                catalogService: catalogService,
                smbService:     smbService,
                tempDir:        tempDir,
                logger:         logger,
        }
}</span>

// @Summary Copy file between SMB shares
// @Description Copy a file from one SMB location to another
// @Tags copy
// @Accept json
// @Param request body models.CopyRequest true "Copy request"
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/copy/smb [post]
func (h *CopyHandler) CopyToSMB(c *gin.Context) <span class="cov0" title="0">{
        var req models.CopyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">if req.SourcePath == "" || req.DestinationPath == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Source and destination paths are required"})
                return
        }</span>

        // Parse source and destination
        <span class="cov0" title="0">sourceHost, sourcePath := h.parseHostPath(req.SourcePath)
        destHost, destPath := h.parseHostPath(req.DestinationPath)

        if sourceHost == "" || destHost == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid host:path format. Use 'host:path'"})
                return
        }</span>

        // Check if destination exists and handle overwrite
        <span class="cov0" title="0">if !req.Overwrite </span><span class="cov0" title="0">{
                exists, err := h.smbService.FileExists(destHost, destPath)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to check destination file", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check destination"})
                        return
                }</span>
                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Destination file already exists"})
                        return
                }</span>
        }

        // Perform copy
        <span class="cov0" title="0">err := h.smbService.CopyFile(sourceHost, sourcePath, destHost, destPath)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to copy file via SMB",
                        zap.String("source", req.SourcePath),
                        zap.String("destination", req.DestinationPath),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Copy operation failed"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("File copied successfully via SMB",
                zap.String("source", req.SourcePath),
                zap.String("destination", req.DestinationPath))

        c.JSON(http.StatusOK, gin.H{
                "message":     "File copied successfully",
                "source":      req.SourcePath,
                "destination": req.DestinationPath,
        })</span>
}

// @Summary Copy file from SMB to local filesystem
// @Description Copy a file from SMB share to local filesystem
// @Tags copy
// @Accept json
// @Param request body models.CopyRequest true "Copy request"
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/copy/local [post]
func (h *CopyHandler) CopyToLocal(c *gin.Context) <span class="cov0" title="0">{
        var req models.CopyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">if req.SourcePath == "" || req.DestinationPath == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Source and destination paths are required"})
                return
        }</span>

        // Parse source
        <span class="cov0" title="0">sourceHost, sourcePath := h.parseHostPath(req.SourcePath)
        if sourceHost == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid source format. Use 'host:path'"})
                return
        }</span>

        // Destination is local path
        <span class="cov0" title="0">destPath := req.DestinationPath

        // Check if destination exists and handle overwrite
        if !req.Overwrite </span><span class="cov0" title="0">{
                if _, err := os.Stat(destPath); err == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Destination file already exists"})
                        return
                }</span>
        }

        // Create destination directory if needed
        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(destPath), 0755); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create destination directory", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create destination directory"})
                return
        }</span>

        // Download from SMB to local
        <span class="cov0" title="0">err := h.smbService.DownloadFile(sourceHost, sourcePath, destPath)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to copy file from SMB to local",
                        zap.String("source", req.SourcePath),
                        zap.String("destination", destPath),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Copy operation failed"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("File copied successfully from SMB to local",
                zap.String("source", req.SourcePath),
                zap.String("destination", destPath))

        c.JSON(http.StatusOK, gin.H{
                "message":     "File copied successfully to local filesystem",
                "source":      req.SourcePath,
                "destination": destPath,
        })</span>
}

// @Summary Upload file from local to SMB
// @Description Upload a file from local filesystem to SMB share
// @Tags copy
// @Accept multipart/form-data
// @Param file formData file true "File to upload"
// @Param destination formData string true "Destination path (host:path)"
// @Param overwrite formData bool false "Overwrite existing file"
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/copy/upload [post]
func (h *CopyHandler) CopyFromLocal(c *gin.Context) <span class="cov0" title="0">{
        // Get uploaded file
        file, header, err := c.Request.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "No file uploaded"})
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        destination := c.PostForm("destination")
        if destination == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Destination path is required"})
                return
        }</span>

        <span class="cov0" title="0">overwrite := c.PostForm("overwrite") == "true"

        // Parse destination
        destHost, destPath := h.parseHostPath(destination)
        if destHost == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid destination format. Use 'host:path'"})
                return
        }</span>

        // Check if destination exists and handle overwrite
        <span class="cov0" title="0">if !overwrite </span><span class="cov0" title="0">{
                exists, err := h.smbService.FileExists(destHost, destPath)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to check destination file", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check destination"})
                        return
                }</span>
                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Destination file already exists"})
                        return
                }</span>
        }

        // Save uploaded file to temp location
        <span class="cov0" title="0">tempFile, err := os.CreateTemp(h.tempDir, "upload_*")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create temp file", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process upload"})
                return
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempFile.Name())
        defer tempFile.Close()

        // Copy uploaded data to temp file
        _, err = tempFile.ReadFrom(file)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to save uploaded file", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save upload"})
                return
        }</span>

        // Upload to SMB
        <span class="cov0" title="0">err = h.smbService.UploadFile(destHost, tempFile.Name(), destPath)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to upload file to SMB",
                        zap.String("filename", header.Filename),
                        zap.String("destination", destination),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Upload to SMB failed"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("File uploaded successfully to SMB",
                zap.String("filename", header.Filename),
                zap.String("destination", destination),
                zap.Int64("size", header.Size))

        c.JSON(http.StatusOK, gin.H{
                "message":     "File uploaded successfully",
                "filename":    header.Filename,
                "destination": destination,
                "size":        header.Size,
        })</span>
}

// @Summary List files in SMB directory
// @Description List files and directories in an SMB share
// @Tags smb
// @Param host query string true "SMB host name"
// @Param path path string false "Directory path"
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/smb/list/{path} [get]
func (h *CopyHandler) ListSMBPath(c *gin.Context) <span class="cov0" title="0">{
        hostName := c.Query("host")
        if hostName == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Host name is required"})
                return
        }</span>

        <span class="cov0" title="0">path := c.Param("path")
        if path == "" </span><span class="cov0" title="0">{
                path = "/"
        }</span>

        // Remove leading slash if present
        <span class="cov0" title="0">if path[0] == '/' </span><span class="cov0" title="0">{
                path = path[1:]
        }</span>

        <span class="cov0" title="0">files, err := h.smbService.ListFiles(hostName, path)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to list SMB directory",
                        zap.String("host", hostName),
                        zap.String("path", path),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list directory"})
                return
        }</span>

        // Convert os.FileInfo to a more JSON-friendly format
        <span class="cov0" title="0">var fileList []map[string]interface{}
        for _, file := range files </span><span class="cov0" title="0">{
                fileList = append(fileList, map[string]interface{}{
                        "name":          file.Name(),
                        "size":          file.Size(),
                        "is_directory":  file.IsDir(),
                        "last_modified": file.ModTime(),
                        "mode":          file.Mode().String(),
                })
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "host":  hostName,
                "path":  path,
                "files": fileList,
                "count": len(fileList),
        })</span>
}

// Helper function to parse host:path format
func (h *CopyHandler) parseHostPath(hostPath string) (string, string) <span class="cov0" title="0">{
        parts := strings.SplitN(hostPath, ":", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return "", ""
        }</span>
        <span class="cov0" title="0">return parts[0], parts[1]</span>
}

// @Summary Get available SMB hosts
// @Description Get list of configured SMB hosts
// @Tags smb
// @Produce json
// @Success 200 {array} string
// @Router /api/v1/smb/hosts [get]
func (h *CopyHandler) GetSMBHosts(c *gin.Context) <span class="cov0" title="0">{
        hosts := h.smbService.GetHosts()
        c.JSON(http.StatusOK, gin.H{
                "hosts": hosts,
                "count": len(hosts),
        })
}</span>

// @Summary Copy file to storage
// @Description Copy a file to a storage location
// @Tags copy
// @Accept json
// @Produce json
// @Param request body object true "Copy to storage request"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/copy/storage [post]
func (h *CopyHandler) CopyToStorage(c *gin.Context) <span class="cov10" title="7">{
        var req struct {
                SourcePath string `json:"source_path" binding:"required"`
                DestPath   string `json:"dest_path" binding:"required"`
                StorageID  string `json:"storage_id" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="5">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Implement storage copy logic
        <span class="cov4" title="2">c.JSON(http.StatusOK, gin.H{
                "message":     "File copied to storage successfully",
                "source":      req.SourcePath,
                "destination": req.DestPath,
                "storage_id":  req.StorageID,
        })</span>
}

// @Summary List files in storage path
// @Description List files in a storage path
// @Tags storage
// @Param path path string true "Storage path"
// @Param storage_id query string true "Storage ID"
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Router /api/v1/storage/list/{path} [get]
func (h *CopyHandler) ListStoragePath(c *gin.Context) <span class="cov8" title="5">{
        path := c.Param("path")
        storageID := c.Query("storage_id")

        if storageID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "storage_id is required"})
                return
        }</span>

        // Return mock data for now
        <span class="cov7" title="4">c.JSON(http.StatusOK, gin.H{
                "path":       path,
                "storage_id": storageID,
                "files":      []gin.H{},
        })</span>
}

// @Summary Get storage roots
// @Description Get available storage roots
// @Tags storage
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Router /api/v1/storage/roots [get]
func (h *CopyHandler) GetStorageRoots(c *gin.Context) <span class="cov6" title="3">{
        roots := []gin.H{
                {"id": "local", "name": "Local Storage", "path": "/data/storage"},
                {"id": "smb", "name": "SMB Storage", "path": "smb://server/share"},
        }

        c.JSON(http.StatusOK, gin.H{"roots": roots})
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package handlers

import (
        "archive/tar"
        "archive/zip"
        "catalogizer/internal/models"
        "catalogizer/internal/services"
        "compress/gzip"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type DownloadHandler struct {
        catalogService *services.CatalogService
        smbService     *services.SMBService
        tempDir        string
        maxArchiveSize int64
        chunkSize      int
        logger         *zap.Logger
}

func NewDownloadHandler(catalogService *services.CatalogService, smbService *services.SMBService, tempDir string, maxArchiveSize int64, chunkSize int, logger *zap.Logger) *DownloadHandler <span class="cov0" title="0">{
        return &amp;DownloadHandler{
                catalogService: catalogService,
                smbService:     smbService,
                tempDir:        tempDir,
                maxArchiveSize: maxArchiveSize,
                chunkSize:      chunkSize,
                logger:         logger,
        }
}</span>

// @Summary Download a single file
// @Description Download a file from the catalog
// @Tags download
// @Param id path int true "File ID"
// @Produce application/octet-stream
// @Success 200 {file} binary
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/download/file/{id} [get]
func (h *DownloadHandler) DownloadFile(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid file ID"})
                return
        }</span>

        <span class="cov0" title="0">fileInfo, err := h.catalogService.GetFileInfo(strconv.FormatInt(id, 10))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get file info", zap.Int64("id", id), zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get file information"})
                return
        }</span>

        <span class="cov0" title="0">if fileInfo == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "File not found"})
                return
        }</span>

        <span class="cov0" title="0">if fileInfo.IsDirectory </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Cannot download directory as single file"})
                return
        }</span>

        // Create temporary file for download
        <span class="cov0" title="0">tempFile, err := os.CreateTemp(h.tempDir, "download_*")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create temp file", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to prepare download"})
                return
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempFile.Name())
        defer tempFile.Close()

        // Download from SMB to temp file
        err = h.smbService.DownloadFile(fileInfo.SmbRoot, fileInfo.Path, tempFile.Name())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to download from SMB", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to download file"})
                return
        }</span>

        // Stream file to client
        <span class="cov0" title="0">c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", fileInfo.Name))
        c.Header("Content-Type", "application/octet-stream")
        c.Header("Content-Length", strconv.FormatInt(fileInfo.Size, 10))

        tempFile.Seek(0, 0)
        _, err = io.CopyBuffer(c.Writer, tempFile, make([]byte, h.chunkSize))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to stream file", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("File downloaded successfully", zap.String("file", fileInfo.Name), zap.Int64("id", id))</span>
}

// @Summary Download directory as archive
// @Description Download a directory and its contents as a compressed archive
// @Tags download
// @Param path path string true "Directory path"
// @Param format query string false "Archive format (zip, tar, tar.gz)" default(zip)
// @Produce application/octet-stream
// @Success 200 {file} binary
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/download/directory/{path} [get]
func (h *DownloadHandler) DownloadDirectory(c *gin.Context) <span class="cov0" title="0">{
        path := c.Param("path")
        if path == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Path is required"})
                return
        }</span>

        <span class="cov0" title="0">format := c.DefaultQuery("format", "zip")
        if format != "zip" &amp;&amp; format != "tar" &amp;&amp; format != "tar.gz" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid format. Supported: zip, tar, tar.gz"})
                return
        }</span>

        // Clean the path
        <span class="cov0" title="0">if strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                path = path[1:]
        }</span>

        // Get directory listing recursively
        <span class="cov0" title="0">files, err := h.getDirectoryContentsRecursive(path)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get directory contents", zap.String("path", path), zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to read directory"})
                return
        }</span>

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Directory not found or empty"})
                return
        }</span>

        // Check total size
        <span class="cov0" title="0">var totalSize int64
        for _, file := range files </span><span class="cov0" title="0">{
                totalSize += file.Size
        }</span>

        <span class="cov0" title="0">if totalSize &gt; h.maxArchiveSize </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":      "Directory too large for download",
                        "total_size": totalSize,
                        "max_size":   h.maxArchiveSize,
                })
                return
        }</span>

        // Create archive
        <span class="cov0" title="0">filename := filepath.Base(path) + "." + format
        c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))

        switch format </span>{
        case "zip":<span class="cov0" title="0">
                c.Header("Content-Type", "application/zip")
                h.createZipArchive(c.Writer, files)</span>
        case "tar":<span class="cov0" title="0">
                c.Header("Content-Type", "application/x-tar")
                h.createTarArchive(c.Writer, files, false)</span>
        case "tar.gz":<span class="cov0" title="0">
                c.Header("Content-Type", "application/gzip")
                h.createTarArchive(c.Writer, files, true)</span>
        }

        <span class="cov0" title="0">h.logger.Info("Directory downloaded successfully", zap.String("path", path), zap.String("format", format))</span>
}

// @Summary Create archive from multiple files
// @Description Create and download an archive containing specified files
// @Tags download
// @Accept json
// @Param request body models.DownloadRequest true "Download request"
// @Produce application/octet-stream
// @Success 200 {file} binary
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/download/archive [post]
func (h *DownloadHandler) DownloadArchive(c *gin.Context) <span class="cov0" title="0">{
        var req models.DownloadRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">if len(req.Paths) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "No paths specified"})
                return
        }</span>

        <span class="cov0" title="0">if req.Format == "" </span><span class="cov0" title="0">{
                req.Format = "zip"
        }</span>

        <span class="cov0" title="0">if req.Format != "zip" &amp;&amp; req.Format != "tar" &amp;&amp; req.Format != "tar.gz" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid format. Supported: zip, tar, tar.gz"})
                return
        }</span>

        // Get file information for all paths
        <span class="cov0" title="0">var files []models.FileInfo
        var totalSize int64

        for _, path := range req.Paths </span><span class="cov0" title="0">{
                // This is a simplified implementation - you'd need to implement path-to-ID conversion
                // or modify the catalog service to search by path
                fileList, err := h.getFilesByPath(path, req.SmbRoot)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to get files for path", zap.String("path", path), zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">for _, file := range fileList </span><span class="cov0" title="0">{
                        totalSize += file.Size
                        files = append(files, file)
                }</span>
        }

        <span class="cov0" title="0">if totalSize &gt; h.maxArchiveSize </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":      "Total size too large for download",
                        "total_size": totalSize,
                        "max_size":   h.maxArchiveSize,
                })
                return
        }</span>

        // Create archive
        <span class="cov0" title="0">filename := fmt.Sprintf("archive_%d.%s", time.Now().Unix(), req.Format)
        c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))

        switch req.Format </span>{
        case "zip":<span class="cov0" title="0">
                c.Header("Content-Type", "application/zip")
                h.createZipArchive(c.Writer, files)</span>
        case "tar":<span class="cov0" title="0">
                c.Header("Content-Type", "application/x-tar")
                h.createTarArchive(c.Writer, files, false)</span>
        case "tar.gz":<span class="cov0" title="0">
                c.Header("Content-Type", "application/gzip")
                h.createTarArchive(c.Writer, files, true)</span>
        }

        <span class="cov0" title="0">h.logger.Info("Archive downloaded successfully", zap.Int("file_count", len(files)), zap.String("format", req.Format))</span>
}

func (h *DownloadHandler) createZipArchive(w io.Writer, files []models.FileInfo) error <span class="cov0" title="0">{
        zipWriter := zip.NewWriter(w)
        defer zipWriter.Close()

        for _, file := range files </span><span class="cov0" title="0">{
                if file.IsDirectory </span><span class="cov0" title="0">{
                        continue</span> // Skip directories for now
                }

                // Download file to temp location
                <span class="cov0" title="0">tempFile, err := os.CreateTemp(h.tempDir, "zip_*")
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to create temp file for zip", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">err = h.smbService.DownloadFile(file.SmbRoot, file.Path, tempFile.Name())
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to download file for zip", zap.String("path", file.Path), zap.Error(err))
                        tempFile.Close()
                        os.Remove(tempFile.Name())
                        continue</span>
                }

                // Add to zip
                <span class="cov0" title="0">zipFile, err := zipWriter.Create(file.Path)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to create zip entry", zap.String("path", file.Path), zap.Error(err))
                        tempFile.Close()
                        os.Remove(tempFile.Name())
                        continue</span>
                }

                <span class="cov0" title="0">tempFile.Seek(0, 0)
                _, err = io.Copy(zipFile, tempFile)
                tempFile.Close()
                os.Remove(tempFile.Name())

                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to write zip entry", zap.String("path", file.Path), zap.Error(err))
                        continue</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (h *DownloadHandler) createTarArchive(w io.Writer, files []models.FileInfo, compress bool) error <span class="cov0" title="0">{
        var tarWriter *tar.Writer

        if compress </span><span class="cov0" title="0">{
                gzWriter := gzip.NewWriter(w)
                defer gzWriter.Close()
                tarWriter = tar.NewWriter(gzWriter)
        }</span> else<span class="cov0" title="0"> {
                tarWriter = tar.NewWriter(w)
        }</span>
        <span class="cov0" title="0">defer tarWriter.Close()

        for _, file := range files </span><span class="cov0" title="0">{
                if file.IsDirectory </span><span class="cov0" title="0">{
                        continue</span> // Skip directories for now
                }

                // Download file to temp location
                <span class="cov0" title="0">tempFile, err := os.CreateTemp(h.tempDir, "tar_*")
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to create temp file for tar", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">err = h.smbService.DownloadFile(file.SmbRoot, file.Path, tempFile.Name())
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to download file for tar", zap.String("path", file.Path), zap.Error(err))
                        tempFile.Close()
                        os.Remove(tempFile.Name())
                        continue</span>
                }

                // Create tar header
                <span class="cov0" title="0">header := &amp;tar.Header{
                        Name:    file.Path,
                        Size:    file.Size,
                        Mode:    0644,
                        ModTime: file.LastModified,
                }

                err = tarWriter.WriteHeader(header)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to write tar header", zap.String("path", file.Path), zap.Error(err))
                        tempFile.Close()
                        os.Remove(tempFile.Name())
                        continue</span>
                }

                <span class="cov0" title="0">tempFile.Seek(0, 0)
                _, err = io.Copy(tarWriter, tempFile)
                tempFile.Close()
                os.Remove(tempFile.Name())

                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to write tar entry", zap.String("path", file.Path), zap.Error(err))
                        continue</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper functions
func (h *DownloadHandler) getDirectoryContentsRecursive(path string) ([]models.FileInfo, error) <span class="cov0" title="0">{
        // This is a placeholder implementation
        // You would need to implement recursive directory traversal
        // using your catalog service
        return []models.FileInfo{}, nil
}</span>

func (h *DownloadHandler) getFilesByPath(path, smbRoot string) ([]models.FileInfo, error) <span class="cov0" title="0">{
        // This is a placeholder implementation
        // You would need to implement path-based file lookup
        return []models.FileInfo{}, nil
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gorilla/mux"
        "go.uber.org/zap"

        "catalogizer/internal/services"
)

type LocalizationHandlers struct {
        logger              *zap.Logger
        localizationService *services.LocalizationService
}

func NewLocalizationHandlers(
        logger *zap.Logger,
        localizationService *services.LocalizationService,
) *LocalizationHandlers <span class="cov0" title="0">{
        return &amp;LocalizationHandlers{
                logger:              logger,
                localizationService: localizationService,
        }
}</span>

func (h *LocalizationHandlers) RegisterRoutes(router *mux.Router) <span class="cov0" title="0">{
        api := router.PathPrefix("/api/v1").Subrouter()

        // Installation Wizard Routes
        api.HandleFunc("/wizard/localization/defaults", h.GetWizardDefaults).Methods("GET", "OPTIONS")
        api.HandleFunc("/wizard/localization/setup", h.SetupWizardLocalization).Methods("POST", "OPTIONS")

        // JSON Configuration Routes
        api.HandleFunc("/wizard/configuration/export", h.ExportConfiguration).Methods("POST", "OPTIONS")
        api.HandleFunc("/wizard/configuration/import", h.ImportConfiguration).Methods("POST", "OPTIONS")
        api.HandleFunc("/wizard/configuration/validate", h.ValidateConfiguration).Methods("POST", "OPTIONS")
        api.HandleFunc("/wizard/configuration/edit", h.EditConfiguration).Methods("POST", "OPTIONS")
        api.HandleFunc("/wizard/configuration/templates", h.GetConfigurationTemplates).Methods("GET", "OPTIONS")

        // Localization Management Routes
        api.HandleFunc("/localization", h.GetUserLocalization).Methods("GET", "OPTIONS")
        api.HandleFunc("/localization", h.UpdateUserLocalization).Methods("PUT", "OPTIONS")
        api.HandleFunc("/localization/languages", h.GetSupportedLanguages).Methods("GET", "OPTIONS")
        api.HandleFunc("/localization/languages/{languageCode}", h.GetLanguageProfile).Methods("GET", "OPTIONS")
        api.HandleFunc("/localization/preferences/{contentType}", h.GetContentLanguagePreferences).Methods("GET", "OPTIONS")
        api.HandleFunc("/localization/stats", h.GetLocalizationStats).Methods("GET", "OPTIONS")

        // Content-specific Routes
        api.HandleFunc("/localization/detect", h.DetectLanguage).Methods("POST", "OPTIONS")
        api.HandleFunc("/localization/check-support", h.CheckLanguageSupport).Methods("POST", "OPTIONS")
        api.HandleFunc("/localization/format-datetime", h.FormatDateTime).Methods("POST", "OPTIONS")

        // Add CORS middleware
        api.Use(h.corsMiddleware)
}</span>

// Installation Wizard Handlers

func (h *LocalizationHandlers) GetWizardDefaults(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Debug("Getting wizard localization defaults")

        userAgent := r.Header.Get("User-Agent")
        acceptLanguage := r.Header.Get("Accept-Language")

        detectedLanguage := h.localizationService.DetectUserLanguage(r.Context(), userAgent, acceptLanguage)
        defaults := h.localizationService.GetWizardDefaults(r.Context(), detectedLanguage)

        h.sendSuccess(w, map[string]interface{}{
                "detected_language": detectedLanguage,
                "defaults":          defaults,
        })
}</span>

func (h *LocalizationHandlers) SetupWizardLocalization(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Info("Setting up wizard localization")

        var req services.WizardLocalizationStep
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.UserID == 0 </span><span class="cov0" title="0">{
                userID := h.getUserID(r)
                if userID == 0 </span><span class="cov0" title="0">{
                        h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">req.UserID = userID</span>
        }

        <span class="cov0" title="0">if req.PrimaryLanguage == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Primary language is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">localization, err := h.localizationService.SetupUserLocalization(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to setup user localization", zap.Error(err))
                h.sendError(w, "Failed to setup localization preferences", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]interface{}{
                "localization": localization,
                "message":      "Localization preferences configured successfully",
        })</span>
}

// Localization Management Handlers

func (h *LocalizationHandlers) GetUserLocalization(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">localization, err := h.localizationService.GetUserLocalization(r.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get user localization", zap.Error(err))
                h.sendError(w, "Failed to get localization preferences", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, localization)</span>
}

func (h *LocalizationHandlers) UpdateUserLocalization(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var updates map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;updates); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.localizationService.UpdateUserLocalization(r.Context(), userID, updates)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update user localization", zap.Error(err))
                h.sendError(w, "Failed to update localization preferences", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Localization preferences updated successfully"})</span>
}

func (h *LocalizationHandlers) GetSupportedLanguages(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Debug("Getting supported languages")

        languages, err := h.localizationService.GetSupportedLanguages(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get supported languages", zap.Error(err))
                h.sendError(w, "Failed to get supported languages", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, languages)</span>
}

func (h *LocalizationHandlers) GetLanguageProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        languageCode := mux.Vars(r)["languageCode"]

        profile, err := h.localizationService.GetLanguageProfile(r.Context(), languageCode)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get language profile",
                        zap.String("language", languageCode),
                        zap.Error(err))
                h.sendError(w, "Language not supported", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, profile)</span>
}

func (h *LocalizationHandlers) GetContentLanguagePreferences(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">contentType := mux.Vars(r)["contentType"]

        languages, err := h.localizationService.GetPreferredLanguagesForContent(r.Context(), userID, contentType)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get content language preferences",
                        zap.Int64("user_id", userID),
                        zap.String("content_type", contentType),
                        zap.Error(err))
                h.sendError(w, "Failed to get language preferences", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">autoTranslate, _ := h.localizationService.ShouldAutoTranslate(r.Context(), userID, contentType)
        autoDownload, _ := h.localizationService.ShouldAutoDownload(r.Context(), userID, contentType)

        h.sendSuccess(w, map[string]interface{}{
                "languages":      languages,
                "auto_translate": autoTranslate,
                "auto_download":  autoDownload,
        })</span>
}

func (h *LocalizationHandlers) GetLocalizationStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Debug("Getting localization statistics")

        stats, err := h.localizationService.GetLocalizationStats(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get localization stats", zap.Error(err))
                h.sendError(w, "Failed to get localization statistics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, stats)</span>
}

// JSON Configuration Handlers

func (h *LocalizationHandlers) ExportConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ConfigType  string   `json:"config_type"`
                Description string   `json:"description"`
                Tags        []string `json:"tags"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ConfigType == "" </span><span class="cov0" title="0">{
                req.ConfigType = "full"
        }</span>

        <span class="cov0" title="0">config, err := h.localizationService.ExportConfiguration(r.Context(), userID, req.ConfigType, req.Description, req.Tags)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to export configuration",
                        zap.Int64("user_id", userID),
                        zap.String("config_type", req.ConfigType),
                        zap.Error(err))
                h.sendError(w, "Failed to export configuration", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, config)</span>
}

func (h *LocalizationHandlers) ImportConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ConfigJSON string          `json:"config_json"`
                Options    map[string]bool `json:"options"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ConfigJSON == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Configuration JSON is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Options == nil </span><span class="cov0" title="0">{
                req.Options = map[string]bool{
                        "overwrite_existing": false,
                        "backup_current":     true,
                        "validate_only":      false,
                }
        }</span>

        <span class="cov0" title="0">result, err := h.localizationService.ImportConfiguration(r.Context(), userID, req.ConfigJSON, req.Options)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to import configuration",
                        zap.Int64("user_id", userID),
                        zap.Error(err))
                h.sendError(w, fmt.Sprintf("Failed to import configuration: %v", err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, result)</span>
}

func (h *LocalizationHandlers) ValidateConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                ConfigJSON string `json:"config_json"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ConfigJSON == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Configuration JSON is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">validation, err := h.localizationService.ValidateConfigurationJSON(r.Context(), req.ConfigJSON)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to validate configuration", zap.Error(err))
                h.sendError(w, "Failed to validate configuration", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, validation)</span>
}

func (h *LocalizationHandlers) EditConfiguration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ConfigJSON string                 `json:"config_json"`
                Edits      map[string]interface{} `json:"edits"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ConfigJSON == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Configuration JSON is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Edits == nil </span><span class="cov0" title="0">{
                h.sendError(w, "Edits are required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">editedConfig, err := h.localizationService.EditConfiguration(r.Context(), userID, req.ConfigJSON, req.Edits)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to edit configuration",
                        zap.Int64("user_id", userID),
                        zap.Error(err))
                h.sendError(w, fmt.Sprintf("Failed to edit configuration: %v", err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]interface{}{
                "edited_config": editedConfig,
                "message":       "Configuration edited successfully",
        })</span>
}

func (h *LocalizationHandlers) GetConfigurationTemplates(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Debug("Getting configuration templates")

        // Get all template types
        templateTypes := []string{"localization", "media", "playlists", "full"}
        templates := make(map[string]interface{})

        for _, templateType := range templateTypes </span><span class="cov0" title="0">{
                template, err := h.localizationService.GetConfigurationTemplate(r.Context(), templateType)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Warn("Failed to get template",
                                zap.String("type", templateType),
                                zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">templates[templateType] = template</span>
        }

        <span class="cov0" title="0">h.sendSuccess(w, map[string]interface{}{
                "templates": templates,
                "count":     len(templates),
        })</span>
}

// Content-specific Handlers

func (h *LocalizationHandlers) DetectLanguage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                UserAgent      string `json:"user_agent"`
                AcceptLanguage string `json:"accept_language"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.UserAgent == "" </span><span class="cov0" title="0">{
                req.UserAgent = r.Header.Get("User-Agent")
        }</span>
        <span class="cov0" title="0">if req.AcceptLanguage == "" </span><span class="cov0" title="0">{
                req.AcceptLanguage = r.Header.Get("Accept-Language")
        }</span>

        <span class="cov0" title="0">detectedLanguage := h.localizationService.DetectUserLanguage(r.Context(), req.UserAgent, req.AcceptLanguage)

        h.sendSuccess(w, map[string]interface{}{
                "detected_language": detectedLanguage,
                "confidence":        1.0,
        })</span>
}

func (h *LocalizationHandlers) CheckLanguageSupport(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                LanguageCode string `json:"language_code"`
                ContentType  string `json:"content_type"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.LanguageCode == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Language code is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.ContentType == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Content type is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">supported := h.localizationService.IsLanguageSupported(r.Context(), req.LanguageCode, req.ContentType)

        profile, err := h.localizationService.GetLanguageProfile(r.Context(), req.LanguageCode)
        var qualityRating float64
        var providers []string

        if err == nil </span><span class="cov0" title="0">{
                qualityRating = profile.QualityRating
                providers = profile.SupportedBy
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]interface{}{
                "supported":      supported,
                "language_code":  req.LanguageCode,
                "content_type":   req.ContentType,
                "quality_rating": qualityRating,
                "providers":      providers,
        })</span>
}

func (h *LocalizationHandlers) FormatDateTime(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Timestamp string `json:"timestamp"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Timestamp == "" </span><span class="cov0" title="0">{
                h.sendError(w, "Timestamp is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">timestamp, err := parseTimestamp(req.Timestamp)
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid timestamp format", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">formatted, err := h.localizationService.FormatDateTimeForUser(r.Context(), userID, timestamp)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to format datetime", zap.Error(err))
                h.sendError(w, "Failed to format datetime", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]interface{}{
                "original":  req.Timestamp,
                "formatted": formatted,
                "timezone":  timestamp.Location().String(),
        })</span>
}

// Helper Methods

func (h *LocalizationHandlers) sendSuccess(w http.ResponseWriter, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(APIResponse{
                Success: true,
                Data:    data,
        })
}</span>

func (h *LocalizationHandlers) sendError(w http.ResponseWriter, message string, statusCode int) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(APIResponse{
                Success: false,
                Error:   message,
        })
}</span>

func (h *LocalizationHandlers) getUserID(r *http.Request) int64 <span class="cov0" title="0">{
        userIDStr := r.Header.Get("X-User-ID")
        if userIDStr == "" </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">userID, err := strconv.ParseInt(userIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return userID</span>
}

func (h *LocalizationHandlers) corsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-User-ID, Accept-Language")
                w.Header().Set("Access-Control-Max-Age", "86400")

                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

func parseTimestamp(timestampStr string) (time.Time, error) <span class="cov0" title="0">{
        formats := []string{
                "2006-01-02T15:04:05Z",
                "2006-01-02T15:04:05.000Z",
                "2006-01-02T15:04:05-07:00",
                "2006-01-02 15:04:05",
                "2006-01-02",
                "1136239445", // Unix timestamp
        }

        for _, format := range formats </span><span class="cov0" title="0">{
                if timestamp, err := time.Parse(format, timestampStr); err == nil </span><span class="cov0" title="0">{
                        return timestamp, nil
                }</span>
        }

        // Try parsing as Unix timestamp
        <span class="cov0" title="0">if unix, err := strconv.ParseInt(timestampStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                return time.Unix(unix, 0), nil
        }</span>

        <span class="cov0" title="0">return time.Time{}, fmt.Errorf("unable to parse timestamp: %s", timestampStr)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package handlers

import (
        "catalogizer/internal/media/analyzer"
        "catalogizer/internal/media/database"
        "catalogizer/internal/media/models"
        "database/sql"
        "encoding/json"
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// MediaHandler handles media metadata endpoints
type MediaHandler struct {
        mediaDB  *database.MediaDatabase
        analyzer *analyzer.MediaAnalyzer
        logger   *zap.Logger
}

// NewMediaHandler creates a new media handler
func NewMediaHandler(mediaDB *database.MediaDatabase, analyzer *analyzer.MediaAnalyzer, logger *zap.Logger) *MediaHandler <span class="cov0" title="0">{
        return &amp;MediaHandler{
                mediaDB:  mediaDB,
                analyzer: analyzer,
                logger:   logger,
        }
}</span>

// @Summary Get all media types
// @Description Get list of all supported media types
// @Tags media
// @Produce json
// @Success 200 {array} models.MediaType
// @Failure 500 {object} map[string]string
// @Router /api/v1/media/types [get]
func (h *MediaHandler) GetMediaTypes(c *gin.Context) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, detection_patterns, metadata_providers, created_at, updated_at
                FROM media_types
                ORDER BY name
        `

        rows, err := h.mediaDB.GetDB().Query(query)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get media types", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve media types"})
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var mediaTypes []models.MediaType
        for rows.Next() </span><span class="cov0" title="0">{
                var mt models.MediaType
                var patternsJSON, providersJSON string

                err := rows.Scan(
                        &amp;mt.ID, &amp;mt.Name, &amp;mt.Description, &amp;patternsJSON, &amp;providersJSON,
                        &amp;mt.CreatedAt, &amp;mt.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to scan media type", zap.Error(err))
                        continue</span>
                }

                // Parse JSON fields
                <span class="cov0" title="0">json.Unmarshal([]byte(patternsJSON), &amp;mt.DetectionPatterns)
                json.Unmarshal([]byte(providersJSON), &amp;mt.MetadataProviders)

                mediaTypes = append(mediaTypes, mt)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "media_types": mediaTypes,
                "count":       len(mediaTypes),
        })</span>
}

// @Summary Search media items
// @Description Search for media items with various filters
// @Tags media
// @Param query query string false "Search query"
// @Param media_types query string false "Comma-separated media type names"
// @Param year query int false "Specific year"
// @Param year_from query int false "Year range from"
// @Param year_to query int false "Year range to"
// @Param genre query string false "Comma-separated genres"
// @Param min_rating query number false "Minimum rating"
// @Param has_externals query bool false "Has external metadata"
// @Param quality query string false "Comma-separated quality levels"
// @Param smb_roots query string false "Comma-separated SMB roots"
// @Param watched_status query string false "Watched status"
// @Param sort_by query string false "Sort field" default(title)
// @Param sort_order query string false "Sort order" default(asc)
// @Param limit query int false "Limit results" default(50)
// @Param offset query int false "Offset for pagination" default(0)
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/media/search [get]
func (h *MediaHandler) SearchMedia(c *gin.Context) <span class="cov0" title="0">{
        var req models.MediaSearchRequest

        // Parse query parameters
        req.Query = c.Query("query")
        req.SortBy = c.DefaultQuery("sort_by", "title")
        req.SortOrder = c.DefaultQuery("sort_order", "asc")
        req.Limit, _ = strconv.Atoi(c.DefaultQuery("limit", "50"))
        req.Offset, _ = strconv.Atoi(c.DefaultQuery("offset", "0"))

        // Parse media types
        if mediaTypesStr := c.Query("media_types"); mediaTypesStr != "" </span><span class="cov0" title="0">{
                req.MediaTypes = strings.Split(mediaTypesStr, ",")
        }</span>

        // Parse year
        <span class="cov0" title="0">if yearStr := c.Query("year"); yearStr != "" </span><span class="cov0" title="0">{
                if year, err := strconv.Atoi(yearStr); err == nil </span><span class="cov0" title="0">{
                        req.Year = &amp;year
                }</span>
        }

        // Parse year range
        <span class="cov0" title="0">if yearFromStr := c.Query("year_from"); yearFromStr != "" </span><span class="cov0" title="0">{
                if yearFrom, err := strconv.Atoi(yearFromStr); err == nil </span><span class="cov0" title="0">{
                        if req.YearRange == nil </span><span class="cov0" title="0">{
                                req.YearRange = &amp;models.YearRange{}
                        }</span>
                        <span class="cov0" title="0">req.YearRange.From = yearFrom</span>
                }
        }
        <span class="cov0" title="0">if yearToStr := c.Query("year_to"); yearToStr != "" </span><span class="cov0" title="0">{
                if yearTo, err := strconv.Atoi(yearToStr); err == nil </span><span class="cov0" title="0">{
                        if req.YearRange == nil </span><span class="cov0" title="0">{
                                req.YearRange = &amp;models.YearRange{}
                        }</span>
                        <span class="cov0" title="0">req.YearRange.To = yearTo</span>
                }
        }

        // Parse other filters
        <span class="cov0" title="0">if genreStr := c.Query("genre"); genreStr != "" </span><span class="cov0" title="0">{
                req.Genre = strings.Split(genreStr, ",")
        }</span>
        <span class="cov0" title="0">if qualityStr := c.Query("quality"); qualityStr != "" </span><span class="cov0" title="0">{
                req.Quality = strings.Split(qualityStr, ",")
        }</span>
        <span class="cov0" title="0">if smbRootsStr := c.Query("smb_roots"); smbRootsStr != "" </span><span class="cov0" title="0">{
                req.SmbRoots = strings.Split(smbRootsStr, ",")
        }</span>

        <span class="cov0" title="0">if minRatingStr := c.Query("min_rating"); minRatingStr != "" </span><span class="cov0" title="0">{
                if minRating, err := strconv.ParseFloat(minRatingStr, 64); err == nil </span><span class="cov0" title="0">{
                        req.MinRating = &amp;minRating
                }</span>
        }

        <span class="cov0" title="0">if hasExternalsStr := c.Query("has_externals"); hasExternalsStr != "" </span><span class="cov0" title="0">{
                hasExternals := hasExternalsStr == "true"
                req.HasExternals = &amp;hasExternals
        }</span>

        <span class="cov0" title="0">req.WatchedStatus = &amp;[]string{c.Query("watched_status")}[0]

        // Build query
        baseQuery := `
                SELECT mi.id, mi.media_type_id, mi.title, mi.original_title, mi.year, mi.description,
                       mi.genre, mi.director, mi.cast_crew, mi.rating, mi.runtime, mi.language, mi.country,
                       mi.status, mi.first_detected, mi.last_updated,
                       mt.name as media_type_name, mt.description as media_type_description
                FROM media_items mi
                JOIN media_types mt ON mi.media_type_id = mt.id
                WHERE 1=1
        `

        countQuery := `
                SELECT COUNT(*)
                FROM media_items mi
                JOIN media_types mt ON mi.media_type_id = mt.id
                WHERE 1=1
        `

        var conditions []string
        var args []interface{}

        // Add search conditions
        if req.Query != "" </span><span class="cov0" title="0">{
                conditions = append(conditions, "(mi.title LIKE ? OR mi.original_title LIKE ?)")
                searchTerm := "%" + req.Query + "%"
                args = append(args, searchTerm, searchTerm)
        }</span>

        <span class="cov0" title="0">if len(req.MediaTypes) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := strings.Repeat("?,", len(req.MediaTypes))
                placeholders = placeholders[:len(placeholders)-1]
                conditions = append(conditions, "mt.name IN ("+placeholders+")")
                for _, mt := range req.MediaTypes </span><span class="cov0" title="0">{
                        args = append(args, mt)
                }</span>
        }

        <span class="cov0" title="0">if req.Year != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "mi.year = ?")
                args = append(args, *req.Year)
        }</span>

        <span class="cov0" title="0">if req.YearRange != nil </span><span class="cov0" title="0">{
                if req.YearRange.From &gt; 0 </span><span class="cov0" title="0">{
                        conditions = append(conditions, "mi.year &gt;= ?")
                        args = append(args, req.YearRange.From)
                }</span>
                <span class="cov0" title="0">if req.YearRange.To &gt; 0 </span><span class="cov0" title="0">{
                        conditions = append(conditions, "mi.year &lt;= ?")
                        args = append(args, req.YearRange.To)
                }</span>
        }

        <span class="cov0" title="0">if req.MinRating != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "mi.rating &gt;= ?")
                args = append(args, *req.MinRating)
        }</span>

        <span class="cov0" title="0">if req.HasExternals != nil &amp;&amp; *req.HasExternals </span><span class="cov0" title="0">{
                conditions = append(conditions, "EXISTS (SELECT 1 FROM external_metadata em WHERE em.media_item_id = mi.id)")
        }</span>

        // Build final queries
        <span class="cov0" title="0">whereClause := ""
        if len(conditions) &gt; 0 </span><span class="cov0" title="0">{
                whereClause = " AND " + strings.Join(conditions, " AND ")
        }</span>

        // Get total count
        <span class="cov0" title="0">var total int64
        err := h.mediaDB.GetDB().QueryRow(countQuery+whereClause, args...).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to count search results", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Search failed"})
                return
        }</span>

        // Add sorting and pagination
        <span class="cov0" title="0">finalQuery := baseQuery + whereClause
        switch req.SortBy </span>{
        case "title":<span class="cov0" title="0">
                finalQuery += " ORDER BY mi.title"</span>
        case "year":<span class="cov0" title="0">
                finalQuery += " ORDER BY mi.year"</span>
        case "rating":<span class="cov0" title="0">
                finalQuery += " ORDER BY mi.rating"</span>
        case "created":<span class="cov0" title="0">
                finalQuery += " ORDER BY mi.first_detected"</span>
        default:<span class="cov0" title="0">
                finalQuery += " ORDER BY mi.title"</span>
        }

        <span class="cov0" title="0">if req.SortOrder == "desc" </span><span class="cov0" title="0">{
                finalQuery += " DESC"
        }</span> else<span class="cov0" title="0"> {
                finalQuery += " ASC"
        }</span>

        <span class="cov0" title="0">finalQuery += " LIMIT ? OFFSET ?"
        args = append(args, req.Limit, req.Offset)

        // Execute search
        rows, err := h.mediaDB.GetDB().Query(finalQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to execute search", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Search failed"})
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var mediaItems []models.MediaItem
        for rows.Next() </span><span class="cov0" title="0">{
                var item models.MediaItem
                var mediaType models.MediaType
                var genreJSON, castCrewJSON string

                err := rows.Scan(
                        &amp;item.ID, &amp;item.MediaTypeID, &amp;item.Title, &amp;item.OriginalTitle, &amp;item.Year,
                        &amp;item.Description, &amp;genreJSON, &amp;item.Director, &amp;castCrewJSON, &amp;item.Rating,
                        &amp;item.Runtime, &amp;item.Language, &amp;item.Country, &amp;item.Status,
                        &amp;item.FirstDetected, &amp;item.LastUpdated,
                        &amp;mediaType.Name, &amp;mediaType.Description,
                )
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Failed to scan media item", zap.Error(err))
                        continue</span>
                }

                // Parse JSON fields
                <span class="cov0" title="0">json.Unmarshal([]byte(genreJSON), &amp;item.Genre)
                json.Unmarshal([]byte(castCrewJSON), &amp;item.CastCrew)

                item.MediaType = &amp;mediaType
                mediaItems = append(mediaItems, item)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "media_items": mediaItems,
                "total":       total,
                "count":       len(mediaItems),
                "limit":       req.Limit,
                "offset":      req.Offset,
                "has_more":    int64(req.Offset+req.Limit) &lt; total,
        })</span>
}

// @Summary Get media item details
// @Description Get detailed information about a specific media item
// @Tags media
// @Param id path int true "Media Item ID"
// @Produce json
// @Success 200 {object} models.MediaItem
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/media/{id} [get]
func (h *MediaHandler) GetMediaItem(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid media item ID"})
                return
        }</span>

        <span class="cov0" title="0">mediaItem, err := h.getMediaItemWithDetails(id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "Media item not found"})
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("Failed to get media item", zap.Int64("id", id), zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve media item"})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, mediaItem)</span>
}

// @Summary Analyze directory
// @Description Trigger analysis of a specific directory
// @Tags media
// @Accept json
// @Param request body object true "Analysis request"
// @Produce json
// @Success 202 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/media/analyze [post]
func (h *MediaHandler) AnalyzeDirectory(c *gin.Context) <span class="cov0" title="0">{
        var request struct {
                DirectoryPath string `json:"directory_path" binding:"required"`
                SmbRoot       string `json:"smb_root" binding:"required"`
                Priority      int    `json:"priority"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">if request.Priority == 0 </span><span class="cov0" title="0">{
                request.Priority = 5 // Default priority
        }</span>

        <span class="cov0" title="0">err := h.analyzer.AnalyzeDirectory(c.Request.Context(), request.DirectoryPath, request.SmbRoot, request.Priority)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to queue directory analysis",
                        zap.String("directory", request.DirectoryPath),
                        zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to queue analysis"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusAccepted, gin.H{
                "message":        "Directory analysis queued",
                "directory_path": request.DirectoryPath,
                "smb_root":       request.SmbRoot,
                "priority":       request.Priority,
        })</span>
}

// @Summary Get media statistics
// @Description Get statistics about media items and analysis
// @Tags media
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 500 {object} map[string]string
// @Router /api/v1/media/stats [get]
func (h *MediaHandler) GetMediaStats(c *gin.Context) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Database stats
        dbStats, err := h.mediaDB.GetStats()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get database stats", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["database"] = dbStats
        }</span>

        // Media type distribution
        <span class="cov0" title="0">typeDistribution, err := h.getMediaTypeDistribution()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get media type distribution", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["media_type_distribution"] = typeDistribution
        }</span>

        // Quality distribution
        <span class="cov0" title="0">qualityDistribution, err := h.getQualityDistribution()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get quality distribution", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["quality_distribution"] = qualityDistribution
        }</span>

        // Recent activity
        <span class="cov0" title="0">recentActivity, err := h.getRecentActivity()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get recent activity", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["recent_activity"] = recentActivity
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, stats)</span>
}

// Helper methods

func (h *MediaHandler) getMediaItemWithDetails(id int64) (*models.MediaItem, error) <span class="cov0" title="0">{
        // Get basic media item
        query := `
                SELECT mi.id, mi.media_type_id, mi.title, mi.original_title, mi.year, mi.description,
                       mi.genre, mi.director, mi.cast_crew, mi.rating, mi.runtime, mi.language, mi.country,
                       mi.status, mi.first_detected, mi.last_updated,
                       mt.name, mt.description
                FROM media_items mi
                JOIN media_types mt ON mi.media_type_id = mt.id
                WHERE mi.id = ?
        `

        var item models.MediaItem
        var mediaType models.MediaType
        var genreJSON, castCrewJSON string

        err := h.mediaDB.GetDB().QueryRow(query, id).Scan(
                &amp;item.ID, &amp;item.MediaTypeID, &amp;item.Title, &amp;item.OriginalTitle, &amp;item.Year,
                &amp;item.Description, &amp;genreJSON, &amp;item.Director, &amp;castCrewJSON, &amp;item.Rating,
                &amp;item.Runtime, &amp;item.Language, &amp;item.Country, &amp;item.Status,
                &amp;item.FirstDetected, &amp;item.LastUpdated,
                &amp;mediaType.Name, &amp;mediaType.Description,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse JSON fields
        <span class="cov0" title="0">json.Unmarshal([]byte(genreJSON), &amp;item.Genre)
        json.Unmarshal([]byte(castCrewJSON), &amp;item.CastCrew)
        item.MediaType = &amp;mediaType

        // Get external metadata
        item.ExternalMetadata, _ = h.getExternalMetadata(id)

        // Get files
        item.Files, _ = h.getMediaFiles(id)

        // Get user metadata
        item.UserMetadata, _ = h.getUserMetadata(id)

        return &amp;item, nil</span>
}

func (h *MediaHandler) getExternalMetadata(mediaItemID int64) ([]models.ExternalMetadata, error) <span class="cov0" title="0">{
        query := `
                SELECT id, media_item_id, provider, external_id, data, rating, review_url, cover_url, trailer_url, last_fetched
                FROM external_metadata
                WHERE media_item_id = ?
                ORDER BY provider
        `

        rows, err := h.mediaDB.GetDB().Query(query, mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var metadata []models.ExternalMetadata
        for rows.Next() </span><span class="cov0" title="0">{
                var em models.ExternalMetadata
                err := rows.Scan(
                        &amp;em.ID, &amp;em.MediaItemID, &amp;em.Provider, &amp;em.ExternalID, &amp;em.Data,
                        &amp;em.Rating, &amp;em.ReviewURL, &amp;em.CoverURL, &amp;em.TrailerURL, &amp;em.LastFetched,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">metadata = append(metadata, em)</span>
        }

        <span class="cov0" title="0">return metadata, nil</span>
}

func (h *MediaHandler) getMediaFiles(mediaItemID int64) ([]models.MediaFile, error) <span class="cov0" title="0">{
        query := `
                SELECT id, media_item_id, file_path, smb_root, filename, file_size, file_extension,
                       quality_info, language, subtitle_tracks, audio_tracks, duration, checksum,
                       virtual_smb_link, direct_smb_link, last_verified, created_at
                FROM media_files
                WHERE media_item_id = ?
                ORDER BY filename
        `

        rows, err := h.mediaDB.GetDB().Query(query, mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var files []models.MediaFile
        for rows.Next() </span><span class="cov0" title="0">{
                var mf models.MediaFile
                var qualityInfoJSON, subtitleTracksJSON, audioTracksJSON string

                err := rows.Scan(
                        &amp;mf.ID, &amp;mf.MediaItemID, &amp;mf.FilePath, &amp;mf.SmbRoot, &amp;mf.Filename,
                        &amp;mf.FileSize, &amp;mf.FileExtension, &amp;qualityInfoJSON, &amp;mf.Language,
                        &amp;subtitleTracksJSON, &amp;audioTracksJSON, &amp;mf.Duration, &amp;mf.Checksum,
                        &amp;mf.VirtualSmbLink, &amp;mf.DirectSmbLink, &amp;mf.LastVerified, &amp;mf.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse JSON fields
                <span class="cov0" title="0">json.Unmarshal([]byte(qualityInfoJSON), &amp;mf.QualityInfo)
                json.Unmarshal([]byte(subtitleTracksJSON), &amp;mf.SubtitleTracks)
                json.Unmarshal([]byte(audioTracksJSON), &amp;mf.AudioTracks)

                files = append(files, mf)</span>
        }

        <span class="cov0" title="0">return files, nil</span>
}

func (h *MediaHandler) getUserMetadata(mediaItemID int64) (*models.UserMetadata, error) <span class="cov0" title="0">{
        query := `
                SELECT id, media_item_id, user_rating, watched_status, watched_date, personal_notes, tags, favorite, created_at, updated_at
                FROM user_metadata
                WHERE media_item_id = ?
        `

        var um models.UserMetadata
        var tagsJSON string

        err := h.mediaDB.GetDB().QueryRow(query, mediaItemID).Scan(
                &amp;um.ID, &amp;um.MediaItemID, &amp;um.UserRating, &amp;um.WatchedStatus, &amp;um.WatchedDate,
                &amp;um.PersonalNotes, &amp;tagsJSON, &amp;um.Favorite, &amp;um.CreatedAt, &amp;um.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">json.Unmarshal([]byte(tagsJSON), &amp;um.Tags)
        return &amp;um, nil</span>
}

func (h *MediaHandler) getMediaTypeDistribution() (map[string]int, error) <span class="cov0" title="0">{
        query := `
                SELECT mt.name, COUNT(mi.id) as count
                FROM media_types mt
                LEFT JOIN media_items mi ON mt.id = mi.media_type_id
                GROUP BY mt.id, mt.name
                ORDER BY count DESC
        `

        rows, err := h.mediaDB.GetDB().Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        distribution := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var mediaType string
                var count int
                if err := rows.Scan(&amp;mediaType, &amp;count); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">distribution[mediaType] = count</span>
        }

        <span class="cov0" title="0">return distribution, nil</span>
}

func (h *MediaHandler) getQualityDistribution() (map[string]int, error) <span class="cov0" title="0">{
        // This would analyze the quality_info JSON fields
        // Simplified implementation for now
        return map[string]int{
                "4K/UHD": 0,
                "1080p":  0,
                "720p":   0,
                "Other":  0,
        }, nil
}</span>

func (h *MediaHandler) getRecentActivity() (map[string]interface{}, error) <span class="cov0" title="0">{
        activity := make(map[string]interface{})

        // Recent analyses
        var recentAnalyses int
        err := h.mediaDB.GetDB().QueryRow(
                "SELECT COUNT(*) FROM directory_analysis WHERE last_analyzed &gt; datetime('now', '-24 hours')",
        ).Scan(&amp;recentAnalyses)
        if err == nil </span><span class="cov0" title="0">{
                activity["analyses_24h"] = recentAnalyses
        }</span>

        // Recent media items
        <span class="cov0" title="0">var recentItems int
        err = h.mediaDB.GetDB().QueryRow(
                "SELECT COUNT(*) FROM media_items WHERE first_detected &gt; datetime('now', '-24 hours')",
        ).Scan(&amp;recentItems)
        if err == nil </span><span class="cov0" title="0">{
                activity["new_items_24h"] = recentItems
        }</span>

        // Recent metadata updates
        <span class="cov0" title="0">var recentMetadata int
        err = h.mediaDB.GetDB().QueryRow(
                "SELECT COUNT(*) FROM external_metadata WHERE last_fetched &gt; datetime('now', '-24 hours')",
        ).Scan(&amp;recentMetadata)
        if err == nil </span><span class="cov0" title="0">{
                activity["metadata_updates_24h"] = recentMetadata
        }</span>

        <span class="cov0" title="0">return activity, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"
        "time"

        "github.com/gorilla/mux"
        "go.uber.org/zap"

        "catalogizer/internal/services"
)

type MediaPlayerHandlers struct {
        logger             *zap.Logger
        musicPlayerService *services.MusicPlayerService
        videoPlayerService *services.VideoPlayerService
        playlistService    *services.PlaylistService
        positionService    *services.PlaybackPositionService
        subtitleService    *services.SubtitleService
        lyricsService      *services.LyricsService
        coverArtService    *services.CoverArtService
        translationService *services.TranslationService
}

type APIResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Message string      `json:"message,omitempty"`
}

type PlaybackSessionResponse struct {
        SessionID      string                   `json:"session_id"`
        CurrentTrack   *services.MusicTrack     `json:"current_track,omitempty"`
        CurrentVideo   *services.VideoContent   `json:"current_video,omitempty"`
        PlaybackState  services.PlaybackState   `json:"playback_state"`
        Position       int64                    `json:"position"`
        Duration       int64                    `json:"duration"`
        Volume         float64                  `json:"volume"`
        IsMuted        bool                     `json:"is_muted"`
        PlaybackSpeed  float64                  `json:"playback_speed,omitempty"`
        Queue          interface{}              `json:"queue,omitempty"`
        QueueIndex     int                      `json:"queue_index,omitempty"`
        RepeatMode     string                   `json:"repeat_mode,omitempty"`
        ShuffleEnabled bool                     `json:"shuffle_enabled,omitempty"`
        Subtitles      []services.SubtitleTrack `json:"subtitles,omitempty"`
        AudioTracks    []services.AudioTrack    `json:"audio_tracks,omitempty"`
        Chapters       []services.Chapter       `json:"chapters,omitempty"`
        Lyrics         *services.LyricsData     `json:"lyrics,omitempty"`
        CoverArt       *services.CoverArt       `json:"cover_art,omitempty"`
        LastActivity   time.Time                `json:"last_activity"`
}

func NewMediaPlayerHandlers(
        logger *zap.Logger,
        musicPlayerService *services.MusicPlayerService,
        videoPlayerService *services.VideoPlayerService,
        playlistService *services.PlaylistService,
        positionService *services.PlaybackPositionService,
        subtitleService *services.SubtitleService,
        lyricsService *services.LyricsService,
        coverArtService *services.CoverArtService,
        translationService *services.TranslationService,
) *MediaPlayerHandlers <span class="cov0" title="0">{
        return &amp;MediaPlayerHandlers{
                logger:             logger,
                musicPlayerService: musicPlayerService,
                videoPlayerService: videoPlayerService,
                playlistService:    playlistService,
                positionService:    positionService,
                subtitleService:    subtitleService,
                lyricsService:      lyricsService,
                coverArtService:    coverArtService,
                translationService: translationService,
        }
}</span>

func (h *MediaPlayerHandlers) RegisterRoutes(router *mux.Router) <span class="cov0" title="0">{
        api := router.PathPrefix("/api/v1").Subrouter()

        // Music Player Routes
        api.HandleFunc("/music/play", h.PlayMusic).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/play/album", h.PlayAlbum).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/play/artist", h.PlayArtist).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}", h.GetMusicSession).Methods("GET", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}/update", h.UpdateMusicPlayback).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}/next", h.NextTrack).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}/previous", h.PreviousTrack).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}/seek", h.SeekMusic).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}/queue", h.AddToMusicQueue).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/session/{sessionId}/equalizer", h.SetEqualizer).Methods("POST", "OPTIONS")
        api.HandleFunc("/music/library/stats", h.GetMusicLibraryStats).Methods("GET", "OPTIONS")

        // Video Player Routes
        api.HandleFunc("/video/play", h.PlayVideo).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/play/series", h.PlaySeries).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/session/{sessionId}", h.GetVideoSession).Methods("GET", "OPTIONS")
        api.HandleFunc("/video/session/{sessionId}/update", h.UpdateVideoPlayback).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/session/{sessionId}/next", h.NextVideo).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/session/{sessionId}/previous", h.PreviousVideo).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/session/{sessionId}/seek", h.SeekVideo).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/session/{sessionId}/bookmark", h.CreateVideoBookmark).Methods("POST", "OPTIONS")
        api.HandleFunc("/video/continue-watching", h.GetContinueWatching).Methods("GET", "OPTIONS")
        api.HandleFunc("/video/watch-history", h.GetWatchHistory).Methods("GET", "OPTIONS")

        // Playlist Routes
        api.HandleFunc("/playlists", h.CreatePlaylist).Methods("POST", "OPTIONS")
        api.HandleFunc("/playlists", h.GetUserPlaylists).Methods("GET", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}", h.GetPlaylist).Methods("GET", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}", h.UpdatePlaylist).Methods("PUT", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}/items", h.GetPlaylistItems).Methods("GET", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}/items", h.AddToPlaylist).Methods("POST", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}/items/{itemId}", h.RemoveFromPlaylist).Methods("DELETE", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}/items/{itemId}/reorder", h.ReorderPlaylist).Methods("POST", "OPTIONS")
        api.HandleFunc("/playlists/{playlistId}/refresh", h.RefreshSmartPlaylist).Methods("POST", "OPTIONS")

        // Subtitle Routes
        api.HandleFunc("/subtitles/search", h.SearchSubtitles).Methods("POST", "OPTIONS")
        api.HandleFunc("/subtitles/download", h.DownloadSubtitle).Methods("POST", "OPTIONS")
        api.HandleFunc("/subtitles/translate", h.TranslateSubtitle).Methods("POST", "OPTIONS")

        // Lyrics Routes
        api.HandleFunc("/lyrics/search", h.SearchLyrics).Methods("POST", "OPTIONS")
        api.HandleFunc("/lyrics/sync", h.SynchronizeLyrics).Methods("POST", "OPTIONS")
        api.HandleFunc("/lyrics/concert", h.GetConcertLyrics).Methods("POST", "OPTIONS")

        // Cover Art Routes
        api.HandleFunc("/cover-art/search", h.SearchCoverArt).Methods("POST", "OPTIONS")
        api.HandleFunc("/cover-art/scan", h.ScanLocalCoverArt).Methods("POST", "OPTIONS")

        // Translation Routes
        api.HandleFunc("/translate", h.TranslateText).Methods("POST", "OPTIONS")
        api.HandleFunc("/translate/detect", h.DetectLanguage).Methods("POST", "OPTIONS")

        // Position Tracking Routes
        api.HandleFunc("/playback/position", h.UpdatePlaybackPosition).Methods("POST", "OPTIONS")
        api.HandleFunc("/playback/position/{mediaId}", h.GetPlaybackPosition).Methods("GET", "OPTIONS")
        api.HandleFunc("/playback/continue-watching", h.GetContinueWatchingList).Methods("GET", "OPTIONS")
        api.HandleFunc("/playback/bookmarks", h.CreateBookmark).Methods("POST", "OPTIONS")
        api.HandleFunc("/playback/bookmarks/{mediaId}", h.GetBookmarks).Methods("GET", "OPTIONS")
        api.HandleFunc("/playback/stats", h.GetPlaybackStats).Methods("GET", "OPTIONS")

        // Add CORS middleware
        api.Use(h.corsMiddleware)
}</span>

// Music Player Handlers

func (h *MediaPlayerHandlers) PlayMusic(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.PlayTrackRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">session, err := h.musicPlayerService.PlayTrack(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to play music", zap.Error(err))
                h.sendError(w, "Failed to start playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) PlayAlbum(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.PlayAlbumRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">session, err := h.musicPlayerService.PlayAlbum(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to play album", zap.Error(err))
                h.sendError(w, "Failed to start album playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) PlayArtist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.PlayArtistRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">session, err := h.musicPlayerService.PlayArtist(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to play artist", zap.Error(err))
                h.sendError(w, "Failed to start artist playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) GetMusicSession(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        session, err := h.musicPlayerService.GetSession(r.Context(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get music session", zap.Error(err))
                h.sendError(w, "Session not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) UpdateMusicPlayback(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req services.UpdatePlaybackRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.SessionID = sessionID

        session, err := h.musicPlayerService.UpdatePlayback(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update music playback", zap.Error(err))
                h.sendError(w, "Failed to update playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) NextTrack(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        session, err := h.musicPlayerService.NextTrack(r.Context(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to skip to next track", zap.Error(err))
                h.sendError(w, "Failed to skip track", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) PreviousTrack(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        session, err := h.musicPlayerService.PreviousTrack(r.Context(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to skip to previous track", zap.Error(err))
                h.sendError(w, "Failed to skip track", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) SeekMusic(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req services.SeekRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.SessionID = sessionID

        session, err := h.musicPlayerService.Seek(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to seek in track", zap.Error(err))
                h.sendError(w, "Failed to seek", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) AddToMusicQueue(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req services.QueueRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.SessionID = sessionID

        session, err := h.musicPlayerService.AddToQueue(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to add to queue", zap.Error(err))
                h.sendError(w, "Failed to add to queue", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildMusicSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) SetEqualizer(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req struct {
                Preset string             `json:"preset"`
                Bands  map[string]float64 `json:"bands"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.musicPlayerService.SetEqualizer(r.Context(), sessionID, req.Preset, req.Bands)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to set equalizer", zap.Error(err))
                h.sendError(w, "Failed to set equalizer", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Equalizer updated successfully"})</span>
}

func (h *MediaPlayerHandlers) GetMusicLibraryStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.musicPlayerService.GetLibraryStats(r.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get library stats", zap.Error(err))
                h.sendError(w, "Failed to get library statistics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, stats)</span>
}

// Video Player Handlers

func (h *MediaPlayerHandlers) PlayVideo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.PlayVideoRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">session, err := h.videoPlayerService.PlayVideo(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to play video", zap.Error(err))
                h.sendError(w, "Failed to start video playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) PlaySeries(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.PlaySeriesRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">session, err := h.videoPlayerService.PlaySeries(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to play series", zap.Error(err))
                h.sendError(w, "Failed to start series playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) GetVideoSession(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        session, err := h.videoPlayerService.GetVideoSession(r.Context(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get video session", zap.Error(err))
                h.sendError(w, "Session not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) UpdateVideoPlayback(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req services.UpdateVideoPlaybackRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.SessionID = sessionID

        session, err := h.videoPlayerService.UpdateVideoPlayback(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update video playback", zap.Error(err))
                h.sendError(w, "Failed to update playback", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) NextVideo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        session, err := h.videoPlayerService.NextVideo(r.Context(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to skip to next video", zap.Error(err))
                h.sendError(w, "Failed to skip video", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) PreviousVideo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        session, err := h.videoPlayerService.PreviousVideo(r.Context(), sessionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to skip to previous video", zap.Error(err))
                h.sendError(w, "Failed to skip video", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) SeekVideo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req services.VideoSeekRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.SessionID = sessionID

        session, err := h.videoPlayerService.SeekVideo(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to seek in video", zap.Error(err))
                h.sendError(w, "Failed to seek", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := h.buildVideoSessionResponse(session)
        h.sendSuccess(w, response)</span>
}

func (h *MediaPlayerHandlers) CreateVideoBookmark(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := mux.Vars(r)["sessionId"]

        var req services.CreateVideoBookmarkRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.SessionID = sessionID

        bookmark, err := h.videoPlayerService.CreateVideoBookmark(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create bookmark", zap.Error(err))
                h.sendError(w, "Failed to create bookmark", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, bookmark)</span>
}

func (h *MediaPlayerHandlers) GetContinueWatching(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">limit := 20
        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">videos, err := h.videoPlayerService.GetContinueWatching(r.Context(), userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get continue watching", zap.Error(err))
                h.sendError(w, "Failed to get continue watching", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, videos)</span>
}

func (h *MediaPlayerHandlers) GetWatchHistory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">req := services.WatchHistoryRequest{
                UserID: userID,
                Limit:  50,
                Offset: 0,
        }

        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        req.Limit = l
                }</span>
        }

        <span class="cov0" title="0">if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov0" title="0">{
                        req.Offset = o
                }</span>
        }

        <span class="cov0" title="0">if videoType := r.URL.Query().Get("type"); videoType != "" </span><span class="cov0" title="0">{
                vt := services.VideoType(videoType)
                req.VideoType = &amp;vt
        }</span>

        <span class="cov0" title="0">history, err := h.videoPlayerService.GetWatchHistory(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get watch history", zap.Error(err))
                h.sendError(w, "Failed to get watch history", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, history)</span>
}

// Playlist Handlers

func (h *MediaPlayerHandlers) CreatePlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.CreatePlaylistRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">playlist, err := h.playlistService.CreatePlaylist(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create playlist", zap.Error(err))
                h.sendError(w, "Failed to create playlist", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, playlist)</span>
}

func (h *MediaPlayerHandlers) GetUserPlaylists(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">includePublic := r.URL.Query().Get("include_public") == "true"

        playlists, err := h.playlistService.GetUserPlaylists(r.Context(), userID, includePublic)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get user playlists", zap.Error(err))
                h.sendError(w, "Failed to get playlists", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, playlists)</span>
}

func (h *MediaPlayerHandlers) GetPlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userID := h.getUserID(r)

        playlist, err := h.playlistService.GetPlaylist(r.Context(), playlistID, userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get playlist", zap.Error(err))
                h.sendError(w, "Playlist not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, playlist)</span>
}

func (h *MediaPlayerHandlers) UpdatePlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req services.UpdatePlaylistRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.ID = playlistID

        h.sendSuccess(w, map[string]string{"message": "Playlist updated successfully"})</span>
}

func (h *MediaPlayerHandlers) GetPlaylistItems(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userID := h.getUserID(r)
        limit := 100
        offset := 0

        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov0" title="0">{
                        offset = o
                }</span>
        }

        <span class="cov0" title="0">items, err := h.playlistService.GetPlaylistItems(r.Context(), playlistID, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get playlist items", zap.Error(err))
                h.sendError(w, "Failed to get playlist items", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, items)</span>
}

func (h *MediaPlayerHandlers) AddToPlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req services.AddToPlaylistRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.PlaylistID = playlistID

        err = h.playlistService.AddToPlaylist(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to add to playlist", zap.Error(err))
                h.sendError(w, "Failed to add items to playlist", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Items added to playlist successfully"})</span>
}

func (h *MediaPlayerHandlers) RemoveFromPlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">itemID, err := h.getIDFromPath(r, "itemId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid item ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userID := h.getUserID(r)

        err = h.playlistService.RemoveFromPlaylist(r.Context(), playlistID, itemID, userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to remove from playlist", zap.Error(err))
                h.sendError(w, "Failed to remove item from playlist", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Item removed from playlist successfully"})</span>
}

func (h *MediaPlayerHandlers) ReorderPlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">itemID, err := h.getIDFromPath(r, "itemId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid item ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req services.ReorderPlaylistRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">req.PlaylistID = playlistID
        req.ItemID = itemID

        err = h.playlistService.ReorderPlaylist(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to reorder playlist", zap.Error(err))
                h.sendError(w, "Failed to reorder playlist", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Playlist reordered successfully"})</span>
}

func (h *MediaPlayerHandlers) RefreshSmartPlaylist(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        playlistID, err := h.getIDFromPath(r, "playlistId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid playlist ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.playlistService.RefreshSmartPlaylist(r.Context(), playlistID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to refresh smart playlist", zap.Error(err))
                h.sendError(w, "Failed to refresh smart playlist", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Smart playlist refreshed successfully"})</span>
}

// Subtitle Handlers

func (h *MediaPlayerHandlers) SearchSubtitles(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.SubtitleSearchRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">results, err := h.subtitleService.SearchSubtitles(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to search subtitles", zap.Error(err))
                h.sendError(w, "Failed to search subtitles", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, results)</span>
}

func (h *MediaPlayerHandlers) DownloadSubtitle(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.SubtitleDownloadRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">subtitle, err := h.subtitleService.DownloadSubtitle(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to download subtitle", zap.Error(err))
                h.sendError(w, "Failed to download subtitle", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, subtitle)</span>
}

func (h *MediaPlayerHandlers) TranslateSubtitle(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.SubtitleTranslationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">subtitle, err := h.subtitleService.TranslateSubtitle(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to translate subtitle", zap.Error(err))
                h.sendError(w, "Failed to translate subtitle", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, subtitle)</span>
}

// Lyrics Handlers

func (h *MediaPlayerHandlers) SearchLyrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.LyricsSearchRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">results, err := h.lyricsService.SearchLyrics(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to search lyrics", zap.Error(err))
                h.sendError(w, "Failed to search lyrics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, results)</span>
}

func (h *MediaPlayerHandlers) SynchronizeLyrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.LyricsSyncRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">lyrics, err := h.lyricsService.SynchronizeLyrics(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to synchronize lyrics", zap.Error(err))
                h.sendError(w, "Failed to synchronize lyrics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, lyrics)</span>
}

func (h *MediaPlayerHandlers) GetConcertLyrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.ConcertLyricsRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">lyrics, err := h.lyricsService.GetConcertLyrics(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get concert lyrics", zap.Error(err))
                h.sendError(w, "Failed to get concert lyrics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, lyrics)</span>
}

// Cover Art Handlers

func (h *MediaPlayerHandlers) SearchCoverArt(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.CoverArtSearchRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">results, err := h.coverArtService.SearchCoverArt(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to search cover art", zap.Error(err))
                h.sendError(w, "Failed to search cover art", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, results)</span>
}

func (h *MediaPlayerHandlers) ScanLocalCoverArt(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.LocalCoverArtScanRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">results, err := h.coverArtService.ScanLocalCoverArt(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to scan local cover art", zap.Error(err))
                h.sendError(w, "Failed to scan local cover art", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, results)</span>
}

// Translation Handlers

func (h *MediaPlayerHandlers) TranslateText(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.TranslationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">result, err := h.translationService.TranslateText(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to translate text", zap.Error(err))
                h.sendError(w, "Failed to translate text", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, result)</span>
}

func (h *MediaPlayerHandlers) DetectLanguage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.LanguageDetectionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">result, err := h.translationService.DetectLanguage(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to detect language", zap.Error(err))
                h.sendError(w, "Failed to detect language", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, result)</span>
}

// Position Tracking Handlers

func (h *MediaPlayerHandlers) UpdatePlaybackPosition(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.UpdatePositionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.positionService.UpdatePosition(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update position", zap.Error(err))
                h.sendError(w, "Failed to update playback position", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, map[string]string{"message": "Position updated successfully"})</span>
}

func (h *MediaPlayerHandlers) GetPlaybackPosition(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        mediaID, err := h.getIDFromPath(r, "mediaId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid media ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">position, err := h.positionService.GetPosition(r.Context(), userID, mediaID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get position", zap.Error(err))
                h.sendError(w, "Failed to get playback position", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, position)</span>
}

func (h *MediaPlayerHandlers) GetContinueWatchingList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">limit := 20
        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">positions, err := h.positionService.GetContinueWatching(r.Context(), userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get continue watching", zap.Error(err))
                h.sendError(w, "Failed to get continue watching list", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, positions)</span>
}

func (h *MediaPlayerHandlers) CreateBookmark(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.BookmarkRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">bookmark, err := h.positionService.CreateBookmark(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create bookmark", zap.Error(err))
                h.sendError(w, "Failed to create bookmark", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, bookmark)</span>
}

func (h *MediaPlayerHandlers) GetBookmarks(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        mediaID, err := h.getIDFromPath(r, "mediaId")
        if err != nil </span><span class="cov0" title="0">{
                h.sendError(w, "Invalid media ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">bookmarks, err := h.positionService.GetBookmarks(r.Context(), userID, mediaID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get bookmarks", zap.Error(err))
                h.sendError(w, "Failed to get bookmarks", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, bookmarks)</span>
}

func (h *MediaPlayerHandlers) GetPlaybackStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := h.getUserID(r)
        if userID == 0 </span><span class="cov0" title="0">{
                h.sendError(w, "User not authenticated", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">req := services.PlaybackStatsRequest{
                UserID: userID,
                Limit:  20,
        }

        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        req.Limit = l
                }</span>
        }

        <span class="cov0" title="0">if mediaType := r.URL.Query().Get("media_type"); mediaType != "" </span><span class="cov0" title="0">{
                req.MediaType = mediaType
        }</span>

        <span class="cov0" title="0">stats, err := h.positionService.GetPlaybackStats(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get playback stats", zap.Error(err))
                h.sendError(w, "Failed to get playback statistics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.sendSuccess(w, stats)</span>
}

// Helper Methods

func (h *MediaPlayerHandlers) buildMusicSessionResponse(session *services.MusicPlaybackSession) *PlaybackSessionResponse <span class="cov0" title="0">{
        return &amp;PlaybackSessionResponse{
                SessionID:      session.ID,
                CurrentTrack:   session.CurrentTrack,
                PlaybackState:  session.PlaybackState,
                Position:       session.Position,
                Duration:       session.Duration,
                Volume:         session.Volume,
                IsMuted:        session.IsMuted,
                Queue:          session.Queue,
                QueueIndex:     session.QueueIndex,
                RepeatMode:     string(session.RepeatMode),
                ShuffleEnabled: session.ShuffleEnabled,
                LastActivity:   session.LastActivity,
        }
}</span>

func (h *MediaPlayerHandlers) buildVideoSessionResponse(session *services.VideoPlaybackSession) *PlaybackSessionResponse <span class="cov0" title="0">{
        return &amp;PlaybackSessionResponse{
                SessionID:     session.ID,
                CurrentVideo:  session.CurrentVideo,
                PlaybackState: session.PlaybackState,
                Position:      session.Position,
                Duration:      session.Duration,
                Volume:        session.Volume,
                IsMuted:       session.IsMuted,
                PlaybackSpeed: session.PlaybackSpeed,
                Queue:         session.Playlist,
                QueueIndex:    session.PlaylistIndex,
                Subtitles:     session.SubtitleTracks,
                AudioTracks:   session.AudioTracks,
                Chapters:      session.Chapters,
                LastActivity:  session.LastActivity,
        }
}</span>

func (h *MediaPlayerHandlers) sendSuccess(w http.ResponseWriter, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(APIResponse{
                Success: true,
                Data:    data,
        })
}</span>

func (h *MediaPlayerHandlers) sendError(w http.ResponseWriter, message string, statusCode int) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(APIResponse{
                Success: false,
                Error:   message,
        })
}</span>

func (h *MediaPlayerHandlers) getUserID(r *http.Request) int64 <span class="cov0" title="0">{
        userIDStr := r.Header.Get("X-User-ID")
        if userIDStr == "" </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">userID, err := strconv.ParseInt(userIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return userID</span>
}

func (h *MediaPlayerHandlers) getIDFromPath(r *http.Request, key string) (int64, error) <span class="cov0" title="0">{
        idStr := mux.Vars(r)[key]
        return strconv.ParseInt(idStr, 10, 64)
}</span>

func (h *MediaPlayerHandlers) corsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-User-ID")
                w.Header().Set("Access-Control-Max-Age", "86400")

                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/gorilla/mux"

        "catalogizer/models"
        "catalogizer/internal/services"
        "catalogizer/repository"
)

type RecommendationHandler struct {
        recommendationService *services.RecommendationService
        deepLinkingService    *services.DeepLinkingService
        fileRepository        *repository.FileRepository
}

func NewRecommendationHandler(
        recommendationService *services.RecommendationService,
        deepLinkingService *services.DeepLinkingService,
        fileRepository *repository.FileRepository,
) *RecommendationHandler <span class="cov0" title="0">{
        return &amp;RecommendationHandler{
                recommendationService: recommendationService,
                deepLinkingService:    deepLinkingService,
                fileRepository:        fileRepository,
        }
}</span>

// GetSimilarItems handles GET /api/v1/media/{id}/similar
func (rh *RecommendationHandler) GetSimilarItems(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        mediaID := vars["id"]

        if mediaID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Media ID is required", http.StatusBadRequest)
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">maxLocal := 10
        if maxLocalStr := r.URL.Query().Get("max_local"); maxLocalStr != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(maxLocalStr); err == nil &amp;&amp; val &gt; 0 </span><span class="cov0" title="0">{
                        maxLocal = val
                }</span>
        }

        <span class="cov0" title="0">maxExternal := 5
        if maxExternalStr := r.URL.Query().Get("max_external"); maxExternalStr != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(maxExternalStr); err == nil &amp;&amp; val &gt; 0 </span><span class="cov0" title="0">{
                        maxExternal = val
                }</span>
        }

        <span class="cov0" title="0">includeExternal := r.URL.Query().Get("include_external") == "true"

        similarityThreshold := 0.3
        if thresholdStr := r.URL.Query().Get("similarity_threshold"); thresholdStr != "" </span><span class="cov0" title="0">{
                if val, err := strconv.ParseFloat(thresholdStr, 64); err == nil &amp;&amp; val &gt;= 0 &amp;&amp; val &lt;= 1 </span><span class="cov0" title="0">{
                        similarityThreshold = val
                }</span>
        }

        // Parse filters
        <span class="cov0" title="0">filters := &amp;services.RecommendationFilters{}

        if genreFilter := r.URL.Query().Get("genre"); genreFilter != "" </span><span class="cov0" title="0">{
                filters.GenreFilter = []string{genreFilter}
        }</span>

        <span class="cov0" title="0">if yearStart := r.URL.Query().Get("year_start"); yearStart != "" </span><span class="cov0" title="0">{
                if yearEnd := r.URL.Query().Get("year_end"); yearEnd != "" </span><span class="cov0" title="0">{
                        if start, err1 := strconv.Atoi(yearStart); err1 == nil </span><span class="cov0" title="0">{
                                if end, err2 := strconv.Atoi(yearEnd); err2 == nil </span><span class="cov0" title="0">{
                                        filters.YearRange = &amp;services.YearRange{
                                                StartYear: start,
                                                EndYear:   end,
                                        }
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if minRating := r.URL.Query().Get("min_rating"); minRating != "" </span><span class="cov0" title="0">{
                if maxRating := r.URL.Query().Get("max_rating"); maxRating != "" </span><span class="cov0" title="0">{
                        if min, err1 := strconv.ParseFloat(minRating, 64); err1 == nil </span><span class="cov0" title="0">{
                                if max, err2 := strconv.ParseFloat(maxRating, 64); err2 == nil </span><span class="cov0" title="0">{
                                        filters.RatingRange = &amp;services.RatingRange{
                                                MinRating: min,
                                                MaxRating: max,
                                        }
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if language := r.URL.Query().Get("language"); language != "" </span><span class="cov0" title="0">{
                filters.LanguageFilter = []string{language}
        }</span>

        <span class="cov0" title="0">filters.ExcludeWatched = r.URL.Query().Get("exclude_watched") == "true"
        filters.ExcludeOwned = r.URL.Query().Get("exclude_owned") == "true"

        if minConfidence := r.URL.Query().Get("min_confidence"); minConfidence != "" </span><span class="cov0" title="0">{
                if val, err := strconv.ParseFloat(minConfidence, 64); err == nil &amp;&amp; val &gt;= 0 &amp;&amp; val &lt;= 1 </span><span class="cov0" title="0">{
                        filters.MinConfidence = val
                }</span>
        }

        // Get actual media metadata from database
        <span class="cov0" title="0">mediaIDInt, err := strconv.ParseInt(mediaID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid media ID format", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">fileWithMetadata, err := rh.fileRepository.GetFileByID(r.Context(), mediaIDInt)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get media metadata: "+err.Error(), http.StatusNotFound)
                return
        }</span>

        // Convert file metadata to MediaMetadata
        <span class="cov0" title="0">metadata := rh.convertFileToMediaMetadata(fileWithMetadata)

        req := &amp;services.SimilarItemsRequest{
                MediaID:             mediaID,
                MediaMetadata:       metadata,
                MaxLocalItems:       maxLocal,
                MaxExternalItems:    maxExternal,
                IncludeExternal:     includeExternal,
                SimilarityThreshold: similarityThreshold,
                Filters:             filters,
        }

        response, err := rh.recommendationService.GetSimilarItems(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get similar items: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// PostSimilarItems handles POST /api/v1/media/similar
func (rh *RecommendationHandler) PostSimilarItems(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.SimilarItemsRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.MediaID == "" &amp;&amp; req.MediaMetadata == nil </span><span class="cov0" title="0">{
                http.Error(w, "Either media_id or media_metadata is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">response, err := rh.recommendationService.GetSimilarItems(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get similar items: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// GenerateDeepLinks handles POST /api/v1/links/generate
func (rh *RecommendationHandler) GenerateDeepLinks(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.DeepLinkRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.MediaID == "" &amp;&amp; req.MediaMetadata == nil </span><span class="cov0" title="0">{
                http.Error(w, "Either media_id or media_metadata is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Action == "" </span><span class="cov0" title="0">{
                req.Action = "detail"
        }</span>

        <span class="cov0" title="0">response, err := rh.deepLinkingService.GenerateDeepLinks(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate deep links: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// GetMediaWithSimilarItems handles GET /api/v1/media/{id}/detail-with-similar
func (rh *RecommendationHandler) GetMediaWithSimilarItems(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        mediaID := vars["id"]

        if mediaID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Media ID is required", http.StatusBadRequest)
                return
        }</span>

        // Parse parameters for similar items
        <span class="cov0" title="0">maxLocal := 10
        if maxLocalStr := r.URL.Query().Get("max_similar"); maxLocalStr != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(maxLocalStr); err == nil &amp;&amp; val &gt; 0 </span><span class="cov0" title="0">{
                        maxLocal = val
                }</span>
        }

        <span class="cov0" title="0">includeExternal := r.URL.Query().Get("include_external") == "true"

        // Get actual media metadata from database
        mediaIDInt, err := strconv.ParseInt(mediaID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid media ID format", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">fileWithMetadata, err := rh.fileRepository.GetFileByID(r.Context(), mediaIDInt)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get media metadata: "+err.Error(), http.StatusNotFound)
                return
        }</span>

        // Convert file metadata to MediaMetadata
        <span class="cov0" title="0">metadata := rh.convertFileToMediaMetadata(fileWithMetadata)

        response := &amp;MediaDetailWithSimilarResponse{
                MediaID:       mediaID,
                MediaMetadata: metadata,
                SimilarItems:  nil, // Will be populated below
                Links:         nil, // Will be populated below
        }

        // Get similar items
        similarReq := &amp;services.SimilarItemsRequest{
                MediaID:             mediaID,
                MediaMetadata:       metadata,
                MaxLocalItems:       maxLocal,
                MaxExternalItems:    5,
                IncludeExternal:     includeExternal,
                SimilarityThreshold: 0.3,
        }

        similarItems, err := rh.recommendationService.GetSimilarItems(r.Context(), similarReq)
        if err == nil </span><span class="cov0" title="0">{
                response.SimilarItems = similarItems
        }</span>

        // Generate deep links
        <span class="cov0" title="0">linkReq := &amp;services.DeepLinkRequest{
                MediaID: mediaID,
                Action:  "detail",
                Context: extractLinkContext(r),
        }

        links, err := rh.deepLinkingService.GenerateDeepLinks(r.Context(), linkReq)
        if err == nil </span><span class="cov0" title="0">{
                response.Links = links
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// TrackLinkClick handles POST /api/v1/links/track
func (rh *RecommendationHandler) TrackLinkClick(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var event services.LinkTrackingEvent
        if err := json.NewDecoder(r.Body).Decode(&amp;event); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if event.TrackingID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Tracking ID is required", http.StatusBadRequest)
                return
        }</span>

        // Set additional fields from request
        <span class="cov0" title="0">event.UserAgent = r.Header.Get("User-Agent")
        event.IPAddress = getClientIP(r)

        err := rh.deepLinkingService.TrackLinkEvent(r.Context(), &amp;event)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to track link event: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"status": "success"})</span>
}

// GetLinkAnalytics handles GET /api/v1/links/{tracking_id}/analytics
func (rh *RecommendationHandler) GetLinkAnalytics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        trackingID := vars["tracking_id"]

        if trackingID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Tracking ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">analytics, err := rh.deepLinkingService.GetLinkAnalytics(r.Context(), trackingID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get analytics: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(analytics)</span>
}

// BatchGenerateLinks handles POST /api/v1/links/batch
func (rh *RecommendationHandler) BatchGenerateLinks(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var requests []*services.DeepLinkRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;requests); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if len(requests) == 0 </span><span class="cov0" title="0">{
                http.Error(w, "At least one request is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if len(requests) &gt; 50 </span><span class="cov0" title="0">{ // Limit batch size
                http.Error(w, "Too many requests (max 50)", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">responses, err := rh.deepLinkingService.GenerateBatchLinks(r.Context(), requests)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate batch links: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "links":     responses,
                "processed": len(responses),
                "requested": len(requests),
        })</span>
}

// GenerateSmartLink handles POST /api/v1/links/smart
func (rh *RecommendationHandler) GenerateSmartLink(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req services.DeepLinkRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.MediaID == "" &amp;&amp; req.MediaMetadata == nil </span><span class="cov0" title="0">{
                http.Error(w, "Either media_id or media_metadata is required", http.StatusBadRequest)
                return
        }</span>

        // Set context from request if not provided
        <span class="cov0" title="0">if req.Context == nil </span><span class="cov0" title="0">{
                req.Context = extractLinkContext(r)
        }</span>

        <span class="cov0" title="0">response, err := rh.deepLinkingService.GenerateSmartLink(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate smart link: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// GetRecommendationTrends handles GET /api/v1/recommendations/trends
func (rh *RecommendationHandler) GetRecommendationTrends(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        mediaType := r.URL.Query().Get("media_type")
        period := r.URL.Query().Get("period")
        if period == "" </span><span class="cov0" title="0">{
                period = "week"
        }</span>

        <span class="cov0" title="0">limit := 20
        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(limitStr); err == nil &amp;&amp; val &gt; 0 &amp;&amp; val &lt;= 100 </span><span class="cov0" title="0">{
                        limit = val
                }</span>
        }

        // Mock trending recommendations
        <span class="cov0" title="0">trends := &amp;RecommendationTrends{
                Period:    period,
                MediaType: mediaType,
                Items:     generateMockTrendingItems(mediaType, limit),
                UpdatedAt: time.Now(),
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(trends)</span>
}

// Helper types
type MediaDetailWithSimilarResponse struct {
        MediaID       string                         `json:"media_id"`
        MediaMetadata interface{}                    `json:"media_metadata"` // Would be proper type
        SimilarItems  *services.SimilarItemsResponse `json:"similar_items"`
        Links         *services.DeepLinkResponse     `json:"links"`
}

type RecommendationTrends struct {
        Period    string      `json:"period"`
        MediaType string      `json:"media_type,omitempty"`
        Items     []TrendItem `json:"items"`
        UpdatedAt time.Time   `json:"updated_at"`
}

type TrendItem struct {
        MediaID             string  `json:"media_id"`
        Title               string  `json:"title"`
        Subtitle            string  `json:"subtitle,omitempty"`
        CoverArt            string  `json:"cover_art,omitempty"`
        TrendScore          float64 `json:"trend_score"`
        RecommendationCount int     `json:"recommendation_count"`
        ViewCount           int     `json:"view_count"`
        Rating              float64 `json:"rating,omitempty"`
}

// Helper functions
func extractLinkContext(r *http.Request) *services.LinkContext <span class="cov0" title="0">{
        context := &amp;services.LinkContext{
                ReferrerPage: r.Header.Get("Referer"),
        }

        // Extract user context from headers or query params
        if userID := r.Header.Get("X-User-ID"); userID != "" </span><span class="cov0" title="0">{
                context.UserID = userID
        }</span>
        <span class="cov0" title="0">if deviceID := r.Header.Get("X-Device-ID"); deviceID != "" </span><span class="cov0" title="0">{
                context.DeviceID = deviceID
        }</span>
        <span class="cov0" title="0">if sessionID := r.Header.Get("X-Session-ID"); sessionID != "" </span><span class="cov0" title="0">{
                context.SessionID = sessionID
        }</span>

        // Determine platform from User-Agent
        <span class="cov0" title="0">userAgent := strings.ToLower(r.Header.Get("User-Agent"))
        switch </span>{
        case strings.Contains(userAgent, "android"):<span class="cov0" title="0">
                context.Platform = "android"</span>
        case strings.Contains(userAgent, "iphone") || strings.Contains(userAgent, "ipad"):<span class="cov0" title="0">
                context.Platform = "ios"</span>
        case strings.Contains(userAgent, "catalogizer-desktop"):<span class="cov0" title="0">
                context.Platform = "desktop"</span>
        default:<span class="cov0" title="0">
                context.Platform = "web"</span>
        }

        // Extract UTM parameters
        <span class="cov0" title="0">query := r.URL.Query()
        if query.Get("utm_source") != "" </span><span class="cov0" title="0">{
                context.UTMParams = &amp;services.UTMParameters{
                        Source:   query.Get("utm_source"),
                        Medium:   query.Get("utm_medium"),
                        Campaign: query.Get("utm_campaign"),
                        Term:     query.Get("utm_term"),
                        Content:  query.Get("utm_content"),
                }
        }</span>

        <span class="cov0" title="0">return context</span>
}

func getClientIP(r *http.Request) string <span class="cov0" title="0">{
        // Check X-Forwarded-For header
        forwarded := r.Header.Get("X-Forwarded-For")
        if forwarded != "" </span><span class="cov0" title="0">{
                return strings.Split(forwarded, ",")[0]
        }</span>

        // Check X-Real-IP header
        <span class="cov0" title="0">realIP := r.Header.Get("X-Real-IP")
        if realIP != "" </span><span class="cov0" title="0">{
                return realIP
        }</span>

        // Fallback to RemoteAddr
        <span class="cov0" title="0">return r.RemoteAddr</span>
}

func generateMockTrendingItems(mediaType string, limit int) []TrendItem <span class="cov0" title="0">{
        items := make([]TrendItem, 0, limit)

        for i := 0; i &lt; limit; i++ </span><span class="cov0" title="0">{
                item := TrendItem{
                        MediaID:             fmt.Sprintf("trending_%s_%d", mediaType, i),
                        TrendScore:          0.9 - float64(i)*0.02,
                        RecommendationCount: 100 - i*5,
                        ViewCount:           1000 - i*50,
                        Rating:              8.5 - float64(i)*0.1,
                }

                switch mediaType </span>{
                case "video":<span class="cov0" title="0">
                        item.Title = fmt.Sprintf("Trending Movie %d", i+1)
                        item.Subtitle = "Action/Adventure"</span>
                case "audio":<span class="cov0" title="0">
                        item.Title = fmt.Sprintf("Trending Song %d", i+1)
                        item.Subtitle = "Popular Artist"</span>
                case "book":<span class="cov0" title="0">
                        item.Title = fmt.Sprintf("Trending Book %d", i+1)
                        item.Subtitle = "Bestselling Author"</span>
                default:<span class="cov0" title="0">
                        item.Title = fmt.Sprintf("Trending Item %d", i+1)</span>
                }

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items</span>
}

// convertFileToMediaMetadata converts FileWithMetadata to MediaMetadata
func (rh *RecommendationHandler) convertFileToMediaMetadata(fileWithMetadata *models.FileWithMetadata) *models.MediaMetadata <span class="cov0" title="0">{
        if fileWithMetadata == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">metadata := &amp;models.MediaMetadata{
                ID:          fileWithMetadata.File.ID,
                Title:       fileWithMetadata.File.Name,
                Description: "",
                FileSize:    &amp;fileWithMetadata.File.Size,
                CreatedAt:   fileWithMetadata.File.CreatedAt,
                UpdatedAt:   fileWithMetadata.File.ModifiedAt,
                Metadata:    make(map[string]interface{}),
        }

        // Extract metadata from FileMetadata array
        for _, meta := range fileWithMetadata.Metadata </span><span class="cov0" title="0">{
                switch meta.Key </span>{
                case "media_type", "type":<span class="cov0" title="0">
                        metadata.MediaType = meta.Value</span>
                case "title":<span class="cov0" title="0">
                        metadata.Title = meta.Value</span>
                case "description", "synopsis", "plot":<span class="cov0" title="0">
                        metadata.Description = meta.Value</span>
                case "genre":<span class="cov0" title="0">
                        metadata.Genre = meta.Value</span>
                case "year", "release_year":<span class="cov0" title="0">
                        if year, err := strconv.Atoi(meta.Value); err == nil </span><span class="cov0" title="0">{
                                metadata.Year = &amp;year
                        }</span>
                case "rating", "imdb_rating":<span class="cov0" title="0">
                        if rating, err := strconv.ParseFloat(meta.Value, 64); err == nil </span><span class="cov0" title="0">{
                                metadata.Rating = &amp;rating
                        }</span>
                case "duration", "runtime":<span class="cov0" title="0">
                        if duration, err := strconv.Atoi(meta.Value); err == nil </span><span class="cov0" title="0">{
                                metadata.Duration = &amp;duration
                        }</span>
                case "language":<span class="cov0" title="0">
                        metadata.Language = meta.Value</span>
                case "country":<span class="cov0" title="0">
                        metadata.Country = meta.Value</span>
                case "director":<span class="cov0" title="0">
                        metadata.Director = meta.Value</span>
                case "producer":<span class="cov0" title="0">
                        metadata.Producer = meta.Value</span>
                case "cast":<span class="cov0" title="0">
                        metadata.Cast = strings.Split(meta.Value, ",")</span>
                case "resolution", "quality":<span class="cov0" title="0">
                        metadata.Resolution = meta.Value</span>
                default:<span class="cov0" title="0">
                        // Store other metadata in the generic metadata map
                        metadata.Metadata[meta.Key] = meta.Value</span>
                }
        }

        // If media type is not set, try to infer from MIME type
        <span class="cov0" title="0">if metadata.MediaType == "" &amp;&amp; fileWithMetadata.File.MimeType != nil </span><span class="cov0" title="0">{
                switch </span>{
                case strings.HasPrefix(*fileWithMetadata.File.MimeType, "video/"):<span class="cov0" title="0">
                        metadata.MediaType = "video"</span>
                case strings.HasPrefix(*fileWithMetadata.File.MimeType, "audio/"):<span class="cov0" title="0">
                        metadata.MediaType = "audio"</span>
                case strings.HasPrefix(*fileWithMetadata.File.MimeType, "image/"):<span class="cov0" title="0">
                        metadata.MediaType = "image"</span>
                case strings.HasPrefix(*fileWithMetadata.File.MimeType, "text/"):<span class="cov0" title="0">
                        metadata.MediaType = "text"</span>
                case strings.Contains(*fileWithMetadata.File.MimeType, "pdf") || strings.Contains(*fileWithMetadata.File.MimeType, "epub"):<span class="cov0" title="0">
                        metadata.MediaType = "book"</span>
                default:<span class="cov0" title="0">
                        metadata.MediaType = "other"</span>
                }
        }

        <span class="cov0" title="0">return metadata</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package handlers

import (
        "catalogizer/internal/smb"
        "errors"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// SMBHandler handles SMB-related endpoints
type SMBHandler struct {
        smbManager *smb.ResilientSMBManager
        logger     *zap.Logger
}

// NewSMBHandler creates a new SMB handler
func NewSMBHandler(smbManager *smb.ResilientSMBManager, logger *zap.Logger) *SMBHandler <span class="cov0" title="0">{
        return &amp;SMBHandler{
                smbManager: smbManager,
                logger:     logger,
        }
}</span>

// AddSourceRequest represents a request to add an SMB source
type AddSourceRequest struct {
        Name              string `json:"name" binding:"required"`
        Path              string `json:"path" binding:"required"`
        Username          string `json:"username"`
        Password          string `json:"password"`
        Domain            string `json:"domain"`
        MaxRetryAttempts  int    `json:"max_retry_attempts"`
        RetryDelaySeconds int    `json:"retry_delay_seconds"`
        ConnectionTimeout int    `json:"connection_timeout_seconds"`
}

// @Summary Add SMB source
// @Description Add a new SMB source for monitoring
// @Tags smb
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param request body AddSourceRequest true "SMB source details"
// @Success 201 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/smb/sources [post]
func (h *SMBHandler) AddSource(c *gin.Context) <span class="cov0" title="0">{
        var req AddSourceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">source := &amp;smb.SMBSource{
                Name:     req.Name,
                Path:     req.Path,
                Username: req.Username,
                Password: req.Password,
                Domain:   req.Domain,
        }

        // Set optional parameters
        if req.MaxRetryAttempts &gt; 0 </span><span class="cov0" title="0">{
                source.MaxRetryAttempts = req.MaxRetryAttempts
        }</span>
        <span class="cov0" title="0">if req.RetryDelaySeconds &gt; 0 </span><span class="cov0" title="0">{
                source.RetryDelay = time.Duration(req.RetryDelaySeconds) * time.Second
        }</span>
        <span class="cov0" title="0">if req.ConnectionTimeout &gt; 0 </span><span class="cov0" title="0">{
                source.ConnectionTimeout = time.Duration(req.ConnectionTimeout) * time.Second
        }</span>

        <span class="cov0" title="0">err := h.smbManager.AddSource(source)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to add SMB source", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to add SMB source"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("SMB source added successfully",
                zap.String("name", req.Name),
                zap.String("path", req.Path))

        c.JSON(http.StatusCreated, gin.H{
                "message":   "SMB source added successfully",
                "source_id": source.ID,
        })</span>
}

// @Summary Remove SMB source
// @Description Remove an existing SMB source
// @Tags smb
// @Security BearerAuth
// @Param id path string true "Source ID"
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/smb/sources/{id} [delete]
func (h *SMBHandler) RemoveSource(c *gin.Context) <span class="cov0" title="0">{
        sourceID := c.Param("id")
        if sourceID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Source ID is required"})
                return
        }</span>

        <span class="cov0" title="0">err := h.smbManager.RemoveSource(sourceID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to remove SMB source",
                        zap.String("source_id", sourceID),
                        zap.Error(err))
                c.JSON(http.StatusNotFound, gin.H{"error": "SMB source not found"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("SMB source removed successfully", zap.String("source_id", sourceID))

        c.JSON(http.StatusOK, gin.H{
                "message": "SMB source removed successfully",
        })</span>
}

// @Summary Get SMB sources status
// @Description Get the status of all configured SMB sources
// @Tags smb
// @Security BearerAuth
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Router /api/v1/smb/sources/status [get]
func (h *SMBHandler) GetSourcesStatus(c *gin.Context) <span class="cov0" title="0">{
        status := h.smbManager.GetSourceStatus()

        c.JSON(http.StatusOK, gin.H{
                "sources": status,
                "summary": h.generateStatusSummary(status),
        })
}</span>

// @Summary Get SMB source details
// @Description Get detailed information about a specific SMB source
// @Tags smb
// @Security BearerAuth
// @Param id path string true "Source ID"
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/smb/sources/{id} [get]
func (h *SMBHandler) GetSourceDetails(c *gin.Context) <span class="cov0" title="0">{
        sourceID := c.Param("id")
        if sourceID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Source ID is required"})
                return
        }</span>

        <span class="cov0" title="0">status := h.smbManager.GetSourceStatus()
        sourceStatus, exists := status[sourceID]
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "SMB source not found"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "source": sourceStatus,
        })</span>
}

// @Summary Test SMB connection
// @Description Test connection to an SMB source
// @Tags smb
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param request body AddSourceRequest true "SMB connection details"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /api/v1/smb/test-connection [post]
func (h *SMBHandler) TestConnection(c *gin.Context) <span class="cov0" title="0">{
        var req AddSourceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        // Create temporary source for testing
        <span class="cov0" title="0">source := &amp;smb.SMBSource{
                Name:              "test",
                Path:              req.Path,
                Username:          req.Username,
                Password:          req.Password,
                Domain:            req.Domain,
                ConnectionTimeout: 10 * time.Second,
        }

        // Test connection (this would use actual SMB connection logic)
        start := time.Now()
        err := h.testSMBConnection(source)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("SMB connection test failed",
                        zap.String("path", req.Path),
                        zap.Error(err))

                c.JSON(http.StatusInternalServerError, gin.H{
                        "success":       false,
                        "error":         err.Error(),
                        "test_duration": duration.Milliseconds(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success":       true,
                "message":       "Connection successful",
                "test_duration": duration.Milliseconds(),
        })</span>
}

// @Summary Force reconnect SMB source
// @Description Force a reconnection attempt for an SMB source
// @Tags smb
// @Security BearerAuth
// @Param id path string true "Source ID"
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/smb/sources/{id}/reconnect [post]
func (h *SMBHandler) ForceReconnect(c *gin.Context) <span class="cov0" title="0">{
        sourceID := c.Param("id")
        if sourceID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Source ID is required"})
                return
        }</span>

        // This would trigger a reconnection attempt
        <span class="cov0" title="0">err := h.smbManager.ForceReconnect(sourceID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to force reconnect",
                        zap.String("source_id", sourceID),
                        zap.Error(err))
                c.JSON(http.StatusNotFound, gin.H{"error": "SMB source not found or reconnect failed"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Forced reconnect initiated", zap.String("source_id", sourceID))

        c.JSON(http.StatusOK, gin.H{
                "message": "Reconnection initiated",
        })</span>
}

// @Summary Get SMB statistics
// @Description Get statistics about SMB sources and their performance
// @Tags smb
// @Security BearerAuth
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Router /api/v1/smb/statistics [get]
func (h *SMBHandler) GetStatistics(c *gin.Context) <span class="cov0" title="0">{
        status := h.smbManager.GetSourceStatus()
        stats := h.generateStatistics(status)

        c.JSON(http.StatusOK, stats)
}</span>

// Helper methods

func (h *SMBHandler) generateStatusSummary(status map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        summary := map[string]interface{}{
                "total":        len(status),
                "connected":    0,
                "disconnected": 0,
                "reconnecting": 0,
                "offline":      0,
        }

        for _, sourceStatus := range status </span><span class="cov0" title="0">{
                if sourceMap, ok := sourceStatus.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if state, exists := sourceMap["state"]; exists </span><span class="cov0" title="0">{
                                switch state </span>{
                                case "connected":<span class="cov0" title="0">
                                        summary["connected"] = summary["connected"].(int) + 1</span>
                                case "disconnected":<span class="cov0" title="0">
                                        summary["disconnected"] = summary["disconnected"].(int) + 1</span>
                                case "reconnecting":<span class="cov0" title="0">
                                        summary["reconnecting"] = summary["reconnecting"].(int) + 1</span>
                                case "offline":<span class="cov0" title="0">
                                        summary["offline"] = summary["offline"].(int) + 1</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return summary</span>
}

func (h *SMBHandler) generateStatistics(status map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        stats := map[string]interface{}{
                "total_sources":     len(status),
                "health_summary":    h.generateStatusSummary(status),
                "uptime_stats":      h.calculateUptimeStats(status),
                "performance_stats": h.calculatePerformanceStats(status),
                "error_stats":       h.calculateErrorStats(status),
        }

        return stats
}</span>

func (h *SMBHandler) calculateUptimeStats(status map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        now := time.Now()
        totalUptime := time.Duration(0)
        connectedSources := 0

        for _, sourceStatus := range status </span><span class="cov0" title="0">{
                if sourceMap, ok := sourceStatus.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if state, exists := sourceMap["state"]; exists &amp;&amp; state == "connected" </span><span class="cov0" title="0">{
                                if lastConnectedStr, exists := sourceMap["last_connected"]; exists </span><span class="cov0" title="0">{
                                        if lastConnected, ok := lastConnectedStr.(time.Time); ok </span><span class="cov0" title="0">{
                                                uptime := now.Sub(lastConnected)
                                                totalUptime += uptime
                                                connectedSources++
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">averageUptime := time.Duration(0)
        if connectedSources &gt; 0 </span><span class="cov0" title="0">{
                averageUptime = totalUptime / time.Duration(connectedSources)
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "total_uptime_hours":   totalUptime.Hours(),
                "average_uptime_hours": averageUptime.Hours(),
                "connected_sources":    connectedSources,
        }</span>
}

func (h *SMBHandler) calculatePerformanceStats(status map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        // This would include metrics like:
        // - Average response time
        // - Throughput
        // - Connection success rate
        // For now, return placeholder data

        return map[string]interface{}{
                "avg_response_time_ms":    150,
                "connection_success_rate": 0.95,
                "total_operations":        1000,
        }
}</span>

func (h *SMBHandler) calculateErrorStats(status map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        totalErrors := 0
        sourcesWithErrors := 0

        for _, sourceStatus := range status </span><span class="cov0" title="0">{
                if sourceMap, ok := sourceStatus.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if retryAttempts, exists := sourceMap["retry_attempts"]; exists </span><span class="cov0" title="0">{
                                if attempts, ok := retryAttempts.(int); ok &amp;&amp; attempts &gt; 0 </span><span class="cov0" title="0">{
                                        totalErrors += attempts
                                        sourcesWithErrors++
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "total_errors":        totalErrors,
                "sources_with_errors": sourcesWithErrors,
                "error_rate":          float64(sourcesWithErrors) / float64(len(status)),
        }</span>
}

func (h *SMBHandler) testSMBConnection(source *smb.SMBSource) error <span class="cov0" title="0">{
        // Placeholder for actual SMB connection testing
        // In a real implementation, this would:
        // 1. Create SMB connection with provided credentials
        // 2. Attempt to list directory contents
        // 3. Test read permissions
        // 4. Return any connection errors

        time.Sleep(100 * time.Millisecond) // Simulate connection time

        // Simulate occasional failures for testing
        if time.Now().Unix()%10 == 0 </span><span class="cov0" title="0">{
                return errors.New("Connection timeout")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateSourceRequest represents a request to update SMB source settings
type UpdateSourceRequest struct {
        Name              *string `json:"name,omitempty"`
        Username          *string `json:"username,omitempty"`
        Password          *string `json:"password,omitempty"`
        Domain            *string `json:"domain,omitempty"`
        MaxRetryAttempts  *int    `json:"max_retry_attempts,omitempty"`
        RetryDelaySeconds *int    `json:"retry_delay_seconds,omitempty"`
        ConnectionTimeout *int    `json:"connection_timeout_seconds,omitempty"`
        IsEnabled         *bool   `json:"is_enabled,omitempty"`
}

// @Summary Update SMB source
// @Description Update settings for an existing SMB source
// @Tags smb
// @Security BearerAuth
// @Accept json
// @Produce json
// @Param id path string true "Source ID"
// @Param request body UpdateSourceRequest true "Update data"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/smb/sources/{id} [put]
func (h *SMBHandler) UpdateSource(c *gin.Context) <span class="cov0" title="0">{
        sourceID := c.Param("id")
        if sourceID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Source ID is required"})
                return
        }</span>

        <span class="cov0" title="0">var req UpdateSourceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>

        <span class="cov0" title="0">err := h.smbManager.UpdateSource(sourceID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update SMB source",
                        zap.String("source_id", sourceID),
                        zap.Error(err))
                c.JSON(http.StatusNotFound, gin.H{"error": "SMB source not found"})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("SMB source updated successfully", zap.String("source_id", sourceID))

        c.JSON(http.StatusOK, gin.H{
                "message": "SMB source updated successfully",
        })</span>
}

// @Summary Get SMB health
// @Description Get overall health status of SMB monitoring system
// @Tags smb
// @Security BearerAuth
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} map[string]string
// @Router /api/v1/smb/health [get]
func (h *SMBHandler) GetHealth(c *gin.Context) <span class="cov0" title="0">{
        status := h.smbManager.GetSourceStatus()
        summary := h.generateStatusSummary(status)

        isHealthy := summary["offline"].(int) == 0 &amp;&amp; summary["disconnected"].(int) &lt; len(status)/2

        health := map[string]interface{}{
                "healthy":         isHealthy,
                "sources_summary": summary,
                "total_sources":   len(status),
                "system_uptime":   time.Since(h.smbManager.GetStartTime()).Hours(),
                "last_check":      time.Now(),
        }

        statusCode := http.StatusOK
        if !isHealthy </span><span class="cov0" title="0">{
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, health)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package handlers

import (
        "catalogizer/internal/services"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// SMBDiscoveryHandler handles SMB discovery API requests
type SMBDiscoveryHandler struct {
        service *services.SMBDiscoveryService
        logger  *zap.Logger
}

// NewSMBDiscoveryHandler creates a new SMB discovery handler
func NewSMBDiscoveryHandler(service *services.SMBDiscoveryService, logger *zap.Logger) *SMBDiscoveryHandler <span class="cov0" title="0">{
        return &amp;SMBDiscoveryHandler{
                service: service,
                logger:  logger,
        }
}</span>

// DiscoverSharesRequest represents the request to discover SMB shares
type DiscoverSharesRequest struct {
        Host     string  `json:"host" binding:"required"`
        Username string  `json:"username" binding:"required"`
        Password string  `json:"password" binding:"required"`
        Domain   *string `json:"domain"`
}

// TestConnectionRequest represents the request to test SMB connection
type TestConnectionRequest struct {
        Host     string  `json:"host" binding:"required"`
        Port     int     `json:"port"`
        Share    string  `json:"share" binding:"required"`
        Username string  `json:"username" binding:"required"`
        Password string  `json:"password" binding:"required"`
        Domain   *string `json:"domain"`
}

// BrowseShareRequest represents the request to browse SMB share
type BrowseShareRequest struct {
        Host     string  `json:"host" binding:"required"`
        Port     int     `json:"port"`
        Share    string  `json:"share" binding:"required"`
        Username string  `json:"username" binding:"required"`
        Password string  `json:"password" binding:"required"`
        Domain   *string `json:"domain"`
        Path     string  `json:"path"`
}

// DiscoverShares discovers available SMB shares on a host
// @Summary Discover SMB shares
// @Description Discovers available SMB shares on the specified host
// @Tags SMB
// @Accept json
// @Produce json
// @Param request body DiscoverSharesRequest true "Discovery request"
// @Success 200 {array} services.SMBShareInfo
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /api/v1/smb/discover [post]
func (h *SMBDiscoveryHandler) DiscoverShares(c *gin.Context) <span class="cov0" title="0">{
        var req DiscoverSharesRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid request", zap.Error(err))
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Discovering SMB shares", zap.String("host", req.Host), zap.String("username", req.Username))

        shares, err := h.service.DiscoverShares(c.Request.Context(), req.Host, req.Username, req.Password, req.Domain)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to discover SMB shares", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to discover shares: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, shares)</span>
}

// TestConnection tests an SMB connection
// @Summary Test SMB connection
// @Description Tests connectivity to an SMB share with the provided credentials
// @Tags SMB
// @Accept json
// @Produce json
// @Param request body TestConnectionRequest true "Connection test request"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /api/v1/smb/test [post]
func (h *SMBDiscoveryHandler) TestConnection(c *gin.Context) <span class="cov0" title="0">{
        var req TestConnectionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid request", zap.Error(err))
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
                return
        }</span>

        // Set default port if not provided
        <span class="cov0" title="0">if req.Port == 0 </span><span class="cov0" title="0">{
                req.Port = 445
        }</span>

        <span class="cov0" title="0">h.logger.Info("Testing SMB connection", zap.String("host", req.Host), zap.String("share", req.Share))

        config := services.SMBConnectionConfig{
                Host:     req.Host,
                Port:     req.Port,
                Share:    req.Share,
                Username: req.Username,
                Password: req.Password,
                Domain:   req.Domain,
        }

        success := h.service.TestConnection(c.Request.Context(), config)

        c.JSON(http.StatusOK, gin.H{
                "success":    success,
                "host":       req.Host,
                "share":      req.Share,
                "username":   req.Username,
                "connection": success,
        })</span>
}

// BrowseShare browses files and directories in an SMB share
// @Summary Browse SMB share
// @Description Lists files and directories in the specified SMB share path
// @Tags SMB
// @Accept json
// @Produce json
// @Param request body BrowseShareRequest true "Browse request"
// @Success 200 {array} services.SMBFileEntry
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /api/v1/smb/browse [post]
func (h *SMBDiscoveryHandler) BrowseShare(c *gin.Context) <span class="cov0" title="0">{
        var req BrowseShareRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid request", zap.Error(err))
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
                return
        }</span>

        // Set default port if not provided
        <span class="cov0" title="0">if req.Port == 0 </span><span class="cov0" title="0">{
                req.Port = 445
        }</span>

        // Set default path if not provided
        <span class="cov0" title="0">if req.Path == "" </span><span class="cov0" title="0">{
                req.Path = "."
        }</span>

        <span class="cov0" title="0">h.logger.Info("Browsing SMB share", zap.String("host", req.Host), zap.String("share", req.Share), zap.String("path", req.Path))

        config := services.SMBConnectionConfig{
                Host:     req.Host,
                Port:     req.Port,
                Share:    req.Share,
                Username: req.Username,
                Password: req.Password,
                Domain:   req.Domain,
        }

        entries, err := h.service.BrowseShare(c.Request.Context(), config, req.Path)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to browse SMB share", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to browse share: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, entries)</span>
}

// DiscoverSharesGET discovers SMB shares using GET parameters (for simple testing)
// @Summary Discover SMB shares (GET)
// @Description Discovers available SMB shares using GET parameters
// @Tags SMB
// @Produce json
// @Param host query string true "SMB host"
// @Param username query string true "Username"
// @Param password query string true "Password"
// @Param domain query string false "Domain"
// @Success 200 {array} services.SMBShareInfo
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /api/v1/smb/discover [get]
func (h *SMBDiscoveryHandler) DiscoverSharesGET(c *gin.Context) <span class="cov0" title="0">{
        host := c.Query("host")
        username := c.Query("username")
        password := c.Query("password")
        domain := c.Query("domain")

        if host == "" || username == "" || password == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "host, username, and password are required"})
                return
        }</span>

        <span class="cov0" title="0">var domainPtr *string
        if domain != "" </span><span class="cov0" title="0">{
                domainPtr = &amp;domain
        }</span>

        <span class="cov0" title="0">shares, err := h.service.DiscoverShares(c.Request.Context(), host, username, password, domainPtr)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to discover SMB shares", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to discover shares: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, shares)</span>
}

// TestConnectionGET tests SMB connection using GET parameters (for simple testing)
// @Summary Test SMB connection (GET)
// @Description Tests SMB connection using GET parameters
// @Tags SMB
// @Produce json
// @Param host query string true "SMB host"
// @Param share query string true "Share name"
// @Param username query string true "Username"
// @Param password query string true "Password"
// @Param domain query string false "Domain"
// @Param port query int false "Port (default 445)"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]interface{}
// @Router /api/v1/smb/test [get]
func (h *SMBDiscoveryHandler) TestConnectionGET(c *gin.Context) <span class="cov0" title="0">{
        host := c.Query("host")
        share := c.Query("share")
        username := c.Query("username")
        password := c.Query("password")
        domain := c.Query("domain")
        portStr := c.Query("port")

        if host == "" || share == "" || username == "" || password == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "host, share, username, and password are required"})
                return
        }</span>

        <span class="cov0" title="0">port := 445
        if portStr != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(portStr); err == nil </span><span class="cov0" title="0">{
                        port = p
                }</span>
        }

        <span class="cov0" title="0">var domainPtr *string
        if domain != "" </span><span class="cov0" title="0">{
                domainPtr = &amp;domain
        }</span>

        <span class="cov0" title="0">config := services.SMBConnectionConfig{
                Host:     host,
                Port:     port,
                Share:    share,
                Username: username,
                Password: password,
                Domain:   domainPtr,
        }

        success := h.service.TestConnection(c.Request.Context(), config)

        c.JSON(http.StatusOK, gin.H{
                "success":    success,
                "host":       host,
                "share":      share,
                "username":   username,
                "connection": success,
        })</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package analyzer

import (
        "catalogizer/internal/media/detector"
        mediamodels "catalogizer/internal/media/models"
        "catalogizer/internal/media/providers"
        "catalogizer/internal/models"
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"
)

// MediaAnalyzer handles real-time analysis of directory content
type MediaAnalyzer struct {
        db              *sql.DB
        detector        *detector.DetectionEngine
        providerManager *providers.ProviderManager
        logger          *zap.Logger
        analysisQueue   chan AnalysisRequest
        workers         int
        stopCh          chan struct{}
        wg              sync.WaitGroup
        mu              sync.RWMutex
        pendingAnalysis map[string]*AnalysisRequest
}

// AnalysisRequest represents a request to analyze a directory
type AnalysisRequest struct {
        DirectoryPath string
        SmbRoot       string
        Priority      int // Higher number = higher priority
        Timestamp     time.Time
        Callback      func(*AnalysisResult, error)
}

// AnalysisResult represents the result of directory analysis
type AnalysisResult struct {
        DirectoryAnalysis *mediamodels.DirectoryAnalysis
        MediaItem         *mediamodels.MediaItem
        ExternalMetadata  []mediamodels.ExternalMetadata
        QualityAnalysis   *QualityAnalysis
        UpdatedFiles      []mediamodels.MediaFile
}

// QualityAnalysis represents quality analysis of media files
type QualityAnalysis struct {
        BestQuality        *mediamodels.QualityInfo
        AvailableQualities []string
        TotalFiles         int
        TotalSize          int64
        DuplicateCount     int
        MissingQualities   []string
}

// NewMediaAnalyzer creates a new media analyzer
func NewMediaAnalyzer(db *sql.DB, detector *detector.DetectionEngine, providerManager *providers.ProviderManager, logger *zap.Logger) *MediaAnalyzer <span class="cov0" title="0">{
        return &amp;MediaAnalyzer{
                db:              db,
                detector:        detector,
                providerManager: providerManager,
                logger:          logger,
                analysisQueue:   make(chan AnalysisRequest, 1000),
                workers:         4, // Number of concurrent workers
                stopCh:          make(chan struct{}),
                pendingAnalysis: make(map[string]*AnalysisRequest),
        }
}</span>

// Start starts the analyzer workers
func (ma *MediaAnalyzer) Start() <span class="cov0" title="0">{
        ma.logger.Info("Starting media analyzer", zap.Int("workers", ma.workers))

        for i := 0; i &lt; ma.workers; i++ </span><span class="cov0" title="0">{
                ma.wg.Add(1)
                go ma.worker(i)
        }</span>
}

// Stop stops the analyzer workers
func (ma *MediaAnalyzer) Stop() <span class="cov0" title="0">{
        ma.logger.Info("Stopping media analyzer")
        close(ma.stopCh)
        ma.wg.Wait()
}</span>

// AnalyzeDirectory queues a directory for analysis
func (ma *MediaAnalyzer) AnalyzeDirectory(ctx context.Context, directoryPath, smbRoot string, priority int) error <span class="cov0" title="0">{
        request := AnalysisRequest{
                DirectoryPath: directoryPath,
                SmbRoot:       smbRoot,
                Priority:      priority,
                Timestamp:     time.Now(),
        }

        // Check if already pending
        ma.mu.Lock()
        if existing, exists := ma.pendingAnalysis[directoryPath]; exists </span><span class="cov0" title="0">{
                // Update priority if higher
                if priority &gt; existing.Priority </span><span class="cov0" title="0">{
                        existing.Priority = priority
                }</span>
                <span class="cov0" title="0">ma.mu.Unlock()
                return nil</span>
        }
        <span class="cov0" title="0">ma.pendingAnalysis[directoryPath] = &amp;request
        ma.mu.Unlock()

        select </span>{
        case ma.analysisQueue &lt;- request:<span class="cov0" title="0">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                ma.mu.Lock()
                delete(ma.pendingAnalysis, directoryPath)
                ma.mu.Unlock()
                return ctx.Err()</span>
        }
}

// AnalyzeDirectorySync performs synchronous directory analysis
func (ma *MediaAnalyzer) AnalyzeDirectorySync(ctx context.Context, directoryPath, smbRoot string) (*AnalysisResult, error) <span class="cov0" title="0">{
        // Get directory files
        files, err := ma.getDirectoryFiles(directoryPath, smbRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get directory files: %w", err)
        }</span>

        // Convert to detector.FileInfo
        <span class="cov0" title="0">detectorFiles := make([]detector.FileInfo, len(files))
        for i, file := range files </span><span class="cov0" title="0">{
                extension := ""
                if file.Extension != nil </span><span class="cov0" title="0">{
                        extension = *file.Extension
                }</span>
                <span class="cov0" title="0">detectorFiles[i] = detector.FileInfo{
                        Name:      file.Name,
                        Path:      file.Path,
                        Size:      file.Size,
                        Extension: extension,
                        IsDir:     file.IsDirectory,
                }</span>
        }

        // Run detection
        <span class="cov0" title="0">detectionResult, err := ma.detector.AnalyzeDirectory(directoryPath, detectorFiles)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("detection failed: %w", err)
        }</span>

        <span class="cov0" title="0">if detectionResult == nil </span><span class="cov0" title="0">{
                return &amp;AnalysisResult{}, nil // No detection
        }</span>

        // Create or update directory analysis record
        <span class="cov0" title="0">dirAnalysis, err := ma.createDirectoryAnalysis(directoryPath, smbRoot, detectionResult)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create directory analysis: %w", err)
        }</span>

        // Create or get media item
        <span class="cov0" title="0">mediaItem, err := ma.createOrUpdateMediaItem(ctx, detectionResult, dirAnalysis)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create media item: %w", err)
        }</span>

        // Fetch external metadata
        <span class="cov0" title="0">externalMetadata, err := ma.fetchExternalMetadata(ctx, mediaItem)
        if err != nil </span><span class="cov0" title="0">{
                ma.logger.Error("Failed to fetch external metadata", zap.Error(err))
                // Don't fail the whole analysis for metadata errors
        }</span>

        // Analyze quality
        <span class="cov0" title="0">qualityAnalysis, err := ma.analyzeQuality(files, mediaItem)
        if err != nil </span><span class="cov0" title="0">{
                ma.logger.Error("Failed to analyze quality", zap.Error(err))
        }</span>

        // Update media files
        <span class="cov0" title="0">updatedFiles, err := ma.updateMediaFiles(mediaItem.ID, files, directoryPath, smbRoot)
        if err != nil </span><span class="cov0" title="0">{
                ma.logger.Error("Failed to update media files", zap.Error(err))
        }</span>

        <span class="cov0" title="0">result := &amp;AnalysisResult{
                DirectoryAnalysis: dirAnalysis,
                MediaItem:         mediaItem,
                ExternalMetadata:  externalMetadata,
                QualityAnalysis:   qualityAnalysis,
                UpdatedFiles:      updatedFiles,
        }

        return result, nil</span>
}

// worker processes analysis requests
func (ma *MediaAnalyzer) worker(workerID int) <span class="cov0" title="0">{
        defer ma.wg.Done()

        ma.logger.Info("Media analyzer worker started", zap.Int("worker_id", workerID))

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ma.stopCh:<span class="cov0" title="0">
                        return</span>

                case request := &lt;-ma.analysisQueue:<span class="cov0" title="0">
                        ma.mu.Lock()
                        delete(ma.pendingAnalysis, request.DirectoryPath)
                        ma.mu.Unlock()

                        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
                        result, err := ma.AnalyzeDirectorySync(ctx, request.DirectoryPath, request.SmbRoot)
                        cancel()

                        if request.Callback != nil </span><span class="cov0" title="0">{
                                request.Callback(result, err)
                        }</span>

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                ma.logger.Error("Directory analysis failed",
                                        zap.String("directory", request.DirectoryPath),
                                        zap.String("smb_root", request.SmbRoot),
                                        zap.Error(err))
                        }</span> else<span class="cov0" title="0"> {
                                ma.logger.Info("Directory analysis completed",
                                        zap.String("directory", request.DirectoryPath),
                                        zap.String("media_type", result.MediaItem.MediaType.Name))
                        }</span>
                }
        }
}

// getDirectoryFiles retrieves files in a directory from the catalog database
func (ma *MediaAnalyzer) getDirectoryFiles(directoryPath, smbRoot string) ([]models.FileInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, path, is_directory, size, last_modified, extension, mime_type
                FROM files
                WHERE path LIKE ? AND smb_root = ?
                ORDER BY is_directory DESC, name ASC
        `

        rows, err := ma.db.Query(query, directoryPath+"%", smbRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var files []models.FileInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var file models.FileInfo
                err := rows.Scan(
                        &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory,
                        &amp;file.Size, &amp;file.LastModified, &amp;file.Extension, &amp;file.MimeType,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">files = append(files, file)</span>
        }

        <span class="cov0" title="0">return files, nil</span>
}

// createDirectoryAnalysis creates or updates directory analysis record
func (ma *MediaAnalyzer) createDirectoryAnalysis(directoryPath, smbRoot string, detection *detector.DetectionResult) (*mediamodels.DirectoryAnalysis, error) <span class="cov0" title="0">{
        analysisDataJSON, _ := json.Marshal(detection.AnalysisData)

        query := `
                INSERT OR REPLACE INTO directory_analysis
                (directory_path, smb_root, media_item_id, confidence_score, detection_method, analysis_data, last_analyzed, files_count, total_size)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        // Calculate files count and total size from analysis data
        filesCount := 0
        totalSize := int64(0)
        if detection.AnalysisData != nil </span><span class="cov0" title="0">{
                for _, count := range detection.AnalysisData.FileTypes </span><span class="cov0" title="0">{
                        filesCount += count
                }</span>
                <span class="cov0" title="0">for _, size := range detection.AnalysisData.SizeDistribution </span><span class="cov0" title="0">{
                        totalSize += size
                }</span>
        }

        <span class="cov0" title="0">_, err := ma.db.Exec(query,
                directoryPath, smbRoot, nil, // media_item_id will be set later
                detection.Confidence, detection.Method, string(analysisDataJSON),
                time.Now(), filesCount, totalSize,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the created record
        <span class="cov0" title="0">return &amp;mediamodels.DirectoryAnalysis{
                DirectoryPath:   directoryPath,
                SmbRoot:         smbRoot,
                ConfidenceScore: detection.Confidence,
                DetectionMethod: detection.Method,
                AnalysisData:    detection.AnalysisData,
                LastAnalyzed:    time.Now(),
                FilesCount:      filesCount,
                TotalSize:       totalSize,
        }, nil</span>
}

// createOrUpdateMediaItem creates or updates media item
func (ma *MediaAnalyzer) createOrUpdateMediaItem(ctx context.Context, detection *detector.DetectionResult, dirAnalysis *mediamodels.DirectoryAnalysis) (*mediamodels.MediaItem, error) <span class="cov0" title="0">{
        // Check if media item already exists
        var existingID *int64
        err := ma.db.QueryRow(
                "SELECT media_item_id FROM directory_analysis WHERE directory_path = ?",
                dirAnalysis.DirectoryPath,
        ).Scan(&amp;existingID)

        if err == nil &amp;&amp; existingID != nil </span><span class="cov0" title="0">{
                // Update existing media item
                return ma.updateExistingMediaItem(*existingID, detection)
        }</span>

        // Create new media item
        <span class="cov0" title="0">genreJSON, _ := json.Marshal([]string{}) // Empty for now
        castCrewJSON, _ := json.Marshal(&amp;mediamodels.CastCrew{})

        query := `
                INSERT INTO media_items
                (media_type_id, title, year, description, genre, cast_crew, status, first_detected, last_updated)
                VALUES (?, ?, ?, ?, ?, ?, 'active', ?, ?)
        `

        result, err := ma.db.Exec(query,
                detection.MediaTypeID, detection.SuggestedTitle, detection.SuggestedYear,
                nil, string(genreJSON), string(castCrewJSON),
                time.Now(), time.Now(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mediaItemID, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update directory analysis with media item ID
        <span class="cov0" title="0">_, err = ma.db.Exec(
                "UPDATE directory_analysis SET media_item_id = ? WHERE directory_path = ?",
                mediaItemID, dirAnalysis.DirectoryPath,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return the created media item
        <span class="cov0" title="0">mediaItem := &amp;mediamodels.MediaItem{
                ID:            mediaItemID,
                MediaTypeID:   detection.MediaTypeID,
                MediaType:     detection.MediaType,
                Title:         detection.SuggestedTitle,
                Year:          detection.SuggestedYear,
                Status:        "active",
                FirstDetected: time.Now(),
                LastUpdated:   time.Now(),
        }

        return mediaItem, nil</span>
}

// updateExistingMediaItem updates an existing media item
func (ma *MediaAnalyzer) updateExistingMediaItem(mediaItemID int64, detection *detector.DetectionResult) (*mediamodels.MediaItem, error) <span class="cov0" title="0">{
        // Get existing media item
        query := `
                SELECT id, media_type_id, title, year, description, genre, director, cast_crew, rating, runtime, language, country, status, first_detected, last_updated
                FROM media_items WHERE id = ?
        `

        var item mediamodels.MediaItem
        var genreJSON, castCrewJSON string

        err := ma.db.QueryRow(query, mediaItemID).Scan(
                &amp;item.ID, &amp;item.MediaTypeID, &amp;item.Title, &amp;item.Year, &amp;item.Description,
                &amp;genreJSON, &amp;item.Director, &amp;castCrewJSON, &amp;item.Rating, &amp;item.Runtime,
                &amp;item.Language, &amp;item.Country, &amp;item.Status, &amp;item.FirstDetected, &amp;item.LastUpdated,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unmarshal JSON fields
        <span class="cov0" title="0">json.Unmarshal([]byte(genreJSON), &amp;item.Genre)
        json.Unmarshal([]byte(castCrewJSON), &amp;item.CastCrew)

        // Update last_updated timestamp
        _, err = ma.db.Exec("UPDATE media_items SET last_updated = ? WHERE id = ?", time.Now(), mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">item.LastUpdated = time.Now()
        return &amp;item, nil</span>
}

// fetchExternalMetadata fetches metadata from external providers
func (ma *MediaAnalyzer) fetchExternalMetadata(ctx context.Context, mediaItem *mediamodels.MediaItem) ([]mediamodels.ExternalMetadata, error) <span class="cov0" title="0">{
        if mediaItem.MediaType == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("media type not available")
        }</span>

        // Get the best match from providers
        <span class="cov0" title="0">bestResult, providerName, err := ma.providerManager.GetBestMatch(
                ctx, mediaItem.Title, mediaItem.MediaType.Name, mediaItem.Year,
        )
        if err != nil || bestResult == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get detailed metadata
        <span class="cov0" title="0">metadata, err := ma.providerManager.GetDetails(ctx, providerName, bestResult.ExternalID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">metadata.MediaItemID = mediaItem.ID

        // Save to database
        query := `
                INSERT OR REPLACE INTO external_metadata
                (media_item_id, provider, external_id, data, rating, review_url, cover_url, trailer_url, last_fetched)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = ma.db.Exec(query,
                metadata.MediaItemID, metadata.Provider, metadata.ExternalID, metadata.Data,
                metadata.Rating, metadata.ReviewURL, metadata.CoverURL, metadata.TrailerURL, metadata.LastFetched,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return []mediamodels.ExternalMetadata{*metadata}, nil</span>
}

// analyzeQuality analyzes the quality of media files
func (ma *MediaAnalyzer) analyzeQuality(files []models.FileInfo, mediaItem *mediamodels.MediaItem) (*QualityAnalysis, error) <span class="cov0" title="0">{
        if mediaItem.MediaType == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("media type not available")
        }</span>

        <span class="cov0" title="0">analysis := &amp;QualityAnalysis{
                AvailableQualities: make([]string, 0),
                TotalFiles:         len(files),
        }

        // Analyze video/audio files
        mediaFiles := ma.filterMediaFiles(files, mediaItem.MediaType.Name)
        analysis.TotalFiles = len(mediaFiles)

        for _, file := range mediaFiles </span><span class="cov0" title="0">{
                analysis.TotalSize += file.Size

                // Extract quality information from filename
                qualityInfo := ma.extractQualityFromFilename(file.Name, file.Extension)
                if qualityInfo != nil </span><span class="cov0" title="0">{
                        qualityName := qualityInfo.GetDisplayName()
                        if !contains(analysis.AvailableQualities, qualityName) </span><span class="cov0" title="0">{
                                analysis.AvailableQualities = append(analysis.AvailableQualities, qualityName)
                        }</span>

                        // Track best quality
                        <span class="cov0" title="0">if analysis.BestQuality == nil || qualityInfo.IsBetterThan(analysis.BestQuality) </span><span class="cov0" title="0">{
                                analysis.BestQuality = qualityInfo
                        }</span>
                }
        }

        <span class="cov0" title="0">return analysis, nil</span>
}

// filterMediaFiles filters files relevant to the media type
func (ma *MediaAnalyzer) filterMediaFiles(files []models.FileInfo, mediaType string) []models.FileInfo <span class="cov0" title="0">{
        mediaExtensions := map[string][]string{
                "movie":     {".mp4", ".mkv", ".avi", ".mov", ".wmv", ".flv", ".m4v"},
                "tv_show":   {".mp4", ".mkv", ".avi", ".mov", ".wmv", ".flv", ".m4v"},
                "anime":     {".mp4", ".mkv", ".avi", ".mov", ".wmv", ".flv", ".m4v"},
                "music":     {".mp3", ".flac", ".wav", ".m4a", ".aac", ".ogg", ".wma"},
                "audiobook": {".mp3", ".m4a", ".m4b", ".aac", ".ogg"},
                "podcast":   {".mp3", ".m4a", ".aac", ".ogg"},
        }

        extensions, exists := mediaExtensions[mediaType]
        if !exists </span><span class="cov0" title="0">{
                return files // Return all files if media type not recognized
        }</span>

        <span class="cov0" title="0">var filtered []models.FileInfo
        for _, file := range files </span><span class="cov0" title="0">{
                if file.IsDirectory </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if file.Extension != nil </span><span class="cov0" title="0">{
                        for _, ext := range extensions </span><span class="cov0" title="0">{
                                if strings.EqualFold(*file.Extension, ext) </span><span class="cov0" title="0">{
                                        filtered = append(filtered, file)
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return filtered</span>
}

// extractQualityFromFilename extracts quality information from filename
func (ma *MediaAnalyzer) extractQualityFromFilename(filename string, extension *string) *mediamodels.QualityInfo <span class="cov0" title="0">{
        lower := strings.ToLower(filename)
        quality := &amp;mediamodels.QualityInfo{}

        // Resolution detection
        if strings.Contains(lower, "2160p") || strings.Contains(lower, "4k") || strings.Contains(lower, "uhd") </span><span class="cov0" title="0">{
                quality.Resolution = &amp;mediamodels.Resolution{Width: 3840, Height: 2160}
                quality.QualityScore = 100
                profile := "4K/UHD"
                quality.QualityProfile = &amp;profile
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "1080p") || strings.Contains(lower, "fhd") </span><span class="cov0" title="0">{
                quality.Resolution = &amp;mediamodels.Resolution{Width: 1920, Height: 1080}
                quality.QualityScore = 80
                profile := "1080p"
                quality.QualityProfile = &amp;profile
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "720p") || strings.Contains(lower, "hd") </span><span class="cov0" title="0">{
                quality.Resolution = &amp;mediamodels.Resolution{Width: 1280, Height: 720}
                quality.QualityScore = 60
                profile := "720p"
                quality.QualityProfile = &amp;profile
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "480p") || strings.Contains(lower, "dvd") </span><span class="cov0" title="0">{
                quality.Resolution = &amp;mediamodels.Resolution{Width: 720, Height: 480}
                quality.QualityScore = 40
                profile := "480p/DVD"
                quality.QualityProfile = &amp;profile
        }</span>

        // Source detection
        <span class="cov0" title="0">if strings.Contains(lower, "bluray") || strings.Contains(lower, "brrip") </span><span class="cov0" title="0">{
                source := "BluRay"
                quality.Source = &amp;source
                quality.QualityScore += 10
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "webdl") || strings.Contains(lower, "web-dl") </span><span class="cov0" title="0">{
                source := "WEB-DL"
                quality.Source = &amp;source
                quality.QualityScore += 5
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "webrip") </span><span class="cov0" title="0">{
                source := "WEB-RIP"
                quality.Source = &amp;source
        }</span>

        // Codec detection
        <span class="cov0" title="0">if strings.Contains(lower, "x265") || strings.Contains(lower, "h265") || strings.Contains(lower, "hevc") </span><span class="cov0" title="0">{
                codec := "H.265/HEVC"
                quality.VideoCodec = &amp;codec
                quality.QualityScore += 5
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "x264") || strings.Contains(lower, "h264") || strings.Contains(lower, "avc") </span><span class="cov0" title="0">{
                codec := "H.264/AVC"
                quality.VideoCodec = &amp;codec
        }</span>

        // Audio codec detection
        <span class="cov0" title="0">if strings.Contains(lower, "dts") </span><span class="cov0" title="0">{
                audioCodec := "DTS"
                quality.AudioCodec = &amp;audioCodec
                quality.QualityScore += 5
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "aac") </span><span class="cov0" title="0">{
                audioCodec := "AAC"
                quality.AudioCodec = &amp;audioCodec
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "ac3") </span><span class="cov0" title="0">{
                audioCodec := "AC3"
                quality.AudioCodec = &amp;audioCodec
        }</span>

        // HDR detection
        <span class="cov0" title="0">if strings.Contains(lower, "hdr") || strings.Contains(lower, "dolby.vision") </span><span class="cov0" title="0">{
                quality.HDR = true
                quality.QualityScore += 10
        }</span>

        // For audio files
        <span class="cov0" title="0">if extension != nil </span><span class="cov0" title="0">{
                ext := strings.ToLower(*extension)
                if ext == ".flac" || ext == ".wav" </span><span class="cov0" title="0">{
                        quality.QualityScore = 90
                        profile := "Audio_Lossless"
                        quality.QualityProfile = &amp;profile
                }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "320") || strings.Contains(lower, "320k") </span><span class="cov0" title="0">{
                        quality.QualityScore = 70
                        profile := "Audio_320k"
                        quality.QualityProfile = &amp;profile
                }</span> else<span class="cov0" title="0"> if ext == ".mp3" </span><span class="cov0" title="0">{
                        quality.QualityScore = 50
                        profile := "Audio_128k"
                        quality.QualityProfile = &amp;profile
                }</span>
        }

        <span class="cov0" title="0">return quality</span>
}

// updateMediaFiles creates or updates media file records
func (ma *MediaAnalyzer) updateMediaFiles(mediaItemID int64, files []models.FileInfo, directoryPath, smbRoot string) ([]mediamodels.MediaFile, error) <span class="cov0" title="0">{
        var updatedFiles []mediamodels.MediaFile

        for _, file := range files </span><span class="cov0" title="0">{
                if file.IsDirectory </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract quality info
                <span class="cov0" title="0">qualityInfo := ma.extractQualityFromFilename(file.Name, file.Extension)
                qualityJSON, _ := json.Marshal(qualityInfo)

                // Generate SMB links
                directSmbLink := fmt.Sprintf("smb://%s/%s", smbRoot, file.Path)
                virtualSmbLink := fmt.Sprintf("virtual://%s/%d", smbRoot, file.ID)

                query := `
                        INSERT OR REPLACE INTO media_files
                        (media_item_id, file_path, smb_root, filename, file_size, file_extension, quality_info,
                         direct_smb_link, virtual_smb_link, last_verified, created_at)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                `

                _, err := ma.db.Exec(query,
                        mediaItemID, file.Path, smbRoot, file.Name, file.Size, file.Extension,
                        string(qualityJSON), directSmbLink, virtualSmbLink, time.Now(), time.Now(),
                )
                if err != nil </span><span class="cov0" title="0">{
                        ma.logger.Error("Failed to update media file", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">mediaFile := mediamodels.MediaFile{
                        MediaItemID:    mediaItemID,
                        FilePath:       file.Path,
                        SmbRoot:        smbRoot,
                        Filename:       file.Name,
                        FileSize:       file.Size,
                        FileExtension:  file.Extension,
                        QualityInfo:    qualityInfo,
                        DirectSmbLink:  directSmbLink,
                        VirtualSmbLink: &amp;virtualSmbLink,
                        LastVerified:   time.Now(),
                        CreatedAt:      time.Now(),
                }

                updatedFiles = append(updatedFiles, mediaFile)</span>
        }

        <span class="cov0" title="0">return updatedFiles, nil</span>
}

// Helper function
func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "io/ioutil"
        "path/filepath"

        _ "github.com/mattn/go-sqlite3"
        "go.uber.org/zap"
)

// MediaDatabase handles SQLite database with SQLCipher encryption
type MediaDatabase struct {
        db       *sql.DB
        dbPath   string
        password string
        logger   *zap.Logger
}

// DatabaseConfig represents database configuration
type DatabaseConfig struct {
        Path     string `json:"path"`
        Password string `json:"password"`
}

// NewMediaDatabase creates a new encrypted media database
func NewMediaDatabase(config DatabaseConfig, logger *zap.Logger) (*MediaDatabase, error) <span class="cov0" title="0">{
        if config.Path == "" </span><span class="cov0" title="0">{
                config.Path = "media_catalog.db"
        }</span>

        <span class="cov0" title="0">if config.Password == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database password is required for encryption")
        }</span>

        <span class="cov0" title="0">mdb := &amp;MediaDatabase{
                dbPath:   config.Path,
                password: config.Password,
                logger:   logger,
        }

        if err := mdb.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">if err := mdb.initialize(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize database: %w", err)
        }</span>

        <span class="cov0" title="0">return mdb, nil</span>
}

// connect establishes connection to the encrypted database
func (mdb *MediaDatabase) connect() error <span class="cov0" title="0">{
        // Connection string for SQLCipher
        dsn := fmt.Sprintf("file:%s?_pragma_key=%s&amp;_pragma_cipher_page_size=4096", mdb.dbPath, mdb.password)

        db, err := sql.Open("sqlcipher", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Test the connection and encryption
        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return fmt.Errorf("failed to ping database: %w", err)
        }</span>

        // Verify encryption is working
        <span class="cov0" title="0">var result string
        err = db.QueryRow("PRAGMA cipher_version").Scan(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                db.Close()
                return fmt.Errorf("failed to verify encryption: %w", err)
        }</span>

        <span class="cov0" title="0">mdb.db = db
        mdb.logger.Info("Connected to encrypted media database",
                zap.String("path", mdb.dbPath),
                zap.String("cipher_version", result))

        return nil</span>
}

// initialize creates database schema
func (mdb *MediaDatabase) initialize() error <span class="cov0" title="0">{
        // Read schema from file
        schemaPath := filepath.Join(filepath.Dir(mdb.dbPath), "schema.sql")
        schemaContent, err := ioutil.ReadFile(schemaPath)
        if err != nil </span><span class="cov0" title="0">{
                // If schema file doesn't exist, use embedded schema
                return mdb.createSchemaFromString(getEmbeddedSchema())
        }</span>

        <span class="cov0" title="0">return mdb.createSchemaFromString(string(schemaContent))</span>
}

// createSchemaFromString executes schema SQL
func (mdb *MediaDatabase) createSchemaFromString(schema string) error <span class="cov0" title="0">{
        // Execute schema in a transaction
        tx, err := mdb.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        if _, err := tx.Exec(schema); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute schema: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit schema: %w", err)
        }</span>

        <span class="cov0" title="0">mdb.logger.Info("Database schema initialized successfully")
        return nil</span>
}

// GetDB returns the database connection
func (mdb *MediaDatabase) GetDB() *sql.DB <span class="cov0" title="0">{
        return mdb.db
}</span>

// Close closes the database connection
func (mdb *MediaDatabase) Close() error <span class="cov0" title="0">{
        if mdb.db != nil </span><span class="cov0" title="0">{
                return mdb.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Backup creates an encrypted backup of the database
func (mdb *MediaDatabase) Backup(backupPath string) error <span class="cov0" title="0">{
        _, err := mdb.db.Exec(fmt.Sprintf(`
                ATTACH DATABASE '%s' AS backup KEY '%s';
                INSERT INTO backup.sqlite_master SELECT * FROM main.sqlite_master WHERE type='table';
        `, backupPath, mdb.password))

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("backup failed: %w", err)
        }</span>

        // Copy all tables
        <span class="cov0" title="0">tables, err := mdb.getTables()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get tables: %w", err)
        }</span>

        <span class="cov0" title="0">tx, err := mdb.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin backup transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Attach backup database
        if _, err := tx.Exec(fmt.Sprintf("ATTACH DATABASE '%s' AS backup KEY '%s'", backupPath, mdb.password)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to attach backup database: %w", err)
        }</span>

        // Copy each table
        <span class="cov0" title="0">for _, table := range tables </span><span class="cov0" title="0">{
                copyQuery := fmt.Sprintf("CREATE TABLE backup.%s AS SELECT * FROM main.%s", table, table)
                if _, err := tx.Exec(copyQuery); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to copy table %s: %w", table, err)
                }</span>
        }

        // Detach backup database
        <span class="cov0" title="0">if _, err := tx.Exec("DETACH DATABASE backup"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to detach backup database: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit backup: %w", err)
        }</span>

        <span class="cov0" title="0">mdb.logger.Info("Database backup created", zap.String("backup_path", backupPath))
        return nil</span>
}

// HealthCheck verifies database health
func (mdb *MediaDatabase) HealthCheck() error <span class="cov0" title="0">{
        // Check database integrity
        var result string
        if err := mdb.db.QueryRow("PRAGMA integrity_check").Scan(&amp;result); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integrity check failed: %w", err)
        }</span>

        <span class="cov0" title="0">if result != "ok" </span><span class="cov0" title="0">{
                return fmt.Errorf("database integrity check failed: %s", result)
        }</span>

        // Check if we can read from a table
        <span class="cov0" title="0">var count int
        if err := mdb.db.QueryRow("SELECT COUNT(*) FROM media_types").Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query media_types: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetStats returns database statistics
func (mdb *MediaDatabase) GetStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Database size
        var pageCount, pageSize int64
        if err := mdb.db.QueryRow("PRAGMA page_count").Scan(&amp;pageCount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := mdb.db.QueryRow("PRAGMA page_size").Scan(&amp;pageSize); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">stats["size_bytes"] = pageCount * pageSize

        // Table counts
        tableCounts := map[string]int64{
                "media_types":        0,
                "media_items":        0,
                "external_metadata":  0,
                "directory_analysis": 0,
                "media_files":        0,
                "media_collections":  0,
                "user_metadata":      0,
        }

        for table := range tableCounts </span><span class="cov0" title="0">{
                var count int64
                query := fmt.Sprintf("SELECT COUNT(*) FROM %s", table)
                if err := mdb.db.QueryRow(query).Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                        mdb.logger.Error("Failed to count table", zap.String("table", table), zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">tableCounts[table] = count</span>
        }
        <span class="cov0" title="0">stats["table_counts"] = tableCounts

        // Recent activity
        var recentAnalysis int64
        if err := mdb.db.QueryRow("SELECT COUNT(*) FROM directory_analysis WHERE last_analyzed &gt; datetime('now', '-24 hours')").Scan(&amp;recentAnalysis); err == nil </span><span class="cov0" title="0">{
                stats["recent_analysis_24h"] = recentAnalysis
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// getTables returns list of all tables
func (mdb *MediaDatabase) getTables() ([]string, error) <span class="cov0" title="0">{
        rows, err := mdb.db.Query("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tables []string
        for rows.Next() </span><span class="cov0" title="0">{
                var table string
                if err := rows.Scan(&amp;table); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">tables = append(tables, table)</span>
        }

        <span class="cov0" title="0">return tables, nil</span>
}

// getEmbeddedSchema returns the embedded schema as fallback
func getEmbeddedSchema() string <span class="cov0" title="0">{
        return `
-- Simplified embedded schema for fallback
CREATE TABLE IF NOT EXISTS media_types (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    detection_patterns TEXT,
    metadata_providers TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS media_items (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    media_type_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    original_title TEXT,
    year INTEGER,
    description TEXT,
    genre TEXT,
    director TEXT,
    cast_crew TEXT,
    rating REAL,
    runtime INTEGER,
    language TEXT,
    country TEXT,
    status TEXT DEFAULT 'active',
    first_detected DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (media_type_id) REFERENCES media_types(id)
);

CREATE TABLE IF NOT EXISTS external_metadata (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    media_item_id INTEGER NOT NULL,
    provider TEXT NOT NULL,
    external_id TEXT NOT NULL,
    data TEXT NOT NULL,
    rating REAL,
    review_url TEXT,
    cover_url TEXT,
    trailer_url TEXT,
    last_fetched DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (media_item_id) REFERENCES media_items(id),
    UNIQUE(media_item_id, provider)
);

CREATE TABLE IF NOT EXISTS directory_analysis (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    directory_path TEXT NOT NULL UNIQUE,
    smb_root TEXT NOT NULL,
    media_item_id INTEGER,
    confidence_score REAL NOT NULL,
    detection_method TEXT NOT NULL,
    analysis_data TEXT,
    last_analyzed DATETIME DEFAULT CURRENT_TIMESTAMP,
    files_count INTEGER DEFAULT 0,
    total_size INTEGER DEFAULT 0,
    FOREIGN KEY (media_item_id) REFERENCES media_items(id)
);

CREATE TABLE IF NOT EXISTS media_files (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    media_item_id INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    smb_root TEXT NOT NULL,
    filename TEXT NOT NULL,
    file_size INTEGER NOT NULL,
    file_extension TEXT,
    quality_info TEXT,
    language TEXT,
    subtitle_tracks TEXT,
    audio_tracks TEXT,
    duration INTEGER,
    checksum TEXT,
    virtual_smb_link TEXT,
    direct_smb_link TEXT,
    last_verified DATETIME DEFAULT CURRENT_TIMESTAMP,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (media_item_id) REFERENCES media_items(id)
);

-- Insert basic media types
INSERT OR IGNORE INTO media_types (name, description) VALUES
('movie', 'Feature films and movies'),
('tv_show', 'Television series and episodes'),
('music', 'Music albums and tracks'),
('game', 'Video games and software'),
('software', 'Applications and utilities'),
('training', 'Educational and training content'),
('other', 'Unclassified content');
`
}</span>

// Vacuum optimizes the database
func (mdb *MediaDatabase) Vacuum() error <span class="cov0" title="0">{
        mdb.logger.Info("Starting database vacuum")
        if _, err := mdb.db.Exec("VACUUM"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("vacuum failed: %w", err)
        }</span>
        <span class="cov0" title="0">mdb.logger.Info("Database vacuum completed")
        return nil</span>
}

// ChangePassword changes the database encryption password
func (mdb *MediaDatabase) ChangePassword(newPassword string) error <span class="cov0" title="0">{
        if newPassword == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("new password cannot be empty")
        }</span>

        <span class="cov0" title="0">pragma := fmt.Sprintf("PRAGMA rekey = '%s'", newPassword)
        if _, err := mdb.db.Exec(pragma); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to change password: %w", err)
        }</span>

        <span class="cov0" title="0">mdb.password = newPassword
        mdb.logger.Info("Database password changed successfully")
        return nil</span>
}

// ExecuteInTransaction executes multiple statements in a transaction
func (mdb *MediaDatabase) ExecuteInTransaction(fn func(*sql.Tx) error) error <span class="cov0" title="0">{
        tx, err := mdb.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        if err := fn(tx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package detector

import (
        "catalogizer/internal/media/models"
        "encoding/json"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "time"

        "go.uber.org/zap"
)

// DetectionEngine handles automatic content type detection
type DetectionEngine struct {
        logger     *zap.Logger
        rules      []models.DetectionRule
        mediaTypes map[int64]*models.MediaType
}

// NewDetectionEngine creates a new detection engine
func NewDetectionEngine(logger *zap.Logger) *DetectionEngine <span class="cov0" title="0">{
        return &amp;DetectionEngine{
                logger:     logger,
                rules:      []models.DetectionRule{},
                mediaTypes: make(map[int64]*models.MediaType),
        }
}</span>

// LoadRules loads detection rules from database or configuration
func (e *DetectionEngine) LoadRules(rules []models.DetectionRule, mediaTypes []models.MediaType) <span class="cov0" title="0">{
        e.rules = rules

        // Sort rules by priority (higher first)
        sort.Slice(e.rules, func(i, j int) bool </span><span class="cov0" title="0">{
                return e.rules[i].Priority &gt; e.rules[j].Priority
        }</span>)

        // Index media types
        <span class="cov0" title="0">for _, mt := range mediaTypes </span><span class="cov0" title="0">{
                e.mediaTypes[mt.ID] = &amp;mt
        }</span>

        <span class="cov0" title="0">e.logger.Info("Detection rules loaded",
                zap.Int("rules_count", len(e.rules)),
                zap.Int("media_types", len(e.mediaTypes)))</span>
}

// DetectionResult represents the result of content detection
type DetectionResult struct {
        MediaTypeID     int64                `json:"media_type_id"`
        MediaType       *models.MediaType    `json:"media_type"`
        Confidence      float64              `json:"confidence"`
        Method          string               `json:"method"`
        MatchedPatterns []string             `json:"matched_patterns"`
        AnalysisData    *models.AnalysisData `json:"analysis_data"`
        SuggestedTitle  string               `json:"suggested_title"`
        SuggestedYear   *int                 `json:"suggested_year"`
        QualityHints    []string             `json:"quality_hints"`
}

// AnalyzeDirectory analyzes a directory to determine its content type
func (e *DetectionEngine) AnalyzeDirectory(directoryPath string, files []FileInfo) (*DetectionResult, error) <span class="cov0" title="0">{
        results := make([]*DetectionResult, 0)

        // Run all enabled rules
        for _, rule := range e.rules </span><span class="cov0" title="0">{
                if !rule.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">mediaType := e.mediaTypes[rule.MediaTypeID]
                if mediaType == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var confidence float64
                var matchedPatterns []string
                var method string

                switch rule.RuleType </span>{
                case "filename_pattern":<span class="cov0" title="0">
                        confidence, matchedPatterns = e.analyzeFilenamePatterns(rule.Pattern, files)
                        method = "filename_pattern"</span>

                case "directory_structure":<span class="cov0" title="0">
                        confidence, matchedPatterns = e.analyzeDirectoryStructure(rule.Pattern, directoryPath, files)
                        method = "directory_structure"</span>

                case "file_analysis":<span class="cov0" title="0">
                        confidence, matchedPatterns = e.analyzeFileContent(rule.Pattern, files)
                        method = "file_analysis"</span>

                case "hybrid":<span class="cov0" title="0">
                        confidence, matchedPatterns = e.analyzeHybrid(rule.Pattern, directoryPath, files)
                        method = "hybrid"</span>
                }

                <span class="cov0" title="0">if confidence &gt; 0 </span><span class="cov0" title="0">{
                        // Apply rule weight
                        confidence *= rule.ConfidenceWeight

                        // Extract additional metadata
                        title, year := e.extractTitleAndYear(directoryPath, files, mediaType.Name)
                        qualityHints := e.extractQualityHints(directoryPath, files)

                        result := &amp;DetectionResult{
                                MediaTypeID:     rule.MediaTypeID,
                                MediaType:       mediaType,
                                Confidence:      confidence,
                                Method:          method,
                                MatchedPatterns: matchedPatterns,
                                SuggestedTitle:  title,
                                SuggestedYear:   year,
                                QualityHints:    qualityHints,
                                AnalysisData:    e.buildAnalysisData(directoryPath, files, matchedPatterns, confidence),
                        }

                        results = append(results, result)
                }</span>
        }

        // Return the highest confidence result
        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Sort by confidence
        <span class="cov0" title="0">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                return results[i].Confidence &gt; results[j].Confidence
        }</span>)

        <span class="cov0" title="0">return results[0], nil</span>
}

// FileInfo represents basic file information for analysis
type FileInfo struct {
        Name      string
        Path      string
        Size      int64
        Extension string
        IsDir     bool
}

// analyzeFilenamePatterns checks files against filename patterns
func (e *DetectionEngine) analyzeFilenamePatterns(pattern string, files []FileInfo) (float64, []string) <span class="cov0" title="0">{
        var patterns []string
        if err := json.Unmarshal([]byte(pattern), &amp;patterns); err != nil </span><span class="cov0" title="0">{
                // Single pattern
                patterns = []string{pattern}
        }</span>

        <span class="cov0" title="0">totalFiles := len(files)
        if totalFiles == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">matchedFiles := 0
        matchedPatterns := make([]string, 0)

        for _, p := range patterns </span><span class="cov0" title="0">{
                regex, err := e.globToRegex(p)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                        if regex.MatchString(strings.ToLower(file.Name)) </span><span class="cov0" title="0">{
                                matchedFiles++
                                matchedPatterns = append(matchedPatterns, p)
                                break</span> // Don't count same pattern multiple times
                        }
                }
        }

        <span class="cov0" title="0">confidence := float64(matchedFiles) / float64(len(patterns))
        if confidence &gt; 1.0 </span><span class="cov0" title="0">{
                confidence = 1.0
        }</span>

        <span class="cov0" title="0">return confidence, matchedPatterns</span>
}

// analyzeDirectoryStructure analyzes directory structure patterns
func (e *DetectionEngine) analyzeDirectoryStructure(pattern string, dirPath string, files []FileInfo) (float64, []string) <span class="cov0" title="0">{
        var structureRules map[string]interface{}
        if err := json.Unmarshal([]byte(pattern), &amp;structureRules); err != nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">confidence := 0.0
        matchedPatterns := make([]string, 0)

        // Check for required directories
        if requiredDirs, ok := structureRules["required_dirs"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, reqDir := range requiredDirs </span><span class="cov0" title="0">{
                        dirName := reqDir.(string)
                        found := false
                        for _, file := range files </span><span class="cov0" title="0">{
                                if file.IsDir &amp;&amp; strings.Contains(strings.ToLower(file.Name), strings.ToLower(dirName)) </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                                confidence += 0.3
                                matchedPatterns = append(matchedPatterns, "dir:"+dirName)
                        }</span>
                }
        }

        // Check for file type distribution
        <span class="cov0" title="0">if fileTypes, ok := structureRules["file_types"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for ext, minCount := range fileTypes </span><span class="cov0" title="0">{
                        count := 0
                        for _, file := range files </span><span class="cov0" title="0">{
                                if strings.EqualFold(file.Extension, ext) </span><span class="cov0" title="0">{
                                        count++
                                }</span>
                        }
                        <span class="cov0" title="0">if count &gt;= int(minCount.(float64)) </span><span class="cov0" title="0">{
                                confidence += 0.2
                                matchedPatterns = append(matchedPatterns, "filetype:"+ext)
                        }</span>
                }
        }

        // Normalize confidence
        <span class="cov0" title="0">if confidence &gt; 1.0 </span><span class="cov0" title="0">{
                confidence = 1.0
        }</span>

        <span class="cov0" title="0">return confidence, matchedPatterns</span>
}

// analyzeFileContent analyzes actual file content (basic implementation)
func (e *DetectionEngine) analyzeFileContent(pattern string, files []FileInfo) (float64, []string) <span class="cov0" title="0">{
        // This would implement more sophisticated content analysis
        // For now, it's a placeholder that analyzes file extensions and sizes

        var contentRules map[string]interface{}
        if err := json.Unmarshal([]byte(pattern), &amp;contentRules); err != nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">confidence := 0.0
        matchedPatterns := make([]string, 0)

        // Analyze file size patterns
        if sizeRules, ok := contentRules["size_patterns"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for sizeType, conditions := range sizeRules </span><span class="cov0" title="0">{
                        condMap := conditions.(map[string]interface{})
                        minSize := int64(condMap["min_size"].(float64))
                        maxSize := int64(condMap["max_size"].(float64))

                        matchCount := 0
                        for _, file := range files </span><span class="cov0" title="0">{
                                if file.Size &gt;= minSize &amp;&amp; file.Size &lt;= maxSize </span><span class="cov0" title="0">{
                                        matchCount++
                                }</span>
                        }

                        <span class="cov0" title="0">if matchCount &gt; 0 </span><span class="cov0" title="0">{
                                confidence += 0.2
                                matchedPatterns = append(matchedPatterns, "size:"+sizeType)
                        }</span>
                }
        }

        <span class="cov0" title="0">return confidence, matchedPatterns</span>
}

// analyzeHybrid combines multiple analysis methods
func (e *DetectionEngine) analyzeHybrid(pattern string, dirPath string, files []FileInfo) (float64, []string) <span class="cov0" title="0">{
        var hybridRules map[string]interface{}
        if err := json.Unmarshal([]byte(pattern), &amp;hybridRules); err != nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">totalConfidence := 0.0
        allPatterns := make([]string, 0)

        // Run filename analysis
        if filenamePattern, ok := hybridRules["filename"].(string); ok </span><span class="cov0" title="0">{
                conf, patterns := e.analyzeFilenamePatterns(filenamePattern, files)
                totalConfidence += conf * 0.4
                allPatterns = append(allPatterns, patterns...)
        }</span>

        // Run structure analysis
        <span class="cov0" title="0">if structurePattern, ok := hybridRules["structure"].(string); ok </span><span class="cov0" title="0">{
                conf, patterns := e.analyzeDirectoryStructure(structurePattern, dirPath, files)
                totalConfidence += conf * 0.3
                allPatterns = append(allPatterns, patterns...)
        }</span>

        // Run content analysis
        <span class="cov0" title="0">if contentPattern, ok := hybridRules["content"].(string); ok </span><span class="cov0" title="0">{
                conf, patterns := e.analyzeFileContent(contentPattern, files)
                totalConfidence += conf * 0.3
                allPatterns = append(allPatterns, patterns...)
        }</span>

        <span class="cov0" title="0">return totalConfidence, allPatterns</span>
}

// extractTitleAndYear extracts title and year from directory/file names
func (e *DetectionEngine) extractTitleAndYear(dirPath string, files []FileInfo, mediaType string) (string, *int) <span class="cov0" title="0">{
        dirName := filepath.Base(dirPath)

        // Extract year using regex
        yearRegex := regexp.MustCompile(`\((\d{4})\)|\[(\d{4})\]|(\d{4})`)
        yearMatches := yearRegex.FindStringSubmatch(dirName)

        var year *int
        if len(yearMatches) &gt; 0 </span><span class="cov0" title="0">{
                for i := 1; i &lt; len(yearMatches); i++ </span><span class="cov0" title="0">{
                        if yearMatches[i] != "" </span><span class="cov0" title="0">{
                                if y := parseInt(yearMatches[i]); y &gt; 1900 &amp;&amp; y &lt;= time.Now().Year()+5 </span><span class="cov0" title="0">{
                                        year = &amp;y
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        // Clean title
        <span class="cov0" title="0">title := dirName

        // Remove year from title
        if year != nil </span><span class="cov0" title="0">{
                title = yearRegex.ReplaceAllString(title, "")
        }</span>

        // Remove common release info
        <span class="cov0" title="0">cleanupRegex := regexp.MustCompile(`(?i)\b(bluray|brrip|dvdrip|webrip|hdtv|720p|1080p|4k|x264|x265|h264|h265|aac|dts|ac3|complete|season|series)\b`)
        title = cleanupRegex.ReplaceAllString(title, "")

        // Clean up extra spaces and dots
        title = regexp.MustCompile(`[._\-\s]+`).ReplaceAllString(title, " ")
        title = strings.TrimSpace(title)

        return title, year</span>
}

// extractQualityHints extracts quality indicators from filenames
func (e *DetectionEngine) extractQualityHints(dirPath string, files []FileInfo) []string <span class="cov0" title="0">{
        hints := make([]string, 0)
        text := strings.ToLower(dirPath)

        // Add file names to analysis
        for _, file := range files </span><span class="cov0" title="0">{
                text += " " + strings.ToLower(file.Name)
        }</span>

        <span class="cov0" title="0">qualityPatterns := map[string][]string{
                "4K":       {"4k", "uhd", "2160p"},
                "1080p":    {"1080p", "fullhd", "fhd"},
                "720p":     {"720p", "hd"},
                "BluRay":   {"bluray", "brrip", "bd"},
                "WEB-DL":   {"webdl", "web-dl", "webrip"},
                "HDR":      {"hdr", "hdr10", "dolby.vision"},
                "Lossless": {"flac", "lossless", "dts-hd"},
                "Remux":    {"remux"},
        }

        for quality, patterns := range qualityPatterns </span><span class="cov0" title="0">{
                for _, pattern := range patterns </span><span class="cov0" title="0">{
                        if strings.Contains(text, pattern) </span><span class="cov0" title="0">{
                                hints = append(hints, quality)
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return hints</span>
}

// buildAnalysisData creates detailed analysis information
func (e *DetectionEngine) buildAnalysisData(dirPath string, files []FileInfo, patterns []string, confidence float64) *models.AnalysisData <span class="cov0" title="0">{
        fileTypes := make(map[string]int)
        sizeDistribution := make(map[string]int64)

        for _, file := range files </span><span class="cov0" title="0">{
                if file.Extension != "" </span><span class="cov0" title="0">{
                        fileTypes[file.Extension]++
                }</span>

                // Categorize by size
                <span class="cov0" title="0">var sizeCategory string
                switch </span>{
                case file.Size &gt; 10*1024*1024*1024:<span class="cov0" title="0"> // &gt; 10GB
                        sizeCategory = "very_large"</span>
                case file.Size &gt; 1024*1024*1024:<span class="cov0" title="0"> // &gt; 1GB
                        sizeCategory = "large"</span>
                case file.Size &gt; 100*1024*1024:<span class="cov0" title="0"> // &gt; 100MB
                        sizeCategory = "medium"</span>
                case file.Size &gt; 10*1024*1024:<span class="cov0" title="0"> // &gt; 10MB
                        sizeCategory = "small"</span>
                default:<span class="cov0" title="0">
                        sizeCategory = "tiny"</span>
                }
                <span class="cov0" title="0">sizeDistribution[sizeCategory] += file.Size</span>
        }

        <span class="cov0" title="0">return &amp;models.AnalysisData{
                MatchedPatterns:   patterns,
                FileTypes:         fileTypes,
                SizeDistribution:  sizeDistribution,
                QualityIndicators: e.extractQualityHints(dirPath, files),
                FilenameScore:     confidence * 0.4,
                StructureScore:    confidence * 0.3,
                MetadataScore:     confidence * 0.3,
        }</span>
}

// Helper functions
func (e *DetectionEngine) globToRegex(glob string) (*regexp.Regexp, error) <span class="cov0" title="0">{
        // Convert glob pattern to regex
        pattern := strings.ReplaceAll(glob, "*", ".*")
        pattern = strings.ReplaceAll(pattern, "?", ".")
        pattern = "^" + pattern + "$"
        return regexp.Compile("(?i)" + pattern)
}</span>

func parseInt(s string) int <span class="cov0" title="0">{
        var result int
        for _, char := range s </span><span class="cov0" title="0">{
                if char &gt;= '0' &amp;&amp; char &lt;= '9' </span><span class="cov0" title="0">{
                        result = result*10 + int(char-'0')
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// GetSupportedMediaTypes returns all supported media types
func (e *DetectionEngine) GetSupportedMediaTypes() []models.MediaType <span class="cov0" title="0">{
        types := make([]models.MediaType, 0, len(e.mediaTypes))
        for _, mt := range e.mediaTypes </span><span class="cov0" title="0">{
                types = append(types, *mt)
        }</span>
        <span class="cov0" title="0">return types</span>
}

// ValidateDetection validates a detection result
func (e *DetectionEngine) ValidateDetection(result *DetectionResult) bool <span class="cov0" title="0">{
        if result == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Minimum confidence threshold
        <span class="cov0" title="0">if result.Confidence &lt; 0.1 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Must have at least one matched pattern
        <span class="cov0" title="0">if len(result.MatchedPatterns) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package media

import (
        "catalogizer/internal/config"
        "catalogizer/internal/media/analyzer"
        "catalogizer/internal/media/database"
        "catalogizer/internal/media/detector"
        "catalogizer/internal/media/models"
        "catalogizer/internal/media/providers"
        "catalogizer/internal/media/realtime"
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "path/filepath"
        "time"

        "go.uber.org/zap"
)

// MediaManager orchestrates all media-related functionality
type MediaManager struct {
        config          *config.Config
        logger          *zap.Logger
        mediaDB         *database.MediaDatabase
        detector        *detector.DetectionEngine
        providerManager *providers.ProviderManager
        analyzer        *analyzer.MediaAnalyzer
        changeWatcher   *realtime.SMBChangeWatcher
        started         bool
}

// MediaConfig represents media-specific configuration
type MediaConfig struct {
        DatabasePath     string            `json:"database_path"`
        DatabasePassword string            `json:"database_password"`
        APIKeys          map[string]string `json:"api_keys"`
        WatchPaths       []WatchPath       `json:"watch_paths"`
        AnalysisWorkers  int               `json:"analysis_workers"`
        EnableRealtime   bool              `json:"enable_realtime"`
}

// WatchPath represents a path to monitor for changes
type WatchPath struct {
        SmbRoot   string `json:"smb_root"`
        LocalPath string `json:"local_path"`
        Enabled   bool   `json:"enabled"`
}

// NewMediaManager creates a new media manager
func NewMediaManager(cfg *config.Config, logger *zap.Logger) (*MediaManager, error) <span class="cov0" title="0">{
        // Initialize encrypted database
        dbConfig := database.DatabaseConfig{
                Path:     "media_catalog.db",
                Password: "secure_password_123", // This should come from config
        }

        mediaDB, err := database.NewMediaDatabase(dbConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize media database: %w", err)
        }</span>

        // Initialize detection engine
        <span class="cov0" title="0">detectionEngine := detector.NewDetectionEngine(logger)

        // Load detection rules and media types from database
        if err := loadDetectionRules(mediaDB, detectionEngine); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to load detection rules", zap.Error(err))
        }</span>

        // Initialize provider manager
        <span class="cov0" title="0">providerManager := providers.NewProviderManager(logger)

        // Initialize analyzer
        mediaAnalyzer := analyzer.NewMediaAnalyzer(mediaDB.GetDB(), detectionEngine, providerManager, logger)

        // Initialize change watcher
        changeWatcher := realtime.NewSMBChangeWatcher(mediaDB, mediaAnalyzer, logger)

        mm := &amp;MediaManager{
                config:          cfg,
                logger:          logger,
                mediaDB:         mediaDB,
                detector:        detectionEngine,
                providerManager: providerManager,
                analyzer:        mediaAnalyzer,
                changeWatcher:   changeWatcher,
        }

        return mm, nil</span>
}

// Start starts all media services
func (mm *MediaManager) Start() error <span class="cov0" title="0">{
        if mm.started </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">mm.logger.Info("Starting Media Manager")

        // Start analyzer
        mm.analyzer.Start()

        // Start change watcher
        if err := mm.changeWatcher.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start change watcher: %w", err)
        }</span>

        // Add watch paths (this would normally come from config)
        <span class="cov0" title="0">watchPaths := []WatchPath{
                {SmbRoot: "nas1", LocalPath: "/mnt/smb/nas1", Enabled: true},
                {SmbRoot: "nas2", LocalPath: "/mnt/smb/nas2", Enabled: true},
        }

        for _, path := range watchPaths </span><span class="cov0" title="0">{
                if path.Enabled </span><span class="cov0" title="0">{
                        if err := mm.changeWatcher.WatchSMBPath(path.SmbRoot, path.LocalPath); err != nil </span><span class="cov0" title="0">{
                                mm.logger.Error("Failed to watch SMB path",
                                        zap.String("smb_root", path.SmbRoot),
                                        zap.String("local_path", path.LocalPath),
                                        zap.Error(err))
                        }</span>
                }
        }

        <span class="cov0" title="0">mm.started = true
        mm.logger.Info("Media Manager started successfully")

        return nil</span>
}

// Stop stops all media services
func (mm *MediaManager) Stop() <span class="cov0" title="0">{
        if !mm.started </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">mm.logger.Info("Stopping Media Manager")

        // Stop services in reverse order
        mm.changeWatcher.Stop()
        mm.analyzer.Stop()

        // Close database
        if err := mm.mediaDB.Close(); err != nil </span><span class="cov0" title="0">{
                mm.logger.Error("Failed to close media database", zap.Error(err))
        }</span>

        <span class="cov0" title="0">mm.started = false
        mm.logger.Info("Media Manager stopped")</span>
}

// GetDatabase returns the media database
func (mm *MediaManager) GetDatabase() *database.MediaDatabase <span class="cov0" title="0">{
        return mm.mediaDB
}</span>

// GetAnalyzer returns the media analyzer
func (mm *MediaManager) GetAnalyzer() *analyzer.MediaAnalyzer <span class="cov0" title="0">{
        return mm.analyzer
}</span>

// GetChangeWatcher returns the change watcher
func (mm *MediaManager) GetChangeWatcher() *realtime.SMBChangeWatcher <span class="cov0" title="0">{
        return mm.changeWatcher
}</span>

// AnalyzeAllDirectories triggers analysis of all directories in the catalog
func (mm *MediaManager) AnalyzeAllDirectories(ctx context.Context) error <span class="cov0" title="0">{
        mm.logger.Info("Starting full directory analysis")

        // Get all unique directory paths from the catalog
        query := `
                SELECT DISTINCT
                        CASE
                                WHEN is_directory = 1 THEN path
                                ELSE substr(path, 1, length(path) - length(name) - 1)
                        END as directory_path,
                        smb_root
                FROM files
                WHERE directory_path != ''
                ORDER BY smb_root, directory_path
        `

        rows, err := mm.mediaDB.GetDB().Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get directories: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var directories []struct {
                Path    string
                SmbRoot string
        }

        for rows.Next() </span><span class="cov0" title="0">{
                var dir struct {
                        Path    string
                        SmbRoot string
                }
                if err := rows.Scan(&amp;dir.Path, &amp;dir.SmbRoot); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">directories = append(directories, dir)</span>
        }

        <span class="cov0" title="0">mm.logger.Info("Found directories to analyze", zap.Int("count", len(directories)))

        // Queue all directories for analysis
        for i, dir := range directories </span><span class="cov0" title="0">{
                priority := 10 - (i / 100) // Decrease priority for later items
                if priority &lt; 1 </span><span class="cov0" title="0">{
                        priority = 1
                }</span>

                <span class="cov0" title="0">if err := mm.analyzer.AnalyzeDirectory(ctx, dir.Path, dir.SmbRoot, priority); err != nil </span><span class="cov0" title="0">{
                        mm.logger.Error("Failed to queue directory analysis",
                                zap.String("path", dir.Path),
                                zap.String("smb_root", dir.SmbRoot),
                                zap.Error(err))
                }</span>

                // Check for context cancellation
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }
        }

        <span class="cov0" title="0">mm.logger.Info("All directories queued for analysis")
        return nil</span>
}

// RefreshExternalMetadata refreshes metadata for all media items
func (mm *MediaManager) RefreshExternalMetadata(ctx context.Context, olderThan time.Duration) error <span class="cov0" title="0">{
        mm.logger.Info("Refreshing external metadata", zap.Duration("older_than", olderThan))

        cutoff := time.Now().Add(-olderThan)

        query := `
                SELECT mi.id, mi.title, mi.year, mt.name as media_type
                FROM media_items mi
                JOIN media_types mt ON mi.media_type_id = mt.id
                WHERE mi.id NOT IN (
                        SELECT media_item_id FROM external_metadata
                        WHERE last_fetched &gt; ?
                )
                OR mi.id IN (
                        SELECT media_item_id FROM external_metadata
                        WHERE last_fetched &lt; ?
                )
                ORDER BY mi.last_updated DESC
                LIMIT 100
        `

        rows, err := mm.mediaDB.GetDB().Query(query, cutoff, cutoff)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get media items for metadata refresh: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var mediaItems []struct {
                ID        int64
                Title     string
                Year      *int
                MediaType string
        }

        for rows.Next() </span><span class="cov0" title="0">{
                var item struct {
                        ID        int64
                        Title     string
                        Year      *int
                        MediaType string
                }
                if err := rows.Scan(&amp;item.ID, &amp;item.Title, &amp;item.Year, &amp;item.MediaType); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">mediaItems = append(mediaItems, item)</span>
        }

        <span class="cov0" title="0">mm.logger.Info("Found media items for metadata refresh", zap.Int("count", len(mediaItems)))

        // Refresh metadata for each item
        for _, item := range mediaItems </span><span class="cov0" title="0">{
                // Get best match from providers
                bestResult, providerName, err := mm.providerManager.GetBestMatch(
                        ctx, item.Title, item.MediaType, item.Year,
                )
                if err != nil || bestResult == nil </span><span class="cov0" title="0">{
                        mm.logger.Debug("No metadata found",
                                zap.String("title", item.Title),
                                zap.String("media_type", item.MediaType))
                        continue</span>
                }

                // Get detailed metadata
                <span class="cov0" title="0">metadata, err := mm.providerManager.GetDetails(ctx, providerName, bestResult.ExternalID)
                if err != nil </span><span class="cov0" title="0">{
                        mm.logger.Error("Failed to get metadata details",
                                zap.String("title", item.Title),
                                zap.String("provider", providerName),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">metadata.MediaItemID = item.ID

                // Save to database
                saveQuery := `
                        INSERT OR REPLACE INTO external_metadata
                        (media_item_id, provider, external_id, data, rating, review_url, cover_url, trailer_url, last_fetched)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                `

                _, err = mm.mediaDB.GetDB().Exec(saveQuery,
                        metadata.MediaItemID, metadata.Provider, metadata.ExternalID, metadata.Data,
                        metadata.Rating, metadata.ReviewURL, metadata.CoverURL, metadata.TrailerURL, metadata.LastFetched,
                )
                if err != nil </span><span class="cov0" title="0">{
                        mm.logger.Error("Failed to save metadata",
                                zap.String("title", item.Title),
                                zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        mm.logger.Debug("Metadata refreshed",
                                zap.String("title", item.Title),
                                zap.String("provider", providerName))
                }</span>

                // Check for context cancellation
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                // Rate limiting - don't overwhelm APIs
                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">mm.logger.Info("External metadata refresh completed")
        return nil</span>
}

// GetStatistics returns comprehensive media statistics
func (mm *MediaManager) GetStatistics() (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Database statistics
        dbStats, err := mm.mediaDB.GetStats()
        if err != nil </span><span class="cov0" title="0">{
                mm.logger.Error("Failed to get database stats", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["database"] = dbStats
        }</span>

        // Change statistics (last 24 hours)
        <span class="cov0" title="0">since := time.Now().Add(-24 * time.Hour)
        changeStats, err := mm.changeWatcher.GetChangeStatistics(since)
        if err != nil </span><span class="cov0" title="0">{
                mm.logger.Error("Failed to get change stats", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["changes_24h"] = changeStats
        }</span>

        // Media type distribution
        <span class="cov0" title="0">typeDistribution, err := mm.getMediaTypeDistribution()
        if err != nil </span><span class="cov0" title="0">{
                mm.logger.Error("Failed to get media type distribution", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["media_types"] = typeDistribution
        }</span>

        // Quality distribution
        <span class="cov0" title="0">qualityDistribution, err := mm.getQualityDistribution()
        if err != nil </span><span class="cov0" title="0">{
                mm.logger.Error("Failed to get quality distribution", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["quality"] = qualityDistribution
        }</span>

        // External metadata coverage
        <span class="cov0" title="0">metadataCoverage, err := mm.getMetadataCoverage()
        if err != nil </span><span class="cov0" title="0">{
                mm.logger.Error("Failed to get metadata coverage", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                stats["metadata_coverage"] = metadataCoverage
        }</span>

        <span class="cov0" title="0">stats["timestamp"] = time.Now()
        stats["uptime"] = mm.started

        return stats, nil</span>
}

// Helper methods

func loadDetectionRules(mediaDB *database.MediaDatabase, engine *detector.DetectionEngine) error <span class="cov0" title="0">{
        // Load media types
        mediaTypesQuery := `
                SELECT id, name, description, detection_patterns, metadata_providers, created_at, updated_at
                FROM media_types
                ORDER BY id
        `

        rows, err := mediaDB.GetDB().Query(mediaTypesQuery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var mediaTypes []models.MediaType
        for rows.Next() </span><span class="cov0" title="0">{
                var mt models.MediaType
                var patternsJSON, providersJSON string

                err := rows.Scan(&amp;mt.ID, &amp;mt.Name, &amp;mt.Description, &amp;patternsJSON, &amp;providersJSON, &amp;mt.CreatedAt, &amp;mt.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse JSON (simplified - would use proper JSON parsing)
                <span class="cov0" title="0">mt.DetectionPatterns = []string{patternsJSON}
                mt.MetadataProviders = []string{providersJSON}

                mediaTypes = append(mediaTypes, mt)</span>
        }

        // Load detection rules
        <span class="cov0" title="0">rulesQuery := `
                SELECT id, media_type_id, rule_name, rule_type, pattern, confidence_weight, enabled, priority, created_at
                FROM detection_rules
                WHERE enabled = true
                ORDER BY priority DESC
        `

        ruleRows, err := mediaDB.GetDB().Query(rulesQuery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer ruleRows.Close()

        var rules []models.DetectionRule
        for ruleRows.Next() </span><span class="cov0" title="0">{
                var rule models.DetectionRule
                err := ruleRows.Scan(
                        &amp;rule.ID, &amp;rule.MediaTypeID, &amp;rule.RuleName, &amp;rule.RuleType,
                        &amp;rule.Pattern, &amp;rule.ConfidenceWeight, &amp;rule.Enabled, &amp;rule.Priority, &amp;rule.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">rules = append(rules, rule)</span>
        }

        // Load rules into engine
        <span class="cov0" title="0">engine.LoadRules(rules, mediaTypes)

        return nil</span>
}

func (mm *MediaManager) getMediaTypeDistribution() (map[string]int, error) <span class="cov0" title="0">{
        query := `
                SELECT mt.name, COUNT(mi.id) as count
                FROM media_types mt
                LEFT JOIN media_items mi ON mt.id = mi.media_type_id
                GROUP BY mt.id, mt.name
                ORDER BY count DESC
        `

        rows, err := mm.mediaDB.GetDB().Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        distribution := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var mediaType string
                var count int
                if err := rows.Scan(&amp;mediaType, &amp;count); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">distribution[mediaType] = count</span>
        }

        <span class="cov0" title="0">return distribution, nil</span>
}

func (mm *MediaManager) getQualityDistribution() (map[string]int, error) <span class="cov0" title="0">{
        // This would analyze quality_info JSON fields in media_files
        // Simplified implementation for now
        return map[string]int{
                "4K/UHD": 0,
                "1080p":  0,
                "720p":   0,
                "DVD":    0,
                "Other":  0,
        }, nil
}</span>

func (mm *MediaManager) getMetadataCoverage() (map[string]interface{}, error) <span class="cov0" title="0">{
        coverage := make(map[string]interface{})

        // Total media items
        var totalItems int
        err := mm.mediaDB.GetDB().QueryRow("SELECT COUNT(*) FROM media_items").Scan(&amp;totalItems)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">coverage["total_items"] = totalItems

        // Items with external metadata
        var itemsWithMetadata int
        err = mm.mediaDB.GetDB().QueryRow(
                "SELECT COUNT(DISTINCT media_item_id) FROM external_metadata",
        ).Scan(&amp;itemsWithMetadata)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">coverage["items_with_metadata"] = itemsWithMetadata

        // Coverage percentage
        if totalItems &gt; 0 </span><span class="cov0" title="0">{
                coverage["coverage_percentage"] = float64(itemsWithMetadata) / float64(totalItems) * 100
        }</span> else<span class="cov0" title="0"> {
                coverage["coverage_percentage"] = 0.0
        }</span>

        // Coverage by provider
        <span class="cov0" title="0">providerQuery := `
                SELECT provider, COUNT(*) as count
                FROM external_metadata
                GROUP BY provider
                ORDER BY count DESC
        `

        rows, err := mm.mediaDB.GetDB().Query(providerQuery)
        if err != nil </span><span class="cov0" title="0">{
                return coverage, nil // Return partial results
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        providerCoverage := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var provider string
                var count int
                if err := rows.Scan(&amp;provider, &amp;count); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">providerCoverage[provider] = count</span>
        }
        <span class="cov0" title="0">coverage["by_provider"] = providerCoverage

        return coverage, nil</span>
}

// ExportData exports media data for backup or migration
func (mm *MediaManager) ExportData(exportPath string) error <span class="cov0" title="0">{
        mm.logger.Info("Exporting media data", zap.String("path", exportPath))

        // Create backup of the encrypted database
        backupPath := filepath.Join(exportPath, fmt.Sprintf("media_backup_%d.db", time.Now().Unix()))
        if err := mm.mediaDB.Backup(backupPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to backup database: %w", err)
        }</span>

        // Export statistics
        <span class="cov0" title="0">stats, err := mm.GetStatistics()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get statistics: %w", err)
        }</span>

        <span class="cov0" title="0">statsPath := filepath.Join(exportPath, "media_stats.json")
        statsJSON, _ := json.Marshal(stats)
        if err := ioutil.WriteFile(statsPath, statsJSON, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to export statistics: %w", err)
        }</span>

        <span class="cov0" title="0">mm.logger.Info("Media data exported successfully",
                zap.String("backup_path", backupPath),
                zap.String("stats_path", statsPath))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package models

import (
        "encoding/json"
        "time"
)

// MediaType represents different types of media content
type MediaType struct {
        ID                int64     `json:"id" db:"id"`
        Name              string    `json:"name" db:"name"`
        Description       string    `json:"description" db:"description"`
        DetectionPatterns []string  `json:"detection_patterns" db:"detection_patterns"`
        MetadataProviders []string  `json:"metadata_providers" db:"metadata_providers"`
        CreatedAt         time.Time `json:"created_at" db:"created_at"`
        UpdatedAt         time.Time `json:"updated_at" db:"updated_at"`
}

// MediaItem represents a detected media item with aggregated metadata
type MediaItem struct {
        ID            int64      `json:"id" db:"id"`
        MediaTypeID   int64      `json:"media_type_id" db:"media_type_id"`
        MediaType     *MediaType `json:"media_type,omitempty"`
        Title         string     `json:"title" db:"title"`
        OriginalTitle *string    `json:"original_title,omitempty" db:"original_title"`
        Year          *int       `json:"year,omitempty" db:"year"`
        Description   *string    `json:"description,omitempty" db:"description"`
        Genre         []string   `json:"genre,omitempty" db:"genre"`
        Director      *string    `json:"director,omitempty" db:"director"`
        CastCrew      *CastCrew  `json:"cast_crew,omitempty" db:"cast_crew"`
        Rating        *float64   `json:"rating,omitempty" db:"rating"`
        Runtime       *int       `json:"runtime,omitempty" db:"runtime"`
        Language      *string    `json:"language,omitempty" db:"language"`
        Country       *string    `json:"country,omitempty" db:"country"`
        Status        string     `json:"status" db:"status"`
        FirstDetected time.Time  `json:"first_detected" db:"first_detected"`
        LastUpdated   time.Time  `json:"last_updated" db:"last_updated"`

        // Aggregated data
        ExternalMetadata []ExternalMetadata `json:"external_metadata,omitempty"`
        Files            []MediaFile        `json:"files,omitempty"`
        Collections      []MediaCollection  `json:"collections,omitempty"`
        UserMetadata     *UserMetadata      `json:"user_metadata,omitempty"`
}

// CastCrew represents cast and crew information
type CastCrew struct {
        Director   *string  `json:"director,omitempty"`
        Writers    []string `json:"writers,omitempty"`
        Actors     []Actor  `json:"actors,omitempty"`
        Producers  []string `json:"producers,omitempty"`
        Musicians  []string `json:"musicians,omitempty"`
        Developers []string `json:"developers,omitempty"`
}

// Actor represents an actor with their character
type Actor struct {
        Name      string `json:"name"`
        Character string `json:"character,omitempty"`
        Order     int    `json:"order,omitempty"`
}

// ExternalMetadata represents metadata from external sources
type ExternalMetadata struct {
        ID          int64     `json:"id" db:"id"`
        MediaItemID int64     `json:"media_item_id" db:"media_item_id"`
        Provider    string    `json:"provider" db:"provider"`
        ExternalID  string    `json:"external_id" db:"external_id"`
        Data        string    `json:"data" db:"data"`
        Rating      *float64  `json:"rating,omitempty" db:"rating"`
        ReviewURL   *string   `json:"review_url,omitempty" db:"review_url"`
        CoverURL    *string   `json:"cover_url,omitempty" db:"cover_url"`
        TrailerURL  *string   `json:"trailer_url,omitempty" db:"trailer_url"`
        LastFetched time.Time `json:"last_fetched" db:"last_fetched"`
}

// DirectoryAnalysis represents analysis of a directory's content
type DirectoryAnalysis struct {
        ID              int64         `json:"id" db:"id"`
        DirectoryPath   string        `json:"directory_path" db:"directory_path"`
        SmbRoot         string        `json:"smb_root" db:"smb_root"`
        MediaItemID     *int64        `json:"media_item_id,omitempty" db:"media_item_id"`
        MediaItem       *MediaItem    `json:"media_item,omitempty"`
        ConfidenceScore float64       `json:"confidence_score" db:"confidence_score"`
        DetectionMethod string        `json:"detection_method" db:"detection_method"`
        AnalysisData    *AnalysisData `json:"analysis_data,omitempty" db:"analysis_data"`
        LastAnalyzed    time.Time     `json:"last_analyzed" db:"last_analyzed"`
        FilesCount      int           `json:"files_count" db:"files_count"`
        TotalSize       int64         `json:"total_size" db:"total_size"`
}

// AnalysisData contains detailed analysis information
type AnalysisData struct {
        MatchedPatterns   []string         `json:"matched_patterns"`
        FileTypes         map[string]int   `json:"file_types"`
        SizeDistribution  map[string]int64 `json:"size_distribution"`
        DetectedLanguages []string         `json:"detected_languages"`
        QualityIndicators []string         `json:"quality_indicators"`
        StructureScore    float64          `json:"structure_score"`
        FilenameScore     float64          `json:"filename_score"`
        MetadataScore     float64          `json:"metadata_score"`
        AlternativeTitles []string         `json:"alternative_titles"`
}

// MediaFile represents individual file versions
type MediaFile struct {
        ID             int64           `json:"id" db:"id"`
        MediaItemID    int64           `json:"media_item_id" db:"media_item_id"`
        FilePath       string          `json:"file_path" db:"file_path"`
        SmbRoot        string          `json:"smb_root" db:"smb_root"`
        Filename       string          `json:"filename" db:"filename"`
        FileSize       int64           `json:"file_size" db:"file_size"`
        FileExtension  *string         `json:"file_extension,omitempty" db:"file_extension"`
        QualityInfo    *QualityInfo    `json:"quality_info,omitempty" db:"quality_info"`
        Language       *string         `json:"language,omitempty" db:"language"`
        SubtitleTracks []SubtitleTrack `json:"subtitle_tracks,omitempty" db:"subtitle_tracks"`
        AudioTracks    []AudioTrack    `json:"audio_tracks,omitempty" db:"audio_tracks"`
        Duration       *int            `json:"duration,omitempty" db:"duration"`
        Checksum       *string         `json:"checksum,omitempty" db:"checksum"`
        VirtualSmbLink *string         `json:"virtual_smb_link,omitempty" db:"virtual_smb_link"`
        DirectSmbLink  string          `json:"direct_smb_link" db:"direct_smb_link"`
        LastVerified   time.Time       `json:"last_verified" db:"last_verified"`
        CreatedAt      time.Time       `json:"created_at" db:"created_at"`
}

// QualityInfo represents file quality information
type QualityInfo struct {
        Resolution     *Resolution `json:"resolution,omitempty"`
        Bitrate        *int        `json:"bitrate,omitempty"`
        VideoCodec     *string     `json:"video_codec,omitempty"`
        AudioCodec     *string     `json:"audio_codec,omitempty"`
        FrameRate      *float64    `json:"frame_rate,omitempty"`
        AspectRatio    *string     `json:"aspect_ratio,omitempty"`
        ColorDepth     *int        `json:"color_depth,omitempty"`
        HDR            bool        `json:"hdr,omitempty"`
        QualityProfile *string     `json:"quality_profile,omitempty"`
        Source         *string     `json:"source,omitempty"` // BluRay, DVD, WEB-DL, etc.
        QualityScore   int         `json:"quality_score"`
}

// Resolution represents video resolution
type Resolution struct {
        Width  int `json:"width"`
        Height int `json:"height"`
}

// SubtitleTrack represents subtitle information
type SubtitleTrack struct {
        Language string `json:"language"`
        Format   string `json:"format"`
        Forced   bool   `json:"forced,omitempty"`
        Default  bool   `json:"default,omitempty"`
}

// AudioTrack represents audio track information
type AudioTrack struct {
        Language   string `json:"language"`
        Codec      string `json:"codec"`
        Channels   string `json:"channels"`
        Bitrate    *int   `json:"bitrate,omitempty"`
        SampleRate *int   `json:"sample_rate,omitempty"`
        Default    bool   `json:"default,omitempty"`
        Commentary bool   `json:"commentary,omitempty"`
}

// QualityProfile represents quality comparison profiles
type QualityProfile struct {
        ID               int64     `json:"id" db:"id"`
        Name             string    `json:"name" db:"name"`
        ResolutionWidth  *int      `json:"resolution_width,omitempty" db:"resolution_width"`
        ResolutionHeight *int      `json:"resolution_height,omitempty" db:"resolution_height"`
        MinBitrate       *int      `json:"min_bitrate,omitempty" db:"min_bitrate"`
        MaxBitrate       *int      `json:"max_bitrate,omitempty" db:"max_bitrate"`
        PreferredCodecs  []string  `json:"preferred_codecs,omitempty" db:"preferred_codecs"`
        QualityScore     int       `json:"quality_score" db:"quality_score"`
        CreatedAt        time.Time `json:"created_at" db:"created_at"`
}

// MediaCollection represents collections of related media
type MediaCollection struct {
        ID             int64                 `json:"id" db:"id"`
        Name           string                `json:"name" db:"name"`
        CollectionType string                `json:"collection_type" db:"collection_type"`
        Description    *string               `json:"description,omitempty" db:"description"`
        TotalItems     int                   `json:"total_items" db:"total_items"`
        ExternalIDs    map[string]string     `json:"external_ids,omitempty" db:"external_ids"`
        CoverURL       *string               `json:"cover_url,omitempty" db:"cover_url"`
        CreatedAt      time.Time             `json:"created_at" db:"created_at"`
        UpdatedAt      time.Time             `json:"updated_at" db:"updated_at"`
        Items          []MediaCollectionItem `json:"items,omitempty"`
}

// MediaCollectionItem represents an item within a collection
type MediaCollectionItem struct {
        ID             int64      `json:"id" db:"id"`
        CollectionID   int64      `json:"collection_id" db:"collection_id"`
        MediaItemID    int64      `json:"media_item_id" db:"media_item_id"`
        MediaItem      *MediaItem `json:"media_item,omitempty"`
        SequenceNumber *int       `json:"sequence_number,omitempty" db:"sequence_number"`
        SeasonNumber   *int       `json:"season_number,omitempty" db:"season_number"`
        ReleaseOrder   *int       `json:"release_order,omitempty" db:"release_order"`
}

// UserMetadata represents user-specific metadata
type UserMetadata struct {
        ID            int64      `json:"id" db:"id"`
        MediaItemID   int64      `json:"media_item_id" db:"media_item_id"`
        UserRating    *float64   `json:"user_rating,omitempty" db:"user_rating"`
        WatchedStatus *string    `json:"watched_status,omitempty" db:"watched_status"`
        WatchedDate   *time.Time `json:"watched_date,omitempty" db:"watched_date"`
        PersonalNotes *string    `json:"personal_notes,omitempty" db:"personal_notes"`
        Tags          []string   `json:"tags,omitempty" db:"tags"`
        Favorite      bool       `json:"favorite" db:"favorite"`
        CreatedAt     time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt     time.Time  `json:"updated_at" db:"updated_at"`
}

// DetectionRule represents rules for media detection
type DetectionRule struct {
        ID               int64     `json:"id" db:"id"`
        MediaTypeID      int64     `json:"media_type_id" db:"media_type_id"`
        RuleName         string    `json:"rule_name" db:"rule_name"`
        RuleType         string    `json:"rule_type" db:"rule_type"`
        Pattern          string    `json:"pattern" db:"pattern"`
        ConfidenceWeight float64   `json:"confidence_weight" db:"confidence_weight"`
        Enabled          bool      `json:"enabled" db:"enabled"`
        Priority         int       `json:"priority" db:"priority"`
        CreatedAt        time.Time `json:"created_at" db:"created_at"`
}

// ChangeLog represents tracked changes for real-time updates
type ChangeLog struct {
        ID         int64     `json:"id" db:"id"`
        EntityType string    `json:"entity_type" db:"entity_type"`
        EntityID   string    `json:"entity_id" db:"entity_id"`
        ChangeType string    `json:"change_type" db:"change_type"`
        OldData    *string   `json:"old_data,omitempty" db:"old_data"`
        NewData    *string   `json:"new_data,omitempty" db:"new_data"`
        DetectedAt time.Time `json:"detected_at" db:"detected_at"`
        Processed  bool      `json:"processed" db:"processed"`
}

// MediaSearchRequest represents search parameters for media
type MediaSearchRequest struct {
        Query         string     `json:"query" form:"query"`
        MediaTypes    []string   `json:"media_types" form:"media_types"`
        Year          *int       `json:"year" form:"year"`
        YearRange     *YearRange `json:"year_range"`
        Genre         []string   `json:"genre" form:"genre"`
        Quality       []string   `json:"quality" form:"quality"`
        Language      []string   `json:"language" form:"language"`
        MinRating     *float64   `json:"min_rating" form:"min_rating"`
        HasExternals  *bool      `json:"has_externals" form:"has_externals"`
        SmbRoots      []string   `json:"smb_roots" form:"smb_roots"`
        WatchedStatus *string    `json:"watched_status" form:"watched_status"`
        SortBy        string     `json:"sort_by" form:"sort_by"`
        SortOrder     string     `json:"sort_order" form:"sort_order"`
        Limit         int        `json:"limit" form:"limit"`
        Offset        int        `json:"offset" form:"offset"`
}

// YearRange represents a range of years
type YearRange struct {
        From int `json:"from"`
        To   int `json:"to"`
}

// MediaOverview represents aggregated media statistics
type MediaOverview struct {
        ID                 int64      `json:"id" db:"id"`
        Title              string     `json:"title" db:"title"`
        Year               *int       `json:"year" db:"year"`
        MediaType          string     `json:"media_type" db:"media_type"`
        FileCount          int        `json:"file_count" db:"file_count"`
        TotalSize          int64      `json:"total_size" db:"total_size"`
        LastVerified       *time.Time `json:"last_verified" db:"last_verified"`
        AvailableQualities []string   `json:"available_qualities" db:"available_qualities"`
}

// Custom JSON marshaling for database storage
func (mt *MediaType) MarshalDetectionPatterns() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(mt.DetectionPatterns)
}</span>

func (mt *MediaType) UnmarshalDetectionPatterns(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, &amp;mt.DetectionPatterns)
}</span>

func (mi *MediaItem) MarshalGenre() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(mi.Genre)
}</span>

func (mi *MediaItem) UnmarshalGenre(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, &amp;mi.Genre)
}</span>

func (mi *MediaItem) MarshalCastCrew() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(mi.CastCrew)
}</span>

func (mi *MediaItem) UnmarshalCastCrew(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, &amp;mi.CastCrew)
}</span>

// Helper methods for quality comparison
func (qi *QualityInfo) IsBetterThan(other *QualityInfo) bool <span class="cov0" title="0">{
        if qi == nil || other == nil </span><span class="cov0" title="0">{
                return qi != nil
        }</span>
        <span class="cov0" title="0">return qi.QualityScore &gt; other.QualityScore</span>
}

func (qi *QualityInfo) GetDisplayName() string <span class="cov0" title="0">{
        if qi.QualityProfile != nil </span><span class="cov0" title="0">{
                return *qi.QualityProfile
        }</span>
        <span class="cov0" title="0">if qi.Resolution != nil </span><span class="cov0" title="0">{
                return qi.Resolution.GetDisplayName()
        }</span>
        <span class="cov0" title="0">return "Unknown"</span>
}

func (r *Resolution) GetDisplayName() string <span class="cov0" title="0">{
        switch </span>{
        case r.Width &gt;= 3840:<span class="cov0" title="0">
                return "4K/UHD"</span>
        case r.Width &gt;= 1920:<span class="cov0" title="0">
                return "1080p"</span>
        case r.Width &gt;= 1280:<span class="cov0" title="0">
                return "720p"</span>
        case r.Width &gt;= 720:<span class="cov0" title="0">
                return "480p/DVD"</span>
        default:<span class="cov0" title="0">
                return "Low Quality"</span>
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package providers

import (
        "catalogizer/internal/media/models"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "time"

        "go.uber.org/zap"
)

// MetadataProvider interface for external metadata sources
type MetadataProvider interface {
        GetName() string
        Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error)
        GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error)
        IsEnabled() bool
}

// SearchResult represents search results from providers
type SearchResult struct {
        ExternalID  string   `json:"external_id"`
        Title       string   `json:"title"`
        Year        *int     `json:"year,omitempty"`
        Rating      *float64 `json:"rating,omitempty"`
        Description *string  `json:"description,omitempty"`
        CoverURL    *string  `json:"cover_url,omitempty"`
        Relevance   float64  `json:"relevance"`
}

// ProviderManager manages all metadata providers
type ProviderManager struct {
        providers map[string]MetadataProvider
        logger    *zap.Logger
        client    *http.Client
}

// NewProviderManager creates a new provider manager
func NewProviderManager(logger *zap.Logger) *ProviderManager <span class="cov0" title="0">{
        client := &amp;http.Client{
                Timeout: 30 * time.Second,
        }

        pm := &amp;ProviderManager{
                providers: make(map[string]MetadataProvider),
                logger:    logger,
                client:    client,
        }

        // Initialize all providers
        pm.registerProviders()

        return pm
}</span>

// registerProviders registers all available providers
func (pm *ProviderManager) registerProviders() <span class="cov0" title="0">{
        // Movie/TV providers
        pm.providers["tmdb"] = NewTMDBProvider(pm.client, pm.logger)
        pm.providers["imdb"] = NewIMDBProvider(pm.client, pm.logger)
        pm.providers["tvdb"] = NewTVDBProvider(pm.client, pm.logger)

        // Music providers
        pm.providers["musicbrainz"] = NewMusicBrainzProvider(pm.client, pm.logger)
        pm.providers["spotify"] = NewSpotifyProvider(pm.client, pm.logger)
        pm.providers["lastfm"] = NewLastFMProvider(pm.client, pm.logger)

        // Gaming providers
        pm.providers["igdb"] = NewIGDBProvider(pm.client, pm.logger)
        pm.providers["steam"] = NewSteamProvider(pm.client, pm.logger)

        // Books providers
        pm.providers["goodreads"] = NewGoodreadsProvider(pm.client, pm.logger)
        pm.providers["openlibrary"] = NewOpenLibraryProvider(pm.client, pm.logger)

        // Anime providers
        pm.providers["anidb"] = NewAniDBProvider(pm.client, pm.logger)
        pm.providers["myanimelist"] = NewMyAnimeListProvider(pm.client, pm.logger)

        // YouTube/Social providers
        pm.providers["youtube"] = NewYouTubeProvider(pm.client, pm.logger)

        // Software providers
        pm.providers["github"] = NewGitHubProvider(pm.client, pm.logger)

        pm.logger.Info("Metadata providers registered", zap.Int("count", len(pm.providers)))
}</span>

// SearchAll searches across all relevant providers
func (pm *ProviderManager) SearchAll(ctx context.Context, query string, mediaType string, year *int, providers []string) (map[string][]SearchResult, error) <span class="cov0" title="0">{
        results := make(map[string][]SearchResult)

        // If no specific providers requested, use all relevant ones
        if len(providers) == 0 </span><span class="cov0" title="0">{
                providers = pm.getProvidersForMediaType(mediaType)
        }</span>

        <span class="cov0" title="0">for _, providerName := range providers </span><span class="cov0" title="0">{
                provider, exists := pm.providers[providerName]
                if !exists || !provider.IsEnabled() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">providerResults, err := provider.Search(ctx, query, mediaType, year)
                if err != nil </span><span class="cov0" title="0">{
                        pm.logger.Error("Provider search failed",
                                zap.String("provider", providerName),
                                zap.String("query", query),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if len(providerResults) &gt; 0 </span><span class="cov0" title="0">{
                        results[providerName] = providerResults
                }</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// GetBestMatch finds the best matching result across all providers
func (pm *ProviderManager) GetBestMatch(ctx context.Context, query string, mediaType string, year *int) (*SearchResult, string, error) <span class="cov0" title="0">{
        allResults, err := pm.SearchAll(ctx, query, mediaType, year, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">var bestResult *SearchResult
        var bestProvider string
        var bestScore float64

        for providerName, results := range allResults </span><span class="cov0" title="0">{
                for _, result := range results </span><span class="cov0" title="0">{
                        score := pm.calculateRelevanceScore(result, query, year)
                        if score &gt; bestScore </span><span class="cov0" title="0">{
                                bestScore = score
                                bestResult = &amp;result
                                bestProvider = providerName
                        }</span>
                }
        }

        <span class="cov0" title="0">return bestResult, bestProvider, nil</span>
}

// GetDetails gets detailed metadata from a specific provider
func (pm *ProviderManager) GetDetails(ctx context.Context, providerName, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        provider, exists := pm.providers[providerName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider not found: %s", providerName)
        }</span>

        <span class="cov0" title="0">if !provider.IsEnabled() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider disabled: %s", providerName)
        }</span>

        <span class="cov0" title="0">return provider.GetDetails(ctx, externalID)</span>
}

// calculateRelevanceScore calculates how relevant a search result is
func (pm *ProviderManager) calculateRelevanceScore(result SearchResult, query string, year *int) float64 <span class="cov0" title="0">{
        score := result.Relevance

        // Bonus for exact title match
        if strings.EqualFold(result.Title, query) </span><span class="cov0" title="0">{
                score += 0.3
        }</span> else<span class="cov0" title="0"> if strings.Contains(strings.ToLower(result.Title), strings.ToLower(query)) </span><span class="cov0" title="0">{
                score += 0.2
        }</span>

        // Bonus for year match
        <span class="cov0" title="0">if year != nil &amp;&amp; result.Year != nil &amp;&amp; *result.Year == *year </span><span class="cov0" title="0">{
                score += 0.2
        }</span>

        // Bonus for having rating
        <span class="cov0" title="0">if result.Rating != nil &amp;&amp; *result.Rating &gt; 0 </span><span class="cov0" title="0">{
                score += 0.1
        }</span>

        <span class="cov0" title="0">return score</span>
}

// getProvidersForMediaType returns relevant providers for a media type
func (pm *ProviderManager) getProvidersForMediaType(mediaType string) []string <span class="cov0" title="0">{
        providerMap := map[string][]string{
                "movie":         {"tmdb", "imdb"},
                "tv_show":       {"tmdb", "imdb", "tvdb"},
                "anime":         {"anidb", "myanimelist", "tmdb"},
                "music":         {"musicbrainz", "spotify", "lastfm"},
                "pc_game":       {"igdb", "steam"},
                "console_game":  {"igdb"},
                "mobile_game":   {"igdb"},
                "ebook":         {"goodreads", "openlibrary"},
                "audiobook":     {"goodreads"},
                "documentary":   {"tmdb", "imdb"},
                "youtube_video": {"youtube"},
                "software":      {"github"},
                "podcast":       {"spotify"},
        }

        if providers, exists := providerMap[mediaType]; exists </span><span class="cov0" title="0">{
                return providers
        }</span>

        // Default providers for unknown types
        <span class="cov0" title="0">return []string{"tmdb", "imdb"}</span>
}

// Base provider struct with common functionality
type BaseProvider struct {
        name    string
        client  *http.Client
        logger  *zap.Logger
        enabled bool
        apiKey  string
        baseURL string
}

func NewBaseProvider(name, baseURL, apiKey string, client *http.Client, logger *zap.Logger) *BaseProvider <span class="cov0" title="0">{
        return &amp;BaseProvider{
                name:    name,
                client:  client,
                logger:  logger,
                enabled: apiKey != "",
                apiKey:  apiKey,
                baseURL: baseURL,
        }
}</span>

func (bp *BaseProvider) GetName() string <span class="cov0" title="0">{
        return bp.name
}</span>

func (bp *BaseProvider) IsEnabled() bool <span class="cov0" title="0">{
        return bp.enabled
}</span>

// makeRequest makes an HTTP request with error handling
func (bp *BaseProvider) makeRequest(ctx context.Context, url string, headers map[string]string) ([]byte, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Add headers
        <span class="cov0" title="0">for key, value := range headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        // Add API key if available
        <span class="cov0" title="0">if bp.apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+bp.apiKey)
        }</span>

        <span class="cov0" title="0">resp, err := bp.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP %d: %s", resp.StatusCode, resp.Status)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">return body, nil</span>
}

// TMDB Provider Implementation
type TMDBProvider struct {
        *BaseProvider
}

func NewTMDBProvider(client *http.Client, logger *zap.Logger) *TMDBProvider <span class="cov0" title="0">{
        // API key should be loaded from config
        apiKey := "" // Load from environment or config
        return &amp;TMDBProvider{
                BaseProvider: NewBaseProvider("tmdb", "https://api.themoviedb.org/3", apiKey, client, logger),
        }
}</span>

func (t *TMDBProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        endpoint := "/search/multi"
        if mediaType == "movie" </span><span class="cov0" title="0">{
                endpoint = "/search/movie"
        }</span> else<span class="cov0" title="0"> if mediaType == "tv_show" </span><span class="cov0" title="0">{
                endpoint = "/search/tv"
        }</span>

        <span class="cov0" title="0">params := url.Values{}
        params.Add("api_key", t.apiKey)
        params.Add("query", query)
        if year != nil </span><span class="cov0" title="0">{
                params.Add("year", fmt.Sprintf("%d", *year))
        }</span>

        <span class="cov0" title="0">requestURL := t.baseURL + endpoint + "?" + params.Encode()

        body, err := t.makeRequest(ctx, requestURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var response struct {
                Results []struct {
                        ID           int     `json:"id"`
                        Title        string  `json:"title"`
                        Name         string  `json:"name"`
                        ReleaseDate  string  `json:"release_date"`
                        FirstAirDate string  `json:"first_air_date"`
                        Overview     string  `json:"overview"`
                        PosterPath   string  `json:"poster_path"`
                        VoteAverage  float64 `json:"vote_average"`
                        MediaType    string  `json:"media_type"`
                } `json:"results"`
        }

        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">results := make([]SearchResult, 0, len(response.Results))
        for _, item := range response.Results </span><span class="cov0" title="0">{
                title := item.Title
                if title == "" </span><span class="cov0" title="0">{
                        title = item.Name
                }</span>

                <span class="cov0" title="0">var year *int
                dateStr := item.ReleaseDate
                if dateStr == "" </span><span class="cov0" title="0">{
                        dateStr = item.FirstAirDate
                }</span>
                <span class="cov0" title="0">if len(dateStr) &gt;= 4 </span><span class="cov0" title="0">{
                        if y := parseInt(dateStr[:4]); y &gt; 1900 </span><span class="cov0" title="0">{
                                year = &amp;y
                        }</span>
                }

                <span class="cov0" title="0">var coverURL *string
                if item.PosterPath != "" </span><span class="cov0" title="0">{
                        url := fmt.Sprintf("https://image.tmdb.org/t/p/w500%s", item.PosterPath)
                        coverURL = &amp;url
                }</span>

                <span class="cov0" title="0">var rating *float64
                if item.VoteAverage &gt; 0 </span><span class="cov0" title="0">{
                        rating = &amp;item.VoteAverage
                }</span>

                <span class="cov0" title="0">result := SearchResult{
                        ExternalID:  fmt.Sprintf("%d", item.ID),
                        Title:       title,
                        Year:        year,
                        Rating:      rating,
                        Description: &amp;item.Overview,
                        CoverURL:    coverURL,
                        Relevance:   0.8, // Base relevance for TMDB
                }

                results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

func (t *TMDBProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        // Implementation for getting detailed TMDB data
        endpoint := fmt.Sprintf("/movie/%s", externalID)
        params := url.Values{}
        params.Add("api_key", t.apiKey)
        params.Add("append_to_response", "credits,videos,external_ids")

        requestURL := t.baseURL + endpoint + "?" + params.Encode()

        body, err := t.makeRequest(ctx, requestURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">metadata := &amp;models.ExternalMetadata{
                Provider:    t.name,
                ExternalID:  externalID,
                Data:        string(body),
                LastFetched: time.Now(),
        }

        // Parse specific fields
        var details struct {
                Title       string  `json:"title"`
                VoteAverage float64 `json:"vote_average"`
                PosterPath  string  `json:"poster_path"`
                Homepage    string  `json:"homepage"`
                Videos      struct {
                        Results []struct {
                                Site string `json:"site"`
                                Key  string `json:"key"`
                                Type string `json:"type"`
                        } `json:"results"`
                } `json:"videos"`
        }

        if err := json.Unmarshal(body, &amp;details); err == nil </span><span class="cov0" title="0">{
                if details.VoteAverage &gt; 0 </span><span class="cov0" title="0">{
                        metadata.Rating = &amp;details.VoteAverage
                }</span>
                <span class="cov0" title="0">if details.PosterPath != "" </span><span class="cov0" title="0">{
                        url := fmt.Sprintf("https://image.tmdb.org/t/p/w500%s", details.PosterPath)
                        metadata.CoverURL = &amp;url
                }</span>
                <span class="cov0" title="0">if details.Homepage != "" </span><span class="cov0" title="0">{
                        metadata.ReviewURL = &amp;details.Homepage
                }</span>

                // Find trailer
                <span class="cov0" title="0">for _, video := range details.Videos.Results </span><span class="cov0" title="0">{
                        if video.Site == "YouTube" &amp;&amp; video.Type == "Trailer" </span><span class="cov0" title="0">{
                                trailerURL := fmt.Sprintf("https://www.youtube.com/watch?v=%s", video.Key)
                                metadata.TrailerURL = &amp;trailerURL
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return metadata, nil</span>
}

// Helper function (duplicate from detector package)
func parseInt(s string) int <span class="cov0" title="0">{
        var result int
        for _, char := range s </span><span class="cov0" title="0">{
                if char &gt;= '0' &amp;&amp; char &lt;= '9' </span><span class="cov0" title="0">{
                        result = result*10 + int(char-'0')
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// Placeholder implementations for other providers
// These would be implemented similarly to TMDBProvider

type IMDBProvider struct{ *BaseProvider }
type TVDBProvider struct{ *BaseProvider }
type MusicBrainzProvider struct{ *BaseProvider }
type SpotifyProvider struct{ *BaseProvider }
type LastFMProvider struct{ *BaseProvider }
type IGDBProvider struct{ *BaseProvider }
type SteamProvider struct{ *BaseProvider }
type GoodreadsProvider struct{ *BaseProvider }
type OpenLibraryProvider struct{ *BaseProvider }
type AniDBProvider struct{ *BaseProvider }
type MyAnimeListProvider struct{ *BaseProvider }
type YouTubeProvider struct{ *BaseProvider }
type GitHubProvider struct{ *BaseProvider }

// Placeholder constructor functions
func NewIMDBProvider(client *http.Client, logger *zap.Logger) *IMDBProvider <span class="cov0" title="0">{
        return &amp;IMDBProvider{NewBaseProvider("imdb", "https://imdb-api.com", "", client, logger)}
}</span>

func NewTVDBProvider(client *http.Client, logger *zap.Logger) *TVDBProvider <span class="cov0" title="0">{
        return &amp;TVDBProvider{NewBaseProvider("tvdb", "https://api.thetvdb.com", "", client, logger)}
}</span>

func NewMusicBrainzProvider(client *http.Client, logger *zap.Logger) *MusicBrainzProvider <span class="cov0" title="0">{
        return &amp;MusicBrainzProvider{NewBaseProvider("musicbrainz", "https://musicbrainz.org/ws/2", "", client, logger)}
}</span>

func NewSpotifyProvider(client *http.Client, logger *zap.Logger) *SpotifyProvider <span class="cov0" title="0">{
        return &amp;SpotifyProvider{NewBaseProvider("spotify", "https://api.spotify.com/v1", "", client, logger)}
}</span>

func NewLastFMProvider(client *http.Client, logger *zap.Logger) *LastFMProvider <span class="cov0" title="0">{
        return &amp;LastFMProvider{NewBaseProvider("lastfm", "https://ws.audioscrobbler.com/2.0", "", client, logger)}
}</span>

func NewIGDBProvider(client *http.Client, logger *zap.Logger) *IGDBProvider <span class="cov0" title="0">{
        return &amp;IGDBProvider{NewBaseProvider("igdb", "https://api.igdb.com/v4", "", client, logger)}
}</span>

func NewSteamProvider(client *http.Client, logger *zap.Logger) *SteamProvider <span class="cov0" title="0">{
        return &amp;SteamProvider{NewBaseProvider("steam", "https://store.steampowered.com/api", "", client, logger)}
}</span>

func NewGoodreadsProvider(client *http.Client, logger *zap.Logger) *GoodreadsProvider <span class="cov0" title="0">{
        return &amp;GoodreadsProvider{NewBaseProvider("goodreads", "https://www.goodreads.com/book", "", client, logger)}
}</span>

func NewOpenLibraryProvider(client *http.Client, logger *zap.Logger) *OpenLibraryProvider <span class="cov0" title="0">{
        return &amp;OpenLibraryProvider{NewBaseProvider("openlibrary", "https://openlibrary.org", "", client, logger)}
}</span>

func NewAniDBProvider(client *http.Client, logger *zap.Logger) *AniDBProvider <span class="cov0" title="0">{
        return &amp;AniDBProvider{NewBaseProvider("anidb", "https://anidb.net/perl-bin/animedb.pl", "", client, logger)}
}</span>

func NewMyAnimeListProvider(client *http.Client, logger *zap.Logger) *MyAnimeListProvider <span class="cov0" title="0">{
        return &amp;MyAnimeListProvider{NewBaseProvider("myanimelist", "https://api.myanimelist.net/v2", "", client, logger)}
}</span>

func NewYouTubeProvider(client *http.Client, logger *zap.Logger) *YouTubeProvider <span class="cov0" title="0">{
        return &amp;YouTubeProvider{NewBaseProvider("youtube", "https://www.googleapis.com/youtube/v3", "", client, logger)}
}</span>

func NewGitHubProvider(client *http.Client, logger *zap.Logger) *GitHubProvider <span class="cov0" title="0">{
        return &amp;GitHubProvider{NewBaseProvider("github", "https://api.github.com", "", client, logger)}
}</span>

// Implement Search and GetDetails methods for each provider
// (Similar pattern to TMDBProvider, customized for each API)

func (p *IMDBProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        // IMDB API implementation
        return []SearchResult{}, nil
}</span>

func (p *IMDBProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        // IMDB details implementation
        return &amp;models.ExternalMetadata{}, nil
}</span>

// TVDBProvider GetDetails implementation
func (p *TVDBProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// MusicBrainzProvider GetDetails implementation
func (p *MusicBrainzProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// SpotifyProvider GetDetails implementation
func (p *SpotifyProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// LastFMProvider GetDetails implementation
func (p *LastFMProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// IGDBProvider GetDetails implementation
func (p *IGDBProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// SteamProvider GetDetails implementation
func (p *SteamProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// GoodreadsProvider GetDetails implementation
func (p *GoodreadsProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// OpenLibraryProvider GetDetails implementation
func (p *OpenLibraryProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// AniDBProvider GetDetails implementation
func (p *AniDBProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// MyAnimeListProvider GetDetails implementation
func (p *MyAnimeListProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// YouTubeProvider GetDetails implementation
func (p *YouTubeProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// GitHubProvider GetDetails implementation
func (p *GitHubProvider) GetDetails(ctx context.Context, externalID string) (*models.ExternalMetadata, error) <span class="cov0" title="0">{
        return &amp;models.ExternalMetadata{}, nil
}</span>

// Search method implementations for all providers
func (p *TVDBProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *MusicBrainzProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *SpotifyProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *LastFMProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *IGDBProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *SteamProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *GoodreadsProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *OpenLibraryProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *AniDBProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *MyAnimeListProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *YouTubeProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>

func (p *GitHubProvider) Search(ctx context.Context, query string, mediaType string, year *int) ([]SearchResult, error) <span class="cov0" title="0">{
        return []SearchResult{}, nil
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package realtime

import (
        "catalogizer/internal/media/analyzer"
        "catalogizer/internal/media/database"
        "catalogizer/internal/models"
        "catalogizer/internal/services"
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "io"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/fsnotify/fsnotify"
        "go.uber.org/zap"
)

// EnhancedChangeWatcher monitors file system changes with intelligent rename detection
type EnhancedChangeWatcher struct {
        mediaDB       *database.MediaDatabase
        analyzer      *analyzer.MediaAnalyzer
        renameTracker *services.RenameTracker
        logger        *zap.Logger
        watchers      map[string]*fsnotify.Watcher
        watcherMu     sync.RWMutex
        changeQueue   chan EnhancedChangeEvent
        workers       int
        stopCh        chan struct{}
        wg            sync.WaitGroup
        debounceMap   map[string]*time.Timer
        debounceMu    sync.Mutex
        debounceDelay time.Duration
}

// EnhancedChangeEvent represents a file system change with additional metadata
type EnhancedChangeEvent struct {
        Path         string
        SmbRoot      string
        Operation    string // created, modified, deleted, moved
        Timestamp    time.Time
        Size         int64
        IsDir        bool
        FileHash     *string
        FileID       *int64
        PreviousPath *string // for move operations
}

// NewEnhancedChangeWatcher creates a new enhanced change watcher
func NewEnhancedChangeWatcher(mediaDB *database.MediaDatabase, analyzer *analyzer.MediaAnalyzer, renameTracker *services.RenameTracker, logger *zap.Logger) *EnhancedChangeWatcher <span class="cov0" title="0">{
        return &amp;EnhancedChangeWatcher{
                mediaDB:       mediaDB,
                analyzer:      analyzer,
                renameTracker: renameTracker,
                logger:        logger,
                watchers:      make(map[string]*fsnotify.Watcher),
                changeQueue:   make(chan EnhancedChangeEvent, 10000),
                workers:       4, // Increased workers for better performance
                debounceMap:   make(map[string]*time.Timer),
                debounceDelay: 2 * time.Second,
                stopCh:        make(chan struct{}),
        }
}</span>

// Start starts the enhanced change watcher
func (w *EnhancedChangeWatcher) Start() error <span class="cov0" title="0">{
        w.logger.Info("Starting enhanced change watcher", zap.Int("workers", w.workers))

        // Start worker goroutines
        for i := 0; i &lt; w.workers; i++ </span><span class="cov0" title="0">{
                w.wg.Add(1)
                go w.changeWorker(i)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the enhanced change watcher
func (w *EnhancedChangeWatcher) Stop() <span class="cov0" title="0">{
        w.logger.Info("Stopping enhanced change watcher")

        // Stop all file watchers
        w.watcherMu.Lock()
        for path, watcher := range w.watchers </span><span class="cov0" title="0">{
                watcher.Close()
                w.logger.Debug("Closed watcher", zap.String("path", path))
        }</span>
        <span class="cov0" title="0">w.watchers = make(map[string]*fsnotify.Watcher)
        w.watcherMu.Unlock()

        // Stop workers
        close(w.stopCh)
        w.wg.Wait()

        w.logger.Info("Enhanced change watcher stopped")</span>
}

// WatchPath adds a new path to watch
func (w *EnhancedChangeWatcher) WatchPath(smbRoot, localMountPath string) error <span class="cov0" title="0">{
        w.watcherMu.Lock()
        defer w.watcherMu.Unlock()

        // Check if already watching
        if _, exists := w.watchers[smbRoot]; exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create new watcher
        <span class="cov0" title="0">watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add path to watcher recursively
        <span class="cov0" title="0">err = w.addPathRecursively(watcher, localMountPath)
        if err != nil </span><span class="cov0" title="0">{
                watcher.Close()
                return err
        }</span>

        <span class="cov0" title="0">w.watchers[smbRoot] = watcher

        // Start monitoring goroutine
        w.wg.Add(1)
        go w.monitorPath(smbRoot, localMountPath, watcher)

        w.logger.Info("Started watching path",
                zap.String("smb_root", smbRoot),
                zap.String("local_path", localMountPath))

        return nil</span>
}

// UnwatchPath removes a path from watching
func (w *EnhancedChangeWatcher) UnwatchPath(smbRoot string) <span class="cov0" title="0">{
        w.watcherMu.Lock()
        defer w.watcherMu.Unlock()

        if watcher, exists := w.watchers[smbRoot]; exists </span><span class="cov0" title="0">{
                watcher.Close()
                delete(w.watchers, smbRoot)
                w.logger.Info("Stopped watching path", zap.String("smb_root", smbRoot))
        }</span>
}

// addPathRecursively adds a path and all its subdirectories to the watcher
func (w *EnhancedChangeWatcher) addPathRecursively(watcher *fsnotify.Watcher, rootPath string) error <span class="cov0" title="0">{
        return filepath.Walk(rootPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Skip problematic paths
                }</span>

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return watcher.Add(path)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
}

// monitorPath monitors a specific path for changes
func (w *EnhancedChangeWatcher) monitorPath(smbRoot, localPath string, watcher *fsnotify.Watcher) <span class="cov0" title="0">{
        defer w.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>

                case event, ok := &lt;-watcher.Events:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">w.handleFileSystemEvent(smbRoot, localPath, event)</span>

                case err, ok := &lt;-watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">w.logger.Error("File watcher error",
                                zap.String("smb_root", smbRoot),
                                zap.Error(err))</span>
                }
        }
}

// handleFileSystemEvent processes a file system event with enhanced logic
func (w *EnhancedChangeWatcher) handleFileSystemEvent(smbRoot, localPath string, event fsnotify.Event) <span class="cov0" title="0">{
        // Convert local path to relative path within the storage root
        relativePath, err := w.getRelativePath(localPath, event.Name)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Warn("Failed to get relative path", zap.Error(err))
                return
        }</span>

        // Determine operation type
        <span class="cov0" title="0">var operation string
        switch </span>{
        case event.Op&amp;fsnotify.Create == fsnotify.Create:<span class="cov0" title="0">
                operation = "created"</span>
        case event.Op&amp;fsnotify.Write == fsnotify.Write:<span class="cov0" title="0">
                operation = "modified"</span>
        case event.Op&amp;fsnotify.Remove == fsnotify.Remove:<span class="cov0" title="0">
                operation = "deleted"</span>
        case event.Op&amp;fsnotify.Rename == fsnotify.Rename:<span class="cov0" title="0">
                operation = "moved"</span>
        default:<span class="cov0" title="0">
                return</span> // Ignore other events
        }

        // Get file info and metadata
        <span class="cov0" title="0">var size int64
        var isDir bool
        var fileHash *string
        var fileID *int64

        if operation != "deleted" </span><span class="cov0" title="0">{
                // Get file stats
                info, err := os.Stat(event.Name)
                if err == nil </span><span class="cov0" title="0">{
                        size = info.Size()
                        isDir = info.IsDir()

                        // Calculate hash for files (not directories)
                        if !isDir &amp;&amp; size &gt; 0 &amp;&amp; size &lt; 100*1024*1024 </span><span class="cov0" title="0">{ // Only hash files &lt; 100MB
                                if hash := w.calculateFileHash(event.Name); hash != "" </span><span class="cov0" title="0">{
                                        fileHash = &amp;hash
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // For deleted files, try to get info from database
                fileInfo := w.getFileInfoFromDB(relativePath, smbRoot)
                if fileInfo != nil </span><span class="cov0" title="0">{
                        size = fileInfo.Size
                        isDir = fileInfo.IsDirectory
                        if fileInfo.Hash != nil </span><span class="cov0" title="0">{
                                fileHash = fileInfo.Hash
                        }</span>
                        <span class="cov0" title="0">fileID = &amp;fileInfo.ID</span>
                }
        }

        // Handle directory creation by adding to watcher
        <span class="cov0" title="0">if operation == "created" &amp;&amp; isDir </span><span class="cov0" title="0">{
                w.watcherMu.Lock()
                if watcher, exists := w.watchers[smbRoot]; exists </span><span class="cov0" title="0">{
                        watcher.Add(event.Name)
                }</span>
                <span class="cov0" title="0">w.watcherMu.Unlock()</span>
        }

        <span class="cov0" title="0">changeEvent := EnhancedChangeEvent{
                Path:      relativePath,
                SmbRoot:   smbRoot,
                Operation: operation,
                Timestamp: time.Now(),
                Size:      size,
                IsDir:     isDir,
                FileHash:  fileHash,
                FileID:    fileID,
        }

        // Debounce changes to avoid processing rapid consecutive changes
        w.debounceChange(changeEvent)</span>
}

// getRelativePath converts absolute path to relative path within storage root
func (w *EnhancedChangeWatcher) getRelativePath(basePath, fullPath string) (string, error) <span class="cov6" title="4">{
        relPath, err := filepath.Rel(basePath, fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Normalize path separators for cross-platform compatibility
        <span class="cov6" title="4">relPath = filepath.ToSlash(relPath)

        // Ensure path starts with /
        if !strings.HasPrefix(relPath, "/") </span><span class="cov6" title="4">{
                relPath = "/" + relPath
        }</span>

        <span class="cov6" title="4">return relPath, nil</span>
}

// getFileInfoFromDB retrieves file information from database
func (w *EnhancedChangeWatcher) getFileInfoFromDB(path, smbRoot string) *models.FileInfo <span class="cov0" title="0">{
        query := `
                SELECT f.id, f.name, f.path, f.is_directory, f.size, f.last_modified, f.hash, f.extension, f.mime_type, f.parent_id, f.smb_root, f.created_at, f.updated_at
                FROM files f
                JOIN storage_roots sr ON f.storage_root_id = sr.id
                WHERE f.path = ? AND sr.name = ?`

        var file models.FileInfo
        err := w.mediaDB.GetDB().QueryRow(query, path, smbRoot).Scan(
                &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory, &amp;file.Size,
                &amp;file.LastModified, &amp;file.Hash, &amp;file.Extension, &amp;file.MimeType,
                &amp;file.ParentID, &amp;file.SmbRoot, &amp;file.CreatedAt, &amp;file.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if file.IsDirectory </span><span class="cov0" title="0">{
                file.Type = "directory"
        }</span> else<span class="cov0" title="0"> {
                file.Type = "file"
        }</span>

        <span class="cov0" title="0">return &amp;file</span>
}

// calculateFileHash calculates MD5 hash of a file
func (w *EnhancedChangeWatcher) calculateFileHash(filePath string) string <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">defer file.Close()

        hash := md5.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return hex.EncodeToString(hash.Sum(nil))</span>
}

// debounceChange debounces file changes to avoid excessive processing
func (w *EnhancedChangeWatcher) debounceChange(event EnhancedChangeEvent) <span class="cov0" title="0">{
        w.debounceMu.Lock()
        defer w.debounceMu.Unlock()

        key := event.SmbRoot + ":" + event.Path

        // Cancel existing timer
        if timer, exists := w.debounceMap[key]; exists </span><span class="cov0" title="0">{
                timer.Stop()
        }</span>

        // Create new timer
        <span class="cov0" title="0">w.debounceMap[key] = time.AfterFunc(w.debounceDelay, func() </span><span class="cov0" title="0">{
                w.debounceMu.Lock()
                delete(w.debounceMap, key)
                w.debounceMu.Unlock()

                // Send to processing queue
                select </span>{
                case w.changeQueue &lt;- event:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        w.logger.Warn("Change queue full, dropping event",
                                zap.String("path", event.Path),
                                zap.String("operation", event.Operation))</span>
                }
        })
}

// changeWorker processes change events
func (w *EnhancedChangeWatcher) changeWorker(workerID int) <span class="cov0" title="0">{
        defer w.wg.Done()

        w.logger.Info("Enhanced change worker started", zap.Int("worker_id", workerID))

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>

                case event := &lt;-w.changeQueue:<span class="cov0" title="0">
                        w.processChange(event, workerID)</span>
                }
        }
}

// processChange processes a single change event with rename detection
func (w *EnhancedChangeWatcher) processChange(event EnhancedChangeEvent, workerID int) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        w.logger.Debug("Processing enhanced change event",
                zap.Int("worker_id", workerID),
                zap.String("path", event.Path),
                zap.String("operation", event.Operation),
                zap.String("smb_root", event.SmbRoot))

        // Log the change
        if err := w.logChange(event); err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to log change", zap.Error(err))
        }</span>

        <span class="cov0" title="0">switch event.Operation </span>{
        case "created":<span class="cov0" title="0">
                w.handleCreate(ctx, event)</span>
        case "modified":<span class="cov0" title="0">
                w.handleModify(ctx, event)</span>
        case "deleted":<span class="cov0" title="0">
                w.handleDelete(ctx, event)</span>
        case "moved":<span class="cov0" title="0">
                w.handleMove(ctx, event)</span>
        }
}

// handleCreate handles file/directory creation with rename detection
func (w *EnhancedChangeWatcher) handleCreate(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        // Check if this creation is actually part of a move operation
        if pendingMove, isMove := w.renameTracker.DetectCreate(ctx, event.Path, event.SmbRoot, event.Size, event.FileHash, event.IsDir); isMove </span><span class="cov0" title="0">{
                // This is a move operation, not a new file
                err := w.renameTracker.ProcessMove(ctx, pendingMove, event.Path)
                if err != nil </span><span class="cov0" title="0">{
                        w.logger.Error("Failed to process move operation",
                                zap.String("old_path", pendingMove.Path),
                                zap.String("new_path", event.Path),
                                zap.Error(err))

                        // Fall back to treating as delete + create
                        w.handleDeleteFallback(ctx, pendingMove)
                        w.handleCreateNew(ctx, event)
                }</span> else<span class="cov0" title="0"> {
                        w.logger.Info("Successfully processed rename operation",
                                zap.String("old_path", pendingMove.Path),
                                zap.String("new_path", event.Path),
                                zap.Bool("is_directory", event.IsDir))

                        // No need for rescanning - just metadata update
                        w.updateFileMetadata(ctx, event)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // This is a genuinely new file/directory
        <span class="cov0" title="0">w.handleCreateNew(ctx, event)</span>
}

// handleCreateNew handles creation of a genuinely new file/directory
func (w *EnhancedChangeWatcher) handleCreateNew(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        if event.IsDir </span><span class="cov0" title="0">{
                // Directory creation - trigger directory analysis
                err := w.analyzer.AnalyzeDirectory(ctx, event.Path, event.SmbRoot, 7) // High priority
                if err != nil </span><span class="cov0" title="0">{
                        w.logger.Error("Failed to queue directory analysis",
                                zap.String("path", event.Path),
                                zap.Error(err))
                }</span>
        } else<span class="cov0" title="0"> {
                // File creation - analyze parent directory
                parentDir := filepath.Dir(event.Path)
                err := w.analyzer.AnalyzeDirectory(ctx, parentDir, event.SmbRoot, 6) // Medium-high priority
                if err != nil </span><span class="cov0" title="0">{
                        w.logger.Error("Failed to queue directory analysis for new file",
                                zap.String("file", event.Path),
                                zap.String("parent_dir", parentDir),
                                zap.Error(err))
                }</span>
        }
}

// handleModify handles file modification
func (w *EnhancedChangeWatcher) handleModify(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        if event.IsDir </span><span class="cov0" title="0">{
                // Directory modification - usually metadata changes
                w.updateDirectoryMetadata(ctx, event)
        }</span> else<span class="cov0" title="0"> {
                // File modification - update file metadata and check for changes
                w.updateFileMetadata(ctx, event)

                // If this is a media file, might need re-analysis
                if w.isMediaFile(event.Path) </span><span class="cov0" title="0">{
                        parentDir := filepath.Dir(event.Path)
                        w.analyzer.AnalyzeDirectory(ctx, parentDir, event.SmbRoot, 5) // Medium priority
                }</span>
        }
}

// handleDelete handles file/directory deletion with move tracking
func (w *EnhancedChangeWatcher) handleDelete(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        // Track this deletion for potential move detection
        if event.FileID != nil </span><span class="cov0" title="0">{
                w.renameTracker.TrackDelete(ctx, *event.FileID, event.Path, event.SmbRoot, event.Size, event.FileHash, event.IsDir)
        }</span>

        // Don't immediately delete from database - wait for move window to expire
        // The rename tracker's cleanup will handle actual deletions
}

// handleDeleteFallback handles deletion when move processing fails
func (w *EnhancedChangeWatcher) handleDeleteFallback(ctx context.Context, pendingMove *services.PendingMove) <span class="cov0" title="0">{
        // Mark files as deleted in database
        query := `
                UPDATE files
                SET deleted = true, deleted_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := w.mediaDB.GetDB().ExecContext(ctx, query, pendingMove.FileID)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to mark file as deleted",
                        zap.String("path", pendingMove.Path),
                        zap.Error(err))
        }</span>
}

// handleMove handles explicit move operations (rare with fsnotify)
func (w *EnhancedChangeWatcher) handleMove(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        // This is handled by the create/delete pair in most file systems
        w.logger.Debug("Explicit move event received", zap.String("path", event.Path))
}</span>

// updateFileMetadata updates file metadata without rescanning
func (w *EnhancedChangeWatcher) updateFileMetadata(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        query := `
                UPDATE files
                SET last_scan_at = CURRENT_TIMESTAMP, modified_at = ?, size = ?, quick_hash = ?
                WHERE path = ? AND storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)`

        _, err := w.mediaDB.GetDB().ExecContext(ctx, query, event.Timestamp, event.Size, event.FileHash, event.Path, event.SmbRoot)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to update file metadata",
                        zap.String("path", event.Path),
                        zap.Error(err))
        }</span>
}

// updateDirectoryMetadata updates directory metadata
func (w *EnhancedChangeWatcher) updateDirectoryMetadata(ctx context.Context, event EnhancedChangeEvent) <span class="cov0" title="0">{
        query := `
                UPDATE files
                SET last_scan_at = CURRENT_TIMESTAMP, modified_at = ?
                WHERE path = ? AND storage_root_id = (SELECT id FROM storage_roots WHERE name = ?) AND is_directory = true`

        _, err := w.mediaDB.GetDB().ExecContext(ctx, query, event.Timestamp, event.Path, event.SmbRoot)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to update directory metadata",
                        zap.String("path", event.Path),
                        zap.Error(err))
        }</span>
}

// isMediaFile checks if a file is a media file based on extension
func (w *EnhancedChangeWatcher) isMediaFile(path string) bool <span class="cov10" title="10">{
        ext := strings.ToLower(filepath.Ext(path))
        mediaExtensions := map[string]bool{
                ".mp4": true, ".avi": true, ".mkv": true, ".mov": true, ".wmv": true,
                ".mp3": true, ".flac": true, ".wav": true, ".aac": true, ".ogg": true,
                ".jpg": true, ".jpeg": true, ".png": true, ".gif": true, ".bmp": true,
                ".pdf": true, ".epub": true, ".mobi": true,
        }
        return mediaExtensions[ext]
}</span>

// logChange logs the change to the database
func (w *EnhancedChangeWatcher) logChange(event EnhancedChangeEvent) error <span class="cov0" title="0">{
        eventDataJSON, _ := json.Marshal(map[string]interface{}{
                "path":      event.Path,
                "operation": event.Operation,
                "timestamp": event.Timestamp,
                "size":      event.Size,
                "is_dir":    event.IsDir,
                "file_hash": event.FileHash,
                "file_id":   event.FileID,
        })

        query := `
                INSERT INTO change_log (entity_type, entity_id, change_type, new_data, detected_at, processed)
                VALUES (?, ?, ?, ?, ?, ?)`

        _, err := w.mediaDB.GetDB().Exec(query,
                "file", event.Path, event.Operation, string(eventDataJSON), event.Timestamp, false)

        return err
}</span>

// GetStatistics returns statistics about the enhanced watcher
func (w *EnhancedChangeWatcher) GetStatistics(since time.Time) (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Get change statistics
        query := `
                SELECT change_type, COUNT(*) as count
                FROM change_log
                WHERE detected_at &gt;= ?
                GROUP BY change_type`

        rows, err := w.mediaDB.GetDB().Query(query, since)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        changeTypes := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var changeType string
                var count int
                if err := rows.Scan(&amp;changeType, &amp;count); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">changeTypes[changeType] = count</span>
        }
        <span class="cov0" title="0">stats["changes_by_type"] = changeTypes

        // Get rename tracker statistics
        renameStats := w.renameTracker.GetStatistics()
        stats["rename_tracking"] = renameStats

        // Count currently watched paths
        w.watcherMu.RLock()
        stats["watched_paths"] = len(w.watchers)
        w.watcherMu.RUnlock()

        // Queue statistics
        stats["queue_length"] = len(w.changeQueue)
        stats["workers"] = w.workers

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package realtime

import (
        "catalogizer/internal/media/analyzer"
        "catalogizer/internal/media/database"
        "context"
        "encoding/json"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/fsnotify/fsnotify"
        "go.uber.org/zap"
)

// SMBChangeWatcher monitors SMB shares for changes and triggers real-time analysis
type SMBChangeWatcher struct {
        mediaDB       *database.MediaDatabase
        analyzer      *analyzer.MediaAnalyzer
        logger        *zap.Logger
        watchers      map[string]*fsnotify.Watcher
        watcherMu     sync.RWMutex
        changeQueue   chan ChangeEvent
        workers       int
        stopCh        chan struct{}
        wg            sync.WaitGroup
        debounceMap   map[string]*time.Timer
        debounceMu    sync.Mutex
        debounceDelay time.Duration
}

// ChangeEvent represents a file system change
type ChangeEvent struct {
        Path      string
        SmbRoot   string
        Operation string // created, modified, deleted, moved
        Timestamp time.Time
        Size      int64
        IsDir     bool
}

// NewSMBChangeWatcher creates a new change watcher
func NewSMBChangeWatcher(mediaDB *database.MediaDatabase, analyzer *analyzer.MediaAnalyzer, logger *zap.Logger) *SMBChangeWatcher <span class="cov0" title="0">{
        return &amp;SMBChangeWatcher{
                mediaDB:       mediaDB,
                analyzer:      analyzer,
                logger:        logger,
                watchers:      make(map[string]*fsnotify.Watcher),
                changeQueue:   make(chan ChangeEvent, 10000),
                workers:       2,
                debounceMap:   make(map[string]*time.Timer),
                debounceDelay: 2 * time.Second, // Wait 2 seconds before processing changes
                stopCh:        make(chan struct{}),
        }
}</span>

// Start starts the change watcher
func (w *SMBChangeWatcher) Start() error <span class="cov0" title="0">{
        w.logger.Info("Starting SMB change watcher", zap.Int("workers", w.workers))

        // Start worker goroutines
        for i := 0; i &lt; w.workers; i++ </span><span class="cov0" title="0">{
                w.wg.Add(1)
                go w.changeWorker(i)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the change watcher
func (w *SMBChangeWatcher) Stop() <span class="cov0" title="0">{
        w.logger.Info("Stopping SMB change watcher")

        // Stop all file watchers
        w.watcherMu.Lock()
        for path, watcher := range w.watchers </span><span class="cov0" title="0">{
                watcher.Close()
                w.logger.Debug("Closed watcher", zap.String("path", path))
        }</span>
        <span class="cov0" title="0">w.watchers = make(map[string]*fsnotify.Watcher)
        w.watcherMu.Unlock()

        // Stop workers
        close(w.stopCh)
        w.wg.Wait()

        w.logger.Info("SMB change watcher stopped")</span>
}

// WatchSMBPath adds a new SMB path to watch
func (w *SMBChangeWatcher) WatchSMBPath(smbRoot, localMountPath string) error <span class="cov0" title="0">{
        w.watcherMu.Lock()
        defer w.watcherMu.Unlock()

        // Check if already watching
        if _, exists := w.watchers[smbRoot]; exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create new watcher
        <span class="cov0" title="0">watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add path to watcher
        <span class="cov0" title="0">err = watcher.Add(localMountPath)
        if err != nil </span><span class="cov0" title="0">{
                watcher.Close()
                return err
        }</span>

        <span class="cov0" title="0">w.watchers[smbRoot] = watcher

        // Start monitoring goroutine
        w.wg.Add(1)
        go w.monitorPath(smbRoot, localMountPath, watcher)

        w.logger.Info("Started watching SMB path",
                zap.String("smb_root", smbRoot),
                zap.String("local_path", localMountPath))

        return nil</span>
}

// UnwatchSMBPath removes an SMB path from watching
func (w *SMBChangeWatcher) UnwatchSMBPath(smbRoot string) <span class="cov0" title="0">{
        w.watcherMu.Lock()
        defer w.watcherMu.Unlock()

        if watcher, exists := w.watchers[smbRoot]; exists </span><span class="cov0" title="0">{
                watcher.Close()
                delete(w.watchers, smbRoot)
                w.logger.Info("Stopped watching SMB path", zap.String("smb_root", smbRoot))
        }</span>
}

// monitorPath monitors a specific path for changes
func (w *SMBChangeWatcher) monitorPath(smbRoot, localPath string, watcher *fsnotify.Watcher) <span class="cov0" title="0">{
        defer w.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>

                case event, ok := &lt;-watcher.Events:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">w.handleFileSystemEvent(smbRoot, event)</span>

                case err, ok := &lt;-watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">w.logger.Error("File watcher error",
                                zap.String("smb_root", smbRoot),
                                zap.Error(err))</span>
                }
        }
}

// handleFileSystemEvent processes a file system event
func (w *SMBChangeWatcher) handleFileSystemEvent(smbRoot string, event fsnotify.Event) <span class="cov0" title="0">{
        // Determine operation type
        var operation string
        switch </span>{
        case event.Op&amp;fsnotify.Create == fsnotify.Create:<span class="cov0" title="0">
                operation = "created"</span>
        case event.Op&amp;fsnotify.Write == fsnotify.Write:<span class="cov0" title="0">
                operation = "modified"</span>
        case event.Op&amp;fsnotify.Remove == fsnotify.Remove:<span class="cov0" title="0">
                operation = "deleted"</span>
        case event.Op&amp;fsnotify.Rename == fsnotify.Rename:<span class="cov0" title="0">
                operation = "moved"</span>
        default:<span class="cov0" title="0">
                return</span> // Ignore other events
        }

        // Get file info
        <span class="cov0" title="0">var size int64
        var isDir bool
        if operation != "deleted" </span><span class="cov0" title="0">{
                if info, err := filepath.Glob(event.Name); err == nil &amp;&amp; len(info) &gt; 0 </span><span class="cov0" title="0">{
                        // This is a simplified check - in real implementation,
                        // you'd use proper file stat
                        isDir = filepath.Ext(event.Name) == ""
                }</span>
        }

        <span class="cov0" title="0">changeEvent := ChangeEvent{
                Path:      event.Name,
                SmbRoot:   smbRoot,
                Operation: operation,
                Timestamp: time.Now(),
                Size:      size,
                IsDir:     isDir,
        }

        // Debounce changes to avoid processing rapid consecutive changes
        w.debounceChange(changeEvent)</span>
}

// debounceChange debounces file changes to avoid excessive processing
func (w *SMBChangeWatcher) debounceChange(event ChangeEvent) <span class="cov0" title="0">{
        w.debounceMu.Lock()
        defer w.debounceMu.Unlock()

        key := event.SmbRoot + ":" + event.Path

        // Cancel existing timer
        if timer, exists := w.debounceMap[key]; exists </span><span class="cov0" title="0">{
                timer.Stop()
        }</span>

        // Create new timer
        <span class="cov0" title="0">w.debounceMap[key] = time.AfterFunc(w.debounceDelay, func() </span><span class="cov0" title="0">{
                w.debounceMu.Lock()
                delete(w.debounceMap, key)
                w.debounceMu.Unlock()

                // Send to processing queue
                select </span>{
                case w.changeQueue &lt;- event:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        w.logger.Warn("Change queue full, dropping event",
                                zap.String("path", event.Path),
                                zap.String("operation", event.Operation))</span>
                }
        })
}

// changeWorker processes change events
func (w *SMBChangeWatcher) changeWorker(workerID int) <span class="cov0" title="0">{
        defer w.wg.Done()

        w.logger.Info("Change worker started", zap.Int("worker_id", workerID))

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>

                case event := &lt;-w.changeQueue:<span class="cov0" title="0">
                        w.processChange(event, workerID)</span>
                }
        }
}

// processChange processes a single change event
func (w *SMBChangeWatcher) processChange(event ChangeEvent, workerID int) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        w.logger.Debug("Processing change event",
                zap.Int("worker_id", workerID),
                zap.String("path", event.Path),
                zap.String("operation", event.Operation),
                zap.String("smb_root", event.SmbRoot))

        // Log the change
        if err := w.logChange(event); err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to log change", zap.Error(err))
        }</span>

        <span class="cov0" title="0">switch event.Operation </span>{
        case "created", "modified":<span class="cov0" title="0">
                w.handleCreateOrModify(ctx, event)</span>
        case "deleted":<span class="cov0" title="0">
                w.handleDelete(ctx, event)</span>
        case "moved":<span class="cov0" title="0">
                w.handleMove(ctx, event)</span>
        }
}

// logChange logs the change to the database
func (w *SMBChangeWatcher) logChange(event ChangeEvent) error <span class="cov0" title="0">{
        oldDataJSON, _ := json.Marshal(map[string]interface{}{
                "path":      event.Path,
                "operation": event.Operation,
                "timestamp": event.Timestamp,
                "size":      event.Size,
                "is_dir":    event.IsDir,
        })

        query := `
                INSERT INTO change_log (entity_type, entity_id, change_type, new_data, detected_at, processed)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err := w.mediaDB.GetDB().Exec(query,
                "file", event.Path, event.Operation, string(oldDataJSON), event.Timestamp, false)

        return err
}</span>

// handleCreateOrModify handles file creation or modification
func (w *SMBChangeWatcher) handleCreateOrModify(ctx context.Context, event ChangeEvent) <span class="cov0" title="0">{
        if event.IsDir </span><span class="cov0" title="0">{
                // Directory change - trigger directory analysis
                err := w.analyzer.AnalyzeDirectory(ctx, event.Path, event.SmbRoot, 7) // High priority
                if err != nil </span><span class="cov0" title="0">{
                        w.logger.Error("Failed to queue directory analysis",
                                zap.String("path", event.Path),
                                zap.Error(err))
                }</span>
        } else<span class="cov0" title="0"> {
                // File change - check if it belongs to existing media item
                w.handleFileChange(ctx, event)
        }</span>
}

// handleDelete handles file or directory deletion
func (w *SMBChangeWatcher) handleDelete(ctx context.Context, event ChangeEvent) <span class="cov0" title="0">{
        // Mark files as missing in database
        query := `
                UPDATE media_files
                SET last_verified = ?, virtual_smb_link = NULL
                WHERE file_path = ? AND smb_root = ?
        `

        _, err := w.mediaDB.GetDB().Exec(query, time.Now(), event.Path, event.SmbRoot)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to mark file as deleted",
                        zap.String("path", event.Path),
                        zap.Error(err))
        }</span>

        // Check if this affects any media items
        <span class="cov0" title="0">w.checkMediaItemIntegrity(ctx, event.Path, event.SmbRoot)</span>
}

// handleMove handles file or directory moves
func (w *SMBChangeWatcher) handleMove(ctx context.Context, event ChangeEvent) <span class="cov0" title="0">{
        // This is complex to implement properly as we need both old and new paths
        // For now, treat as delete + create
        w.handleDelete(ctx, event)
}</span>

// handleFileChange handles individual file changes
func (w *SMBChangeWatcher) handleFileChange(ctx context.Context, event ChangeEvent) <span class="cov0" title="0">{
        // Check if file belongs to existing media item
        query := `
                SELECT mf.media_item_id, mi.title, mi.media_type_id
                FROM media_files mf
                JOIN media_items mi ON mf.media_item_id = mi.id
                WHERE mf.file_path = ? AND mf.smb_root = ?
        `

        var mediaItemID, mediaTypeID int64
        var title string
        err := w.mediaDB.GetDB().QueryRow(query, event.Path, event.SmbRoot).Scan(&amp;mediaItemID, &amp;title, &amp;mediaTypeID)

        if err == nil </span><span class="cov0" title="0">{
                // File belongs to existing media item - update verification timestamp
                updateQuery := `UPDATE media_files SET last_verified = ? WHERE file_path = ? AND smb_root = ?`
                w.mediaDB.GetDB().Exec(updateQuery, time.Now(), event.Path, event.SmbRoot)

                w.logger.Debug("Updated existing media file",
                        zap.String("path", event.Path),
                        zap.String("title", title),
                        zap.Int64("media_item_id", mediaItemID))
        }</span> else<span class="cov0" title="0"> {
                // New file - analyze parent directory
                parentDir := filepath.Dir(event.Path)
                err := w.analyzer.AnalyzeDirectory(ctx, parentDir, event.SmbRoot, 6) // Medium-high priority
                if err != nil </span><span class="cov0" title="0">{
                        w.logger.Error("Failed to queue directory analysis for new file",
                                zap.String("file", event.Path),
                                zap.String("parent_dir", parentDir),
                                zap.Error(err))
                }</span>
        }
}

// checkMediaItemIntegrity checks if a media item is still valid after file changes
func (w *SMBChangeWatcher) checkMediaItemIntegrity(ctx context.Context, filePath, smbRoot string) <span class="cov0" title="0">{
        // Find media items that might be affected
        query := `
                SELECT DISTINCT mi.id, mi.title, COUNT(mf.id) as file_count
                FROM media_items mi
                JOIN media_files mf ON mi.id = mf.media_item_id
                WHERE mf.smb_root = ? AND mf.file_path LIKE ?
                GROUP BY mi.id, mi.title
        `

        dirPattern := filepath.Dir(filePath) + "%"
        rows, err := w.mediaDB.GetDB().Query(query, smbRoot, dirPattern)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error("Failed to check media item integrity", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var mediaItemID int64
                var title string
                var fileCount int

                if err := rows.Scan(&amp;mediaItemID, &amp;title, &amp;fileCount); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // If media item has very few files remaining, mark for review
                <span class="cov0" title="0">if fileCount &lt;= 1 </span><span class="cov0" title="0">{
                        w.logger.Warn("Media item may be incomplete after file deletion",
                                zap.Int64("media_item_id", mediaItemID),
                                zap.String("title", title),
                                zap.Int("remaining_files", fileCount))

                        // Update media item status
                        updateQuery := `UPDATE media_items SET status = 'missing', last_updated = ? WHERE id = ?`
                        w.mediaDB.GetDB().Exec(updateQuery, time.Now(), mediaItemID)
                }</span>
        }
}

// GetChangeStatistics returns statistics about recent changes
func (w *SMBChangeWatcher) GetChangeStatistics(since time.Time) (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Count changes by type
        query := `
                SELECT change_type, COUNT(*) as count
                FROM change_log
                WHERE detected_at &gt;= ?
                GROUP BY change_type
        `

        rows, err := w.mediaDB.GetDB().Query(query, since)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        changeTypes := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var changeType string
                var count int
                if err := rows.Scan(&amp;changeType, &amp;count); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">changeTypes[changeType] = count</span>
        }
        <span class="cov0" title="0">stats["changes_by_type"] = changeTypes

        // Count total changes
        var totalChanges int
        err = w.mediaDB.GetDB().QueryRow(
                "SELECT COUNT(*) FROM change_log WHERE detected_at &gt;= ?", since).Scan(&amp;totalChanges)
        if err == nil </span><span class="cov0" title="0">{
                stats["total_changes"] = totalChanges
        }</span>

        // Count unprocessed changes
        <span class="cov0" title="0">var unprocessed int
        err = w.mediaDB.GetDB().QueryRow(
                "SELECT COUNT(*) FROM change_log WHERE processed = false").Scan(&amp;unprocessed)
        if err == nil </span><span class="cov0" title="0">{
                stats["unprocessed_changes"] = unprocessed
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// ProcessPendingChanges processes any unprocessed changes
func (w *SMBChangeWatcher) ProcessPendingChanges(ctx context.Context) error <span class="cov0" title="0">{
        query := `
                SELECT id, entity_id, change_type, new_data, detected_at
                FROM change_log
                WHERE processed = false
                ORDER BY detected_at ASC
                LIMIT 100
        `

        rows, err := w.mediaDB.GetDB().Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var processedIDs []int64

        for rows.Next() </span><span class="cov0" title="0">{
                var id int64
                var entityID, changeType, newDataJSON string
                var detectedAt time.Time

                if err := rows.Scan(&amp;id, &amp;entityID, &amp;changeType, &amp;newDataJSON, &amp;detectedAt); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse change data
                <span class="cov0" title="0">var changeData map[string]interface{}
                if err := json.Unmarshal([]byte(newDataJSON), &amp;changeData); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create change event
                <span class="cov0" title="0">event := ChangeEvent{
                        Path:      entityID,
                        Operation: changeType,
                        Timestamp: detectedAt,
                }

                if smbRoot, ok := changeData["smb_root"].(string); ok </span><span class="cov0" title="0">{
                        event.SmbRoot = smbRoot
                }</span>
                <span class="cov0" title="0">if size, ok := changeData["size"].(float64); ok </span><span class="cov0" title="0">{
                        event.Size = int64(size)
                }</span>
                <span class="cov0" title="0">if isDir, ok := changeData["is_dir"].(bool); ok </span><span class="cov0" title="0">{
                        event.IsDir = isDir
                }</span>

                // Process the change
                <span class="cov0" title="0">w.processChange(event, 0)
                processedIDs = append(processedIDs, id)</span>
        }

        // Mark changes as processed
        <span class="cov0" title="0">if len(processedIDs) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := strings.Repeat("?,", len(processedIDs))
                placeholders = placeholders[:len(placeholders)-1]

                updateQuery := "UPDATE change_log SET processed = true WHERE id IN (" + placeholders + ")"
                args := make([]interface{}, len(processedIDs))
                for i, id := range processedIDs </span><span class="cov0" title="0">{
                        args[i] = id
                }</span>

                <span class="cov0" title="0">_, err = w.mediaDB.GetDB().Exec(updateQuery, args...)
                if err != nil </span><span class="cov0" title="0">{
                        w.logger.Error("Failed to mark changes as processed", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        w.logger.Info("Processed pending changes", zap.Int("count", len(processedIDs)))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package middleware

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
)

func CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Credentials", "true")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Header("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE, PATCH")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func Logger(logger *zap.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                path := c.Request.URL.Path
                raw := c.Request.URL.RawQuery

                c.Next()

                latency := time.Since(start)
                clientIP := c.ClientIP()
                method := c.Request.Method
                statusCode := c.Writer.Status()

                if raw != "" </span><span class="cov0" title="0">{
                        path = path + "?" + raw
                }</span>

                <span class="cov0" title="0">logger.Info("HTTP Request",
                        zap.String("method", method),
                        zap.String("path", path),
                        zap.Int("status", statusCode),
                        zap.String("ip", clientIP),
                        zap.Duration("latency", latency),
                        zap.String("user_agent", c.Request.UserAgent()),
                )</span>
        }
}

func ErrorHandler() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        err := c.Errors.Last()
                        switch err.Type </span>{
                        case gin.ErrorTypeBind:<span class="cov0" title="0">
                                c.JSON(http.StatusBadRequest, gin.H{
                                        "error":   "Invalid request format",
                                        "details": err.Error(),
                                })</span>
                        case gin.ErrorTypePublic:<span class="cov0" title="0">
                                c.JSON(http.StatusInternalServerError, gin.H{
                                        "error": err.Error(),
                                })</span>
                        default:<span class="cov0" title="0">
                                c.JSON(http.StatusInternalServerError, gin.H{
                                        "error": "Internal server error",
                                })</span>
                        }
                }
        }
}

func RequestID() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = uuid.New().String()
                }</span>
                <span class="cov0" title="0">c.Header("X-Request-ID", requestID)
                c.Set("RequestID", requestID)
                c.Next()</span>
        }
}

type RateLimiter struct {
        requests map[string][]time.Time
        limit    int
        window   time.Duration
}

func NewRateLimiter(limit int, window time.Duration) *RateLimiter <span class="cov0" title="0">{
        return &amp;RateLimiter{
                requests: make(map[string][]time.Time),
                limit:    limit,
                window:   window,
        }
}</span>

func (rl *RateLimiter) Middleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                clientIP := c.ClientIP()
                now := time.Now()

                // Clean old requests
                if requests, exists := rl.requests[clientIP]; exists </span><span class="cov0" title="0">{
                        var validRequests []time.Time
                        for _, req := range requests </span><span class="cov0" title="0">{
                                if now.Sub(req) &lt; rl.window </span><span class="cov0" title="0">{
                                        validRequests = append(validRequests, req)
                                }</span>
                        }
                        <span class="cov0" title="0">rl.requests[clientIP] = validRequests</span>
                }

                // Check if limit exceeded
                <span class="cov0" title="0">if len(rl.requests[clientIP]) &gt;= rl.limit </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": "Rate limit exceeded",
                        })
                        c.Abort()
                        return
                }</span>

                // Add current request
                <span class="cov0" title="0">rl.requests[clientIP] = append(rl.requests[clientIP], now)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package recovery

import (
        "errors"
        "sync"
        "time"

        "go.uber.org/zap"
)

// CircuitState represents the state of a circuit breaker
type CircuitState int

const (
        StateClosed CircuitState = iota
        StateHalfOpen
        StateOpen
)

func (s CircuitState) String() string <span class="cov0" title="0">{
        switch s </span>{
        case StateClosed:<span class="cov0" title="0">
                return "closed"</span>
        case StateHalfOpen:<span class="cov0" title="0">
                return "half-open"</span>
        case StateOpen:<span class="cov0" title="0">
                return "open"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// CircuitBreaker implements the circuit breaker pattern for fault tolerance
type CircuitBreaker struct {
        name            string
        maxFailures     int
        resetTimeout    time.Duration
        state           CircuitState
        failures        int
        lastFailureTime time.Time
        nextAttempt     time.Time
        mutex           sync.RWMutex
        logger          *zap.Logger
        onStateChange   func(string, CircuitState, CircuitState)
}

// CircuitBreakerConfig contains configuration for a circuit breaker
type CircuitBreakerConfig struct {
        Name         string
        MaxFailures  int
        ResetTimeout time.Duration
        Logger       *zap.Logger
}

// NewCircuitBreaker creates a new circuit breaker
func NewCircuitBreaker(config CircuitBreakerConfig) *CircuitBreaker <span class="cov0" title="0">{
        if config.MaxFailures &lt;= 0 </span><span class="cov0" title="0">{
                config.MaxFailures = 5
        }</span>
        <span class="cov0" title="0">if config.ResetTimeout &lt;= 0 </span><span class="cov0" title="0">{
                config.ResetTimeout = 60 * time.Second
        }</span>

        <span class="cov0" title="0">return &amp;CircuitBreaker{
                name:         config.Name,
                maxFailures:  config.MaxFailures,
                resetTimeout: config.ResetTimeout,
                state:        StateClosed,
                logger:       config.Logger,
        }</span>
}

// SetStateChangeCallback sets a callback for state changes
func (cb *CircuitBreaker) SetStateChangeCallback(callback func(string, CircuitState, CircuitState)) <span class="cov0" title="0">{
        cb.onStateChange = callback
}</span>

// Execute executes a function with circuit breaker protection
func (cb *CircuitBreaker) Execute(fn func() error) error <span class="cov0" title="0">{
        if !cb.allowRequest() </span><span class="cov0" title="0">{
                return errors.New("circuit breaker is open")
        }</span>

        <span class="cov0" title="0">err := fn()
        cb.recordResult(err)
        return err</span>
}

// allowRequest determines if a request should be allowed
func (cb *CircuitBreaker) allowRequest() bool <span class="cov0" title="0">{
        cb.mutex.RLock()
        defer cb.mutex.RUnlock()

        switch cb.state </span>{
        case StateClosed:<span class="cov0" title="0">
                return true</span>
        case StateOpen:<span class="cov0" title="0">
                return time.Now().After(cb.nextAttempt)</span>
        case StateHalfOpen:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// recordResult records the result of an operation
func (cb *CircuitBreaker) recordResult(err error) <span class="cov0" title="0">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        if err != nil </span><span class="cov0" title="0">{
                cb.recordFailure()
        }</span> else<span class="cov0" title="0"> {
                cb.recordSuccess()
        }</span>
}

// recordFailure records a failure
func (cb *CircuitBreaker) recordFailure() <span class="cov0" title="0">{
        cb.failures++
        cb.lastFailureTime = time.Now()

        switch cb.state </span>{
        case StateClosed:<span class="cov0" title="0">
                if cb.failures &gt;= cb.maxFailures </span><span class="cov0" title="0">{
                        cb.setState(StateOpen)
                        cb.nextAttempt = time.Now().Add(cb.resetTimeout)
                }</span>
        case StateHalfOpen:<span class="cov0" title="0">
                cb.setState(StateOpen)
                cb.nextAttempt = time.Now().Add(cb.resetTimeout)</span>
        }

        <span class="cov0" title="0">cb.logger.Warn("Circuit breaker recorded failure",
                zap.String("name", cb.name),
                zap.Int("failures", cb.failures),
                zap.String("state", cb.state.String()))</span>
}

// recordSuccess records a success
func (cb *CircuitBreaker) recordSuccess() <span class="cov0" title="0">{
        switch cb.state </span>{
        case StateHalfOpen:<span class="cov0" title="0">
                cb.failures = 0
                cb.setState(StateClosed)</span>
        case StateClosed:<span class="cov0" title="0">
                cb.failures = 0</span>
        }

        <span class="cov0" title="0">cb.logger.Debug("Circuit breaker recorded success",
                zap.String("name", cb.name),
                zap.String("state", cb.state.String()))</span>
}

// setState changes the circuit breaker state
func (cb *CircuitBreaker) setState(newState CircuitState) <span class="cov0" title="0">{
        if cb.state == newState </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">oldState := cb.state
        cb.state = newState

        cb.logger.Info("Circuit breaker state changed",
                zap.String("name", cb.name),
                zap.String("old_state", oldState.String()),
                zap.String("new_state", newState.String()))

        if cb.onStateChange != nil </span><span class="cov0" title="0">{
                cb.onStateChange(cb.name, oldState, newState)
        }</span>
}

// GetState returns the current state
func (cb *CircuitBreaker) GetState() CircuitState <span class="cov0" title="0">{
        cb.mutex.RLock()
        defer cb.mutex.RUnlock()
        return cb.state
}</span>

// GetFailures returns the current failure count
func (cb *CircuitBreaker) GetFailures() int <span class="cov0" title="0">{
        cb.mutex.RLock()
        defer cb.mutex.RUnlock()
        return cb.failures
}</span>

// GetStats returns circuit breaker statistics
func (cb *CircuitBreaker) GetStats() map[string]interface{} <span class="cov0" title="0">{
        cb.mutex.RLock()
        defer cb.mutex.RUnlock()

        return map[string]interface{}{
                "name":              cb.name,
                "state":             cb.state.String(),
                "failures":          cb.failures,
                "max_failures":      cb.maxFailures,
                "last_failure_time": cb.lastFailureTime,
                "next_attempt":      cb.nextAttempt,
                "reset_timeout":     cb.resetTimeout,
        }
}</span>

// Reset manually resets the circuit breaker
func (cb *CircuitBreaker) Reset() <span class="cov0" title="0">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        cb.failures = 0
        cb.setState(StateClosed)

        cb.logger.Info("Circuit breaker manually reset", zap.String("name", cb.name))
}</span>

// CircuitBreakerManager manages multiple circuit breakers
type CircuitBreakerManager struct {
        breakers map[string]*CircuitBreaker
        mutex    sync.RWMutex
        logger   *zap.Logger
}

// NewCircuitBreakerManager creates a new circuit breaker manager
func NewCircuitBreakerManager(logger *zap.Logger) *CircuitBreakerManager <span class="cov0" title="0">{
        return &amp;CircuitBreakerManager{
                breakers: make(map[string]*CircuitBreaker),
                logger:   logger,
        }
}</span>

// GetOrCreate gets an existing circuit breaker or creates a new one
func (m *CircuitBreakerManager) GetOrCreate(name string, config CircuitBreakerConfig) *CircuitBreaker <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if breaker, exists := m.breakers[name]; exists </span><span class="cov0" title="0">{
                return breaker
        }</span>

        <span class="cov0" title="0">config.Name = name
        if config.Logger == nil </span><span class="cov0" title="0">{
                config.Logger = m.logger
        }</span>

        <span class="cov0" title="0">breaker := NewCircuitBreaker(config)
        m.breakers[name] = breaker

        m.logger.Info("Created new circuit breaker", zap.String("name", name))
        return breaker</span>
}

// Get retrieves a circuit breaker by name
func (m *CircuitBreakerManager) Get(name string) *CircuitBreaker <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        return m.breakers[name]
}</span>

// GetAll returns all circuit breakers
func (m *CircuitBreakerManager) GetAll() map[string]*CircuitBreaker <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        result := make(map[string]*CircuitBreaker)
        for name, breaker := range m.breakers </span><span class="cov0" title="0">{
                result[name] = breaker
        }</span>
        <span class="cov0" title="0">return result</span>
}

// GetStats returns statistics for all circuit breakers
func (m *CircuitBreakerManager) GetStats() map[string]interface{} <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        stats := make(map[string]interface{})
        for name, breaker := range m.breakers </span><span class="cov0" title="0">{
                stats[name] = breaker.GetStats()
        }</span>
        <span class="cov0" title="0">return stats</span>
}

// Reset resets all circuit breakers
func (m *CircuitBreakerManager) Reset() <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        for _, breaker := range m.breakers </span><span class="cov0" title="0">{
                breaker.Reset()
        }</span>

        <span class="cov0" title="0">m.logger.Info("All circuit breakers reset")</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package recovery

import (
        "context"
        "math"
        "math/rand"
        "sync"
        "time"

        "go.uber.org/zap"
)

// RetryConfig contains configuration for retry logic
type RetryConfig struct {
        MaxAttempts   int
        InitialDelay  time.Duration
        MaxDelay      time.Duration
        BackoffFactor float64
        Jitter        bool
        Logger        *zap.Logger
}

// DefaultRetryConfig returns a default retry configuration
func DefaultRetryConfig() RetryConfig <span class="cov0" title="0">{
        return RetryConfig{
                MaxAttempts:   3,
                InitialDelay:  1 * time.Second,
                MaxDelay:      30 * time.Second,
                BackoffFactor: 2.0,
                Jitter:        true,
        }
}</span>

// RetryableError represents an error that can be retried
type RetryableError struct {
        Err       error
        Retryable bool
}

func (e RetryableError) Error() string <span class="cov0" title="0">{
        return e.Err.Error()
}</span>

// IsRetryable returns true if the error is retryable
func (e RetryableError) IsRetryable() bool <span class="cov0" title="0">{
        return e.Retryable
}</span>

// NewRetryableError creates a new retryable error
func NewRetryableError(err error, retryable bool) RetryableError <span class="cov0" title="0">{
        return RetryableError{
                Err:       err,
                Retryable: retryable,
        }
}</span>

// RetryFunc is a function that can be retried
type RetryFunc func() error

// RetryWithCallback is a function that can be retried with callbacks
type RetryWithCallback func(attempt int) error

// Retry executes a function with retry logic
func Retry(ctx context.Context, config RetryConfig, fn RetryFunc) error <span class="cov0" title="0">{
        return RetryWithCallbacks(ctx, config, func(attempt int) error </span><span class="cov0" title="0">{
                return fn()
        }</span>, nil, nil)
}

// RetryWithCallbacks executes a function with retry logic and callbacks
func RetryWithCallbacks(
        ctx context.Context,
        config RetryConfig,
        fn RetryWithCallback,
        onRetry func(attempt int, err error, delay time.Duration),
        onFinalError func(attempt int, err error),
) error <span class="cov0" title="0">{
        var lastErr error

        for attempt := 0; attempt &lt; config.MaxAttempts; attempt++ </span><span class="cov0" title="0">{
                if config.Logger != nil </span><span class="cov0" title="0">{
                        config.Logger.Debug("Retry attempt",
                                zap.Int("attempt", attempt+1),
                                zap.Int("max_attempts", config.MaxAttempts))
                }</span>

                <span class="cov0" title="0">err := fn(attempt)
                if err == nil </span><span class="cov0" title="0">{
                        if config.Logger != nil &amp;&amp; attempt &gt; 0 </span><span class="cov0" title="0">{
                                config.Logger.Info("Operation succeeded after retry",
                                        zap.Int("attempts", attempt+1))
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">lastErr = err

                // Check if the error is retryable
                if retryableErr, ok := err.(RetryableError); ok &amp;&amp; !retryableErr.IsRetryable() </span><span class="cov0" title="0">{
                        if config.Logger != nil </span><span class="cov0" title="0">{
                                config.Logger.Debug("Error is not retryable", zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                // Don't wait after the last attempt
                <span class="cov0" title="0">if attempt == config.MaxAttempts-1 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Calculate delay
                <span class="cov0" title="0">delay := calculateDelay(config, attempt)

                if onRetry != nil </span><span class="cov0" title="0">{
                        onRetry(attempt+1, err, delay)
                }</span>

                <span class="cov0" title="0">if config.Logger != nil </span><span class="cov0" title="0">{
                        config.Logger.Warn("Operation failed, retrying",
                                zap.Error(err),
                                zap.Int("attempt", attempt+1),
                                zap.Duration("delay", delay))
                }</span>

                // Wait for the delay or context cancellation
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                        // Continue to next attempt
                }
        }

        <span class="cov0" title="0">if onFinalError != nil </span><span class="cov0" title="0">{
                onFinalError(config.MaxAttempts, lastErr)
        }</span>

        <span class="cov0" title="0">if config.Logger != nil </span><span class="cov0" title="0">{
                config.Logger.Error("All retry attempts failed",
                        zap.Int("attempts", config.MaxAttempts),
                        zap.Error(lastErr))
        }</span>

        <span class="cov0" title="0">return lastErr</span>
}

// calculateDelay calculates the delay for the next retry attempt
func calculateDelay(config RetryConfig, attempt int) time.Duration <span class="cov0" title="0">{
        delay := float64(config.InitialDelay) * math.Pow(config.BackoffFactor, float64(attempt))

        // Apply maximum delay limit
        if delay &gt; float64(config.MaxDelay) </span><span class="cov0" title="0">{
                delay = float64(config.MaxDelay)
        }</span>

        // Apply jitter if enabled
        <span class="cov0" title="0">if config.Jitter </span><span class="cov0" title="0">{
                jitter := rand.Float64() * 0.1 * delay // 10% jitter
                delay += jitter
        }</span>

        <span class="cov0" title="0">return time.Duration(delay)</span>
}

// ExponentialBackoff implements exponential backoff retry strategy
type ExponentialBackoff struct {
        config RetryConfig
        logger *zap.Logger
}

// NewExponentialBackoff creates a new exponential backoff strategy
func NewExponentialBackoff(config RetryConfig) *ExponentialBackoff <span class="cov0" title="0">{
        if config.MaxAttempts &lt;= 0 </span><span class="cov0" title="0">{
                config.MaxAttempts = 3
        }</span>
        <span class="cov0" title="0">if config.InitialDelay &lt;= 0 </span><span class="cov0" title="0">{
                config.InitialDelay = 1 * time.Second
        }</span>
        <span class="cov0" title="0">if config.MaxDelay &lt;= 0 </span><span class="cov0" title="0">{
                config.MaxDelay = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if config.BackoffFactor &lt;= 0 </span><span class="cov0" title="0">{
                config.BackoffFactor = 2.0
        }</span>

        <span class="cov0" title="0">return &amp;ExponentialBackoff{
                config: config,
                logger: config.Logger,
        }</span>
}

// Execute executes a function with exponential backoff
func (eb *ExponentialBackoff) Execute(ctx context.Context, fn RetryFunc) error <span class="cov0" title="0">{
        return Retry(ctx, eb.config, fn)
}</span>

// ExecuteWithCallbacks executes a function with exponential backoff and callbacks
func (eb *ExponentialBackoff) ExecuteWithCallbacks(
        ctx context.Context,
        fn RetryWithCallback,
        onRetry func(attempt int, err error, delay time.Duration),
        onFinalError func(attempt int, err error),
) error <span class="cov0" title="0">{
        return RetryWithCallbacks(ctx, eb.config, fn, onRetry, onFinalError)
}</span>

// BulkheadConfig contains configuration for bulkhead pattern
type BulkheadConfig struct {
        MaxConcurrent int
        QueueSize     int
        Timeout       time.Duration
        Logger        *zap.Logger
}

// Bulkhead implements the bulkhead pattern for resource isolation
type Bulkhead struct {
        semaphore chan struct{}
        queue     chan func()
        config    BulkheadConfig
        logger    *zap.Logger
}

// NewBulkhead creates a new bulkhead
func NewBulkhead(config BulkheadConfig) *Bulkhead <span class="cov0" title="0">{
        if config.MaxConcurrent &lt;= 0 </span><span class="cov0" title="0">{
                config.MaxConcurrent = 10
        }</span>
        <span class="cov0" title="0">if config.QueueSize &lt;= 0 </span><span class="cov0" title="0">{
                config.QueueSize = 100
        }</span>
        <span class="cov0" title="0">if config.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                config.Timeout = 30 * time.Second
        }</span>

        <span class="cov0" title="0">bulkhead := &amp;Bulkhead{
                semaphore: make(chan struct{}, config.MaxConcurrent),
                queue:     make(chan func(), config.QueueSize),
                config:    config,
                logger:    config.Logger,
        }

        // Pre-fill semaphore
        for i := 0; i &lt; config.MaxConcurrent; i++ </span><span class="cov0" title="0">{
                bulkhead.semaphore &lt;- struct{}{}
        }</span>

        <span class="cov0" title="0">return bulkhead</span>
}

// Execute executes a function with bulkhead protection
func (b *Bulkhead) Execute(ctx context.Context, fn func() error) error <span class="cov0" title="0">{
        // Try to acquire a permit
        select </span>{
        case &lt;-b.semaphore:<span class="cov0" title="0">
                defer func() </span><span class="cov0" title="0">{
                        b.semaphore &lt;- struct{}{} // Return permit
                }</span>()
                <span class="cov0" title="0">return fn()</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case &lt;-time.After(b.config.Timeout):<span class="cov0" title="0">
                if b.logger != nil </span><span class="cov0" title="0">{
                        b.logger.Warn("Bulkhead timeout", zap.Duration("timeout", b.config.Timeout))
                }</span>
                <span class="cov0" title="0">return NewRetryableError(context.DeadlineExceeded, true)</span>
        }
}

// GetStats returns bulkhead statistics
func (b *Bulkhead) GetStats() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "max_concurrent":    b.config.MaxConcurrent,
                "available_permits": len(b.semaphore),
                "queue_size":        b.config.QueueSize,
                "queue_length":      len(b.queue),
                "timeout":           b.config.Timeout,
        }
}</span>

// HealthChecker provides health checking capabilities
type HealthChecker struct {
        checks   map[string]HealthCheck
        mutex    sync.RWMutex
        logger   *zap.Logger
        interval time.Duration
        timeout  time.Duration
}

// HealthCheck represents a health check function
type HealthCheck struct {
        Name     string
        Check    func(ctx context.Context) error
        Interval time.Duration
        Timeout  time.Duration
        Critical bool
}

// HealthStatus represents the health status
type HealthStatus struct {
        Healthy bool                   `json:"healthy"`
        Checks  map[string]CheckResult `json:"checks"`
}

// CheckResult represents the result of a health check
type CheckResult struct {
        Healthy   bool      `json:"healthy"`
        Error     string    `json:"error,omitempty"`
        Duration  int64     `json:"duration_ms"`
        Timestamp time.Time `json:"timestamp"`
        Critical  bool      `json:"critical"`
}

// NewHealthChecker creates a new health checker
func NewHealthChecker(interval, timeout time.Duration, logger *zap.Logger) *HealthChecker <span class="cov0" title="0">{
        return &amp;HealthChecker{
                checks:   make(map[string]HealthCheck),
                logger:   logger,
                interval: interval,
                timeout:  timeout,
        }
}</span>

// AddCheck adds a health check
func (hc *HealthChecker) AddCheck(check HealthCheck) <span class="cov0" title="0">{
        hc.mutex.Lock()
        defer hc.mutex.Unlock()

        if check.Timeout == 0 </span><span class="cov0" title="0">{
                check.Timeout = hc.timeout
        }</span>

        <span class="cov0" title="0">hc.checks[check.Name] = check

        if hc.logger != nil </span><span class="cov0" title="0">{
                hc.logger.Info("Health check added",
                        zap.String("name", check.Name),
                        zap.Bool("critical", check.Critical))
        }</span>
}

// RemoveCheck removes a health check
func (hc *HealthChecker) RemoveCheck(name string) <span class="cov0" title="0">{
        hc.mutex.Lock()
        defer hc.mutex.Unlock()

        delete(hc.checks, name)

        if hc.logger != nil </span><span class="cov0" title="0">{
                hc.logger.Info("Health check removed", zap.String("name", name))
        }</span>
}

// CheckHealth performs all health checks
func (hc *HealthChecker) CheckHealth(ctx context.Context) HealthStatus <span class="cov0" title="0">{
        hc.mutex.RLock()
        checks := make(map[string]HealthCheck)
        for name, check := range hc.checks </span><span class="cov0" title="0">{
                checks[name] = check
        }</span>
        <span class="cov0" title="0">hc.mutex.RUnlock()

        results := make(map[string]CheckResult)
        overall := true

        for name, check := range checks </span><span class="cov0" title="0">{
                result := hc.runCheck(ctx, check)
                results[name] = result

                if !result.Healthy &amp;&amp; check.Critical </span><span class="cov0" title="0">{
                        overall = false
                }</span>
        }

        <span class="cov0" title="0">return HealthStatus{
                Healthy: overall,
                Checks:  results,
        }</span>
}

// runCheck runs a single health check
func (hc *HealthChecker) runCheck(ctx context.Context, check HealthCheck) CheckResult <span class="cov0" title="0">{
        start := time.Now()

        checkCtx, cancel := context.WithTimeout(ctx, check.Timeout)
        defer cancel()

        err := check.Check(checkCtx)
        duration := time.Since(start)

        result := CheckResult{
                Healthy:   err == nil,
                Duration:  duration.Milliseconds(),
                Timestamp: time.Now(),
                Critical:  check.Critical,
        }

        if err != nil </span><span class="cov0" title="0">{
                result.Error = err.Error()
        }</span>

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "regexp"
        "strconv"
        "strings"
        "time"

        "catalogizer/internal/models"

        "go.uber.org/zap"
)

// Book and publication recognition provider with OCR and metadata APIs
type BookRecognitionProvider struct {
        logger      *zap.Logger
        httpClient  *http.Client
        baseURLs    map[string]string
        apiKeys     map[string]string
        rateLimiter map[string]*time.Ticker
}

// Google Books API structures
type GoogleBooksResponse struct {
        Kind       string           `json:"kind"`
        TotalItems int              `json:"totalItems"`
        Items      []GoogleBookItem `json:"items"`
}

type GoogleBookItem struct {
        Kind       string               `json:"kind"`
        ID         string               `json:"id"`
        ETag       string               `json:"etag"`
        SelfLink   string               `json:"selfLink"`
        VolumeInfo GoogleBookVolumeInfo `json:"volumeInfo"`
        SaleInfo   GoogleBookSaleInfo   `json:"saleInfo"`
        AccessInfo GoogleBookAccessInfo `json:"accessInfo"`
        SearchInfo GoogleBookSearchInfo `json:"searchInfo,omitempty"`
}

type GoogleBookVolumeInfo struct {
        Title               string                 `json:"title"`
        Subtitle            string                 `json:"subtitle,omitempty"`
        Authors             []string               `json:"authors,omitempty"`
        Publisher           string                 `json:"publisher,omitempty"`
        PublishedDate       string                 `json:"publishedDate,omitempty"`
        Description         string                 `json:"description,omitempty"`
        IndustryIdentifiers []GoogleBookIdentifier `json:"industryIdentifiers,omitempty"`
        ReadingModes        GoogleBookReadingModes `json:"readingModes"`
        PageCount           int                    `json:"pageCount,omitempty"`
        PrintType           string                 `json:"printType"`
        Categories          []string               `json:"categories,omitempty"`
        AverageRating       float64                `json:"averageRating,omitempty"`
        RatingsCount        int                    `json:"ratingsCount,omitempty"`
        MaturityRating      string                 `json:"maturityRating"`
        AllowAnonLogging    bool                   `json:"allowAnonLogging"`
        ContentVersion      string                 `json:"contentVersion"`
        PanelizationSummary GoogleBookPanelization `json:"panelizationSummary,omitempty"`
        ImageLinks          GoogleBookImageLinks   `json:"imageLinks,omitempty"`
        Language            string                 `json:"language"`
        PreviewLink         string                 `json:"previewLink"`
        InfoLink            string                 `json:"infoLink"`
        CanonicalVolumeLink string                 `json:"canonicalVolumeLink"`
        SeriesInfo          GoogleBookSeriesInfo   `json:"seriesInfo,omitempty"`
}

type GoogleBookIdentifier struct {
        Type       string `json:"type"`
        Identifier string `json:"identifier"`
}

type GoogleBookReadingModes struct {
        Text  bool `json:"text"`
        Image bool `json:"image"`
}

type GoogleBookPanelization struct {
        ContainsEpubBubbles  bool `json:"containsEpubBubbles"`
        ContainsImageBubbles bool `json:"containsImageBubbles"`
}

type GoogleBookImageLinks struct {
        SmallThumbnail string `json:"smallThumbnail,omitempty"`
        Thumbnail      string `json:"thumbnail,omitempty"`
        Small          string `json:"small,omitempty"`
        Medium         string `json:"medium,omitempty"`
        Large          string `json:"large,omitempty"`
        ExtraLarge     string `json:"extraLarge,omitempty"`
}

type GoogleBookSaleInfo struct {
        Country     string            `json:"country"`
        Saleability string            `json:"saleability"`
        IsEbook     bool              `json:"isEbook"`
        ListPrice   GoogleBookPrice   `json:"listPrice,omitempty"`
        RetailPrice GoogleBookPrice   `json:"retailPrice,omitempty"`
        BuyLink     string            `json:"buyLink,omitempty"`
        Offers      []GoogleBookOffer `json:"offers,omitempty"`
}

type GoogleBookPrice struct {
        Amount       float64 `json:"amount"`
        CurrencyCode string  `json:"currencyCode"`
}

type GoogleBookOffer struct {
        FinskyOfferType int             `json:"finskyOfferType"`
        ListPrice       GoogleBookPrice `json:"listPrice"`
        RetailPrice     GoogleBookPrice `json:"retailPrice"`
        GiftablePrice   GoogleBookPrice `json:"giftablePrice,omitempty"`
}

type GoogleBookAccessInfo struct {
        Country                string                       `json:"country"`
        Viewability            string                       `json:"viewability"`
        Embeddable             bool                         `json:"embeddable"`
        PublicDomain           bool                         `json:"publicDomain"`
        TextToSpeechPermission string                       `json:"textToSpeechPermission"`
        Epub                   GoogleBookFormatAvailability `json:"epub"`
        PDF                    GoogleBookFormatAvailability `json:"pdf"`
        WebReaderLink          string                       `json:"webReaderLink,omitempty"`
        AccessViewStatus       string                       `json:"accessViewStatus"`
        QuoteSharingAllowed    bool                         `json:"quoteSharingAllowed"`
}

type GoogleBookFormatAvailability struct {
        IsAvailable  bool   `json:"isAvailable"`
        AcsTokenLink string `json:"acsTokenLink,omitempty"`
}

type GoogleBookSearchInfo struct {
        TextSnippet string `json:"textSnippet"`
}

type GoogleBookSeriesInfo struct {
        Kind                 string `json:"kind"`
        BookDisplayNumber    string `json:"bookDisplayNumber"`
        VolumeDisplayNumber  string `json:"volumeDisplayNumber"`
        ShortSeriesBookTitle string `json:"shortSeriesBookTitle"`
}

// Open Library API structures
type OpenLibrarySearchResponse struct {
        NumFound      int                   `json:"numFound"`
        Start         int                   `json:"start"`
        NumFoundExact bool                  `json:"numFoundExact"`
        Docs          []OpenLibraryDocument `json:"docs"`
}

type OpenLibraryDocument struct {
        Key                   string    `json:"key"`
        Type                  string    `json:"type"`
        Seed                  []string  `json:"seed,omitempty"`
        Title                 string    `json:"title"`
        TitleSuggest          string    `json:"title_suggest,omitempty"`
        TitleSort             string    `json:"title_sort,omitempty"`
        Subtitle              string    `json:"subtitle,omitempty"`
        AlternativeTitle      []string  `json:"alternative_title,omitempty"`
        AlternativeSubtitle   []string  `json:"alternative_subtitle,omitempty"`
        Edition               []string  `json:"edition_name,omitempty"`
        FullTitle             string    `json:"full_title,omitempty"`
        AuthorKey             []string  `json:"author_key,omitempty"`
        AuthorName            []string  `json:"author_name,omitempty"`
        AuthorAlternativeName []string  `json:"author_alternative_name,omitempty"`
        AuthorFacet           []string  `json:"author_facet,omitempty"`
        ContributorName       []string  `json:"contributor,omitempty"`
        Subject               []string  `json:"subject,omitempty"`
        SubjectKey            []string  `json:"subject_key,omitempty"`
        SubjectFacet          []string  `json:"subject_facet,omitempty"`
        Place                 []string  `json:"place,omitempty"`
        PlaceKey              []string  `json:"place_key,omitempty"`
        PlaceFacet            []string  `json:"place_facet,omitempty"`
        Person                []string  `json:"person,omitempty"`
        PersonKey             []string  `json:"person_key,omitempty"`
        PersonFacet           []string  `json:"person_facet,omitempty"`
        Language              []string  `json:"language,omitempty"`
        PublisherName         []string  `json:"publisher,omitempty"`
        PublisherFacet        []string  `json:"publisher_facet,omitempty"`
        PublishDate           []string  `json:"publish_date,omitempty"`
        PublishYear           []int     `json:"publish_year,omitempty"`
        PublishPlace          []string  `json:"publish_place,omitempty"`
        FirstPublishYear      int       `json:"first_publish_year,omitempty"`
        NumberOfPagesMedian   int       `json:"number_of_pages_median,omitempty"`
        LccnSort              string    `json:"lccn_sort,omitempty"`
        EditionCount          int       `json:"edition_count"`
        EditionKey            []string  `json:"edition_key,omitempty"`
        PrintDisabled         []string  `json:"printdisabled,omitempty"`
        LendingEdition        string    `json:"lending_edition,omitempty"`
        LendingIdentifier     string    `json:"lending_identifier,omitempty"`
        ISBN                  []string  `json:"isbn,omitempty"`
        LastModified          time.Time `json:"last_modified_i"`
        EbookCount            int       `json:"ebook_count_i"`
        EbookAccess           string    `json:"ebook_access,omitempty"`
        HasFulltext           bool      `json:"has_fulltext"`
        PublicScan            bool      `json:"public_scan_b,omitempty"`
        CoverID               int       `json:"cover_i,omitempty"`
        CoverEditionKey       string    `json:"cover_edition_key,omitempty"`
        FirstSentence         []string  `json:"first_sentence,omitempty"`
        LCCN                  []string  `json:"lccn,omitempty"`
        OCLC                  []string  `json:"oclc,omitempty"`
        ContributorKey        []string  `json:"contributor_key,omitempty"`
        ID_Amazon             []string  `json:"id_amazon,omitempty"`
        ID_LibraryThing       []string  `json:"id_librarything,omitempty"`
        ID_Goodreads          []string  `json:"id_goodreads,omitempty"`
        ID_DepositoLegal      []string  `json:"id_dnb,omitempty"`
        ID_Wikisource         []string  `json:"id_wikisource,omitempty"`
}

// Crossref API structures (for academic publications)
type CrossrefResponse struct {
        Status  string          `json:"status"`
        Message CrossrefMessage `json:"message"`
}

type CrossrefMessage struct {
        Facets       map[string]interface{} `json:"facets,omitempty"`
        TotalResults int                    `json:"total-results"`
        Items        []CrossrefWork         `json:"items"`
        ItemsPerPage int                    `json:"items-per-page"`
        Query        map[string]interface{} `json:"query,omitempty"`
}

type CrossrefWork struct {
        Indexed             CrossrefDate           `json:"indexed"`
        ReferenceCount      int                    `json:"reference-count"`
        Publisher           string                 `json:"publisher"`
        Issue               string                 `json:"issue,omitempty"`
        License             []CrossrefLicense      `json:"license,omitempty"`
        Funder              []CrossrefFunder       `json:"funder,omitempty"`
        ContentDomain       CrossrefContentDomain  `json:"content-domain"`
        ShortContainerTitle []string               `json:"short-container-title,omitempty"`
        Published           CrossrefPartialDate    `json:"published,omitempty"`
        Abstract            string                 `json:"abstract,omitempty"`
        DOI                 string                 `json:"DOI"`
        Type                string                 `json:"type"`
        Created             CrossrefDate           `json:"created"`
        Page                string                 `json:"page,omitempty"`
        UpdatePolicy        string                 `json:"update-policy,omitempty"`
        Source              string                 `json:"source"`
        IsReferencedByCount int                    `json:"is-referenced-by-count"`
        Title               []string               `json:"title"`
        Prefix              string                 `json:"prefix"`
        Volume              string                 `json:"volume,omitempty"`
        Author              []CrossrefAuthor       `json:"author,omitempty"`
        Member              string                 `json:"member"`
        ContainerTitle      []string               `json:"container-title,omitempty"`
        OriginalTitle       []string               `json:"original-title,omitempty"`
        Language            string                 `json:"language,omitempty"`
        Link                []CrossrefLink         `json:"link,omitempty"`
        Deposited           CrossrefDate           `json:"deposited"`
        Score               float64                `json:"score"`
        Subtitle            []string               `json:"subtitle,omitempty"`
        ShortTitle          []string               `json:"short-title,omitempty"`
        Issued              CrossrefPartialDate    `json:"issued,omitempty"`
        ReferencesCount     int                    `json:"references-count"`
        JournalIssue        CrossrefJournalIssue   `json:"journal-issue,omitempty"`
        AlternativeID       []string               `json:"alternative-id,omitempty"`
        URL                 string                 `json:"URL,omitempty"`
        Relation            map[string]interface{} `json:"relation,omitempty"`
        ISSN                []string               `json:"ISSN,omitempty"`
        IssnType            []CrossrefIssnType     `json:"issn-type,omitempty"`
        Subject             []string               `json:"subject,omitempty"`
        PublishedOnline     CrossrefPartialDate    `json:"published-online,omitempty"`
        PublishedPrint      CrossrefPartialDate    `json:"published-print,omitempty"`
}

type CrossrefDate struct {
        DateParts [][]int   `json:"date-parts"`
        DateTime  time.Time `json:"date-time"`
        Timestamp int64     `json:"timestamp"`
}

type CrossrefPartialDate struct {
        DateParts [][]int `json:"date-parts"`
}

type CrossrefLicense struct {
        Start          CrossrefDate `json:"start"`
        ContentVersion string       `json:"content-version"`
        DelayInDays    int          `json:"delay-in-days"`
        URL            string       `json:"URL"`
}

type CrossrefFunder struct {
        DOI   string   `json:"DOI,omitempty"`
        Name  string   `json:"name"`
        Award []string `json:"award,omitempty"`
}

type CrossrefContentDomain struct {
        Domain               []string `json:"domain"`
        CrossmarkRestriction bool     `json:"crossmark-restriction"`
}

type CrossrefAuthor struct {
        ORCID       string                `json:"ORCID,omitempty"`
        Given       string                `json:"given,omitempty"`
        Family      string                `json:"family,omitempty"`
        Sequence    string                `json:"sequence"`
        Affiliation []CrossrefAffiliation `json:"affiliation,omitempty"`
}

type CrossrefAffiliation struct {
        Name string `json:"name"`
}

type CrossrefLink struct {
        URL                 string `json:"URL"`
        ContentType         string `json:"content-type"`
        ContentVersion      string `json:"content-version"`
        IntendedApplication string `json:"intended-application"`
}

type CrossrefJournalIssue struct {
        Issue           string              `json:"issue,omitempty"`
        PublishedOnline CrossrefPartialDate `json:"published-online,omitempty"`
        PublishedPrint  CrossrefPartialDate `json:"published-print,omitempty"`
}

type CrossrefIssnType struct {
        Value string `json:"value"`
        Type  string `json:"type"`
}

// OCR Service structures
type OCRRequest struct {
        ImageData []byte            `json:"image_data"`
        ImageURL  string            `json:"image_url,omitempty"`
        Language  string            `json:"language,omitempty"`
        Options   map[string]string `json:"options,omitempty"`
}

type OCRResponse struct {
        Text       string            `json:"text"`
        Confidence float64           `json:"confidence"`
        Language   string            `json:"language"`
        Blocks     []OCRTextBlock    `json:"blocks"`
        Words      []OCRWord         `json:"words"`
        Lines      []OCRLine         `json:"lines"`
        Metadata   map[string]string `json:"metadata"`
}

type OCRTextBlock struct {
        Text        string         `json:"text"`
        Confidence  float64        `json:"confidence"`
        BoundingBox OCRBoundingBox `json:"bounding_box"`
        Lines       []OCRLine      `json:"lines"`
}

type OCRLine struct {
        Text        string         `json:"text"`
        Confidence  float64        `json:"confidence"`
        BoundingBox OCRBoundingBox `json:"bounding_box"`
        Words       []OCRWord      `json:"words"`
}

type OCRWord struct {
        Text        string         `json:"text"`
        Confidence  float64        `json:"confidence"`
        BoundingBox OCRBoundingBox `json:"bounding_box"`
}

type OCRBoundingBox struct {
        X      int `json:"x"`
        Y      int `json:"y"`
        Width  int `json:"width"`
        Height int `json:"height"`
}

// Text analysis for book content
type BookContentAnalysis struct {
        Language         string        `json:"language"`
        WordCount        int           `json:"word_count"`
        CharacterCount   int           `json:"character_count"`
        ParagraphCount   int           `json:"paragraph_count"`
        SentenceCount    int           `json:"sentence_count"`
        ReadabilityScore float64       `json:"readability_score"`
        Topics           []string      `json:"topics"`
        Keywords         []string      `json:"keywords"`
        Entities         []NamedEntity `json:"entities"`
        Metadata         BookMetadata  `json:"metadata"`
}

type NamedEntity struct {
        Text       string  `json:"text"`
        Label      string  `json:"label"`
        Confidence float64 `json:"confidence"`
        StartPos   int     `json:"start_pos"`
        EndPos     int     `json:"end_pos"`
}

type BookMetadata struct {
        Title           string              `json:"title"`
        Author          string              `json:"author"`
        Publisher       string              `json:"publisher"`
        PublicationDate string              `json:"publication_date"`
        ISBN            string              `json:"isbn"`
        Edition         string              `json:"edition"`
        ChapterTitles   []string            `json:"chapter_titles"`
        TableOfContents []TOCEntry          `json:"table_of_contents"`
        Bibliography    []BibliographyEntry `json:"bibliography"`
        Index           []IndexEntry        `json:"index"`
}

type TOCEntry struct {
        Title      string     `json:"title"`
        PageNumber int        `json:"page_number"`
        Level      int        `json:"level"`
        Children   []TOCEntry `json:"children,omitempty"`
}

type BibliographyEntry struct {
        Citation string   `json:"citation"`
        Type     string   `json:"type"`
        Authors  []string `json:"authors"`
        Title    string   `json:"title"`
        Year     int      `json:"year"`
}

type IndexEntry struct {
        Term       string       `json:"term"`
        Pages      []int        `json:"pages"`
        SubEntries []IndexEntry `json:"sub_entries,omitempty"`
}

func NewBookRecognitionProvider(logger *zap.Logger) *BookRecognitionProvider <span class="cov0" title="0">{
        return &amp;BookRecognitionProvider{
                logger:     logger,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                baseURLs: map[string]string{
                        "google_books":  "https://www.googleapis.com/books/v1",
                        "open_library":  "https://openlibrary.org",
                        "crossref":      "https://api.crossref.org",
                        "worldcat":      "https://www.worldcat.org/webservices",
                        "libgen":        "https://libgen.is/json.php",
                        "archive_org":   "https://archive.org",
                        "tesseract":     "https://api.ocr.space/parse",
                        "google_vision": "https://vision.googleapis.com/v1",
                },
                apiKeys: map[string]string{
                        "google_books":  "free_api_key",
                        "google_vision": "free_api_key",
                        "ocr_space":     "free_api_key",
                },
                rateLimiter: make(map[string]*time.Ticker),
        }
}</span>

func (p *BookRecognitionProvider) RecognizeMedia(ctx context.Context, req *MediaRecognitionRequest) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        p.logger.Info("Starting book/publication recognition",
                zap.String("file_path", req.FilePath),
                zap.String("media_type", string(req.MediaType)))

        // Extract metadata from filename
        title, author, isbn := p.extractBookMetadataFromFilename(req.FileName)

        p.logger.Debug("Extracted metadata from filename",
                zap.String("title", title),
                zap.String("author", author),
                zap.String("isbn", isbn))

        // Try OCR if image sample provided
        if len(req.ImageSample) &gt; 0 </span><span class="cov0" title="0">{
                if ocrResult, err := p.performOCR(ctx, req.ImageSample); err == nil </span><span class="cov0" title="0">{
                        if bookInfo := p.extractBookInfoFromOCR(ocrResult); bookInfo != nil </span><span class="cov0" title="0">{
                                title = bookInfo.Title
                                author = bookInfo.Author
                                isbn = bookInfo.ISBN
                        }</span>
                }
        }

        // Try text analysis if text sample provided
        <span class="cov0" title="0">if req.TextSample != "" </span><span class="cov0" title="0">{
                if analysis, err := p.analyzeBookContent(ctx, req.TextSample); err == nil </span><span class="cov0" title="0">{
                        if analysis.Metadata.Title != "" </span><span class="cov0" title="0">{
                                title = analysis.Metadata.Title
                        }</span>
                        <span class="cov0" title="0">if analysis.Metadata.Author != "" </span><span class="cov0" title="0">{
                                author = analysis.Metadata.Author
                        }</span>
                        <span class="cov0" title="0">if analysis.Metadata.ISBN != "" </span><span class="cov0" title="0">{
                                isbn = analysis.Metadata.ISBN
                        }</span>
                }
        }

        // Try different recognition methods based on available metadata
        <span class="cov0" title="0">if isbn != "" </span><span class="cov0" title="0">{
                if result, err := p.recognizeByISBN(ctx, isbn); err == nil </span><span class="cov0" title="0">{
                        p.logger.Info("Successfully recognized by ISBN",
                                zap.String("title", result.Title),
                                zap.Float64("confidence", result.Confidence))
                        return result, nil
                }</span>
        }

        <span class="cov0" title="0">if title != "" || author != "" </span><span class="cov0" title="0">{
                if result, err := p.recognizeByMetadata(ctx, title, author); err == nil </span><span class="cov0" title="0">{
                        p.logger.Info("Successfully recognized by metadata",
                                zap.String("title", result.Title),
                                zap.Float64("confidence", result.Confidence))
                        return result, nil
                }</span>
        }

        // Determine publication type
        <span class="cov0" title="0">mediaType := p.determinePublicationType(title, req.FileName, req.MimeType)

        // Fallback to basic recognition
        return p.basicBookRecognition(req, title, author, isbn, mediaType), nil</span>
}

func (p *BookRecognitionProvider) performOCR(ctx context.Context, imageData []byte) (*OCRResponse, error) <span class="cov0" title="0">{
        // Try OCR.space API first (free tier)
        if result, err := p.performOCRSpace(ctx, imageData); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try Tesseract via local processing
        <span class="cov0" title="0">if result, err := p.performTesseract(ctx, imageData); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("OCR processing failed")</span>
}

func (p *BookRecognitionProvider) performOCRSpace(ctx context.Context, imageData []byte) (*OCRResponse, error) <span class="cov0" title="0">{
        // OCR.space API implementation
        // This would encode the image and send it to OCR.space

        // Mock OCR result for demonstration
        return &amp;OCRResponse{
                Text:       "Sample OCR text from book cover or page",
                Confidence: 0.85,
                Language:   "en",
                Blocks: []OCRTextBlock{
                        {
                                Text:        "Book Title",
                                Confidence:  0.9,
                                BoundingBox: OCRBoundingBox{X: 50, Y: 100, Width: 200, Height: 30},
                        },
                        {
                                Text:        "Author Name",
                                Confidence:  0.8,
                                BoundingBox: OCRBoundingBox{X: 50, Y: 150, Width: 150, Height: 25},
                        },
                },
        }, nil
}</span>

func (p *BookRecognitionProvider) performTesseract(ctx context.Context, imageData []byte) (*OCRResponse, error) <span class="cov0" title="0">{
        // Local Tesseract processing would go here
        // For now, return a mock result
        return &amp;OCRResponse{
                Text:       "Tesseract OCR result",
                Confidence: 0.75,
                Language:   "en",
        }, nil
}</span>

func (p *BookRecognitionProvider) extractBookInfoFromOCR(ocrResult *OCRResponse) *BookMetadata <span class="cov0" title="0">{
        text := ocrResult.Text

        // Extract title (usually the largest/most prominent text)
        title := p.extractTitleFromOCR(text, ocrResult.Blocks)

        // Extract author (often appears below title)
        author := p.extractAuthorFromOCR(text, ocrResult.Blocks)

        // Extract ISBN (if visible)
        isbn := p.extractISBNFromText(text)

        if title == "" &amp;&amp; author == "" &amp;&amp; isbn == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;BookMetadata{
                Title:  title,
                Author: author,
                ISBN:   isbn,
        }</span>
}

func (p *BookRecognitionProvider) analyzeBookContent(ctx context.Context, text string) (*BookContentAnalysis, error) <span class="cov0" title="0">{
        analysis := &amp;BookContentAnalysis{
                Language:       p.detectLanguage(text),
                WordCount:      len(strings.Fields(text)),
                CharacterCount: len(text),
                ParagraphCount: len(strings.Split(text, "\n\n")),
                SentenceCount:  len(regexp.MustCompile(`[.!?]+`).FindAllString(text, -1)),
        }

        // Extract metadata from content
        analysis.Metadata = p.extractMetadataFromContent(text)

        // Extract topics and keywords
        analysis.Topics = p.extractTopics(text)
        analysis.Keywords = p.extractKeywords(text)

        // Calculate readability score
        analysis.ReadabilityScore = p.calculateReadabilityScore(text)

        return analysis, nil
}</span>

func (p *BookRecognitionProvider) recognizeByISBN(ctx context.Context, isbn string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Clean ISBN
        cleanISBN := p.cleanISBN(isbn)

        // Try Google Books API first
        if result, err := p.searchGoogleBooksByISBN(ctx, cleanISBN); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try Open Library as fallback
        <span class="cov0" title="0">if result, err := p.searchOpenLibraryByISBN(ctx, cleanISBN); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no results found for ISBN: %s", cleanISBN)</span>
}

func (p *BookRecognitionProvider) recognizeByMetadata(ctx context.Context, title, author string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Try Google Books API first
        if result, err := p.searchGoogleBooks(ctx, title, author); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try Open Library as fallback
        <span class="cov0" title="0">if result, err := p.searchOpenLibrary(ctx, title, author); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try Crossref for academic publications
        <span class="cov0" title="0">if result, err := p.searchCrossref(ctx, title, author); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no results found for title/author: %s / %s", title, author)</span>
}

func (p *BookRecognitionProvider) searchGoogleBooks(ctx context.Context, title, author string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}

        // Build search query
        query := ""
        if title != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf("intitle:%s", title)
        }</span>
        <span class="cov0" title="0">if author != "" </span><span class="cov0" title="0">{
                if query != "" </span><span class="cov0" title="0">{
                        query += "+"
                }</span>
                <span class="cov0" title="0">query += fmt.Sprintf("inauthor:%s", author)</span>
        }

        <span class="cov0" title="0">params.Set("q", query)
        params.Set("maxResults", "10")
        params.Set("printType", "books")
        params.Set("key", p.apiKeys["google_books"])

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/volumes?%s", p.baseURLs["google_books"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var booksResp GoogleBooksResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;booksResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(booksResp.Items) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no books found in Google Books")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := booksResp.Items[0]
        return p.convertGoogleBook(bestMatch), nil</span>
}

func (p *BookRecognitionProvider) searchGoogleBooksByISBN(ctx context.Context, isbn string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}
        params.Set("q", "isbn:"+isbn)
        params.Set("key", p.apiKeys["google_books"])

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/volumes?%s", p.baseURLs["google_books"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var booksResp GoogleBooksResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;booksResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(booksResp.Items) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no books found for ISBN in Google Books")
        }</span>

        <span class="cov0" title="0">return p.convertGoogleBook(booksResp.Items[0]), nil</span>
}

func (p *BookRecognitionProvider) convertGoogleBook(book GoogleBookItem) *MediaRecognitionResult <span class="cov0" title="0">{
        volumeInfo := book.VolumeInfo

        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("google_books_%s", book.ID),
                MediaType:         p.determineBookType(volumeInfo),
                Title:             volumeInfo.Title,
                Description:       volumeInfo.Description,
                PageCount:         volumeInfo.PageCount,
                Language:          volumeInfo.Language,
                Rating:            volumeInfo.AverageRating,
                Confidence:        p.calculateGoogleBooksConfidence(volumeInfo.AverageRating, volumeInfo.RatingsCount),
                RecognitionMethod: "google_books_api",
                APIProvider:       "Google Books",
        }

        // Set subtitle if available
        if volumeInfo.Subtitle != "" </span><span class="cov0" title="0">{
                result.Title = fmt.Sprintf("%s: %s", volumeInfo.Title, volumeInfo.Subtitle)
        }</span>

        // Set authors
        <span class="cov0" title="0">if len(volumeInfo.Authors) &gt; 0 </span><span class="cov0" title="0">{
                result.Author = volumeInfo.Authors[0]
                for _, author := range volumeInfo.Authors </span><span class="cov0" title="0">{
                        result.Authors = append(result.Authors, Person{
                                Name: author,
                                Role: "Author",
                        })
                }</span>
        }

        // Set publisher
        <span class="cov0" title="0">result.Publisher = volumeInfo.Publisher

        // Parse publication date
        if volumeInfo.PublishedDate != "" </span><span class="cov0" title="0">{
                result.Year = p.parseYear(volumeInfo.PublishedDate)
                if pubDate, err := p.parseDate(volumeInfo.PublishedDate); err == nil </span><span class="cov0" title="0">{
                        result.ReleaseDate = &amp;pubDate
                }</span>
        }

        // Extract ISBN
        <span class="cov0" title="0">for _, identifier := range volumeInfo.IndustryIdentifiers </span><span class="cov0" title="0">{
                if identifier.Type == "ISBN_13" </span><span class="cov0" title="0">{
                        result.ISBN13 = identifier.Identifier
                        result.ISBN = identifier.Identifier
                }</span> else<span class="cov0" title="0"> if identifier.Type == "ISBN_10" </span><span class="cov0" title="0">{
                        result.ISBN10 = identifier.Identifier
                        if result.ISBN == "" </span><span class="cov0" title="0">{
                                result.ISBN = identifier.Identifier
                        }</span>
                }
        }

        // Set categories as genres
        <span class="cov0" title="0">result.Genres = volumeInfo.Categories

        // Get cover images
        if volumeInfo.ImageLinks.Thumbnail != "" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        ID:      "google_books_thumbnail",
                        URL:     volumeInfo.ImageLinks.Thumbnail,
                        Quality: "medium",
                        Source:  "Google Books",
                })
        }</span>
        <span class="cov0" title="0">if volumeInfo.ImageLinks.SmallThumbnail != "" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        ID:      "google_books_small",
                        URL:     volumeInfo.ImageLinks.SmallThumbnail,
                        Quality: "small",
                        Source:  "Google Books",
                })
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "google_books_id": book.ID,
                "preview_link":    volumeInfo.PreviewLink,
                "info_link":       volumeInfo.InfoLink,
        }

        return result</span>
}

func (p *BookRecognitionProvider) searchOpenLibrary(ctx context.Context, title, author string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}

        // Build search query
        query := ""
        if title != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf("title:%s", title)
        }</span>
        <span class="cov0" title="0">if author != "" </span><span class="cov0" title="0">{
                if query != "" </span><span class="cov0" title="0">{
                        query += " AND "
                }</span>
                <span class="cov0" title="0">query += fmt.Sprintf("author:%s", author)</span>
        }

        <span class="cov0" title="0">params.Set("q", query)
        params.Set("limit", "10")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/search.json?%s", p.baseURLs["open_library"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResp OpenLibrarySearchResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResp.Docs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no books found in Open Library")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := searchResp.Docs[0]
        return p.convertOpenLibraryBook(bestMatch), nil</span>
}

func (p *BookRecognitionProvider) searchOpenLibraryByISBN(ctx context.Context, isbn string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}
        params.Set("q", "isbn:"+isbn)
        params.Set("limit", "1")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/search.json?%s", p.baseURLs["open_library"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResp OpenLibrarySearchResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResp.Docs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no books found for ISBN in Open Library")
        }</span>

        <span class="cov0" title="0">return p.convertOpenLibraryBook(searchResp.Docs[0]), nil</span>
}

func (p *BookRecognitionProvider) convertOpenLibraryBook(doc OpenLibraryDocument) *MediaRecognitionResult <span class="cov0" title="0">{
        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("open_library_%s", strings.TrimPrefix(doc.Key, "/works/")),
                MediaType:         MediaTypeBook,
                Title:             doc.Title,
                PageCount:         doc.NumberOfPagesMedian,
                Confidence:        p.calculateOpenLibraryConfidence(doc.EditionCount, doc.EbookCount),
                RecognitionMethod: "open_library_api",
                APIProvider:       "Open Library",
        }

        // Set subtitle
        if doc.Subtitle != "" </span><span class="cov0" title="0">{
                result.Title = fmt.Sprintf("%s: %s", doc.Title, doc.Subtitle)
        }</span>

        // Set authors
        <span class="cov0" title="0">if len(doc.AuthorName) &gt; 0 </span><span class="cov0" title="0">{
                result.Author = doc.AuthorName[0]
                for _, author := range doc.AuthorName </span><span class="cov0" title="0">{
                        result.Authors = append(result.Authors, Person{
                                Name: author,
                                Role: "Author",
                        })
                }</span>
        }

        // Set publisher
        <span class="cov0" title="0">if len(doc.PublisherName) &gt; 0 </span><span class="cov0" title="0">{
                result.Publisher = doc.PublisherName[0]
        }</span>

        // Set publication year
        <span class="cov0" title="0">if doc.FirstPublishYear &gt; 0 </span><span class="cov0" title="0">{
                result.Year = doc.FirstPublishYear
        }</span>

        // Set ISBN
        <span class="cov0" title="0">if len(doc.ISBN) &gt; 0 </span><span class="cov0" title="0">{
                result.ISBN = doc.ISBN[0]
                // Determine ISBN-10 vs ISBN-13
                for _, isbn := range doc.ISBN </span><span class="cov0" title="0">{
                        if len(isbn) == 10 </span><span class="cov0" title="0">{
                                result.ISBN10 = isbn
                        }</span> else<span class="cov0" title="0"> if len(isbn) == 13 </span><span class="cov0" title="0">{
                                result.ISBN13 = isbn
                        }</span>
                }
        }

        // Set subjects as genres
        <span class="cov0" title="0">result.Genres = doc.Subject

        // Get cover image
        if doc.CoverID &gt; 0 </span><span class="cov0" title="0">{
                coverURL := fmt.Sprintf("https://covers.openlibrary.org/b/id/%d-L.jpg", doc.CoverID)
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        ID:      fmt.Sprintf("open_library_%d", doc.CoverID),
                        URL:     coverURL,
                        Quality: "large",
                        Source:  "Open Library",
                })
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "open_library_key": doc.Key,
        }
        if len(doc.ID_Goodreads) &gt; 0 </span><span class="cov0" title="0">{
                result.ExternalIDs["goodreads_id"] = doc.ID_Goodreads[0]
        }</span>

        <span class="cov0" title="0">return result</span>
}

func (p *BookRecognitionProvider) searchCrossref(ctx context.Context, title, author string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}

        // Build search query for academic publications
        query := ""
        if title != "" </span><span class="cov0" title="0">{
                query += title
        }</span>
        <span class="cov0" title="0">if author != "" </span><span class="cov0" title="0">{
                if query != "" </span><span class="cov0" title="0">{
                        query += " "
                }</span>
                <span class="cov0" title="0">query += author</span>
        }

        <span class="cov0" title="0">params.Set("query", query)
        params.Set("rows", "10")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/works?%s", p.baseURLs["crossref"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var crossrefResp CrossrefResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;crossrefResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(crossrefResp.Message.Items) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no publications found in Crossref")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := crossrefResp.Message.Items[0]
        return p.convertCrossrefWork(bestMatch), nil</span>
}

func (p *BookRecognitionProvider) convertCrossrefWork(work CrossrefWork) *MediaRecognitionResult <span class="cov0" title="0">{
        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("crossref_%s", work.DOI),
                MediaType:         p.mapCrossrefType(work.Type),
                DOI:               work.DOI,
                Publisher:         work.Publisher,
                Confidence:        work.Score,
                RecognitionMethod: "crossref_api",
                APIProvider:       "Crossref",
        }

        // Set title
        if len(work.Title) &gt; 0 </span><span class="cov0" title="0">{
                result.Title = work.Title[0]
        }</span>

        // Set authors
        <span class="cov0" title="0">if len(work.Author) &gt; 0 </span><span class="cov0" title="0">{
                result.Author = fmt.Sprintf("%s %s", work.Author[0].Given, work.Author[0].Family)
                for _, author := range work.Author </span><span class="cov0" title="0">{
                        fullName := fmt.Sprintf("%s %s", author.Given, author.Family)
                        result.Authors = append(result.Authors, Person{
                                Name: fullName,
                                Role: "Author",
                        })
                }</span>
        }

        // Set publication date
        <span class="cov0" title="0">if len(work.Issued.DateParts) &gt; 0 &amp;&amp; len(work.Issued.DateParts[0]) &gt; 0 </span><span class="cov0" title="0">{
                result.Year = work.Issued.DateParts[0][0]
        }</span>

        // Set journal/container title
        <span class="cov0" title="0">if len(work.ContainerTitle) &gt; 0 </span><span class="cov0" title="0">{
                result.Series = work.ContainerTitle[0]
        }</span>

        // Set volume and issue
        <span class="cov0" title="0">if work.Volume != "" </span><span class="cov0" title="0">{
                if vol, err := strconv.Atoi(work.Volume); err == nil </span><span class="cov0" title="0">{
                        result.Volume = vol
                }</span>
        }
        <span class="cov0" title="0">if work.Issue != "" </span><span class="cov0" title="0">{
                if issue, err := strconv.Atoi(work.Issue); err == nil </span><span class="cov0" title="0">{
                        result.Issue = issue
                }</span>
        }

        // Set ISSN
        <span class="cov0" title="0">if len(work.ISSN) &gt; 0 </span><span class="cov0" title="0">{
                result.ISSN = work.ISSN[0]
        }</span>

        // Set subjects as genres
        <span class="cov0" title="0">result.Genres = work.Subject

        // Set external IDs
        result.ExternalIDs = map[string]string{
                "doi": work.DOI,
        }
        if work.URL != "" </span><span class="cov0" title="0">{
                result.ExternalIDs["url"] = work.URL
        }</span>

        <span class="cov0" title="0">return result</span>
}

func (p *BookRecognitionProvider) basicBookRecognition(req *MediaRecognitionRequest, title, author, isbn string, mediaType MediaType) *MediaRecognitionResult <span class="cov0" title="0">{
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("basic_book_%s_%d", strings.ReplaceAll(title, " ", "_"), time.Now().Unix()),
                MediaType:         mediaType,
                Title:             title,
                Author:            author,
                ISBN:              isbn,
                Confidence:        0.3,
                RecognitionMethod: "filename_parsing",
                APIProvider:       "basic",
                ExternalIDs:       make(map[string]string),
        }
}</span>

// Helper methods
func (p *BookRecognitionProvider) extractBookMetadataFromFilename(filename string) (title, author, isbn string) <span class="cov0" title="0">{
        // Remove file extension
        baseName := strings.TrimSuffix(filename, "."+p.getFileExtension(filename))

        // Extract ISBN pattern
        isbnPattern := regexp.MustCompile(`\b(?:ISBN[-\s]*(?:10|13)?[-\s]*[:\s]?)?(?:97[89][-\s]?)?(?:\d[-\s]?){9}[\dXx]\b`)
        if matches := isbnPattern.FindString(baseName); matches != "" </span><span class="cov0" title="0">{
                isbn = p.cleanISBN(matches)
                // Remove ISBN from filename
                baseName = isbnPattern.ReplaceAllString(baseName, "")
        }</span>

        // Common patterns for books:
        // Author - Title
        // Title - Author
        // Author (Year) Title
        // Title by Author

        // Pattern: "by Author"
        <span class="cov0" title="0">byPattern := regexp.MustCompile(`\s+by\s+(.+)$`)
        if matches := byPattern.FindStringSubmatch(baseName); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                author = strings.TrimSpace(matches[1])
                title = strings.TrimSpace(byPattern.ReplaceAllString(baseName, ""))
                return title, author, isbn
        }</span>

        // Pattern: Author - Title or Title - Author
        <span class="cov0" title="0">if parts := strings.Split(baseName, " - "); len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                // Try to determine which is author and which is title
                if p.looksLikeAuthorName(parts[0]) </span><span class="cov0" title="0">{
                        author = strings.TrimSpace(parts[0])
                        title = strings.TrimSpace(parts[1])
                }</span> else<span class="cov0" title="0"> {
                        title = strings.TrimSpace(parts[0])
                        author = strings.TrimSpace(parts[1])
                }</span>
                <span class="cov0" title="0">return title, author, isbn</span>
        }

        // Pattern: Author (Year) Title
        <span class="cov0" title="0">yearPattern := regexp.MustCompile(`^(.+?)\s*\((\d{4})\)\s*(.+)$`)
        if matches := yearPattern.FindStringSubmatch(baseName); len(matches) == 4 </span><span class="cov0" title="0">{
                author = strings.TrimSpace(matches[1])
                title = strings.TrimSpace(matches[3])
                return title, author, isbn
        }</span>

        // Fallback: use entire filename as title
        <span class="cov0" title="0">title = baseName
        return title, author, isbn</span>
}

func (p *BookRecognitionProvider) looksLikeAuthorName(str string) bool <span class="cov0" title="0">{
        // Simple heuristic: author names often have 2-3 words and proper capitalization
        words := strings.Fields(str)
        if len(words) &lt; 2 || len(words) &gt; 4 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if words look like names (capitalized)
        <span class="cov0" title="0">for _, word := range words </span><span class="cov0" title="0">{
                if len(word) &gt; 0 &amp;&amp; strings.ToUpper(word[:1]) != word[:1] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (p *BookRecognitionProvider) extractTitleFromOCR(text string, blocks []OCRTextBlock) string <span class="cov0" title="0">{
        // Find the largest text block (usually the title)
        var largestBlock OCRTextBlock
        maxArea := 0

        for _, block := range blocks </span><span class="cov0" title="0">{
                area := block.BoundingBox.Width * block.BoundingBox.Height
                if area &gt; maxArea &amp;&amp; block.Confidence &gt; 0.8 </span><span class="cov0" title="0">{
                        maxArea = area
                        largestBlock = block
                }</span>
        }

        <span class="cov0" title="0">if largestBlock.Text != "" </span><span class="cov0" title="0">{
                return strings.TrimSpace(largestBlock.Text)
        }</span>

        // Fallback: extract first line that looks like a title
        <span class="cov0" title="0">lines := strings.Split(text, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if len(line) &gt; 5 &amp;&amp; len(line) &lt; 100 &amp;&amp; !strings.Contains(line, "ISBN") </span><span class="cov0" title="0">{
                        return line
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func (p *BookRecognitionProvider) extractAuthorFromOCR(text string, blocks []OCRTextBlock) string <span class="cov0" title="0">{
        // Look for "by" pattern
        byPattern := regexp.MustCompile(`(?i)by\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)`)
        if matches := byPattern.FindStringSubmatch(text); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                return strings.TrimSpace(matches[1])
        }</span>

        // Look for author-like text blocks (smaller than title, proper case)
        <span class="cov0" title="0">for _, block := range blocks </span><span class="cov0" title="0">{
                if block.Confidence &gt; 0.7 &amp;&amp; p.looksLikeAuthorName(block.Text) </span><span class="cov0" title="0">{
                        return strings.TrimSpace(block.Text)
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func (p *BookRecognitionProvider) extractISBNFromText(text string) string <span class="cov0" title="0">{
        isbnPattern := regexp.MustCompile(`\b(?:ISBN[-\s]*(?:10|13)?[-\s]*[:\s]?)?(?:97[89][-\s]?)?(?:\d[-\s]?){9}[\dXx]\b`)
        if match := isbnPattern.FindString(text); match != "" </span><span class="cov0" title="0">{
                return p.cleanISBN(match)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (p *BookRecognitionProvider) cleanISBN(isbn string) string <span class="cov0" title="0">{
        // Remove all non-digit characters except X
        cleaned := regexp.MustCompile(`[^\dXx]`).ReplaceAllString(isbn, "")
        return strings.ToUpper(cleaned)
}</span>

func (p *BookRecognitionProvider) extractMetadataFromContent(text string) BookMetadata <span class="cov0" title="0">{
        metadata := BookMetadata{}

        // Extract title from first significant line
        lines := strings.Split(text, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if len(line) &gt; 10 &amp;&amp; len(line) &lt; 100 </span><span class="cov0" title="0">{
                        metadata.Title = line
                        break</span>
                }
        }

        // Extract chapter titles
        <span class="cov0" title="0">chapterPattern := regexp.MustCompile(`(?i)^(?:chapter|ch\.?)\s+\d+[\.\:\s]+(.+)$`)
        for _, line := range lines </span><span class="cov0" title="0">{
                if matches := chapterPattern.FindStringSubmatch(strings.TrimSpace(line)); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        metadata.ChapterTitles = append(metadata.ChapterTitles, matches[1])
                }</span>
        }

        <span class="cov0" title="0">return metadata</span>
}

func (p *BookRecognitionProvider) detectLanguage(text string) string <span class="cov0" title="0">{
        // Simple language detection based on common words
        // This would be replaced with a proper language detection library

        englishWords := []string{"the", "and", "of", "to", "a", "in", "is", "it", "you", "that"}
        spanishWords := []string{"el", "la", "de", "que", "y", "en", "un", "es", "se", "no"}
        frenchWords := []string{"le", "de", "et", "", "un", "il", "tre", "et", "en", "avoir"}

        lowerText := strings.ToLower(text)

        englishCount := 0
        for _, word := range englishWords </span><span class="cov0" title="0">{
                englishCount += strings.Count(lowerText, " "+word+" ")
        }</span>

        <span class="cov0" title="0">spanishCount := 0
        for _, word := range spanishWords </span><span class="cov0" title="0">{
                spanishCount += strings.Count(lowerText, " "+word+" ")
        }</span>

        <span class="cov0" title="0">frenchCount := 0
        for _, word := range frenchWords </span><span class="cov0" title="0">{
                frenchCount += strings.Count(lowerText, " "+word+" ")
        }</span>

        <span class="cov0" title="0">if englishCount &gt;= spanishCount &amp;&amp; englishCount &gt;= frenchCount </span><span class="cov0" title="0">{
                return "en"
        }</span> else<span class="cov0" title="0"> if spanishCount &gt;= frenchCount </span><span class="cov0" title="0">{
                return "es"
        }</span> else<span class="cov0" title="0"> {
                return "fr"
        }</span>
}

func (p *BookRecognitionProvider) extractTopics(text string) []string <span class="cov0" title="0">{
        // Simple topic extraction - would be replaced with NLP library
        topics := []string{}

        // Look for capitalized phrases that might be topics
        topicPattern := regexp.MustCompile(`\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b`)
        matches := topicPattern.FindAllString(text, -1)

        topicCount := make(map[string]int)
        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt; 3 </span><span class="cov0" title="0">{ // Filter out short matches
                        topicCount[match]++
                }</span>
        }

        // Return most frequent topics
        <span class="cov0" title="0">for topic, count := range topicCount </span><span class="cov0" title="0">{
                if count &gt; 1 </span><span class="cov0" title="0">{ // Topic appears multiple times
                        topics = append(topics, topic)
                }</span>
        }

        <span class="cov0" title="0">return topics</span>
}

func (p *BookRecognitionProvider) extractKeywords(text string) []string <span class="cov0" title="0">{
        // Simple keyword extraction
        words := strings.Fields(strings.ToLower(text))
        wordCount := make(map[string]int)

        // Count word frequency, excluding common words
        stopWords := map[string]bool{
                "the": true, "and": true, "of": true, "to": true, "a": true,
                "in": true, "is": true, "it": true, "you": true, "that": true,
                "he": true, "was": true, "for": true, "on": true, "are": true,
        }

        for _, word := range words </span><span class="cov0" title="0">{
                word = regexp.MustCompile(`[^\w]`).ReplaceAllString(word, "")
                if len(word) &gt; 3 &amp;&amp; !stopWords[word] </span><span class="cov0" title="0">{
                        wordCount[word]++
                }</span>
        }

        // Return most frequent keywords
        <span class="cov0" title="0">var keywords []string
        for word, count := range wordCount </span><span class="cov0" title="0">{
                if count &gt; 2 </span><span class="cov0" title="0">{ // Word appears multiple times
                        keywords = append(keywords, word)
                }</span>
        }

        <span class="cov0" title="0">return keywords</span>
}

func (p *BookRecognitionProvider) calculateReadabilityScore(text string) float64 <span class="cov0" title="0">{
        // Simple Flesch Reading Ease approximation
        sentences := len(regexp.MustCompile(`[.!?]+`).FindAllString(text, -1))
        words := len(strings.Fields(text))
        syllables := p.countSyllables(text)

        if sentences == 0 || words == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">avgSentenceLength := float64(words) / float64(sentences)
        avgSyllablesPerWord := float64(syllables) / float64(words)

        score := 206.835 - 1.015*avgSentenceLength - 84.6*avgSyllablesPerWord

        // Normalize to 0-1 scale
        if score &lt; 0 </span><span class="cov0" title="0">{
                score = 0
        }</span> else<span class="cov0" title="0"> if score &gt; 100 </span><span class="cov0" title="0">{
                score = 100
        }</span>

        <span class="cov0" title="0">return score / 100.0</span>
}

func (p *BookRecognitionProvider) countSyllables(text string) int <span class="cov0" title="0">{
        // Simple syllable counting approximation
        words := strings.Fields(strings.ToLower(text))
        syllables := 0

        for _, word := range words </span><span class="cov0" title="0">{
                wordSyllables := 0
                vowels := "aeiouy"
                lastWasVowel := false

                for _, char := range word </span><span class="cov0" title="0">{
                        isVowel := strings.ContainsRune(vowels, char)
                        if isVowel &amp;&amp; !lastWasVowel </span><span class="cov0" title="0">{
                                wordSyllables++
                        }</span>
                        <span class="cov0" title="0">lastWasVowel = isVowel</span>
                }

                // At least one syllable per word
                <span class="cov0" title="0">if wordSyllables == 0 </span><span class="cov0" title="0">{
                        wordSyllables = 1
                }</span>

                <span class="cov0" title="0">syllables += wordSyllables</span>
        }

        <span class="cov0" title="0">return syllables</span>
}

func (p *BookRecognitionProvider) determinePublicationType(title, filename, mimeType string) MediaType <span class="cov0" title="0">{
        filename = strings.ToLower(filename)
        title = strings.ToLower(title)

        // Check for comic book patterns
        comicPatterns := []string{"comic", "manga", "graphic novel", "superhero", "marvel", "dc comics"}
        for _, pattern := range comicPatterns </span><span class="cov0" title="0">{
                if strings.Contains(filename, pattern) || strings.Contains(title, pattern) </span><span class="cov0" title="0">{
                        return MediaTypeComicBook
                }</span>
        }

        // Check for magazine patterns
        <span class="cov0" title="0">magazinePatterns := []string{"magazine", "issue", "vol.", "monthly", "weekly", "quarterly"}
        for _, pattern := range magazinePatterns </span><span class="cov0" title="0">{
                if strings.Contains(filename, pattern) || strings.Contains(title, pattern) </span><span class="cov0" title="0">{
                        return MediaTypeMagazine
                }</span>
        }

        // Check for academic journal patterns
        <span class="cov0" title="0">journalPatterns := []string{"journal", "proceedings", "conference", "symposium", "research"}
        for _, pattern := range journalPatterns </span><span class="cov0" title="0">{
                if strings.Contains(filename, pattern) || strings.Contains(title, pattern) </span><span class="cov0" title="0">{
                        return MediaTypeJournal
                }</span>
        }

        // Check for manual patterns
        <span class="cov0" title="0">manualPatterns := []string{"manual", "guide", "handbook", "reference", "documentation"}
        for _, pattern := range manualPatterns </span><span class="cov0" title="0">{
                if strings.Contains(filename, pattern) || strings.Contains(title, pattern) </span><span class="cov0" title="0">{
                        return MediaTypeManual
                }</span>
        }

        // Default to book
        <span class="cov0" title="0">return MediaTypeBook</span>
}

func (p *BookRecognitionProvider) determineBookType(volumeInfo GoogleBookVolumeInfo) MediaType <span class="cov0" title="0">{
        // Check print type
        if volumeInfo.PrintType == "MAGAZINE" </span><span class="cov0" title="0">{
                return MediaTypeMagazine
        }</span>

        // Check categories
        <span class="cov0" title="0">for _, category := range volumeInfo.Categories </span><span class="cov0" title="0">{
                category = strings.ToLower(category)
                if strings.Contains(category, "comic") || strings.Contains(category, "graphic") </span><span class="cov0" title="0">{
                        return MediaTypeComicBook
                }</span>
                <span class="cov0" title="0">if strings.Contains(category, "magazine") || strings.Contains(category, "periodical") </span><span class="cov0" title="0">{
                        return MediaTypeMagazine
                }</span>
                <span class="cov0" title="0">if strings.Contains(category, "reference") || strings.Contains(category, "manual") </span><span class="cov0" title="0">{
                        return MediaTypeManual
                }</span>
        }

        <span class="cov0" title="0">return MediaTypeBook</span>
}

func (p *BookRecognitionProvider) mapCrossrefType(crossrefType string) MediaType <span class="cov0" title="0">{
        switch strings.ToLower(crossrefType) </span>{
        case "journal-article":<span class="cov0" title="0">
                return MediaTypeJournal</span>
        case "book-chapter", "book":<span class="cov0" title="0">
                return MediaTypeBook</span>
        case "proceedings-article":<span class="cov0" title="0">
                return MediaTypeJournal</span>
        case "reference-entry":<span class="cov0" title="0">
                return MediaTypeManual</span>
        default:<span class="cov0" title="0">
                return MediaTypeBook</span>
        }
}

func (p *BookRecognitionProvider) getFileExtension(filename string) string <span class="cov0" title="0">{
        parts := strings.Split(filename, ".")
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                return parts[len(parts)-1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (p *BookRecognitionProvider) parseYear(dateStr string) int <span class="cov0" title="0">{
        yearPattern := regexp.MustCompile(`(\d{4})`)
        if matches := yearPattern.FindStringSubmatch(dateStr); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                if year, err := strconv.Atoi(matches[1]); err == nil </span><span class="cov0" title="0">{
                        return year
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func (p *BookRecognitionProvider) parseDate(dateStr string) (time.Time, error) <span class="cov0" title="0">{
        formats := []string{
                "2006-01-02",
                "2006-01",
                "2006",
                "January 2, 2006",
                "Jan 2, 2006",
                "2006-01-02T15:04:05Z",
        }

        for _, format := range formats </span><span class="cov0" title="0">{
                if date, err := time.Parse(format, dateStr); err == nil </span><span class="cov0" title="0">{
                        return date, nil
                }</span>
        }

        <span class="cov0" title="0">return time.Time{}, fmt.Errorf("unable to parse date: %s", dateStr)</span>
}

func (p *BookRecognitionProvider) calculateGoogleBooksConfidence(rating float64, ratingCount int) float64 <span class="cov0" title="0">{
        confidence := 0.5

        if rating &gt; 4.0 &amp;&amp; ratingCount &gt; 100 </span><span class="cov0" title="0">{
                confidence += 0.3
        }</span> else<span class="cov0" title="0"> if rating &gt; 3.5 &amp;&amp; ratingCount &gt; 50 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *BookRecognitionProvider) calculateOpenLibraryConfidence(editionCount, ebookCount int) float64 <span class="cov0" title="0">{
        confidence := 0.5

        if editionCount &gt; 5 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">if ebookCount &gt; 0 </span><span class="cov0" title="0">{
                confidence += 0.1
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *BookRecognitionProvider) generateID(input string) string <span class="cov0" title="0">{
        hash := md5.Sum([]byte(input))
        return hex.EncodeToString(hash[:])[:12]
}</span>

// RecognitionProvider interface implementation
func (p *BookRecognitionProvider) GetProviderName() string <span class="cov0" title="0">{
        return "book_recognition"
}</span>

func (p *BookRecognitionProvider) SupportsMediaType(mediaType MediaType) bool <span class="cov0" title="0">{
        supportedTypes := []MediaType{
                MediaTypeBook,
                MediaTypeComicBook,
                MediaTypeMagazine,
                MediaTypeNewspaper,
                MediaTypeJournal,
                MediaTypeManual,
                MediaTypeEbook,
        }

        for _, supported := range supportedTypes </span><span class="cov0" title="0">{
                if mediaType == supported </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (p *BookRecognitionProvider) GetConfidenceThreshold() float64 <span class="cov0" title="0">{
        return 0.4
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "database/sql"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "time"

        "go.uber.org/zap"
)

type CacheService struct {
        db     *sql.DB
        logger *zap.Logger
}

type CacheEntry struct {
        ID        int64     `json:"id" db:"id"`
        CacheKey  string    `json:"cache_key" db:"cache_key"`
        Value     string    `json:"value" db:"value"`
        ExpiresAt time.Time `json:"expires_at" db:"expires_at"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
        UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

type MediaMetadataCache struct {
        ID           int64     `json:"id"`
        MediaItemID  int64     `json:"media_item_id"`
        MetadataType string    `json:"metadata_type"`
        Provider     string    `json:"provider"`
        Data         string    `json:"data"`
        Quality      float64   `json:"quality"`
        ExpiresAt    time.Time `json:"expires_at"`
        CreatedAt    time.Time `json:"created_at"`
        UpdatedAt    time.Time `json:"updated_at"`
}

type APICache struct {
        ID          int64     `json:"id"`
        Provider    string    `json:"provider"`
        Endpoint    string    `json:"endpoint"`
        RequestHash string    `json:"request_hash"`
        Response    string    `json:"response"`
        StatusCode  int       `json:"status_code"`
        ExpiresAt   time.Time `json:"expires_at"`
        CreatedAt   time.Time `json:"created_at"`
}

type ThumbnailCache struct {
        ID        int64     `json:"id"`
        VideoID   int64     `json:"video_id"`
        Position  int64     `json:"position"`
        URL       string    `json:"url"`
        Width     int       `json:"width"`
        Height    int       `json:"height"`
        FileSize  int64     `json:"file_size"`
        CreatedAt time.Time `json:"created_at"`
}

type CacheStats struct {
        TotalEntries     int64            `json:"total_entries"`
        TotalSize        int64            `json:"total_size"`
        HitRate          float64          `json:"hit_rate"`
        MissRate         float64          `json:"miss_rate"`
        ExpiredEntries   int64            `json:"expired_entries"`
        CachesByType     map[string]int64 `json:"caches_by_type"`
        CachesByProvider map[string]int64 `json:"caches_by_provider"`
        RecentActivity   []CacheActivity  `json:"recent_activity"`
}

type CacheActivity struct {
        Type      string    `json:"type"`
        Key       string    `json:"key"`
        Provider  string    `json:"provider"`
        Hit       bool      `json:"hit"`
        Timestamp time.Time `json:"timestamp"`
}

const (
        DefaultCacheTTL     = 24 * time.Hour
        MetadataCacheTTL    = 7 * 24 * time.Hour
        ThumbnailCacheTTL   = 30 * 24 * time.Hour
        APICacheTTL         = 1 * time.Hour
        TranslationCacheTTL = 30 * 24 * time.Hour
        SubtitleCacheTTL    = 7 * 24 * time.Hour
        LyricsCacheTTL      = 14 * 24 * time.Hour
        CoverArtCacheTTL    = 30 * 24 * time.Hour
)

func NewCacheService(db *sql.DB, logger *zap.Logger) *CacheService <span class="cov0" title="0">{
        return &amp;CacheService{
                db:     db,
                logger: logger,
        }
}</span>

func (s *CacheService) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error <span class="cov0" title="0">{
        s.logger.Debug("Setting cache entry",
                zap.String("key", key),
                zap.Duration("ttl", ttl))

        valueJSON, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal value: %w", err)
        }</span>

        <span class="cov0" title="0">expiresAt := time.Now().Add(ttl)

        query := `
                INSERT INTO cache_entries (cache_key, value, expires_at, created_at, updated_at)
                VALUES ($1, $2, $3, NOW(), NOW())
                ON CONFLICT (cache_key)
                DO UPDATE SET
                        value = EXCLUDED.value,
                        expires_at = EXCLUDED.expires_at,
                        updated_at = NOW()
        `

        _, err = s.db.ExecContext(ctx, query, key, string(valueJSON), expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to set cache entry", zap.Error(err))
                return fmt.Errorf("failed to set cache entry: %w", err)
        }</span>

        <span class="cov0" title="0">s.recordCacheActivity(ctx, "SET", key, "", true)
        return nil</span>
}

func (s *CacheService) Get(ctx context.Context, key string, dest interface{}) (bool, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting cache entry", zap.String("key", key))

        query := `
                SELECT value, expires_at
                FROM cache_entries
                WHERE cache_key = $1 AND expires_at &gt; NOW()
        `

        var valueJSON string
        var expiresAt time.Time

        err := s.db.QueryRowContext(ctx, query, key).Scan(&amp;valueJSON, &amp;expiresAt)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                s.recordCacheActivity(ctx, "GET", key, "", false)
                return false, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get cache entry", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", key, "", false)
                return false, fmt.Errorf("failed to get cache entry: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(valueJSON), dest); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to unmarshal cache value", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", key, "", false)
                return false, fmt.Errorf("failed to unmarshal cache value: %w", err)
        }</span>

        <span class="cov0" title="0">s.recordCacheActivity(ctx, "GET", key, "", true)
        return true, nil</span>
}

func (s *CacheService) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        s.logger.Debug("Deleting cache entry", zap.String("key", key))

        query := `DELETE FROM cache_entries WHERE cache_key = $1`

        result, err := s.db.ExecContext(ctx, query, key)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to delete cache entry", zap.Error(err))
                return fmt.Errorf("failed to delete cache entry: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        s.recordCacheActivity(ctx, "DELETE", key, "", rowsAffected &gt; 0)

        return nil</span>
}

func (s *CacheService) Clear(ctx context.Context, pattern string) error <span class="cov0" title="0">{
        s.logger.Info("Clearing cache entries", zap.String("pattern", pattern))

        var query string
        var args []interface{}

        if pattern == "" </span><span class="cov0" title="0">{
                query = `DELETE FROM cache_entries`
        }</span> else<span class="cov0" title="0"> {
                query = `DELETE FROM cache_entries WHERE cache_key LIKE $1`
                args = append(args, pattern)
        }</span>

        <span class="cov0" title="0">result, err := s.db.ExecContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to clear cache entries", zap.Error(err))
                return fmt.Errorf("failed to clear cache entries: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        s.logger.Info("Cleared cache entries", zap.Int64("count", rowsAffected))

        return nil</span>
}

func (s *CacheService) SetMediaMetadata(ctx context.Context, mediaItemID int64, metadataType, provider string, data interface{}, quality float64) error <span class="cov0" title="0">{
        s.logger.Debug("Setting media metadata cache",
                zap.Int64("media_item_id", mediaItemID),
                zap.String("type", metadataType),
                zap.String("provider", provider))

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">expiresAt := time.Now().Add(MetadataCacheTTL)

        query := `
                INSERT INTO media_metadata_cache (
                        media_item_id, metadata_type, provider, data, quality, expires_at, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
                ON CONFLICT (media_item_id, metadata_type, provider)
                DO UPDATE SET
                        data = EXCLUDED.data,
                        quality = EXCLUDED.quality,
                        expires_at = EXCLUDED.expires_at,
                        updated_at = NOW()
        `

        _, err = s.db.ExecContext(ctx, query, mediaItemID, metadataType, provider, string(dataJSON), quality, expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to set media metadata cache", zap.Error(err))
                return fmt.Errorf("failed to set media metadata: %w", err)
        }</span>

        <span class="cov0" title="0">cacheKey := fmt.Sprintf("metadata:%d:%s:%s", mediaItemID, metadataType, provider)
        s.recordCacheActivity(ctx, "SET", cacheKey, provider, true)

        return nil</span>
}

func (s *CacheService) GetMediaMetadata(ctx context.Context, mediaItemID int64, metadataType, provider string, dest interface{}) (bool, float64, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting media metadata cache",
                zap.Int64("media_item_id", mediaItemID),
                zap.String("type", metadataType),
                zap.String("provider", provider))

        query := `
                SELECT data, quality, expires_at
                FROM media_metadata_cache
                WHERE media_item_id = $1 AND metadata_type = $2 AND provider = $3 AND expires_at &gt; NOW()
                ORDER BY quality DESC, updated_at DESC
                LIMIT 1
        `

        var dataJSON string
        var quality float64
        var expiresAt time.Time

        err := s.db.QueryRowContext(ctx, query, mediaItemID, metadataType, provider).Scan(&amp;dataJSON, &amp;quality, &amp;expiresAt)
        cacheKey := fmt.Sprintf("metadata:%d:%s:%s", mediaItemID, metadataType, provider)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                s.recordCacheActivity(ctx, "GET", cacheKey, provider, false)
                return false, 0, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get media metadata cache", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", cacheKey, provider, false)
                return false, 0, fmt.Errorf("failed to get media metadata: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(dataJSON), dest); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to unmarshal metadata", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", cacheKey, provider, false)
                return false, 0, fmt.Errorf("failed to unmarshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">s.recordCacheActivity(ctx, "GET", cacheKey, provider, true)
        return true, quality, nil</span>
}

func (s *CacheService) SetAPIResponse(ctx context.Context, provider, endpoint string, requestData interface{}, response interface{}, statusCode int, ttl time.Duration) error <span class="cov0" title="0">{
        s.logger.Debug("Setting API response cache",
                zap.String("provider", provider),
                zap.String("endpoint", endpoint))

        requestHash, err := s.hashRequest(requestData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash request: %w", err)
        }</span>

        <span class="cov0" title="0">responseJSON, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal response: %w", err)
        }</span>

        <span class="cov0" title="0">expiresAt := time.Now().Add(ttl)

        query := `
                INSERT INTO api_cache (provider, endpoint, request_hash, response, status_code, expires_at, created_at)
                VALUES ($1, $2, $3, $4, $5, $6, NOW())
                ON CONFLICT (provider, endpoint, request_hash)
                DO UPDATE SET
                        response = EXCLUDED.response,
                        status_code = EXCLUDED.status_code,
                        expires_at = EXCLUDED.expires_at,
                        created_at = NOW()
        `

        _, err = s.db.ExecContext(ctx, query, provider, endpoint, requestHash, string(responseJSON), statusCode, expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to set API response cache", zap.Error(err))
                return fmt.Errorf("failed to set API response: %w", err)
        }</span>

        <span class="cov0" title="0">cacheKey := fmt.Sprintf("api:%s:%s:%s", provider, endpoint, requestHash)
        s.recordCacheActivity(ctx, "SET", cacheKey, provider, true)

        return nil</span>
}

func (s *CacheService) GetAPIResponse(ctx context.Context, provider, endpoint string, requestData interface{}, dest interface{}) (bool, int, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting API response cache",
                zap.String("provider", provider),
                zap.String("endpoint", endpoint))

        requestHash, err := s.hashRequest(requestData)
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, fmt.Errorf("failed to hash request: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                SELECT response, status_code, expires_at
                FROM api_cache
                WHERE provider = $1 AND endpoint = $2 AND request_hash = $3 AND expires_at &gt; NOW()
        `

        var responseJSON string
        var statusCode int
        var expiresAt time.Time

        err = s.db.QueryRowContext(ctx, query, provider, endpoint, requestHash).Scan(&amp;responseJSON, &amp;statusCode, &amp;expiresAt)
        cacheKey := fmt.Sprintf("api:%s:%s:%s", provider, endpoint, requestHash)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                s.recordCacheActivity(ctx, "GET", cacheKey, provider, false)
                return false, 0, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get API response cache", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", cacheKey, provider, false)
                return false, 0, fmt.Errorf("failed to get API response: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(responseJSON), dest); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to unmarshal API response", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", cacheKey, provider, false)
                return false, statusCode, fmt.Errorf("failed to unmarshal API response: %w", err)
        }</span>

        <span class="cov0" title="0">s.recordCacheActivity(ctx, "GET", cacheKey, provider, true)
        return true, statusCode, nil</span>
}

func (s *CacheService) SetThumbnail(ctx context.Context, videoID, position int64, url string, width, height int, fileSize int64) error <span class="cov0" title="0">{
        s.logger.Debug("Setting thumbnail cache",
                zap.Int64("video_id", videoID),
                zap.Int64("position", position))

        query := `
                INSERT INTO thumbnail_cache (video_id, position, url, width, height, file_size, created_at)
                VALUES ($1, $2, $3, $4, $5, $6, NOW())
                ON CONFLICT (video_id, position, width, height)
                DO UPDATE SET
                        url = EXCLUDED.url,
                        file_size = EXCLUDED.file_size,
                        created_at = NOW()
        `

        _, err := s.db.ExecContext(ctx, query, videoID, position, url, width, height, fileSize)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to set thumbnail cache", zap.Error(err))
                return fmt.Errorf("failed to set thumbnail: %w", err)
        }</span>

        <span class="cov0" title="0">cacheKey := fmt.Sprintf("thumbnail:%d:%d:%dx%d", videoID, position, width, height)
        s.recordCacheActivity(ctx, "SET", cacheKey, "thumbnail", true)

        return nil</span>
}

func (s *CacheService) GetThumbnail(ctx context.Context, videoID, position int64, width, height int) (*ThumbnailCache, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting thumbnail cache",
                zap.Int64("video_id", videoID),
                zap.Int64("position", position))

        query := `
                SELECT id, video_id, position, url, width, height, file_size, created_at
                FROM thumbnail_cache
                WHERE video_id = $1 AND position = $2 AND width = $3 AND height = $4
                ORDER BY created_at DESC
                LIMIT 1
        `

        var thumbnail ThumbnailCache
        err := s.db.QueryRowContext(ctx, query, videoID, position, width, height).Scan(
                &amp;thumbnail.ID, &amp;thumbnail.VideoID, &amp;thumbnail.Position, &amp;thumbnail.URL,
                &amp;thumbnail.Width, &amp;thumbnail.Height, &amp;thumbnail.FileSize, &amp;thumbnail.CreatedAt,
        )

        cacheKey := fmt.Sprintf("thumbnail:%d:%d:%dx%d", videoID, position, width, height)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                s.recordCacheActivity(ctx, "GET", cacheKey, "thumbnail", false)
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get thumbnail cache", zap.Error(err))
                s.recordCacheActivity(ctx, "GET", cacheKey, "thumbnail", false)
                return nil, fmt.Errorf("failed to get thumbnail: %w", err)
        }</span>

        <span class="cov0" title="0">s.recordCacheActivity(ctx, "GET", cacheKey, "thumbnail", true)
        return &amp;thumbnail, nil</span>
}

func (s *CacheService) SetTranslation(ctx context.Context, sourceText, sourceLang, targetLang, provider string, translation string) error <span class="cov0" title="0">{
        s.logger.Debug("Setting translation cache",
                zap.String("source_lang", sourceLang),
                zap.String("target_lang", targetLang),
                zap.String("provider", provider))

        key := fmt.Sprintf("translation:%s:%s:%s:%s", provider, sourceLang, targetLang, s.hashString(sourceText))

        translationData := map[string]interface{}{
                "source_text": sourceText,
                "source_lang": sourceLang,
                "target_lang": targetLang,
                "translation": translation,
                "provider":    provider,
                "cached_at":   time.Now(),
        }

        return s.Set(ctx, key, translationData, TranslationCacheTTL)
}</span>

func (s *CacheService) GetTranslation(ctx context.Context, sourceText, sourceLang, targetLang, provider string) (string, bool, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting translation cache",
                zap.String("source_lang", sourceLang),
                zap.String("target_lang", targetLang),
                zap.String("provider", provider))

        key := fmt.Sprintf("translation:%s:%s:%s:%s", provider, sourceLang, targetLang, s.hashString(sourceText))

        var translationData map[string]interface{}
        found, err := s.Get(ctx, key, &amp;translationData)
        if err != nil || !found </span><span class="cov0" title="0">{
                return "", false, err
        }</span>

        <span class="cov0" title="0">if translation, ok := translationData["translation"].(string); ok </span><span class="cov0" title="0">{
                return translation, true, nil
        }</span>

        <span class="cov0" title="0">return "", false, fmt.Errorf("invalid translation data in cache")</span>
}

func (s *CacheService) SetSubtitle(ctx context.Context, videoID int64, language, provider string, subtitle *SubtitleTrack) error <span class="cov0" title="0">{
        s.logger.Debug("Setting subtitle cache",
                zap.Int64("video_id", videoID),
                zap.String("language", language),
                zap.String("provider", provider))

        key := fmt.Sprintf("subtitle:%d:%s:%s", videoID, language, provider)
        return s.Set(ctx, key, subtitle, SubtitleCacheTTL)
}</span>

func (s *CacheService) GetSubtitle(ctx context.Context, videoID int64, language, provider string) (*SubtitleTrack, bool, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting subtitle cache",
                zap.Int64("video_id", videoID),
                zap.String("language", language),
                zap.String("provider", provider))

        key := fmt.Sprintf("subtitle:%d:%s:%s", videoID, language, provider)

        var subtitle SubtitleTrack
        found, err := s.Get(ctx, key, &amp;subtitle)
        if err != nil || !found </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov0" title="0">return &amp;subtitle, true, nil</span>
}

func (s *CacheService) SetLyrics(ctx context.Context, artist, title, provider string, lyrics *LyricsData) error <span class="cov0" title="0">{
        s.logger.Debug("Setting lyrics cache",
                zap.String("artist", artist),
                zap.String("title", title),
                zap.String("provider", provider))

        key := fmt.Sprintf("lyrics:%s:%s:%s", provider, s.hashString(artist), s.hashString(title))
        return s.Set(ctx, key, lyrics, LyricsCacheTTL)
}</span>

func (s *CacheService) GetLyrics(ctx context.Context, artist, title, provider string) (*LyricsData, bool, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting lyrics cache",
                zap.String("artist", artist),
                zap.String("title", title),
                zap.String("provider", provider))

        key := fmt.Sprintf("lyrics:%s:%s:%s", provider, s.hashString(artist), s.hashString(title))

        var lyrics LyricsData
        found, err := s.Get(ctx, key, &amp;lyrics)
        if err != nil || !found </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov0" title="0">return &amp;lyrics, true, nil</span>
}

func (s *CacheService) SetCoverArt(ctx context.Context, artist, album, provider string, coverArt *CoverArt) error <span class="cov0" title="0">{
        s.logger.Debug("Setting cover art cache",
                zap.String("artist", artist),
                zap.String("album", album),
                zap.String("provider", provider))

        key := fmt.Sprintf("coverart:%s:%s:%s", provider, s.hashString(artist), s.hashString(album))
        return s.Set(ctx, key, coverArt, CoverArtCacheTTL)
}</span>

func (s *CacheService) GetCoverArt(ctx context.Context, artist, album, provider string) (*CoverArt, bool, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting cover art cache",
                zap.String("artist", artist),
                zap.String("album", album),
                zap.String("provider", provider))

        key := fmt.Sprintf("coverart:%s:%s:%s", provider, s.hashString(artist), s.hashString(album))

        var coverArt CoverArt
        found, err := s.Get(ctx, key, &amp;coverArt)
        if err != nil || !found </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov0" title="0">return &amp;coverArt, true, nil</span>
}

func (s *CacheService) GetStats(ctx context.Context) (*CacheStats, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting cache statistics")

        stats := &amp;CacheStats{
                CachesByType:     make(map[string]int64),
                CachesByProvider: make(map[string]int64),
        }

        if err := s.getBasicStats(ctx, stats); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.getCachesByType(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get caches by type", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getCachesByProvider(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get caches by provider", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getRecentActivity(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get recent activity", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.calculateHitRate(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to calculate hit rate", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (s *CacheService) CleanupExpired(ctx context.Context) error <span class="cov0" title="0">{
        s.logger.Info("Cleaning up expired cache entries")

        tables := []string{
                "cache_entries",
                "media_metadata_cache",
                "api_cache",
        }

        totalCleaned := int64(0)

        for _, table := range tables </span><span class="cov0" title="0">{
                query := fmt.Sprintf("DELETE FROM %s WHERE expires_at &lt;= NOW()", table)
                result, err := s.db.ExecContext(ctx, query)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to cleanup expired entries",
                                zap.String("table", table),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
                totalCleaned += rowsAffected

                s.logger.Debug("Cleaned expired entries",
                        zap.String("table", table),
                        zap.Int64("count", rowsAffected))</span>
        }

        <span class="cov0" title="0">s.logger.Info("Completed cache cleanup", zap.Int64("total_cleaned", totalCleaned))
        return nil</span>
}

func (s *CacheService) hashRequest(data interface{}) (string, error) <span class="cov0" title="0">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return s.hashString(string(jsonData)), nil</span>
}

func (s *CacheService) hashString(text string) string <span class="cov0" title="0">{
        hash := md5.Sum([]byte(text))
        return hex.EncodeToString(hash[:])
}</span>

func (s *CacheService) recordCacheActivity(ctx context.Context, activityType, key, provider string, hit bool) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                query := `
                        INSERT INTO cache_activity (type, cache_key, provider, hit, timestamp)
                        VALUES ($1, $2, $3, $4, NOW())
                `
                _, err := s.db.ExecContext(context.Background(), query, activityType, key, provider, hit)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Debug("Failed to record cache activity", zap.Error(err))
                }</span>
        }()
}

func (s *CacheService) getBasicStats(ctx context.Context, stats *CacheStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        COUNT(*) as total_entries,
                        COALESCE(SUM(LENGTH(value)), 0) as total_size,
                        COUNT(CASE WHEN expires_at &lt;= NOW() THEN 1 END) as expired_entries
                FROM cache_entries
        `

        return s.db.QueryRowContext(ctx, query).Scan(
                &amp;stats.TotalEntries, &amp;stats.TotalSize, &amp;stats.ExpiredEntries)
}</span>

func (s *CacheService) getCachesByType(ctx context.Context, stats *CacheStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        CASE
                                WHEN cache_key LIKE 'translation:%' THEN 'translation'
                                WHEN cache_key LIKE 'subtitle:%' THEN 'subtitle'
                                WHEN cache_key LIKE 'lyrics:%' THEN 'lyrics'
                                WHEN cache_key LIKE 'coverart:%' THEN 'coverart'
                                WHEN cache_key LIKE 'api:%' THEN 'api'
                                WHEN cache_key LIKE 'metadata:%' THEN 'metadata'
                                WHEN cache_key LIKE 'thumbnail:%' THEN 'thumbnail'
                                ELSE 'other'
                        END as cache_type,
                        COUNT(*) as count
                FROM cache_entries
                WHERE expires_at &gt; NOW()
                GROUP BY cache_type
                ORDER BY count DESC
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var cacheType string
                var count int64
                if err := rows.Scan(&amp;cacheType, &amp;count); err == nil </span><span class="cov0" title="0">{
                        stats.CachesByType[cacheType] = count
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *CacheService) getCachesByProvider(ctx context.Context, stats *CacheStats) error <span class="cov0" title="0">{
        query := `
                SELECT provider, COUNT(*) as count
                FROM api_cache
                WHERE expires_at &gt; NOW()
                GROUP BY provider
                ORDER BY count DESC
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var provider string
                var count int64
                if err := rows.Scan(&amp;provider, &amp;count); err == nil </span><span class="cov0" title="0">{
                        stats.CachesByProvider[provider] = count
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *CacheService) getRecentActivity(ctx context.Context, stats *CacheStats) error <span class="cov0" title="0">{
        query := `
                SELECT type, cache_key, provider, hit, timestamp
                FROM cache_activity
                WHERE timestamp &gt; NOW() - INTERVAL '1 hour'
                ORDER BY timestamp DESC
                LIMIT 100
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var activity CacheActivity
                if err := rows.Scan(&amp;activity.Type, &amp;activity.Key, &amp;activity.Provider, &amp;activity.Hit, &amp;activity.Timestamp); err == nil </span><span class="cov0" title="0">{
                        stats.RecentActivity = append(stats.RecentActivity, activity)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *CacheService) calculateHitRate(ctx context.Context, stats *CacheStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        COUNT(CASE WHEN hit = true THEN 1 END) as hits,
                        COUNT(CASE WHEN hit = false THEN 1 END) as misses,
                        COUNT(*) as total
                FROM cache_activity
                WHERE timestamp &gt; NOW() - INTERVAL '24 hours'
        `

        var hits, misses, total int64
        err := s.db.QueryRowContext(ctx, query).Scan(&amp;hits, &amp;misses, &amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if total &gt; 0 </span><span class="cov0" title="0">{
                stats.HitRate = float64(hits) / float64(total) * 100
                stats.MissRate = float64(misses) / float64(total) * 100
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *CacheService) Warmup(ctx context.Context) error <span class="cov0" title="0">{
        s.logger.Info("Starting cache warmup")

        return nil
}</span>

func (s *CacheService) InvalidateByPattern(ctx context.Context, pattern string) error <span class="cov0" title="0">{
        s.logger.Info("Invalidating cache entries by pattern", zap.String("pattern", pattern))

        query := `DELETE FROM cache_entries WHERE cache_key LIKE $1`
        result, err := s.db.ExecContext(ctx, query, pattern)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to invalidate cache entries: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        s.logger.Info("Invalidated cache entries", zap.Int64("count", rowsAffected))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package services

import (
        "catalogizer/internal/config"
        "catalogizer/internal/models"
        "database/sql"
        "fmt"
        "strconv"
        "strings"

        "go.uber.org/zap"
)

// CatalogServiceInterface defines the interface for catalog operations
type CatalogServiceInterface interface {
        SetDB(db *sql.DB)
        ListPath(path string, sortBy string, sortOrder string, limit, offset int) ([]models.FileInfo, error)
        GetFileInfo(pathOrID string) (*models.FileInfo, error)
        SearchFiles(req *models.SearchRequest) ([]models.FileInfo, int64, error)
        GetDirectoriesBySize(smbRoot string, limit int) ([]models.DirectoryStats, error)
        GetDuplicateGroups(smbRoot string, minCount int, limit int) ([]models.DuplicateGroup, error)
        GetSMBRoots() ([]string, error)
        ListDirectory(path string) ([]models.FileInfo, error)
        Search(query string, fileType string, limit int, offset int) ([]models.FileInfo, error)
        SearchDuplicates() ([]models.DuplicateGroup, error)
        GetFileInfoByPath(path string) (*models.FileInfo, error)
        GetDuplicatesCount() (int64, error)
        GetDirectoriesBySizeLimited(limit int) ([]models.DirectoryStats, error)
}

type CatalogService struct {
        db     *sql.DB
        config *config.Config
        logger *zap.Logger
}

func NewCatalogService(cfg *config.Config, logger *zap.Logger) *CatalogService <span class="cov8" title="12">{
        return &amp;CatalogService{
                config: cfg,
                logger: logger,
        }
}</span>

func (s *CatalogService) SetDB(db *sql.DB) <span class="cov8" title="12">{
        s.db = db
}</span>

func (s *CatalogService) ListPath(path string, sortBy string, sortOrder string, limit, offset int) ([]models.FileInfo, error) <span class="cov5" title="4">{
        var query string
        var args []interface{}

        // Check if path exists in database
        var parentID sql.NullInt64
        err := s.db.QueryRow(`SELECT id FROM files WHERE path = ? LIMIT 1`, path).Scan(&amp;parentID)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to check path: %w", err)
        }</span>

        <span class="cov4" title="3">if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                // Path not in database
                if path == "/" </span><span class="cov1" title="1">{
                        // Root, return top-level directories
                        query = `
                                SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, media_type, parent_id, smb_root, created_at, updated_at
                                FROM files
                                WHERE parent_id IS NULL
                        `
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("path not found: %s", path)
                }</span>
        } else<span class="cov3" title="2"> {
                // Path exists, list its children
                query = `
                        SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, media_type, parent_id, smb_root, created_at, updated_at
                        FROM files
                        WHERE parent_id = ?
                `
                args = []interface{}{parentID.Int64}
        }</span>

        // Add sorting
        <span class="cov4" title="3">switch sortBy </span>{
        case "name":<span class="cov4" title="3">
                query += " ORDER BY name"</span>
        case "size":<span class="cov0" title="0">
                query += " ORDER BY size"</span>
        case "modified":<span class="cov0" title="0">
                query += " ORDER BY last_modified"</span>
        default:<span class="cov0" title="0">
                query += " ORDER BY is_directory DESC, name"</span>
        }

        <span class="cov4" title="3">if sortOrder == "desc" </span><span class="cov0" title="0">{
                query += " DESC"
        }</span> else<span class="cov4" title="3"> {
                query += " ASC"
        }</span>

        // Add pagination
        <span class="cov4" title="3">if limit &gt; 0 </span><span class="cov0" title="0">{
                query += " LIMIT ?"
                args = append(args, limit)
        }</span>
        <span class="cov4" title="3">if offset &gt; 0 </span><span class="cov0" title="0">{
                query += " OFFSET ?"
                args = append(args, offset)
        }</span>

        <span class="cov4" title="3">rows, err := s.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query files: %w", err)
        }</span>
        <span class="cov4" title="3">defer rows.Close()

        var files []models.FileInfo
        for rows.Next() </span><span class="cov6" title="6">{
                var file models.FileInfo
                var mediaType *string
                var lastModified sql.NullTime
                var createdAt sql.NullTime
                var updatedAt sql.NullTime
                err := rows.Scan(
                        &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory, &amp;file.Size,
                        &amp;lastModified, &amp;file.Hash, &amp;file.Extension, &amp;file.MimeType,
                        &amp;mediaType, &amp;file.ParentID, &amp;file.SmbRoot, &amp;createdAt, &amp;updatedAt,
                )
                if mediaType != nil </span><span class="cov3" title="2">{
                        file.MediaType = mediaType
                }</span>
                <span class="cov6" title="6">if lastModified.Valid </span><span class="cov0" title="0">{
                        file.LastModified = lastModified.Time
                }</span>
                <span class="cov6" title="6">if createdAt.Valid </span><span class="cov6" title="6">{
                        file.CreatedAt = createdAt.Time
                }</span>
                <span class="cov6" title="6">if updatedAt.Valid </span><span class="cov6" title="6">{
                        file.UpdatedAt = updatedAt.Time
                }</span>
                <span class="cov6" title="6">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan file: %w", err)
                }</span>
                <span class="cov6" title="6">if file.IsDirectory </span><span class="cov5" title="4">{
                        file.Type = "directory"
                }</span> else<span class="cov3" title="2"> {
                        file.Type = "file"
                }</span>
                <span class="cov6" title="6">files = append(files, file)</span>
        }

        <span class="cov4" title="3">return files, nil</span>
}

func (s *CatalogService) GetFileInfo(pathOrID string) (*models.FileInfo, error) <span class="cov4" title="3">{
        var query string
        var arg interface{}

        // Try to parse as ID first
        if id, err := strconv.ParseInt(pathOrID, 10, 64); err == nil </span><span class="cov0" title="0">{
                query = `
                        SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, media_type, parent_id, smb_root, created_at, updated_at
                        FROM files
                        WHERE id = ?
                `
                arg = id
        }</span> else<span class="cov4" title="3"> {
                // Treat as path
                query = `
                        SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, media_type, parent_id, smb_root, created_at, updated_at
                        FROM files
                        WHERE path = ?
                `
                arg = pathOrID
        }</span>

        <span class="cov4" title="3">var file models.FileInfo
        var mediaType *string
        var lastModified sql.NullTime
        var createdAt sql.NullTime
        var updatedAt sql.NullTime
        err := s.db.QueryRow(query, arg).Scan(
                &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory, &amp;file.Size,
                &amp;lastModified, &amp;file.Hash, &amp;file.Extension, &amp;file.MimeType,
                &amp;mediaType, &amp;file.ParentID, &amp;file.SmbRoot, &amp;createdAt, &amp;updatedAt,
        )
        if mediaType != nil </span><span class="cov1" title="1">{
                file.MediaType = mediaType
        }</span>
        <span class="cov4" title="3">if lastModified.Valid </span><span class="cov0" title="0">{
                file.LastModified = lastModified.Time
        }</span>
        <span class="cov4" title="3">if createdAt.Valid </span><span class="cov1" title="1">{
                file.CreatedAt = createdAt.Time
        }</span>
        <span class="cov4" title="3">if updatedAt.Valid </span><span class="cov1" title="1">{
                file.UpdatedAt = updatedAt.Time
        }</span>

        <span class="cov4" title="3">if err != nil </span><span class="cov3" title="2">{
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        return nil, nil
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("failed to get file info: %w", err)</span>
        }

        <span class="cov1" title="1">if file.IsDirectory </span><span class="cov0" title="0">{
                file.Type = "directory"
        }</span> else<span class="cov1" title="1"> {
                file.Type = "file"
        }</span>

        <span class="cov1" title="1">return &amp;file, nil</span>
}

func (s *CatalogService) SearchFiles(req *models.SearchRequest) ([]models.FileInfo, int64, error) <span class="cov7" title="8">{
        baseQuery := `
                SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, media_type, parent_id, smb_root, created_at, updated_at
                FROM files
                WHERE 1=1
        `

        countQuery := `
                SELECT COUNT(*)
                FROM files
                WHERE 1=1
        `

        var conditions []string
        var args []interface{}

        // Add search conditions
        if req.Query != "" </span><span class="cov7" title="8">{
                conditions = append(conditions, "name LIKE ?")
                args = append(args, "%"+req.Query+"%")
        }</span>

        <span class="cov7" title="8">if req.Path != "" </span><span class="cov0" title="0">{
                conditions = append(conditions, "path LIKE ?")
                args = append(args, req.Path+"%")
        }</span>

        <span class="cov7" title="8">if req.Extension != "" </span><span class="cov0" title="0">{
                conditions = append(conditions, "extension = ?")
                args = append(args, req.Extension)
        }</span>

        <span class="cov7" title="8">if req.MimeType != "" </span><span class="cov1" title="1">{
                conditions = append(conditions, "media_type = ?")
                args = append(args, req.MimeType)
        }</span>

        <span class="cov7" title="8">if req.MinSize != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "size &gt;= ?")
                args = append(args, *req.MinSize)
        }</span>

        <span class="cov7" title="8">if req.MaxSize != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "size &lt;= ?")
                args = append(args, *req.MaxSize)
        }</span>

        <span class="cov7" title="8">if len(req.SmbRoots) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := strings.Repeat("?,", len(req.SmbRoots))
                placeholders = placeholders[:len(placeholders)-1]
                conditions = append(conditions, fmt.Sprintf("smb_root IN (%s)", placeholders))
                for _, root := range req.SmbRoots </span><span class="cov0" title="0">{
                        args = append(args, root)
                }</span>
        }

        <span class="cov7" title="8">if req.IsDirectory != nil </span><span class="cov7" title="8">{
                conditions = append(conditions, "is_directory = ?")
                args = append(args, *req.IsDirectory)
        }</span>

        // Build final queries
        <span class="cov7" title="8">whereClause := ""
        if len(conditions) &gt; 0 </span><span class="cov7" title="8">{
                whereClause = " AND " + strings.Join(conditions, " AND ")
        }</span>

        // Get total count
        <span class="cov7" title="8">var total int64
        err := s.db.QueryRow(countQuery+whereClause, args...).Scan(&amp;total)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("failed to count results: %w", err)
        }</span>

        // Add sorting and pagination to main query
        <span class="cov7" title="7">query := baseQuery + whereClause

        // Add sorting
        switch req.SortBy </span>{
        case "name":<span class="cov0" title="0">
                query += " ORDER BY name"</span>
        case "size":<span class="cov0" title="0">
                query += " ORDER BY size"</span>
        case "modified":<span class="cov0" title="0">
                query += " ORDER BY last_modified"</span>
        default:<span class="cov7" title="7">
                query += " ORDER BY is_directory DESC, name"</span>
        }

        <span class="cov7" title="7">if req.SortOrder == "desc" </span><span class="cov0" title="0">{
                query += " DESC"
        }</span> else<span class="cov7" title="7"> {
                query += " ASC"
        }</span>

        // Add pagination
        <span class="cov7" title="7">if req.Limit &gt; 0 </span><span class="cov7" title="7">{
                query += " LIMIT ?"
                args = append(args, req.Limit)
        }</span>
        <span class="cov7" title="7">if req.Offset &gt; 0 </span><span class="cov3" title="2">{
                query += " OFFSET ?"
                args = append(args, req.Offset)
        }</span>

        // Execute main query
        <span class="cov7" title="7">rows, err := s.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to search files: %w", err)
        }</span>
        <span class="cov7" title="7">defer rows.Close()

        var files []models.FileInfo
        for rows.Next() </span><span class="cov10" title="17">{
                var file models.FileInfo
                var mediaType *string
                var lastModified sql.NullTime
                var createdAt sql.NullTime
                var updatedAt sql.NullTime
                err := rows.Scan(
                        &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory, &amp;file.Size,
                        &amp;lastModified, &amp;file.Hash, &amp;file.Extension, &amp;file.MimeType,
                        &amp;mediaType, &amp;file.ParentID, &amp;file.SmbRoot, &amp;createdAt, &amp;updatedAt,
                )
                if mediaType != nil </span><span class="cov10" title="17">{
                        file.MediaType = mediaType
                }</span>
                <span class="cov10" title="17">if lastModified.Valid </span><span class="cov0" title="0">{
                        file.LastModified = lastModified.Time
                }</span>
                <span class="cov10" title="17">if createdAt.Valid </span><span class="cov10" title="17">{
                        file.CreatedAt = createdAt.Time
                }</span>
                <span class="cov10" title="17">if updatedAt.Valid </span><span class="cov10" title="17">{
                        file.UpdatedAt = updatedAt.Time
                }</span>
                <span class="cov10" title="17">if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to scan file: %w", err)
                }</span>
                <span class="cov10" title="17">if file.IsDirectory </span><span class="cov0" title="0">{
                        file.Type = "directory"
                }</span> else<span class="cov10" title="17"> {
                        file.Type = "file"
                }</span>
                <span class="cov10" title="17">files = append(files, file)</span>
        }

        <span class="cov7" title="7">return files, total, nil</span>
}

func (s *CatalogService) GetDirectoriesBySize(smbRoot string, limit int) ([]models.DirectoryStats, error) <span class="cov1" title="1">{
        query := `
                WITH RECURSIVE dir_sizes AS (
                        SELECT
                                id, path, name, is_directory,
                                CASE WHEN is_directory THEN 0 ELSE size END as file_size,
                                CASE WHEN is_directory THEN 0 ELSE 1 END as file_count
                        FROM files
                        WHERE smb_root = ? AND is_directory = true

                        UNION ALL

                        SELECT
                                f.id, f.path, f.name, f.is_directory,
                                CASE WHEN f.is_directory THEN 0 ELSE f.size END,
                                CASE WHEN f.is_directory THEN 0 ELSE 1 END
                        FROM files f
                        JOIN dir_sizes ds ON f.parent_id = ds.id
                        WHERE f.smb_root = ?
                )
                SELECT
                        path,
                        SUM(file_size) as total_size,
                        SUM(file_count) as file_count,
                        COUNT(CASE WHEN is_directory THEN 1 END) as directory_count
                FROM dir_sizes
                WHERE is_directory = true
                GROUP BY path
                ORDER BY total_size DESC
                LIMIT ?
        `

        rows, err := s.db.Query(query, smbRoot, smbRoot, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get directories by size: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        var stats []models.DirectoryStats
        for rows.Next() </span><span class="cov5" title="4">{
                var stat models.DirectoryStats
                err := rows.Scan(&amp;stat.Path, &amp;stat.TotalSize, &amp;stat.FileCount, &amp;stat.DirectoryCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan directory stats: %w", err)
                }</span>
                <span class="cov5" title="4">stats = append(stats, stat)</span>
        }

        <span class="cov1" title="1">return stats, nil</span>
}

func (s *CatalogService) GetDuplicateGroups(smbRoot string, minCount int, limit int) ([]models.DuplicateGroup, error) <span class="cov1" title="1">{
        query := `
                SELECT
                        hash, size, COUNT(*) as count
                FROM files
                WHERE hash IS NOT NULL
                        AND is_directory = false
        `
        args := []interface{}{}

        if smbRoot != "" </span><span class="cov0" title="0">{
                query += " AND smb_root = ?"
                args = append(args, smbRoot)
        }</span>

        <span class="cov1" title="1">query += `
                GROUP BY hash, size
                HAVING COUNT(*) &gt;= ?
                ORDER BY COUNT(*) DESC, size DESC
        `
        args = append(args, minCount)

        if limit &gt; 0 </span><span class="cov0" title="0">{
                query += " LIMIT ?"
                args = append(args, limit)
        }</span>

        <span class="cov1" title="1">rows, err := s.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get duplicate groups: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        var groups []models.DuplicateGroup
        for rows.Next() </span><span class="cov1" title="1">{
                var group models.DuplicateGroup
                err := rows.Scan(&amp;group.Hash, &amp;group.Size, &amp;group.Count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan duplicate group: %w", err)
                }</span>

                // Get files in this duplicate group
                <span class="cov1" title="1">filesQuery := `
                        SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, parent_id, smb_root, created_at, updated_at
                        FROM files
                        WHERE hash = ? AND size = ?
                `
                args2 := []interface{}{group.Hash, group.Size}

                if smbRoot != "" </span><span class="cov0" title="0">{
                        filesQuery += " AND smb_root = ?"
                        args2 = append(args2, smbRoot)
                }</span>

                <span class="cov1" title="1">filesQuery += " ORDER BY path"

                fileRows, err := s.db.Query(filesQuery, args2...)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to get files for duplicate group", zap.Error(err))
                        continue</span>
                }

                <span class="cov1" title="1">for fileRows.Next() </span><span class="cov3" title="2">{
                        var file models.FileInfo
                        var lastModified sql.NullTime
                        var createdAt sql.NullTime
                        var updatedAt sql.NullTime
                        err := fileRows.Scan(
                                &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory, &amp;file.Size,
                                &amp;lastModified, &amp;file.Hash, &amp;file.Extension, &amp;file.MimeType,
                                &amp;file.ParentID, &amp;file.SmbRoot, &amp;createdAt, &amp;updatedAt,
                        )
                        if lastModified.Valid </span><span class="cov0" title="0">{
                                file.LastModified = lastModified.Time
                        }</span>
                        <span class="cov3" title="2">if createdAt.Valid </span><span class="cov3" title="2">{
                                file.CreatedAt = createdAt.Time
                        }</span>
                        <span class="cov3" title="2">if updatedAt.Valid </span><span class="cov3" title="2">{
                                file.UpdatedAt = updatedAt.Time
                        }</span>
                        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to scan duplicate file", zap.Error(err))
                                continue</span>
                        }
                        <span class="cov3" title="2">group.Files = append(group.Files, file)</span>
                }
                <span class="cov1" title="1">fileRows.Close()

                group.TotalSize = group.Size * int64(group.Count)
                groups = append(groups, group)</span>
        }

        <span class="cov1" title="1">return groups, nil</span>
}

func (s *CatalogService) GetSMBRoots() ([]string, error) <span class="cov0" title="0">{
        query := `SELECT DISTINCT smb_root FROM files ORDER BY smb_root`

        rows, err := s.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get SMB roots: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var roots []string
        for rows.Next() </span><span class="cov0" title="0">{
                var root string
                if err := rows.Scan(&amp;root); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan SMB root: %w", err)
                }</span>
                <span class="cov0" title="0">roots = append(roots, root)</span>
        }

        <span class="cov0" title="0">return roots, nil</span>
}

// ListDirectory lists files in a directory (alias for ListPath)
func (s *CatalogService) ListDirectory(path string) ([]models.FileInfo, error) <span class="cov5" title="4">{
        return s.ListPath(path, "name", "asc", 0, 0)
}</span>

// Search searches files by query (simplified version)
func (s *CatalogService) Search(query string, fileType string, limit int, offset int) ([]models.FileInfo, error) <span class="cov7" title="8">{
        isDirectory := false
        req := &amp;models.SearchRequest{
                Query:       query,
                MimeType:    fileType,
                IsDirectory: &amp;isDirectory,
                Limit:       limit,
                Offset:      offset,
        }
        files, _, err := s.SearchFiles(req)
        return files, err
}</span>

// SearchDuplicates searches for duplicate files
func (s *CatalogService) SearchDuplicates() ([]models.DuplicateGroup, error) <span class="cov1" title="1">{
        return s.GetDuplicateGroups("", 2, 0)
}</span>

// GetFileInfoByPath gets file info by path (for test compatibility)
func (s *CatalogService) GetFileInfoByPath(path string) (*models.FileInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, path, is_directory, size, last_modified, hash, extension, mime_type, media_type, parent_id, smb_root, created_at, updated_at
                FROM files
                WHERE path = ?
        `

        var file models.FileInfo
        var mediaType *string
        var lastModified sql.NullTime
        var createdAt sql.NullTime
        var updatedAt sql.NullTime
        err := s.db.QueryRow(query, path).Scan(
                &amp;file.ID, &amp;file.Name, &amp;file.Path, &amp;file.IsDirectory, &amp;file.Size,
                &amp;lastModified, &amp;file.Hash, &amp;file.Extension, &amp;file.MimeType,
                &amp;mediaType, &amp;file.ParentID, &amp;file.SmbRoot, &amp;createdAt, &amp;updatedAt,
        )
        if mediaType != nil </span><span class="cov0" title="0">{
                file.MediaType = mediaType
        }</span>
        <span class="cov0" title="0">if lastModified.Valid </span><span class="cov0" title="0">{
                file.LastModified = lastModified.Time
        }</span>
        <span class="cov0" title="0">if createdAt.Valid </span><span class="cov0" title="0">{
                file.CreatedAt = createdAt.Time
        }</span>
        <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                file.UpdatedAt = updatedAt.Time
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get file info by path: %w", err)</span>
        }

        <span class="cov0" title="0">if file.IsDirectory </span><span class="cov0" title="0">{
                file.Type = "directory"
        }</span> else<span class="cov0" title="0"> {
                file.Type = "file"
        }</span>

        <span class="cov0" title="0">return &amp;file, nil</span>
}

// GetDuplicatesCount gets the count of duplicate files
func (s *CatalogService) GetDuplicatesCount() (int64, error) <span class="cov3" title="2">{
        query := `
                SELECT COUNT(*) FROM (
                        SELECT hash, COUNT(*) as count
                        FROM files
                        WHERE hash IS NOT NULL AND hash != '' AND is_directory = false
                        GROUP BY hash
                        HAVING COUNT(*) &gt; 1
                )
        `

        var count int64
        err := s.db.QueryRow(query).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get duplicates count: %w", err)
        }</span>

        <span class="cov3" title="2">return count, nil</span>
}

// GetDirectoriesBySizeLimited gets directories by size with default limit
func (s *CatalogService) GetDirectoriesBySizeLimited(limit int) ([]models.DirectoryStats, error) <span class="cov0" title="0">{
        return s.GetDirectoriesBySize("", limit)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "database/sql"
        "encoding/hex"
        "fmt"
        "image"
        "image/jpeg"
        "image/png"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "time"

        "go.uber.org/zap"
        "golang.org/x/image/draw"
)

// CoverArtService handles cover art retrieval, processing, and caching
type CoverArtService struct {
        db         *sql.DB
        logger     *zap.Logger
        httpClient *http.Client
        apiKeys    map[string]string
        cacheDir   string
}

// CoverArtProvider represents different cover art providers
type CoverArtProvider string

const (
        CoverArtProviderMusicBrainz CoverArtProvider = "musicbrainz"
        CoverArtProviderLastFM      CoverArtProvider = "lastfm"
        CoverArtProviderSpotify     CoverArtProvider = "spotify"
        CoverArtProviderDeezer      CoverArtProvider = "deezer"
        CoverArtProviderITunes      CoverArtProvider = "itunes"
        CoverArtProviderDiscogs     CoverArtProvider = "discogs"
        CoverArtProviderEmbedded    CoverArtProvider = "embedded"
        CoverArtProviderLocal       CoverArtProvider = "local"
)

// CoverArtQuality represents different quality levels
type CoverArtQuality string

const (
        QualityThumbnail CoverArtQuality = "thumbnail" // 150x150
        QualityMedium    CoverArtQuality = "medium"    // 300x300
        QualityHigh      CoverArtQuality = "high"      // 600x600
        QualityOriginal  CoverArtQuality = "original"  // Original size
)

// CoverArtSearchRequest represents a cover art search request
type CoverArtSearchRequest struct {
        Title         string             `json:"title"`
        Artist        string             `json:"artist"`
        Album         *string            `json:"album,omitempty"`
        Year          *int               `json:"year,omitempty"`
        MusicBrainzID *string            `json:"musicbrainz_id,omitempty"`
        SpotifyID     *string            `json:"spotify_id,omitempty"`
        Quality       CoverArtQuality    `json:"quality"`
        Providers     []CoverArtProvider `json:"providers,omitempty"`
        UseCache      bool               `json:"use_cache"`
}

// CoverArtSearchResult represents a cover art search result
type CoverArtSearchResult struct {
        ID           string           `json:"id"`
        Provider     CoverArtProvider `json:"provider"`
        Title        string           `json:"title"`
        Artist       string           `json:"artist"`
        Album        *string          `json:"album,omitempty"`
        URL          string           `json:"url"`
        ThumbnailURL *string          `json:"thumbnail_url,omitempty"`
        Width        int              `json:"width"`
        Height       int              `json:"height"`
        Format       string           `json:"format"`
        Quality      CoverArtQuality  `json:"quality"`
        Size         *int64           `json:"size,omitempty"`
        MatchScore   float64          `json:"match_score"`
        Copyright    *string          `json:"copyright,omitempty"`
        Source       string           `json:"source"`
}

// CoverArtDownloadRequest represents a cover art download request
type CoverArtDownloadRequest struct {
        MediaItemID   int64             `json:"media_item_id"`
        ResultID      string            `json:"result_id"`
        Quality       CoverArtQuality   `json:"quality"`
        GenerateSizes []CoverArtQuality `json:"generate_sizes,omitempty"`
        SetAsDefault  bool              `json:"set_as_default"`
}

// VideoThumbnailRequest represents a video thumbnail generation request
type VideoThumbnailRequest struct {
        MediaItemID   int64             `json:"media_item_id"`
        VideoPath     string            `json:"video_path"`
        Timestamps    []float64         `json:"timestamps,omitempty"` // Seconds
        Quality       CoverArtQuality   `json:"quality"`
        GenerateSizes []CoverArtQuality `json:"generate_sizes,omitempty"`
        Count         int               `json:"count"` // Number of thumbnails to generate
}

// LocalCoverArtScanRequest represents a request to scan for local cover art
type LocalCoverArtScanRequest struct {
        MediaItemID int64  `json:"media_item_id"`
        Directory   string `json:"directory"`
        Recursive   bool   `json:"recursive"`
}

// CoverArtProcessingOptions represents image processing options
type CoverArtProcessingOptions struct {
        Width           int     `json:"width"`
        Height          int     `json:"height"`
        Quality         int     `json:"quality"`                    // JPEG quality 1-100
        Format          string  `json:"format"`                     // "jpeg", "png", "webp"
        Crop            bool    `json:"crop"`                       // Crop to exact dimensions
        PreserveAspect  bool    `json:"preserve_aspect"`            // Preserve aspect ratio
        BackgroundColor *string `json:"background_color,omitempty"` // Hex color for padding
}

// NewCoverArtService creates a new cover art service
func NewCoverArtService(db *sql.DB, logger *zap.Logger) *CoverArtService <span class="cov0" title="0">{
        return &amp;CoverArtService{
                db:         db,
                logger:     logger,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                apiKeys:    make(map[string]string),
                cacheDir:   "./cache/cover_art",
        }
}</span>

// SearchCoverArt searches for cover art across multiple providers
func (s *CoverArtService) SearchCoverArt(ctx context.Context, request *CoverArtSearchRequest) ([]CoverArtSearchResult, error) <span class="cov0" title="0">{
        s.logger.Info("Searching cover art",
                zap.String("title", request.Title),
                zap.String("artist", request.Artist),
                zap.String("album", getStringValue(request.Album)))

        // Check cache first if requested
        if request.UseCache </span><span class="cov0" title="0">{
                if cached := s.getCachedCoverArt(ctx, request); cached != nil </span><span class="cov0" title="0">{
                        return []CoverArtSearchResult{*cached}, nil
                }</span>
        }

        <span class="cov0" title="0">var allResults []CoverArtSearchResult

        // Default providers if none specified
        providers := request.Providers
        if len(providers) == 0 </span><span class="cov0" title="0">{
                providers = []CoverArtProvider{
                        CoverArtProviderMusicBrainz,
                        CoverArtProviderLastFM,
                        CoverArtProviderITunes,
                }
        }</span>

        // Search each provider
        <span class="cov0" title="0">for _, provider := range providers </span><span class="cov0" title="0">{
                results, err := s.searchProvider(ctx, provider, request)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Provider search failed",
                                zap.String("provider", string(provider)),
                                zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">allResults = append(allResults, results...)</span>
        }

        // Sort by match score and quality
        <span class="cov0" title="0">s.sortCoverArtResults(allResults)

        s.logger.Info("Cover art search completed",
                zap.Int("total_results", len(allResults)))

        return allResults, nil</span>
}

// DownloadCoverArt downloads and processes cover art
func (s *CoverArtService) DownloadCoverArt(ctx context.Context, request *CoverArtDownloadRequest) (*CoverArt, error) <span class="cov0" title="0">{
        s.logger.Info("Downloading cover art",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("result_id", request.ResultID))

        // Get download info
        result, err := s.getCoverArtDownloadInfo(ctx, request.ResultID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get download info: %w", err)
        }</span>

        // Download image
        <span class="cov0" title="0">imageData, err := s.downloadImage(ctx, result.URL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to download image: %w", err)
        }</span>

        // Process and save image
        <span class="cov0" title="0">coverArt, err := s.processAndSaveCoverArt(ctx, request.MediaItemID, imageData, result, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to process cover art: %w", err)
        }</span>

        // Generate additional sizes if requested
        <span class="cov0" title="0">if len(request.GenerateSizes) &gt; 0 </span><span class="cov0" title="0">{
                go s.generateAdditionalSizes(ctx, coverArt, request.GenerateSizes)
        }</span>

        // Set as default if requested
        <span class="cov0" title="0">if request.SetAsDefault </span><span class="cov0" title="0">{
                if err := s.setDefaultCoverArt(ctx, request.MediaItemID, coverArt.ID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to set as default cover art", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return coverArt, nil</span>
}

// GenerateVideoThumbnails generates thumbnails for video files
func (s *CoverArtService) GenerateVideoThumbnails(ctx context.Context, request *VideoThumbnailRequest) ([]*CoverArt, error) <span class="cov0" title="0">{
        s.logger.Info("Generating video thumbnails",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("video_path", request.VideoPath))

        // Get video duration
        duration, err := s.getVideoDuration(request.VideoPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get video duration: %w", err)
        }</span>

        // Generate timestamps if not provided
        <span class="cov0" title="0">timestamps := request.Timestamps
        if len(timestamps) == 0 </span><span class="cov0" title="0">{
                timestamps = s.generateTimestamps(duration, request.Count)
        }</span>

        <span class="cov0" title="0">var thumbnails []*CoverArt

        // Generate thumbnail for each timestamp
        for i, timestamp := range timestamps </span><span class="cov0" title="0">{
                thumbnail, err := s.generateVideoThumbnail(ctx, request, timestamp, i)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to generate thumbnail",
                                zap.Float64("timestamp", timestamp),
                                zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">thumbnails = append(thumbnails, thumbnail)</span>
        }

        <span class="cov0" title="0">return thumbnails, nil</span>
}

// ScanLocalCoverArt scans directory for local cover art files
func (s *CoverArtService) ScanLocalCoverArt(ctx context.Context, request *LocalCoverArtScanRequest) ([]*CoverArt, error) <span class="cov0" title="0">{
        s.logger.Info("Scanning local cover art",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("directory", request.Directory))

        var coverArts []*CoverArt

        // Common cover art filenames
        coverFilenames := []string{
                "cover.jpg", "cover.jpeg", "cover.png",
                "folder.jpg", "folder.jpeg", "folder.png",
                "album.jpg", "album.jpeg", "album.png",
                "front.jpg", "front.jpeg", "front.png",
                "albumart.jpg", "albumart.jpeg", "albumart.png",
        }

        // Scan directory
        files, err := os.ReadDir(request.Directory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                if file.IsDir() &amp;&amp; request.Recursive </span><span class="cov0" title="0">{
                        // Recursively scan subdirectories
                        subRequest := *request
                        subRequest.Directory = filepath.Join(request.Directory, file.Name())
                        subCoverArts, err := s.ScanLocalCoverArt(ctx, &amp;subRequest)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to scan subdirectory", zap.Error(err))
                                continue</span>
                        }
                        <span class="cov0" title="0">coverArts = append(coverArts, subCoverArts...)
                        continue</span>
                }

                // Check if file is a potential cover art
                <span class="cov0" title="0">filename := strings.ToLower(file.Name())
                for _, coverFilename := range coverFilenames </span><span class="cov0" title="0">{
                        if filename == coverFilename || strings.HasPrefix(filename, strings.TrimSuffix(coverFilename, filepath.Ext(coverFilename))) </span><span class="cov0" title="0">{
                                filePath := filepath.Join(request.Directory, file.Name())
                                coverArt, err := s.processLocalCoverArt(ctx, request.MediaItemID, filePath)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Warn("Failed to process local cover art",
                                                zap.String("file", filePath),
                                                zap.Error(err))
                                        continue</span>
                                }
                                <span class="cov0" title="0">coverArts = append(coverArts, coverArt)
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return coverArts, nil</span>
}

// GetCoverArt returns cover art for a media item
func (s *CoverArtService) GetCoverArt(ctx context.Context, mediaItemID int64) (*CoverArt, error) <span class="cov0" title="0">{
        query := `
                SELECT id, media_item_id, source, url, local_path, width, height,
                       format, size, quality, created_at, cached_at
                FROM cover_art WHERE media_item_id = ? AND is_default = 1
                ORDER BY created_at DESC LIMIT 1`

        var coverArt CoverArt
        var url, localPath sql.NullString
        var size sql.NullInt64
        var cachedAt sql.NullTime

        err := s.db.QueryRowContext(ctx, query, mediaItemID).Scan(
                &amp;coverArt.ID, &amp;coverArt.MediaItemID, &amp;coverArt.Source,
                &amp;url, &amp;localPath, &amp;coverArt.Width, &amp;coverArt.Height,
                &amp;coverArt.Format, &amp;size, &amp;coverArt.Quality,
                &amp;coverArt.CreatedAt, &amp;cachedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil // No cover art found
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get cover art: %w", err)</span>
        }

        <span class="cov0" title="0">if url.Valid </span><span class="cov0" title="0">{
                coverArt.URL = &amp;url.String
        }</span>
        <span class="cov0" title="0">if localPath.Valid </span><span class="cov0" title="0">{
                coverArt.LocalPath = &amp;localPath.String
        }</span>
        <span class="cov0" title="0">if size.Valid </span><span class="cov0" title="0">{
                coverArt.Size = &amp;size.Int64
        }</span>
        <span class="cov0" title="0">if cachedAt.Valid </span><span class="cov0" title="0">{
                coverArt.CachedAt = &amp;cachedAt.Time
        }</span>

        <span class="cov0" title="0">return &amp;coverArt, nil</span>
}

// ProcessImage processes an image with specified options
func (s *CoverArtService) ProcessImage(inputPath string, outputPath string, options *CoverArtProcessingOptions) error <span class="cov0" title="0">{
        s.logger.Debug("Processing image",
                zap.String("input", inputPath),
                zap.String("output", outputPath))

        // Open input image
        inputFile, err := os.Open(inputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open input file: %w", err)
        }</span>
        <span class="cov0" title="0">defer inputFile.Close()

        // Decode image
        img, format, err := image.Decode(inputFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode image: %w", err)
        }</span>

        // Resize image
        <span class="cov0" title="0">resizedImg := s.resizeImage(img, options)

        // Create output file
        outputFile, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output file: %w", err)
        }</span>
        <span class="cov0" title="0">defer outputFile.Close()

        // Encode image
        switch strings.ToLower(options.Format) </span>{
        case "jpeg", "jpg":<span class="cov0" title="0">
                return jpeg.Encode(outputFile, resizedImg, &amp;jpeg.Options{Quality: options.Quality})</span>
        case "png":<span class="cov0" title="0">
                return png.Encode(outputFile, resizedImg)</span>
        default:<span class="cov0" title="0">
                // Default to original format
                switch format </span>{
                case "jpeg":<span class="cov0" title="0">
                        return jpeg.Encode(outputFile, resizedImg, &amp;jpeg.Options{Quality: options.Quality})</span>
                case "png":<span class="cov0" title="0">
                        return png.Encode(outputFile, resizedImg)</span>
                default:<span class="cov0" title="0">
                        return jpeg.Encode(outputFile, resizedImg, &amp;jpeg.Options{Quality: options.Quality})</span>
                }
        }
}

// Provider-specific implementations
func (s *CoverArtService) searchProvider(ctx context.Context, provider CoverArtProvider, request *CoverArtSearchRequest) ([]CoverArtSearchResult, error) <span class="cov0" title="0">{
        switch provider </span>{
        case CoverArtProviderMusicBrainz:<span class="cov0" title="0">
                return s.searchMusicBrainz(ctx, request)</span>
        case CoverArtProviderLastFM:<span class="cov0" title="0">
                return s.searchLastFM(ctx, request)</span>
        case CoverArtProviderITunes:<span class="cov0" title="0">
                return s.searchITunes(ctx, request)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported provider: %s", provider)</span>
        }
}

func (s *CoverArtService) searchMusicBrainz(ctx context.Context, request *CoverArtSearchRequest) ([]CoverArtSearchResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Searching MusicBrainz",
                zap.String("artist", request.Artist),
                zap.String("album", getStringValue(request.Album)))

        // Mock implementation for demonstration
        result := CoverArtSearchResult{
                ID:         "mb_1",
                Provider:   CoverArtProviderMusicBrainz,
                Title:      request.Title,
                Artist:     request.Artist,
                Album:      request.Album,
                URL:        "https://coverartarchive.org/sample/front.jpg",
                Width:      500,
                Height:     500,
                Format:     "jpeg",
                Quality:    QualityHigh,
                MatchScore: 0.9,
                Source:     "coverartarchive.org",
        }

        return []CoverArtSearchResult{result}, nil
}</span>

func (s *CoverArtService) searchLastFM(ctx context.Context, request *CoverArtSearchRequest) ([]CoverArtSearchResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Searching Last.FM")

        result := CoverArtSearchResult{
                ID:         "lastfm_1",
                Provider:   CoverArtProviderLastFM,
                Title:      request.Title,
                Artist:     request.Artist,
                Album:      request.Album,
                URL:        "https://lastfm-img2.akamaized.net/sample.jpg",
                Width:      300,
                Height:     300,
                Format:     "jpeg",
                Quality:    QualityMedium,
                MatchScore: 0.85,
                Source:     "last.fm",
        }

        return []CoverArtSearchResult{result}, nil
}</span>

func (s *CoverArtService) searchITunes(ctx context.Context, request *CoverArtSearchRequest) ([]CoverArtSearchResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Searching iTunes")

        result := CoverArtSearchResult{
                ID:         "itunes_1",
                Provider:   CoverArtProviderITunes,
                Title:      request.Title,
                Artist:     request.Artist,
                Album:      request.Album,
                URL:        "https://is1-ssl.mzstatic.com/sample.jpg",
                Width:      600,
                Height:     600,
                Format:     "jpeg",
                Quality:    QualityHigh,
                MatchScore: 0.92,
                Source:     "itunes.apple.com",
        }

        return []CoverArtSearchResult{result}, nil
}</span>

// Helper functions
func (s *CoverArtService) downloadImage(ctx context.Context, url string) ([]byte, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP %d: %s", resp.StatusCode, resp.Status)
        }</span>

        <span class="cov0" title="0">return io.ReadAll(resp.Body)</span>
}

func (s *CoverArtService) resizeImage(img image.Image, options *CoverArtProcessingOptions) image.Image <span class="cov0" title="0">{
        bounds := img.Bounds()
        srcWidth := bounds.Dx()
        srcHeight := bounds.Dy()

        dstWidth := options.Width
        dstHeight := options.Height

        if options.PreserveAspect </span><span class="cov0" title="0">{
                // Calculate dimensions preserving aspect ratio
                aspectRatio := float64(srcWidth) / float64(srcHeight)
                if float64(dstWidth)/float64(dstHeight) &gt; aspectRatio </span><span class="cov0" title="0">{
                        dstWidth = int(float64(dstHeight) * aspectRatio)
                }</span> else<span class="cov0" title="0"> {
                        dstHeight = int(float64(dstWidth) / aspectRatio)
                }</span>
        }

        // Create destination image
        <span class="cov0" title="0">dst := image.NewRGBA(image.Rect(0, 0, dstWidth, dstHeight))

        // Resize image
        draw.BiLinear.Scale(dst, dst.Bounds(), img, bounds, draw.Over, nil)

        return dst</span>
}

func (s *CoverArtService) generateTimestamps(duration float64, count int) []float64 <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                count = 3 // Default to 3 thumbnails
        }</span>

        <span class="cov0" title="0">var timestamps []float64
        interval := duration / float64(count+1)

        for i := 1; i &lt;= count; i++ </span><span class="cov0" title="0">{
                timestamps = append(timestamps, interval*float64(i))
        }</span>

        <span class="cov0" title="0">return timestamps</span>
}

func (s *CoverArtService) generateCoverArtID() string <span class="cov0" title="0">{
        return fmt.Sprintf("cover_%d", time.Now().UnixNano())
}</span>

func (s *CoverArtService) generateCacheKey(request *CoverArtSearchRequest) string <span class="cov0" title="0">{
        data := fmt.Sprintf("%s_%s_%s_%s", request.Artist, request.Title,
                getStringValue(request.Album), request.Quality)
        hash := md5.Sum([]byte(data))
        return hex.EncodeToString(hash[:])
}</span>

func (s *CoverArtService) sortCoverArtResults(results []CoverArtSearchResult) <span class="cov0" title="0">{
        // Sort by match score descending, then by quality/size
        for i := 0; i &lt; len(results)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(results); j++ </span><span class="cov0" title="0">{
                        if results[i].MatchScore &lt; results[j].MatchScore ||
                                (results[i].MatchScore == results[j].MatchScore &amp;&amp; results[i].Width &lt; results[j].Width) </span><span class="cov0" title="0">{
                                results[i], results[j] = results[j], results[i]
                        }</span>
                }
        }
}

// getCachedCoverArt retrieves cached cover art from the database
func (s *CoverArtService) getCachedCoverArt(ctx context.Context, request *CoverArtSearchRequest) *CoverArtSearchResult <span class="cov0" title="0">{
        // Generate cache key based on request parameters
        cacheKey := s.generateCacheKey(request)

        query := `
                SELECT id, provider, title, artist, album, url, thumbnail_url, width, height,
                       format, quality, size, match_score, source, created_at
                FROM cover_art_cache
                WHERE cache_key = ? AND created_at &gt; ?
                ORDER BY match_score DESC
                LIMIT 1
        `

        // Cache valid for 30 days
        cacheExpiry := time.Now().Add(-30 * 24 * time.Hour)

        var result CoverArtSearchResult
        var album sql.NullString
        var thumbnailURL sql.NullString
        var size sql.NullInt64
        var createdAt time.Time

        err := s.db.QueryRowContext(ctx, query, cacheKey, cacheExpiry).Scan(
                &amp;result.ID, &amp;result.Provider, &amp;result.Title, &amp;result.Artist,
                &amp;album, &amp;result.URL, &amp;thumbnailURL, &amp;result.Width, &amp;result.Height,
                &amp;result.Format, &amp;result.Quality, &amp;size, &amp;result.MatchScore,
                &amp;result.Source, &amp;createdAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to get cached cover art", zap.Error(err))
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">if album.Valid </span><span class="cov0" title="0">{
                result.Album = &amp;album.String
        }</span>
        <span class="cov0" title="0">if thumbnailURL.Valid </span><span class="cov0" title="0">{
                result.ThumbnailURL = &amp;thumbnailURL.String
        }</span>
        <span class="cov0" title="0">if size.Valid </span><span class="cov0" title="0">{
                result.Size = &amp;size.Int64
        }</span>

        <span class="cov0" title="0">return &amp;result</span>
}

// getCoverArtDownloadInfo retrieves cover art download information
func (s *CoverArtService) getCoverArtDownloadInfo(ctx context.Context, resultID string) (*CoverArtSearchResult, error) <span class="cov0" title="0">{
        // For now, return a placeholder - in a real implementation, this would query the database
        // or search results cache for the specific result ID
        return &amp;CoverArtSearchResult{
                ID:       resultID,
                Provider: CoverArtProviderLocal,
                URL:      "",
                Quality:  QualityHigh,
                Source:   "cache",
        }, nil
}</span>

// processAndSaveCoverArt processes and saves cover art
func (s *CoverArtService) processAndSaveCoverArt(ctx context.Context, mediaItemID int64, imageData []byte, result *CoverArtSearchResult, request *CoverArtDownloadRequest) (*CoverArt, error) <span class="cov0" title="0">{
        // Decode image
        img, format, err := image.Decode(strings.NewReader(string(imageData)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode image: %w", err)
        }</span>

        // Get image dimensions
        <span class="cov0" title="0">bounds := img.Bounds()
        width := bounds.Dx()
        height := bounds.Dy()

        // Generate local path
        coverID := s.generateCoverArtID()
        filename := fmt.Sprintf("%s.%s", coverID, format)
        localPath := filepath.Join(s.cacheDir, filename)

        // Ensure cache directory exists
        if err := os.MkdirAll(s.cacheDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cache directory: %w", err)
        }</span>

        // Save image
        <span class="cov0" title="0">outFile, err := os.Create(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov0" title="0">defer outFile.Close()

        switch format </span>{
        case "jpeg", "jpg":<span class="cov0" title="0">
                err = jpeg.Encode(outFile, img, &amp;jpeg.Options{Quality: 90})</span>
        case "png":<span class="cov0" title="0">
                err = png.Encode(outFile, img)</span>
        default:<span class="cov0" title="0">
                err = jpeg.Encode(outFile, img, &amp;jpeg.Options{Quality: 90})</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save image: %w", err)
        }</span>

        // Get file size
        <span class="cov0" title="0">fileInfo, err := os.Stat(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file info: %w", err)
        }</span>
        <span class="cov0" title="0">size := fileInfo.Size()

        // Create CoverArt record
        now := time.Now()
        coverArt := &amp;CoverArt{
                ID:          coverID,
                MediaItemID: mediaItemID,
                Source:      string(result.Provider),
                LocalPath:   &amp;localPath,
                Width:       &amp;width,
                Height:      &amp;height,
                Format:      format,
                Size:        &amp;size,
                Quality:     string(request.Quality),
                CreatedAt:   now,
                CachedAt:    &amp;now,
        }

        return coverArt, nil</span>
}

// generateAdditionalSizes generates additional sizes of cover art
func (s *CoverArtService) generateAdditionalSizes(ctx context.Context, coverArt *CoverArt, sizes []CoverArtQuality) <span class="cov0" title="0">{
        if coverArt.LocalPath == nil </span><span class="cov0" title="0">{
                s.logger.Warn("Cannot generate additional sizes: no local path")
                return
        }</span>

        // Open source image
        <span class="cov0" title="0">srcFile, err := os.Open(*coverArt.LocalPath)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to open source image", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer srcFile.Close()

        srcImg, _, err := image.Decode(srcFile)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to decode source image", zap.Error(err))
                return
        }</span>

        // Generate each size
        <span class="cov0" title="0">for _, quality := range sizes </span><span class="cov0" title="0">{
                targetSize := 0
                switch quality </span>{
                case QualityThumbnail:<span class="cov0" title="0">
                        targetSize = 150</span>
                case QualityMedium:<span class="cov0" title="0">
                        targetSize = 300</span>
                case QualityHigh:<span class="cov0" title="0">
                        targetSize = 600</span>
                default:<span class="cov0" title="0">
                        continue</span>
                }

                // Resize image
                <span class="cov0" title="0">newImg := image.NewRGBA(image.Rect(0, 0, targetSize, targetSize))
                draw.ApproxBiLinear.Scale(newImg, newImg.Bounds(), srcImg, srcImg.Bounds(), draw.Over, nil)

                // Save resized image
                resizedFilename := fmt.Sprintf("%s_%s.%s", coverArt.ID, quality, coverArt.Format)
                resizedPath := filepath.Join(s.cacheDir, resizedFilename)

                outFile, err := os.Create(resizedPath)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to create resized file",
                                zap.String("quality", string(quality)),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if coverArt.Format == "png" </span><span class="cov0" title="0">{
                        err = png.Encode(outFile, newImg)
                }</span> else<span class="cov0" title="0"> {
                        err = jpeg.Encode(outFile, newImg, &amp;jpeg.Options{Quality: 85})
                }</span>
                <span class="cov0" title="0">outFile.Close()

                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to encode resized image",
                                zap.String("quality", string(quality)),
                                zap.Error(err))
                }</span>
        }
}

// setDefaultCoverArt sets cover art as default for a media item
func (s *CoverArtService) setDefaultCoverArt(ctx context.Context, mediaItemID int64, coverArtID string) error <span class="cov0" title="0">{
        // In a real implementation, this would update the database to mark the cover art as default
        query := `UPDATE cover_art SET is_default = 0 WHERE media_item_id = ?`
        _, err := s.db.ExecContext(ctx, query, mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query = `UPDATE cover_art SET is_default = 1 WHERE id = ? AND media_item_id = ?`
        _, err = s.db.ExecContext(ctx, query, coverArtID, mediaItemID)
        return err</span>
}

// getVideoDuration gets the duration of a video file
func (s *CoverArtService) getVideoDuration(videoPath string) (float64, error) <span class="cov0" title="0">{
        // In a real implementation, this would use ffprobe or similar tool to get video duration
        // For now, return a placeholder duration
        return 120.0, nil
}</span>

// generateVideoThumbnail generates a thumbnail for a video at a specific timestamp
func (s *CoverArtService) generateVideoThumbnail(ctx context.Context, request *VideoThumbnailRequest, timestamp float64, index int) (*CoverArt, error) <span class="cov0" title="0">{
        // In a real implementation, this would use ffmpeg to extract a frame from the video
        // For now, return a placeholder
        coverID := fmt.Sprintf("video_thumb_%d_%d", request.MediaItemID, index)
        now := time.Now()

        return &amp;CoverArt{
                ID:          coverID,
                MediaItemID: request.MediaItemID,
                Source:      "video_thumbnail",
                Quality:     string(request.Quality),
                CreatedAt:   now,
        }, nil
}</span>

// processLocalCoverArt processes local cover art file
func (s *CoverArtService) processLocalCoverArt(ctx context.Context, mediaItemID int64, filePath string) (*CoverArt, error) <span class="cov0" title="0">{
        // Open and decode image
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        img, format, err := image.Decode(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get image dimensions
        <span class="cov0" title="0">bounds := img.Bounds()
        width := bounds.Dx()
        height := bounds.Dy()

        // Get file size
        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">size := fileInfo.Size()

        // Create CoverArt record
        coverID := s.generateCoverArtID()
        now := time.Now()

        coverArt := &amp;CoverArt{
                ID:          coverID,
                MediaItemID: mediaItemID,
                Source:      "local",
                LocalPath:   &amp;filePath,
                Width:       &amp;width,
                Height:      &amp;height,
                Format:      format,
                Size:        &amp;size,
                Quality:     "original",
                CreatedAt:   now,
        }

        return coverArt, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package services

import (
        "context"
        "fmt"
        neturl "net/url"
        "strings"
        "time"

        "catalogizer/internal/models"
)

type DeepLinkingService struct {
        baseURL    string
        apiVersion string
}

type DeepLinkRequest struct {
        MediaID       string                `json:"media_id"`
        MediaMetadata *models.MediaMetadata `json:"media_metadata"`
        TargetApp     string                `json:"target_app,omitempty"`
        Action        string                `json:"action"` // detail, play, download, edit
        Context       *LinkContext          `json:"context,omitempty"`
}

type LinkContext struct {
        UserID       string            `json:"user_id,omitempty"`
        DeviceID     string            `json:"device_id,omitempty"`
        SessionID    string            `json:"session_id,omitempty"`
        ReferrerPage string            `json:"referrer_page,omitempty"`
        Platform     string            `json:"platform,omitempty"` // web, android, ios, desktop
        AppVersion   string            `json:"app_version,omitempty"`
        Preferences  map[string]string `json:"preferences,omitempty"`
        UTMParams    *UTMParameters    `json:"utm_params,omitempty"`
}

type UTMParameters struct {
        Source   string `json:"utm_source,omitempty"`
        Medium   string `json:"utm_medium,omitempty"`
        Campaign string `json:"utm_campaign,omitempty"`
        Term     string `json:"utm_term,omitempty"`
        Content  string `json:"utm_content,omitempty"`
}

type DeepLinkResponse struct {
        Links         map[string]*DeepLink `json:"links"` // Platform -&gt; DeepLink
        UniversalLink string               `json:"universal_link"`
        QRCode        string               `json:"qr_code,omitempty"`
        ShareableLink string               `json:"shareable_link"`
        ExpiresAt     *time.Time           `json:"expires_at,omitempty"`
        TrackingID    string               `json:"tracking_id"`
        SupportedApps []string             `json:"supported_apps"`
        FallbackURL   string               `json:"fallback_url"`
}

type DeepLink struct {
        URL          string                 `json:"url"`
        Scheme       string                 `json:"scheme"`
        Package      string                 `json:"package,omitempty"`   // Android package name
        BundleID     string                 `json:"bundle_id,omitempty"` // iOS bundle ID
        StoreURL     string                 `json:"store_url,omitempty"` // App store download link
        Parameters   map[string]string      `json:"parameters"`
        Headers      map[string]string      `json:"headers,omitempty"`
        PostData     map[string]interface{} `json:"post_data,omitempty"`
        RequiresAuth bool                   `json:"requires_auth"`
        AppVersion   string                 `json:"min_app_version,omitempty"`
        Features     []string               `json:"required_features,omitempty"`
}

type LinkTrackingEvent struct {
        TrackingID   string                 `json:"tracking_id"`
        EventType    string                 `json:"event_type"` // click, open, fallback, error
        Platform     string                 `json:"platform"`
        UserAgent    string                 `json:"user_agent,omitempty"`
        IPAddress    string                 `json:"ip_address,omitempty"`
        Timestamp    time.Time              `json:"timestamp"`
        Success      bool                   `json:"success"`
        ErrorMessage string                 `json:"error_message,omitempty"`
        AppOpened    bool                   `json:"app_opened"`
        FallbackUsed bool                   `json:"fallback_used"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

type AppConfiguration struct {
        AppID         string            `json:"app_id"`
        Name          string            `json:"name"`
        Platforms     []string          `json:"platforms"`
        Schemes       map[string]string `json:"schemes"`      // Platform -&gt; URL scheme
        Packages      map[string]string `json:"packages"`     // Platform -&gt; package/bundle ID
        StoreURLs     map[string]string `json:"store_urls"`   // Platform -&gt; store download URL
        MinVersions   map[string]string `json:"min_versions"` // Platform -&gt; minimum version
        Features      []string          `json:"supported_features"`
        PreferredApps bool              `json:"is_preferred"`
        Active        bool              `json:"is_active"`
}

func NewDeepLinkingService(baseURL, apiVersion string) *DeepLinkingService <span class="cov0" title="0">{
        return &amp;DeepLinkingService{
                baseURL:    baseURL,
                apiVersion: apiVersion,
        }
}</span>

func (dls *DeepLinkingService) GenerateDeepLinks(ctx context.Context, req *DeepLinkRequest) (*DeepLinkResponse, error) <span class="cov0" title="0">{
        // Validate request
        if req.MediaID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("media ID is required")
        }</span>

        <span class="cov0" title="0">trackingID := dls.generateTrackingID()

        response := &amp;DeepLinkResponse{
                Links:         make(map[string]*DeepLink),
                TrackingID:    trackingID,
                SupportedApps: dls.getSupportedApps(),
                FallbackURL:   dls.generateFallbackURL(req),
        }

        // Generate universal link
        response.UniversalLink = dls.generateUniversalLink(req, trackingID)
        response.ShareableLink = response.UniversalLink

        // Generate platform-specific links
        platforms := []string{"web", "android", "ios", "desktop"}

        for _, platform := range platforms </span><span class="cov0" title="0">{
                link, err := dls.generatePlatformLink(ctx, req, platform, trackingID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip platforms that fail
                }
                <span class="cov0" title="0">response.Links[platform] = link</span>
        }

        // Generate QR code for easy sharing
        <span class="cov0" title="0">response.QRCode = dls.generateQRCodeURL(response.UniversalLink)

        // Set expiration for temporary links
        if req.Action == "play" || req.Action == "download" </span><span class="cov0" title="0">{
                expiresAt := time.Now().Add(24 * time.Hour)
                response.ExpiresAt = &amp;expiresAt
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}

func (dls *DeepLinkingService) generatePlatformLink(ctx context.Context, req *DeepLinkRequest, platform, trackingID string) (*DeepLink, error) <span class="cov0" title="0">{
        switch platform </span>{
        case "web":<span class="cov0" title="0">
                return dls.generateWebLink(req, trackingID)</span>
        case "android":<span class="cov0" title="0">
                return dls.generateAndroidLink(req, trackingID)</span>
        case "ios":<span class="cov0" title="0">
                return dls.generateIOSLink(req, trackingID)</span>
        case "desktop":<span class="cov0" title="0">
                return dls.generateDesktopLink(req, trackingID)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported platform: %s", platform)</span>
        }
}

func (dls *DeepLinkingService) generateWebLink(req *DeepLinkRequest, trackingID string) (*DeepLink, error) <span class="cov0" title="0">{
        baseURL := dls.baseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "https://catalogizer.app"
        }</span>

        <span class="cov0" title="0">var path string
        parameters := make(map[string]string)

        switch req.Action </span>{
        case "detail":<span class="cov0" title="0">
                path = fmt.Sprintf("/detail/%s", req.MediaID)</span>
        case "play":<span class="cov0" title="0">
                path = fmt.Sprintf("/play/%s", req.MediaID)
                parameters["autoplay"] = "true"</span>
        case "download":<span class="cov0" title="0">
                path = fmt.Sprintf("/download/%s", req.MediaID)</span>
        case "edit":<span class="cov0" title="0">
                path = fmt.Sprintf("/edit/%s", req.MediaID)</span>
        default:<span class="cov0" title="0">
                path = fmt.Sprintf("/detail/%s", req.MediaID)</span>
        }

        // Add context parameters
        <span class="cov0" title="0">if req.Context != nil </span><span class="cov0" title="0">{
                if req.Context.UserID != "" </span><span class="cov0" title="0">{
                        parameters["user_id"] = req.Context.UserID
                }</span>
                <span class="cov0" title="0">if req.Context.SessionID != "" </span><span class="cov0" title="0">{
                        parameters["session_id"] = req.Context.SessionID
                }</span>
                <span class="cov0" title="0">if req.Context.ReferrerPage != "" </span><span class="cov0" title="0">{
                        parameters["ref"] = req.Context.ReferrerPage
                }</span>

                // Add UTM parameters
                <span class="cov0" title="0">if req.Context.UTMParams != nil </span><span class="cov0" title="0">{
                        if req.Context.UTMParams.Source != "" </span><span class="cov0" title="0">{
                                parameters["utm_source"] = req.Context.UTMParams.Source
                        }</span>
                        <span class="cov0" title="0">if req.Context.UTMParams.Medium != "" </span><span class="cov0" title="0">{
                                parameters["utm_medium"] = req.Context.UTMParams.Medium
                        }</span>
                        <span class="cov0" title="0">if req.Context.UTMParams.Campaign != "" </span><span class="cov0" title="0">{
                                parameters["utm_campaign"] = req.Context.UTMParams.Campaign
                        }</span>
                        <span class="cov0" title="0">if req.Context.UTMParams.Term != "" </span><span class="cov0" title="0">{
                                parameters["utm_term"] = req.Context.UTMParams.Term
                        }</span>
                        <span class="cov0" title="0">if req.Context.UTMParams.Content != "" </span><span class="cov0" title="0">{
                                parameters["utm_content"] = req.Context.UTMParams.Content
                        }</span>
                }
        }

        // Add tracking
        <span class="cov0" title="0">parameters["track"] = trackingID

        // Build URL with parameters
        u, err := neturl.Parse(baseURL + path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">query := u.Query()
        for key, value := range parameters </span><span class="cov0" title="0">{
                query.Set(key, value)
        }</span>
        <span class="cov0" title="0">u.RawQuery = query.Encode()

        return &amp;DeepLink{
                URL:          u.String(),
                Scheme:       "https",
                Parameters:   parameters,
                RequiresAuth: req.Action == "edit" || req.Action == "download",
        }, nil</span>
}

func (dls *DeepLinkingService) generateAndroidLink(req *DeepLinkRequest, trackingID string) (*DeepLink, error) <span class="cov0" title="0">{
        scheme := "catalogizer"
        packageName := "com.catalogizer.app"

        var path string
        parameters := make(map[string]string)

        switch req.Action </span>{
        case "detail":<span class="cov0" title="0">
                path = fmt.Sprintf("detail/%s", req.MediaID)</span>
        case "play":<span class="cov0" title="0">
                path = fmt.Sprintf("play/%s", req.MediaID)
                parameters["autoplay"] = "true"</span>
        case "download":<span class="cov0" title="0">
                path = fmt.Sprintf("download/%s", req.MediaID)</span>
        case "edit":<span class="cov0" title="0">
                path = fmt.Sprintf("edit/%s", req.MediaID)</span>
        default:<span class="cov0" title="0">
                path = fmt.Sprintf("detail/%s", req.MediaID)</span>
        }

        // Add context
        <span class="cov0" title="0">if req.Context != nil </span><span class="cov0" title="0">{
                if req.Context.UserID != "" </span><span class="cov0" title="0">{
                        parameters["user_id"] = req.Context.UserID
                }</span>
                <span class="cov0" title="0">if req.Context.SessionID != "" </span><span class="cov0" title="0">{
                        parameters["session_id"] = req.Context.SessionID
                }</span>
        }

        // Add tracking
        <span class="cov0" title="0">parameters["track"] = trackingID

        // Build Android deep link
        url := fmt.Sprintf("%s://%s", scheme, path)
        if len(parameters) &gt; 0 </span><span class="cov0" title="0">{
                query := make([]string, 0, len(parameters))
                for key, value := range parameters </span><span class="cov0" title="0">{
                        query = append(query, fmt.Sprintf("%s=%s", key, neturl.QueryEscape(value)))
                }</span>
                <span class="cov0" title="0">url += "?" + strings.Join(query, "&amp;")</span>
        }

        <span class="cov0" title="0">return &amp;DeepLink{
                URL:          url,
                Scheme:       scheme,
                Package:      packageName,
                StoreURL:     "https://play.google.com/store/apps/details?id=" + packageName,
                Parameters:   parameters,
                RequiresAuth: req.Action == "edit" || req.Action == "download",
                AppVersion:   "1.0.0",
                Features:     dls.getRequiredFeatures(req),
        }, nil</span>
}

func (dls *DeepLinkingService) generateIOSLink(req *DeepLinkRequest, trackingID string) (*DeepLink, error) <span class="cov0" title="0">{
        scheme := "catalogizer"
        bundleID := "com.catalogizer.app"

        var path string
        parameters := make(map[string]string)

        switch req.Action </span>{
        case "detail":<span class="cov0" title="0">
                path = fmt.Sprintf("detail/%s", req.MediaID)</span>
        case "play":<span class="cov0" title="0">
                path = fmt.Sprintf("play/%s", req.MediaID)
                parameters["autoplay"] = "true"</span>
        case "download":<span class="cov0" title="0">
                path = fmt.Sprintf("download/%s", req.MediaID)</span>
        case "edit":<span class="cov0" title="0">
                path = fmt.Sprintf("edit/%s", req.MediaID)</span>
        default:<span class="cov0" title="0">
                path = fmt.Sprintf("detail/%s", req.MediaID)</span>
        }

        // Add context
        <span class="cov0" title="0">if req.Context != nil </span><span class="cov0" title="0">{
                if req.Context.UserID != "" </span><span class="cov0" title="0">{
                        parameters["user_id"] = req.Context.UserID
                }</span>
                <span class="cov0" title="0">if req.Context.SessionID != "" </span><span class="cov0" title="0">{
                        parameters["session_id"] = req.Context.SessionID
                }</span>
        }

        // Add tracking
        <span class="cov0" title="0">parameters["track"] = trackingID

        // Build iOS deep link
        url := fmt.Sprintf("%s://%s", scheme, path)
        if len(parameters) &gt; 0 </span><span class="cov0" title="0">{
                query := make([]string, 0, len(parameters))
                for key, value := range parameters </span><span class="cov0" title="0">{
                        query = append(query, fmt.Sprintf("%s=%s", key, neturl.QueryEscape(value)))
                }</span>
                <span class="cov0" title="0">url += "?" + strings.Join(query, "&amp;")</span>
        }

        <span class="cov0" title="0">return &amp;DeepLink{
                URL:          url,
                Scheme:       scheme,
                BundleID:     bundleID,
                StoreURL:     "https://apps.apple.com/app/id123456789", // Would be actual App Store ID
                Parameters:   parameters,
                RequiresAuth: req.Action == "edit" || req.Action == "download",
                AppVersion:   "1.0.0",
                Features:     dls.getRequiredFeatures(req),
        }, nil</span>
}

func (dls *DeepLinkingService) generateDesktopLink(req *DeepLinkRequest, trackingID string) (*DeepLink, error) <span class="cov0" title="0">{
        scheme := "catalogizer-desktop"

        var path string
        parameters := make(map[string]string)

        switch req.Action </span>{
        case "detail":<span class="cov0" title="0">
                path = fmt.Sprintf("detail/%s", req.MediaID)</span>
        case "play":<span class="cov0" title="0">
                path = fmt.Sprintf("play/%s", req.MediaID)
                parameters["autoplay"] = "true"</span>
        case "download":<span class="cov0" title="0">
                path = fmt.Sprintf("download/%s", req.MediaID)</span>
        case "edit":<span class="cov0" title="0">
                path = fmt.Sprintf("edit/%s", req.MediaID)</span>
        default:<span class="cov0" title="0">
                path = fmt.Sprintf("detail/%s", req.MediaID)</span>
        }

        // Add context
        <span class="cov0" title="0">if req.Context != nil </span><span class="cov0" title="0">{
                if req.Context.UserID != "" </span><span class="cov0" title="0">{
                        parameters["user_id"] = req.Context.UserID
                }</span>
                <span class="cov0" title="0">if req.Context.SessionID != "" </span><span class="cov0" title="0">{
                        parameters["session_id"] = req.Context.SessionID
                }</span>
        }

        // Add tracking
        <span class="cov0" title="0">parameters["track"] = trackingID

        // Build desktop deep link
        url := fmt.Sprintf("%s://%s", scheme, path)
        if len(parameters) &gt; 0 </span><span class="cov0" title="0">{
                query := make([]string, 0, len(parameters))
                for key, value := range parameters </span><span class="cov0" title="0">{
                        query = append(query, fmt.Sprintf("%s=%s", key, neturl.QueryEscape(value)))
                }</span>
                <span class="cov0" title="0">url += "?" + strings.Join(query, "&amp;")</span>
        }

        <span class="cov0" title="0">return &amp;DeepLink{
                URL:          url,
                Scheme:       scheme,
                StoreURL:     "https://github.com/catalogizer/desktop/releases", // GitHub releases
                Parameters:   parameters,
                RequiresAuth: req.Action == "edit" || req.Action == "download",
                AppVersion:   "1.0.0",
                Features:     dls.getRequiredFeatures(req),
        }, nil</span>
}

func (dls *DeepLinkingService) generateUniversalLink(req *DeepLinkRequest, trackingID string) string <span class="cov0" title="0">{
        baseURL := dls.baseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "https://catalogizer.app"
        }</span>

        <span class="cov0" title="0">switch req.Action </span>{
        case "detail":<span class="cov0" title="0">
                return fmt.Sprintf("%s/link/detail/%s?track=%s", baseURL, req.MediaID, trackingID)</span>
        case "play":<span class="cov0" title="0">
                return fmt.Sprintf("%s/link/play/%s?track=%s", baseURL, req.MediaID, trackingID)</span>
        case "download":<span class="cov0" title="0">
                return fmt.Sprintf("%s/link/download/%s?track=%s", baseURL, req.MediaID, trackingID)</span>
        case "edit":<span class="cov0" title="0">
                return fmt.Sprintf("%s/link/edit/%s?track=%s", baseURL, req.MediaID, trackingID)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%s/link/detail/%s?track=%s", baseURL, req.MediaID, trackingID)</span>
        }
}

func (dls *DeepLinkingService) generateFallbackURL(req *DeepLinkRequest) string <span class="cov0" title="0">{
        baseURL := dls.baseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "https://catalogizer.app"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s/detail/%s", baseURL, req.MediaID)</span>
}

func (dls *DeepLinkingService) generateQRCodeURL(link string) string <span class="cov0" title="0">{
        // Use a QR code generation service
        return fmt.Sprintf("https://api.qrserver.com/v1/create-qr-code/?size=200x200&amp;data=%s", neturl.QueryEscape(link))
}</span>

func (dls *DeepLinkingService) generateTrackingID() string <span class="cov0" title="0">{
        // Generate unique tracking ID
        return fmt.Sprintf("track_%d", time.Now().UnixNano())
}</span>

func (dls *DeepLinkingService) getSupportedApps() []string <span class="cov0" title="0">{
        return []string{
                "catalogizer-web",
                "catalogizer-android",
                "catalogizer-ios",
                "catalogizer-desktop",
                "catalogizer-tv",
        }
}</span>

func (dls *DeepLinkingService) getRequiredFeatures(req *DeepLinkRequest) []string <span class="cov0" title="0">{
        var features []string

        // Base features based on action
        if req.Action == "play" </span><span class="cov0" title="0">{
                features = append(features, "media_playback")
        }</span>

        <span class="cov0" title="0">if req.Action == "download" </span><span class="cov0" title="0">{
                features = append(features, "file_download")
        }</span>

        <span class="cov0" title="0">if req.Action == "edit" </span><span class="cov0" title="0">{
                features = append(features, "file_edit", "user_authentication")
        }</span>

        // Media type specific features
        <span class="cov0" title="0">if req.MediaMetadata != nil &amp;&amp; req.MediaMetadata.MediaType != "" </span><span class="cov0" title="0">{
                switch req.MediaMetadata.MediaType </span>{
                case "video":<span class="cov0" title="0">
                        if req.Action == "play" </span><span class="cov0" title="0">{
                                features = append(features, "video_playback", "fullscreen_video")
                        }</span>
                case "audio":<span class="cov0" title="0">
                        if req.Action == "play" </span><span class="cov0" title="0">{
                                features = append(features, "audio_playback", "background_audio")
                        }</span>
                case "book":<span class="cov0" title="0">
                        features = append(features, "pdf_reader", "epub_reader")</span>
                case "game":<span class="cov0" title="0">
                        features = append(features, "external_app_launch")</span>
                }
        }

        <span class="cov0" title="0">return features</span>
}

// Link tracking methods
func (dls *DeepLinkingService) TrackLinkEvent(ctx context.Context, event *LinkTrackingEvent) error <span class="cov0" title="0">{
        // This would normally store the event in a database or analytics service
        // For now, we'll just log it
        fmt.Printf("Link tracking event: %+v\n", event)
        return nil
}</span>

func (dls *DeepLinkingService) GetLinkAnalytics(ctx context.Context, trackingID string) (*LinkAnalytics, error) <span class="cov0" title="0">{
        // This would normally retrieve analytics from storage
        // Mock implementation
        return &amp;LinkAnalytics{
                TrackingID:   trackingID,
                TotalClicks:  45,
                UniqueClicks: 32,
                PlatformBreakdown: map[string]int{
                        "web":     20,
                        "android": 15,
                        "ios":     8,
                        "desktop": 2,
                },
                ConversionRate: 0.71, // 71% opened the app
                FirstClickAt:   time.Now().Add(-24 * time.Hour),
                LastClickAt:    time.Now().Add(-1 * time.Hour),
        }, nil
}</span>

type LinkAnalytics struct {
        TrackingID        string         `json:"tracking_id"`
        TotalClicks       int            `json:"total_clicks"`
        UniqueClicks      int            `json:"unique_clicks"`
        PlatformBreakdown map[string]int `json:"platform_breakdown"`
        ConversionRate    float64        `json:"conversion_rate"`
        FirstClickAt      time.Time      `json:"first_click_at"`
        LastClickAt       time.Time      `json:"last_click_at"`
}

// App registration and configuration
func (dls *DeepLinkingService) RegisterApp(ctx context.Context, config *AppConfiguration) error <span class="cov0" title="0">{
        // This would normally store the app configuration
        // For now, we'll just validate it
        if config.AppID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app_id is required")
        }</span>
        <span class="cov0" title="0">if config.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app name is required")
        }</span>
        <span class="cov0" title="0">if len(config.Platforms) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one platform is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (dls *DeepLinkingService) GetAppConfiguration(ctx context.Context, appID string) (*AppConfiguration, error) <span class="cov0" title="0">{
        // Mock implementation - would normally retrieve from storage
        return &amp;AppConfiguration{
                AppID:     appID,
                Name:      "Catalogizer",
                Platforms: []string{"web", "android", "ios", "desktop"},
                Schemes: map[string]string{
                        "web":     "https",
                        "android": "catalogizer",
                        "ios":     "catalogizer",
                        "desktop": "catalogizer-desktop",
                },
                Packages: map[string]string{
                        "android": "com.catalogizer.app",
                        "ios":     "com.catalogizer.app",
                },
                StoreURLs: map[string]string{
                        "android": "https://play.google.com/store/apps/details?id=com.catalogizer.app",
                        "ios":     "https://apps.apple.com/app/id123456789",
                        "desktop": "https://github.com/catalogizer/desktop/releases",
                },
                MinVersions: map[string]string{
                        "android": "1.0.0",
                        "ios":     "1.0.0",
                        "desktop": "1.0.0",
                },
                Features:      []string{"video_playback", "audio_playback", "pdf_reader", "file_download"},
                PreferredApps: true,
                Active:        true,
        }, nil
}</span>

// Smart link routing based on user context
func (dls *DeepLinkingService) GenerateSmartLink(ctx context.Context, req *DeepLinkRequest) (*SmartLinkResponse, error) <span class="cov0" title="0">{
        // Analyze user context to determine best link strategy
        strategy := dls.determineRoutingStrategy(req.Context)

        response := &amp;SmartLinkResponse{
                Strategy:      strategy,
                PrimaryLink:   "",
                FallbackLinks: make([]string, 0),
                Instructions:  make(map[string]string),
        }

        switch strategy </span>{
        case "native_preferred":<span class="cov0" title="0">
                // Try native app first, fallback to web
                if req.Context.Platform == "android" </span><span class="cov0" title="0">{
                        androidLink, _ := dls.generateAndroidLink(req, dls.generateTrackingID())
                        response.PrimaryLink = androidLink.URL
                        webLink, _ := dls.generateWebLink(req, dls.generateTrackingID())
                        response.FallbackLinks = append(response.FallbackLinks, webLink.URL)
                }</span> else<span class="cov0" title="0"> if req.Context.Platform == "ios" </span><span class="cov0" title="0">{
                        iosLink, _ := dls.generateIOSLink(req, dls.generateTrackingID())
                        response.PrimaryLink = iosLink.URL
                        webLink, _ := dls.generateWebLink(req, dls.generateTrackingID())
                        response.FallbackLinks = append(response.FallbackLinks, webLink.URL)
                }</span>

        case "web_only":<span class="cov0" title="0">
                // Web-only strategy
                webLink, _ := dls.generateWebLink(req, dls.generateTrackingID())
                response.PrimaryLink = webLink.URL</span>

        case "universal":<span class="cov0" title="0">
                // Universal link that detects platform
                response.PrimaryLink = dls.generateUniversalLink(req, dls.generateTrackingID())</span>
        }

        // Add usage instructions
        <span class="cov0" title="0">response.Instructions["primary"] = "Tap to open in your preferred app"
        response.Instructions["fallback"] = "If the app doesn't open, use the web version"

        return response, nil</span>
}

type SmartLinkResponse struct {
        Strategy      string            `json:"strategy"`
        PrimaryLink   string            `json:"primary_link"`
        FallbackLinks []string          `json:"fallback_links"`
        Instructions  map[string]string `json:"instructions"`
}

func (dls *DeepLinkingService) determineRoutingStrategy(context *LinkContext) string <span class="cov0" title="0">{
        if context == nil </span><span class="cov0" title="0">{
                return "universal"
        }</span>

        // Determine strategy based on context
        <span class="cov0" title="0">switch context.Platform </span>{
        case "android", "ios":<span class="cov0" title="0">
                return "native_preferred"</span>
        case "web":<span class="cov0" title="0">
                return "web_only"</span>
        default:<span class="cov0" title="0">
                return "universal"</span>
        }
}

// Batch link generation for multiple items
func (dls *DeepLinkingService) GenerateBatchLinks(ctx context.Context, requests []*DeepLinkRequest) ([]*DeepLinkResponse, error) <span class="cov0" title="0">{
        responses := make([]*DeepLinkResponse, 0, len(requests))

        for _, req := range requests </span><span class="cov0" title="0">{
                response, err := dls.GenerateDeepLinks(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        // Continue with others even if one fails
                        continue</span>
                }
                <span class="cov0" title="0">responses = append(responses, response)</span>
        }

        <span class="cov0" title="0">return responses, nil</span>
}

// Link validation and testing
func (dls *DeepLinkingService) ValidateLinks(ctx context.Context, links []*DeepLink) (*ValidationResult, error) <span class="cov0" title="0">{
        result := &amp;ValidationResult{
                TotalLinks:   len(links),
                ValidLinks:   0,
                InvalidLinks: 0,
                Warnings:     make([]string, 0),
                Errors:       make([]string, 0),
        }

        for _, link := range links </span><span class="cov0" title="0">{
                if dls.validateLink(link) </span><span class="cov0" title="0">{
                        result.ValidLinks++
                }</span> else<span class="cov0" title="0"> {
                        result.InvalidLinks++
                        result.Errors = append(result.Errors, fmt.Sprintf("Invalid link: %s", link.URL))
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

type ValidationResult struct {
        TotalLinks   int      `json:"total_links"`
        ValidLinks   int      `json:"valid_links"`
        InvalidLinks int      `json:"invalid_links"`
        Warnings     []string `json:"warnings"`
        Errors       []string `json:"errors"`
}

func (dls *DeepLinkingService) validateLink(link *DeepLink) bool <span class="cov0" title="0">{
        if link.URL == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if link.Scheme == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        // Add more validation logic as needed
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package services

import (
        "context"
        "database/sql"
        "math"
        "regexp"
        "strings"
        "time"

        "go.uber.org/zap"
)

// Duplicate detection and deduplication service
type DuplicateDetectionService struct {
        db           *sql.DB
        logger       *zap.Logger
        cacheService *CacheService
}

// Duplicate detection result
type DuplicateGroup struct {
        ID              string          `json:"id"`
        MediaType       MediaType       `json:"media_type"`
        PrimaryItem     DuplicateItem   `json:"primary_item"`
        DuplicateItems  []DuplicateItem `json:"duplicate_items"`
        Confidence      float64         `json:"confidence"`
        DetectionMethod string          `json:"detection_method"`
        MatchTypes      []string        `json:"match_types"`
        CreatedAt       time.Time       `json:"created_at"`
        UpdatedAt       time.Time       `json:"updated_at"`
        Status          string          `json:"status"` // pending, confirmed, dismissed
        AutoResolved    bool            `json:"auto_resolved"`
}

type DuplicateItem struct {
        MediaID      string                 `json:"media_id"`
        FilePath     string                 `json:"file_path"`
        FileName     string                 `json:"file_name"`
        FileSize     int64                  `json:"file_size"`
        FileHash     string                 `json:"file_hash"`
        Title        string                 `json:"title"`
        Artist       string                 `json:"artist,omitempty"`
        Album        string                 `json:"album,omitempty"`
        Director     string                 `json:"director,omitempty"`
        Author       string                 `json:"author,omitempty"`
        Year         int                    `json:"year,omitempty"`
        Duration     int64                  `json:"duration,omitempty"`
        Quality      string                 `json:"quality,omitempty"`
        Format       string                 `json:"format,omitempty"`
        Bitrate      int                    `json:"bitrate,omitempty"`
        Resolution   string                 `json:"resolution,omitempty"`
        ExternalIDs  map[string]string      `json:"external_ids"`
        Fingerprints map[string]string      `json:"fingerprints"`
        Similarity   float64                `json:"similarity"`
        MatchReasons []string               `json:"match_reasons"`
        Metadata     map[string]interface{} `json:"metadata"`
        AddedAt      time.Time              `json:"added_at"`
        LastSeen     time.Time              `json:"last_seen"`
}

// Similarity calculation components
type SimilarityAnalysis struct {
        OverallScore          float64            `json:"overall_score"`
        TitleSimilarity       float64            `json:"title_similarity"`
        MetadataSimilarity    float64            `json:"metadata_similarity"`
        FingerprintSimilarity float64            `json:"fingerprint_similarity"`
        FileSimilarity        float64            `json:"file_similarity"`
        ExternalIDMatch       bool               `json:"external_id_match"`
        HashMatch             bool               `json:"hash_match"`
        Components            map[string]float64 `json:"components"`
        MatchingFields        []string           `json:"matching_fields"`
        DifferencesFound      []string           `json:"differences_found"`
}

// Text similarity algorithms
type TextSimilarityMetrics struct {
        LevenshteinDistance int     `json:"levenshtein_distance"`
        JaroWinklerScore    float64 `json:"jaro_winkler_score"`
        CosineSimilarity    float64 `json:"cosine_similarity"`
        JaccardIndex        float64 `json:"jaccard_index"`
        LCSRatio            float64 `json:"lcs_ratio"`
        SoundexMatch        bool    `json:"soundex_match"`
        MetaphoneMatch      bool    `json:"metaphone_match"`
}

// Deduplication action
type DeduplicationAction struct {
        GroupID       string                 `json:"group_id"`
        Action        string                 `json:"action"` // keep_primary, keep_best_quality, merge, custom
        PrimaryItemID string                 `json:"primary_item_id"`
        ItemsToRemove []string               `json:"items_to_remove"`
        ItemsToKeep   []string               `json:"items_to_keep"`
        MergeStrategy string                 `json:"merge_strategy,omitempty"`
        UserID        int64                  `json:"user_id"`
        Reason        string                 `json:"reason"`
        ExecutedAt    time.Time              `json:"executed_at"`
        RollbackData  map[string]interface{} `json:"rollback_data,omitempty"`
}

// Duplicate detection request
type DuplicateDetectionRequest struct {
        MediaTypes       []MediaType `json:"media_types,omitempty"`
        IncludePaths     []string    `json:"include_paths,omitempty"`
        ExcludePaths     []string    `json:"exclude_paths,omitempty"`
        MinSimilarity    float64     `json:"min_similarity"`
        DetectionMethods []string    `json:"detection_methods"`
        IncludeExisting  bool        `json:"include_existing"`
        BatchSize        int         `json:"batch_size"`
        UserID           int64       `json:"user_id"`
}

func NewDuplicateDetectionService(
        db *sql.DB,
        logger *zap.Logger,
        cacheService *CacheService,
) *DuplicateDetectionService <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = zap.NewNop()
        }</span>
        <span class="cov0" title="0">return &amp;DuplicateDetectionService{
                db:           db,
                logger:       logger,
                cacheService: cacheService,
        }</span>
}

// Main duplicate detection method
func (s *DuplicateDetectionService) DetectDuplicates(ctx context.Context, req *DuplicateDetectionRequest) ([]DuplicateGroup, error) <span class="cov0" title="0">{
        s.logger.Info("Starting duplicate detection",
                zap.Int("media_types", len(req.MediaTypes)),
                zap.Float64("min_similarity", req.MinSimilarity),
                zap.Int64("user_id", req.UserID))

        var duplicateGroups []DuplicateGroup

        // Process each media type
        mediaTypes := req.MediaTypes
        if len(mediaTypes) == 0 </span><span class="cov0" title="0">{
                // Default to all types
                mediaTypes = []MediaType{
                        MediaTypeMovie, MediaTypeTVSeries, MediaTypeTVEpisode,
                        MediaTypeMusic, MediaTypeAlbum, MediaTypeAudiobook,
                        MediaTypeBook, MediaTypeComicBook, MediaTypeMagazine,
                        MediaTypeGame, MediaTypeSoftware,
                }
        }</span>

        <span class="cov0" title="0">for _, mediaType := range mediaTypes </span><span class="cov0" title="0">{
                groups, err := s.detectDuplicatesForMediaType(ctx, mediaType, req)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to detect duplicates for media type",
                                zap.String("media_type", string(mediaType)),
                                zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">duplicateGroups = append(duplicateGroups, groups...)</span>
        }

        // Store detected duplicates
        <span class="cov0" title="0">for _, group := range duplicateGroups </span><span class="cov0" title="0">{
                if err := s.storeDuplicateGroup(ctx, &amp;group); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to store duplicate group",
                                zap.String("group_id", group.ID),
                                zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">s.logger.Info("Duplicate detection completed",
                zap.Int("groups_found", len(duplicateGroups)))

        return duplicateGroups, nil</span>
}

// Detect duplicates for a specific media type
func (s *DuplicateDetectionService) detectDuplicatesForMediaType(ctx context.Context, mediaType MediaType, req *DuplicateDetectionRequest) ([]DuplicateGroup, error) <span class="cov0" title="0">{
        // Get all items of this media type
        items, err := s.getMediaItems(ctx, mediaType, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(items) &lt; 2 </span><span class="cov0" title="0">{
                return []DuplicateGroup{}, nil
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Processing media items for duplicates",
                zap.String("media_type", string(mediaType)),
                zap.Int("item_count", len(items)))

        var duplicateGroups []DuplicateGroup

        // Compare each item with every other item
        for i := 0; i &lt; len(items); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(items); j++ </span><span class="cov0" title="0">{
                        similarity := s.calculateSimilarity(ctx, &amp;items[i], &amp;items[j], mediaType)

                        if similarity.OverallScore &gt;= req.MinSimilarity </span><span class="cov0" title="0">{
                                // Create or add to duplicate group
                                group := s.createOrAddToDuplicateGroup(duplicateGroups, items[i], items[j], similarity, mediaType)
                                if group != nil </span><span class="cov0" title="0">{
                                        duplicateGroups = s.mergeDuplicateGroup(duplicateGroups, *group)
                                }</span>
                        }
                }
        }

        // Post-process groups to determine primary items
        <span class="cov0" title="0">for i := range duplicateGroups </span><span class="cov0" title="0">{
                s.determinePrimaryItem(&amp;duplicateGroups[i])
        }</span>

        <span class="cov0" title="0">return duplicateGroups, nil</span>
}

// Calculate similarity between two media items
func (s *DuplicateDetectionService) calculateSimilarity(ctx context.Context, item1, item2 *DuplicateItem, mediaType MediaType) *SimilarityAnalysis <span class="cov0" title="0">{
        analysis := &amp;SimilarityAnalysis{
                Components:       make(map[string]float64),
                MatchingFields:   []string{},
                DifferencesFound: []string{},
        }

        // 1. Exact hash match (highest priority)
        if item1.FileHash != "" &amp;&amp; item2.FileHash != "" &amp;&amp; item1.FileHash == item2.FileHash </span><span class="cov0" title="0">{
                analysis.HashMatch = true
                analysis.OverallScore = 1.0
                analysis.MatchingFields = append(analysis.MatchingFields, "file_hash")
                return analysis
        }</span>

        // 2. External ID match
        <span class="cov0" title="0">for key, id1 := range item1.ExternalIDs </span><span class="cov0" title="0">{
                if id2, exists := item2.ExternalIDs[key]; exists &amp;&amp; id1 == id2 &amp;&amp; id1 != "" </span><span class="cov0" title="0">{
                        analysis.ExternalIDMatch = true
                        analysis.OverallScore = 0.95
                        analysis.MatchingFields = append(analysis.MatchingFields, "external_id_"+key)
                        return analysis
                }</span>
        }

        // 3. Comprehensive similarity calculation
        <span class="cov0" title="0">weights := s.getSimilarityWeights(mediaType)

        // Title similarity
        analysis.TitleSimilarity = s.calculateTextSimilarity(item1.Title, item2.Title)
        analysis.Components["title"] = analysis.TitleSimilarity * weights["title"]

        // Metadata similarity based on media type
        switch mediaType </span>{
        case MediaTypeMovie, MediaTypeTVSeries, MediaTypeTVEpisode:<span class="cov0" title="0">
                analysis.MetadataSimilarity = s.calculateVideoMetadataSimilarity(item1, item2)</span>
        case MediaTypeMusic, MediaTypeAlbum, MediaTypeAudiobook:<span class="cov0" title="0">
                analysis.MetadataSimilarity = s.calculateAudioMetadataSimilarity(item1, item2)</span>
        case MediaTypeBook, MediaTypeComicBook, MediaTypeMagazine:<span class="cov0" title="0">
                analysis.MetadataSimilarity = s.calculateBookMetadataSimilarity(item1, item2)</span>
        case MediaTypeGame, MediaTypeSoftware:<span class="cov0" title="0">
                analysis.MetadataSimilarity = s.calculateSoftwareMetadataSimilarity(item1, item2)</span>
        default:<span class="cov0" title="0">
                analysis.MetadataSimilarity = s.calculateGenericMetadataSimilarity(item1, item2)</span>
        }
        <span class="cov0" title="0">analysis.Components["metadata"] = analysis.MetadataSimilarity * weights["metadata"]

        // Fingerprint similarity
        if len(item1.Fingerprints) &gt; 0 &amp;&amp; len(item2.Fingerprints) &gt; 0 </span><span class="cov0" title="0">{
                analysis.FingerprintSimilarity = s.calculateFingerprintSimilarity(item1.Fingerprints, item2.Fingerprints)
                analysis.Components["fingerprint"] = analysis.FingerprintSimilarity * weights["fingerprint"]
        }</span>

        // File similarity (size, format, quality)
        <span class="cov0" title="0">analysis.FileSimilarity = s.calculateFileSimilarity(item1, item2)
        analysis.Components["file"] = analysis.FileSimilarity * weights["file"]

        // Calculate overall score
        totalWeight := 0.0
        for _, weight := range weights </span><span class="cov0" title="0">{
                totalWeight += weight
        }</span>

        <span class="cov0" title="0">analysis.OverallScore = 0.0
        for _, score := range analysis.Components </span><span class="cov0" title="0">{
                analysis.OverallScore += score
        }</span>
        <span class="cov0" title="0">if totalWeight &gt; 0 </span><span class="cov0" title="0">{
                analysis.OverallScore /= totalWeight
        }</span>

        // Determine matching fields and differences
        <span class="cov0" title="0">s.analyzeFieldMatches(item1, item2, analysis)

        return analysis</span>
}

// Calculate text similarity using multiple algorithms
func (s *DuplicateDetectionService) calculateTextSimilarity(text1, text2 string) float64 <span class="cov0" title="0">{
        if text1 == "" || text2 == "" </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Normalize texts
        <span class="cov0" title="0">norm1 := s.normalizeText(text1)
        norm2 := s.normalizeText(text2)

        if norm1 == norm2 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        // Calculate multiple similarity metrics
        <span class="cov0" title="0">metrics := s.calculateTextMetrics(norm1, norm2)

        // Weighted combination of metrics
        score := 0.0
        score += metrics.JaroWinklerScore * 0.4
        score += metrics.CosineSimilarity * 0.3
        score += metrics.JaccardIndex * 0.2
        score += metrics.LCSRatio * 0.1

        // Bonus for exact phonetic matches
        if metrics.SoundexMatch </span><span class="cov0" title="0">{
                score += 0.1
        }</span>
        <span class="cov0" title="0">if metrics.MetaphoneMatch </span><span class="cov0" title="0">{
                score += 0.1
        }</span>

        <span class="cov0" title="0">if score &gt; 1.0 </span><span class="cov0" title="0">{
                score = 1.0
        }</span>

        <span class="cov0" title="0">return score</span>
}

// Calculate video metadata similarity
func (s *DuplicateDetectionService) calculateVideoMetadataSimilarity(item1, item2 *DuplicateItem) float64 <span class="cov0" title="0">{
        score := 0.0
        components := 0

        // Director similarity
        if item1.Director != "" &amp;&amp; item2.Director != "" </span><span class="cov0" title="0">{
                score += s.calculateTextSimilarity(item1.Director, item2.Director)
                components++
        }</span>

        // Year similarity
        <span class="cov0" title="0">if item1.Year &gt; 0 &amp;&amp; item2.Year &gt; 0 </span><span class="cov0" title="0">{
                yearDiff := math.Abs(float64(item1.Year - item2.Year))
                yearScore := math.Max(0, 1.0-yearDiff/5.0) // Penalty for year differences
                score += yearScore
                components++
        }</span>

        // Duration similarity
        <span class="cov0" title="0">if item1.Duration &gt; 0 &amp;&amp; item2.Duration &gt; 0 </span><span class="cov0" title="0">{
                durationDiff := math.Abs(float64(item1.Duration - item2.Duration))
                durationScore := math.Max(0, 1.0-durationDiff/600000) // 10 minute tolerance
                score += durationScore
                components++
        }</span>

        // Quality/Resolution similarity
        <span class="cov0" title="0">if item1.Quality != "" &amp;&amp; item2.Quality != "" </span><span class="cov0" title="0">{
                qualityScore := 0.0
                if item1.Quality == item2.Quality </span><span class="cov0" title="0">{
                        qualityScore = 1.0
                }</span> else<span class="cov0" title="0"> if s.areQualitiesSimilar(item1.Quality, item2.Quality) </span><span class="cov0" title="0">{
                        qualityScore = 0.7
                }</span>
                <span class="cov0" title="0">score += qualityScore
                components++</span>
        }

        <span class="cov0" title="0">if components &gt; 0 </span><span class="cov0" title="0">{
                return score / float64(components)
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// Calculate audio metadata similarity
func (s *DuplicateDetectionService) calculateAudioMetadataSimilarity(item1, item2 *DuplicateItem) float64 <span class="cov0" title="0">{
        score := 0.0
        components := 0

        // Artist similarity
        if item1.Artist != "" &amp;&amp; item2.Artist != "" </span><span class="cov0" title="0">{
                score += s.calculateTextSimilarity(item1.Artist, item2.Artist)
                components++
        }</span>

        // Album similarity
        <span class="cov0" title="0">if item1.Album != "" &amp;&amp; item2.Album != "" </span><span class="cov0" title="0">{
                score += s.calculateTextSimilarity(item1.Album, item2.Album)
                components++
        }</span>

        // Year similarity
        <span class="cov0" title="0">if item1.Year &gt; 0 &amp;&amp; item2.Year &gt; 0 </span><span class="cov0" title="0">{
                yearDiff := math.Abs(float64(item1.Year - item2.Year))
                yearScore := math.Max(0, 1.0-yearDiff/2.0) // Smaller tolerance for music
                score += yearScore
                components++
        }</span>

        // Duration similarity
        <span class="cov0" title="0">if item1.Duration &gt; 0 &amp;&amp; item2.Duration &gt; 0 </span><span class="cov0" title="0">{
                durationDiff := math.Abs(float64(item1.Duration - item2.Duration))
                durationScore := math.Max(0, 1.0-durationDiff/30000) // 30 second tolerance
                score += durationScore
                components++
        }</span>

        // Bitrate similarity
        <span class="cov0" title="0">if item1.Bitrate &gt; 0 &amp;&amp; item2.Bitrate &gt; 0 </span><span class="cov0" title="0">{
                bitrateDiff := math.Abs(float64(item1.Bitrate - item2.Bitrate))
                bitrateScore := math.Max(0, 1.0-bitrateDiff/320) // Normalize by 320kbps
                score += bitrateScore
                components++
        }</span>

        <span class="cov0" title="0">if components &gt; 0 </span><span class="cov0" title="0">{
                return score / float64(components)
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// Calculate book metadata similarity
func (s *DuplicateDetectionService) calculateBookMetadataSimilarity(item1, item2 *DuplicateItem) float64 <span class="cov0" title="0">{
        score := 0.0
        components := 0

        // Author similarity
        if item1.Author != "" &amp;&amp; item2.Author != "" </span><span class="cov0" title="0">{
                score += s.calculateTextSimilarity(item1.Author, item2.Author)
                components++
        }</span>

        // Year similarity
        <span class="cov0" title="0">if item1.Year &gt; 0 &amp;&amp; item2.Year &gt; 0 </span><span class="cov0" title="0">{
                yearDiff := math.Abs(float64(item1.Year - item2.Year))
                yearScore := math.Max(0, 1.0-yearDiff/5.0)
                score += yearScore
                components++
        }</span>

        // Check for ISBN matches in external IDs
        <span class="cov0" title="0">isbn1 := s.extractISBN(item1.ExternalIDs)
        isbn2 := s.extractISBN(item2.ExternalIDs)
        if isbn1 != "" &amp;&amp; isbn2 != "" </span><span class="cov0" title="0">{
                if isbn1 == isbn2 </span><span class="cov0" title="0">{
                        score += 1.0
                }</span> else<span class="cov0" title="0"> if s.areISBNsRelated(isbn1, isbn2) </span><span class="cov0" title="0">{
                        score += 0.8
                }</span>
                <span class="cov0" title="0">components++</span>
        }

        <span class="cov0" title="0">if components &gt; 0 </span><span class="cov0" title="0">{
                return score / float64(components)
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// Calculate software metadata similarity
func (s *DuplicateDetectionService) calculateSoftwareMetadataSimilarity(item1, item2 *DuplicateItem) float64 <span class="cov0" title="0">{
        score := 0.0
        components := 0

        // Version similarity
        version1 := s.extractVersion(item1.Metadata)
        version2 := s.extractVersion(item2.Metadata)
        if version1 != "" &amp;&amp; version2 != "" </span><span class="cov0" title="0">{
                score += s.calculateVersionSimilarity(version1, version2)
                components++
        }</span>

        // Platform similarity
        <span class="cov0" title="0">platform1 := s.extractPlatform(item1.Metadata)
        platform2 := s.extractPlatform(item2.Metadata)
        if platform1 != "" &amp;&amp; platform2 != "" </span><span class="cov0" title="0">{
                if platform1 == platform2 </span><span class="cov0" title="0">{
                        score += 1.0
                }</span> else<span class="cov0" title="0"> if s.arePlatformsSimilar(platform1, platform2) </span><span class="cov0" title="0">{
                        score += 0.5
                }</span>
                <span class="cov0" title="0">components++</span>
        }

        // File size similarity (important for software)
        <span class="cov0" title="0">if item1.FileSize &gt; 0 &amp;&amp; item2.FileSize &gt; 0 </span><span class="cov0" title="0">{
                sizeDiff := math.Abs(float64(item1.FileSize - item2.FileSize))
                sizeScore := math.Max(0, 1.0-sizeDiff/float64(math.Max(float64(item1.FileSize), float64(item2.FileSize))))
                score += sizeScore
                components++
        }</span>

        <span class="cov0" title="0">if components &gt; 0 </span><span class="cov0" title="0">{
                return score / float64(components)
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// Calculate generic metadata similarity
func (s *DuplicateDetectionService) calculateGenericMetadataSimilarity(item1, item2 *DuplicateItem) float64 <span class="cov0" title="0">{
        score := 0.0
        components := 0

        // File name similarity
        score += s.calculateTextSimilarity(item1.FileName, item2.FileName)
        components++

        // Format similarity
        if item1.Format != "" &amp;&amp; item2.Format != "" </span><span class="cov0" title="0">{
                if item1.Format == item2.Format </span><span class="cov0" title="0">{
                        score += 1.0
                }</span> else<span class="cov0" title="0"> if s.areFormatsSimilar(item1.Format, item2.Format) </span><span class="cov0" title="0">{
                        score += 0.5
                }</span>
                <span class="cov0" title="0">components++</span>
        }

        // File size similarity
        <span class="cov0" title="0">if item1.FileSize &gt; 0 &amp;&amp; item2.FileSize &gt; 0 </span><span class="cov0" title="0">{
                sizeDiff := math.Abs(float64(item1.FileSize - item2.FileSize))
                maxSize := math.Max(float64(item1.FileSize), float64(item2.FileSize))
                if maxSize &gt; 0 </span><span class="cov0" title="0">{
                        sizeScore := math.Max(0, 1.0-sizeDiff/maxSize)
                        score += sizeScore
                        components++
                }</span>
        }

        <span class="cov0" title="0">if components &gt; 0 </span><span class="cov0" title="0">{
                return score / float64(components)
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// Calculate fingerprint similarity
func (s *DuplicateDetectionService) calculateFingerprintSimilarity(fp1, fp2 map[string]string) float64 <span class="cov0" title="0">{
        if len(fp1) == 0 || len(fp2) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">maxScore := 0.0

        // Compare each fingerprint type
        for fpType, hash1 := range fp1 </span><span class="cov0" title="0">{
                if hash2, exists := fp2[fpType]; exists </span><span class="cov0" title="0">{
                        similarity := s.calculateHashSimilarity(hash1, hash2, fpType)
                        if similarity &gt; maxScore </span><span class="cov0" title="0">{
                                maxScore = similarity
                        }</span>
                }
        }

        <span class="cov0" title="0">return maxScore</span>
}

// Calculate file similarity
func (s *DuplicateDetectionService) calculateFileSimilarity(item1, item2 *DuplicateItem) float64 <span class="cov0" title="0">{
        score := 0.0
        components := 0

        // File name similarity
        score += s.calculateTextSimilarity(item1.FileName, item2.FileName)
        components++

        // File size similarity
        if item1.FileSize &gt; 0 &amp;&amp; item2.FileSize &gt; 0 </span><span class="cov0" title="0">{
                sizeDiff := math.Abs(float64(item1.FileSize - item2.FileSize))
                maxSize := math.Max(float64(item1.FileSize), float64(item2.FileSize))
                if maxSize &gt; 0 </span><span class="cov0" title="0">{
                        sizeScore := 1.0 - sizeDiff/maxSize
                        if sizeScore &lt; 0 </span><span class="cov0" title="0">{
                                sizeScore = 0
                        }</span>
                        <span class="cov0" title="0">score += sizeScore
                        components++</span>
                }
        }

        // Format similarity
        <span class="cov0" title="0">if item1.Format != "" &amp;&amp; item2.Format != "" </span><span class="cov0" title="0">{
                if strings.EqualFold(item1.Format, item2.Format) </span><span class="cov0" title="0">{
                        score += 1.0
                }</span> else<span class="cov0" title="0"> if s.areFormatsSimilar(item1.Format, item2.Format) </span><span class="cov0" title="0">{
                        score += 0.7
                }</span>
                <span class="cov0" title="0">components++</span>
        }

        <span class="cov0" title="0">if components &gt; 0 </span><span class="cov0" title="0">{
                return score / float64(components)
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

// Helper methods for text analysis
func (s *DuplicateDetectionService) normalizeText(text string) string <span class="cov0" title="0">{
        // Convert to lowercase
        text = strings.ToLower(text)

        // Remove common articles and prepositions
        stopWords := []string{"the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for", "of", "with", "by"}
        words := strings.Fields(text)
        var filtered []string

        for _, word := range words </span><span class="cov0" title="0">{
                isStopWord := false
                for _, stopWord := range stopWords </span><span class="cov0" title="0">{
                        if word == stopWord </span><span class="cov0" title="0">{
                                isStopWord = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isStopWord </span><span class="cov0" title="0">{
                        filtered = append(filtered, word)
                }</span>
        }

        // Remove special characters and normalize spaces
        <span class="cov0" title="0">normalized := strings.Join(filtered, " ")
        normalized = regexp.MustCompile(`[^\p{L}\p{N}\s]`).ReplaceAllString(normalized, "")
        normalized = regexp.MustCompile(`\s+`).ReplaceAllString(normalized, " ")
        normalized = strings.TrimSpace(normalized)

        return normalized</span>
}

func (s *DuplicateDetectionService) calculateTextMetrics(text1, text2 string) *TextSimilarityMetrics <span class="cov0" title="0">{
        metrics := &amp;TextSimilarityMetrics{}

        // Levenshtein distance
        metrics.LevenshteinDistance = s.levenshteinDistance(text1, text2)

        // Jaro-Winkler similarity
        metrics.JaroWinklerScore = s.jaroWinklerSimilarity(text1, text2)

        // Cosine similarity
        metrics.CosineSimilarity = s.cosineSimilarity(text1, text2)

        // Jaccard index
        metrics.JaccardIndex = s.jaccardIndex(text1, text2)

        // LCS ratio
        metrics.LCSRatio = s.lcsRatio(text1, text2)

        // Soundex match
        metrics.SoundexMatch = s.soundexMatch(text1, text2)

        // Metaphone match
        metrics.MetaphoneMatch = s.metaphoneMatch(text1, text2)

        return metrics
}</span>

// Levenshtein distance algorithm
func (s *DuplicateDetectionService) levenshteinDistance(s1, s2 string) int <span class="cov0" title="0">{
        if len(s1) == 0 </span><span class="cov0" title="0">{
                return len(s2)
        }</span>
        <span class="cov0" title="0">if len(s2) == 0 </span><span class="cov0" title="0">{
                return len(s1)
        }</span>

        <span class="cov0" title="0">matrix := make([][]int, len(s1)+1)
        for i := range matrix </span><span class="cov0" title="0">{
                matrix[i] = make([]int, len(s2)+1)
                matrix[i][0] = i
        }</span>

        <span class="cov0" title="0">for j := 0; j &lt;= len(s2); j++ </span><span class="cov0" title="0">{
                matrix[0][j] = j
        }</span>

        <span class="cov0" title="0">for i := 1; i &lt;= len(s1); i++ </span><span class="cov0" title="0">{
                for j := 1; j &lt;= len(s2); j++ </span><span class="cov0" title="0">{
                        cost := 0
                        if s1[i-1] != s2[j-1] </span><span class="cov0" title="0">{
                                cost = 1
                        }</span>

                        <span class="cov0" title="0">matrix[i][j] = min3(
                                matrix[i-1][j]+1,      // deletion
                                matrix[i][j-1]+1,      // insertion
                                matrix[i-1][j-1]+cost, // substitution
                        )</span>
                }
        }

        <span class="cov0" title="0">return matrix[len(s1)][len(s2)]</span>
}

// Jaro-Winkler similarity
func (s *DuplicateDetectionService) jaroWinklerSimilarity(s1, s2 string) float64 <span class="cov0" title="0">{
        if s1 == s2 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov0" title="0">len1, len2 := len(s1), len(s2)
        if len1 == 0 || len2 == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">matchWindow := max(len1, len2)/2 - 1
        if matchWindow &lt; 0 </span><span class="cov0" title="0">{
                matchWindow = 0
        }</span>

        <span class="cov0" title="0">s1Matches := make([]bool, len1)
        s2Matches := make([]bool, len2)

        matches := 0
        transpositions := 0

        // Find matches
        for i := 0; i &lt; len1; i++ </span><span class="cov0" title="0">{
                start := max(0, i-matchWindow)
                end := min(i+matchWindow+1, len2)

                for j := start; j &lt; end; j++ </span><span class="cov0" title="0">{
                        if s2Matches[j] || s1[i] != s2[j] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">s1Matches[i] = true
                        s2Matches[j] = true
                        matches++
                        break</span>
                }
        }

        <span class="cov0" title="0">if matches == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Find transpositions
        <span class="cov0" title="0">k := 0
        for i := 0; i &lt; len1; i++ </span><span class="cov0" title="0">{
                if !s1Matches[i] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for !s2Matches[k] </span><span class="cov0" title="0">{
                        k++
                }</span>
                <span class="cov0" title="0">if s1[i] != s2[k] </span><span class="cov0" title="0">{
                        transpositions++
                }</span>
                <span class="cov0" title="0">k++</span>
        }

        <span class="cov0" title="0">jaro := (float64(matches)/float64(len1) + float64(matches)/float64(len2) + float64(matches-transpositions/2)/float64(matches)) / 3.0

        // Jaro-Winkler adjustment
        prefix := 0
        for i := 0; i &lt; min(len1, len2) &amp;&amp; i &lt; 4; i++ </span><span class="cov0" title="0">{
                if s1[i] == s2[i] </span><span class="cov0" title="0">{
                        prefix++
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">return jaro + 0.1*float64(prefix)*(1.0-jaro)</span>
}

// Cosine similarity
func (s *DuplicateDetectionService) cosineSimilarity(text1, text2 string) float64 <span class="cov0" title="0">{
        words1 := strings.Fields(text1)
        words2 := strings.Fields(text2)

        if len(words1) == 0 || len(words2) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Create word frequency maps
        <span class="cov0" title="0">freq1 := make(map[string]int)
        freq2 := make(map[string]int)

        for _, word := range words1 </span><span class="cov0" title="0">{
                freq1[word]++
        }</span>
        <span class="cov0" title="0">for _, word := range words2 </span><span class="cov0" title="0">{
                freq2[word]++
        }</span>

        // Calculate dot product and magnitudes
        <span class="cov0" title="0">dotProduct := 0.0
        magnitude1 := 0.0
        magnitude2 := 0.0

        allWords := make(map[string]bool)
        for word := range freq1 </span><span class="cov0" title="0">{
                allWords[word] = true
        }</span>
        <span class="cov0" title="0">for word := range freq2 </span><span class="cov0" title="0">{
                allWords[word] = true
        }</span>

        <span class="cov0" title="0">for word := range allWords </span><span class="cov0" title="0">{
                f1 := float64(freq1[word])
                f2 := float64(freq2[word])

                dotProduct += f1 * f2
                magnitude1 += f1 * f1
                magnitude2 += f2 * f2
        }</span>

        <span class="cov0" title="0">if magnitude1 == 0 || magnitude2 == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return dotProduct / (math.Sqrt(magnitude1) * math.Sqrt(magnitude2))</span>
}

// Jaccard index
func (s *DuplicateDetectionService) jaccardIndex(text1, text2 string) float64 <span class="cov0" title="0">{
        words1 := make(map[string]bool)
        words2 := make(map[string]bool)

        for _, word := range strings.Fields(text1) </span><span class="cov0" title="0">{
                words1[word] = true
        }</span>
        <span class="cov0" title="0">for _, word := range strings.Fields(text2) </span><span class="cov0" title="0">{
                words2[word] = true
        }</span>

        <span class="cov0" title="0">intersection := 0
        union := 0

        allWords := make(map[string]bool)
        for word := range words1 </span><span class="cov0" title="0">{
                allWords[word] = true
        }</span>
        <span class="cov0" title="0">for word := range words2 </span><span class="cov0" title="0">{
                allWords[word] = true
        }</span>

        <span class="cov0" title="0">for word := range allWords </span><span class="cov0" title="0">{
                inFirst := words1[word]
                inSecond := words2[word]

                if inFirst &amp;&amp; inSecond </span><span class="cov0" title="0">{
                        intersection++
                }</span>
                <span class="cov0" title="0">union++</span>
        }

        <span class="cov0" title="0">if union == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return float64(intersection) / float64(union)</span>
}

// Longest Common Subsequence ratio
func (s *DuplicateDetectionService) lcsRatio(s1, s2 string) float64 <span class="cov0" title="0">{
        lcsLength := s.lcsLength(s1, s2)
        maxLength := max(len(s1), len(s2))

        if maxLength == 0 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov0" title="0">return float64(lcsLength) / float64(maxLength)</span>
}

func (s *DuplicateDetectionService) lcsLength(s1, s2 string) int <span class="cov0" title="0">{
        m, n := len(s1), len(s2)
        dp := make([][]int, m+1)
        for i := range dp </span><span class="cov0" title="0">{
                dp[i] = make([]int, n+1)
        }</span>

        <span class="cov0" title="0">for i := 1; i &lt;= m; i++ </span><span class="cov0" title="0">{
                for j := 1; j &lt;= n; j++ </span><span class="cov0" title="0">{
                        if s1[i-1] == s2[j-1] </span><span class="cov0" title="0">{
                                dp[i][j] = dp[i-1][j-1] + 1
                        }</span> else<span class="cov0" title="0"> {
                                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                        }</span>
                }
        }

        <span class="cov0" title="0">return dp[m][n]</span>
}

// Soundex matching (simplified)
func (s *DuplicateDetectionService) soundexMatch(s1, s2 string) bool <span class="cov0" title="0">{
        return s.soundex(s1) == s.soundex(s2)
}</span>

func (s *DuplicateDetectionService) soundex(str string) string <span class="cov0" title="0">{
        if len(str) == 0 </span><span class="cov0" title="0">{
                return "0000"
        }</span>

        <span class="cov0" title="0">str = strings.ToUpper(str)
        result := string(str[0])

        // Mapping table
        mapping := map[rune]string{
                'B': "1", 'F': "1", 'P': "1", 'V': "1",
                'C': "2", 'G': "2", 'J': "2", 'K': "2", 'Q': "2", 'S': "2", 'X': "2", 'Z': "2",
                'D': "3", 'T': "3",
                'L': "4",
                'M': "5", 'N': "5",
                'R': "6",
        }

        prev := ""
        for _, char := range str[1:] </span><span class="cov0" title="0">{
                if code, exists := mapping[char]; exists </span><span class="cov0" title="0">{
                        if code != prev </span><span class="cov0" title="0">{
                                result += code
                                prev = code
                        }</span>
                } else<span class="cov0" title="0"> {
                        prev = ""
                }</span>

                <span class="cov0" title="0">if len(result) &gt;= 4 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // Pad with zeros
        <span class="cov0" title="0">for len(result) &lt; 4 </span><span class="cov0" title="0">{
                result += "0"
        }</span>

        <span class="cov0" title="0">return result[:4]</span>
}

// Metaphone matching (simplified)
func (s *DuplicateDetectionService) metaphoneMatch(s1, s2 string) bool <span class="cov0" title="0">{
        return s.metaphone(s1) == s.metaphone(s2)
}</span>

func (s *DuplicateDetectionService) metaphone(str string) string <span class="cov0" title="0">{
        if len(str) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">str = strings.ToUpper(str)
        result := ""

        // Simplified metaphone algorithm
        for i, char := range str </span><span class="cov0" title="0">{
                switch char </span>{
                case 'A', 'E', 'I', 'O', 'U':<span class="cov0" title="0">
                        if i == 0 </span><span class="cov0" title="0">{
                                result += string(char)
                        }</span>
                case 'B':<span class="cov0" title="0">
                        if i == len(str)-1 &amp;&amp; str[i-1] == 'M' </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">result += "B"</span>
                case 'C':<span class="cov0" title="0">
                        if i &lt; len(str)-1 &amp;&amp; str[i+1] == 'H' </span><span class="cov0" title="0">{
                                result += "X"
                        }</span> else<span class="cov0" title="0"> {
                                result += "K"
                        }</span>
                case 'D':<span class="cov0" title="0">
                        result += "T"</span>
                case 'F', 'J', 'L', 'M', 'N', 'R':<span class="cov0" title="0">
                        result += string(char)</span>
                case 'G':<span class="cov0" title="0">
                        result += "K"</span>
                case 'H':<span class="cov0" title="0">
                        if i == 0 || isVowel(rune(str[i-1])) </span><span class="cov0" title="0">{
                                result += "H"
                        }</span>
                case 'K':<span class="cov0" title="0">
                        if i == 0 || str[i-1] != 'C' </span><span class="cov0" title="0">{
                                result += "K"
                        }</span>
                case 'P':<span class="cov0" title="0">
                        if i &lt; len(str)-1 &amp;&amp; str[i+1] == 'H' </span><span class="cov0" title="0">{
                                result += "F"
                        }</span> else<span class="cov0" title="0"> {
                                result += "P"
                        }</span>
                case 'Q':<span class="cov0" title="0">
                        result += "K"</span>
                case 'S':<span class="cov0" title="0">
                        result += "S"</span>
                case 'T':<span class="cov0" title="0">
                        if i &lt; len(str)-1 &amp;&amp; str[i+1] == 'H' </span><span class="cov0" title="0">{
                                result += "0"
                        }</span> else<span class="cov0" title="0"> {
                                result += "T"
                        }</span>
                case 'V':<span class="cov0" title="0">
                        result += "F"</span>
                case 'W', 'Y':<span class="cov0" title="0">
                        if i == 0 || isVowel(rune(str[i-1])) </span><span class="cov0" title="0">{
                                result += string(char)
                        }</span>
                case 'X':<span class="cov0" title="0">
                        result += "KS"</span>
                case 'Z':<span class="cov0" title="0">
                        result += "S"</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

func isVowel(r rune) bool <span class="cov0" title="0">{
        return r == 'A' || r == 'E' || r == 'I' || r == 'O' || r == 'U'
}</span>

// Utility functions
func min3(a, b, c int) int <span class="cov0" title="0">{
        if a &lt;= b &amp;&amp; a &lt;= c </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">if b &lt;= c </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov0" title="0">return c</span>
}

func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// Additional helper methods would continue here...
// (Implementation continues with remaining methods for duplicate group management,
// deduplication actions, storage methods, etc.)

// Placeholder implementations for some methods
func (s *DuplicateDetectionService) getSimilarityWeights(mediaType MediaType) map[string]float64 <span class="cov0" title="0">{
        switch mediaType </span>{
        case MediaTypeMusic:<span class="cov0" title="0">
                return map[string]float64{
                        "title":       0.4,
                        "metadata":    0.4,
                        "fingerprint": 0.15,
                        "file":        0.05,
                }</span>
        case MediaTypeMovie:<span class="cov0" title="0">
                return map[string]float64{
                        "title":       0.5,
                        "metadata":    0.3,
                        "fingerprint": 0.1,
                        "file":        0.1,
                }</span>
        default:<span class="cov0" title="0">
                return map[string]float64{
                        "title":       0.4,
                        "metadata":    0.3,
                        "fingerprint": 0.2,
                        "file":        0.1,
                }</span>
        }
}

func (s *DuplicateDetectionService) getMediaItems(ctx context.Context, mediaType MediaType, req *DuplicateDetectionRequest) ([]DuplicateItem, error) <span class="cov0" title="0">{
        // Implementation would query database for media items
        return []DuplicateItem{}, nil
}</span>

func (s *DuplicateDetectionService) createOrAddToDuplicateGroup(groups []DuplicateGroup, item1, item2 DuplicateItem, similarity *SimilarityAnalysis, mediaType MediaType) *DuplicateGroup <span class="cov0" title="0">{
        // Implementation would create new group or add to existing
        return nil
}</span>

func (s *DuplicateDetectionService) mergeDuplicateGroup(groups []DuplicateGroup, newGroup DuplicateGroup) []DuplicateGroup <span class="cov0" title="0">{
        // Implementation would merge groups if needed
        return groups
}</span>

func (s *DuplicateDetectionService) determinePrimaryItem(group *DuplicateGroup) {<span class="cov0" title="0">
        // Implementation would determine the best quality/primary item
}</span>

func (s *DuplicateDetectionService) storeDuplicateGroup(ctx context.Context, group *DuplicateGroup) error <span class="cov0" title="0">{
        // Implementation would store duplicate group in database
        return nil
}</span>

func (s *DuplicateDetectionService) analyzeFieldMatches(item1, item2 *DuplicateItem, analysis *SimilarityAnalysis) {<span class="cov0" title="0">
        // Implementation would analyze which fields match and which differ
}</span>

func (s *DuplicateDetectionService) calculateHashSimilarity(hash1, hash2, fpType string) float64 <span class="cov0" title="0">{
        // Implementation would calculate hash similarity based on type
        return 0.0
}</span>

func (s *DuplicateDetectionService) areQualitiesSimilar(q1, q2 string) bool <span class="cov0" title="0">{
        // Implementation would check if qualities are similar
        return false
}</span>

func (s *DuplicateDetectionService) extractISBN(externalIDs map[string]string) string <span class="cov0" title="0">{
        // Implementation would extract ISBN from external IDs
        return ""
}</span>

func (s *DuplicateDetectionService) areISBNsRelated(isbn1, isbn2 string) bool <span class="cov0" title="0">{
        // Implementation would check if ISBNs are related (ISBN-10 vs ISBN-13)
        return false
}</span>

func (s *DuplicateDetectionService) extractVersion(metadata map[string]interface{}) string <span class="cov0" title="0">{
        // Implementation would extract version from metadata
        return ""
}</span>

func (s *DuplicateDetectionService) extractPlatform(metadata map[string]interface{}) string <span class="cov0" title="0">{
        // Implementation would extract platform from metadata
        return ""
}</span>

func (s *DuplicateDetectionService) calculateVersionSimilarity(v1, v2 string) float64 <span class="cov0" title="0">{
        // Implementation would calculate version similarity
        return 0.0
}</span>

func (s *DuplicateDetectionService) arePlatformsSimilar(p1, p2 string) bool <span class="cov0" title="0">{
        // Implementation would check if platforms are similar
        return false
}</span>

func (s *DuplicateDetectionService) areFormatsSimilar(f1, f2 string) bool <span class="cov0" title="0">{
        // Implementation would check if formats are similar
        return false
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "regexp"
        "strconv"
        "strings"
        "time"

        "catalogizer/internal/models"

        "go.uber.org/zap"
)

// Game and software recognition provider
type GameSoftwareRecognitionProvider struct {
        logger      *zap.Logger
        httpClient  *http.Client
        baseURLs    map[string]string
        apiKeys     map[string]string
        rateLimiter map[string]*time.Ticker
}

// IGDB (Internet Game Database) API structures
type IGDBGame struct {
        ID                    int                     `json:"id"`
        Name                  string                  `json:"name"`
        Summary               string                  `json:"summary"`
        Storyline             string                  `json:"storyline"`
        FirstReleaseDate      int64                   `json:"first_release_date"`
        Category              int                     `json:"category"`
        Status                int                     `json:"status"`
        Rating                float64                 `json:"rating"`
        RatingCount           int                     `json:"rating_count"`
        AggregatedRating      float64                 `json:"aggregated_rating"`
        AggregatedRatingCount int                     `json:"aggregated_rating_count"`
        TotalRating           float64                 `json:"total_rating"`
        TotalRatingCount      int                     `json:"total_rating_count"`
        Popularity            float64                 `json:"popularity"`
        Cover                 IGDBCover               `json:"cover"`
        Screenshots           []IGDBScreenshot        `json:"screenshots"`
        Artworks              []IGDBArtwork           `json:"artworks"`
        Videos                []IGDBVideo             `json:"videos"`
        Genres                []IGDBGenre             `json:"genres"`
        Themes                []IGDBTheme             `json:"themes"`
        Platforms             []IGDBPlatform          `json:"platforms"`
        GameModes             []IGDBGameMode          `json:"game_modes"`
        PlayerPerspectives    []IGDBPlayerPerspective `json:"player_perspectives"`
        InvolvedCompanies     []IGDBInvolvedCompany   `json:"involved_companies"`
        Franchises            []IGDBFranchise         `json:"franchises"`
        Collection            IGDBCollection          `json:"collection"`
        DLC                   []IGDBGame              `json:"dlcs"`
        Expansions            []IGDBGame              `json:"expansions"`
        StandaloneExpansions  []IGDBGame              `json:"standalone_expansions"`
        Remakes               []IGDBGame              `json:"remakes"`
        Remasters             []IGDBGame              `json:"remasters"`
        ExternalGames         []IGDBExternalGame      `json:"external_games"`
        Websites              []IGDBWebsite           `json:"websites"`
        LanguageSupports      []IGDBLanguageSupport   `json:"language_supports"`
        MultiplayerModes      []IGDBMultiplayerMode   `json:"multiplayer_modes"`
        AlternativeNames      []IGDBAlternativeName   `json:"alternative_names"`
        Keywords              []IGDBKeyword           `json:"keywords"`
        Tags                  []int                   `json:"tags"`
}

type IGDBCover struct {
        ID      int    `json:"id"`
        URL     string `json:"url"`
        ImageID string `json:"image_id"`
        Width   int    `json:"width"`
        Height  int    `json:"height"`
}

type IGDBScreenshot struct {
        ID      int    `json:"id"`
        URL     string `json:"url"`
        ImageID string `json:"image_id"`
        Width   int    `json:"width"`
        Height  int    `json:"height"`
}

type IGDBArtwork struct {
        ID      int    `json:"id"`
        URL     string `json:"url"`
        ImageID string `json:"image_id"`
        Width   int    `json:"width"`
        Height  int    `json:"height"`
}

type IGDBVideo struct {
        ID       int    `json:"id"`
        Name     string `json:"name"`
        VideoID  string `json:"video_id"`
        Checksum string `json:"checksum"`
}

type IGDBGenre struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

type IGDBTheme struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

type IGDBPlatform struct {
        ID           int              `json:"id"`
        Name         string           `json:"name"`
        Abbreviation string           `json:"abbreviation"`
        Category     int              `json:"category"`
        Generation   int              `json:"generation"`
        PlatformLogo IGDBPlatformLogo `json:"platform_logo"`
        Websites     []IGDBWebsite    `json:"websites"`
}

type IGDBPlatformLogo struct {
        ID      int    `json:"id"`
        URL     string `json:"url"`
        ImageID string `json:"image_id"`
}

type IGDBGameMode struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

type IGDBPlayerPerspective struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

type IGDBInvolvedCompany struct {
        ID         int         `json:"id"`
        Company    IGDBCompany `json:"company"`
        Developer  bool        `json:"developer"`
        Publisher  bool        `json:"publisher"`
        Porting    bool        `json:"porting"`
        Supporting bool        `json:"supporting"`
}

type IGDBCompany struct {
        ID          int             `json:"id"`
        Name        string          `json:"name"`
        Slug        string          `json:"slug"`
        Country     int             `json:"country"`
        Description string          `json:"description"`
        StartDate   int64           `json:"start_date"`
        Logo        IGDBCompanyLogo `json:"logo"`
        Websites    []IGDBWebsite   `json:"websites"`
}

type IGDBCompanyLogo struct {
        ID      int    `json:"id"`
        URL     string `json:"url"`
        ImageID string `json:"image_id"`
}

type IGDBFranchise struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

type IGDBCollection struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

type IGDBExternalGame struct {
        ID        int    `json:"id"`
        Category  int    `json:"category"`
        UID       string `json:"uid"`
        URL       string `json:"url"`
        Year      int    `json:"year"`
        Media     int    `json:"media"`
        Platform  int    `json:"platform"`
        Countries []int  `json:"countries"`
}

type IGDBWebsite struct {
        ID       int    `json:"id"`
        Category int    `json:"category"`
        Trusted  bool   `json:"trusted"`
        URL      string `json:"url"`
}

type IGDBLanguageSupport struct {
        ID                  int                     `json:"id"`
        Language            IGDBLanguage            `json:"language"`
        LanguageSupportType IGDBLanguageSupportType `json:"language_support_type"`
}

type IGDBLanguage struct {
        ID         int    `json:"id"`
        Name       string `json:"name"`
        NativeName string `json:"native_name"`
        Locale     string `json:"locale"`
}

type IGDBLanguageSupportType struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
}

type IGDBMultiplayerMode struct {
        ID                int  `json:"id"`
        CampaignCoop      bool `json:"campaigncoop"`
        LancCoop          bool `json:"lancoop"`
        OfflineCoop       bool `json:"offlinecoop"`
        OfflineCoopMax    int  `json:"offlinecoopmax"`
        OfflineMax        int  `json:"offlinemax"`
        OnlineCoop        bool `json:"onlinecoop"`
        OnlineCoopMax     int  `json:"onlinecoopmax"`
        OnlineMax         int  `json:"onlinemax"`
        Platform          int  `json:"platform"`
        SplitScreen       bool `json:"splitscreen"`
        SplitScreenOnline bool `json:"splitscreenonline"`
}

type IGDBAlternativeName struct {
        ID      int    `json:"id"`
        Name    string `json:"name"`
        Comment string `json:"comment"`
}

type IGDBKeyword struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Slug string `json:"slug"`
}

// Steam API structures
type SteamAppDetails struct {
        Success bool         `json:"success"`
        Data    SteamAppData `json:"data"`
}

type SteamAppData struct {
        Type                string                  `json:"type"`
        Name                string                  `json:"name"`
        SteamAppID          int                     `json:"steam_appid"`
        RequiredAge         int                     `json:"required_age"`
        IsFree              bool                    `json:"is_free"`
        ControllerSupport   string                  `json:"controller_support"`
        DLCs                []int                   `json:"dlc"`
        DetailedDescription string                  `json:"detailed_description"`
        AboutTheGame        string                  `json:"about_the_game"`
        ShortDescription    string                  `json:"short_description"`
        SupportedLanguages  string                  `json:"supported_languages"`
        Reviews             string                  `json:"reviews"`
        HeaderImage         string                  `json:"header_image"`
        Website             string                  `json:"website"`
        PCRequirements      SteamRequirements       `json:"pc_requirements"`
        MacRequirements     SteamRequirements       `json:"mac_requirements"`
        LinuxRequirements   SteamRequirements       `json:"linux_requirements"`
        LegalNotice         string                  `json:"legal_notice"`
        Developers          []string                `json:"developers"`
        Publishers          []string                `json:"publishers"`
        PriceOverview       SteamPriceOverview      `json:"price_overview"`
        Packages            []int                   `json:"packages"`
        PackageGroups       []SteamPackageGroup     `json:"package_groups"`
        Platforms           SteamPlatforms          `json:"platforms"`
        Metacritic          SteamMetacritic         `json:"metacritic"`
        Categories          []SteamCategory         `json:"categories"`
        Genres              []SteamGenre            `json:"genres"`
        Screenshots         []SteamScreenshot       `json:"screenshots"`
        Movies              []SteamMovie            `json:"movies"`
        Recommendations     SteamRecommendations    `json:"recommendations"`
        Achievements        SteamAchievements       `json:"achievements"`
        ReleaseDate         SteamReleaseDate        `json:"release_date"`
        SupportInfo         SteamSupportInfo        `json:"support_info"`
        Background          string                  `json:"background"`
        ContentDescriptors  SteamContentDescriptors `json:"content_descriptors"`
}

type SteamRequirements struct {
        Minimum     string `json:"minimum"`
        Recommended string `json:"recommended"`
}

type SteamPriceOverview struct {
        Currency         string `json:"currency"`
        Initial          int    `json:"initial"`
        Final            int    `json:"final"`
        DiscountPercent  int    `json:"discount_percent"`
        InitialFormatted string `json:"initial_formatted"`
        FinalFormatted   string `json:"final_formatted"`
}

type SteamPackageGroup struct {
        Name                    string     `json:"name"`
        Title                   string     `json:"title"`
        Description             string     `json:"description"`
        SelectionText           string     `json:"selection_text"`
        SaveText                string     `json:"save_text"`
        DisplayType             int        `json:"display_type"`
        IsRecurringSubscription string     `json:"is_recurring_subscription"`
        Subs                    []SteamSub `json:"subs"`
}

type SteamSub struct {
        PackageID                int    `json:"packageid"`
        PercentSavingsText       string `json:"percent_savings_text"`
        PercentSavings           int    `json:"percent_savings"`
        OptionText               string `json:"option_text"`
        OptionDescription        string `json:"option_description"`
        CanGetFreeLicense        string `json:"can_get_free_license"`
        IsFreeLicense            bool   `json:"is_free_license"`
        PriceInCentsWithDiscount int    `json:"price_in_cents_with_discount"`
}

type SteamPlatforms struct {
        Windows bool `json:"windows"`
        Mac     bool `json:"mac"`
        Linux   bool `json:"linux"`
}

type SteamMetacritic struct {
        Score int    `json:"score"`
        URL   string `json:"url"`
}

type SteamCategory struct {
        ID          int    `json:"id"`
        Description string `json:"description"`
}

type SteamGenre struct {
        ID          string `json:"id"`
        Description string `json:"description"`
}

type SteamScreenshot struct {
        ID            int    `json:"id"`
        PathThumbnail string `json:"path_thumbnail"`
        PathFull      string `json:"path_full"`
}

type SteamMovie struct {
        ID        int               `json:"id"`
        Name      string            `json:"name"`
        Thumbnail string            `json:"thumbnail"`
        Webm      map[string]string `json:"webm"`
        Mp4       map[string]string `json:"mp4"`
        Highlight bool              `json:"highlight"`
}

type SteamRecommendations struct {
        Total int `json:"total"`
}

type SteamAchievements struct {
        Total       int                `json:"total"`
        Highlighted []SteamAchievement `json:"highlighted"`
}

type SteamAchievement struct {
        Name string `json:"name"`
        Path string `json:"path"`
}

type SteamReleaseDate struct {
        ComingSoon bool   `json:"coming_soon"`
        Date       string `json:"date"`
}

type SteamSupportInfo struct {
        URL   string `json:"url"`
        Email string `json:"email"`
}

type SteamContentDescriptors struct {
        IDs   []int  `json:"ids"`
        Notes string `json:"notes"`
}

// Software identification structures
type SoftwareInfo struct {
        Name            string            `json:"name"`
        Version         string            `json:"version"`
        Architecture    string            `json:"architecture"`
        Platform        string            `json:"platform"`
        FileSize        int64             `json:"file_size"`
        FileHash        string            `json:"file_hash"`
        Publisher       string            `json:"publisher"`
        InstallLocation string            `json:"install_location"`
        Registry        map[string]string `json:"registry"`
        Dependencies    []string          `json:"dependencies"`
        PEInfo          *PEInfo           `json:"pe_info,omitempty"`
        ELFInfo         *ELFInfo          `json:"elf_info,omitempty"`
        MachoInfo       *MachoInfo        `json:"macho_info,omitempty"`
}

type PEInfo struct {
        Machine           string            `json:"machine"`
        Timestamp         int64             `json:"timestamp"`
        VersionInfo       map[string]string `json:"version_info"`
        ImportedLibraries []string          `json:"imported_libraries"`
        ExportedFunctions []string          `json:"exported_functions"`
        Sections          []PESection       `json:"sections"`
        Subsystem         string            `json:"subsystem"`
        EntryPoint        string            `json:"entry_point"`
}

type PESection struct {
        Name            string `json:"name"`
        VirtualAddress  string `json:"virtual_address"`
        VirtualSize     int    `json:"virtual_size"`
        RawSize         int    `json:"raw_size"`
        Characteristics string `json:"characteristics"`
}

type ELFInfo struct {
        Class            string       `json:"class"`
        Data             string       `json:"data"`
        Version          string       `json:"version"`
        OSABI            string       `json:"osabi"`
        Machine          string       `json:"machine"`
        Type             string       `json:"type"`
        EntryPoint       string       `json:"entry_point"`
        DynamicLibraries []string     `json:"dynamic_libraries"`
        Symbols          []string     `json:"symbols"`
        Sections         []ELFSection `json:"sections"`
}

type ELFSection struct {
        Name    string `json:"name"`
        Type    string `json:"type"`
        Address string `json:"address"`
        Size    int    `json:"size"`
        Flags   string `json:"flags"`
}

type MachoInfo struct {
        Architecture     string             `json:"architecture"`
        FileType         string             `json:"file_type"`
        LoadCommands     []MachoLoadCommand `json:"load_commands"`
        DynamicLibraries []string           `json:"dynamic_libraries"`
        Symbols          []string           `json:"symbols"`
}

type MachoLoadCommand struct {
        Command string `json:"command"`
        Size    int    `json:"size"`
        Data    string `json:"data"`
}

func NewGameSoftwareRecognitionProvider(logger *zap.Logger) *GameSoftwareRecognitionProvider <span class="cov0" title="0">{
        return &amp;GameSoftwareRecognitionProvider{
                logger:     logger,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                baseURLs: map[string]string{
                        "igdb":        "https://api.igdb.com/v4",
                        "steam":       "https://store.steampowered.com/api",
                        "github":      "https://api.github.com",
                        "sourceforge": "https://sourceforge.net/rest",
                        "winget":      "https://api.winget.run",
                        "flatpak":     "https://flathub.org/api",
                        "snapcraft":   "https://api.snapcraft.io",
                        "homebrew":    "https://formulae.brew.sh/api",
                },
                apiKeys: map[string]string{
                        "igdb":   "free_api_key",
                        "github": "free_api_key",
                },
                rateLimiter: make(map[string]*time.Ticker),
        }
}</span>

func (p *GameSoftwareRecognitionProvider) RecognizeMedia(ctx context.Context, req *MediaRecognitionRequest) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        p.logger.Info("Starting game/software recognition",
                zap.String("file_path", req.FilePath),
                zap.String("media_type", string(req.MediaType)))

        // Extract metadata from filename and file structure
        name, version, platform := p.extractSoftwareMetadataFromFilename(req.FileName)

        p.logger.Debug("Extracted metadata from filename",
                zap.String("name", name),
                zap.String("version", version),
                zap.String("platform", platform))

        // Determine if it's a game or software
        isGame := p.looksLikeGame(name, req.FileName)

        if isGame </span><span class="cov0" title="0">{
                // Try game recognition
                if result, err := p.recognizeGame(ctx, name, platform); err == nil </span><span class="cov0" title="0">{
                        p.logger.Info("Successfully recognized as game",
                                zap.String("name", result.Title),
                                zap.Float64("confidence", result.Confidence))
                        return result, nil
                }</span>
        }

        // Try software recognition
        <span class="cov0" title="0">if result, err := p.recognizeSoftware(ctx, name, version, platform, req); err == nil </span><span class="cov0" title="0">{
                p.logger.Info("Successfully recognized as software",
                        zap.String("name", result.Title),
                        zap.Float64("confidence", result.Confidence))
                return result, nil
        }</span>

        // Fallback to basic recognition
        <span class="cov0" title="0">return p.basicGameSoftwareRecognition(req, name, version, platform, isGame), nil</span>
}

func (p *GameSoftwareRecognitionProvider) recognizeGame(ctx context.Context, name, platform string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Try IGDB first
        if result, err := p.searchIGDB(ctx, name, platform); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try Steam as fallback
        <span class="cov0" title="0">if result, err := p.searchSteam(ctx, name); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no game recognition results found")</span>
}

func (p *GameSoftwareRecognitionProvider) searchIGDB(ctx context.Context, name, platform string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Build IGDB query
        query := fmt.Sprintf(`search "%s"; fields *; limit 10;`, name)

        req, err := http.NewRequestWithContext(ctx, "POST", p.baseURLs["igdb"]+"/games", strings.NewReader(query))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Client-ID", p.apiKeys["igdb"])
        req.Header.Set("Authorization", "Bearer "+p.apiKeys["igdb"])
        req.Header.Set("Content-Type", "text/plain")

        resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var games []IGDBGame
        if err := json.NewDecoder(resp.Body).Decode(&amp;games); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(games) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no games found in IGDB")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := games[0]

        return p.convertIGDBGame(bestMatch), nil</span>
}

func (p *GameSoftwareRecognitionProvider) convertIGDBGame(game IGDBGame) *MediaRecognitionResult <span class="cov0" title="0">{
        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("igdb_%d", game.ID),
                MediaType:         MediaTypeGame,
                Title:             game.Name,
                Description:       game.Summary,
                Rating:            game.Rating / 10.0, // IGDB uses 0-100 scale
                Confidence:        p.calculateIGDBConfidence(game.Rating, game.RatingCount, game.Popularity),
                RecognitionMethod: "igdb_api",
                APIProvider:       "IGDB",
                IGDBId:            strconv.Itoa(game.ID),
        }

        // Parse release date
        if game.FirstReleaseDate &gt; 0 </span><span class="cov0" title="0">{
                releaseDate := time.Unix(game.FirstReleaseDate, 0)
                result.ReleaseDate = &amp;releaseDate
                result.Year = releaseDate.Year()
        }</span>

        // Extract genres
        <span class="cov0" title="0">for _, genre := range game.Genres </span><span class="cov0" title="0">{
                result.Genres = append(result.Genres, genre.Name)
        }</span>

        // Extract platforms
        <span class="cov0" title="0">for _, platform := range game.Platforms </span><span class="cov0" title="0">{
                result.Platforms = append(result.Platforms, platform.Name)
        }</span>

        // Extract developer and publisher
        <span class="cov0" title="0">for _, company := range game.InvolvedCompanies </span><span class="cov0" title="0">{
                if company.Developer </span><span class="cov0" title="0">{
                        result.Developer = company.Company.Name
                }</span>
                <span class="cov0" title="0">if company.Publisher </span><span class="cov0" title="0">{
                        result.Publisher_Game = company.Company.Name
                }</span>
        }

        // Get cover art
        <span class="cov0" title="0">if game.Cover.URL != "" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        ID:      game.Cover.ImageID,
                        URL:     p.getIGDBImageURL(game.Cover.ImageID, "cover_big"),
                        Quality: "large",
                        Source:  "IGDB",
                })
        }</span>

        // Get screenshots
        <span class="cov0" title="0">for _, screenshot := range game.Screenshots </span><span class="cov0" title="0">{
                result.Screenshots = append(result.Screenshots, p.getIGDBImageURL(screenshot.ImageID, "screenshot_med"))
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "igdb_id": strconv.Itoa(game.ID),
        }

        // Parse external games for Steam ID
        for _, external := range game.ExternalGames </span><span class="cov0" title="0">{
                if external.Category == 1 </span><span class="cov0" title="0">{ // Steam
                        result.ExternalIDs["steam_id"] = external.UID
                        result.SteamID = external.UID
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func (p *GameSoftwareRecognitionProvider) searchSteam(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Steam doesn't have a direct search API, so we need to use app details
        // This is a simplified implementation - in practice, you'd maintain a database of Steam app IDs

        // For demonstration, we'll generate a mock Steam result
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("steam_%s", p.generateID(name)),
                MediaType:         MediaTypeGame,
                Title:             name,
                Confidence:        0.6,
                RecognitionMethod: "steam_lookup",
                APIProvider:       "Steam",
                ExternalIDs:       make(map[string]string),
        }, nil
}</span>

func (p *GameSoftwareRecognitionProvider) recognizeSoftware(ctx context.Context, name, version, platform string, req *MediaRecognitionRequest) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Try different software repositories based on platform
        switch strings.ToLower(platform) </span>{
        case "windows":<span class="cov0" title="0">
                if result, err := p.searchWinget(ctx, name); err == nil </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
        case "linux":<span class="cov0" title="0">
                if result, err := p.searchFlatpak(ctx, name); err == nil </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
                <span class="cov0" title="0">if result, err := p.searchSnapcraft(ctx, name); err == nil </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
        case "macos", "darwin":<span class="cov0" title="0">
                if result, err := p.searchHomebrew(ctx, name); err == nil </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
        }

        // Try GitHub for open source software
        <span class="cov0" title="0">if result, err := p.searchGitHub(ctx, name); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try SourceForge
        <span class="cov0" title="0">if result, err := p.searchSourceForge(ctx, name); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no software recognition results found")</span>
}

func (p *GameSoftwareRecognitionProvider) searchWinget(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Winget API search
        params := url.Values{}
        params.Set("query", name)

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/packages?%s", p.baseURLs["winget"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var packages []WingetPackage
        if err := json.NewDecoder(resp.Body).Decode(&amp;packages); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(packages) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no packages found in winget")
        }</span>

        <span class="cov0" title="0">pkg := packages[0]
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("winget_%s", pkg.PackageIdentifier),
                MediaType:         MediaTypeSoftware,
                Title:             pkg.PackageName,
                Publisher:         pkg.Publisher,
                Version:           pkg.PackageVersion,
                Platform:          "Windows",
                Confidence:        0.8,
                RecognitionMethod: "winget_api",
                APIProvider:       "Winget",
                ExternalIDs: map[string]string{
                        "winget_id": pkg.PackageIdentifier,
                },
        }, nil</span>
}

func (p *GameSoftwareRecognitionProvider) searchFlatpak(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Flatpak/Flathub API search
        params := url.Values{}
        params.Set("q", name)

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/v1/apps/search?%s", p.baseURLs["flatpak"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var apps []FlatpakApp
        if err := json.NewDecoder(resp.Body).Decode(&amp;apps); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(apps) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no apps found in Flatpak")
        }</span>

        <span class="cov0" title="0">app := apps[0]
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("flatpak_%s", app.FlatpakAppID),
                MediaType:         MediaTypeSoftware,
                Title:             app.Name,
                Description:       app.Summary,
                Platform:          "Linux",
                Confidence:        0.8,
                RecognitionMethod: "flatpak_api",
                APIProvider:       "Flatpak",
                ExternalIDs: map[string]string{
                        "flatpak_id": app.FlatpakAppID,
                },
        }, nil</span>
}

func (p *GameSoftwareRecognitionProvider) searchSnapcraft(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Snapcraft API search
        params := url.Values{}
        params.Set("q", name)

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/v2/find?%s", p.baseURLs["snapcraft"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var result SnapcraftSearchResult
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(result.Results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no snaps found in Snapcraft")
        }</span>

        <span class="cov0" title="0">snap := result.Results[0]
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("snap_%s", snap.Name),
                MediaType:         MediaTypeSoftware,
                Title:             snap.Title,
                Description:       snap.Summary,
                Publisher:         snap.Publisher.DisplayName,
                Platform:          "Linux",
                Confidence:        0.8,
                RecognitionMethod: "snapcraft_api",
                APIProvider:       "Snapcraft",
                ExternalIDs: map[string]string{
                        "snap_id": snap.Name,
                },
        }, nil</span>
}

func (p *GameSoftwareRecognitionProvider) searchHomebrew(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Homebrew formulae API
        resp, err := p.httpClient.Get(fmt.Sprintf("%s/formula/%s.json", p.baseURLs["homebrew"], name))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var formula HomebrewFormula
        if err := json.NewDecoder(resp.Body).Decode(&amp;formula); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("homebrew_%s", formula.Name),
                MediaType:         MediaTypeSoftware,
                Title:             formula.Name,
                Description:       formula.Desc,
                Version:           formula.Versions.Stable,
                Platform:          "macOS",
                Confidence:        0.8,
                RecognitionMethod: "homebrew_api",
                APIProvider:       "Homebrew",
                ExternalIDs: map[string]string{
                        "homebrew_name": formula.Name,
                },
        }, nil</span>
}

func (p *GameSoftwareRecognitionProvider) searchGitHub(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // GitHub repository search
        params := url.Values{}
        params.Set("q", name)
        params.Set("sort", "stars")
        params.Set("order", "desc")

        req, err := http.NewRequestWithContext(ctx, "GET", fmt.Sprintf("%s/search/repositories?%s", p.baseURLs["github"], params.Encode()), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "token "+p.apiKeys["github"])
        req.Header.Set("Accept", "application/vnd.github.v3+json")

        resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResult GitHubSearchResult
        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResult); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResult.Items) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no repositories found on GitHub")
        }</span>

        <span class="cov0" title="0">repo := searchResult.Items[0]
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("github_%d", repo.ID),
                MediaType:         MediaTypeSoftware,
                Title:             repo.Name,
                Description:       repo.Description,
                Developer:         repo.Owner.Login,
                License:           repo.License.Name,
                Confidence:        p.calculateGitHubConfidence(repo.StargazersCount, repo.ForksCount),
                RecognitionMethod: "github_api",
                APIProvider:       "GitHub",
                ExternalIDs: map[string]string{
                        "github_id":  strconv.Itoa(repo.ID),
                        "github_url": repo.HTMLURL,
                },
        }, nil</span>
}

func (p *GameSoftwareRecognitionProvider) searchSourceForge(ctx context.Context, name string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // SourceForge API search (simplified)
        return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("sourceforge_%s", p.generateID(name)),
                MediaType:         MediaTypeSoftware,
                Title:             name,
                Confidence:        0.5,
                RecognitionMethod: "sourceforge_lookup",
                APIProvider:       "SourceForge",
                ExternalIDs:       make(map[string]string),
        }, nil
}</span>

func (p *GameSoftwareRecognitionProvider) basicGameSoftwareRecognition(req *MediaRecognitionRequest, name, version, platform string, isGame bool) *MediaRecognitionResult <span class="cov0" title="0">{
        mediaType := MediaTypeSoftware
        if isGame </span><span class="cov0" title="0">{
                mediaType = MediaTypeGame
        }</span>

        <span class="cov0" title="0">return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("basic_%s_%s_%d", strings.ReplaceAll(name, " ", "_"), platform, time.Now().Unix()),
                MediaType:         mediaType,
                Title:             name,
                Version:           version,
                Platform:          platform,
                Confidence:        0.3,
                RecognitionMethod: "filename_parsing",
                APIProvider:       "basic",
                ExternalIDs:       make(map[string]string),
        }</span>
}

// Helper methods
func (p *GameSoftwareRecognitionProvider) extractSoftwareMetadataFromFilename(filename string) (name, version, platform string) <span class="cov0" title="0">{
        // Remove file extension
        baseName := strings.TrimSuffix(filename, "."+p.getFileExtension(filename))

        // Common patterns for software/games:
        // Name v1.0.0
        // Name-1.0.0-win32
        // Name_Setup_v1.0.exe
        // Game.Name.2023.Repack

        // Extract version patterns
        versionPatterns := []string{
                `v?(\d+\.\d+\.\d+)`,
                `v?(\d+\.\d+)`,
                `(\d{4})`, // Year as version
        }

        for _, pattern := range versionPatterns </span><span class="cov0" title="0">{
                re := regexp.MustCompile(pattern)
                if matches := re.FindStringSubmatch(baseName); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        version = matches[1]
                        // Remove version from name
                        baseName = re.ReplaceAllString(baseName, "")
                        break</span>
                }
        }

        // Extract platform patterns
        <span class="cov0" title="0">platformPatterns := map[string][]string{
                "windows": {"win", "windows", "x86", "x64", "win32", "win64"},
                "linux":   {"linux", "ubuntu", "debian", "fedora", "arch"},
                "macos":   {"mac", "macos", "osx", "darwin"},
                "android": {"android", "apk"},
                "ios":     {"ios", "iphone", "ipad"},
        }

        lowerName := strings.ToLower(baseName)
        for platformName, patterns := range platformPatterns </span><span class="cov0" title="0">{
                for _, pattern := range patterns </span><span class="cov0" title="0">{
                        if strings.Contains(lowerName, pattern) </span><span class="cov0" title="0">{
                                platform = platformName
                                // Remove platform identifier from name
                                baseName = regexp.MustCompile(`(?i)`+pattern).ReplaceAllString(baseName, "")
                                break</span>
                        }
                }
                <span class="cov0" title="0">if platform != "" </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // Clean up name
        <span class="cov0" title="0">name = regexp.MustCompile(`[._-]+`).ReplaceAllString(baseName, " ")
        name = regexp.MustCompile(`\s+`).ReplaceAllString(name, " ")
        name = strings.TrimSpace(name)

        // Remove common software suffixes
        suffixes := []string{"setup", "installer", "install", "portable", "repack", "crack", "keygen"}
        for _, suffix := range suffixes </span><span class="cov0" title="0">{
                re := regexp.MustCompile(`(?i)\b` + suffix + `\b`)
                name = re.ReplaceAllString(name, "")
        }</span>

        <span class="cov0" title="0">name = strings.TrimSpace(name)

        return name, version, platform</span>
}

func (p *GameSoftwareRecognitionProvider) looksLikeGame(name, filename string) bool <span class="cov0" title="0">{
        gameKeywords := []string{
                "game", "play", "quest", "adventure", "action", "rpg", "fps", "strategy",
                "simulation", "racing", "sports", "puzzle", "arcade", "indie", "multiplayer",
                "steam", "gog", "epic", "uplay", "origin", "battle.net",
        }

        searchText := strings.ToLower(name + " " + filename)
        for _, keyword := range gameKeywords </span><span class="cov0" title="0">{
                if strings.Contains(searchText, keyword) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (p *GameSoftwareRecognitionProvider) getFileExtension(filename string) string <span class="cov0" title="0">{
        parts := strings.Split(filename, ".")
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                return parts[len(parts)-1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (p *GameSoftwareRecognitionProvider) getIGDBImageURL(imageID, size string) string <span class="cov0" title="0">{
        return fmt.Sprintf("https://images.igdb.com/igdb/image/upload/t_%s/%s.jpg", size, imageID)
}</span>

func (p *GameSoftwareRecognitionProvider) calculateIGDBConfidence(rating float64, ratingCount int, popularity float64) float64 <span class="cov0" title="0">{
        confidence := 0.5

        if rating &gt; 70 &amp;&amp; ratingCount &gt; 100 </span><span class="cov0" title="0">{
                confidence += 0.3
        }</span> else<span class="cov0" title="0"> if rating &gt; 60 &amp;&amp; ratingCount &gt; 50 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">if popularity &gt; 10 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *GameSoftwareRecognitionProvider) calculateGitHubConfidence(stars, forks int) float64 <span class="cov0" title="0">{
        confidence := 0.5

        if stars &gt; 1000 </span><span class="cov0" title="0">{
                confidence += 0.3
        }</span> else<span class="cov0" title="0"> if stars &gt; 100 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">if forks &gt; 100 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *GameSoftwareRecognitionProvider) generateID(name string) string <span class="cov0" title="0">{
        hash := md5.Sum([]byte(name))
        return hex.EncodeToString(hash[:])[:12]
}</span>

// RecognitionProvider interface implementation
func (p *GameSoftwareRecognitionProvider) GetProviderName() string <span class="cov0" title="0">{
        return "game_software_recognition"
}</span>

func (p *GameSoftwareRecognitionProvider) SupportsMediaType(mediaType MediaType) bool <span class="cov0" title="0">{
        supportedTypes := []MediaType{
                MediaTypeGame,
                MediaTypeGameOS,
                MediaTypeSoftware,
                MediaTypeSoftwareOS,
        }

        for _, supported := range supportedTypes </span><span class="cov0" title="0">{
                if mediaType == supported </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (p *GameSoftwareRecognitionProvider) GetConfidenceThreshold() float64 <span class="cov0" title="0">{
        return 0.4
}</span>

// Additional API structures
type WingetPackage struct {
        PackageIdentifier string `json:"PackageIdentifier"`
        PackageName       string `json:"PackageName"`
        PackageVersion    string `json:"PackageVersion"`
        Publisher         string `json:"Publisher"`
}

type FlatpakApp struct {
        FlatpakAppID  string `json:"flatpakAppId"`
        Name          string `json:"name"`
        Summary       string `json:"summary"`
        Description   string `json:"description"`
        DeveloperName string `json:"developerName"`
}

type SnapcraftSearchResult struct {
        Results []SnapcraftSnap `json:"_embedded"`
}

type SnapcraftSnap struct {
        Name      string             `json:"name"`
        Title     string             `json:"title"`
        Summary   string             `json:"summary"`
        Publisher SnapcraftPublisher `json:"publisher"`
}

type SnapcraftPublisher struct {
        DisplayName string `json:"display-name"`
}

type HomebrewFormula struct {
        Name     string           `json:"name"`
        Desc     string           `json:"desc"`
        Versions HomebrewVersions `json:"versions"`
}

type HomebrewVersions struct {
        Stable string `json:"stable"`
        Head   string `json:"head"`
}

type GitHubSearchResult struct {
        Items []GitHubRepository `json:"items"`
}

type GitHubRepository struct {
        ID              int           `json:"id"`
        Name            string        `json:"name"`
        FullName        string        `json:"full_name"`
        Description     string        `json:"description"`
        HTMLURL         string        `json:"html_url"`
        StargazersCount int           `json:"stargazers_count"`
        ForksCount      int           `json:"forks_count"`
        Language        string        `json:"language"`
        License         GitHubLicense `json:"license"`
        Owner           GitHubOwner   `json:"owner"`
}

type GitHubLicense struct {
        Name string `json:"name"`
}

type GitHubOwner struct {
        Login string `json:"login"`
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "go.uber.org/zap"
)

type LocalizationService struct {
        db                 *sql.DB
        logger             *zap.Logger
        translationService *TranslationService
        cacheService       *CacheService
}

type UserLocalization struct {
        ID                    int64     `json:"id" db:"id"`
        UserID                int64     `json:"user_id" db:"user_id"`
        PrimaryLanguage       string    `json:"primary_language" db:"primary_language"`
        SecondaryLanguages    []string  `json:"secondary_languages" db:"secondary_languages"`
        SubtitleLanguages     []string  `json:"subtitle_languages" db:"subtitle_languages"`
        LyricsLanguages       []string  `json:"lyrics_languages" db:"lyrics_languages"`
        MetadataLanguages     []string  `json:"metadata_languages" db:"metadata_languages"`
        AutoTranslate         bool      `json:"auto_translate" db:"auto_translate"`
        AutoDownloadSubtitles bool      `json:"auto_download_subtitles" db:"auto_download_subtitles"`
        AutoDownloadLyrics    bool      `json:"auto_download_lyrics" db:"auto_download_lyrics"`
        PreferredRegion       string    `json:"preferred_region" db:"preferred_region"`
        DateFormat            string    `json:"date_format" db:"date_format"`
        TimeFormat            string    `json:"time_format" db:"time_format"`
        NumberFormat          string    `json:"number_format" db:"number_format"`
        CurrencyCode          string    `json:"currency_code" db:"currency_code"`
        CreatedAt             time.Time `json:"created_at" db:"created_at"`
        UpdatedAt             time.Time `json:"updated_at" db:"updated_at"`
}

type LanguageProfile struct {
        Code            string   `json:"code"`
        Name            string   `json:"name"`
        NativeName      string   `json:"native_name"`
        Direction       string   `json:"direction"`
        Region          string   `json:"region"`
        Country         string   `json:"country"`
        SupportedBy     []string `json:"supported_by"`
        QualityRating   float64  `json:"quality_rating"`
        PopularityScore int      `json:"popularity_score"`
}

type ContentLanguagePreference struct {
        ID          int64     `json:"id" db:"id"`
        UserID      int64     `json:"user_id" db:"user_id"`
        ContentType string    `json:"content_type" db:"content_type"`
        Languages   []string  `json:"languages" db:"languages"`
        Priority    int       `json:"priority" db:"priority"`
        AutoApply   bool      `json:"auto_apply" db:"auto_apply"`
        CreatedAt   time.Time `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time `json:"updated_at" db:"updated_at"`
}

type LocalizationStats struct {
        TotalUsers             int64                      `json:"total_users"`
        UsersWithLocalization  int64                      `json:"users_with_localization"`
        PopularLanguages       []LanguageStats            `json:"popular_languages"`
        PopularRegions         []RegionStats              `json:"popular_regions"`
        TranslationRequests    int64                      `json:"translation_requests"`
        AutoTranslationEnabled int64                      `json:"auto_translation_enabled"`
        LanguageSupport        map[string]LanguageSupport `json:"language_support"`
}

type LanguageStats struct {
        Language string  `json:"language"`
        Count    int64   `json:"count"`
        Percent  float64 `json:"percent"`
}

type RegionStats struct {
        Region  string  `json:"region"`
        Count   int64   `json:"count"`
        Percent float64 `json:"percent"`
}

type LanguageSupport struct {
        Subtitles bool `json:"subtitles"`
        Lyrics    bool `json:"lyrics"`
        Metadata  bool `json:"metadata"`
        UI        bool `json:"ui"`
}

type WizardLocalizationStep struct {
        UserID                int64    `json:"user_id"`
        PrimaryLanguage       string   `json:"primary_language"`
        SecondaryLanguages    []string `json:"secondary_languages"`
        SubtitleLanguages     []string `json:"subtitle_languages"`
        LyricsLanguages       []string `json:"lyrics_languages"`
        MetadataLanguages     []string `json:"metadata_languages"`
        AutoTranslate         bool     `json:"auto_translate"`
        AutoDownloadSubtitles bool     `json:"auto_download_subtitles"`
        AutoDownloadLyrics    bool     `json:"auto_download_lyrics"`
        PreferredRegion       string   `json:"preferred_region"`
        DateFormat            string   `json:"date_format"`
        TimeFormat            string   `json:"time_format"`
        NumberFormat          string   `json:"number_format"`
        CurrencyCode          string   `json:"currency_code"`
}

type ConfigurationExport struct {
        Version          string                  `json:"version"`
        ExportedAt       time.Time               `json:"exported_at"`
        ExportedBy       int64                   `json:"exported_by"`
        ConfigType       string                  `json:"config_type"`
        Localization     *UserLocalization       `json:"localization,omitempty"`
        WizardStep       *WizardLocalizationStep `json:"wizard_step,omitempty"`
        MediaSettings    *MediaPlayerConfig      `json:"media_settings,omitempty"`
        PlaylistSettings *PlaylistConfig         `json:"playlist_settings,omitempty"`
        Description      string                  `json:"description"`
        Tags             []string                `json:"tags"`
}

type MediaPlayerConfig struct {
        DefaultQuality    string             `json:"default_quality"`
        AutoPlay          bool               `json:"auto_play"`
        CrossfadeEnabled  bool               `json:"crossfade_enabled"`
        CrossfadeDuration int                `json:"crossfade_duration"`
        EqualizerPreset   string             `json:"equalizer_preset"`
        EqualizerBands    map[string]float64 `json:"equalizer_bands"`
        RepeatMode        string             `json:"repeat_mode"`
        ShuffleEnabled    bool               `json:"shuffle_enabled"`
        VolumeLevel       float64            `json:"volume_level"`
        ReplayGainEnabled bool               `json:"replay_gain_enabled"`
}

type PlaylistConfig struct {
        AutoCreatePlaylists  bool     `json:"auto_create_playlists"`
        SmartPlaylistRules   []string `json:"smart_playlist_rules"`
        DefaultPlaylistType  string   `json:"default_playlist_type"`
        CollaborativeDefault bool     `json:"collaborative_default"`
        PublicDefault        bool     `json:"public_default"`
}

type ConfigurationImportResult struct {
        Success          bool                 `json:"success"`
        ImportedConfig   *ConfigurationExport `json:"imported_config"`
        ValidationErrors []string             `json:"validation_errors"`
        AppliedSettings  []string             `json:"applied_settings"`
        SkippedSettings  []string             `json:"skipped_settings"`
        BackupCreated    bool                 `json:"backup_created"`
        BackupPath       string               `json:"backup_path"`
}

const (
        ContentTypeSubtitles = "subtitles"
        ContentTypeLyrics    = "lyrics"
        ContentTypeMetadata  = "metadata"
        ContentTypeUI        = "ui"
)

var SupportedLanguages = map[string]LanguageProfile{
        "en": {Code: "en", Name: "English", NativeName: "English", Direction: "ltr", Region: "US", Country: "United States", SupportedBy: []string{"subtitles", "lyrics", "metadata", "ui"}, QualityRating: 10.0, PopularityScore: 100},
        "es": {Code: "es", Name: "Spanish", NativeName: "Espaol", Direction: "ltr", Region: "ES", Country: "Spain", SupportedBy: []string{"subtitles", "lyrics", "metadata", "ui"}, QualityRating: 9.5, PopularityScore: 85},
        "fr": {Code: "fr", Name: "French", NativeName: "Franais", Direction: "ltr", Region: "FR", Country: "France", SupportedBy: []string{"subtitles", "lyrics", "metadata", "ui"}, QualityRating: 9.5, PopularityScore: 75},
        "de": {Code: "de", Name: "German", NativeName: "Deutsch", Direction: "ltr", Region: "DE", Country: "Germany", SupportedBy: []string{"subtitles", "lyrics", "metadata", "ui"}, QualityRating: 9.2, PopularityScore: 70},
        "it": {Code: "it", Name: "Italian", NativeName: "Italiano", Direction: "ltr", Region: "IT", Country: "Italy", SupportedBy: []string{"subtitles", "lyrics", "metadata", "ui"}, QualityRating: 9.0, PopularityScore: 65},
        "pt": {Code: "pt", Name: "Portuguese", NativeName: "Portugus", Direction: "ltr", Region: "PT", Country: "Portugal", SupportedBy: []string{"subtitles", "lyrics", "metadata", "ui"}, QualityRating: 8.8, PopularityScore: 60},
        "ru": {Code: "ru", Name: "Russian", NativeName: "", Direction: "ltr", Region: "RU", Country: "Russia", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.5, PopularityScore: 55},
        "ja": {Code: "ja", Name: "Japanese", NativeName: "", Direction: "ltr", Region: "JP", Country: "Japan", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.8, PopularityScore: 50},
        "ko": {Code: "ko", Name: "Korean", NativeName: "", Direction: "ltr", Region: "KR", Country: "South Korea", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.6, PopularityScore: 45},
        "zh": {Code: "zh", Name: "Chinese", NativeName: "", Direction: "ltr", Region: "CN", Country: "China", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.7, PopularityScore: 80},
        "ar": {Code: "ar", Name: "Arabic", NativeName: "", Direction: "rtl", Region: "SA", Country: "Saudi Arabia", SupportedBy: []string{"subtitles", "metadata"}, QualityRating: 7.5, PopularityScore: 40},
        "hi": {Code: "hi", Name: "Hindi", NativeName: "", Direction: "ltr", Region: "IN", Country: "India", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 7.8, PopularityScore: 60},
        "nl": {Code: "nl", Name: "Dutch", NativeName: "Nederlands", Direction: "ltr", Region: "NL", Country: "Netherlands", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.9, PopularityScore: 30},
        "sv": {Code: "sv", Name: "Swedish", NativeName: "Svenska", Direction: "ltr", Region: "SE", Country: "Sweden", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.7, PopularityScore: 25},
        "no": {Code: "no", Name: "Norwegian", NativeName: "Norsk", Direction: "ltr", Region: "NO", Country: "Norway", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.6, PopularityScore: 20},
        "da": {Code: "da", Name: "Danish", NativeName: "Dansk", Direction: "ltr", Region: "DK", Country: "Denmark", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.5, PopularityScore: 18},
        "pl": {Code: "pl", Name: "Polish", NativeName: "Polski", Direction: "ltr", Region: "PL", Country: "Poland", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.3, PopularityScore: 35},
        "tr": {Code: "tr", Name: "Turkish", NativeName: "Trke", Direction: "ltr", Region: "TR", Country: "Turkey", SupportedBy: []string{"subtitles", "lyrics", "metadata"}, QualityRating: 8.0, PopularityScore: 30},
        "he": {Code: "he", Name: "Hebrew", NativeName: "", Direction: "rtl", Region: "IL", Country: "Israel", SupportedBy: []string{"subtitles", "metadata"}, QualityRating: 7.8, PopularityScore: 15},
        "th": {Code: "th", Name: "Thai", NativeName: "", Direction: "ltr", Region: "TH", Country: "Thailand", SupportedBy: []string{"subtitles", "metadata"}, QualityRating: 7.2, PopularityScore: 25},
        "vi": {Code: "vi", Name: "Vietnamese", NativeName: "Ting Vit", Direction: "ltr", Region: "VN", Country: "Vietnam", SupportedBy: []string{"subtitles", "metadata"}, QualityRating: 7.0, PopularityScore: 28},
}

func NewLocalizationService(
        db *sql.DB,
        logger *zap.Logger,
        translationService *TranslationService,
        cacheService *CacheService,
) *LocalizationService <span class="cov0" title="0">{
        return &amp;LocalizationService{
                db:                 db,
                logger:             logger,
                translationService: translationService,
                cacheService:       cacheService,
        }
}</span>

func (s *LocalizationService) SetupUserLocalization(ctx context.Context, req *WizardLocalizationStep) (*UserLocalization, error) <span class="cov0" title="0">{
        s.logger.Info("Setting up user localization",
                zap.Int64("user_id", req.UserID),
                zap.String("primary_language", req.PrimaryLanguage))

        secondaryLanguagesJSON, _ := json.Marshal(req.SecondaryLanguages)
        subtitleLanguagesJSON, _ := json.Marshal(req.SubtitleLanguages)
        lyricsLanguagesJSON, _ := json.Marshal(req.LyricsLanguages)
        metadataLanguagesJSON, _ := json.Marshal(req.MetadataLanguages)

        query := `
                INSERT INTO user_localization (
                        user_id, primary_language, secondary_languages, subtitle_languages,
                        lyrics_languages, metadata_languages, auto_translate, auto_download_subtitles,
                        auto_download_lyrics, preferred_region, date_format, time_format,
                        number_format, currency_code, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, NOW(), NOW())
                ON CONFLICT (user_id)
                DO UPDATE SET
                        primary_language = EXCLUDED.primary_language,
                        secondary_languages = EXCLUDED.secondary_languages,
                        subtitle_languages = EXCLUDED.subtitle_languages,
                        lyrics_languages = EXCLUDED.lyrics_languages,
                        metadata_languages = EXCLUDED.metadata_languages,
                        auto_translate = EXCLUDED.auto_translate,
                        auto_download_subtitles = EXCLUDED.auto_download_subtitles,
                        auto_download_lyrics = EXCLUDED.auto_download_lyrics,
                        preferred_region = EXCLUDED.preferred_region,
                        date_format = EXCLUDED.date_format,
                        time_format = EXCLUDED.time_format,
                        number_format = EXCLUDED.number_format,
                        currency_code = EXCLUDED.currency_code,
                        updated_at = NOW()
                RETURNING id, created_at, updated_at
        `

        var localization UserLocalization
        err := s.db.QueryRowContext(ctx, query,
                req.UserID, req.PrimaryLanguage, string(secondaryLanguagesJSON),
                string(subtitleLanguagesJSON), string(lyricsLanguagesJSON),
                string(metadataLanguagesJSON), req.AutoTranslate, req.AutoDownloadSubtitles,
                req.AutoDownloadLyrics, req.PreferredRegion, req.DateFormat,
                req.TimeFormat, req.NumberFormat, req.CurrencyCode).Scan(
                &amp;localization.ID, &amp;localization.CreatedAt, &amp;localization.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to setup user localization", zap.Error(err))
                return nil, fmt.Errorf("failed to setup localization: %w", err)
        }</span>

        <span class="cov0" title="0">localization.UserID = req.UserID
        localization.PrimaryLanguage = req.PrimaryLanguage
        localization.SecondaryLanguages = req.SecondaryLanguages
        localization.SubtitleLanguages = req.SubtitleLanguages
        localization.LyricsLanguages = req.LyricsLanguages
        localization.MetadataLanguages = req.MetadataLanguages
        localization.AutoTranslate = req.AutoTranslate
        localization.AutoDownloadSubtitles = req.AutoDownloadSubtitles
        localization.AutoDownloadLyrics = req.AutoDownloadLyrics
        localization.PreferredRegion = req.PreferredRegion
        localization.DateFormat = req.DateFormat
        localization.TimeFormat = req.TimeFormat
        localization.NumberFormat = req.NumberFormat
        localization.CurrencyCode = req.CurrencyCode

        if err := s.setupContentPreferences(ctx, &amp;localization); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to setup content preferences", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.preloadTranslations(ctx, &amp;localization); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to preload translations", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return &amp;localization, nil</span>
}

func (s *LocalizationService) GetUserLocalization(ctx context.Context, userID int64) (*UserLocalization, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting user localization", zap.Int64("user_id", userID))

        query := `
                SELECT id, user_id, primary_language, secondary_languages, subtitle_languages,
                           lyrics_languages, metadata_languages, auto_translate, auto_download_subtitles,
                           auto_download_lyrics, preferred_region, date_format, time_format,
                           number_format, currency_code, created_at, updated_at
                FROM user_localization
                WHERE user_id = $1
        `

        var localization UserLocalization
        var secondaryLanguagesJSON, subtitleLanguagesJSON, lyricsLanguagesJSON, metadataLanguagesJSON string

        err := s.db.QueryRowContext(ctx, query, userID).Scan(
                &amp;localization.ID, &amp;localization.UserID, &amp;localization.PrimaryLanguage,
                &amp;secondaryLanguagesJSON, &amp;subtitleLanguagesJSON, &amp;lyricsLanguagesJSON,
                &amp;metadataLanguagesJSON, &amp;localization.AutoTranslate, &amp;localization.AutoDownloadSubtitles,
                &amp;localization.AutoDownloadLyrics, &amp;localization.PreferredRegion, &amp;localization.DateFormat,
                &amp;localization.TimeFormat, &amp;localization.NumberFormat, &amp;localization.CurrencyCode,
                &amp;localization.CreatedAt, &amp;localization.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return s.createDefaultLocalization(ctx, userID)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get user localization", zap.Error(err))
                return nil, fmt.Errorf("failed to get user localization: %w", err)
        }</span>

        <span class="cov0" title="0">json.Unmarshal([]byte(secondaryLanguagesJSON), &amp;localization.SecondaryLanguages)
        json.Unmarshal([]byte(subtitleLanguagesJSON), &amp;localization.SubtitleLanguages)
        json.Unmarshal([]byte(lyricsLanguagesJSON), &amp;localization.LyricsLanguages)
        json.Unmarshal([]byte(metadataLanguagesJSON), &amp;localization.MetadataLanguages)

        return &amp;localization, nil</span>
}

func (s *LocalizationService) UpdateUserLocalization(ctx context.Context, userID int64, updates map[string]interface{}) error <span class="cov0" title="0">{
        s.logger.Info("Updating user localization", zap.Int64("user_id", userID))

        if len(updates) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no updates provided")
        }</span>

        <span class="cov0" title="0">setParts := []string{}
        args := []interface{}{}
        argIndex := 1

        for field, value := range updates </span><span class="cov0" title="0">{
                switch field </span>{
                case "primary_language", "preferred_region", "date_format", "time_format", "number_format", "currency_code":<span class="cov0" title="0">
                        setParts = append(setParts, fmt.Sprintf("%s = $%d", field, argIndex))
                        args = append(args, value)
                        argIndex++</span>
                case "secondary_languages", "subtitle_languages", "lyrics_languages", "metadata_languages":<span class="cov0" title="0">
                        if languages, ok := value.([]string); ok </span><span class="cov0" title="0">{
                                languagesJSON, _ := json.Marshal(languages)
                                setParts = append(setParts, fmt.Sprintf("%s = $%d", field, argIndex))
                                args = append(args, string(languagesJSON))
                                argIndex++
                        }</span>
                case "auto_translate", "auto_download_subtitles", "auto_download_lyrics":<span class="cov0" title="0">
                        setParts = append(setParts, fmt.Sprintf("%s = $%d", field, argIndex))
                        args = append(args, value)
                        argIndex++</span>
                }
        }

        <span class="cov0" title="0">if len(setParts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no valid updates provided")
        }</span>

        <span class="cov0" title="0">setParts = append(setParts, "updated_at = NOW()")
        args = append(args, userID)

        query := fmt.Sprintf(`
                UPDATE user_localization
                SET %s
                WHERE user_id = $%d
        `, strings.Join(setParts, ", "), argIndex)

        _, err := s.db.ExecContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update user localization", zap.Error(err))
                return fmt.Errorf("failed to update user localization: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalizationService) GetPreferredLanguagesForContent(ctx context.Context, userID int64, contentType string) ([]string, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting preferred languages for content",
                zap.Int64("user_id", userID),
                zap.String("content_type", contentType))

        localization, err := s.GetUserLocalization(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return []string{"en"}, err
        }</span>

        <span class="cov0" title="0">switch contentType </span>{
        case ContentTypeSubtitles:<span class="cov0" title="0">
                if len(localization.SubtitleLanguages) &gt; 0 </span><span class="cov0" title="0">{
                        return localization.SubtitleLanguages, nil
                }</span>
        case ContentTypeLyrics:<span class="cov0" title="0">
                if len(localization.LyricsLanguages) &gt; 0 </span><span class="cov0" title="0">{
                        return localization.LyricsLanguages, nil
                }</span>
        case ContentTypeMetadata:<span class="cov0" title="0">
                if len(localization.MetadataLanguages) &gt; 0 </span><span class="cov0" title="0">{
                        return localization.MetadataLanguages, nil
                }</span>
        }

        <span class="cov0" title="0">languages := []string{localization.PrimaryLanguage}
        languages = append(languages, localization.SecondaryLanguages...)

        if len(languages) == 0 </span><span class="cov0" title="0">{
                return []string{"en"}, nil
        }</span>

        <span class="cov0" title="0">return languages, nil</span>
}

func (s *LocalizationService) ShouldAutoTranslate(ctx context.Context, userID int64, contentType string) (bool, error) <span class="cov0" title="0">{
        localization, err := s.GetUserLocalization(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return localization.AutoTranslate, nil</span>
}

func (s *LocalizationService) ShouldAutoDownload(ctx context.Context, userID int64, contentType string) (bool, error) <span class="cov0" title="0">{
        localization, err := s.GetUserLocalization(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">switch contentType </span>{
        case ContentTypeSubtitles:<span class="cov0" title="0">
                return localization.AutoDownloadSubtitles, nil</span>
        case ContentTypeLyrics:<span class="cov0" title="0">
                return localization.AutoDownloadLyrics, nil</span>
        default:<span class="cov0" title="0">
                return false, nil</span>
        }
}

func (s *LocalizationService) GetSupportedLanguages(ctx context.Context) (map[string]LanguageProfile, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting supported languages")

        cacheKey := "localization:supported_languages"
        var languages map[string]LanguageProfile

        found, err := s.cacheService.Get(ctx, cacheKey, &amp;languages)
        if err == nil &amp;&amp; found </span><span class="cov0" title="0">{
                return languages, nil
        }</span>

        <span class="cov0" title="0">languages = make(map[string]LanguageProfile)
        for code, profile := range SupportedLanguages </span><span class="cov0" title="0">{
                languages[code] = profile
        }</span>

        <span class="cov0" title="0">if err := s.cacheService.Set(ctx, cacheKey, languages, 24*time.Hour); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to cache supported languages", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return languages, nil</span>
}

func (s *LocalizationService) GetLanguageProfile(ctx context.Context, languageCode string) (*LanguageProfile, error) <span class="cov0" title="0">{
        if profile, exists := SupportedLanguages[languageCode]; exists </span><span class="cov0" title="0">{
                return &amp;profile, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("language not supported: %s", languageCode)</span>
}

func (s *LocalizationService) IsLanguageSupported(ctx context.Context, languageCode, contentType string) bool <span class="cov0" title="0">{
        profile, exists := SupportedLanguages[languageCode]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, supportedType := range profile.SupportedBy </span><span class="cov0" title="0">{
                if supportedType == contentType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (s *LocalizationService) GetLocalizationStats(ctx context.Context) (*LocalizationStats, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting localization statistics")

        stats := &amp;LocalizationStats{
                PopularLanguages: make([]LanguageStats, 0),
                PopularRegions:   make([]RegionStats, 0),
                LanguageSupport:  make(map[string]LanguageSupport),
        }

        if err := s.getBasicLocalizationStats(ctx, stats); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.getPopularLanguages(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get popular languages", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getPopularRegions(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get popular regions", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getLanguageSupport(ctx, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get language support", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (s *LocalizationService) createDefaultLocalization(ctx context.Context, userID int64) (*UserLocalization, error) <span class="cov0" title="0">{
        s.logger.Info("Creating default localization", zap.Int64("user_id", userID))

        defaultReq := &amp;WizardLocalizationStep{
                UserID:                userID,
                PrimaryLanguage:       "en",
                SecondaryLanguages:    []string{},
                SubtitleLanguages:     []string{"en"},
                LyricsLanguages:       []string{"en"},
                MetadataLanguages:     []string{"en"},
                AutoTranslate:         false,
                AutoDownloadSubtitles: true,
                AutoDownloadLyrics:    true,
                PreferredRegion:       "US",
                DateFormat:            "MM/DD/YYYY",
                TimeFormat:            "12h",
                NumberFormat:          "en-US",
                CurrencyCode:          "USD",
        }

        return s.SetupUserLocalization(ctx, defaultReq)
}</span>

func (s *LocalizationService) setupContentPreferences(ctx context.Context, localization *UserLocalization) error <span class="cov0" title="0">{
        contentTypes := []struct {
                Type      string
                Languages []string
        }{
                {ContentTypeSubtitles, localization.SubtitleLanguages},
                {ContentTypeLyrics, localization.LyricsLanguages},
                {ContentTypeMetadata, localization.MetadataLanguages},
        }

        for _, ct := range contentTypes </span><span class="cov0" title="0">{
                if len(ct.Languages) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">languagesJSON, _ := json.Marshal(ct.Languages)

                query := `
                        INSERT INTO content_language_preferences (user_id, content_type, languages, priority, auto_apply, created_at, updated_at)
                        VALUES ($1, $2, $3, 1, true, NOW(), NOW())
                        ON CONFLICT (user_id, content_type)
                        DO UPDATE SET
                                languages = EXCLUDED.languages,
                                auto_apply = EXCLUDED.auto_apply,
                                updated_at = NOW()
                `

                _, err := s.db.ExecContext(ctx, query, localization.UserID, ct.Type, string(languagesJSON))
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to setup content preference",
                                zap.String("content_type", ct.Type),
                                zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalizationService) preloadTranslations(ctx context.Context, localization *UserLocalization) error <span class="cov0" title="0">{
        if !localization.AutoTranslate </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">commonPhrases := []string{
                "Play", "Pause", "Stop", "Next", "Previous", "Volume", "Subtitles",
                "Audio", "Quality", "Fullscreen", "Playlist", "Lyrics", "Settings",
                "Search", "Library", "Recently Played", "Favorites", "Download",
                "Share", "Info", "Cast", "Speed", "Bookmark", "Chapter",
        }

        sourceLang := "en"
        targetLangs := append([]string{localization.PrimaryLanguage}, localization.SecondaryLanguages...)

        for _, targetLang := range targetLangs </span><span class="cov0" title="0">{
                if targetLang == sourceLang </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, phrase := range commonPhrases </span><span class="cov0" title="0">{
                        req := TranslationRequest{
                                Text:           phrase,
                                SourceLanguage: sourceLang,
                                TargetLanguage: targetLang,
                        }

                        go func(req TranslationRequest) </span><span class="cov0" title="0">{
                                _, err := s.translationService.TranslateText(ctx, req)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Debug("Failed to preload translation",
                                                zap.String("phrase", req.Text),
                                                zap.String("target_lang", req.TargetLanguage),
                                                zap.Error(err))
                                }</span>
                        }(req)
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalizationService) getBasicLocalizationStats(ctx context.Context, stats *LocalizationStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        (SELECT COUNT(*) FROM users) as total_users,
                        COUNT(*) as users_with_localization,
                        COUNT(CASE WHEN auto_translate = true THEN 1 END) as auto_translation_enabled
                FROM user_localization
        `

        return s.db.QueryRowContext(ctx, query).Scan(
                &amp;stats.TotalUsers, &amp;stats.UsersWithLocalization, &amp;stats.AutoTranslationEnabled)
}</span>

func (s *LocalizationService) getPopularLanguages(ctx context.Context, stats *LocalizationStats) error <span class="cov0" title="0">{
        query := `
                SELECT primary_language, COUNT(*) as count
                FROM user_localization
                GROUP BY primary_language
                ORDER BY count DESC
                LIMIT 10
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        total := float64(stats.UsersWithLocalization)
        for rows.Next() </span><span class="cov0" title="0">{
                var lang LanguageStats
                if err := rows.Scan(&amp;lang.Language, &amp;lang.Count); err == nil </span><span class="cov0" title="0">{
                        if total &gt; 0 </span><span class="cov0" title="0">{
                                lang.Percent = float64(lang.Count) / total * 100
                        }</span>
                        <span class="cov0" title="0">stats.PopularLanguages = append(stats.PopularLanguages, lang)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalizationService) getPopularRegions(ctx context.Context, stats *LocalizationStats) error <span class="cov0" title="0">{
        query := `
                SELECT preferred_region, COUNT(*) as count
                FROM user_localization
                WHERE preferred_region != ''
                GROUP BY preferred_region
                ORDER BY count DESC
                LIMIT 10
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        total := float64(stats.UsersWithLocalization)
        for rows.Next() </span><span class="cov0" title="0">{
                var region RegionStats
                if err := rows.Scan(&amp;region.Region, &amp;region.Count); err == nil </span><span class="cov0" title="0">{
                        if total &gt; 0 </span><span class="cov0" title="0">{
                                region.Percent = float64(region.Count) / total * 100
                        }</span>
                        <span class="cov0" title="0">stats.PopularRegions = append(stats.PopularRegions, region)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalizationService) getLanguageSupport(ctx context.Context, stats *LocalizationStats) error <span class="cov0" title="0">{
        for code, profile := range SupportedLanguages </span><span class="cov0" title="0">{
                support := LanguageSupport{}

                for _, contentType := range profile.SupportedBy </span><span class="cov0" title="0">{
                        switch contentType </span>{
                        case "subtitles":<span class="cov0" title="0">
                                support.Subtitles = true</span>
                        case "lyrics":<span class="cov0" title="0">
                                support.Lyrics = true</span>
                        case "metadata":<span class="cov0" title="0">
                                support.Metadata = true</span>
                        case "ui":<span class="cov0" title="0">
                                support.UI = true</span>
                        }
                }

                <span class="cov0" title="0">stats.LanguageSupport[code] = support</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalizationService) DetectUserLanguage(ctx context.Context, userAgent, acceptLanguage string) string <span class="cov0" title="0">{
        if acceptLanguage != "" </span><span class="cov0" title="0">{
                languages := strings.Split(acceptLanguage, ",")
                for _, lang := range languages </span><span class="cov0" title="0">{
                        langCode := strings.TrimSpace(strings.Split(lang, ";")[0])
                        langCode = strings.Split(langCode, "-")[0]

                        if _, exists := SupportedLanguages[langCode]; exists </span><span class="cov0" title="0">{
                                return langCode
                        }</span>
                }
        }

        <span class="cov0" title="0">return "en"</span>
}

func (s *LocalizationService) FormatDateTimeForUser(ctx context.Context, userID int64, timestamp time.Time) (string, error) <span class="cov0" title="0">{
        localization, err := s.GetUserLocalization(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return timestamp.Format("2006-01-02 15:04:05"), nil
        }</span>

        <span class="cov0" title="0">dateFormat := localization.DateFormat
        timeFormat := localization.TimeFormat

        var layout string
        switch dateFormat </span>{
        case "DD/MM/YYYY":<span class="cov0" title="0">
                layout = "02/01/2006"</span>
        case "YYYY-MM-DD":<span class="cov0" title="0">
                layout = "2006-01-02"</span>
        case "MM-DD-YYYY":<span class="cov0" title="0">
                layout = "01-02-2006"</span>
        default:<span class="cov0" title="0">
                layout = "01/02/2006"</span>
        }

        <span class="cov0" title="0">if timeFormat == "24h" </span><span class="cov0" title="0">{
                layout += " 15:04"
        }</span> else<span class="cov0" title="0"> {
                layout += " 03:04 PM"
        }</span>

        <span class="cov0" title="0">return timestamp.Format(layout), nil</span>
}

func (s *LocalizationService) GetWizardDefaults(ctx context.Context, detectedLanguage string) *WizardLocalizationStep <span class="cov0" title="0">{
        profile, exists := SupportedLanguages[detectedLanguage]
        if !exists </span><span class="cov0" title="0">{
                detectedLanguage = "en"
                profile = SupportedLanguages["en"]
        }</span>

        <span class="cov0" title="0">return &amp;WizardLocalizationStep{
                PrimaryLanguage:       detectedLanguage,
                SecondaryLanguages:    []string{},
                SubtitleLanguages:     []string{detectedLanguage, "en"},
                LyricsLanguages:       []string{detectedLanguage, "en"},
                MetadataLanguages:     []string{detectedLanguage, "en"},
                AutoTranslate:         detectedLanguage != "en",
                AutoDownloadSubtitles: true,
                AutoDownloadLyrics:    true,
                PreferredRegion:       profile.Region,
                DateFormat:            s.getDefaultDateFormat(profile.Region),
                TimeFormat:            s.getDefaultTimeFormat(profile.Region),
                NumberFormat:          detectedLanguage + "-" + profile.Region,
                CurrencyCode:          s.getDefaultCurrency(profile.Region),
        }</span>
}

func (s *LocalizationService) getDefaultDateFormat(region string) string <span class="cov0" title="0">{
        switch region </span>{
        case "US":<span class="cov0" title="0">
                return "MM/DD/YYYY"</span>
        case "GB", "AU", "NZ":<span class="cov0" title="0">
                return "DD/MM/YYYY"</span>
        default:<span class="cov0" title="0">
                return "YYYY-MM-DD"</span>
        }
}

func (s *LocalizationService) getDefaultTimeFormat(region string) string <span class="cov0" title="0">{
        switch region </span>{
        case "US":<span class="cov0" title="0">
                return "12h"</span>
        default:<span class="cov0" title="0">
                return "24h"</span>
        }
}

func (s *LocalizationService) getDefaultCurrency(region string) string <span class="cov0" title="0">{
        currencyMap := map[string]string{
                "US": "USD", "CA": "CAD", "GB": "GBP", "EU": "EUR", "FR": "EUR",
                "DE": "EUR", "IT": "EUR", "ES": "EUR", "PT": "EUR", "NL": "EUR",
                "JP": "JPY", "KR": "KRW", "CN": "CNY", "IN": "INR", "AU": "AUD",
                "RU": "RUB", "BR": "BRL", "MX": "MXN", "AR": "ARS", "SE": "SEK",
                "NO": "NOK", "DK": "DKK", "CH": "CHF", "PL": "PLN", "TR": "TRY",
        }

        if currency, exists := currencyMap[region]; exists </span><span class="cov0" title="0">{
                return currency
        }</span>
        <span class="cov0" title="0">return "USD"</span>
}

func (s *LocalizationService) ExportConfiguration(ctx context.Context, userID int64, configType string, description string, tags []string) (*ConfigurationExport, error) <span class="cov0" title="0">{
        s.logger.Info("Exporting user configuration",
                zap.Int64("user_id", userID),
                zap.String("config_type", configType))

        export := &amp;ConfigurationExport{
                Version:     "1.0",
                ExportedAt:  time.Now(),
                ExportedBy:  userID,
                ConfigType:  configType,
                Description: description,
                Tags:        tags,
        }

        // Export localization settings
        if configType == "full" || configType == "localization" </span><span class="cov0" title="0">{
                localization, err := s.GetUserLocalization(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to get localization for export", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        export.Localization = localization
                        export.WizardStep = s.convertLocalizationToWizardStep(localization)
                }</span>
        }

        // Export media player settings
        <span class="cov0" title="0">if configType == "full" || configType == "media" </span><span class="cov0" title="0">{
                mediaSettings, err := s.getMediaPlayerConfig(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to get media settings for export", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        export.MediaSettings = mediaSettings
                }</span>
        }

        // Export playlist settings
        <span class="cov0" title="0">if configType == "full" || configType == "playlists" </span><span class="cov0" title="0">{
                playlistSettings, err := s.getPlaylistConfig(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to get playlist settings for export", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        export.PlaylistSettings = playlistSettings
                }</span>
        }

        // Store export in database for future reference
        <span class="cov0" title="0">if err := s.storeConfigurationExport(ctx, export); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to store export record", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return export, nil</span>
}

func (s *LocalizationService) ImportConfiguration(ctx context.Context, userID int64, configJSON string, options map[string]bool) (*ConfigurationImportResult, error) <span class="cov0" title="0">{
        s.logger.Info("Importing user configuration", zap.Int64("user_id", userID))

        result := &amp;ConfigurationImportResult{
                Success:          false,
                ValidationErrors: make([]string, 0),
                AppliedSettings:  make([]string, 0),
                SkippedSettings:  make([]string, 0),
        }

        // Parse JSON configuration
        var config ConfigurationExport
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                result.ValidationErrors = append(result.ValidationErrors, fmt.Sprintf("Invalid JSON format: %v", err))
                return result, fmt.Errorf("failed to parse configuration JSON: %w", err)
        }</span>

        <span class="cov0" title="0">result.ImportedConfig = &amp;config

        // Validate configuration
        if validationErrors := s.validateConfiguration(&amp;config); len(validationErrors) &gt; 0 </span><span class="cov0" title="0">{
                result.ValidationErrors = append(result.ValidationErrors, validationErrors...)
                if !options["force_import"] </span><span class="cov0" title="0">{
                        return result, fmt.Errorf("configuration validation failed")
                }</span>
        }

        // Create backup of current settings
        <span class="cov0" title="0">if options["create_backup"] </span><span class="cov0" title="0">{
                backup, err := s.ExportConfiguration(ctx, userID, "full", "Pre-import backup", []string{"backup", "auto"})
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to create backup", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        result.BackupCreated = true
                        result.BackupPath = fmt.Sprintf("/backups/user_%d_%d.json", userID, backup.ExportedAt.Unix())
                }</span>
        }

        // Import localization settings
        <span class="cov0" title="0">if config.Localization != nil &amp;&amp; (options["import_localization"] || options["import_all"]) </span><span class="cov0" title="0">{
                if err := s.importLocalizationSettings(ctx, userID, config.Localization); err != nil </span><span class="cov0" title="0">{
                        result.SkippedSettings = append(result.SkippedSettings, fmt.Sprintf("Localization: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        result.AppliedSettings = append(result.AppliedSettings, "Localization preferences")
                }</span>
        }

        // Import wizard step configuration
        <span class="cov0" title="0">if config.WizardStep != nil &amp;&amp; (options["import_wizard"] || options["import_all"]) </span><span class="cov0" title="0">{
                if err := s.importWizardStepSettings(ctx, userID, config.WizardStep); err != nil </span><span class="cov0" title="0">{
                        result.SkippedSettings = append(result.SkippedSettings, fmt.Sprintf("Wizard step: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        result.AppliedSettings = append(result.AppliedSettings, "Wizard step configuration")
                }</span>
        }

        // Import media settings
        <span class="cov0" title="0">if config.MediaSettings != nil &amp;&amp; (options["import_media"] || options["import_all"]) </span><span class="cov0" title="0">{
                if err := s.importMediaSettings(ctx, userID, config.MediaSettings); err != nil </span><span class="cov0" title="0">{
                        result.SkippedSettings = append(result.SkippedSettings, fmt.Sprintf("Media settings: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        result.AppliedSettings = append(result.AppliedSettings, "Media player settings")
                }</span>
        }

        // Import playlist settings
        <span class="cov0" title="0">if config.PlaylistSettings != nil &amp;&amp; (options["import_playlists"] || options["import_all"]) </span><span class="cov0" title="0">{
                if err := s.importPlaylistSettings(ctx, userID, config.PlaylistSettings); err != nil </span><span class="cov0" title="0">{
                        result.SkippedSettings = append(result.SkippedSettings, fmt.Sprintf("Playlist settings: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        result.AppliedSettings = append(result.AppliedSettings, "Playlist settings")
                }</span>
        }

        <span class="cov0" title="0">result.Success = len(result.AppliedSettings) &gt; 0

        // Log import activity
        if err := s.logImportActivity(ctx, userID, &amp;config, result); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to log import activity", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (s *LocalizationService) ValidateConfigurationJSON(ctx context.Context, configJSON string) ([]string, error) <span class="cov0" title="0">{
        s.logger.Debug("Validating configuration JSON")

        var config ConfigurationExport
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                return []string{fmt.Sprintf("Invalid JSON format: %v", err)}, err
        }</span>

        <span class="cov0" title="0">return s.validateConfiguration(&amp;config), nil</span>
}

func (s *LocalizationService) GetConfigurationTemplate(ctx context.Context, templateType string) (*ConfigurationExport, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting configuration template", zap.String("type", templateType))

        template := &amp;ConfigurationExport{
                Version:     "1.0",
                ExportedAt:  time.Now(),
                ExportedBy:  0,
                ConfigType:  templateType,
                Description: fmt.Sprintf("Template for %s configuration", templateType),
                Tags:        []string{"template"},
        }

        switch templateType </span>{
        case "localization":<span class="cov0" title="0">
                template.Localization = s.getDefaultLocalizationTemplate()
                template.WizardStep = s.getDefaultWizardStepTemplate()</span>
        case "media":<span class="cov0" title="0">
                template.MediaSettings = s.getDefaultMediaSettingsTemplate()</span>
        case "playlists":<span class="cov0" title="0">
                template.PlaylistSettings = s.getDefaultPlaylistSettingsTemplate()</span>
        case "full":<span class="cov0" title="0">
                template.Localization = s.getDefaultLocalizationTemplate()
                template.WizardStep = s.getDefaultWizardStepTemplate()
                template.MediaSettings = s.getDefaultMediaSettingsTemplate()
                template.PlaylistSettings = s.getDefaultPlaylistSettingsTemplate()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown template type: %s", templateType)</span>
        }

        <span class="cov0" title="0">return template, nil</span>
}

func (s *LocalizationService) EditConfiguration(ctx context.Context, userID int64, configJSON string, edits map[string]interface{}) (string, error) <span class="cov0" title="0">{
        s.logger.Info("Editing configuration", zap.Int64("user_id", userID))

        var config ConfigurationExport
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse configuration JSON: %w", err)
        }</span>

        // Apply edits to the configuration
        <span class="cov0" title="0">for path, value := range edits </span><span class="cov0" title="0">{
                if err := s.applyConfigurationEdit(&amp;config, path, value); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to apply edit", zap.String("path", path), zap.Error(err))
                        return "", fmt.Errorf("failed to apply edit at path %s: %w", path, err)
                }</span>
        }

        // Update metadata
        <span class="cov0" title="0">config.ExportedAt = time.Now()
        config.ExportedBy = userID

        // Convert back to JSON
        editedJSON, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal edited configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return string(editedJSON), nil</span>
}

func (s *LocalizationService) ConvertWizardToConfiguration(ctx context.Context, wizardStep *WizardLocalizationStep) (*ConfigurationExport, error) <span class="cov0" title="0">{
        s.logger.Debug("Converting wizard step to configuration")

        config := &amp;ConfigurationExport{
                Version:     "1.0",
                ExportedAt:  time.Now(),
                ExportedBy:  wizardStep.UserID,
                ConfigType:  "wizard",
                WizardStep:  wizardStep,
                Description: "Configuration generated from installation wizard",
                Tags:        []string{"wizard", "generated"},
        }

        // Convert wizard step to full localization
        localization := &amp;UserLocalization{
                UserID:                wizardStep.UserID,
                PrimaryLanguage:       wizardStep.PrimaryLanguage,
                SecondaryLanguages:    wizardStep.SecondaryLanguages,
                SubtitleLanguages:     wizardStep.SubtitleLanguages,
                LyricsLanguages:       wizardStep.LyricsLanguages,
                MetadataLanguages:     wizardStep.MetadataLanguages,
                AutoTranslate:         wizardStep.AutoTranslate,
                AutoDownloadSubtitles: wizardStep.AutoDownloadSubtitles,
                AutoDownloadLyrics:    wizardStep.AutoDownloadLyrics,
                PreferredRegion:       wizardStep.PreferredRegion,
                DateFormat:            wizardStep.DateFormat,
                TimeFormat:            wizardStep.TimeFormat,
                NumberFormat:          wizardStep.NumberFormat,
                CurrencyCode:          wizardStep.CurrencyCode,
                CreatedAt:             time.Now(),
                UpdatedAt:             time.Now(),
        }

        config.Localization = localization

        return config, nil
}</span>

// Helper methods for configuration management

func (s *LocalizationService) convertLocalizationToWizardStep(localization *UserLocalization) *WizardLocalizationStep <span class="cov0" title="0">{
        return &amp;WizardLocalizationStep{
                UserID:                localization.UserID,
                PrimaryLanguage:       localization.PrimaryLanguage,
                SecondaryLanguages:    localization.SecondaryLanguages,
                SubtitleLanguages:     localization.SubtitleLanguages,
                LyricsLanguages:       localization.LyricsLanguages,
                MetadataLanguages:     localization.MetadataLanguages,
                AutoTranslate:         localization.AutoTranslate,
                AutoDownloadSubtitles: localization.AutoDownloadSubtitles,
                AutoDownloadLyrics:    localization.AutoDownloadLyrics,
                PreferredRegion:       localization.PreferredRegion,
                DateFormat:            localization.DateFormat,
                TimeFormat:            localization.TimeFormat,
                NumberFormat:          localization.NumberFormat,
                CurrencyCode:          localization.CurrencyCode,
        }
}</span>

func (s *LocalizationService) getMediaPlayerConfig(ctx context.Context, userID int64) (*MediaPlayerConfig, error) <span class="cov0" title="0">{
        // This would typically fetch from a user_media_settings table
        // For now, return default settings
        return &amp;MediaPlayerConfig{
                DefaultQuality:    "high",
                AutoPlay:          true,
                CrossfadeEnabled:  true,
                CrossfadeDuration: 3000,
                EqualizerPreset:   "flat",
                EqualizerBands:    make(map[string]float64),
                RepeatMode:        "none",
                ShuffleEnabled:    false,
                VolumeLevel:       1.0,
                ReplayGainEnabled: true,
        }, nil
}</span>

func (s *LocalizationService) getPlaylistConfig(ctx context.Context, userID int64) (*PlaylistConfig, error) <span class="cov0" title="0">{
        // This would typically fetch from a user_playlist_settings table
        // For now, return default settings
        return &amp;PlaylistConfig{
                AutoCreatePlaylists:  true,
                SmartPlaylistRules:   []string{"recently_played", "top_rated"},
                DefaultPlaylistType:  "standard",
                CollaborativeDefault: false,
                PublicDefault:        false,
        }, nil
}</span>

func (s *LocalizationService) validateConfiguration(config *ConfigurationExport) []string <span class="cov0" title="0">{
        var errors []string

        // Validate version
        if config.Version == "" </span><span class="cov0" title="0">{
                errors = append(errors, "Configuration version is required")
        }</span>

        // Validate config type
        <span class="cov0" title="0">validTypes := []string{"full", "localization", "media", "playlists", "wizard"}
        typeValid := false
        for _, validType := range validTypes </span><span class="cov0" title="0">{
                if config.ConfigType == validType </span><span class="cov0" title="0">{
                        typeValid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !typeValid </span><span class="cov0" title="0">{
                errors = append(errors, fmt.Sprintf("Invalid config type: %s", config.ConfigType))
        }</span>

        // Validate localization settings
        <span class="cov0" title="0">if config.Localization != nil </span><span class="cov0" title="0">{
                if config.Localization.PrimaryLanguage == "" </span><span class="cov0" title="0">{
                        errors = append(errors, "Primary language is required")
                }</span> else<span class="cov0" title="0"> if _, exists := SupportedLanguages[config.Localization.PrimaryLanguage]; !exists </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("Unsupported primary language: %s", config.Localization.PrimaryLanguage))
                }</span>

                // Validate secondary languages
                <span class="cov0" title="0">for _, lang := range config.Localization.SecondaryLanguages </span><span class="cov0" title="0">{
                        if _, exists := SupportedLanguages[lang]; !exists </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Sprintf("Unsupported secondary language: %s", lang))
                        }</span>
                }

                // Validate date/time formats
                <span class="cov0" title="0">validDateFormats := []string{"MM/DD/YYYY", "DD/MM/YYYY", "YYYY-MM-DD"}
                dateFormatValid := false
                for _, format := range validDateFormats </span><span class="cov0" title="0">{
                        if config.Localization.DateFormat == format </span><span class="cov0" title="0">{
                                dateFormatValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !dateFormatValid </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("Invalid date format: %s", config.Localization.DateFormat))
                }</span>

                <span class="cov0" title="0">validTimeFormats := []string{"12h", "24h"}
                timeFormatValid := false
                for _, format := range validTimeFormats </span><span class="cov0" title="0">{
                        if config.Localization.TimeFormat == format </span><span class="cov0" title="0">{
                                timeFormatValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !timeFormatValid </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("Invalid time format: %s", config.Localization.TimeFormat))
                }</span>
        }

        // Validate media settings
        <span class="cov0" title="0">if config.MediaSettings != nil </span><span class="cov0" title="0">{
                validQualities := []string{"low", "medium", "high", "lossless"}
                qualityValid := false
                for _, quality := range validQualities </span><span class="cov0" title="0">{
                        if config.MediaSettings.DefaultQuality == quality </span><span class="cov0" title="0">{
                                qualityValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !qualityValid </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("Invalid default quality: %s", config.MediaSettings.DefaultQuality))
                }</span>

                <span class="cov0" title="0">if config.MediaSettings.VolumeLevel &lt; 0 || config.MediaSettings.VolumeLevel &gt; 1 </span><span class="cov0" title="0">{
                        errors = append(errors, "Volume level must be between 0 and 1")
                }</span>

                <span class="cov0" title="0">if config.MediaSettings.CrossfadeDuration &lt; 0 || config.MediaSettings.CrossfadeDuration &gt; 10000 </span><span class="cov0" title="0">{
                        errors = append(errors, "Crossfade duration must be between 0 and 10000ms")
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

func (s *LocalizationService) importLocalizationSettings(ctx context.Context, userID int64, localization *UserLocalization) error <span class="cov0" title="0">{
        updates := map[string]interface{}{
                "primary_language":        localization.PrimaryLanguage,
                "secondary_languages":     localization.SecondaryLanguages,
                "subtitle_languages":      localization.SubtitleLanguages,
                "lyrics_languages":        localization.LyricsLanguages,
                "metadata_languages":      localization.MetadataLanguages,
                "auto_translate":          localization.AutoTranslate,
                "auto_download_subtitles": localization.AutoDownloadSubtitles,
                "auto_download_lyrics":    localization.AutoDownloadLyrics,
                "preferred_region":        localization.PreferredRegion,
                "date_format":             localization.DateFormat,
                "time_format":             localization.TimeFormat,
                "number_format":           localization.NumberFormat,
                "currency_code":           localization.CurrencyCode,
        }

        return s.UpdateUserLocalization(ctx, userID, updates)
}</span>

func (s *LocalizationService) importWizardStepSettings(ctx context.Context, userID int64, wizardStep *WizardLocalizationStep) error <span class="cov0" title="0">{
        wizardStep.UserID = userID
        _, err := s.SetupUserLocalization(ctx, wizardStep)
        return err
}</span>

func (s *LocalizationService) importMediaSettings(ctx context.Context, userID int64, mediaSettings *MediaPlayerConfig) error <span class="cov0" title="0">{
        // This would typically save to user_media_settings table
        s.logger.Info("Media settings imported", zap.Int64("user_id", userID))
        return nil
}</span>

func (s *LocalizationService) importPlaylistSettings(ctx context.Context, userID int64, playlistSettings *PlaylistConfig) error <span class="cov0" title="0">{
        // This would typically save to user_playlist_settings table
        s.logger.Info("Playlist settings imported", zap.Int64("user_id", userID))
        return nil
}</span>

func (s *LocalizationService) storeConfigurationExport(ctx context.Context, export *ConfigurationExport) error <span class="cov0" title="0">{
        exportJSON, err := json.Marshal(export)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO configuration_exports (user_id, config_type, config_data, description, tags, created_at)
                VALUES ($1, $2, $3, $4, $5, NOW())
        `

        tagsJSON, _ := json.Marshal(export.Tags)
        _, err = s.db.ExecContext(ctx, query, export.ExportedBy, export.ConfigType, string(exportJSON), export.Description, string(tagsJSON))
        return err</span>
}

func (s *LocalizationService) logImportActivity(ctx context.Context, userID int64, config *ConfigurationExport, result *ConfigurationImportResult) error <span class="cov0" title="0">{
        activityJSON, err := json.Marshal(map[string]interface{}{
                "config_version":    config.Version,
                "config_type":       config.ConfigType,
                "original_user":     config.ExportedBy,
                "applied_settings":  result.AppliedSettings,
                "skipped_settings":  result.SkippedSettings,
                "validation_errors": result.ValidationErrors,
                "backup_created":    result.BackupCreated,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO configuration_import_log (user_id, import_data, success, created_at)
                VALUES ($1, $2, $3, NOW())
        `

        _, err = s.db.ExecContext(ctx, query, userID, string(activityJSON), result.Success)
        return err</span>
}

func (s *LocalizationService) applyConfigurationEdit(config *ConfigurationExport, path string, value interface{}) error <span class="cov0" title="0">{
        parts := strings.Split(path, ".")

        switch parts[0] </span>{
        case "localization":<span class="cov0" title="0">
                if config.Localization == nil </span><span class="cov0" title="0">{
                        config.Localization = &amp;UserLocalization{}
                }</span>
                <span class="cov0" title="0">return s.applyLocalizationEdit(config.Localization, parts[1:], value)</span>
        case "wizard_step":<span class="cov0" title="0">
                if config.WizardStep == nil </span><span class="cov0" title="0">{
                        config.WizardStep = &amp;WizardLocalizationStep{}
                }</span>
                <span class="cov0" title="0">return s.applyWizardStepEdit(config.WizardStep, parts[1:], value)</span>
        case "media_settings":<span class="cov0" title="0">
                if config.MediaSettings == nil </span><span class="cov0" title="0">{
                        config.MediaSettings = &amp;MediaPlayerConfig{}
                }</span>
                <span class="cov0" title="0">return s.applyMediaSettingsEdit(config.MediaSettings, parts[1:], value)</span>
        case "playlist_settings":<span class="cov0" title="0">
                if config.PlaylistSettings == nil </span><span class="cov0" title="0">{
                        config.PlaylistSettings = &amp;PlaylistConfig{}
                }</span>
                <span class="cov0" title="0">return s.applyPlaylistSettingsEdit(config.PlaylistSettings, parts[1:], value)</span>
        case "description":<span class="cov0" title="0">
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        config.Description = str
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("description must be a string")</span>
        case "tags":<span class="cov0" title="0">
                if tags, ok := value.([]interface{}); ok </span><span class="cov0" title="0">{
                        stringTags := make([]string, len(tags))
                        for i, tag := range tags </span><span class="cov0" title="0">{
                                if str, ok := tag.(string); ok </span><span class="cov0" title="0">{
                                        stringTags[i] = str
                                }</span> else<span class="cov0" title="0"> {
                                        return fmt.Errorf("all tags must be strings")
                                }</span>
                        }
                        <span class="cov0" title="0">config.Tags = stringTags
                        return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("tags must be an array of strings")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown configuration path: %s", parts[0])</span>
        }
}

func (s *LocalizationService) applyLocalizationEdit(localization *UserLocalization, parts []string, value interface{}) error <span class="cov0" title="0">{
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid localization path")
        }</span>

        <span class="cov0" title="0">switch parts[0] </span>{
        case "primary_language":<span class="cov0" title="0">
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        localization.PrimaryLanguage = str
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("primary_language must be a string")</span>
        case "auto_translate":<span class="cov0" title="0">
                if b, ok := value.(bool); ok </span><span class="cov0" title="0">{
                        localization.AutoTranslate = b
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("auto_translate must be a boolean")</span>
        case "preferred_region":<span class="cov0" title="0">
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        localization.PreferredRegion = str
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("preferred_region must be a string")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown localization field: %s", parts[0])</span>
        }
}

func (s *LocalizationService) applyWizardStepEdit(wizardStep *WizardLocalizationStep, parts []string, value interface{}) error <span class="cov0" title="0">{
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid wizard step path")
        }</span>

        <span class="cov0" title="0">switch parts[0] </span>{
        case "primary_language":<span class="cov0" title="0">
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        wizardStep.PrimaryLanguage = str
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("primary_language must be a string")</span>
        case "auto_translate":<span class="cov0" title="0">
                if b, ok := value.(bool); ok </span><span class="cov0" title="0">{
                        wizardStep.AutoTranslate = b
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("auto_translate must be a boolean")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown wizard step field: %s", parts[0])</span>
        }
}

func (s *LocalizationService) applyMediaSettingsEdit(mediaSettings *MediaPlayerConfig, parts []string, value interface{}) error <span class="cov0" title="0">{
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid media settings path")
        }</span>

        <span class="cov0" title="0">switch parts[0] </span>{
        case "default_quality":<span class="cov0" title="0">
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        mediaSettings.DefaultQuality = str
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("default_quality must be a string")</span>
        case "volume_level":<span class="cov0" title="0">
                if f, ok := value.(float64); ok </span><span class="cov0" title="0">{
                        mediaSettings.VolumeLevel = f
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("volume_level must be a number")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown media settings field: %s", parts[0])</span>
        }
}

func (s *LocalizationService) applyPlaylistSettingsEdit(playlistSettings *PlaylistConfig, parts []string, value interface{}) error <span class="cov0" title="0">{
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid playlist settings path")
        }</span>

        <span class="cov0" title="0">switch parts[0] </span>{
        case "auto_create_playlists":<span class="cov0" title="0">
                if b, ok := value.(bool); ok </span><span class="cov0" title="0">{
                        playlistSettings.AutoCreatePlaylists = b
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("auto_create_playlists must be a boolean")</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown playlist settings field: %s", parts[0])</span>
        }
}

func (s *LocalizationService) getDefaultLocalizationTemplate() *UserLocalization <span class="cov0" title="0">{
        return &amp;UserLocalization{
                PrimaryLanguage:       "en",
                SecondaryLanguages:    []string{},
                SubtitleLanguages:     []string{"en"},
                LyricsLanguages:       []string{"en"},
                MetadataLanguages:     []string{"en"},
                AutoTranslate:         false,
                AutoDownloadSubtitles: true,
                AutoDownloadLyrics:    true,
                PreferredRegion:       "US",
                DateFormat:            "MM/DD/YYYY",
                TimeFormat:            "12h",
                NumberFormat:          "en-US",
                CurrencyCode:          "USD",
        }
}</span>

func (s *LocalizationService) getDefaultWizardStepTemplate() *WizardLocalizationStep <span class="cov0" title="0">{
        return &amp;WizardLocalizationStep{
                PrimaryLanguage:       "en",
                SecondaryLanguages:    []string{},
                SubtitleLanguages:     []string{"en"},
                LyricsLanguages:       []string{"en"},
                MetadataLanguages:     []string{"en"},
                AutoTranslate:         false,
                AutoDownloadSubtitles: true,
                AutoDownloadLyrics:    true,
                PreferredRegion:       "US",
                DateFormat:            "MM/DD/YYYY",
                TimeFormat:            "12h",
                NumberFormat:          "en-US",
                CurrencyCode:          "USD",
        }
}</span>

func (s *LocalizationService) getDefaultMediaSettingsTemplate() *MediaPlayerConfig <span class="cov0" title="0">{
        return &amp;MediaPlayerConfig{
                DefaultQuality:    "high",
                AutoPlay:          true,
                CrossfadeEnabled:  false,
                CrossfadeDuration: 3000,
                EqualizerPreset:   "flat",
                EqualizerBands:    make(map[string]float64),
                RepeatMode:        "none",
                ShuffleEnabled:    false,
                VolumeLevel:       1.0,
                ReplayGainEnabled: false,
        }
}</span>

func (s *LocalizationService) getDefaultPlaylistSettingsTemplate() *PlaylistConfig <span class="cov0" title="0">{
        return &amp;PlaylistConfig{
                AutoCreatePlaylists:  false,
                SmartPlaylistRules:   []string{},
                DefaultPlaylistType:  "standard",
                CollaborativeDefault: false,
                PublicDefault:        false,
        }
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "catalogizer/utils"
        "go.uber.org/zap"
)

// LyricsService handles lyrics retrieval, synchronization, and caching
type LyricsService struct {
        db                 *sql.DB
        logger             *zap.Logger
        translationService *TranslationService
        httpClient         *http.Client
        apiKeys            map[string]string
        cacheDir           string
}

// LyricsProvider represents different lyrics providers
type LyricsProvider string

const (
        LyricsProviderGenius     LyricsProvider = "genius"
        LyricsProviderMusixmatch LyricsProvider = "musixmatch"
        LyricsProviderAZLyrics   LyricsProvider = "azlyrics"
        LyricsProviderLyricFind  LyricsProvider = "lyricfind"
        LyricsProviderSongLyrics LyricsProvider = "songlyrics"
        LyricsProviderEmbedded   LyricsProvider = "embedded"
)

// LyricsSearchRequest represents a lyrics search request
type LyricsSearchRequest struct {
        Title      string           `json:"title"`
        Artist     string           `json:"artist"`
        Album      *string          `json:"album,omitempty"`
        Duration   *float64         `json:"duration,omitempty"`
        Languages  []string         `json:"languages,omitempty"`
        Providers  []LyricsProvider `json:"providers,omitempty"`
        SyncedOnly bool             `json:"synced_only"`
        UseCache   bool             `json:"use_cache"`
}

// LyricsSearchResult represents a lyrics search result
type LyricsSearchResult struct {
        ID           string         `json:"id"`
        Provider     LyricsProvider `json:"provider"`
        Title        string         `json:"title"`
        Artist       string         `json:"artist"`
        Album        *string        `json:"album,omitempty"`
        Language     string         `json:"language"`
        LanguageCode string         `json:"language_code"`
        Content      string         `json:"content"`
        IsSynced     bool           `json:"is_synced"`
        SyncData     []LyricsLine   `json:"sync_data,omitempty"`
        Source       string         `json:"source"`
        Confidence   float64        `json:"confidence"`
        MatchScore   float64        `json:"match_score"`
        URL          *string        `json:"url,omitempty"`
        Copyright    *string        `json:"copyright,omitempty"`
        Writer       []string       `json:"writer,omitempty"`
        Publisher    *string        `json:"publisher,omitempty"`
}

// LyricsDownloadRequest represents a lyrics download request
type LyricsDownloadRequest struct {
        MediaItemID   int64    `json:"media_item_id"`
        ResultID      string   `json:"result_id"`
        Language      string   `json:"language"`
        AutoTranslate []string `json:"auto_translate,omitempty"`
        UseForConcert bool     `json:"use_for_concert"` // For concert videos
}

// LyricsTranslationRequest represents a lyrics translation request
type LyricsTranslationRequest struct {
        LyricsID       string `json:"lyrics_id"`
        SourceLanguage string `json:"source_language"`
        TargetLanguage string `json:"target_language"`
        PreserveTiming bool   `json:"preserve_timing"`
        UseCache       bool   `json:"use_cache"`
}

// LyricsSyncRequest represents a request to synchronize lyrics with audio
type LyricsSyncRequest struct {
        MediaItemID int64   `json:"media_item_id"`
        LyricsID    string  `json:"lyrics_id"`
        AudioPath   string  `json:"audio_path"`
        Method      string  `json:"method"` // "auto", "manual", "ai"
        Offset      float64 `json:"offset"` // Manual offset in seconds
}

// ConcertLyricsRequest represents a request to get lyrics for concert videos
type ConcertLyricsRequest struct {
        MediaItemID int64    `json:"media_item_id"`
        SetList     []string `json:"set_list,omitempty"` // List of songs if known
        Artist      string   `json:"artist"`
        VenueDate   *string  `json:"venue_date,omitempty"`
        Venue       *string  `json:"venue,omitempty"`
}

// SyncedLyricsLine represents a single line of synchronized lyrics
type SyncedLyricsLine struct {
        StartTime  float64  `json:"start_time"`
        EndTime    *float64 `json:"end_time,omitempty"`
        Text       string   `json:"text"`
        Type       string   `json:"type"` // "verse", "chorus", "bridge", "instrumental"
        Confidence float64  `json:"confidence"`
}

// NewLyricsService creates a new lyrics service
func NewLyricsService(db *sql.DB, logger *zap.Logger) *LyricsService <span class="cov0" title="0">{
        return &amp;LyricsService{
                db:                 db,
                logger:             logger,
                translationService: NewTranslationService(logger),
                httpClient:         &amp;http.Client{Timeout: 30 * time.Second},
                apiKeys:            make(map[string]string),
                cacheDir:           "./cache/lyrics",
        }
}</span>

// SearchLyrics searches for lyrics across multiple providers
func (s *LyricsService) SearchLyrics(ctx context.Context, request *LyricsSearchRequest) ([]LyricsSearchResult, error) <span class="cov0" title="0">{
        s.logger.Info("Searching lyrics",
                zap.String("title", request.Title),
                zap.String("artist", request.Artist))

        // Check cache first if requested
        if request.UseCache </span><span class="cov0" title="0">{
                if cached := s.getCachedLyrics(ctx, request.Title, request.Artist); cached != nil </span><span class="cov0" title="0">{
                        return []LyricsSearchResult{*cached}, nil
                }</span>
        }

        <span class="cov0" title="0">var allResults []LyricsSearchResult

        // Default providers if none specified
        providers := request.Providers
        if len(providers) == 0 </span><span class="cov0" title="0">{
                providers = []LyricsProvider{
                        LyricsProviderGenius,
                        LyricsProviderMusixmatch,
                        LyricsProviderAZLyrics,
                }
        }</span>

        // Search each provider
        <span class="cov0" title="0">for _, provider := range providers </span><span class="cov0" title="0">{
                results, err := s.searchProvider(ctx, provider, request)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Provider search failed",
                                zap.String("provider", string(provider)),
                                zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">allResults = append(allResults, results...)</span>
        }

        // Filter synced only if requested
        <span class="cov0" title="0">if request.SyncedOnly </span><span class="cov0" title="0">{
                allResults = s.filterSyncedLyrics(allResults)
        }</span>

        // Sort by match score and confidence
        <span class="cov0" title="0">s.sortLyricsResults(allResults)

        s.logger.Info("Lyrics search completed",
                zap.Int("total_results", len(allResults)))

        return allResults, nil</span>
}

// DownloadLyrics downloads and caches lyrics
func (s *LyricsService) DownloadLyrics(ctx context.Context, request *LyricsDownloadRequest) (*LyricsData, error) <span class="cov0" title="0">{
        s.logger.Info("Downloading lyrics",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("result_id", request.ResultID))

        // Get download info
        result, err := s.getLyricsDownloadInfo(ctx, request.ResultID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get download info: %w", err)
        }</span>

        // Create lyrics data
        <span class="cov0" title="0">lyricsData := &amp;LyricsData{
                ID:          generateLyricsID(),
                MediaItemID: request.MediaItemID,
                Source:      string(result.Provider),
                Language:    result.Language,
                Content:     result.Content,
                IsSynced:    result.IsSynced,
                SyncData:    result.SyncData,
                CreatedAt:   time.Now(),
                CachedAt:    timePtr(time.Now()),
        }

        // Save to database
        if err := s.saveLyricsData(ctx, lyricsData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save lyrics: %w", err)
        }</span>

        // Auto-translate if requested
        <span class="cov0" title="0">if len(request.AutoTranslate) &gt; 0 </span><span class="cov0" title="0">{
                go s.autoTranslateLyrics(ctx, lyricsData, request.AutoTranslate)
        }</span>

        <span class="cov0" title="0">return lyricsData, nil</span>
}

// TranslateLyrics translates lyrics to another language
func (s *LyricsService) TranslateLyrics(ctx context.Context, request *LyricsTranslationRequest) (*LyricsData, error) <span class="cov0" title="0">{
        s.logger.Info("Translating lyrics",
                zap.String("lyrics_id", request.LyricsID),
                zap.String("target_language", request.TargetLanguage))

        // Check cache first
        if request.UseCache </span><span class="cov0" title="0">{
                if cached := s.getCachedTranslation(ctx, request.LyricsID, request.TargetLanguage); cached != nil </span><span class="cov0" title="0">{
                        return cached, nil
                }</span>
        }

        // Get original lyrics
        <span class="cov0" title="0">original, err := s.getLyricsData(ctx, request.LyricsID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get original lyrics: %w", err)
        }</span>

        // Translate content
        <span class="cov0" title="0">translatedContent, err := s.translationService.TranslateText(ctx, TranslationRequest{
                Text:           original.Content,
                SourceLanguage: request.SourceLanguage,
                TargetLanguage: request.TargetLanguage,
                Context:        "lyrics",
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to translate lyrics: %w", err)
        }</span>

        // Create translated lyrics
        <span class="cov0" title="0">translatedLyrics := &amp;LyricsData{
                ID:          generateLyricsID(),
                MediaItemID: original.MediaItemID,
                Source:      "translated",
                Language:    getLanguageName(request.TargetLanguage),
                Content:     translatedContent.TranslatedText,
                IsSynced:    original.IsSynced &amp;&amp; request.PreserveTiming,
                CreatedAt:   time.Now(),
                CachedAt:    timePtr(time.Now()),
        }

        // Preserve timing if requested and available
        if request.PreserveTiming &amp;&amp; original.IsSynced </span><span class="cov0" title="0">{
                translatedLyrics.SyncData = s.preserveLyricsTiming(original.SyncData, translatedContent.TranslatedText)
        }</span>

        // Save translation
        <span class="cov0" title="0">if err := s.saveCachedLyricsTranslation(ctx, request.LyricsID, request.TargetLanguage, translatedLyrics); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to cache lyrics translation", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return translatedLyrics, nil</span>
}

// SynchronizeLyrics synchronizes lyrics with audio timing
func (s *LyricsService) SynchronizeLyrics(ctx context.Context, request *LyricsSyncRequest) (*LyricsData, error) <span class="cov0" title="0">{
        s.logger.Info("Synchronizing lyrics",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("method", request.Method))

        // Get existing lyrics
        lyrics, err := s.getLyricsData(ctx, request.LyricsID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get lyrics: %w", err)
        }</span>

        <span class="cov0" title="0">var syncData []LyricsLine

        switch request.Method </span>{
        case "auto":<span class="cov0" title="0">
                syncData, err = s.autoSynchronizeLyrics(ctx, lyrics, request.AudioPath)</span>
        case "manual":<span class="cov0" title="0">
                syncData, err = s.manualSynchronizeLyrics(ctx, lyrics, request.Offset)</span>
        case "ai":<span class="cov0" title="0">
                syncData, err = s.aiSynchronizeLyrics(ctx, lyrics, request.AudioPath)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported synchronization method: %s", request.Method)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to synchronize lyrics: %w", err)
        }</span>

        // Update lyrics with sync data
        <span class="cov0" title="0">lyrics.IsSynced = true
        lyrics.SyncData = syncData

        // Save updated lyrics
        if err := s.saveLyricsData(ctx, lyrics); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save synchronized lyrics: %w", err)
        }</span>

        <span class="cov0" title="0">return lyrics, nil</span>
}

// GetConcertLyrics gets lyrics for concert videos with setlist support
func (s *LyricsService) GetConcertLyrics(ctx context.Context, request *ConcertLyricsRequest) ([]*LyricsData, error) <span class="cov0" title="0">{
        s.logger.Info("Getting concert lyrics",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("artist", request.Artist))

        var concertLyrics []*LyricsData

        // If setlist is provided, get lyrics for each song
        if len(request.SetList) &gt; 0 </span><span class="cov0" title="0">{
                for _, song := range request.SetList </span><span class="cov0" title="0">{
                        lyricsSearch := &amp;LyricsSearchRequest{
                                Title:     song,
                                Artist:    request.Artist,
                                Languages: []string{"en"}, // Default to English, could be configurable
                                UseCache:  true,
                        }

                        results, err := s.SearchLyrics(ctx, lyricsSearch)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to find lyrics for concert song",
                                        zap.String("song", song),
                                        zap.Error(err))
                                continue</span>
                        }

                        <span class="cov0" title="0">if len(results) &gt; 0 </span><span class="cov0" title="0">{
                                // Take the best match
                                downloadReq := &amp;LyricsDownloadRequest{
                                        MediaItemID:   request.MediaItemID,
                                        ResultID:      results[0].ID,
                                        Language:      results[0].Language,
                                        UseForConcert: true,
                                }

                                lyrics, err := s.DownloadLyrics(ctx, downloadReq)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Warn("Failed to download concert lyrics",
                                                zap.String("song", song),
                                                zap.Error(err))
                                        continue</span>
                                }

                                <span class="cov0" title="0">concertLyrics = append(concertLyrics, lyrics)</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // Try to auto-detect setlist from concert metadata or title
                detectedSetlist, err := s.detectConcertSetlist(ctx, request)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to detect concert setlist", zap.Error(err))
                        return concertLyrics, nil
                }</span>

                // Recursively call with detected setlist
                <span class="cov0" title="0">request.SetList = detectedSetlist
                return s.GetConcertLyrics(ctx, request)</span>
        }

        <span class="cov0" title="0">return concertLyrics, nil</span>
}

// GetLyrics returns lyrics for a media item
func (s *LyricsService) GetLyrics(ctx context.Context, mediaItemID int64) (*LyricsData, error) <span class="cov0" title="0">{
        query := `
                SELECT id, media_item_id, source, language, content, is_synced,
                       sync_data, translations, created_at, cached_at
                FROM lyrics_data WHERE media_item_id = ?
                ORDER BY created_at DESC LIMIT 1`

        var lyrics LyricsData
        var syncDataJSON, translationsJSON sql.NullString
        var cachedAt sql.NullTime

        err := s.db.QueryRowContext(ctx, query, mediaItemID).Scan(
                &amp;lyrics.ID, &amp;lyrics.MediaItemID, &amp;lyrics.Source, &amp;lyrics.Language,
                &amp;lyrics.Content, &amp;lyrics.IsSynced, &amp;syncDataJSON, &amp;translationsJSON,
                &amp;lyrics.CreatedAt, &amp;cachedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil // No lyrics found
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get lyrics: %w", err)</span>
        }

        <span class="cov0" title="0">if cachedAt.Valid </span><span class="cov0" title="0">{
                lyrics.CachedAt = &amp;cachedAt.Time
        }</span>

        // Parse sync data
        <span class="cov0" title="0">if syncDataJSON.Valid &amp;&amp; syncDataJSON.String != "" </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(syncDataJSON.String), &amp;lyrics.SyncData); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to parse sync data", zap.Error(err))
                }</span>
        }

        // Parse translations
        <span class="cov0" title="0">if translationsJSON.Valid &amp;&amp; translationsJSON.String != "" </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(translationsJSON.String), &amp;lyrics.Translations); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to parse translations", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return &amp;lyrics, nil</span>
}

// Provider-specific implementations
func (s *LyricsService) searchProvider(ctx context.Context, provider LyricsProvider, request *LyricsSearchRequest) ([]LyricsSearchResult, error) <span class="cov0" title="0">{
        switch provider </span>{
        case LyricsProviderGenius:<span class="cov0" title="0">
                return s.searchGenius(ctx, request)</span>
        case LyricsProviderMusixmatch:<span class="cov0" title="0">
                return s.searchMusixmatch(ctx, request)</span>
        case LyricsProviderAZLyrics:<span class="cov0" title="0">
                return s.searchAZLyrics(ctx, request)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported provider: %s", provider)</span>
        }
}

func (s *LyricsService) searchGenius(ctx context.Context, request *LyricsSearchRequest) ([]LyricsSearchResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Searching Genius",
                zap.String("title", request.Title),
                zap.String("artist", request.Artist))

        // Mock implementation for demonstration
        result := LyricsSearchResult{
                ID:           "genius_1",
                Provider:     LyricsProviderGenius,
                Title:        request.Title,
                Artist:       request.Artist,
                Language:     "English",
                LanguageCode: "en",
                Content:      generateSampleLyrics(request.Title, request.Artist),
                IsSynced:     false,
                Source:       "genius.com",
                Confidence:   0.95,
                MatchScore:   0.9,
                URL:          utils.StringPtr("https://genius.com/sample"),
        }

        return []LyricsSearchResult{result}, nil
}</span>

func (s *LyricsService) searchMusixmatch(ctx context.Context, request *LyricsSearchRequest) ([]LyricsSearchResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Searching Musixmatch")

        // Mock synced lyrics
        syncData := []LyricsLine{
                {StartTime: 0.0, EndTime: floatPtr(3.5), Text: "Verse 1 line 1"},
                {StartTime: 3.5, EndTime: floatPtr(7.0), Text: "Verse 1 line 2"},
                {StartTime: 7.0, EndTime: floatPtr(10.5), Text: "Chorus line 1"},
                {StartTime: 10.5, EndTime: floatPtr(14.0), Text: "Chorus line 2"},
        }

        result := LyricsSearchResult{
                ID:           "musixmatch_1",
                Provider:     LyricsProviderMusixmatch,
                Title:        request.Title,
                Artist:       request.Artist,
                Language:     "English",
                LanguageCode: "en",
                Content:      generateSampleLyrics(request.Title, request.Artist),
                IsSynced:     true,
                SyncData:     syncData,
                Source:       "musixmatch.com",
                Confidence:   0.88,
                MatchScore:   0.85,
        }

        return []LyricsSearchResult{result}, nil
}</span>

func (s *LyricsService) searchAZLyrics(ctx context.Context, request *LyricsSearchRequest) ([]LyricsSearchResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Searching AZLyrics")
        return []LyricsSearchResult{}, nil
}</span>

// Synchronization methods
func (s *LyricsService) autoSynchronizeLyrics(ctx context.Context, lyrics *LyricsData, audioPath string) ([]LyricsLine, error) <span class="cov0" title="0">{
        // Implementation would use audio analysis to automatically sync lyrics
        // This is a complex process involving:
        // 1. Audio feature extraction
        // 2. Text-to-speech alignment
        // 3. Machine learning models for timing prediction

        s.logger.Debug("Auto-synchronizing lyrics", zap.String("audio_path", audioPath))

        // Mock implementation
        lines := s.parseLyricsLines(lyrics.Content)
        duration := 180.0 // Mock 3-minute song

        var syncData []LyricsLine
        timePerLine := duration / float64(len(lines))

        for i, line := range lines </span><span class="cov0" title="0">{
                startTime := float64(i) * timePerLine
                endTime := startTime + timePerLine

                syncData = append(syncData, LyricsLine{
                        StartTime: startTime,
                        EndTime:   &amp;endTime,
                        Text:      line,
                })
        }</span>

        <span class="cov0" title="0">return syncData, nil</span>
}

func (s *LyricsService) manualSynchronizeLyrics(ctx context.Context, lyrics *LyricsData, offset float64) ([]LyricsLine, error) <span class="cov0" title="0">{
        // Apply manual offset to existing sync data
        if !lyrics.IsSynced || len(lyrics.SyncData) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("lyrics not synchronized")
        }</span>

        <span class="cov0" title="0">var syncData []LyricsLine
        for _, line := range lyrics.SyncData </span><span class="cov0" title="0">{
                newLine := line
                newLine.StartTime += offset
                if newLine.EndTime != nil </span><span class="cov0" title="0">{
                        newEndTime := *newLine.EndTime + offset
                        newLine.EndTime = &amp;newEndTime
                }</span>
                <span class="cov0" title="0">syncData = append(syncData, newLine)</span>
        }

        <span class="cov0" title="0">return syncData, nil</span>
}

func (s *LyricsService) aiSynchronizeLyrics(ctx context.Context, lyrics *LyricsData, audioPath string) ([]LyricsLine, error) <span class="cov0" title="0">{
        // AI-powered synchronization using speech recognition and NLP
        s.logger.Debug("AI-synchronizing lyrics")

        // This would involve:
        // 1. Speech-to-text on the audio
        // 2. Text alignment algorithms
        // 3. AI models trained on synchronized lyrics

        return s.autoSynchronizeLyrics(ctx, lyrics, audioPath) // Fallback for now
}</span>

// Helper functions
func (s *LyricsService) parseLyricsLines(content string) []string <span class="cov0" title="0">{
        lines := strings.Split(content, "\n")
        var result []string

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line != "" &amp;&amp; !strings.HasPrefix(line, "[") </span><span class="cov0" title="0">{ // Skip structure markers
                        result = append(result, line)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func (s *LyricsService) filterSyncedLyrics(results []LyricsSearchResult) []LyricsSearchResult <span class="cov0" title="0">{
        var synced []LyricsSearchResult
        for _, result := range results </span><span class="cov0" title="0">{
                if result.IsSynced </span><span class="cov0" title="0">{
                        synced = append(synced, result)
                }</span>
        }
        <span class="cov0" title="0">return synced</span>
}

func (s *LyricsService) sortLyricsResults(results []LyricsSearchResult) <span class="cov0" title="0">{
        // Sort by match score, then by confidence
        for i := 0; i &lt; len(results)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(results); j++ </span><span class="cov0" title="0">{
                        if results[i].MatchScore &lt; results[j].MatchScore ||
                                (results[i].MatchScore == results[j].MatchScore &amp;&amp; results[i].Confidence &lt; results[j].Confidence) </span><span class="cov0" title="0">{
                                results[i], results[j] = results[j], results[i]
                        }</span>
                }
        }
}

func generateSampleLyrics(title, artist string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`[Verse 1]
Sample lyrics for "%s" by %s
This is a demonstration of lyrics content
With multiple lines and verses

[Chorus]
This is the chorus section
It repeats throughout the song
Making it memorable and catchy

[Verse 2]
Another verse with different content
Continuing the story or theme
Building on the first verse

[Chorus]
This is the chorus section
It repeats throughout the song
Making it memorable and catchy

[Bridge]
A bridge section with different melody
Providing contrast to verses and chorus
Leading back to the final chorus

[Chorus]
This is the chorus section
It repeats throughout the song
Making it memorable and catchy`, title, artist)
}</span>

func generateLyricsID() string <span class="cov0" title="0">{
        return fmt.Sprintf("lyrics_%d", time.Now().UnixNano())
}</span>

func timePtr(t time.Time) *time.Time <span class="cov0" title="0">{
        return &amp;t
}</span>

func floatPtr(f float64) *float64 <span class="cov0" title="0">{
        return &amp;f
}</span>

// getCachedLyrics retrieves cached lyrics for a title and artist
func (s *LyricsService) getCachedLyrics(ctx context.Context, title, artist string) *LyricsSearchResult <span class="cov0" title="0">{
        // Implementation would check cache for existing lyrics
        // For now, return nil (cache miss)
        return nil
}</span>

// getLyricsDownloadInfo retrieves download information for a lyrics result
func (s *LyricsService) getLyricsDownloadInfo(ctx context.Context, resultID string) (*LyricsSearchResult, error) <span class="cov0" title="0">{
        // Mock implementation - would normally fetch from provider
        return &amp;LyricsSearchResult{
                ID:           resultID,
                Provider:     LyricsProviderGenius,
                Title:        "Sample Title",
                Artist:       "Sample Artist",
                Language:     "English",
                LanguageCode: "en",
                Content:      "Sample lyrics content",
                IsSynced:     false,
                Source:       "genius.com",
                Confidence:   0.9,
                MatchScore:   0.85,
        }, nil
}</span>

// saveLyricsData saves lyrics data to the database
func (s *LyricsService) saveLyricsData(ctx context.Context, lyrics *LyricsData) error <span class="cov0" title="0">{
        syncDataJSON, err := json.Marshal(lyrics.SyncData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal sync data: %w", err)
        }</span>

        <span class="cov0" title="0">translationsJSON, err := json.Marshal(lyrics.Translations)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal translations: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO lyrics_data (id, media_item_id, source, language, content, is_synced, sync_data, translations, created_at, cached_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(id) DO UPDATE SET
                        content = excluded.content,
                        is_synced = excluded.is_synced,
                        sync_data = excluded.sync_data,
                        translations = excluded.translations,
                        cached_at = excluded.cached_at
        `

        var cachedAt interface{}
        if lyrics.CachedAt != nil </span><span class="cov0" title="0">{
                cachedAt = *lyrics.CachedAt
        }</span>

        <span class="cov0" title="0">_, err = s.db.ExecContext(ctx, query,
                lyrics.ID, lyrics.MediaItemID, lyrics.Source, lyrics.Language,
                lyrics.Content, lyrics.IsSynced, string(syncDataJSON), string(translationsJSON),
                lyrics.CreatedAt, cachedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save lyrics data: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// autoTranslateLyrics automatically translates lyrics to multiple languages
func (s *LyricsService) autoTranslateLyrics(ctx context.Context, lyrics *LyricsData, targetLanguages []string) <span class="cov0" title="0">{
        for _, targetLang := range targetLanguages </span><span class="cov0" title="0">{
                req := &amp;LyricsTranslationRequest{
                        LyricsID:       lyrics.ID,
                        SourceLanguage: lyrics.Language,
                        TargetLanguage: targetLang,
                        PreserveTiming: lyrics.IsSynced,
                        UseCache:       true,
                }

                _, err := s.TranslateLyrics(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to auto-translate lyrics",
                                zap.String("target_language", targetLang),
                                zap.Error(err))
                }</span>
        }
}

// getCachedTranslation retrieves a cached translation of lyrics
func (s *LyricsService) getCachedTranslation(ctx context.Context, lyricsID, targetLanguage string) *LyricsData <span class="cov0" title="0">{
        // Implementation would check cache for translated lyrics
        // For now, return nil (cache miss)
        return nil
}</span>

// getLyricsData retrieves lyrics data by ID
func (s *LyricsService) getLyricsData(ctx context.Context, lyricsID string) (*LyricsData, error) <span class="cov0" title="0">{
        query := `
                SELECT id, media_item_id, source, language, content, is_synced,
                       sync_data, translations, created_at, cached_at
                FROM lyrics_data WHERE id = ?
        `

        var lyrics LyricsData
        var syncDataJSON, translationsJSON sql.NullString
        var cachedAt sql.NullTime

        err := s.db.QueryRowContext(ctx, query, lyricsID).Scan(
                &amp;lyrics.ID, &amp;lyrics.MediaItemID, &amp;lyrics.Source, &amp;lyrics.Language,
                &amp;lyrics.Content, &amp;lyrics.IsSynced, &amp;syncDataJSON, &amp;translationsJSON,
                &amp;lyrics.CreatedAt, &amp;cachedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("lyrics not found: %s", lyricsID)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get lyrics data: %w", err)</span>
        }

        <span class="cov0" title="0">if cachedAt.Valid </span><span class="cov0" title="0">{
                lyrics.CachedAt = &amp;cachedAt.Time
        }</span>

        // Parse sync data
        <span class="cov0" title="0">if syncDataJSON.Valid &amp;&amp; syncDataJSON.String != "" </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(syncDataJSON.String), &amp;lyrics.SyncData); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to parse sync data", zap.Error(err))
                }</span>
        }

        // Parse translations
        <span class="cov0" title="0">if translationsJSON.Valid &amp;&amp; translationsJSON.String != "" </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(translationsJSON.String), &amp;lyrics.Translations); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to parse translations", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return &amp;lyrics, nil</span>
}

// saveCachedLyricsTranslation saves a cached translation of lyrics
func (s *LyricsService) saveCachedLyricsTranslation(ctx context.Context, originalID, targetLanguage string, translation *LyricsData) error <span class="cov0" title="0">{
        // Save the translation to database
        return s.saveLyricsData(ctx, translation)
}</span>

// preserveLyricsTiming preserves timing information when translating lyrics
func (s *LyricsService) preserveLyricsTiming(originalSyncData []LyricsLine, translatedText string) []LyricsLine <span class="cov0" title="0">{
        // Parse translated text into lines
        translatedLines := s.parseLyricsLines(translatedText)

        // If line counts don't match, we can't preserve timing perfectly
        if len(translatedLines) != len(originalSyncData) </span><span class="cov0" title="0">{
                s.logger.Warn("Translated lyrics line count mismatch",
                        zap.Int("original", len(originalSyncData)),
                        zap.Int("translated", len(translatedLines)))

                // Return best-effort sync data
                var syncData []LyricsLine
                minLen := len(originalSyncData)
                if len(translatedLines) &lt; minLen </span><span class="cov0" title="0">{
                        minLen = len(translatedLines)
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; minLen; i++ </span><span class="cov0" title="0">{
                        syncData = append(syncData, LyricsLine{
                                StartTime: originalSyncData[i].StartTime,
                                EndTime:   originalSyncData[i].EndTime,
                                Text:      translatedLines[i],
                        })
                }</span>
                <span class="cov0" title="0">return syncData</span>
        }

        // Create new sync data with preserved timing
        <span class="cov0" title="0">var syncData []LyricsLine
        for i, line := range originalSyncData </span><span class="cov0" title="0">{
                syncData = append(syncData, LyricsLine{
                        StartTime: line.StartTime,
                        EndTime:   line.EndTime,
                        Text:      translatedLines[i],
                })
        }</span>

        <span class="cov0" title="0">return syncData</span>
}

// detectConcertSetlist attempts to detect the setlist from concert metadata
func (s *LyricsService) detectConcertSetlist(ctx context.Context, request *ConcertLyricsRequest) ([]string, error) <span class="cov0" title="0">{
        // Implementation would analyze concert metadata, title, description
        // to extract song list. This could involve:
        // 1. Parsing video description
        // 2. Using AI/NLP to extract song names
        // 3. Querying setlist databases (setlist.fm, etc.)

        s.logger.Debug("Detecting concert setlist",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("artist", request.Artist))

        // Mock implementation - return empty list
        return []string{}, nil
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package services

import (
        "context"
        "database/sql"
        "fmt"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "go.uber.org/zap"
)

// MediaPlayerService handles all media playback functionality
type MediaPlayerService struct {
        db                 *sql.DB
        logger             *zap.Logger
        lyricsService      *LyricsService
        subtitleService    *SubtitleService
        coverArtService    *CoverArtService
        translationService *TranslationService
        positionTracker    *PlaybackPositionService
        playlistService    *PlaylistService
}

// MediaItem represents a media file with all its metadata
type MediaItem struct {
        ID        int64     `json:"id" db:"id"`
        Path      string    `json:"path" db:"path"`
        Filename  string    `json:"filename" db:"filename"`
        Title     string    `json:"title" db:"title"`
        MediaType MediaType `json:"media_type" db:"media_type"`
        MimeType  string    `json:"mime_type" db:"mime_type"`
        Size      int64     `json:"size" db:"size"`
        Duration  *float64  `json:"duration,omitempty" db:"duration"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
        UpdatedAt time.Time `json:"updated_at" db:"updated_at"`

        // Music-specific metadata
        Artist      *string `json:"artist,omitempty" db:"artist"`
        Album       *string `json:"album,omitempty" db:"album"`
        AlbumArtist *string `json:"album_artist,omitempty" db:"album_artist"`
        Genre       *string `json:"genre,omitempty" db:"genre"`
        Year        *int    `json:"year,omitempty" db:"year"`
        TrackNumber *int    `json:"track_number,omitempty" db:"track_number"`
        DiscNumber  *int    `json:"disc_number,omitempty" db:"disc_number"`

        // Video-specific metadata
        VideoCodec *string  `json:"video_codec,omitempty" db:"video_codec"`
        AudioCodec *string  `json:"audio_codec,omitempty" db:"audio_codec"`
        Resolution *string  `json:"resolution,omitempty" db:"resolution"`
        Framerate  *float64 `json:"framerate,omitempty" db:"framerate"`
        Bitrate    *int64   `json:"bitrate,omitempty" db:"bitrate"`

        // TV Show/Series metadata
        SeriesTitle  *string `json:"series_title,omitempty" db:"series_title"`
        Season       *int    `json:"season,omitempty" db:"season"`
        Episode      *int    `json:"episode,omitempty" db:"episode"`
        EpisodeTitle *string `json:"episode_title,omitempty" db:"episode_title"`

        // Additional metadata
        Description *string         `json:"description,omitempty" db:"description"`
        Language    *string         `json:"language,omitempty" db:"language"`
        Subtitles   []SubtitleTrack `json:"subtitles,omitempty"`
        CoverArt    *CoverArt       `json:"cover_art,omitempty"`
        Lyrics      *LyricsData     `json:"lyrics,omitempty"`
        Chapters    []Chapter       `json:"chapters,omitempty"`

        // Playback metadata
        LastPosition *float64   `json:"last_position,omitempty" db:"last_position"`
        PlayCount    int        `json:"play_count" db:"play_count"`
        LastPlayed   *time.Time `json:"last_played,omitempty" db:"last_played"`
        IsFavorite   bool       `json:"is_favorite" db:"is_favorite"`
        Rating       *int       `json:"rating,omitempty" db:"rating"` // 1-5 stars

        // Cached external data
        ExternalData map[string]interface{} `json:"external_data,omitempty"`
}

// PlaybackSession represents an active playback session
type PlaybackSession struct {
        ID              string        `json:"id"`
        UserID          string        `json:"user_id"`
        MediaItem       *MediaItem    `json:"media_item"`
        PlaylistID      *string       `json:"playlist_id,omitempty"`
        CurrentPosition float64       `json:"current_position"`
        State           PlaybackState `json:"state"`
        Volume          float64       `json:"volume"`
        PlaybackRate    float64       `json:"playback_rate"`
        RepeatMode      RepeatMode    `json:"repeat_mode"`
        ShuffleEnabled  bool          `json:"shuffle_enabled"`
        StartedAt       time.Time     `json:"started_at"`
        UpdatedAt       time.Time     `json:"updated_at"`

        // Current subtitle and audio tracks
        CurrentSubtitle *SubtitleTrack `json:"current_subtitle,omitempty"`
        CurrentAudio    *AudioTrack    `json:"current_audio,omitempty"`

        // Player-specific settings
        PlayerSettings map[string]interface{} `json:"player_settings,omitempty"`
}

// SubtitleTrack represents a subtitle track
type SubtitleTrack struct {
        ID           string    `json:"id"`
        Language     string    `json:"language"`
        LanguageCode string    `json:"language_code"`
        Source       string    `json:"source"` // "embedded", "external", "downloaded"
        Format       string    `json:"format"` // "srt", "vtt", "ass", etc.
        Path         *string   `json:"path,omitempty"`
        Content      *string   `json:"content,omitempty"`
        IsDefault    bool      `json:"is_default"`
        IsForced     bool      `json:"is_forced"`
        Encoding     string    `json:"encoding"`
        SyncOffset   float64   `json:"sync_offset"` // Milliseconds offset for sync adjustment
        CreatedAt    time.Time `json:"created_at"`
        VerifiedSync bool      `json:"verified_sync"` // Whether sync has been verified
}

// AudioTrack represents an audio track
type AudioTrack struct {
        ID         string  `json:"id"`
        Language   string  `json:"language"`
        Codec      string  `json:"codec"`
        Channels   int     `json:"channels"`
        Bitrate    *int64  `json:"bitrate,omitempty"`
        SampleRate *int    `json:"sample_rate,omitempty"`
        IsDefault  bool    `json:"is_default"`
        Title      *string `json:"title,omitempty"`
}

// Chapter represents a chapter or bookmark in media
type Chapter struct {
        ID        string   `json:"id"`
        Title     string   `json:"title"`
        StartTime float64  `json:"start_time"`
        EndTime   *float64 `json:"end_time,omitempty"`
        Thumbnail *string  `json:"thumbnail,omitempty"`
}

// CoverArt represents cover art metadata
type CoverArt struct {
        ID          string     `json:"id"`
        MediaItemID int64      `json:"media_item_id"`
        Source      string     `json:"source"` // "embedded", "local", "musicbrainz", "lastfm", etc.
        URL         *string    `json:"url,omitempty"`
        LocalPath   *string    `json:"local_path,omitempty"`
        Width       *int       `json:"width,omitempty"`
        Height      *int       `json:"height,omitempty"`
        Format      string     `json:"format"` // "jpeg", "png", "webp"
        Size        *int64     `json:"size,omitempty"`
        Quality     string     `json:"quality"` // "thumbnail", "medium", "high", "original"
        CreatedAt   time.Time  `json:"created_at"`
        CachedAt    *time.Time `json:"cached_at,omitempty"`
}

// LyricsData represents lyrics information
type LyricsData struct {
        ID           string            `json:"id"`
        MediaItemID  int64             `json:"media_item_id"`
        Source       string            `json:"source"` // "embedded", "genius", "musixmatch", etc.
        Language     string            `json:"language"`
        Content      string            `json:"content"`
        IsSynced     bool              `json:"is_synced"`
        SyncData     []LyricsLine      `json:"sync_data,omitempty"`
        Translations map[string]string `json:"translations,omitempty"` // language_code -&gt; translated content
        CreatedAt    time.Time         `json:"created_at"`
        CachedAt     *time.Time        `json:"cached_at,omitempty"`
}

// LyricsLine represents a synchronized lyrics line
type LyricsLine struct {
        StartTime float64  `json:"start_time"`
        EndTime   *float64 `json:"end_time,omitempty"`
        Text      string   `json:"text"`
}

// PlaybackRequest represents a request to start playback
type PlaybackRequest struct {
        MediaItemID    int64                  `json:"media_item_id"`
        PlaylistID     *string                `json:"playlist_id,omitempty"`
        StartPosition  *float64               `json:"start_position,omitempty"`
        Volume         *float64               `json:"volume,omitempty"`
        PlaybackRate   *float64               `json:"playback_rate,omitempty"`
        SubtitleLang   *string                `json:"subtitle_lang,omitempty"`
        AudioTrackID   *string                `json:"audio_track_id,omitempty"`
        PlayerSettings map[string]interface{} `json:"player_settings,omitempty"`
}

// PlaybackUpdateRequest represents a request to update playback state
type PlaybackUpdateRequest struct {
        SessionID       string         `json:"session_id"`
        Position        *float64       `json:"position,omitempty"`
        State           *PlaybackState `json:"state,omitempty"`
        Volume          *float64       `json:"volume,omitempty"`
        PlaybackRate    *float64       `json:"playback_rate,omitempty"`
        RepeatMode      *RepeatMode    `json:"repeat_mode,omitempty"`
        ShuffleEnabled  *bool          `json:"shuffle_enabled,omitempty"`
        SubtitleTrackID *string        `json:"subtitle_track_id,omitempty"`
        AudioTrackID    *string        `json:"audio_track_id,omitempty"`
}

// NewMediaPlayerService creates a new media player service
func NewMediaPlayerService(db *sql.DB, logger *zap.Logger) *MediaPlayerService <span class="cov0" title="0">{
        cacheService := NewCacheService(db, logger)
        return &amp;MediaPlayerService{
                db:                 db,
                logger:             logger,
                lyricsService:      NewLyricsService(db, logger),
                subtitleService:    NewSubtitleService(db, logger, cacheService),
                coverArtService:    NewCoverArtService(db, logger),
                translationService: NewTranslationService(logger),
                positionTracker:    NewPlaybackPositionService(db, logger),
                playlistService:    NewPlaylistService(db, logger),
        }
}</span>

// StartPlayback initiates playback of a media item
func (s *MediaPlayerService) StartPlayback(ctx context.Context, userID string, request *PlaybackRequest) (*PlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting playback",
                zap.String("user_id", userID),
                zap.Int64("media_item_id", request.MediaItemID))

        // Get media item
        mediaItem, err := s.GetMediaItem(ctx, request.MediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get media item: %w", err)
        }</span>

        // Create playback session
        <span class="cov0" title="0">defaultZero := 0.0
        defaultOne := 1.0
        session := &amp;PlaybackSession{
                ID:              generateSessionID(),
                UserID:          userID,
                MediaItem:       mediaItem,
                PlaylistID:      request.PlaylistID,
                CurrentPosition: getFloatValue(request.StartPosition, mediaItem.LastPosition, &amp;defaultZero),
                State:           PlaybackStateLoading,
                Volume:          getFloatValue(request.Volume, nil, &amp;defaultOne),
                PlaybackRate:    getFloatValue(request.PlaybackRate, nil, &amp;defaultOne),
                RepeatMode:      RepeatModeOff,
                ShuffleEnabled:  false,
                StartedAt:       time.Now(),
                UpdatedAt:       time.Now(),
                PlayerSettings:  request.PlayerSettings,
        }

        // Load subtitles if video
        if mediaItem.MediaType == MediaTypeVideo </span><span class="cov0" title="0">{
                subtitles, err := s.subtitleService.GetSubtitles(ctx, mediaItem.ID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to load subtitles", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        mediaItem.Subtitles = subtitles
                        // Set default subtitle track
                        if request.SubtitleLang != nil </span><span class="cov0" title="0">{
                                session.CurrentSubtitle = s.findSubtitleByLanguage(subtitles, *request.SubtitleLang)
                        }</span>
                }
        }

        // Load lyrics if music
        <span class="cov0" title="0">if mediaItem.MediaType == MediaTypeMusic </span><span class="cov0" title="0">{
                lyrics, err := s.lyricsService.GetLyrics(ctx, mediaItem.ID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to load lyrics", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        mediaItem.Lyrics = lyrics
                }</span>
        }

        // Load cover art
        <span class="cov0" title="0">coverArt, err := s.coverArtService.GetCoverArt(ctx, mediaItem.ID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load cover art", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                mediaItem.CoverArt = coverArt
        }</span>

        // Save session
        <span class="cov0" title="0">if err := s.savePlaybackSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save playback session: %w", err)
        }</span>

        // Update play count and last played
        <span class="cov0" title="0">go s.updatePlaybackStats(ctx, mediaItem.ID)

        return session, nil</span>
}

// UpdatePlayback updates the playback state
func (s *MediaPlayerService) UpdatePlayback(ctx context.Context, userID string, request *PlaybackUpdateRequest) error <span class="cov0" title="0">{
        s.logger.Debug("Updating playback",
                zap.String("session_id", request.SessionID),
                zap.String("user_id", userID))

        session, err := s.getPlaybackSession(ctx, request.SessionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get playback session: %w", err)
        }</span>

        // Update fields if provided
        <span class="cov0" title="0">if request.Position != nil </span><span class="cov0" title="0">{
                session.CurrentPosition = *request.Position
                // Save position to database for resume functionality
                userIDInt, _ := strconv.ParseInt(userID, 10, 64)
                go s.positionTracker.UpdatePosition(ctx, &amp;UpdatePositionRequest{
                        UserID:      userIDInt,
                        MediaItemID: session.MediaItem.ID,
                        Position:    int64(*request.Position * 1000), // Convert seconds to milliseconds
                        Duration:    0,                               // Duration unknown at this point
                })
        }</span>

        <span class="cov0" title="0">if request.State != nil </span><span class="cov0" title="0">{
                session.State = *request.State
        }</span>

        <span class="cov0" title="0">if request.Volume != nil </span><span class="cov0" title="0">{
                session.Volume = *request.Volume
        }</span>

        <span class="cov0" title="0">if request.PlaybackRate != nil </span><span class="cov0" title="0">{
                session.PlaybackRate = *request.PlaybackRate
        }</span>

        <span class="cov0" title="0">if request.RepeatMode != nil </span><span class="cov0" title="0">{
                session.RepeatMode = *request.RepeatMode
        }</span>

        <span class="cov0" title="0">if request.ShuffleEnabled != nil </span><span class="cov0" title="0">{
                session.ShuffleEnabled = *request.ShuffleEnabled
        }</span>

        // Update subtitle track
        <span class="cov0" title="0">if request.SubtitleTrackID != nil </span><span class="cov0" title="0">{
                session.CurrentSubtitle = s.findSubtitleByID(session.MediaItem.Subtitles, *request.SubtitleTrackID)
        }</span>

        <span class="cov0" title="0">session.UpdatedAt = time.Now()

        // Save updated session
        return s.savePlaybackSession(ctx, session)</span>
}

// GetMediaItem retrieves a media item by ID
func (s *MediaPlayerService) GetMediaItem(ctx context.Context, id int64) (*MediaItem, error) <span class="cov0" title="0">{
        query := `
                SELECT id, path, filename, title, media_type, mime_type, size, duration,
                       artist, album, album_artist, genre, year, track_number, disc_number,
                       video_codec, audio_codec, resolution, framerate, bitrate,
                       series_title, season, episode, episode_title,
                       description, language, last_position, play_count, last_played,
                       is_favorite, rating, created_at, updated_at
                FROM media_items WHERE id = ?`

        var item MediaItem
        var lastPlayed sql.NullTime

        err := s.db.QueryRowContext(ctx, query, id).Scan(
                &amp;item.ID, &amp;item.Path, &amp;item.Filename, &amp;item.Title, &amp;item.MediaType, &amp;item.MimeType,
                &amp;item.Size, &amp;item.Duration, &amp;item.Artist, &amp;item.Album, &amp;item.AlbumArtist,
                &amp;item.Genre, &amp;item.Year, &amp;item.TrackNumber, &amp;item.DiscNumber,
                &amp;item.VideoCodec, &amp;item.AudioCodec, &amp;item.Resolution, &amp;item.Framerate, &amp;item.Bitrate,
                &amp;item.SeriesTitle, &amp;item.Season, &amp;item.Episode, &amp;item.EpisodeTitle,
                &amp;item.Description, &amp;item.Language, &amp;item.LastPosition, &amp;item.PlayCount,
                &amp;lastPlayed, &amp;item.IsFavorite, &amp;item.Rating, &amp;item.CreatedAt, &amp;item.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("media item not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get media item: %w", err)</span>
        }

        <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                item.LastPlayed = &amp;lastPlayed.Time
        }</span>

        <span class="cov0" title="0">return &amp;item, nil</span>
}

// Helper functions
func generateSessionID() string <span class="cov0" title="0">{
        return fmt.Sprintf("session_%d", time.Now().UnixNano())
}</span>

func getFloatValue(values ...*float64) float64 <span class="cov0" title="0">{
        for _, v := range values </span><span class="cov0" title="0">{
                if v != nil </span><span class="cov0" title="0">{
                        return *v
                }</span>
        }
        <span class="cov0" title="0">return 0.0</span>
}

func (s *MediaPlayerService) findSubtitleByLanguage(subtitles []SubtitleTrack, lang string) *SubtitleTrack <span class="cov0" title="0">{
        for _, sub := range subtitles </span><span class="cov0" title="0">{
                if sub.Language == lang || sub.LanguageCode == lang </span><span class="cov0" title="0">{
                        return &amp;sub
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *MediaPlayerService) findSubtitleByID(subtitles []SubtitleTrack, id string) *SubtitleTrack <span class="cov0" title="0">{
        for _, sub := range subtitles </span><span class="cov0" title="0">{
                if sub.ID == id </span><span class="cov0" title="0">{
                        return &amp;sub
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *MediaPlayerService) savePlaybackSession(ctx context.Context, session *PlaybackSession) error <span class="cov0" title="0">{
        // Implementation would save to Redis or database
        // For now, we'll use in-memory storage or database
        s.logger.Debug("Saving playback session", zap.String("session_id", session.ID))
        return nil
}</span>

func (s *MediaPlayerService) getPlaybackSession(ctx context.Context, sessionID, userID string) (*PlaybackSession, error) <span class="cov0" title="0">{
        // Implementation would retrieve from Redis or database
        s.logger.Debug("Getting playback session", zap.String("session_id", sessionID))
        return nil, fmt.Errorf("session not found")
}</span>

func (s *MediaPlayerService) updatePlaybackStats(ctx context.Context, mediaItemID int64) <span class="cov0" title="0">{
        query := `UPDATE media_items SET play_count = play_count + 1, last_played = ? WHERE id = ?`
        _, err := s.db.ExecContext(ctx, query, time.Now(), mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update playback stats", zap.Error(err))
        }</span>
}

// GetSupportedMediaTypes returns all supported media types
func (s *MediaPlayerService) GetSupportedMediaTypes() []MediaType <span class="cov0" title="0">{
        return []MediaType{
                MediaTypeMusic,
                MediaTypeVideo,
                MediaTypeGame,
                MediaTypeSoftware,
                MediaTypeEbook,
                MediaTypeDocument,
        }
}</span>

// GetMediaTypeFromExtension determines media type from file extension
func GetMediaTypeFromExtension(filename string) MediaType <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(filename))

        // Music formats
        musicExts := map[string]bool{
                ".mp3": true, ".flac": true, ".wav": true, ".aac": true, ".ogg": true,
                ".m4a": true, ".wma": true, ".opus": true, ".aiff": true, ".ape": true,
        }

        // Video formats
        videoExts := map[string]bool{
                ".mp4": true, ".mkv": true, ".avi": true, ".mov": true, ".wmv": true,
                ".flv": true, ".webm": true, ".m4v": true, ".3gp": true, ".ts": true,
                ".m2ts": true, ".vob": true, ".ogv": true,
        }

        // Game formats
        gameExts := map[string]bool{
                ".exe": true, ".msi": true, ".deb": true, ".rpm": true, ".dmg": true,
                ".app": true, ".apk": true, ".ipa": true,
        }

        // Document formats
        docExts := map[string]bool{
                ".pdf": true, ".doc": true, ".docx": true, ".txt": true, ".rtf": true,
                ".odt": true, ".pages": true,
        }

        // Ebook formats
        ebookExts := map[string]bool{
                ".epub": true, ".mobi": true, ".azw": true, ".azw3": true, ".fb2": true,
                ".lit": true, ".pdb": true,
        }

        if musicExts[ext] </span><span class="cov0" title="0">{
                return MediaTypeMusic
        }</span> else<span class="cov0" title="0"> if videoExts[ext] </span><span class="cov0" title="0">{
                return MediaTypeVideo
        }</span> else<span class="cov0" title="0"> if gameExts[ext] </span><span class="cov0" title="0">{
                return MediaTypeGame
        }</span> else<span class="cov0" title="0"> if docExts[ext] </span><span class="cov0" title="0">{
                return MediaTypeDocument
        }</span> else<span class="cov0" title="0"> if ebookExts[ext] </span><span class="cov0" title="0">{
                return MediaTypeEbook
        }</span>

        <span class="cov0" title="0">return MediaTypeSoftware</span> // Default fallback
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/internal/models"
        "go.uber.org/zap"
)

type MediaRecognitionService struct {
        db                    *sql.DB
        logger                *zap.Logger
        cacheService          *CacheService
        translationService    *TranslationService
        movieAPIBaseURL       string
        musicAPIBaseURL       string
        bookAPIBaseURL        string
        gameAPIBaseURL        string
        ocrAPIBaseURL         string
        fingerprintAPIBaseURL string
}

// Recognition request structure
type MediaRecognitionRequest struct {
        FilePath    string            `json:"file_path"`
        FileName    string            `json:"file_name"`
        FileSize    int64             `json:"file_size"`
        FileHash    string            `json:"file_hash"`
        MimeType    string            `json:"mime_type"`
        MediaType   MediaType         `json:"media_type,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        AudioSample []byte            `json:"audio_sample,omitempty"`
        VideoSample []byte            `json:"video_sample,omitempty"`
        ImageSample []byte            `json:"image_sample,omitempty"`
        TextSample  string            `json:"text_sample,omitempty"`
        UserHints   map[string]string `json:"user_hints,omitempty"`
        Languages   []string          `json:"languages,omitempty"`
}

// Recognition result structure
type MediaRecognitionResult struct {
        MediaID           string     `json:"media_id"`
        MediaType         MediaType  `json:"media_type"`
        Title             string     `json:"title"`
        OriginalTitle     string     `json:"original_title,omitempty"`
        AlternativeTitles []string   `json:"alternative_titles,omitempty"`
        Description       string     `json:"description"`
        Year              int        `json:"year,omitempty"`
        ReleaseDate       *time.Time `json:"release_date,omitempty"`
        Duration          int64      `json:"duration,omitempty"`
        Genres            []string   `json:"genres,omitempty"`
        Tags              []string   `json:"tags,omitempty"`

        // Movie/TV specific
        Director    string   `json:"director,omitempty"`
        Cast        []Person `json:"cast,omitempty"`
        IMDbID      string   `json:"imdb_id,omitempty"`
        TMDbID      string   `json:"tmdb_id,omitempty"`
        TVDBId      string   `json:"tvdb_id,omitempty"`
        Season      int      `json:"season,omitempty"`
        Episode     int      `json:"episode,omitempty"`
        SeriesTitle string   `json:"series_title,omitempty"`
        Rating      float64  `json:"rating,omitempty"`

        // Music specific
        Artist        string `json:"artist,omitempty"`
        AlbumArtist   string `json:"album_artist,omitempty"`
        Album         string `json:"album,omitempty"`
        TrackNumber   int    `json:"track_number,omitempty"`
        DiscNumber    int    `json:"disc_number,omitempty"`
        MusicBrainzID string `json:"musicbrainz_id,omitempty"`
        SpotifyID     string `json:"spotify_id,omitempty"`
        LastFMID      string `json:"lastfm_id,omitempty"`
        BPM           int    `json:"bpm,omitempty"`
        Key           string `json:"key,omitempty"`

        // Book/Publication specific
        Author    string   `json:"author,omitempty"`
        Authors   []Person `json:"authors,omitempty"`
        Publisher string   `json:"publisher,omitempty"`
        ISBN      string   `json:"isbn,omitempty"`
        ISBN10    string   `json:"isbn10,omitempty"`
        ISBN13    string   `json:"isbn13,omitempty"`
        ISSN      string   `json:"issn,omitempty"`
        DOI       string   `json:"doi,omitempty"`
        Language  string   `json:"language,omitempty"`
        PageCount int      `json:"page_count,omitempty"`
        WordCount int      `json:"word_count,omitempty"`
        Edition   string   `json:"edition,omitempty"`
        Series    string   `json:"series,omitempty"`
        Volume    int      `json:"volume,omitempty"`
        Issue     int      `json:"issue,omitempty"`

        // Game/Software specific
        Developer          string            `json:"developer,omitempty"`
        Publisher_Game     string            `json:"publisher_game,omitempty"`
        Platform           string            `json:"platform,omitempty"`
        Platforms          []string          `json:"platforms,omitempty"`
        Version            string            `json:"version,omitempty"`
        BuildNumber        string            `json:"build_number,omitempty"`
        License            string            `json:"license,omitempty"`
        SystemRequirements map[string]string `json:"system_requirements,omitempty"`
        IGDBId             string            `json:"igdb_id,omitempty"`
        SteamID            string            `json:"steam_id,omitempty"`

        // Cover art and media
        CoverArt    []models.CoverArtResult `json:"cover_art,omitempty"`
        Screenshots []string                `json:"screenshots,omitempty"`
        Trailer     string                  `json:"trailer,omitempty"`
        PreviewURL  string                  `json:"preview_url,omitempty"`

        // Recognition metadata
        Confidence        float64           `json:"confidence"`
        RecognitionMethod string            `json:"recognition_method"`
        APIProvider       string            `json:"api_provider"`
        RecognizedAt      time.Time         `json:"recognized_at"`
        ProcessingTime    int64             `json:"processing_time_ms"`
        Fingerprints      map[string]string `json:"fingerprints,omitempty"`

        // Additional metadata
        ExternalIDs  map[string]string      `json:"external_ids,omitempty"`
        Translations map[string]Translation `json:"translations,omitempty"`
        RelatedMedia []string               `json:"related_media,omitempty"`
        Duplicates   []DuplicateMatch       `json:"duplicates,omitempty"`
}

type Person struct {
        Name        string            `json:"name"`
        Role        string            `json:"role,omitempty"`
        Character   string            `json:"character,omitempty"`
        Biography   string            `json:"biography,omitempty"`
        BirthDate   *time.Time        `json:"birth_date,omitempty"`
        PhotoURL    string            `json:"photo_url,omitempty"`
        ExternalIDs map[string]string `json:"external_ids,omitempty"`
}

type Translation struct {
        Language    string   `json:"language"`
        Title       string   `json:"title"`
        Description string   `json:"description"`
        Genres      []string `json:"genres,omitempty"`
}

type DuplicateMatch struct {
        MediaID    string  `json:"media_id"`
        FilePath   string  `json:"file_path"`
        Similarity float64 `json:"similarity"`
        MatchType  string  `json:"match_type"`
}

// Recognition providers interface
type RecognitionProvider interface {
        RecognizeMedia(ctx context.Context, req *MediaRecognitionRequest) (*MediaRecognitionResult, error)
        GetProviderName() string
        SupportsMediaType(mediaType MediaType) bool
        GetConfidenceThreshold() float64
}

// Audio fingerprinting structure
type AudioFingerprint struct {
        Algorithm  string               `json:"algorithm"`
        Hash       string               `json:"hash"`
        Duration   float64              `json:"duration"`
        SampleRate int                  `json:"sample_rate"`
        Channels   int                  `json:"channels"`
        Features   map[string]float64   `json:"features"`
        Segments   []FingerprintSegment `json:"segments"`
}

type FingerprintSegment struct {
        StartTime float64            `json:"start_time"`
        EndTime   float64            `json:"end_time"`
        Hash      string             `json:"hash"`
        Features  map[string]float64 `json:"features"`
}

// OCR result structure for text recognition
type OCRResult struct {
        Text       string            `json:"text"`
        Confidence float64           `json:"confidence"`
        Language   string            `json:"language"`
        Blocks     []TextBlock       `json:"blocks"`
        Layout     LayoutInfo        `json:"layout"`
        Metadata   map[string]string `json:"metadata"`
}

type TextBlock struct {
        Text        string    `json:"text"`
        Confidence  float64   `json:"confidence"`
        BoundingBox Rectangle `json:"bounding_box"`
        WordCount   int       `json:"word_count"`
        FontInfo    FontInfo  `json:"font_info"`
}

type Rectangle struct {
        X      int `json:"x"`
        Y      int `json:"y"`
        Width  int `json:"width"`
        Height int `json:"height"`
}

type FontInfo struct {
        Family string  `json:"family"`
        Size   float64 `json:"size"`
        Bold   bool    `json:"bold"`
        Italic bool    `json:"italic"`
        Color  string  `json:"color"`
}

type LayoutInfo struct {
        PageCount   int           `json:"page_count"`
        Orientation string        `json:"orientation"`
        TextColumns int           `json:"text_columns"`
        Images      []ImageRegion `json:"images"`
        Tables      []TableRegion `json:"tables"`
}

type ImageRegion struct {
        BoundingBox Rectangle `json:"bounding_box"`
        Caption     string    `json:"caption"`
        Type        string    `json:"type"`
}

type TableRegion struct {
        BoundingBox Rectangle `json:"bounding_box"`
        Rows        int       `json:"rows"`
        Columns     int       `json:"columns"`
        Headers     []string  `json:"headers"`
}

func NewMediaRecognitionService(
        db *sql.DB,
        logger *zap.Logger,
        cacheService *CacheService,
        translationService *TranslationService,
        movieAPIBaseURL string,
        musicAPIBaseURL string,
        bookAPIBaseURL string,
        gameAPIBaseURL string,
        ocrAPIBaseURL string,
        fingerprintAPIBaseURL string,
) *MediaRecognitionService <span class="cov0" title="0">{
        return &amp;MediaRecognitionService{
                db:                    db,
                logger:                logger,
                cacheService:          cacheService,
                translationService:    translationService,
                movieAPIBaseURL:       movieAPIBaseURL,
                musicAPIBaseURL:       musicAPIBaseURL,
                bookAPIBaseURL:        bookAPIBaseURL,
                gameAPIBaseURL:        gameAPIBaseURL,
                ocrAPIBaseURL:         ocrAPIBaseURL,
                fingerprintAPIBaseURL: fingerprintAPIBaseURL,
        }
}</span>

// Main recognition method that orchestrates all providers
func (s *MediaRecognitionService) RecognizeMedia(ctx context.Context, req *MediaRecognitionRequest) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        startTime := time.Now()
        s.logger.Info("Starting media recognition",
                zap.String("file_path", req.FilePath),
                zap.String("mime_type", req.MimeType),
                zap.String("media_type", string(req.MediaType)))

        // Check cache first
        cacheKey := fmt.Sprintf("media_recognition:%s", req.FileHash)
        var result MediaRecognitionResult
        if found, err := s.cacheService.Get(ctx, cacheKey, &amp;result); err == nil &amp;&amp; found </span><span class="cov0" title="0">{
                s.logger.Debug("Found cached recognition result", zap.String("media_id", result.MediaID))
                return &amp;result, nil
        }</span>

        // Determine media type if not provided
        <span class="cov0" title="0">if req.MediaType == "" </span><span class="cov0" title="0">{
                detectedType, confidence := s.detectMediaType(req)
                req.MediaType = detectedType
                s.logger.Debug("Detected media type",
                        zap.String("type", string(detectedType)),
                        zap.Float64("confidence", confidence))
        }</span>

        // Get appropriate recognition providers
        <span class="cov0" title="0">providers := s.getProvidersForMediaType(req.MediaType)
        if len(providers) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no recognition providers available for media type: %s", req.MediaType)
        }</span>

        // Try recognition with multiple providers
        <span class="cov0" title="0">var bestResult *MediaRecognitionResult
        var bestConfidence float64

        for _, provider := range providers </span><span class="cov0" title="0">{
                result, err := provider.RecognizeMedia(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Recognition provider failed",
                                zap.String("provider", provider.GetProviderName()),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if result.Confidence &gt; bestConfidence &amp;&amp; result.Confidence &gt;= provider.GetConfidenceThreshold() </span><span class="cov0" title="0">{
                        bestResult = result
                        bestConfidence = result.Confidence
                }</span>
        }

        <span class="cov0" title="0">if bestResult == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no recognition provider returned confident results")
        }</span>

        // Enhance with additional metadata
        <span class="cov0" title="0">s.enhanceRecognitionResult(ctx, bestResult, req)

        // Check for duplicates
        duplicates, err := s.findDuplicates(ctx, bestResult)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to find duplicates", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                bestResult.Duplicates = duplicates
        }</span>

        // Translate metadata if requested
        <span class="cov0" title="0">if len(req.Languages) &gt; 0 </span><span class="cov0" title="0">{
                translations, err := s.translateMetadata(ctx, bestResult, req.Languages)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to translate metadata", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        bestResult.Translations = translations
                }</span>
        }

        // Set processing metadata
        <span class="cov0" title="0">bestResult.RecognizedAt = time.Now()
        bestResult.ProcessingTime = time.Since(startTime).Milliseconds()

        // Cache the result
        resultJSON, _ := json.Marshal(bestResult)
        s.cacheService.Set(ctx, cacheKey, string(resultJSON), 24*time.Hour)

        // Store in database
        if err := s.storeRecognitionResult(ctx, bestResult, req); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to store recognition result", zap.Error(err))
        }</span>

        <span class="cov0" title="0">s.logger.Info("Media recognition completed",
                zap.String("media_id", bestResult.MediaID),
                zap.String("title", bestResult.Title),
                zap.Float64("confidence", bestResult.Confidence),
                zap.Int64("processing_time_ms", bestResult.ProcessingTime))

        return bestResult, nil</span>
}

// Detect media type from file characteristics
func (s *MediaRecognitionService) detectMediaType(req *MediaRecognitionRequest) (MediaType, float64) <span class="cov0" title="0">{
        // Video file detection
        videoMimes := []string{"video/mp4", "video/avi", "video/mkv", "video/mov", "video/wmv", "video/flv", "video/webm"}
        for _, mime := range videoMimes </span><span class="cov0" title="0">{
                if req.MimeType == mime </span><span class="cov0" title="0">{
                        // Further distinguish between movie types
                        if s.looksLikeTVEpisode(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeTVEpisode, 0.9
                        }</span>
                        <span class="cov0" title="0">if s.looksLikeConcert(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeConcert, 0.8
                        }</span>
                        <span class="cov0" title="0">if s.looksLikeDocumentary(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeDocumentary, 0.8
                        }</span>
                        <span class="cov0" title="0">if s.looksLikeCourse(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeCourse, 0.8
                        }</span>
                        <span class="cov0" title="0">return MediaTypeMovie, 0.7</span>
                }
        }

        // Audio file detection
        <span class="cov0" title="0">audioMimes := []string{"audio/mp3", "audio/wav", "audio/flac", "audio/ogg", "audio/aac", "audio/m4a"}
        for _, mime := range audioMimes </span><span class="cov0" title="0">{
                if req.MimeType == mime </span><span class="cov0" title="0">{
                        if s.looksLikeAudiobook(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeAudiobook, 0.9
                        }</span>
                        <span class="cov0" title="0">if s.looksLikePodcast(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypePodcast, 0.8
                        }</span>
                        <span class="cov0" title="0">return MediaTypeMusic, 0.8</span>
                }
        }

        // Text/Document file detection
        <span class="cov0" title="0">textMimes := []string{"application/pdf", "text/plain", "application/epub+zip", "application/x-mobipocket-ebook"}
        for _, mime := range textMimes </span><span class="cov0" title="0">{
                if req.MimeType == mime </span><span class="cov0" title="0">{
                        if s.looksLikeComicBook(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeComicBook, 0.9
                        }</span>
                        <span class="cov0" title="0">if s.looksLikeMagazine(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeMagazine, 0.8
                        }</span>
                        <span class="cov0" title="0">if s.looksLikeManual(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeManual, 0.8
                        }</span>
                        <span class="cov0" title="0">return MediaTypeBook, 0.7</span>
                }
        }

        // Executable/Software detection
        <span class="cov0" title="0">execMimes := []string{"application/x-executable", "application/x-msdos-program", "application/x-msdownload"}
        for _, mime := range execMimes </span><span class="cov0" title="0">{
                if req.MimeType == mime </span><span class="cov0" title="0">{
                        if s.looksLikeGame(req.FileName) </span><span class="cov0" title="0">{
                                return MediaTypeGame, 0.8
                        }</span>
                        <span class="cov0" title="0">return MediaTypeSoftware, 0.7</span>
                }
        }

        // Default fallback based on file extension
        <span class="cov0" title="0">return s.detectFromFileName(req.FileName), 0.5</span>
}

// Helper methods for media type detection
func (s *MediaRecognitionService) looksLikeTVEpisode(fileName string) bool <span class="cov0" title="0">{
        // Pattern matching for TV episodes (S01E01, 1x01, etc.)
        // Implementation would use regex patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeConcert(fileName string) bool <span class="cov0" title="0">{
        // Look for concert-related keywords
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeDocumentary(fileName string) bool <span class="cov0" title="0">{
        // Look for documentary keywords
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeCourse(fileName string) bool <span class="cov0" title="0">{
        // Look for course/training keywords
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeAudiobook(fileName string) bool <span class="cov0" title="0">{
        // Look for audiobook patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikePodcast(fileName string) bool <span class="cov0" title="0">{
        // Look for podcast patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeComicBook(fileName string) bool <span class="cov0" title="0">{
        // Look for comic book patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeMagazine(fileName string) bool <span class="cov0" title="0">{
        // Look for magazine patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeManual(fileName string) bool <span class="cov0" title="0">{
        // Look for manual/documentation patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) looksLikeGame(fileName string) bool <span class="cov0" title="0">{
        // Look for game-related patterns
        return false // Placeholder
}</span>

func (s *MediaRecognitionService) detectFromFileName(fileName string) MediaType <span class="cov0" title="0">{
        // Fallback detection based on file extension
        return MediaTypeMovie // Placeholder
}</span>

// Get recognition providers for specific media type
func (s *MediaRecognitionService) getProvidersForMediaType(mediaType MediaType) []RecognitionProvider <span class="cov0" title="0">{
        var providers []RecognitionProvider

        switch mediaType </span>{
        case MediaTypeMovie, MediaTypeTVSeries, MediaTypeTVEpisode, MediaTypeConcert, MediaTypeDocumentary:<span class="cov0" title="0">
                providers = append(providers, s.getMovieProviders()...)</span>
        case MediaTypeMusic, MediaTypeAlbum, MediaTypeAudiobook, MediaTypePodcast:<span class="cov0" title="0">
                providers = append(providers, s.getMusicProviders()...)</span>
        case MediaTypeBook, MediaTypeComicBook, MediaTypeMagazine, MediaTypeEbook:<span class="cov0" title="0">
                providers = append(providers, s.getBookProviders()...)</span>
        case MediaTypeGame, MediaTypeSoftware:<span class="cov0" title="0">
                providers = append(providers, s.getGameProviders()...)</span>
        }

        <span class="cov0" title="0">return providers</span>
}

// Provider getter methods (to be implemented)
func (s *MediaRecognitionService) getMovieProviders() []RecognitionProvider <span class="cov0" title="0">{
        return []RecognitionProvider{} // Placeholder
}</span>

func (s *MediaRecognitionService) getMusicProviders() []RecognitionProvider <span class="cov0" title="0">{
        return []RecognitionProvider{} // Placeholder
}</span>

func (s *MediaRecognitionService) getBookProviders() []RecognitionProvider <span class="cov0" title="0">{
        return []RecognitionProvider{} // Placeholder
}</span>

func (s *MediaRecognitionService) getGameProviders() []RecognitionProvider <span class="cov0" title="0">{
        return []RecognitionProvider{} // Placeholder
}</span>

// Enhance recognition result with additional metadata
func (s *MediaRecognitionService) enhanceRecognitionResult(ctx context.Context, result *MediaRecognitionResult, req *MediaRecognitionRequest) <span class="cov0" title="0">{
        // Get additional cover art
        if coverArt, err := s.getAdditionalCoverArt(ctx, result); err == nil </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, coverArt...)
        }</span>

        // Get additional metadata from alternative sources
        <span class="cov0" title="0">if metadata, err := s.getEnhancedMetadata(ctx, result); err == nil </span><span class="cov0" title="0">{
                // Merge additional metadata
                if result.ExternalIDs == nil </span><span class="cov0" title="0">{
                        result.ExternalIDs = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for key, value := range metadata </span><span class="cov0" title="0">{
                        result.ExternalIDs[key] = value
                }</span>
        }
}

// Find duplicate content
func (s *MediaRecognitionService) findDuplicates(ctx context.Context, result *MediaRecognitionResult) ([]DuplicateMatch, error) <span class="cov0" title="0">{
        var duplicates []DuplicateMatch

        // Query database for potential duplicates based on:
        // 1. Exact title match
        // 2. External IDs (IMDb, ISBN, etc.)
        // 3. Fingerprint similarity
        // 4. File hash similarity

        query := `
                SELECT media_id, file_path, title, external_ids, fingerprints
                FROM media_recognition_results
                WHERE (title = ? OR ? IN (SELECT value FROM json_each(external_ids)))
                AND media_id != ?
        `

        rows, err := s.db.QueryContext(ctx, query, result.Title, result.IMDbID, result.MediaID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var mediaID, filePath, title, externalIDsJSON, fingerprintsJSON string
                if err := rows.Scan(&amp;mediaID, &amp;filePath, &amp;title, &amp;externalIDsJSON, &amp;fingerprintsJSON); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">similarity := s.calculateSimilarity(result, title, externalIDsJSON, fingerprintsJSON)
                if similarity &gt; 0.8 </span><span class="cov0" title="0">{ // High similarity threshold
                        duplicates = append(duplicates, DuplicateMatch{
                                MediaID:    mediaID,
                                FilePath:   filePath,
                                Similarity: similarity,
                                MatchType:  s.determineMatchType(similarity),
                        })
                }</span>
        }

        <span class="cov0" title="0">return duplicates, nil</span>
}

// Calculate similarity between media items
func (s *MediaRecognitionService) calculateSimilarity(result *MediaRecognitionResult, title, externalIDsJSON, fingerprintsJSON string) float64 <span class="cov0" title="0">{
        // Implement similarity calculation logic
        // Consider title similarity, external ID matches, fingerprint similarity
        return 0.0 // Placeholder
}</span>

// Determine match type based on similarity score
func (s *MediaRecognitionService) determineMatchType(similarity float64) string <span class="cov0" title="0">{
        if similarity &gt;= 0.95 </span><span class="cov0" title="0">{
                return "exact"
        }</span> else<span class="cov0" title="0"> if similarity &gt;= 0.85 </span><span class="cov0" title="0">{
                return "high"
        }</span> else<span class="cov0" title="0"> if similarity &gt;= 0.8 </span><span class="cov0" title="0">{
                return "medium"
        }</span>
        <span class="cov0" title="0">return "low"</span>
}

// Translate metadata to multiple languages
func (s *MediaRecognitionService) translateMetadata(ctx context.Context, result *MediaRecognitionResult, languages []string) (map[string]Translation, error) <span class="cov0" title="0">{
        translations := make(map[string]Translation)

        for _, lang := range languages </span><span class="cov0" title="0">{
                if lang == result.Language </span><span class="cov0" title="0">{
                        continue</span> // Skip if same as source language
                }

                <span class="cov0" title="0">translation := Translation{Language: lang}

                // Translate title
                if translatedTitle, err := s.translationService.TranslateText(ctx, TranslationRequest{
                        Text:           result.Title,
                        SourceLanguage: result.Language,
                        TargetLanguage: lang,
                }); err == nil </span><span class="cov0" title="0">{
                        translation.Title = translatedTitle.TranslatedText
                }</span>

                // Translate description
                <span class="cov0" title="0">if result.Description != "" </span><span class="cov0" title="0">{
                        if translatedDesc, err := s.translationService.TranslateText(ctx, TranslationRequest{
                                Text:           result.Description,
                                SourceLanguage: result.Language,
                                TargetLanguage: lang,
                        }); err == nil </span><span class="cov0" title="0">{
                                translation.Description = translatedDesc.TranslatedText
                        }</span>
                }

                // Translate genres
                <span class="cov0" title="0">if len(result.Genres) &gt; 0 </span><span class="cov0" title="0">{
                        var translatedGenres []string
                        for _, genre := range result.Genres </span><span class="cov0" title="0">{
                                if translatedGenre, err := s.translationService.TranslateText(ctx, TranslationRequest{
                                        Text:           genre,
                                        SourceLanguage: result.Language,
                                        TargetLanguage: lang,
                                }); err == nil </span><span class="cov0" title="0">{
                                        translatedGenres = append(translatedGenres, translatedGenre.TranslatedText)
                                }</span>
                        }
                        <span class="cov0" title="0">translation.Genres = translatedGenres</span>
                }

                <span class="cov0" title="0">translations[lang] = translation</span>
        }

        <span class="cov0" title="0">return translations, nil</span>
}

// Store recognition result in database
func (s *MediaRecognitionService) storeRecognitionResult(ctx context.Context, result *MediaRecognitionResult, req *MediaRecognitionRequest) error <span class="cov0" title="0">{
        resultJSON, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fingerprintsJSON, _ := json.Marshal(result.Fingerprints)
        externalIDsJSON, _ := json.Marshal(result.ExternalIDs)

        query := `
                INSERT OR REPLACE INTO media_recognition_results (
                        media_id, file_path, file_hash, media_type, title, original_title,
                        description, year, release_date, duration, genres, tags,
                        recognition_data, fingerprints, external_ids, confidence,
                        recognition_method, api_provider, recognized_at, processing_time_ms
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        genresJSON, _ := json.Marshal(result.Genres)
        tagsJSON, _ := json.Marshal(result.Tags)

        _, err = s.db.ExecContext(ctx, query,
                result.MediaID, req.FilePath, req.FileHash, string(result.MediaType),
                result.Title, result.OriginalTitle, result.Description, result.Year,
                result.ReleaseDate, result.Duration, string(genresJSON), string(tagsJSON),
                string(resultJSON), string(fingerprintsJSON), string(externalIDsJSON),
                result.Confidence, result.RecognitionMethod, result.APIProvider,
                result.RecognizedAt, result.ProcessingTime,
        )

        return err</span>
}

// Additional helper methods for enhancement
func (s *MediaRecognitionService) getAdditionalCoverArt(ctx context.Context, result *MediaRecognitionResult) ([]models.CoverArtResult, error) <span class="cov0" title="0">{
        // Implement additional cover art retrieval
        return []models.CoverArtResult{}, nil
}</span>

func (s *MediaRecognitionService) getEnhancedMetadata(ctx context.Context, result *MediaRecognitionResult) (map[string]string, error) <span class="cov0" title="0">{
        // Implement enhanced metadata retrieval
        return make(map[string]string), nil
}</span>

// Batch recognition for multiple files
func (s *MediaRecognitionService) RecognizeMediaBatch(ctx context.Context, requests []*MediaRecognitionRequest) ([]*MediaRecognitionResult, error) <span class="cov0" title="0">{
        results := make([]*MediaRecognitionResult, len(requests))

        for i, req := range requests </span><span class="cov0" title="0">{
                result, err := s.RecognizeMedia(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to recognize media in batch",
                                zap.String("file_path", req.FilePath),
                                zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">results[i] = result</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// Get recognition statistics
func (s *MediaRecognitionService) GetRecognitionStats(ctx context.Context) (map[string]interface{}, error) <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Count by media type
        query := `
                SELECT media_type, COUNT(*) as count, AVG(confidence) as avg_confidence
                FROM media_recognition_results
                GROUP BY media_type
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        typeStats := make(map[string]map[string]interface{})
        for rows.Next() </span><span class="cov0" title="0">{
                var mediaType string
                var count int
                var avgConfidence float64
                if err := rows.Scan(&amp;mediaType, &amp;count, &amp;avgConfidence); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">typeStats[mediaType] = map[string]interface{}{
                        "count":          count,
                        "avg_confidence": avgConfidence,
                }</span>
        }

        <span class="cov0" title="0">stats["by_type"] = typeStats

        // Overall statistics
        totalQuery := `SELECT COUNT(*) FROM media_recognition_results`
        var totalCount int
        s.db.QueryRowContext(ctx, totalQuery).Scan(&amp;totalCount)
        stats["total_recognized"] = totalCount

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "regexp"
        "strconv"
        "strings"
        "time"

        "catalogizer/internal/models"
        "go.uber.org/zap"
)

// Movie/TV recognition provider using free APIs
type MovieRecognitionProvider struct {
        logger      *zap.Logger
        httpClient  *http.Client
        baseURLs    map[string]string
        apiKeys     map[string]string
        rateLimiter map[string]*time.Ticker
}

// External API response structures
type TMDbSearchResponse struct {
        Page         int          `json:"page"`
        Results      []TMDbResult `json:"results"`
        TotalPages   int          `json:"total_pages"`
        TotalResults int          `json:"total_results"`
}

type TMDbResult struct {
        ID               int      `json:"id"`
        Title            string   `json:"title,omitempty"`
        Name             string   `json:"name,omitempty"`
        OriginalTitle    string   `json:"original_title,omitempty"`
        OriginalName     string   `json:"original_name,omitempty"`
        Overview         string   `json:"overview"`
        ReleaseDate      string   `json:"release_date,omitempty"`
        FirstAirDate     string   `json:"first_air_date,omitempty"`
        GenreIDs         []int    `json:"genre_ids"`
        VoteAverage      float64  `json:"vote_average"`
        VoteCount        int      `json:"vote_count"`
        PosterPath       string   `json:"poster_path,omitempty"`
        BackdropPath     string   `json:"backdrop_path,omitempty"`
        Popularity       float64  `json:"popularity"`
        Adult            bool     `json:"adult"`
        Video            bool     `json:"video,omitempty"`
        MediaType        string   `json:"media_type,omitempty"`
        OriginCountry    []string `json:"origin_country,omitempty"`
        OriginalLanguage string   `json:"original_language"`
}

type TMDbMovieDetails struct {
        ID                  int                     `json:"id"`
        Title               string                  `json:"title"`
        OriginalTitle       string                  `json:"original_title"`
        Overview            string                  `json:"overview"`
        ReleaseDate         string                  `json:"release_date"`
        Runtime             int                     `json:"runtime"`
        Genres              []TMDbGenre             `json:"genres"`
        ProductionCompanies []TMDbProductionCompany `json:"production_companies"`
        ProductionCountries []TMDbCountry           `json:"production_countries"`
        SpokenLanguages     []TMDbLanguage          `json:"spoken_languages"`
        VoteAverage         float64                 `json:"vote_average"`
        VoteCount           int                     `json:"vote_count"`
        Popularity          float64                 `json:"popularity"`
        PosterPath          string                  `json:"poster_path"`
        BackdropPath        string                  `json:"backdrop_path"`
        Adult               bool                    `json:"adult"`
        Homepage            string                  `json:"homepage"`
        IMDbID              string                  `json:"imdb_id"`
        Budget              int64                   `json:"budget"`
        Revenue             int64                   `json:"revenue"`
        Status              string                  `json:"status"`
        Tagline             string                  `json:"tagline"`
}

type TMDbTVDetails struct {
        ID                  int                     `json:"id"`
        Name                string                  `json:"name"`
        OriginalName        string                  `json:"original_name"`
        Overview            string                  `json:"overview"`
        FirstAirDate        string                  `json:"first_air_date"`
        LastAirDate         string                  `json:"last_air_date"`
        Genres              []TMDbGenre             `json:"genres"`
        CreatedBy           []TMDbCreator           `json:"created_by"`
        Networks            []TMDbNetwork           `json:"networks"`
        ProductionCompanies []TMDbProductionCompany `json:"production_companies"`
        ProductionCountries []TMDbCountry           `json:"production_countries"`
        SpokenLanguages     []TMDbLanguage          `json:"spoken_languages"`
        VoteAverage         float64                 `json:"vote_average"`
        VoteCount           int                     `json:"vote_count"`
        Popularity          float64                 `json:"popularity"`
        PosterPath          string                  `json:"poster_path"`
        BackdropPath        string                  `json:"backdrop_path"`
        Homepage            string                  `json:"homepage"`
        InProduction        bool                    `json:"in_production"`
        NumberOfEpisodes    int                     `json:"number_of_episodes"`
        NumberOfSeasons     int                     `json:"number_of_seasons"`
        Status              string                  `json:"status"`
        Type                string                  `json:"type"`
        Tagline             string                  `json:"tagline"`
        ExternalIDs         TMDbExternalIDs         `json:"external_ids,omitempty"`
}

type TMDbGenre struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
}

type TMDbProductionCompany struct {
        ID            int    `json:"id"`
        Name          string `json:"name"`
        LogoPath      string `json:"logo_path"`
        OriginCountry string `json:"origin_country"`
}

type TMDbCountry struct {
        ISO31661 string `json:"iso_3166_1"`
        Name     string `json:"name"`
}

type TMDbLanguage struct {
        ISO6391     string `json:"iso_639_1"`
        EnglishName string `json:"english_name"`
        Name        string `json:"name"`
}

type TMDbCreator struct {
        ID          int    `json:"id"`
        Name        string `json:"name"`
        Gender      int    `json:"gender"`
        ProfilePath string `json:"profile_path"`
}

type TMDbNetwork struct {
        ID            int    `json:"id"`
        Name          string `json:"name"`
        LogoPath      string `json:"logo_path"`
        OriginCountry string `json:"origin_country"`
}

type TMDbExternalIDs struct {
        IMDbID      string `json:"imdb_id"`
        TVDBID      int    `json:"tvdb_id"`
        FacebookID  string `json:"facebook_id"`
        InstagramID string `json:"instagram_id"`
        TwitterID   string `json:"twitter_id"`
}

type TMDbCredits struct {
        ID   int              `json:"id"`
        Cast []TMDbCastMember `json:"cast"`
        Crew []TMDbCrewMember `json:"crew"`
}

type TMDbCastMember struct {
        ID          int     `json:"id"`
        Name        string  `json:"name"`
        Character   string  `json:"character"`
        Order       int     `json:"order"`
        Gender      int     `json:"gender"`
        ProfilePath string  `json:"profile_path"`
        CastID      int     `json:"cast_id"`
        CreditID    string  `json:"credit_id"`
        Popularity  float64 `json:"popularity"`
}

type TMDbCrewMember struct {
        ID          int     `json:"id"`
        Name        string  `json:"name"`
        Job         string  `json:"job"`
        Department  string  `json:"department"`
        Gender      int     `json:"gender"`
        ProfilePath string  `json:"profile_path"`
        CreditID    string  `json:"credit_id"`
        Popularity  float64 `json:"popularity"`
}

// OMDb API structures (fallback)
type OMDbResponse struct {
        Title      string       `json:"Title"`
        Year       string       `json:"Year"`
        Rated      string       `json:"Rated"`
        Released   string       `json:"Released"`
        Runtime    string       `json:"Runtime"`
        Genre      string       `json:"Genre"`
        Director   string       `json:"Director"`
        Writer     string       `json:"Writer"`
        Actors     string       `json:"Actors"`
        Plot       string       `json:"Plot"`
        Language   string       `json:"Language"`
        Country    string       `json:"Country"`
        Awards     string       `json:"Awards"`
        Poster     string       `json:"Poster"`
        Ratings    []OMDbRating `json:"Ratings"`
        Metascore  string       `json:"Metascore"`
        IMDbRating string       `json:"imdbRating"`
        IMDbVotes  string       `json:"imdbVotes"`
        IMDbID     string       `json:"imdbID"`
        Type       string       `json:"Type"`
        DVD        string       `json:"DVD,omitempty"`
        BoxOffice  string       `json:"BoxOffice,omitempty"`
        Production string       `json:"Production,omitempty"`
        Website    string       `json:"Website,omitempty"`
        Response   string       `json:"Response"`
        Error      string       `json:"Error,omitempty"`
}

type OMDbRating struct {
        Source string `json:"Source"`
        Value  string `json:"Value"`
}

func NewMovieRecognitionProvider(logger *zap.Logger) *MovieRecognitionProvider <span class="cov0" title="0">{
        return &amp;MovieRecognitionProvider{
                logger:     logger,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                baseURLs: map[string]string{
                        "tmdb": "https://api.themoviedb.org/3",
                        "omdb": "http://www.omdbapi.com",
                        "tvdb": "https://api4.thetvdb.com/v4",
                        "imdb": "https://imdb-api.com",
                },
                apiKeys: map[string]string{
                        "tmdb": "free_api_key", // Using free tier
                        "omdb": "free_api_key", // Using free tier
                },
                rateLimiter: make(map[string]*time.Ticker),
        }
}</span>

func (p *MovieRecognitionProvider) RecognizeMedia(ctx context.Context, req *MediaRecognitionRequest) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        p.logger.Info("Starting movie/TV recognition",
                zap.String("file_path", req.FilePath),
                zap.String("media_type", string(req.MediaType)))

        // Extract title from filename
        title := p.extractTitleFromFilename(req.FileName)
        year := p.extractYearFromFilename(req.FileName)

        // Extract season/episode info for TV shows
        season, episode := p.extractSeasonEpisode(req.FileName)

        p.logger.Debug("Extracted metadata from filename",
                zap.String("title", title),
                zap.Int("year", year),
                zap.Int("season", season),
                zap.Int("episode", episode))

        // Try TMDb first (best free API)
        if result, err := p.searchTMDb(ctx, title, year, req.MediaType, season, episode); err == nil </span><span class="cov0" title="0">{
                p.logger.Info("Successfully recognized via TMDb",
                        zap.String("title", result.Title),
                        zap.Float64("confidence", result.Confidence))
                return result, nil
        }</span>

        // Fallback to OMDb
        <span class="cov0" title="0">if result, err := p.searchOMDb(ctx, title, year, req.MediaType); err == nil </span><span class="cov0" title="0">{
                p.logger.Info("Successfully recognized via OMDb",
                        zap.String("title", result.Title),
                        zap.Float64("confidence", result.Confidence))
                return result, nil
        }</span>

        // Fallback to basic pattern matching
        <span class="cov0" title="0">return p.basicRecognition(req, title, year, season, episode), nil</span>
}

func (p *MovieRecognitionProvider) searchTMDb(ctx context.Context, title string, year int, mediaType MediaType, season, episode int) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Search for the media
        searchURL := fmt.Sprintf("%s/search/multi", p.baseURLs["tmdb"])
        params := url.Values{}
        params.Set("api_key", p.apiKeys["tmdb"])
        params.Set("query", title)
        if year &gt; 0 </span><span class="cov0" title="0">{
                params.Set("year", strconv.Itoa(year))
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", searchURL, params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResp TMDbSearchResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResp.Results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no results found in TMDb")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := searchResp.Results[0]

        // Get detailed information
        if bestMatch.MediaType == "movie" || (bestMatch.Title != "" &amp;&amp; bestMatch.MediaType == "") </span><span class="cov0" title="0">{
                return p.getTMDbMovieDetails(ctx, bestMatch.ID)
        }</span> else<span class="cov0" title="0"> if bestMatch.MediaType == "tv" || bestMatch.Name != "" </span><span class="cov0" title="0">{
                return p.getTMDbTVDetails(ctx, bestMatch.ID, season, episode)
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported media type from TMDb")</span>
}

func (p *MovieRecognitionProvider) getTMDbMovieDetails(ctx context.Context, movieID int) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Get movie details
        detailsURL := fmt.Sprintf("%s/movie/%d", p.baseURLs["tmdb"], movieID)
        params := url.Values{}
        params.Set("api_key", p.apiKeys["tmdb"])
        params.Set("append_to_response", "credits,external_ids,images")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", detailsURL, params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var movie TMDbMovieDetails
        if err := json.NewDecoder(resp.Body).Decode(&amp;movie); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to MediaRecognitionResult
        <span class="cov0" title="0">result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("tmdb_movie_%d", movie.ID),
                MediaType:         MediaTypeMovie,
                Title:             movie.Title,
                OriginalTitle:     movie.OriginalTitle,
                Description:       movie.Overview,
                Year:              p.parseYear(movie.ReleaseDate),
                Duration:          int64(movie.Runtime * 60), // Convert minutes to seconds
                IMDbID:            movie.IMDbID,
                TMDbID:            strconv.Itoa(movie.ID),
                Rating:            movie.VoteAverage,
                Confidence:        p.calculateConfidence(movie.Title, movie.VoteAverage, movie.VoteCount),
                RecognitionMethod: "tmdb_api",
                APIProvider:       "TMDb",
        }

        // Parse release date
        if releaseDate, err := time.Parse("2006-01-02", movie.ReleaseDate); err == nil </span><span class="cov0" title="0">{
                result.ReleaseDate = &amp;releaseDate
        }</span>

        // Extract genres
        <span class="cov0" title="0">for _, genre := range movie.Genres </span><span class="cov0" title="0">{
                result.Genres = append(result.Genres, genre.Name)
        }</span>

        // Get cover art
        <span class="cov0" title="0">if movie.PosterPath != "" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        URL:     fmt.Sprintf("https://image.tmdb.org/t/p/w500%s", movie.PosterPath),
                        Width:   500,
                        Quality: "medium",
                        Source:  "TMDb",
                })
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        URL:     fmt.Sprintf("https://image.tmdb.org/t/p/original%s", movie.PosterPath),
                        Quality: "high",
                        Source:  "TMDb",
                })
        }</span>

        <span class="cov0" title="0">if movie.BackdropPath != "" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        URL:     fmt.Sprintf("https://image.tmdb.org/t/p/w1280%s", movie.BackdropPath),
                        Width:   1280,
                        Quality: "high",
                        Source:  "TMDb",
                })
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "tmdb_id": strconv.Itoa(movie.ID),
        }
        if movie.IMDbID != "" </span><span class="cov0" title="0">{
                result.ExternalIDs["imdb_id"] = movie.IMDbID
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (p *MovieRecognitionProvider) getTMDbTVDetails(ctx context.Context, tvID, season, episode int) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Get TV series details
        detailsURL := fmt.Sprintf("%s/tv/%d", p.baseURLs["tmdb"], tvID)
        params := url.Values{}
        params.Set("api_key", p.apiKeys["tmdb"])
        params.Set("append_to_response", "credits,external_ids,images")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", detailsURL, params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var tv TMDbTVDetails
        if err := json.NewDecoder(resp.Body).Decode(&amp;tv); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine media type
        <span class="cov0" title="0">mediaType := MediaTypeTVSeries
        title := tv.Name
        if season &gt; 0 &amp;&amp; episode &gt; 0 </span><span class="cov0" title="0">{
                mediaType = MediaTypeTVEpisode
                // Try to get episode details
                if episodeDetails, err := p.getTMDbEpisodeDetails(ctx, tvID, season, episode); err == nil </span><span class="cov0" title="0">{
                        title = episodeDetails.Name
                }</span>
        }

        // Convert to MediaRecognitionResult
        <span class="cov0" title="0">result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("tmdb_tv_%d", tv.ID),
                MediaType:         mediaType,
                Title:             title,
                OriginalTitle:     tv.OriginalName,
                SeriesTitle:       tv.Name,
                Description:       tv.Overview,
                Year:              p.parseYear(tv.FirstAirDate),
                Season:            season,
                Episode:           episode,
                TMDbID:            strconv.Itoa(tv.ID),
                Rating:            tv.VoteAverage,
                Confidence:        p.calculateConfidence(tv.Name, tv.VoteAverage, tv.VoteCount),
                RecognitionMethod: "tmdb_api",
                APIProvider:       "TMDb",
        }

        // Parse first air date
        if firstAirDate, err := time.Parse("2006-01-02", tv.FirstAirDate); err == nil </span><span class="cov0" title="0">{
                result.ReleaseDate = &amp;firstAirDate
        }</span>

        // Extract genres
        <span class="cov0" title="0">for _, genre := range tv.Genres </span><span class="cov0" title="0">{
                result.Genres = append(result.Genres, genre.Name)
        }</span>

        // Get cover art
        <span class="cov0" title="0">if tv.PosterPath != "" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        URL:     fmt.Sprintf("https://image.tmdb.org/t/p/w500%s", tv.PosterPath),
                        Width:   500,
                        Quality: "medium",
                        Source:  "TMDb",
                })
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "tmdb_id": strconv.Itoa(tv.ID),
        }
        if tv.ExternalIDs.IMDbID != "" </span><span class="cov0" title="0">{
                result.ExternalIDs["imdb_id"] = tv.ExternalIDs.IMDbID
                result.IMDbID = tv.ExternalIDs.IMDbID
        }</span>
        <span class="cov0" title="0">if tv.ExternalIDs.TVDBID &gt; 0 </span><span class="cov0" title="0">{
                result.ExternalIDs["tvdb_id"] = strconv.Itoa(tv.ExternalIDs.TVDBID)
                result.TVDBId = strconv.Itoa(tv.ExternalIDs.TVDBID)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (p *MovieRecognitionProvider) getTMDbEpisodeDetails(ctx context.Context, tvID, season, episode int) (*TMDbEpisodeDetails, error) <span class="cov0" title="0">{
        detailsURL := fmt.Sprintf("%s/tv/%d/season/%d/episode/%d", p.baseURLs["tmdb"], tvID, season, episode)
        params := url.Values{}
        params.Set("api_key", p.apiKeys["tmdb"])

        resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", detailsURL, params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var episode_details TMDbEpisodeDetails
        if err := json.NewDecoder(resp.Body).Decode(&amp;episode_details); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;episode_details, nil</span>
}

type TMDbEpisodeDetails struct {
        ID            int     `json:"id"`
        Name          string  `json:"name"`
        Overview      string  `json:"overview"`
        AirDate       string  `json:"air_date"`
        EpisodeNumber int     `json:"episode_number"`
        SeasonNumber  int     `json:"season_number"`
        Runtime       int     `json:"runtime"`
        VoteAverage   float64 `json:"vote_average"`
        VoteCount     int     `json:"vote_count"`
        StillPath     string  `json:"still_path"`
}

func (p *MovieRecognitionProvider) searchOMDb(ctx context.Context, title string, year int, mediaType MediaType) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}
        params.Set("apikey", p.apiKeys["omdb"])
        params.Set("t", title)
        if year &gt; 0 </span><span class="cov0" title="0">{
                params.Set("y", strconv.Itoa(year))
        }</span>

        // Set type based on media type
        <span class="cov0" title="0">switch mediaType </span>{
        case MediaTypeMovie, MediaTypeConcert, MediaTypeDocumentary:<span class="cov0" title="0">
                params.Set("type", "movie")</span>
        case MediaTypeTVSeries, MediaTypeTVEpisode:<span class="cov0" title="0">
                params.Set("type", "series")</span>
        }

        <span class="cov0" title="0">resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", p.baseURLs["omdb"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var omdbResp OMDbResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;omdbResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if omdbResp.Response == "False" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OMDb error: %s", omdbResp.Error)
        }</span>

        // Convert OMDb response to MediaRecognitionResult
        <span class="cov0" title="0">result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("omdb_%s", omdbResp.IMDbID),
                MediaType:         p.mapOMDbType(omdbResp.Type),
                Title:             omdbResp.Title,
                Description:       omdbResp.Plot,
                Year:              p.parseYear(omdbResp.Year),
                Director:          omdbResp.Director,
                IMDbID:            omdbResp.IMDbID,
                Confidence:        p.calculateOMDbConfidence(omdbResp.IMDbRating, omdbResp.IMDbVotes),
                RecognitionMethod: "omdb_api",
                APIProvider:       "OMDb",
        }

        // Parse release date
        if releaseDate, err := time.Parse("02 Jan 2006", omdbResp.Released); err == nil </span><span class="cov0" title="0">{
                result.ReleaseDate = &amp;releaseDate
        }</span>

        // Parse genres
        <span class="cov0" title="0">if omdbResp.Genre != "" </span><span class="cov0" title="0">{
                result.Genres = strings.Split(omdbResp.Genre, ", ")
        }</span>

        // Parse runtime
        <span class="cov0" title="0">if runtime := p.parseRuntime(omdbResp.Runtime); runtime &gt; 0 </span><span class="cov0" title="0">{
                result.Duration = runtime
        }</span>

        // Parse rating
        <span class="cov0" title="0">if rating, err := strconv.ParseFloat(omdbResp.IMDbRating, 64); err == nil </span><span class="cov0" title="0">{
                result.Rating = rating
        }</span>

        // Parse cast
        <span class="cov0" title="0">if omdbResp.Actors != "" </span><span class="cov0" title="0">{
                actors := strings.Split(omdbResp.Actors, ", ")
                for _, actor := range actors </span><span class="cov0" title="0">{
                        result.Cast = append(result.Cast, Person{
                                Name: actor,
                                Role: "Actor",
                        })
                }</span>
        }

        // Add cover art
        <span class="cov0" title="0">if omdbResp.Poster != "" &amp;&amp; omdbResp.Poster != "N/A" </span><span class="cov0" title="0">{
                result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                        URL:     omdbResp.Poster,
                        Quality: "medium",
                        Source:  "OMDb",
                })
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "imdb_id": omdbResp.IMDbID,
        }

        return result, nil</span>
}

func (p *MovieRecognitionProvider) basicRecognition(req *MediaRecognitionRequest, title string, year, season, episode int) *MediaRecognitionResult <span class="cov0" title="0">{
        // Basic fallback recognition
        mediaType := req.MediaType
        if mediaType == "" </span><span class="cov0" title="0">{
                if season &gt; 0 &amp;&amp; episode &gt; 0 </span><span class="cov0" title="0">{
                        mediaType = MediaTypeTVEpisode
                }</span> else<span class="cov0" title="0"> if season &gt; 0 </span><span class="cov0" title="0">{
                        mediaType = MediaTypeTVSeries
                }</span> else<span class="cov0" title="0"> {
                        mediaType = MediaTypeMovie
                }</span>
        }

        <span class="cov0" title="0">return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("basic_%s_%d", strings.ReplaceAll(title, " ", "_"), time.Now().Unix()),
                MediaType:         mediaType,
                Title:             title,
                Year:              year,
                Season:            season,
                Episode:           episode,
                Confidence:        0.3, // Low confidence for basic recognition
                RecognitionMethod: "filename_parsing",
                APIProvider:       "basic",
                ExternalIDs:       make(map[string]string),
        }</span>
}

// Helper methods
func (p *MovieRecognitionProvider) extractTitleFromFilename(filename string) string <span class="cov0" title="0">{
        // Remove file extension
        name := strings.TrimSuffix(filename, "."+p.getFileExtension(filename))

        // Remove common patterns
        patterns := []string{
                `\d{4}`,           // Year
                `S\d{2}E\d{2}`,    // Season/Episode
                `\d{1,2}x\d{1,2}`, // Alternative season/episode
                `(?i)(720p|1080p|4k|hdtv|webrip|bluray|dvdrip|cam|ts|r5)`, // Quality
                `(?i)(xvid|x264|h264|h265|hevc)`,                          // Codec
                `(?i)(aac|ac3|dts|mp3)`,                                   // Audio
                `\[.*?\]`,                                                 // Brackets
                `\(.*?\)`,                                                 // Parentheses
        }

        for _, pattern := range patterns </span><span class="cov0" title="0">{
                re := regexp.MustCompile(pattern)
                name = re.ReplaceAllString(name, "")
        }</span>

        // Clean up
        <span class="cov0" title="0">name = regexp.MustCompile(`[._-]+`).ReplaceAllString(name, " ")
        name = regexp.MustCompile(`\s+`).ReplaceAllString(name, " ")
        name = strings.TrimSpace(name)

        return name</span>
}

func (p *MovieRecognitionProvider) extractYearFromFilename(filename string) int <span class="cov0" title="0">{
        re := regexp.MustCompile(`\b(19|20)\d{2}\b`)
        matches := re.FindAllString(filename, -1)

        if len(matches) &gt; 0 </span><span class="cov0" title="0">{
                if year, err := strconv.Atoi(matches[len(matches)-1]); err == nil </span><span class="cov0" title="0">{
                        return year
                }</span>
        }

        <span class="cov0" title="0">return 0</span>
}

func (p *MovieRecognitionProvider) extractSeasonEpisode(filename string) (int, int) <span class="cov0" title="0">{
        // Pattern: S01E01
        re := regexp.MustCompile(`S(\d{1,2})E(\d{1,2})`)
        matches := re.FindStringSubmatch(filename)
        if len(matches) == 3 </span><span class="cov0" title="0">{
                season, _ := strconv.Atoi(matches[1])
                episode, _ := strconv.Atoi(matches[2])
                return season, episode
        }</span>

        // Pattern: 1x01
        <span class="cov0" title="0">re = regexp.MustCompile(`(\d{1,2})x(\d{1,2})`)
        matches = re.FindStringSubmatch(filename)
        if len(matches) == 3 </span><span class="cov0" title="0">{
                season, _ := strconv.Atoi(matches[1])
                episode, _ := strconv.Atoi(matches[2])
                return season, episode
        }</span>

        <span class="cov0" title="0">return 0, 0</span>
}

func (p *MovieRecognitionProvider) getFileExtension(filename string) string <span class="cov0" title="0">{
        parts := strings.Split(filename, ".")
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                return parts[len(parts)-1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (p *MovieRecognitionProvider) parseYear(dateStr string) int <span class="cov0" title="0">{
        if len(dateStr) &gt;= 4 </span><span class="cov0" title="0">{
                if year, err := strconv.Atoi(dateStr[:4]); err == nil </span><span class="cov0" title="0">{
                        return year
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func (p *MovieRecognitionProvider) parseRuntime(runtime string) int64 <span class="cov0" title="0">{
        re := regexp.MustCompile(`(\d+)\s*min`)
        matches := re.FindStringSubmatch(runtime)
        if len(matches) == 2 </span><span class="cov0" title="0">{
                if minutes, err := strconv.Atoi(matches[1]); err == nil </span><span class="cov0" title="0">{
                        return int64(minutes * 60) // Convert to seconds
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func (p *MovieRecognitionProvider) calculateConfidence(title string, rating float64, voteCount int) float64 <span class="cov0" title="0">{
        confidence := 0.5 // Base confidence

        // Boost confidence based on rating and vote count
        if rating &gt; 7.0 &amp;&amp; voteCount &gt; 1000 </span><span class="cov0" title="0">{
                confidence += 0.3
        }</span> else<span class="cov0" title="0"> if rating &gt; 6.0 &amp;&amp; voteCount &gt; 100 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span> else<span class="cov0" title="0"> if voteCount &gt; 50 </span><span class="cov0" title="0">{
                confidence += 0.1
        }</span>

        // Boost confidence if title is not empty
        <span class="cov0" title="0">if title != "" </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">if confidence &gt; 1.0 </span><span class="cov0" title="0">{
                confidence = 1.0
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *MovieRecognitionProvider) calculateOMDbConfidence(rating, votes string) float64 <span class="cov0" title="0">{
        confidence := 0.5

        if r, err := strconv.ParseFloat(rating, 64); err == nil &amp;&amp; r &gt; 6.0 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        // Parse vote count (remove commas)
        <span class="cov0" title="0">cleanVotes := strings.ReplaceAll(votes, ",", "")
        if v, err := strconv.Atoi(cleanVotes); err == nil &amp;&amp; v &gt; 1000 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *MovieRecognitionProvider) mapOMDbType(omdbType string) MediaType <span class="cov0" title="0">{
        switch strings.ToLower(omdbType) </span>{
        case "movie":<span class="cov0" title="0">
                return MediaTypeMovie</span>
        case "series":<span class="cov0" title="0">
                return MediaTypeTVSeries</span>
        case "episode":<span class="cov0" title="0">
                return MediaTypeTVEpisode</span>
        default:<span class="cov0" title="0">
                return MediaTypeMovie</span>
        }
}

// RecognitionProvider interface implementation
func (p *MovieRecognitionProvider) GetProviderName() string <span class="cov0" title="0">{
        return "movie_recognition"
}</span>

func (p *MovieRecognitionProvider) SupportsMediaType(mediaType MediaType) bool <span class="cov0" title="0">{
        supportedTypes := []MediaType{
                MediaTypeMovie,
                MediaTypeTVSeries,
                MediaTypeTVEpisode,
                MediaTypeConcert,
                MediaTypeDocumentary,
                MediaTypeCourse,
                MediaTypeTraining,
        }

        for _, supported := range supportedTypes </span><span class="cov0" title="0">{
                if mediaType == supported </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (p *MovieRecognitionProvider) GetConfidenceThreshold() float64 <span class="cov0" title="0">{
        return 0.4 // Minimum 40% confidence required
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "math/rand"
        "sort"
        "strings"
        "time"

        "go.uber.org/zap"
)

type MusicPlayerService struct {
        db                 *sql.DB
        logger             *zap.Logger
        mediaPlayerService *MediaPlayerService
        playlistService    *PlaylistService
        positionService    *PlaybackPositionService
        lyricsService      *LyricsService
        coverArtService    *CoverArtService
        translationService *TranslationService
}

type MusicPlaybackSession struct {
        ID                string             `json:"id"`
        UserID            int64              `json:"user_id"`
        CurrentTrack      *MusicTrack        `json:"current_track"`
        Queue             []MusicTrack       `json:"queue"`
        QueueIndex        int                `json:"queue_index"`
        PlaylistID        *int64             `json:"playlist_id"`
        PlayMode          PlayMode           `json:"play_mode"`
        RepeatMode        RepeatMode         `json:"repeat_mode"`
        ShuffleEnabled    bool               `json:"shuffle_enabled"`
        ShuffleHistory    []int              `json:"shuffle_history"`
        Volume            float64            `json:"volume"`
        IsMuted           bool               `json:"is_muted"`
        Crossfade         bool               `json:"crossfade"`
        CrossfadeDuration int                `json:"crossfade_duration"`
        EqualizerPreset   string             `json:"equalizer_preset"`
        EqualizerBands    map[string]float64 `json:"equalizer_bands"`
        PlaybackState     PlaybackState      `json:"playback_state"`
        Position          int64              `json:"position"`
        Duration          int64              `json:"duration"`
        BufferedRanges    []BufferedRange    `json:"buffered_ranges"`
        PlaybackQuality   AudioQuality       `json:"playback_quality"`
        DeviceInfo        DeviceInfo         `json:"device_info"`
        LastActivity      time.Time          `json:"last_activity"`
        CreatedAt         time.Time          `json:"created_at"`
        UpdatedAt         time.Time          `json:"updated_at"`
}

type MusicTrack struct {
        ID            int64             `json:"id"`
        Title         string            `json:"title"`
        Artist        string            `json:"artist"`
        Album         string            `json:"album"`
        AlbumArtist   string            `json:"album_artist"`
        Genre         string            `json:"genre"`
        Year          int               `json:"year"`
        TrackNumber   int               `json:"track_number"`
        DiscNumber    int               `json:"disc_number"`
        Duration      int64             `json:"duration"`
        FilePath      string            `json:"file_path"`
        FileSize      int64             `json:"file_size"`
        Format        string            `json:"format"`
        Bitrate       int               `json:"bitrate"`
        SampleRate    int               `json:"sample_rate"`
        Channels      int               `json:"channels"`
        BPM           *int              `json:"bpm"`
        Key           *string           `json:"key"`
        Rating        *int              `json:"rating"`
        PlayCount     int64             `json:"play_count"`
        LastPlayed    *time.Time        `json:"last_played"`
        DateAdded     time.Time         `json:"date_added"`
        CoverArt      *CoverArt         `json:"cover_art"`
        Lyrics        *LyricsData       `json:"lyrics"`
        AudioFeatures *AudioFeatures    `json:"audio_features"`
        Waveform      *WaveformData     `json:"waveform"`
        Tags          map[string]string `json:"tags"`
        ReplayGain    *ReplayGainData   `json:"replay_gain"`
}

type AudioFeatures struct {
        Danceability     float64 `json:"danceability"`
        Energy           float64 `json:"energy"`
        Speechiness      float64 `json:"speechiness"`
        Acousticness     float64 `json:"acousticness"`
        Instrumentalness float64 `json:"instrumentalness"`
        Liveness         float64 `json:"liveness"`
        Valence          float64 `json:"valence"`
        Tempo            float64 `json:"tempo"`
        Loudness         float64 `json:"loudness"`
}

type WaveformData struct {
        ID       int64     `json:"id"`
        TrackID  int64     `json:"track_id"`
        Data     []float64 `json:"data"`
        Duration int64     `json:"duration"`
        Created  time.Time `json:"created"`
}

type ReplayGainData struct {
        TrackGain float64 `json:"track_gain"`
        TrackPeak float64 `json:"track_peak"`
        AlbumGain float64 `json:"album_gain"`
        AlbumPeak float64 `json:"album_peak"`
}

type BufferedRange struct {
        Start int64 `json:"start"`
        End   int64 `json:"end"`
}

type PlayMode string

const (
        PlayModeTrack    PlayMode = "track"
        PlayModeAlbum    PlayMode = "album"
        PlayModeArtist   PlayMode = "artist"
        PlayModePlaylist PlayMode = "playlist"
        PlayModeFolder   PlayMode = "folder"
        PlayModeGenre    PlayMode = "genre"
        PlayModeQueue    PlayMode = "queue"
)

type AudioQuality string

const (
        QualityLossless AudioQuality = "lossless" // FLAC/ALAC
)

type DeviceInfo struct {
        DeviceID   string `json:"device_id"`
        DeviceName string `json:"device_name"`
        DeviceType string `json:"device_type"`
        Platform   string `json:"platform"`
        AppVersion string `json:"app_version"`
}

type MusicLibraryStats struct {
        TotalTracks      int64            `json:"total_tracks"`
        TotalAlbums      int64            `json:"total_albums"`
        TotalArtists     int64            `json:"total_artists"`
        TotalGenres      int64            `json:"total_genres"`
        TotalDuration    int64            `json:"total_duration"`
        TotalSize        int64            `json:"total_size"`
        FormatBreakdown  map[string]int64 `json:"format_breakdown"`
        QualityBreakdown map[string]int64 `json:"quality_breakdown"`
        YearBreakdown    map[int]int64    `json:"year_breakdown"`
        TopGenres        []GenreStats     `json:"top_genres"`
        TopArtists       []ArtistStats    `json:"top_artists"`
        RecentlyAdded    []MusicTrack     `json:"recently_added"`
        MostPlayed       []MusicTrack     `json:"most_played"`
}

type Album struct {
        ID          int64        `json:"id"`
        Title       string       `json:"title"`
        Artist      string       `json:"artist"`
        AlbumArtist string       `json:"album_artist"`
        Year        int          `json:"year"`
        Genre       string       `json:"genre"`
        TrackCount  int          `json:"track_count"`
        Duration    int64        `json:"duration"`
        CoverArt    *CoverArt    `json:"cover_art"`
        Tracks      []MusicTrack `json:"tracks"`
        PlayCount   int64        `json:"play_count"`
        Rating      *int         `json:"rating"`
        DateAdded   time.Time    `json:"date_added"`
        LastPlayed  *time.Time   `json:"last_played"`
}

type Artist struct {
        ID         int64        `json:"id"`
        Name       string       `json:"name"`
        Biography  string       `json:"biography"`
        Country    string       `json:"country"`
        Genres     []string     `json:"genres"`
        Albums     []Album      `json:"albums"`
        TopTracks  []MusicTrack `json:"top_tracks"`
        TrackCount int          `json:"track_count"`
        AlbumCount int          `json:"album_count"`
        PlayCount  int64        `json:"play_count"`
        Followers  int64        `json:"followers"`
        CoverImage *CoverArt    `json:"cover_image"`
        DateAdded  time.Time    `json:"date_added"`
        LastPlayed *time.Time   `json:"last_played"`
}

type PlayTrackRequest struct {
        UserID     int64        `json:"user_id"`
        TrackID    int64        `json:"track_id"`
        PlayMode   PlayMode     `json:"play_mode"`
        StartTime  *int64       `json:"start_time"`
        Quality    AudioQuality `json:"quality"`
        DeviceInfo DeviceInfo   `json:"device_info"`
        PlaylistID *int64       `json:"playlist_id"`
        AlbumID    *int64       `json:"album_id"`
        ArtistID   *int64       `json:"artist_id"`
        FolderPath *string      `json:"folder_path"`
}

type PlayAlbumRequest struct {
        UserID     int64        `json:"user_id"`
        AlbumID    int64        `json:"album_id"`
        StartTrack *int         `json:"start_track"`
        Shuffle    bool         `json:"shuffle"`
        Quality    AudioQuality `json:"quality"`
        DeviceInfo DeviceInfo   `json:"device_info"`
}

type PlayArtistRequest struct {
        UserID     int64        `json:"user_id"`
        ArtistID   int64        `json:"artist_id"`
        Mode       string       `json:"mode"` // "top_tracks", "all_tracks", "albums"
        Shuffle    bool         `json:"shuffle"`
        Quality    AudioQuality `json:"quality"`
        DeviceInfo DeviceInfo   `json:"device_info"`
}

type UpdatePlaybackRequest struct {
        SessionID  string         `json:"session_id"`
        Position   *int64         `json:"position"`
        State      *PlaybackState `json:"state"`
        Volume     *float64       `json:"volume"`
        IsMuted    *bool          `json:"is_muted"`
        RepeatMode *RepeatMode    `json:"repeat_mode"`
        Shuffle    *bool          `json:"shuffle"`
}

type SeekRequest struct {
        SessionID string `json:"session_id"`
        Position  int64  `json:"position"`
}

type QueueRequest struct {
        SessionID string  `json:"session_id"`
        TrackIDs  []int64 `json:"track_ids"`
        Position  *int    `json:"position"`
}

func NewMusicPlayerService(
        db *sql.DB,
        logger *zap.Logger,
        mediaPlayerService *MediaPlayerService,
        playlistService *PlaylistService,
        positionService *PlaybackPositionService,
        lyricsService *LyricsService,
        coverArtService *CoverArtService,
        translationService *TranslationService,
) *MusicPlayerService <span class="cov0" title="0">{
        return &amp;MusicPlayerService{
                db:                 db,
                logger:             logger,
                mediaPlayerService: mediaPlayerService,
                playlistService:    playlistService,
                positionService:    positionService,
                lyricsService:      lyricsService,
                coverArtService:    coverArtService,
                translationService: translationService,
        }
}</span>

func (s *MusicPlayerService) PlayTrack(ctx context.Context, req *PlayTrackRequest) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting track playback",
                zap.Int64("user_id", req.UserID),
                zap.Int64("track_id", req.TrackID),
                zap.String("play_mode", string(req.PlayMode)))

        track, err := s.getTrack(ctx, req.TrackID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get track: %w", err)
        }</span>

        <span class="cov0" title="0">session := &amp;MusicPlaybackSession{
                ID:                generateSessionID(),
                UserID:            req.UserID,
                CurrentTrack:      track,
                Queue:             []MusicTrack{*track},
                QueueIndex:        0,
                PlayMode:          req.PlayMode,
                RepeatMode:        RepeatModeOff,
                ShuffleEnabled:    false,
                Volume:            1.0,
                IsMuted:           false,
                Crossfade:         false,
                CrossfadeDuration: 3000,
                EqualizerPreset:   "flat",
                EqualizerBands:    make(map[string]float64),
                PlaybackState:     PlaybackStatePlaying,
                Position:          0,
                Duration:          track.Duration,
                PlaybackQuality:   req.Quality,
                DeviceInfo:        req.DeviceInfo,
                LastActivity:      time.Now(),
                CreatedAt:         time.Now(),
                UpdatedAt:         time.Now(),
        }

        if req.StartTime != nil </span><span class="cov0" title="0">{
                session.Position = *req.StartTime
        }</span>

        <span class="cov0" title="0">switch req.PlayMode </span>{
        case PlayModeAlbum:<span class="cov0" title="0">
                if req.AlbumID != nil </span><span class="cov0" title="0">{
                        if err := s.loadAlbumQueue(ctx, session, *req.AlbumID, track.ID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load album queue", zap.Error(err))
                        }</span>
                }
        case PlayModeArtist:<span class="cov0" title="0">
                if req.ArtistID != nil </span><span class="cov0" title="0">{
                        if err := s.loadArtistQueue(ctx, session, *req.ArtistID, track.ID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load artist queue", zap.Error(err))
                        }</span>
                }
        case PlayModePlaylist:<span class="cov0" title="0">
                if req.PlaylistID != nil </span><span class="cov0" title="0">{
                        session.PlaylistID = req.PlaylistID
                        if err := s.loadPlaylistQueue(ctx, session, *req.PlaylistID, track.ID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load playlist queue", zap.Error(err))
                        }</span>
                }
        case PlayModeFolder:<span class="cov0" title="0">
                if req.FolderPath != nil </span><span class="cov0" title="0">{
                        if err := s.loadFolderQueue(ctx, session, *req.FolderPath, track.ID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load folder queue", zap.Error(err))
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to save session", zap.Error(err))
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.recordPlayback(ctx, req.UserID, track.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to record playback", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) PlayAlbum(ctx context.Context, req *PlayAlbumRequest) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting album playback",
                zap.Int64("user_id", req.UserID),
                zap.Int64("album_id", req.AlbumID),
                zap.Bool("shuffle", req.Shuffle))

        album, err := s.getAlbumWithTracks(ctx, req.AlbumID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get album: %w", err)
        }</span>

        <span class="cov0" title="0">if len(album.Tracks) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("album has no tracks")
        }</span>

        <span class="cov0" title="0">startIndex := 0
        if req.StartTrack != nil &amp;&amp; *req.StartTrack &lt; len(album.Tracks) </span><span class="cov0" title="0">{
                startIndex = *req.StartTrack
        }</span>

        <span class="cov0" title="0">session := &amp;MusicPlaybackSession{
                ID:                generateSessionID(),
                UserID:            req.UserID,
                CurrentTrack:      &amp;album.Tracks[startIndex],
                Queue:             album.Tracks,
                QueueIndex:        startIndex,
                PlayMode:          PlayModeAlbum,
                RepeatMode:        RepeatModeOff,
                ShuffleEnabled:    req.Shuffle,
                Volume:            1.0,
                IsMuted:           false,
                Crossfade:         true,
                CrossfadeDuration: 3000,
                EqualizerPreset:   "flat",
                EqualizerBands:    make(map[string]float64),
                PlaybackState:     PlaybackStatePlaying,
                Position:          0,
                Duration:          album.Tracks[startIndex].Duration,
                PlaybackQuality:   req.Quality,
                DeviceInfo:        req.DeviceInfo,
                LastActivity:      time.Now(),
                CreatedAt:         time.Now(),
                UpdatedAt:         time.Now(),
        }

        if req.Shuffle </span><span class="cov0" title="0">{
                s.shuffleQueue(session)
        }</span>

        <span class="cov0" title="0">if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) PlayArtist(ctx context.Context, req *PlayArtistRequest) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting artist playback",
                zap.Int64("user_id", req.UserID),
                zap.Int64("artist_id", req.ArtistID),
                zap.String("mode", req.Mode))

        var tracks []MusicTrack
        var err error

        switch req.Mode </span>{
        case "top_tracks":<span class="cov0" title="0">
                tracks, err = s.getArtistTopTracks(ctx, req.ArtistID, 50)</span>
        case "all_tracks":<span class="cov0" title="0">
                tracks, err = s.getArtistAllTracks(ctx, req.ArtistID)</span>
        case "albums":<span class="cov0" title="0">
                albums, albumErr := s.getArtistAlbums(ctx, req.ArtistID)
                if albumErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get artist albums: %w", albumErr)
                }</span>
                <span class="cov0" title="0">for _, album := range albums </span><span class="cov0" title="0">{
                        albumTracks, trackErr := s.getAlbumTracks(ctx, album.ID)
                        if trackErr == nil </span><span class="cov0" title="0">{
                                tracks = append(tracks, albumTracks...)
                        }</span>
                }
        default:<span class="cov0" title="0">
                tracks, err = s.getArtistTopTracks(ctx, req.ArtistID, 50)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get artist tracks: %w", err)
        }</span>

        <span class="cov0" title="0">if len(tracks) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("artist has no tracks")
        }</span>

        <span class="cov0" title="0">session := &amp;MusicPlaybackSession{
                ID:                generateSessionID(),
                UserID:            req.UserID,
                CurrentTrack:      &amp;tracks[0],
                Queue:             tracks,
                QueueIndex:        0,
                PlayMode:          PlayModeArtist,
                RepeatMode:        RepeatModeOff,
                ShuffleEnabled:    req.Shuffle,
                Volume:            1.0,
                IsMuted:           false,
                Crossfade:         true,
                CrossfadeDuration: 3000,
                EqualizerPreset:   "flat",
                EqualizerBands:    make(map[string]float64),
                PlaybackState:     PlaybackStatePlaying,
                Position:          0,
                Duration:          tracks[0].Duration,
                PlaybackQuality:   req.Quality,
                DeviceInfo:        req.DeviceInfo,
                LastActivity:      time.Now(),
                CreatedAt:         time.Now(),
                UpdatedAt:         time.Now(),
        }

        if req.Shuffle </span><span class="cov0" title="0">{
                s.shuffleQueue(session)
        }</span>

        <span class="cov0" title="0">if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) GetSession(ctx context.Context, sessionID string) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting playback session", zap.String("session_id", sessionID))

        query := `
                SELECT session_data, updated_at
                FROM music_playback_sessions
                WHERE id = $1 AND expires_at &gt; NOW()
        `

        var sessionData string
        var updatedAt time.Time
        err := s.db.QueryRowContext(ctx, query, sessionID).Scan(&amp;sessionData, &amp;updatedAt)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session not found or expired")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get session: %w", err)
        }</span>

        <span class="cov0" title="0">var session MusicPlaybackSession
        if err := json.Unmarshal([]byte(sessionData), &amp;session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal session: %w", err)
        }</span>

        <span class="cov0" title="0">session.UpdatedAt = updatedAt
        return &amp;session, nil</span>
}

func (s *MusicPlayerService) UpdatePlayback(ctx context.Context, req *UpdatePlaybackRequest) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Updating playback", zap.String("session_id", req.SessionID))

        session, err := s.GetSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Position != nil </span><span class="cov0" title="0">{
                session.Position = *req.Position
                if err := s.positionService.UpdatePosition(ctx, &amp;UpdatePositionRequest{
                        UserID:          session.UserID,
                        MediaItemID:     session.CurrentTrack.ID,
                        Position:        *req.Position,
                        Duration:        session.Duration,
                        DeviceInfo:      session.DeviceInfo.DeviceName,
                        PlaybackQuality: string(session.PlaybackQuality),
                }); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to update position", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">if req.State != nil </span><span class="cov0" title="0">{
                session.PlaybackState = *req.State
        }</span>

        <span class="cov0" title="0">if req.Volume != nil </span><span class="cov0" title="0">{
                session.Volume = *req.Volume
        }</span>

        <span class="cov0" title="0">if req.IsMuted != nil </span><span class="cov0" title="0">{
                session.IsMuted = *req.IsMuted
        }</span>

        <span class="cov0" title="0">if req.RepeatMode != nil </span><span class="cov0" title="0">{
                session.RepeatMode = *req.RepeatMode
        }</span>

        <span class="cov0" title="0">if req.Shuffle != nil </span><span class="cov0" title="0">{
                session.ShuffleEnabled = *req.Shuffle
                if *req.Shuffle </span><span class="cov0" title="0">{
                        s.shuffleQueue(session)
                }</span> else<span class="cov0" title="0"> {
                        s.unshuffleQueue(session)
                }</span>
        }

        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) NextTrack(ctx context.Context, sessionID string) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Skipping to next track", zap.String("session_id", sessionID))

        session, err := s.GetSession(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">nextIndex := s.getNextTrackIndex(session)
        if nextIndex == -1 </span><span class="cov0" title="0">{
                session.PlaybackState = PlaybackStateStopped
                return session, nil
        }</span>

        <span class="cov0" title="0">session.QueueIndex = nextIndex
        session.CurrentTrack = &amp;session.Queue[nextIndex]
        session.Position = 0
        session.Duration = session.CurrentTrack.Duration
        session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.recordPlayback(ctx, session.UserID, session.CurrentTrack.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to record playback", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) PreviousTrack(ctx context.Context, sessionID string) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Skipping to previous track", zap.String("session_id", sessionID))

        session, err := s.GetSession(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if session.Position &gt; 3000 </span><span class="cov0" title="0">{
                session.Position = 0
        }</span> else<span class="cov0" title="0"> {
                prevIndex := s.getPreviousTrackIndex(session)
                if prevIndex != -1 </span><span class="cov0" title="0">{
                        session.QueueIndex = prevIndex
                        session.CurrentTrack = &amp;session.Queue[prevIndex]
                        session.Duration = session.CurrentTrack.Duration
                }</span>
                <span class="cov0" title="0">session.Position = 0</span>
        }

        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) Seek(ctx context.Context, req *SeekRequest) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Seeking in track",
                zap.String("session_id", req.SessionID),
                zap.Int64("position", req.Position))

        session, err := s.GetSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Position &lt; 0 </span><span class="cov0" title="0">{
                req.Position = 0
        }</span>
        <span class="cov0" title="0">if req.Position &gt; session.Duration </span><span class="cov0" title="0">{
                req.Position = session.Duration
        }</span>

        <span class="cov0" title="0">session.Position = req.Position
        session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) AddToQueue(ctx context.Context, req *QueueRequest) (*MusicPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Adding tracks to queue",
                zap.String("session_id", req.SessionID),
                zap.Int("track_count", len(req.TrackIDs)))

        session, err := s.GetSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tracks, err := s.getTracks(ctx, req.TrackIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get tracks: %w", err)
        }</span>

        <span class="cov0" title="0">if req.Position != nil &amp;&amp; *req.Position &gt;= 0 &amp;&amp; *req.Position &lt;= len(session.Queue) </span><span class="cov0" title="0">{
                before := session.Queue[:*req.Position]
                after := session.Queue[*req.Position:]
                session.Queue = append(before, append(tracks, after...)...)

                if *req.Position &lt;= session.QueueIndex </span><span class="cov0" title="0">{
                        session.QueueIndex += len(tracks)
                }</span>
        } else<span class="cov0" title="0"> {
                session.Queue = append(session.Queue, tracks...)
        }</span>

        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *MusicPlayerService) GetLibraryStats(ctx context.Context, userID int64) (*MusicLibraryStats, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting library statistics", zap.Int64("user_id", userID))

        stats := &amp;MusicLibraryStats{
                FormatBreakdown:  make(map[string]int64),
                QualityBreakdown: make(map[string]int64),
                YearBreakdown:    make(map[int]int64),
                TopGenres:        make([]GenreStats, 0),
                TopArtists:       make([]ArtistStats, 0),
                RecentlyAdded:    make([]MusicTrack, 0),
                MostPlayed:       make([]MusicTrack, 0),
        }

        if err := s.getBasicStats(ctx, userID, stats); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.getFormatBreakdown(ctx, userID, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get format breakdown", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getTopGenres(ctx, userID, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get top genres", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getTopArtists(ctx, userID, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get top artists", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getRecentlyAdded(ctx, userID, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get recently added", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.getMostPlayed(ctx, userID, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get most played", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (s *MusicPlayerService) SetEqualizer(ctx context.Context, sessionID string, preset string, bands map[string]float64) error <span class="cov0" title="0">{
        s.logger.Debug("Setting equalizer",
                zap.String("session_id", sessionID),
                zap.String("preset", preset))

        session, err := s.GetSession(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.EqualizerPreset = preset
        if bands != nil </span><span class="cov0" title="0">{
                session.EqualizerBands = bands
        }</span>
        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        return s.saveSession(ctx, session)</span>
}

func (s *MusicPlayerService) getTrack(ctx context.Context, trackID int64) (*MusicTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bpm, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE id = $1 AND type = 'audio'
        `

        var track MusicTrack
        var lastPlayed sql.NullTime
        var bpm sql.NullInt64
        var key sql.NullString
        var rating sql.NullInt64

        err := s.db.QueryRowContext(ctx, query, trackID).Scan(
                &amp;track.ID, &amp;track.Title, &amp;track.Artist, &amp;track.Album, &amp;track.AlbumArtist,
                &amp;track.Genre, &amp;track.Year, &amp;track.TrackNumber, &amp;track.DiscNumber,
                &amp;track.Duration, &amp;track.FilePath, &amp;track.FileSize, &amp;track.Format,
                &amp;track.Bitrate, &amp;track.SampleRate, &amp;track.Channels, &amp;bpm, &amp;key,
                &amp;rating, &amp;track.PlayCount, &amp;lastPlayed, &amp;track.DateAdded,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if bpm.Valid </span><span class="cov0" title="0">{
                bpmInt := int(bpm.Int64)
                track.BPM = &amp;bpmInt
        }</span>
        <span class="cov0" title="0">if key.Valid </span><span class="cov0" title="0">{
                track.Key = &amp;key.String
        }</span>
        <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                ratingInt := int(rating.Int64)
                track.Rating = &amp;ratingInt
        }</span>
        <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                track.LastPlayed = &amp;lastPlayed.Time
        }</span>

        <span class="cov0" title="0">return &amp;track, nil</span>
}

func (s *MusicPlayerService) getTracks(ctx context.Context, trackIDs []int64) ([]MusicTrack, error) <span class="cov0" title="0">{
        if len(trackIDs) == 0 </span><span class="cov0" title="0">{
                return []MusicTrack{}, nil
        }</span>

        <span class="cov0" title="0">placeholders := make([]string, len(trackIDs))
        args := make([]interface{}, len(trackIDs))
        for i, id := range trackIDs </span><span class="cov0" title="0">{
                placeholders[i] = fmt.Sprintf("$%d", i+1)
                args[i] = id
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bpm, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE id IN (%s) AND type = 'audio'
                ORDER BY array_position(ARRAY[%s], id)
        `, strings.Join(placeholders, ","), strings.Join(placeholders, ","))

        rows, err := s.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tracks []MusicTrack
        for rows.Next() </span><span class="cov0" title="0">{
                var track MusicTrack
                var lastPlayed sql.NullTime
                var bpm sql.NullInt64
                var key sql.NullString
                var rating sql.NullInt64

                err := rows.Scan(
                        &amp;track.ID, &amp;track.Title, &amp;track.Artist, &amp;track.Album, &amp;track.AlbumArtist,
                        &amp;track.Genre, &amp;track.Year, &amp;track.TrackNumber, &amp;track.DiscNumber,
                        &amp;track.Duration, &amp;track.FilePath, &amp;track.FileSize, &amp;track.Format,
                        &amp;track.Bitrate, &amp;track.SampleRate, &amp;track.Channels, &amp;bpm, &amp;key,
                        &amp;rating, &amp;track.PlayCount, &amp;lastPlayed, &amp;track.DateAdded,
                )

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if bpm.Valid </span><span class="cov0" title="0">{
                        bpmInt := int(bpm.Int64)
                        track.BPM = &amp;bpmInt
                }</span>
                <span class="cov0" title="0">if key.Valid </span><span class="cov0" title="0">{
                        track.Key = &amp;key.String
                }</span>
                <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                        ratingInt := int(rating.Int64)
                        track.Rating = &amp;ratingInt
                }</span>
                <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                        track.LastPlayed = &amp;lastPlayed.Time
                }</span>

                <span class="cov0" title="0">tracks = append(tracks, track)</span>
        }

        <span class="cov0" title="0">return tracks, nil</span>
}

func (s *MusicPlayerService) getAlbumWithTracks(ctx context.Context, albumID int64) (*Album, error) <span class="cov0" title="0">{
        tracks, err := s.getAlbumTracks(ctx, albumID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(tracks) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("album not found")
        }</span>

        <span class="cov0" title="0">album := &amp;Album{
                ID:          albumID,
                Title:       tracks[0].Album,
                Artist:      tracks[0].Artist,
                AlbumArtist: tracks[0].AlbumArtist,
                Year:        tracks[0].Year,
                Genre:       tracks[0].Genre,
                TrackCount:  len(tracks),
                Tracks:      tracks,
                DateAdded:   tracks[0].DateAdded,
        }

        for _, track := range tracks </span><span class="cov0" title="0">{
                album.Duration += track.Duration
                album.PlayCount += track.PlayCount
                if track.LastPlayed != nil &amp;&amp; (album.LastPlayed == nil || track.LastPlayed.After(*album.LastPlayed)) </span><span class="cov0" title="0">{
                        album.LastPlayed = track.LastPlayed
                }</span>
        }

        <span class="cov0" title="0">return album, nil</span>
}

func (s *MusicPlayerService) getAlbumTracks(ctx context.Context, albumID int64) ([]MusicTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bpm, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE album_id = $1 AND type = 'audio'
                ORDER BY disc_number ASC, track_number ASC
        `

        rows, err := s.db.QueryContext(ctx, query, albumID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tracks []MusicTrack
        for rows.Next() </span><span class="cov0" title="0">{
                var track MusicTrack
                var lastPlayed sql.NullTime
                var bpm sql.NullInt64
                var key sql.NullString
                var rating sql.NullInt64

                err := rows.Scan(
                        &amp;track.ID, &amp;track.Title, &amp;track.Artist, &amp;track.Album, &amp;track.AlbumArtist,
                        &amp;track.Genre, &amp;track.Year, &amp;track.TrackNumber, &amp;track.DiscNumber,
                        &amp;track.Duration, &amp;track.FilePath, &amp;track.FileSize, &amp;track.Format,
                        &amp;track.Bitrate, &amp;track.SampleRate, &amp;track.Channels, &amp;bpm, &amp;key,
                        &amp;rating, &amp;track.PlayCount, &amp;lastPlayed, &amp;track.DateAdded,
                )

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if bpm.Valid </span><span class="cov0" title="0">{
                        bpmInt := int(bpm.Int64)
                        track.BPM = &amp;bpmInt
                }</span>
                <span class="cov0" title="0">if key.Valid </span><span class="cov0" title="0">{
                        track.Key = &amp;key.String
                }</span>
                <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                        ratingInt := int(rating.Int64)
                        track.Rating = &amp;ratingInt
                }</span>
                <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                        track.LastPlayed = &amp;lastPlayed.Time
                }</span>

                <span class="cov0" title="0">tracks = append(tracks, track)</span>
        }

        <span class="cov0" title="0">return tracks, nil</span>
}

func (s *MusicPlayerService) getArtistTopTracks(ctx context.Context, artistID int64, limit int) ([]MusicTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bpm, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE artist_id = $1 AND type = 'audio'
                ORDER BY play_count DESC, rating DESC
                LIMIT $2
        `

        rows, err := s.db.QueryContext(ctx, query, artistID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return s.scanTracks(rows)</span>
}

func (s *MusicPlayerService) getArtistAllTracks(ctx context.Context, artistID int64) ([]MusicTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bmp, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE artist_id = $1 AND type = 'audio'
                ORDER BY year DESC, album ASC, disc_number ASC, track_number ASC
        `

        rows, err := s.db.QueryContext(ctx, query, artistID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return s.scanTracks(rows)</span>
}

func (s *MusicPlayerService) getArtistAlbums(ctx context.Context, artistID int64) ([]Album, error) <span class="cov0" title="0">{
        return []Album{}, nil
}</span>

func (s *MusicPlayerService) scanTracks(rows *sql.Rows) ([]MusicTrack, error) <span class="cov0" title="0">{
        var tracks []MusicTrack
        for rows.Next() </span><span class="cov0" title="0">{
                var track MusicTrack
                var lastPlayed sql.NullTime
                var bpm sql.NullInt64
                var key sql.NullString
                var rating sql.NullInt64

                err := rows.Scan(
                        &amp;track.ID, &amp;track.Title, &amp;track.Artist, &amp;track.Album, &amp;track.AlbumArtist,
                        &amp;track.Genre, &amp;track.Year, &amp;track.TrackNumber, &amp;track.DiscNumber,
                        &amp;track.Duration, &amp;track.FilePath, &amp;track.FileSize, &amp;track.Format,
                        &amp;track.Bitrate, &amp;track.SampleRate, &amp;track.Channels, &amp;bpm, &amp;key,
                        &amp;rating, &amp;track.PlayCount, &amp;lastPlayed, &amp;track.DateAdded,
                )

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if bpm.Valid </span><span class="cov0" title="0">{
                        bpmInt := int(bpm.Int64)
                        track.BPM = &amp;bpmInt
                }</span>
                <span class="cov0" title="0">if key.Valid </span><span class="cov0" title="0">{
                        track.Key = &amp;key.String
                }</span>
                <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                        ratingInt := int(rating.Int64)
                        track.Rating = &amp;ratingInt
                }</span>
                <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                        track.LastPlayed = &amp;lastPlayed.Time
                }</span>

                <span class="cov0" title="0">tracks = append(tracks, track)</span>
        }

        <span class="cov0" title="0">return tracks, nil</span>
}

func (s *MusicPlayerService) loadAlbumQueue(ctx context.Context, session *MusicPlaybackSession, albumID, currentTrackID int64) error <span class="cov0" title="0">{
        tracks, err := s.getAlbumTracks(ctx, albumID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.Queue = tracks
        for i, track := range tracks </span><span class="cov0" title="0">{
                if track.ID == currentTrackID </span><span class="cov0" title="0">{
                        session.QueueIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) loadArtistQueue(ctx context.Context, session *MusicPlaybackSession, artistID, currentTrackID int64) error <span class="cov0" title="0">{
        tracks, err := s.getArtistTopTracks(ctx, artistID, 100)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.Queue = tracks
        for i, track := range tracks </span><span class="cov0" title="0">{
                if track.ID == currentTrackID </span><span class="cov0" title="0">{
                        session.QueueIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) loadPlaylistQueue(ctx context.Context, session *MusicPlaybackSession, playlistID, currentTrackID int64) error <span class="cov0" title="0">{
        playlistItems, err := s.playlistService.GetPlaylistItems(ctx, playlistID, session.UserID, 1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var trackIDs []int64
        for _, item := range playlistItems </span><span class="cov0" title="0">{
                trackIDs = append(trackIDs, item.MediaItemID)
        }</span>

        <span class="cov0" title="0">tracks, err := s.getTracks(ctx, trackIDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.Queue = tracks
        for i, track := range tracks </span><span class="cov0" title="0">{
                if track.ID == currentTrackID </span><span class="cov0" title="0">{
                        session.QueueIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) loadFolderQueue(ctx context.Context, session *MusicPlaybackSession, folderPath string, currentTrackID int64) error <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bmp, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE file_path LIKE $1 AND type = 'audio'
                ORDER BY file_path ASC
        `

        rows, err := s.db.QueryContext(ctx, query, folderPath+"%")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        tracks, err := s.scanTracks(rows)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.Queue = tracks
        for i, track := range tracks </span><span class="cov0" title="0">{
                if track.ID == currentTrackID </span><span class="cov0" title="0">{
                        session.QueueIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) shuffleQueue(session *MusicPlaybackSession) <span class="cov0" title="0">{
        if len(session.Queue) &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">currentTrack := session.Queue[session.QueueIndex]
        remainingTracks := make([]MusicTrack, 0, len(session.Queue)-1)

        for i, track := range session.Queue </span><span class="cov0" title="0">{
                if i != session.QueueIndex </span><span class="cov0" title="0">{
                        remainingTracks = append(remainingTracks, track)
                }</span>
        }

        <span class="cov0" title="0">rand.Shuffle(len(remainingTracks), func(i, j int) </span><span class="cov0" title="0">{
                remainingTracks[i], remainingTracks[j] = remainingTracks[j], remainingTracks[i]
        }</span>)

        <span class="cov0" title="0">session.Queue = append([]MusicTrack{currentTrack}, remainingTracks...)
        session.QueueIndex = 0</span>
}

func (s *MusicPlayerService) unshuffleQueue(session *MusicPlaybackSession) <span class="cov0" title="0">{
        if len(session.ShuffleHistory) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">sort.Slice(session.Queue, func(i, j int) bool </span><span class="cov0" title="0">{
                return session.Queue[i].ID &lt; session.Queue[j].ID
        }</span>)

        <span class="cov0" title="0">for i, track := range session.Queue </span><span class="cov0" title="0">{
                if track.ID == session.CurrentTrack.ID </span><span class="cov0" title="0">{
                        session.QueueIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">session.ShuffleHistory = []int{}</span>
}

func (s *MusicPlayerService) getNextTrackIndex(session *MusicPlaybackSession) int <span class="cov0" title="0">{
        if len(session.Queue) == 0 </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">switch session.RepeatMode </span>{
        case RepeatModeTrack:<span class="cov0" title="0">
                return session.QueueIndex</span>
        case RepeatModeAll, RepeatModeAlbum:<span class="cov0" title="0">
                if session.QueueIndex &lt; len(session.Queue)-1 </span><span class="cov0" title="0">{
                        return session.QueueIndex + 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        default:<span class="cov0" title="0">
                if session.QueueIndex &lt; len(session.Queue)-1 </span><span class="cov0" title="0">{
                        return session.QueueIndex + 1
                }</span>
                <span class="cov0" title="0">return -1</span>
        }
}

func (s *MusicPlayerService) getPreviousTrackIndex(session *MusicPlaybackSession) int <span class="cov0" title="0">{
        if len(session.Queue) == 0 </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">if session.QueueIndex &gt; 0 </span><span class="cov0" title="0">{
                return session.QueueIndex - 1
        }</span>

        <span class="cov0" title="0">if session.RepeatMode == RepeatModeAll || session.RepeatMode == RepeatModeAlbum </span><span class="cov0" title="0">{
                return len(session.Queue) - 1
        }</span>

        <span class="cov0" title="0">return -1</span>
}

func (s *MusicPlayerService) saveSession(ctx context.Context, session *MusicPlaybackSession) error <span class="cov0" title="0">{
        sessionData, err := json.Marshal(session)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal session: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO music_playback_sessions (id, user_id, session_data, expires_at, updated_at)
                VALUES ($1, $2, $3, NOW() + INTERVAL '24 hours', NOW())
                ON CONFLICT (id)
                DO UPDATE SET
                        session_data = EXCLUDED.session_data,
                        expires_at = NOW() + INTERVAL '24 hours',
                        updated_at = NOW()
        `

        _, err = s.db.ExecContext(ctx, query, session.ID, session.UserID, string(sessionData))
        return err</span>
}

func (s *MusicPlayerService) recordPlayback(ctx context.Context, userID, trackID int64) error <span class="cov0" title="0">{
        query := `
                UPDATE media_items
                SET play_count = play_count + 1, last_played = NOW()
                WHERE id = $1
        `

        _, err := s.db.ExecContext(ctx, query, trackID)
        return err
}</span>

func (s *MusicPlayerService) getBasicStats(ctx context.Context, userID int64, stats *MusicLibraryStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        COUNT(*) as total_tracks,
                        COUNT(DISTINCT album) as total_albums,
                        COUNT(DISTINCT artist) as total_artists,
                        COUNT(DISTINCT genre) as total_genres,
                        COALESCE(SUM(duration), 0) as total_duration,
                        COALESCE(SUM(file_size), 0) as total_size
                FROM media_items
                WHERE type = 'audio' AND user_id = $1
        `

        return s.db.QueryRowContext(ctx, query, userID).Scan(
                &amp;stats.TotalTracks, &amp;stats.TotalAlbums, &amp;stats.TotalArtists,
                &amp;stats.TotalGenres, &amp;stats.TotalDuration, &amp;stats.TotalSize,
        )
}</span>

func (s *MusicPlayerService) getFormatBreakdown(ctx context.Context, userID int64, stats *MusicLibraryStats) error <span class="cov0" title="0">{
        query := `
                SELECT format, COUNT(*)
                FROM media_items
                WHERE type = 'audio' AND user_id = $1
                GROUP BY format
                ORDER BY COUNT(*) DESC
        `

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var format string
                var count int64
                if err := rows.Scan(&amp;format, &amp;count); err == nil </span><span class="cov0" title="0">{
                        stats.FormatBreakdown[format] = count
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) getTopGenres(ctx context.Context, userID int64, stats *MusicLibraryStats) error <span class="cov0" title="0">{
        query := `
                SELECT genre, COUNT(*) as count, COALESCE(SUM(duration), 0) as duration
                FROM media_items
                WHERE type = 'audio' AND user_id = $1 AND genre != ''
                GROUP BY genre
                ORDER BY COUNT(*) DESC
                LIMIT 10
        `

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var genre GenreStats
                if err := rows.Scan(&amp;genre.Genre, &amp;genre.Count, &amp;genre.Duration); err == nil </span><span class="cov0" title="0">{
                        stats.TopGenres = append(stats.TopGenres, genre)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) getTopArtists(ctx context.Context, userID int64, stats *MusicLibraryStats) error <span class="cov0" title="0">{
        query := `
                SELECT artist, COUNT(*) as count, COALESCE(SUM(duration), 0) as duration
                FROM media_items
                WHERE type = 'audio' AND user_id = $1 AND artist != ''
                GROUP BY artist
                ORDER BY COUNT(*) DESC
                LIMIT 10
        `

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var artist ArtistStats
                if err := rows.Scan(&amp;artist.Artist, &amp;artist.Count, &amp;artist.Duration); err == nil </span><span class="cov0" title="0">{
                        stats.TopArtists = append(stats.TopArtists, artist)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MusicPlayerService) getRecentlyAdded(ctx context.Context, userID int64, stats *MusicLibraryStats) error <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bmp, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE type = 'audio' AND user_id = $1
                ORDER BY date_added DESC
                LIMIT 20
        `

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        tracks, err := s.scanTracks(rows)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">stats.RecentlyAdded = tracks
        return nil</span>
}

func (s *MusicPlayerService) getMostPlayed(ctx context.Context, userID int64, stats *MusicLibraryStats) error <span class="cov0" title="0">{
        query := `
                SELECT id, title, artist, album, album_artist, genre, year, track_number,
                           disc_number, duration, file_path, file_size, format, bitrate,
                           sample_rate, channels, bmp, key, rating, play_count, last_played,
                           date_added
                FROM media_items
                WHERE type = 'audio' AND user_id = $1 AND play_count &gt; 0
                ORDER BY play_count DESC
                LIMIT 20
        `

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        tracks, err := s.scanTracks(rows)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">stats.MostPlayed = tracks
        return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "math"
        "net/http"
        "net/url"
        "regexp"
        "strconv"
        "strings"
        "time"

        "catalogizer/internal/models"
        "go.uber.org/zap"
)

// Music recognition provider with audio fingerprinting
type MusicRecognitionProvider struct {
        logger      *zap.Logger
        httpClient  *http.Client
        baseURLs    map[string]string
        apiKeys     map[string]string
        rateLimiter map[string]*time.Ticker
}

// Last.fm API structures
type LastFMSearchResponse struct {
        Results LastFMResults `json:"results"`
}

type LastFMResults struct {
        TrackMatches  LastFMTrackMatches  `json:"trackmatches"`
        AlbumMatches  LastFMAlbumMatches  `json:"albummatches"`
        ArtistMatches LastFMArtistMatches `json:"artistmatches"`
}

type LastFMTrackMatches struct {
        Track []LastFMTrack `json:"track"`
}

type LastFMAlbumMatches struct {
        Album []LastFMAlbum `json:"album"`
}

type LastFMArtistMatches struct {
        Artist []LastFMArtist `json:"artist"`
}

type LastFMTrack struct {
        Name       string        `json:"name"`
        Artist     string        `json:"artist"`
        URL        string        `json:"url"`
        Streamable string        `json:"streamable"`
        Listeners  string        `json:"listeners"`
        Image      []LastFMImage `json:"image"`
        MBID       string        `json:"mbid"`
}

type LastFMAlbum struct {
        Name   string        `json:"name"`
        Artist string        `json:"artist"`
        URL    string        `json:"url"`
        Image  []LastFMImage `json:"image"`
        MBID   string        `json:"mbid"`
}

type LastFMArtist struct {
        Name       string        `json:"name"`
        Listeners  string        `json:"listeners"`
        MBID       string        `json:"mbid"`
        URL        string        `json:"url"`
        Streamable string        `json:"streamable"`
        Image      []LastFMImage `json:"image"`
}

type LastFMImage struct {
        Text string `json:"#text"`
        Size string `json:"size"`
}

type LastFMTrackInfo struct {
        Track LastFMTrackDetail `json:"track"`
}

type LastFMTrackDetail struct {
        Name       string             `json:"name"`
        MBID       string             `json:"mbid"`
        URL        string             `json:"url"`
        Duration   string             `json:"duration"`
        Streamable LastFMStreamable   `json:"streamable"`
        Listeners  string             `json:"listeners"`
        Playcount  string             `json:"playcount"`
        Artist     LastFMArtistDetail `json:"artist"`
        Album      LastFMAlbumDetail  `json:"album"`
        TopTags    LastFMTopTags      `json:"toptags"`
        Wiki       LastFMWiki         `json:"wiki"`
}

type LastFMStreamable struct {
        Text      string `json:"#text"`
        Fulltrack string `json:"fulltrack"`
}

type LastFMArtistDetail struct {
        Name string `json:"name"`
        MBID string `json:"mbid"`
        URL  string `json:"url"`
}

type LastFMAlbumDetail struct {
        Artist string        `json:"artist"`
        Title  string        `json:"title"`
        MBID   string        `json:"mbid"`
        URL    string        `json:"url"`
        Image  []LastFMImage `json:"image"`
}

type LastFMTopTags struct {
        Tag []LastFMTag `json:"tag"`
}

type LastFMTag struct {
        Name string `json:"name"`
        URL  string `json:"url"`
}

type LastFMWiki struct {
        Published string `json:"published"`
        Summary   string `json:"summary"`
        Content   string `json:"content"`
}

// MusicBrainz API structures
type MusicBrainzSearchResponse struct {
        Recordings []MusicBrainzRecording `json:"recordings"`
        Releases   []MusicBrainzRelease   `json:"releases"`
        Artists    []MusicBrainzArtist    `json:"artists"`
}

type MusicBrainzRecording struct {
        ID             string                    `json:"id"`
        Score          int                       `json:"score"`
        Title          string                    `json:"title"`
        Length         int                       `json:"length"`
        Disambiguation string                    `json:"disambiguation"`
        ArtistCredit   []MusicBrainzArtistCredit `json:"artist-credit"`
        Releases       []MusicBrainzReleaseBasic `json:"releases"`
        Tags           []MusicBrainzTag          `json:"tags"`
        Genres         []MusicBrainzGenre        `json:"genres"`
        ISRCs          []string                  `json:"isrcs"`
}

type MusicBrainzRelease struct {
        ID           string                    `json:"id"`
        Score        int                       `json:"score"`
        Title        string                    `json:"title"`
        StatusID     string                    `json:"status-id"`
        Status       string                    `json:"status"`
        Packaging    string                    `json:"packaging"`
        Date         string                    `json:"date"`
        Country      string                    `json:"country"`
        Barcode      string                    `json:"barcode"`
        ArtistCredit []MusicBrainzArtistCredit `json:"artist-credit"`
        ReleaseGroup MusicBrainzReleaseGroup   `json:"release-group"`
        Media        []MusicBrainzMedia        `json:"media"`
        LabelInfo    []MusicBrainzLabelInfo    `json:"label-info"`
}

type MusicBrainzArtist struct {
        ID        string              `json:"id"`
        Score     int                 `json:"score"`
        Name      string              `json:"name"`
        SortName  string              `json:"sort-name"`
        Type      string              `json:"type"`
        Gender    string              `json:"gender"`
        Country   string              `json:"country"`
        Area      MusicBrainzArea     `json:"area"`
        BeginArea MusicBrainzArea     `json:"begin-area"`
        EndArea   MusicBrainzArea     `json:"end-area"`
        LifeSpan  MusicBrainzLifeSpan `json:"life-span"`
        Aliases   []MusicBrainzAlias  `json:"aliases"`
        Tags      []MusicBrainzTag    `json:"tags"`
        Genres    []MusicBrainzGenre  `json:"genres"`
}

type MusicBrainzArtistCredit struct {
        Name   string            `json:"name"`
        Artist MusicBrainzArtist `json:"artist"`
}

type MusicBrainzReleaseBasic struct {
        ID       string `json:"id"`
        Title    string `json:"title"`
        StatusID string `json:"status-id"`
        Status   string `json:"status"`
        Date     string `json:"date"`
        Country  string `json:"country"`
}

type MusicBrainzReleaseGroup struct {
        ID               string `json:"id"`
        TypeID           string `json:"type-id"`
        Type             string `json:"type"`
        PrimaryTypeID    string `json:"primary-type-id"`
        PrimaryType      string `json:"primary-type"`
        Title            string `json:"title"`
        FirstReleaseDate string `json:"first-release-date"`
}

type MusicBrainzMedia struct {
        Format     string             `json:"format"`
        DiscCount  int                `json:"disc-count"`
        TrackCount int                `json:"track-count"`
        Tracks     []MusicBrainzTrack `json:"tracks"`
}

type MusicBrainzTrack struct {
        ID       string `json:"id"`
        Number   string `json:"number"`
        Title    string `json:"title"`
        Length   int    `json:"length"`
        Position int    `json:"position"`
}

type MusicBrainzLabelInfo struct {
        CatalogNumber string           `json:"catalog-number"`
        Label         MusicBrainzLabel `json:"label"`
}

type MusicBrainzLabel struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

type MusicBrainzArea struct {
        ID       string   `json:"id"`
        Name     string   `json:"name"`
        SortName string   `json:"sort-name"`
        ISO31661 []string `json:"iso-3166-1-codes"`
}

type MusicBrainzLifeSpan struct {
        Begin string `json:"begin"`
        End   string `json:"end"`
        Ended bool   `json:"ended"`
}

type MusicBrainzAlias struct {
        SortName  string `json:"sort-name"`
        Name      string `json:"name"`
        Locale    string `json:"locale"`
        Type      string `json:"type"`
        Primary   bool   `json:"primary"`
        BeginDate string `json:"begin-date"`
        EndDate   string `json:"end-date"`
}

type MusicBrainzTag struct {
        Count int    `json:"count"`
        Name  string `json:"name"`
}

type MusicBrainzGenre struct {
        Count int    `json:"count"`
        Name  string `json:"name"`
}

// Audio fingerprinting structures
type AudioFingerprintAnalysis struct {
        Duration         float64          `json:"duration"`
        SampleRate       int              `json:"sample_rate"`
        Channels         int              `json:"channels"`
        BitRate          int              `json:"bit_rate"`
        Tempo            float64          `json:"tempo"`
        Key              string           `json:"key"`
        Energy           float64          `json:"energy"`
        Valence          float64          `json:"valence"`
        Danceability     float64          `json:"danceability"`
        Acousticness     float64          `json:"acousticness"`
        Instrumentalness float64          `json:"instrumentalness"`
        Speechiness      float64          `json:"speechiness"`
        SpectralFeatures SpectralFeatures `json:"spectral_features"`
        ChromaFeatures   []float64        `json:"chroma_features"`
        MFCCFeatures     []float64        `json:"mfcc_features"`
        RhythmFeatures   RhythmFeatures   `json:"rhythm_features"`
}

type SpectralFeatures struct {
        SpectralCentroid  []float64 `json:"spectral_centroid"`
        SpectralBandwidth []float64 `json:"spectral_bandwidth"`
        SpectralRolloff   []float64 `json:"spectral_rolloff"`
        ZeroCrossingRate  []float64 `json:"zero_crossing_rate"`
        SpectralContrast  []float64 `json:"spectral_contrast"`
}

type RhythmFeatures struct {
        OnsetStrength []float64   `json:"onset_strength"`
        BeatTrack     []float64   `json:"beat_track"`
        Tempoogram    [][]float64 `json:"tempogram"`
}

func NewMusicRecognitionProvider(logger *zap.Logger) *MusicRecognitionProvider <span class="cov0" title="0">{
        return &amp;MusicRecognitionProvider{
                logger:     logger,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                baseURLs: map[string]string{
                        "lastfm":      "http://ws.audioscrobbler.com/2.0/",
                        "musicbrainz": "https://musicbrainz.org/ws/2",
                        "acoustid":    "https://api.acoustid.org/v2",
                        "spotify":     "https://api.spotify.com/v1",
                        "deezer":      "https://api.deezer.com",
                        "discogs":     "https://api.discogs.com",
                },
                apiKeys: map[string]string{
                        "lastfm":   "free_api_key",
                        "acoustid": "free_api_key",
                        "discogs":  "free_api_key",
                },
                rateLimiter: make(map[string]*time.Ticker),
        }
}</span>

func (p *MusicRecognitionProvider) RecognizeMedia(ctx context.Context, req *MediaRecognitionRequest) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        p.logger.Info("Starting music recognition",
                zap.String("file_path", req.FilePath),
                zap.String("media_type", string(req.MediaType)))

        // Extract metadata from filename
        title, artist, album := p.extractMusicMetadataFromFilename(req.FileName)
        trackNumber := p.extractTrackNumber(req.FileName)

        p.logger.Debug("Extracted metadata from filename",
                zap.String("title", title),
                zap.String("artist", artist),
                zap.String("album", album),
                zap.Int("track_number", trackNumber))

        // Try audio fingerprinting if audio sample provided
        if len(req.AudioSample) &gt; 0 </span><span class="cov0" title="0">{
                if result, err := p.recognizeByFingerprint(ctx, req.AudioSample); err == nil </span><span class="cov0" title="0">{
                        p.logger.Info("Successfully recognized via fingerprint",
                                zap.String("title", result.Title),
                                zap.Float64("confidence", result.Confidence))
                        return result, nil
                }</span>
        }

        // Try metadata-based recognition
        <span class="cov0" title="0">if title != "" || artist != "" </span><span class="cov0" title="0">{
                if result, err := p.recognizeByMetadata(ctx, title, artist, album); err == nil </span><span class="cov0" title="0">{
                        result.TrackNumber = trackNumber
                        p.logger.Info("Successfully recognized via metadata",
                                zap.String("title", result.Title),
                                zap.Float64("confidence", result.Confidence))
                        return result, nil
                }</span>
        }

        // Fallback to basic recognition
        <span class="cov0" title="0">return p.basicMusicRecognition(req, title, artist, album, trackNumber), nil</span>
}

func (p *MusicRecognitionProvider) recognizeByFingerprint(ctx context.Context, audioSample []byte) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Generate audio fingerprint
        fingerprint, err := p.generateAudioFingerprint(audioSample)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Query AcoustID API
        <span class="cov0" title="0">params := url.Values{}
        params.Set("client", p.apiKeys["acoustid"])
        params.Set("format", "json")
        params.Set("meta", "recordings+recordingids+releases+releaseids+releasegroups+releasegroupids+tracks+compress+usermeta+sources")
        params.Set("duration", fmt.Sprintf("%.2f", fingerprint.Duration))
        params.Set("fingerprint", fingerprint.Hash)

        resp, err := p.httpClient.PostForm(p.baseURLs["acoustid"]+"/lookup", params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var acoustIDResp AcoustIDResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;acoustIDResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if acoustIDResp.Status != "ok" || len(acoustIDResp.Results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no results from AcoustID")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestResult := acoustIDResp.Results[0]
        if len(bestResult.Recordings) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no recordings found")
        }</span>

        <span class="cov0" title="0">recording := bestResult.Recordings[0]

        // Convert to MediaRecognitionResult
        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("acoustid_%s", recording.ID),
                MediaType:         p.determineAudioMediaType(recording.Title),
                Title:             recording.Title,
                Duration:          int64(recording.Duration * 1000), // Convert to milliseconds
                Confidence:        bestResult.Score,
                RecognitionMethod: "audio_fingerprint",
                APIProvider:       "AcoustID",
                Fingerprints: map[string]string{
                        "acoustid": fingerprint.Hash,
                },
        }

        // Extract artist information
        if len(recording.Artists) &gt; 0 </span><span class="cov0" title="0">{
                result.Artist = recording.Artists[0].Name
                result.AlbumArtist = recording.Artists[0].Name
        }</span>

        // Extract release information
        <span class="cov0" title="0">if len(recording.Releases) &gt; 0 </span><span class="cov0" title="0">{
                release := recording.Releases[0]
                result.Album = release.Title
                if release.Date != "" </span><span class="cov0" title="0">{
                        result.Year = p.parseYear(release.Date)
                }</span>
        }

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "acoustid":    recording.ID,
                "musicbrainz": recording.ID,
        }

        // Get additional metadata from MusicBrainz
        if mbResult, err := p.getMusicBrainzDetails(ctx, recording.ID); err == nil </span><span class="cov0" title="0">{
                p.enhanceMusicResult(result, mbResult)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (p *MusicRecognitionProvider) recognizeByMetadata(ctx context.Context, title, artist, album string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Try Last.fm first
        if result, err := p.searchLastFM(ctx, title, artist, album); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Try MusicBrainz as fallback
        <span class="cov0" title="0">if result, err := p.searchMusicBrainz(ctx, title, artist, album); err == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no results from metadata APIs")</span>
}

func (p *MusicRecognitionProvider) searchLastFM(ctx context.Context, title, artist, album string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}
        params.Set("method", "track.search")
        params.Set("api_key", p.apiKeys["lastfm"])
        params.Set("format", "json")
        params.Set("limit", "10")

        // Build search query
        query := title
        if artist != "" </span><span class="cov0" title="0">{
                query = fmt.Sprintf("%s %s", artist, title)
        }</span>
        <span class="cov0" title="0">params.Set("track", query)

        resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", p.baseURLs["lastfm"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResp LastFMSearchResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResp.Results.TrackMatches.Track) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no tracks found in Last.fm")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := searchResp.Results.TrackMatches.Track[0]

        // Get detailed track information
        return p.getLastFMTrackDetails(ctx, bestMatch.Name, bestMatch.Artist, bestMatch.MBID)</span>
}

func (p *MusicRecognitionProvider) getLastFMTrackDetails(ctx context.Context, track, artist, mbid string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        params := url.Values{}
        params.Set("method", "track.getInfo")
        params.Set("api_key", p.apiKeys["lastfm"])
        params.Set("format", "json")
        params.Set("artist", artist)
        params.Set("track", track)
        if mbid != "" </span><span class="cov0" title="0">{
                params.Set("mbid", mbid)
        }</span>

        <span class="cov0" title="0">resp, err := p.httpClient.Get(fmt.Sprintf("%s?%s", p.baseURLs["lastfm"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var trackInfo LastFMTrackInfo
        if err := json.NewDecoder(resp.Body).Decode(&amp;trackInfo); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">track_detail := trackInfo.Track

        // Convert to MediaRecognitionResult
        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("lastfm_%s", p.generateID(track_detail.Name, track_detail.Artist.Name)),
                MediaType:         p.determineAudioMediaType(track_detail.Name),
                Title:             track_detail.Name,
                Artist:            track_detail.Artist.Name,
                AlbumArtist:       track_detail.Artist.Name,
                Album:             track_detail.Album.Title,
                Confidence:        p.calculateLastFMConfidence(track_detail.Listeners, track_detail.Playcount),
                RecognitionMethod: "metadata_search",
                APIProvider:       "Last.fm",
        }

        // Parse duration
        if duration, err := strconv.ParseInt(track_detail.Duration, 10, 64); err == nil </span><span class="cov0" title="0">{
                result.Duration = duration
        }</span>

        // Extract genres from tags
        <span class="cov0" title="0">for _, tag := range track_detail.TopTags.Tag </span><span class="cov0" title="0">{
                result.Genres = append(result.Genres, tag.Name)
        }</span>

        // Extract description from wiki
        <span class="cov0" title="0">if track_detail.Wiki.Summary != "" </span><span class="cov0" title="0">{
                result.Description = track_detail.Wiki.Summary
        }</span>

        // Get cover art from album
        <span class="cov0" title="0">for _, image := range track_detail.Album.Image </span><span class="cov0" title="0">{
                if image.Text != "" </span><span class="cov0" title="0">{
                        size := "medium"
                        if image.Size == "extralarge" </span><span class="cov0" title="0">{
                                size = "large"
                        }</span> else<span class="cov0" title="0"> if image.Size == "large" </span><span class="cov0" title="0">{
                                size = "medium"
                        }</span> else<span class="cov0" title="0"> if image.Size == "medium" </span><span class="cov0" title="0">{
                                size = "small"
                        }</span>

                        <span class="cov0" title="0">result.CoverArt = append(result.CoverArt, models.CoverArtResult{
                                URL:     image.Text,
                                Quality: size,
                                Source:  "Last.fm",
                        })</span>
                }
        }

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "lastfm_url": track_detail.URL,
        }
        if track_detail.MBID != "" </span><span class="cov0" title="0">{
                result.ExternalIDs["musicbrainz"] = track_detail.MBID
                result.MusicBrainzID = track_detail.MBID
        }</span>
        <span class="cov0" title="0">if track_detail.Album.MBID != "" </span><span class="cov0" title="0">{
                result.ExternalIDs["musicbrainz_album"] = track_detail.Album.MBID
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (p *MusicRecognitionProvider) searchMusicBrainz(ctx context.Context, title, artist, album string) (*MediaRecognitionResult, error) <span class="cov0" title="0">{
        // Build search query
        query := fmt.Sprintf("recording:\"%s\"", title)
        if artist != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND artist:\"%s\"", artist)
        }</span>
        <span class="cov0" title="0">if album != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND release:\"%s\"", album)
        }</span>

        <span class="cov0" title="0">params := url.Values{}
        params.Set("query", query)
        params.Set("fmt", "json")
        params.Set("limit", "10")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/recording?%s", p.baseURLs["musicbrainz"], params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResp MusicBrainzSearchResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResp.Recordings) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no recordings found in MusicBrainz")
        }</span>

        // Get the best match
        <span class="cov0" title="0">bestMatch := searchResp.Recordings[0]

        return p.convertMusicBrainzRecording(bestMatch), nil</span>
}

func (p *MusicRecognitionProvider) getMusicBrainzDetails(ctx context.Context, recordingID string) (*MusicBrainzRecording, error) <span class="cov0" title="0">{
        params := url.Values{}
        params.Set("fmt", "json")
        params.Set("inc", "artists+releases+genres+tags+isrcs")

        resp, err := p.httpClient.Get(fmt.Sprintf("%s/recording/%s?%s", p.baseURLs["musicbrainz"], recordingID, params.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var recording MusicBrainzRecording
        if err := json.NewDecoder(resp.Body).Decode(&amp;recording); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;recording, nil</span>
}

func (p *MusicRecognitionProvider) convertMusicBrainzRecording(recording MusicBrainzRecording) *MediaRecognitionResult <span class="cov0" title="0">{
        result := &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("musicbrainz_%s", recording.ID),
                MediaType:         p.determineAudioMediaType(recording.Title),
                Title:             recording.Title,
                Duration:          int64(recording.Length),
                Confidence:        float64(recording.Score) / 100.0,
                RecognitionMethod: "metadata_search",
                APIProvider:       "MusicBrainz",
                MusicBrainzID:     recording.ID,
        }

        // Extract artist information
        if len(recording.ArtistCredit) &gt; 0 </span><span class="cov0" title="0">{
                result.Artist = recording.ArtistCredit[0].Artist.Name
                result.AlbumArtist = recording.ArtistCredit[0].Artist.Name
        }</span>

        // Extract release information
        <span class="cov0" title="0">if len(recording.Releases) &gt; 0 </span><span class="cov0" title="0">{
                release := recording.Releases[0]
                result.Album = release.Title
                if release.Date != "" </span><span class="cov0" title="0">{
                        result.Year = p.parseYear(release.Date)
                }</span>
        }

        // Extract genres
        <span class="cov0" title="0">for _, genre := range recording.Genres </span><span class="cov0" title="0">{
                result.Genres = append(result.Genres, genre.Name)
        }</span>

        // Extract tags
        <span class="cov0" title="0">for _, tag := range recording.Tags </span><span class="cov0" title="0">{
                result.Tags = append(result.Tags, tag.Name)
        }</span>

        // Set external IDs
        <span class="cov0" title="0">result.ExternalIDs = map[string]string{
                "musicbrainz": recording.ID,
        }
        if len(recording.ISRCs) &gt; 0 </span><span class="cov0" title="0">{
                result.ExternalIDs["isrc"] = recording.ISRCs[0]
        }</span>

        <span class="cov0" title="0">return result</span>
}

func (p *MusicRecognitionProvider) enhanceMusicResult(result *MediaRecognitionResult, mbRecording *MusicBrainzRecording) <span class="cov0" title="0">{
        // Add additional metadata from MusicBrainz
        if result.Title == "" </span><span class="cov0" title="0">{
                result.Title = mbRecording.Title
        }</span>

        // Add genres if not present
        <span class="cov0" title="0">if len(result.Genres) == 0 </span><span class="cov0" title="0">{
                for _, genre := range mbRecording.Genres </span><span class="cov0" title="0">{
                        result.Genres = append(result.Genres, genre.Name)
                }</span>
        }

        // Add tags if not present
        <span class="cov0" title="0">if len(result.Tags) == 0 </span><span class="cov0" title="0">{
                for _, tag := range mbRecording.Tags </span><span class="cov0" title="0">{
                        result.Tags = append(result.Tags, tag.Name)
                }</span>
        }

        // Add ISRC if available
        <span class="cov0" title="0">if len(mbRecording.ISRCs) &gt; 0 &amp;&amp; result.ExternalIDs != nil </span><span class="cov0" title="0">{
                result.ExternalIDs["isrc"] = mbRecording.ISRCs[0]
        }</span>
}

func (p *MusicRecognitionProvider) basicMusicRecognition(req *MediaRecognitionRequest, title, artist, album string, trackNumber int) *MediaRecognitionResult <span class="cov0" title="0">{
        // Basic fallback recognition
        mediaType := req.MediaType
        if mediaType == "" </span><span class="cov0" title="0">{
                mediaType = p.determineAudioMediaType(title)
        }</span>

        <span class="cov0" title="0">return &amp;MediaRecognitionResult{
                MediaID:           fmt.Sprintf("basic_music_%s_%d", strings.ReplaceAll(title, " ", "_"), time.Now().Unix()),
                MediaType:         mediaType,
                Title:             title,
                Artist:            artist,
                Album:             album,
                TrackNumber:       trackNumber,
                Confidence:        0.3, // Low confidence for basic recognition
                RecognitionMethod: "filename_parsing",
                APIProvider:       "basic",
                ExternalIDs:       make(map[string]string),
        }</span>
}

// Audio fingerprinting implementation
func (p *MusicRecognitionProvider) generateAudioFingerprint(audioSample []byte) (*AudioFingerprint, error) <span class="cov0" title="0">{
        // This is a simplified fingerprinting implementation
        // In production, you would use libraries like chromaprint or similar

        // Generate MD5 hash of audio sample as basic fingerprint
        hash := md5.Sum(audioSample)
        fingerprintHash := hex.EncodeToString(hash[:])

        // Extract basic audio features (simplified)
        analysis := p.analyzeAudioFeatures(audioSample)

        fingerprint := &amp;AudioFingerprint{
                Algorithm:  "md5_basic",
                Hash:       fingerprintHash,
                Duration:   analysis.Duration,
                SampleRate: analysis.SampleRate,
                Channels:   analysis.Channels,
                Features: map[string]float64{
                        "energy":  analysis.Energy,
                        "tempo":   analysis.Tempo,
                        "valence": analysis.Valence,
                },
                Segments: p.generateFingerprintSegments(audioSample, analysis),
        }

        return fingerprint, nil
}</span>

func (p *MusicRecognitionProvider) analyzeAudioFeatures(audioSample []byte) *AudioFingerprintAnalysis <span class="cov0" title="0">{
        // Simplified audio analysis
        // In production, use proper audio analysis libraries

        analysis := &amp;AudioFingerprintAnalysis{
                Duration:   float64(len(audioSample)) / 44100.0 / 2.0, // Assume 44.1kHz stereo
                SampleRate: 44100,
                Channels:   2,
                BitRate:    1411,                                      // CD quality
                Tempo:      120.0 + float64(len(audioSample)%60),      // Mock tempo
                Energy:     0.5 + float64(len(audioSample)%100)/200.0, // Mock energy
                Valence:    0.5 + float64(len(audioSample)%50)/100.0,  // Mock valence
        }

        // Generate mock features
        analysis.ChromaFeatures = make([]float64, 12)
        analysis.MFCCFeatures = make([]float64, 13)

        for i := range analysis.ChromaFeatures </span><span class="cov0" title="0">{
                analysis.ChromaFeatures[i] = float64(audioSample[i%len(audioSample)]) / 255.0
        }</span>

        <span class="cov0" title="0">for i := range analysis.MFCCFeatures </span><span class="cov0" title="0">{
                analysis.MFCCFeatures[i] = float64(audioSample[(i*10)%len(audioSample)]) / 255.0
        }</span>

        <span class="cov0" title="0">return analysis</span>
}

func (p *MusicRecognitionProvider) generateFingerprintSegments(audioSample []byte, analysis *AudioFingerprintAnalysis) []FingerprintSegment <span class="cov0" title="0">{
        segments := make([]FingerprintSegment, 0)
        segmentDuration := 10.0 // 10 second segments

        numSegments := int(math.Ceil(analysis.Duration / segmentDuration))
        for i := 0; i &lt; numSegments; i++ </span><span class="cov0" title="0">{
                startTime := float64(i) * segmentDuration
                endTime := math.Min(startTime+segmentDuration, analysis.Duration)

                // Generate segment hash
                segmentStart := int(startTime * float64(analysis.SampleRate) * float64(analysis.Channels))
                segmentEnd := int(endTime * float64(analysis.SampleRate) * float64(analysis.Channels))

                if segmentEnd &gt; len(audioSample) </span><span class="cov0" title="0">{
                        segmentEnd = len(audioSample)
                }</span>
                <span class="cov0" title="0">if segmentStart &gt;= segmentEnd </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">segmentData := audioSample[segmentStart:segmentEnd]
                hash := md5.Sum(segmentData)
                segmentHash := hex.EncodeToString(hash[:])

                segment := FingerprintSegment{
                        StartTime: startTime,
                        EndTime:   endTime,
                        Hash:      segmentHash,
                        Features: map[string]float64{
                                "energy": analysis.Energy * (0.8 + 0.4*float64(i%3)/2.0),
                                "tempo":  analysis.Tempo * (0.9 + 0.2*float64(i%5)/4.0),
                        },
                }

                segments = append(segments, segment)</span>
        }

        <span class="cov0" title="0">return segments</span>
}

// Helper methods
func (p *MusicRecognitionProvider) extractMusicMetadataFromFilename(filename string) (title, artist, album string) <span class="cov0" title="0">{
        // Remove file extension
        name := strings.TrimSuffix(filename, "."+p.getFileExtension(filename))

        // Common patterns for music files:
        // Artist - Title
        // Artist - Album - Track Number - Title
        // Track Number - Artist - Title
        // Album - Track Number - Artist - Title

        // Pattern: Artist - Title
        if parts := strings.Split(name, " - "); len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                artist = strings.TrimSpace(parts[0])
                title = strings.TrimSpace(parts[1])

                // If there are more parts, try to identify album
                if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                        // Check if second part looks like album or track number
                        if !p.looksLikeTrackNumber(parts[1]) </span><span class="cov0" title="0">{
                                album = strings.TrimSpace(parts[1])
                                title = strings.TrimSpace(parts[2])
                        }</span>
                }

                <span class="cov0" title="0">return title, artist, album</span>
        }

        // Pattern: Track Number - Title
        <span class="cov0" title="0">trackNumPattern := regexp.MustCompile(`^(\d+)[\s\-\.]+(.+)$`)
        if matches := trackNumPattern.FindStringSubmatch(name); len(matches) == 3 </span><span class="cov0" title="0">{
                title = strings.TrimSpace(matches[2])
                // Try to extract artist from title if it contains " - "
                if parts := strings.Split(title, " - "); len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        artist = strings.TrimSpace(parts[0])
                        title = strings.TrimSpace(parts[1])
                }</span>
                <span class="cov0" title="0">return title, artist, album</span>
        }

        // Fallback: use filename as title
        <span class="cov0" title="0">title = name
        return title, artist, album</span>
}

func (p *MusicRecognitionProvider) extractTrackNumber(filename string) int <span class="cov0" title="0">{
        // Look for track number at the beginning
        trackNumPattern := regexp.MustCompile(`^(\d+)[\s\-\.]`)
        if matches := trackNumPattern.FindStringSubmatch(filename); len(matches) &gt;= 2 </span><span class="cov0" title="0">{
                if trackNum, err := strconv.Atoi(matches[1]); err == nil </span><span class="cov0" title="0">{
                        return trackNum
                }</span>
        }

        // Look for track number pattern like "Track 01" or "01 -"
        <span class="cov0" title="0">trackPattern := regexp.MustCompile(`(?i)track\s*(\d+)|(\d+)\s*[-\.]`)
        if matches := trackPattern.FindStringSubmatch(filename); len(matches) &gt;= 2 </span><span class="cov0" title="0">{
                for i := 1; i &lt; len(matches); i++ </span><span class="cov0" title="0">{
                        if matches[i] != "" </span><span class="cov0" title="0">{
                                if trackNum, err := strconv.Atoi(matches[i]); err == nil </span><span class="cov0" title="0">{
                                        return trackNum
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return 0</span>
}

func (p *MusicRecognitionProvider) looksLikeTrackNumber(str string) bool <span class="cov0" title="0">{
        // Check if string looks like a track number
        trackPattern := regexp.MustCompile(`^\d{1,3}$`)
        return trackPattern.MatchString(strings.TrimSpace(str))
}</span>

func (p *MusicRecognitionProvider) determineAudioMediaType(title string) MediaType <span class="cov0" title="0">{
        title = strings.ToLower(title)

        // Check for audiobook patterns
        audiobookPatterns := []string{"audiobook", "narrated", "narrator", "chapter", "audio book"}
        for _, pattern := range audiobookPatterns </span><span class="cov0" title="0">{
                if strings.Contains(title, pattern) </span><span class="cov0" title="0">{
                        return MediaTypeAudiobook
                }</span>
        }

        // Check for podcast patterns
        <span class="cov0" title="0">podcastPatterns := []string{"podcast", "episode", "ep.", "show"}
        for _, pattern := range podcastPatterns </span><span class="cov0" title="0">{
                if strings.Contains(title, pattern) </span><span class="cov0" title="0">{
                        return MediaTypePodcast
                }</span>
        }

        // Default to music
        <span class="cov0" title="0">return MediaTypeMusic</span>
}

func (p *MusicRecognitionProvider) getFileExtension(filename string) string <span class="cov0" title="0">{
        parts := strings.Split(filename, ".")
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                return parts[len(parts)-1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (p *MusicRecognitionProvider) parseYear(dateStr string) int <span class="cov0" title="0">{
        if len(dateStr) &gt;= 4 </span><span class="cov0" title="0">{
                if year, err := strconv.Atoi(dateStr[:4]); err == nil </span><span class="cov0" title="0">{
                        return year
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func (p *MusicRecognitionProvider) calculateLastFMConfidence(listeners, playcount string) float64 <span class="cov0" title="0">{
        confidence := 0.5

        if l, err := strconv.Atoi(listeners); err == nil &amp;&amp; l &gt; 1000 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">if p, err := strconv.Atoi(playcount); err == nil &amp;&amp; p &gt; 10000 </span><span class="cov0" title="0">{
                confidence += 0.2
        }</span>

        <span class="cov0" title="0">return confidence</span>
}

func (p *MusicRecognitionProvider) generateID(title, artist string) string <span class="cov0" title="0">{
        combined := fmt.Sprintf("%s_%s", title, artist)
        hash := md5.Sum([]byte(combined))
        return hex.EncodeToString(hash[:])[:12]
}</span>

// RecognitionProvider interface implementation
func (p *MusicRecognitionProvider) GetProviderName() string <span class="cov0" title="0">{
        return "music_recognition"
}</span>

func (p *MusicRecognitionProvider) SupportsMediaType(mediaType MediaType) bool <span class="cov0" title="0">{
        supportedTypes := []MediaType{
                MediaTypeMusic,
                MediaTypeAlbum,
                MediaTypeAudiobook,
                MediaTypePodcast,
        }

        for _, supported := range supportedTypes </span><span class="cov0" title="0">{
                if mediaType == supported </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (p *MusicRecognitionProvider) GetConfidenceThreshold() float64 <span class="cov0" title="0">{
        return 0.4 // Minimum 40% confidence required
}</span>

// AcoustID API response structure
type AcoustIDResponse struct {
        Status  string           `json:"status"`
        Results []AcoustIDResult `json:"results"`
}

type AcoustIDResult struct {
        ID         string              `json:"id"`
        Score      float64             `json:"score"`
        Recordings []AcoustIDRecording `json:"recordings"`
}

type AcoustIDRecording struct {
        ID       string            `json:"id"`
        Title    string            `json:"title"`
        Duration float64           `json:"duration"`
        Artists  []AcoustIDArtist  `json:"artists"`
        Releases []AcoustIDRelease `json:"releases"`
}

type AcoustIDArtist struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

type AcoustIDRelease struct {
        ID      string `json:"id"`
        Title   string `json:"title"`
        Date    string `json:"date"`
        Country string `json:"country"`
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package services

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "go.uber.org/zap"
)

type PlaybackPositionService struct {
        db     *sql.DB
        logger *zap.Logger
}

type PlaybackPosition struct {
        ID              int64     `json:"id" db:"id"`
        UserID          int64     `json:"user_id" db:"user_id"`
        MediaItemID     int64     `json:"media_item_id" db:"media_item_id"`
        Position        int64     `json:"position" db:"position"` // Position in milliseconds
        Duration        int64     `json:"duration" db:"duration"` // Total duration in milliseconds
        PercentComplete float64   `json:"percent_complete" db:"percent_complete"`
        LastPlayed      time.Time `json:"last_played" db:"last_played"`
        IsCompleted     bool      `json:"is_completed" db:"is_completed"`
        DeviceInfo      string    `json:"device_info" db:"device_info"`
        PlaybackQuality string    `json:"playback_quality" db:"playback_quality"`
        CreatedAt       time.Time `json:"created_at" db:"created_at"`
        UpdatedAt       time.Time `json:"updated_at" db:"updated_at"`
}

type PlaybackBookmark struct {
        ID          int64     `json:"id" db:"id"`
        UserID      int64     `json:"user_id" db:"user_id"`
        MediaItemID int64     `json:"media_item_id" db:"media_item_id"`
        Position    int64     `json:"position" db:"position"`
        Name        string    `json:"name" db:"name"`
        Description string    `json:"description" db:"description"`
        CreatedAt   time.Time `json:"created_at" db:"created_at"`
}

type PlaybackHistory struct {
        ID              int64      `json:"id" db:"id"`
        UserID          int64      `json:"user_id" db:"user_id"`
        MediaItemID     int64      `json:"media_item_id" db:"media_item_id"`
        StartTime       time.Time  `json:"start_time" db:"start_time"`
        EndTime         *time.Time `json:"end_time" db:"end_time"`
        Duration        int64      `json:"duration" db:"duration"`
        PercentWatched  float64    `json:"percent_watched" db:"percent_watched"`
        DeviceInfo      string     `json:"device_info" db:"device_info"`
        PlaybackQuality string     `json:"playback_quality" db:"playback_quality"`
        WasCompleted    bool       `json:"was_completed" db:"was_completed"`
}

type UpdatePositionRequest struct {
        UserID          int64  `json:"user_id"`
        MediaItemID     int64  `json:"media_item_id"`
        Position        int64  `json:"position"`
        Duration        int64  `json:"duration"`
        DeviceInfo      string `json:"device_info"`
        PlaybackQuality string `json:"playback_quality"`
}

type BookmarkRequest struct {
        UserID      int64  `json:"user_id"`
        MediaItemID int64  `json:"media_item_id"`
        Position    int64  `json:"position"`
        Name        string `json:"name"`
        Description string `json:"description"`
}

type PlaybackStatsRequest struct {
        UserID    int64      `json:"user_id"`
        StartDate *time.Time `json:"start_date"`
        EndDate   *time.Time `json:"end_date"`
        MediaType string     `json:"media_type"`
        Limit     int        `json:"limit"`
}

type PlaybackStats struct {
        TotalPlaytime     int64             `json:"total_playtime"`
        TotalMediaItems   int64             `json:"total_media_items"`
        CompletedItems    int64             `json:"completed_items"`
        MostPlayedGenres  []GenreStats      `json:"most_played_genres"`
        RecentlyWatched   []PlaybackHistory `json:"recently_watched"`
        TopArtists        []ArtistStats     `json:"top_artists"`
        PlaybackByHour    map[string]int64  `json:"playback_by_hour"`
        WatchTimeByDevice map[string]int64  `json:"watch_time_by_device"`
}

type GenreStats struct {
        Genre    string `json:"genre"`
        Count    int64  `json:"count"`
        Duration int64  `json:"duration"`
}

type ArtistStats struct {
        Artist   string `json:"artist"`
        Count    int64  `json:"count"`
        Duration int64  `json:"duration"`
}

func NewPlaybackPositionService(db *sql.DB, logger *zap.Logger) *PlaybackPositionService <span class="cov0" title="0">{
        return &amp;PlaybackPositionService{
                db:     db,
                logger: logger,
        }
}</span>

func (s *PlaybackPositionService) UpdatePosition(ctx context.Context, req *UpdatePositionRequest) error <span class="cov0" title="0">{
        s.logger.Info("Updating playback position",
                zap.Int64("user_id", req.UserID),
                zap.Int64("media_item_id", req.MediaItemID),
                zap.Int64("position", req.Position),
                zap.Int64("duration", req.Duration))

        percentComplete := float64(req.Position) / float64(req.Duration) * 100
        isCompleted := percentComplete &gt;= 90.0

        query := `
                INSERT INTO playback_positions (
                        user_id, media_item_id, position, duration, percent_complete,
                        last_played, is_completed, device_info, playback_quality, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), NOW())
                ON CONFLICT (user_id, media_item_id)
                DO UPDATE SET
                        position = EXCLUDED.position,
                        duration = EXCLUDED.duration,
                        percent_complete = EXCLUDED.percent_complete,
                        last_played = EXCLUDED.last_played,
                        is_completed = EXCLUDED.is_completed,
                        device_info = EXCLUDED.device_info,
                        playback_quality = EXCLUDED.playback_quality,
                        updated_at = NOW()
        `

        _, err := s.db.ExecContext(ctx, query,
                req.UserID, req.MediaItemID, req.Position, req.Duration,
                percentComplete, time.Now(), isCompleted, req.DeviceInfo, req.PlaybackQuality)

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update playback position", zap.Error(err))
                return fmt.Errorf("failed to update playback position: %w", err)
        }</span>

        <span class="cov0" title="0">if isCompleted </span><span class="cov0" title="0">{
                if err := s.recordPlaybackHistory(ctx, req, true); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to record playback history", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaybackPositionService) GetPosition(ctx context.Context, userID, mediaItemID int64) (*PlaybackPosition, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting playback position",
                zap.Int64("user_id", userID),
                zap.Int64("media_item_id", mediaItemID))

        query := `
                SELECT id, user_id, media_item_id, position, duration, percent_complete,
                           last_played, is_completed, device_info, playback_quality, created_at, updated_at
                FROM playback_positions
                WHERE user_id = $1 AND media_item_id = $2
        `

        var position PlaybackPosition
        err := s.db.QueryRowContext(ctx, query, userID, mediaItemID).Scan(
                &amp;position.ID, &amp;position.UserID, &amp;position.MediaItemID,
                &amp;position.Position, &amp;position.Duration, &amp;position.PercentComplete,
                &amp;position.LastPlayed, &amp;position.IsCompleted, &amp;position.DeviceInfo,
                &amp;position.PlaybackQuality, &amp;position.CreatedAt, &amp;position.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get playback position", zap.Error(err))
                return nil, fmt.Errorf("failed to get playback position: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;position, nil</span>
}

func (s *PlaybackPositionService) GetContinueWatching(ctx context.Context, userID int64, limit int) ([]PlaybackPosition, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting continue watching list",
                zap.Int64("user_id", userID),
                zap.Int("limit", limit))

        query := `
                SELECT pp.id, pp.user_id, pp.media_item_id, pp.position, pp.duration,
                           pp.percent_complete, pp.last_played, pp.is_completed,
                           pp.device_info, pp.playback_quality, pp.created_at, pp.updated_at
                FROM playback_positions pp
                INNER JOIN media_items mi ON pp.media_item_id = mi.id
                WHERE pp.user_id = $1
                  AND pp.percent_complete BETWEEN 5 AND 90
                  AND pp.last_played &gt; NOW() - INTERVAL '30 days'
                ORDER BY pp.last_played DESC
                LIMIT $2
        `

        rows, err := s.db.QueryContext(ctx, query, userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get continue watching list", zap.Error(err))
                return nil, fmt.Errorf("failed to get continue watching: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var positions []PlaybackPosition
        for rows.Next() </span><span class="cov0" title="0">{
                var position PlaybackPosition
                err := rows.Scan(
                        &amp;position.ID, &amp;position.UserID, &amp;position.MediaItemID,
                        &amp;position.Position, &amp;position.Duration, &amp;position.PercentComplete,
                        &amp;position.LastPlayed, &amp;position.IsCompleted, &amp;position.DeviceInfo,
                        &amp;position.PlaybackQuality, &amp;position.CreatedAt, &amp;position.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to scan playback position", zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">positions = append(positions, position)</span>
        }

        <span class="cov0" title="0">return positions, nil</span>
}

func (s *PlaybackPositionService) CreateBookmark(ctx context.Context, req *BookmarkRequest) (*PlaybackBookmark, error) <span class="cov0" title="0">{
        s.logger.Info("Creating playback bookmark",
                zap.Int64("user_id", req.UserID),
                zap.Int64("media_item_id", req.MediaItemID),
                zap.String("name", req.Name))

        query := `
                INSERT INTO playback_bookmarks (user_id, media_item_id, position, name, description, created_at)
                VALUES ($1, $2, $3, $4, $5, NOW())
                RETURNING id, created_at
        `

        var bookmark PlaybackBookmark
        err := s.db.QueryRowContext(ctx, query,
                req.UserID, req.MediaItemID, req.Position, req.Name, req.Description).Scan(
                &amp;bookmark.ID, &amp;bookmark.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create bookmark", zap.Error(err))
                return nil, fmt.Errorf("failed to create bookmark: %w", err)
        }</span>

        <span class="cov0" title="0">bookmark.UserID = req.UserID
        bookmark.MediaItemID = req.MediaItemID
        bookmark.Position = req.Position
        bookmark.Name = req.Name
        bookmark.Description = req.Description

        return &amp;bookmark, nil</span>
}

func (s *PlaybackPositionService) GetBookmarks(ctx context.Context, userID, mediaItemID int64) ([]PlaybackBookmark, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting bookmarks",
                zap.Int64("user_id", userID),
                zap.Int64("media_item_id", mediaItemID))

        query := `
                SELECT id, user_id, media_item_id, position, name, description, created_at
                FROM playback_bookmarks
                WHERE user_id = $1 AND media_item_id = $2
                ORDER BY position ASC
        `

        rows, err := s.db.QueryContext(ctx, query, userID, mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get bookmarks", zap.Error(err))
                return nil, fmt.Errorf("failed to get bookmarks: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var bookmarks []PlaybackBookmark
        for rows.Next() </span><span class="cov0" title="0">{
                var bookmark PlaybackBookmark
                err := rows.Scan(
                        &amp;bookmark.ID, &amp;bookmark.UserID, &amp;bookmark.MediaItemID,
                        &amp;bookmark.Position, &amp;bookmark.Name, &amp;bookmark.Description,
                        &amp;bookmark.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to scan bookmark", zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">bookmarks = append(bookmarks, bookmark)</span>
        }

        <span class="cov0" title="0">return bookmarks, nil</span>
}

func (s *PlaybackPositionService) DeleteBookmark(ctx context.Context, userID, bookmarkID int64) error <span class="cov0" title="0">{
        s.logger.Info("Deleting bookmark",
                zap.Int64("user_id", userID),
                zap.Int64("bookmark_id", bookmarkID))

        query := `DELETE FROM playback_bookmarks WHERE id = $1 AND user_id = $2`

        result, err := s.db.ExecContext(ctx, query, bookmarkID, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to delete bookmark", zap.Error(err))
                return fmt.Errorf("failed to delete bookmark: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("bookmark not found or access denied")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaybackPositionService) GetPlaybackStats(ctx context.Context, req *PlaybackStatsRequest) (*PlaybackStats, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting playback statistics",
                zap.Int64("user_id", req.UserID))

        stats := &amp;PlaybackStats{
                MostPlayedGenres:  make([]GenreStats, 0),
                RecentlyWatched:   make([]PlaybackHistory, 0),
                TopArtists:        make([]ArtistStats, 0),
                PlaybackByHour:    make(map[string]int64),
                WatchTimeByDevice: make(map[string]int64),
        }

        if err := s.getTotalPlaytime(ctx, req, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get total playtime", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.getRecentlyWatched(ctx, req, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get recently watched", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.getPlaybackByHour(ctx, req, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get playback by hour", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.getWatchTimeByDevice(ctx, req, stats); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get watch time by device", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (s *PlaybackPositionService) recordPlaybackHistory(ctx context.Context, req *UpdatePositionRequest, completed bool) error <span class="cov0" title="0">{
        query := `
                INSERT INTO playback_history (
                        user_id, media_item_id, start_time, end_time, duration,
                        percent_watched, device_info, playback_quality, was_completed
                ) VALUES ($1, $2, NOW() - INTERVAL '%d milliseconds', NOW(), $3, $4, $5, $6, $7)
        `

        percentWatched := float64(req.Position) / float64(req.Duration) * 100

        _, err := s.db.ExecContext(ctx, fmt.Sprintf(query, req.Position),
                req.UserID, req.MediaItemID, req.Duration, percentWatched,
                req.DeviceInfo, req.PlaybackQuality, completed)

        return err
}</span>

func (s *PlaybackPositionService) getTotalPlaytime(ctx context.Context, req *PlaybackStatsRequest, stats *PlaybackStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        COALESCE(SUM(duration), 0) as total_playtime,
                        COUNT(*) as total_items,
                        COUNT(CASE WHEN was_completed THEN 1 END) as completed_items
                FROM playback_history
                WHERE user_id = $1
        `

        args := []interface{}{req.UserID}
        if req.StartDate != nil </span><span class="cov0" title="0">{
                query += " AND start_time &gt;= $2"
                args = append(args, *req.StartDate)
        }</span>
        <span class="cov0" title="0">if req.EndDate != nil </span><span class="cov0" title="0">{
                if req.StartDate != nil </span><span class="cov0" title="0">{
                        query += " AND start_time &lt;= $3"
                }</span> else<span class="cov0" title="0"> {
                        query += " AND start_time &lt;= $2"
                }</span>
                <span class="cov0" title="0">args = append(args, *req.EndDate)</span>
        }

        <span class="cov0" title="0">err := s.db.QueryRowContext(ctx, query, args...).Scan(
                &amp;stats.TotalPlaytime, &amp;stats.TotalMediaItems, &amp;stats.CompletedItems)

        return err</span>
}

func (s *PlaybackPositionService) getRecentlyWatched(ctx context.Context, req *PlaybackStatsRequest, stats *PlaybackStats) error <span class="cov0" title="0">{
        limit := req.Limit
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">query := `
                SELECT id, user_id, media_item_id, start_time, end_time, duration,
                           percent_watched, device_info, playback_quality, was_completed
                FROM playback_history
                WHERE user_id = $1
                ORDER BY start_time DESC
                LIMIT $2
        `

        rows, err := s.db.QueryContext(ctx, query, req.UserID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var history PlaybackHistory
                err := rows.Scan(
                        &amp;history.ID, &amp;history.UserID, &amp;history.MediaItemID,
                        &amp;history.StartTime, &amp;history.EndTime, &amp;history.Duration,
                        &amp;history.PercentWatched, &amp;history.DeviceInfo,
                        &amp;history.PlaybackQuality, &amp;history.WasCompleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">stats.RecentlyWatched = append(stats.RecentlyWatched, history)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaybackPositionService) getPlaybackByHour(ctx context.Context, req *PlaybackStatsRequest, stats *PlaybackStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        EXTRACT(HOUR FROM start_time) as hour,
                        COUNT(*) as count
                FROM playback_history
                WHERE user_id = $1
                GROUP BY EXTRACT(HOUR FROM start_time)
                ORDER BY hour
        `

        rows, err := s.db.QueryContext(ctx, query, req.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var hour int
                var count int64
                err := rows.Scan(&amp;hour, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">stats.PlaybackByHour[fmt.Sprintf("%02d:00", hour)] = count</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaybackPositionService) getWatchTimeByDevice(ctx context.Context, req *PlaybackStatsRequest, stats *PlaybackStats) error <span class="cov0" title="0">{
        query := `
                SELECT
                        device_info,
                        SUM(duration) as total_duration
                FROM playback_history
                WHERE user_id = $1
                GROUP BY device_info
                ORDER BY total_duration DESC
        `

        rows, err := s.db.QueryContext(ctx, query, req.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var device string
                var duration int64
                err := rows.Scan(&amp;device, &amp;duration)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">stats.WatchTimeByDevice[device] = duration</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaybackPositionService) CleanupOldPositions(ctx context.Context, olderThan time.Duration) error <span class="cov0" title="0">{
        s.logger.Info("Cleaning up old playback positions",
                zap.Duration("older_than", olderThan))

        query := `
                DELETE FROM playback_positions
                WHERE last_played &lt; $1 AND is_completed = true
        `

        cutoff := time.Now().Add(-olderThan)
        result, err := s.db.ExecContext(ctx, query, cutoff)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to cleanup old positions", zap.Error(err))
                return fmt.Errorf("failed to cleanup old positions: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        s.logger.Info("Cleaned up old playback positions",
                zap.Int64("rows_affected", rowsAffected))

        return nil</span>
}

func (s *PlaybackPositionService) SyncAcrossDevices(ctx context.Context, userID int64) error <span class="cov0" title="0">{
        s.logger.Debug("Syncing playback positions across devices",
                zap.Int64("user_id", userID))

        return nil
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "go.uber.org/zap"
)

type PlaylistService struct {
        db     *sql.DB
        logger *zap.Logger
}

type Playlist struct {
        ID              int64      `json:"id" db:"id"`
        UserID          int64      `json:"user_id" db:"user_id"`
        Name            string     `json:"name" db:"name"`
        Description     string     `json:"description" db:"description"`
        IsPublic        bool       `json:"is_public" db:"is_public"`
        IsSmartPlaylist bool       `json:"is_smart_playlist" db:"is_smart_playlist"`
        SmartCriteria   string     `json:"smart_criteria" db:"smart_criteria"`
        CoverArtURL     string     `json:"cover_art_url" db:"cover_art_url"`
        TrackCount      int        `json:"track_count" db:"track_count"`
        TotalDuration   int64      `json:"total_duration" db:"total_duration"`
        PlayCount       int64      `json:"play_count" db:"play_count"`
        LastPlayed      *time.Time `json:"last_played" db:"last_played"`
        CreatedAt       time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt       time.Time  `json:"updated_at" db:"updated_at"`
        Tags            []string   `json:"tags"`
        CollaboratorIDs []int64    `json:"collaborator_ids"`
}

type PlaylistItem struct {
        ID          int64     `json:"id" db:"id"`
        PlaylistID  int64     `json:"playlist_id" db:"playlist_id"`
        MediaItemID int64     `json:"media_item_id" db:"media_item_id"`
        Position    int       `json:"position" db:"position"`
        AddedBy     int64     `json:"added_by" db:"added_by"`
        AddedAt     time.Time `json:"added_at" db:"added_at"`
        CustomTitle string    `json:"custom_title" db:"custom_title"`
        StartTime   *int64    `json:"start_time" db:"start_time"`
        EndTime     *int64    `json:"end_time" db:"end_time"`
}

type PlaybackQueue struct {
        ID              int64     `json:"id" db:"id"`
        UserID          int64     `json:"user_id" db:"user_id"`
        Name            string    `json:"name" db:"name"`
        CurrentItemID   *int64    `json:"current_item_id" db:"current_item_id"`
        CurrentPosition int       `json:"current_position" db:"current_position"`
        ShuffleEnabled  bool      `json:"shuffle_enabled" db:"shuffle_enabled"`
        RepeatMode      string    `json:"repeat_mode" db:"repeat_mode"` // none, track, playlist
        ShuffleHistory  string    `json:"shuffle_history" db:"shuffle_history"`
        CreatedAt       time.Time `json:"created_at" db:"created_at"`
        UpdatedAt       time.Time `json:"updated_at" db:"updated_at"`
}

type QueueItem struct {
        ID               int64     `json:"id" db:"id"`
        QueueID          int64     `json:"queue_id" db:"queue_id"`
        MediaItemID      int64     `json:"media_item_id" db:"media_item_id"`
        Position         int       `json:"position" db:"position"`
        OriginalPosition int       `json:"original_position" db:"original_position"`
        PlayCount        int       `json:"play_count" db:"play_count"`
        AddedAt          time.Time `json:"added_at" db:"added_at"`
}

type SmartPlaylistCriteria struct {
        Rules []SmartRule `json:"rules"`
        Logic string      `json:"logic"` // "AND" or "OR"
        Limit int         `json:"limit"`
        Order string      `json:"order"` // "added_desc", "added_asc", "play_count_desc", "random", etc.
}

type SmartRule struct {
        Field    string      `json:"field"`    // "genre", "artist", "album", "year", "rating", "play_count", etc.
        Operator string      `json:"operator"` // "equals", "contains", "greater_than", "less_than", "in", etc.
        Value    interface{} `json:"value"`
}

type CreatePlaylistRequest struct {
        UserID          int64                  `json:"user_id"`
        Name            string                 `json:"name"`
        Description     string                 `json:"description"`
        IsPublic        bool                   `json:"is_public"`
        IsSmartPlaylist bool                   `json:"is_smart_playlist"`
        SmartCriteria   *SmartPlaylistCriteria `json:"smart_criteria"`
        Tags            []string               `json:"tags"`
        CollaboratorIDs []int64                `json:"collaborator_ids"`
}

type UpdatePlaylistRequest struct {
        ID              int64    `json:"id"`
        UserID          int64    `json:"user_id"`
        Name            *string  `json:"name"`
        Description     *string  `json:"description"`
        IsPublic        *bool    `json:"is_public"`
        CoverArtURL     *string  `json:"cover_art_url"`
        Tags            []string `json:"tags"`
        CollaboratorIDs []int64  `json:"collaborator_ids"`
}

type AddToPlaylistRequest struct {
        PlaylistID   int64            `json:"playlist_id"`
        MediaItemIDs []int64          `json:"media_item_ids"`
        UserID       int64            `json:"user_id"`
        Position     *int             `json:"position"`
        CustomTitles map[int64]string `json:"custom_titles"`
}

type ReorderPlaylistRequest struct {
        PlaylistID  int64 `json:"playlist_id"`
        UserID      int64 `json:"user_id"`
        ItemID      int64 `json:"item_id"`
        NewPosition int   `json:"new_position"`
}

type PlaylistSearchRequest struct {
        UserID   int64    `json:"user_id"`
        Query    string   `json:"query"`
        IsPublic *bool    `json:"is_public"`
        Tags     []string `json:"tags"`
        Limit    int      `json:"limit"`
        Offset   int      `json:"offset"`
}

func NewPlaylistService(db *sql.DB, logger *zap.Logger) *PlaylistService <span class="cov0" title="0">{
        return &amp;PlaylistService{
                db:     db,
                logger: logger,
        }
}</span>

func (s *PlaylistService) CreatePlaylist(ctx context.Context, req *CreatePlaylistRequest) (*Playlist, error) <span class="cov0" title="0">{
        s.logger.Info("Creating playlist",
                zap.Int64("user_id", req.UserID),
                zap.String("name", req.Name),
                zap.Bool("is_smart", req.IsSmartPlaylist))

        var smartCriteriaJSON string
        if req.SmartCriteria != nil </span><span class="cov0" title="0">{
                criteriaBytes, err := json.Marshal(req.SmartCriteria)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal smart criteria: %w", err)
                }</span>
                <span class="cov0" title="0">smartCriteriaJSON = string(criteriaBytes)</span>
        }

        <span class="cov0" title="0">query := `
                INSERT INTO playlists (
                        user_id, name, description, is_public, is_smart_playlist,
                        smart_criteria, track_count, total_duration, play_count,
                        created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, 0, 0, 0, NOW(), NOW())
                RETURNING id, created_at, updated_at
        `

        var playlist Playlist
        err := s.db.QueryRowContext(ctx, query,
                req.UserID, req.Name, req.Description, req.IsPublic,
                req.IsSmartPlaylist, smartCriteriaJSON).Scan(
                &amp;playlist.ID, &amp;playlist.CreatedAt, &amp;playlist.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create playlist", zap.Error(err))
                return nil, fmt.Errorf("failed to create playlist: %w", err)
        }</span>

        <span class="cov0" title="0">playlist.UserID = req.UserID
        playlist.Name = req.Name
        playlist.Description = req.Description
        playlist.IsPublic = req.IsPublic
        playlist.IsSmartPlaylist = req.IsSmartPlaylist
        playlist.SmartCriteria = smartCriteriaJSON
        playlist.Tags = req.Tags
        playlist.CollaboratorIDs = req.CollaboratorIDs

        if len(req.Tags) &gt; 0 </span><span class="cov0" title="0">{
                if err := s.updatePlaylistTags(ctx, playlist.ID, req.Tags); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to add tags to playlist", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">if len(req.CollaboratorIDs) &gt; 0 </span><span class="cov0" title="0">{
                if err := s.updatePlaylistCollaborators(ctx, playlist.ID, req.CollaboratorIDs); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to add collaborators to playlist", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">if req.IsSmartPlaylist &amp;&amp; req.SmartCriteria != nil </span><span class="cov0" title="0">{
                if err := s.RefreshSmartPlaylist(ctx, playlist.ID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to populate smart playlist", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return &amp;playlist, nil</span>
}

func (s *PlaylistService) GetPlaylist(ctx context.Context, playlistID, userID int64) (*Playlist, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting playlist",
                zap.Int64("playlist_id", playlistID),
                zap.Int64("user_id", userID))

        query := `
                SELECT p.id, p.user_id, p.name, p.description, p.is_public,
                           p.is_smart_playlist, p.smart_criteria, p.cover_art_url,
                           p.track_count, p.total_duration, p.play_count, p.last_played,
                           p.created_at, p.updated_at
                FROM playlists p
                LEFT JOIN playlist_collaborators pc ON p.id = pc.playlist_id
                WHERE p.id = $1
                  AND (p.user_id = $2 OR p.is_public = true OR pc.user_id = $2)
        `

        var playlist Playlist
        err := s.db.QueryRowContext(ctx, query, playlistID, userID).Scan(
                &amp;playlist.ID, &amp;playlist.UserID, &amp;playlist.Name, &amp;playlist.Description,
                &amp;playlist.IsPublic, &amp;playlist.IsSmartPlaylist, &amp;playlist.SmartCriteria,
                &amp;playlist.CoverArtURL, &amp;playlist.TrackCount, &amp;playlist.TotalDuration,
                &amp;playlist.PlayCount, &amp;playlist.LastPlayed, &amp;playlist.CreatedAt, &amp;playlist.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("playlist not found or access denied")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get playlist", zap.Error(err))
                return nil, fmt.Errorf("failed to get playlist: %w", err)
        }</span>

        <span class="cov0" title="0">playlist.Tags, _ = s.getPlaylistTags(ctx, playlistID)
        playlist.CollaboratorIDs, _ = s.getPlaylistCollaborators(ctx, playlistID)

        return &amp;playlist, nil</span>
}

func (s *PlaylistService) GetUserPlaylists(ctx context.Context, userID int64, includePublic bool) ([]Playlist, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting user playlists",
                zap.Int64("user_id", userID),
                zap.Bool("include_public", includePublic))

        baseQuery := `
                SELECT DISTINCT p.id, p.user_id, p.name, p.description, p.is_public,
                           p.is_smart_playlist, p.smart_criteria, p.cover_art_url,
                           p.track_count, p.total_duration, p.play_count, p.last_played,
                           p.created_at, p.updated_at
                FROM playlists p
                LEFT JOIN playlist_collaborators pc ON p.id = pc.playlist_id
                WHERE p.user_id = $1 OR pc.user_id = $1
        `

        if includePublic </span><span class="cov0" title="0">{
                baseQuery += " OR p.is_public = true"
        }</span>

        <span class="cov0" title="0">baseQuery += " ORDER BY p.updated_at DESC"

        rows, err := s.db.QueryContext(ctx, baseQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get user playlists", zap.Error(err))
                return nil, fmt.Errorf("failed to get user playlists: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var playlists []Playlist
        for rows.Next() </span><span class="cov0" title="0">{
                var playlist Playlist
                err := rows.Scan(
                        &amp;playlist.ID, &amp;playlist.UserID, &amp;playlist.Name, &amp;playlist.Description,
                        &amp;playlist.IsPublic, &amp;playlist.IsSmartPlaylist, &amp;playlist.SmartCriteria,
                        &amp;playlist.CoverArtURL, &amp;playlist.TrackCount, &amp;playlist.TotalDuration,
                        &amp;playlist.PlayCount, &amp;playlist.LastPlayed, &amp;playlist.CreatedAt, &amp;playlist.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to scan playlist", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">playlist.Tags, _ = s.getPlaylistTags(ctx, playlist.ID)
                playlist.CollaboratorIDs, _ = s.getPlaylistCollaborators(ctx, playlist.ID)

                playlists = append(playlists, playlist)</span>
        }

        <span class="cov0" title="0">return playlists, nil</span>
}

func (s *PlaylistService) AddToPlaylist(ctx context.Context, req *AddToPlaylistRequest) error <span class="cov0" title="0">{
        s.logger.Info("Adding items to playlist",
                zap.Int64("playlist_id", req.PlaylistID),
                zap.Int("item_count", len(req.MediaItemIDs)))

        if !s.canModifyPlaylist(ctx, req.PlaylistID, req.UserID) </span><span class="cov0" title="0">{
                return fmt.Errorf("permission denied to modify playlist")
        }</span>

        <span class="cov0" title="0">tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        position := 0
        if req.Position != nil </span><span class="cov0" title="0">{
                position = *req.Position
        }</span> else<span class="cov0" title="0"> {
                err := tx.QueryRowContext(ctx,
                        "SELECT COALESCE(MAX(position), 0) + 1 FROM playlist_items WHERE playlist_id = $1",
                        req.PlaylistID).Scan(&amp;position)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get next position: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if req.Position != nil </span><span class="cov0" title="0">{
                _, err := tx.ExecContext(ctx,
                        "UPDATE playlist_items SET position = position + $1 WHERE playlist_id = $2 AND position &gt;= $3",
                        len(req.MediaItemIDs), req.PlaylistID, *req.Position)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to shift positions: %w", err)
                }</span>
        }

        <span class="cov0" title="0">for i, mediaItemID := range req.MediaItemIDs </span><span class="cov0" title="0">{
                customTitle := ""
                if req.CustomTitles != nil </span><span class="cov0" title="0">{
                        customTitle = req.CustomTitles[mediaItemID]
                }</span>

                <span class="cov0" title="0">_, err := tx.ExecContext(ctx, `
                        INSERT INTO playlist_items (playlist_id, media_item_id, position, added_by, added_at, custom_title)
                        VALUES ($1, $2, $3, $4, NOW(), $5)
                `, req.PlaylistID, mediaItemID, position+i, req.UserID, customTitle)

                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to add item to playlist", zap.Error(err))
                        return fmt.Errorf("failed to add item to playlist: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if err := s.updatePlaylistStats(ctx, tx, req.PlaylistID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update playlist stats: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaylistService) RemoveFromPlaylist(ctx context.Context, playlistID, itemID, userID int64) error <span class="cov0" title="0">{
        s.logger.Info("Removing item from playlist",
                zap.Int64("playlist_id", playlistID),
                zap.Int64("item_id", itemID))

        if !s.canModifyPlaylist(ctx, playlistID, userID) </span><span class="cov0" title="0">{
                return fmt.Errorf("permission denied to modify playlist")
        }</span>

        <span class="cov0" title="0">tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        var position int
        err = tx.QueryRowContext(ctx,
                "SELECT position FROM playlist_items WHERE id = $1 AND playlist_id = $2",
                itemID, playlistID).Scan(&amp;position)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("playlist item not found: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx,
                "DELETE FROM playlist_items WHERE id = $1 AND playlist_id = $2",
                itemID, playlistID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove item: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx,
                "UPDATE playlist_items SET position = position - 1 WHERE playlist_id = $1 AND position &gt; $2",
                playlistID, position)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update positions: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.updatePlaylistStats(ctx, tx, playlistID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update playlist stats: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaylistService) ReorderPlaylist(ctx context.Context, req *ReorderPlaylistRequest) error <span class="cov0" title="0">{
        s.logger.Info("Reordering playlist",
                zap.Int64("playlist_id", req.PlaylistID),
                zap.Int64("item_id", req.ItemID),
                zap.Int("new_position", req.NewPosition))

        if !s.canModifyPlaylist(ctx, req.PlaylistID, req.UserID) </span><span class="cov0" title="0">{
                return fmt.Errorf("permission denied to modify playlist")
        }</span>

        <span class="cov0" title="0">tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        var currentPosition int
        err = tx.QueryRowContext(ctx,
                "SELECT position FROM playlist_items WHERE id = $1 AND playlist_id = $2",
                req.ItemID, req.PlaylistID).Scan(&amp;currentPosition)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("playlist item not found: %w", err)
        }</span>

        <span class="cov0" title="0">if currentPosition &lt; req.NewPosition </span><span class="cov0" title="0">{
                _, err = tx.ExecContext(ctx, `
                        UPDATE playlist_items
                        SET position = position - 1
                        WHERE playlist_id = $1 AND position &gt; $2 AND position &lt;= $3
                `, req.PlaylistID, currentPosition, req.NewPosition)
        }</span> else<span class="cov0" title="0"> if currentPosition &gt; req.NewPosition </span><span class="cov0" title="0">{
                _, err = tx.ExecContext(ctx, `
                        UPDATE playlist_items
                        SET position = position + 1
                        WHERE playlist_id = $1 AND position &gt;= $2 AND position &lt; $3
                `, req.PlaylistID, req.NewPosition, currentPosition)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update positions: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx,
                "UPDATE playlist_items SET position = $1 WHERE id = $2",
                req.NewPosition, req.ItemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update item position: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaylistService) GetPlaylistItems(ctx context.Context, playlistID, userID int64, limit, offset int) ([]PlaylistItem, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting playlist items",
                zap.Int64("playlist_id", playlistID),
                zap.Int("limit", limit),
                zap.Int("offset", offset))

        query := `
                SELECT pi.id, pi.playlist_id, pi.media_item_id, pi.position,
                           pi.added_by, pi.added_at, pi.custom_title, pi.start_time, pi.end_time
                FROM playlist_items pi
                INNER JOIN playlists p ON pi.playlist_id = p.id
                LEFT JOIN playlist_collaborators pc ON p.id = pc.playlist_id
                WHERE pi.playlist_id = $1
                  AND (p.user_id = $2 OR p.is_public = true OR pc.user_id = $2)
                ORDER BY pi.position ASC
                LIMIT $3 OFFSET $4
        `

        rows, err := s.db.QueryContext(ctx, query, playlistID, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get playlist items", zap.Error(err))
                return nil, fmt.Errorf("failed to get playlist items: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var items []PlaylistItem
        for rows.Next() </span><span class="cov0" title="0">{
                var item PlaylistItem
                err := rows.Scan(
                        &amp;item.ID, &amp;item.PlaylistID, &amp;item.MediaItemID, &amp;item.Position,
                        &amp;item.AddedBy, &amp;item.AddedAt, &amp;item.CustomTitle, &amp;item.StartTime, &amp;item.EndTime,
                )
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to scan playlist item", zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items, nil</span>
}

func (s *PlaylistService) RefreshSmartPlaylist(ctx context.Context, playlistID int64) error <span class="cov0" title="0">{
        s.logger.Info("Refreshing smart playlist", zap.Int64("playlist_id", playlistID))

        playlist, err := s.GetPlaylist(ctx, playlistID, 0)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get playlist: %w", err)
        }</span>

        <span class="cov0" title="0">if !playlist.IsSmartPlaylist </span><span class="cov0" title="0">{
                return fmt.Errorf("playlist is not a smart playlist")
        }</span>

        <span class="cov0" title="0">var criteria SmartPlaylistCriteria
        if err := json.Unmarshal([]byte(playlist.SmartCriteria), &amp;criteria); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse smart criteria: %w", err)
        }</span>

        <span class="cov0" title="0">query, args := s.buildSmartPlaylistQuery(&amp;criteria)

        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        _, err = tx.ExecContext(ctx, "DELETE FROM playlist_items WHERE playlist_id = $1", playlistID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear playlist: %w", err)
        }</span>

        <span class="cov0" title="0">rows, err := tx.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute smart query: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        position := 1
        for rows.Next() </span><span class="cov0" title="0">{
                var mediaItemID int64
                err := rows.Scan(&amp;mediaItemID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">_, err = tx.ExecContext(ctx, `
                        INSERT INTO playlist_items (playlist_id, media_item_id, position, added_by, added_at)
                        VALUES ($1, $2, $3, $4, NOW())
                `, playlistID, mediaItemID, position, playlist.UserID)

                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to add smart playlist item", zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">position++</span>
        }

        <span class="cov0" title="0">if err := s.updatePlaylistStats(ctx, tx, playlistID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update playlist stats: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaylistService) CreateQueue(ctx context.Context, userID int64, name string) (*PlaybackQueue, error) <span class="cov0" title="0">{
        s.logger.Info("Creating playback queue",
                zap.Int64("user_id", userID),
                zap.String("name", name))

        query := `
                INSERT INTO playback_queues (user_id, name, current_position, shuffle_enabled, repeat_mode, created_at, updated_at)
                VALUES ($1, $2, 0, false, 'none', NOW(), NOW())
                RETURNING id, created_at, updated_at
        `

        var queue PlaybackQueue
        err := s.db.QueryRowContext(ctx, query, userID, name).Scan(
                &amp;queue.ID, &amp;queue.CreatedAt, &amp;queue.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create queue", zap.Error(err))
                return nil, fmt.Errorf("failed to create queue: %w", err)
        }</span>

        <span class="cov0" title="0">queue.UserID = userID
        queue.Name = name
        queue.CurrentPosition = 0
        queue.ShuffleEnabled = false
        queue.RepeatMode = "none"

        return &amp;queue, nil</span>
}

func (s *PlaylistService) AddToQueue(ctx context.Context, queueID int64, mediaItemIDs []int64) error <span class="cov0" title="0">{
        s.logger.Info("Adding items to queue",
                zap.Int64("queue_id", queueID),
                zap.Int("item_count", len(mediaItemIDs)))

        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        var position int
        err = tx.QueryRowContext(ctx,
                "SELECT COALESCE(MAX(position), 0) + 1 FROM queue_items WHERE queue_id = $1",
                queueID).Scan(&amp;position)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get next position: %w", err)
        }</span>

        <span class="cov0" title="0">for i, mediaItemID := range mediaItemIDs </span><span class="cov0" title="0">{
                _, err := tx.ExecContext(ctx, `
                        INSERT INTO queue_items (queue_id, media_item_id, position, original_position, play_count, added_at)
                        VALUES ($1, $2, $3, $4, 0, NOW())
                `, queueID, mediaItemID, position+i, position+i)

                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to add item to queue", zap.Error(err))
                        return fmt.Errorf("failed to add item to queue: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaylistService) ShuffleQueue(ctx context.Context, queueID int64, enabled bool) error <span class="cov0" title="0">{
        s.logger.Info("Setting queue shuffle",
                zap.Int64("queue_id", queueID),
                zap.Bool("enabled", enabled))

        _, err := s.db.ExecContext(ctx,
                "UPDATE playback_queues SET shuffle_enabled = $1, updated_at = NOW() WHERE id = $2",
                enabled, queueID)

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to update queue shuffle", zap.Error(err))
                return fmt.Errorf("failed to update queue shuffle: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *PlaylistService) canModifyPlaylist(ctx context.Context, playlistID, userID int64) bool <span class="cov0" title="0">{
        var count int
        query := `
                SELECT COUNT(*)
                FROM playlists p
                LEFT JOIN playlist_collaborators pc ON p.id = pc.playlist_id
                WHERE p.id = $1 AND (p.user_id = $2 OR pc.user_id = $2)
        `

        err := s.db.QueryRowContext(ctx, query, playlistID, userID).Scan(&amp;count)
        return err == nil &amp;&amp; count &gt; 0
}</span>

func (s *PlaylistService) updatePlaylistStats(ctx context.Context, tx *sql.Tx, playlistID int64) error <span class="cov0" title="0">{
        query := `
                UPDATE playlists
                SET track_count = (
                                SELECT COUNT(*) FROM playlist_items WHERE playlist_id = $1
                        ),
                        total_duration = (
                                SELECT COALESCE(SUM(mi.duration), 0)
                                FROM playlist_items pi
                                JOIN media_items mi ON pi.media_item_id = mi.id
                                WHERE pi.playlist_id = $1
                        ),
                        updated_at = NOW()
                WHERE id = $1
        `

        _, err := tx.ExecContext(ctx, query, playlistID)
        return err
}</span>

func (s *PlaylistService) updatePlaylistTags(ctx context.Context, playlistID int64, tags []string) error <span class="cov0" title="0">{
        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        _, err = tx.ExecContext(ctx, "DELETE FROM playlist_tags WHERE playlist_id = $1", playlistID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, tag := range tags </span><span class="cov0" title="0">{
                _, err = tx.ExecContext(ctx,
                        "INSERT INTO playlist_tags (playlist_id, tag) VALUES ($1, $2)",
                        playlistID, tag)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit()</span>
}

func (s *PlaylistService) updatePlaylistCollaborators(ctx context.Context, playlistID int64, collaboratorIDs []int64) error <span class="cov0" title="0">{
        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        _, err = tx.ExecContext(ctx, "DELETE FROM playlist_collaborators WHERE playlist_id = $1", playlistID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, userID := range collaboratorIDs </span><span class="cov0" title="0">{
                _, err = tx.ExecContext(ctx,
                        "INSERT INTO playlist_collaborators (playlist_id, user_id, added_at) VALUES ($1, $2, NOW())",
                        playlistID, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit()</span>
}

func (s *PlaylistService) getPlaylistTags(ctx context.Context, playlistID int64) ([]string, error) <span class="cov0" title="0">{
        rows, err := s.db.QueryContext(ctx,
                "SELECT tag FROM playlist_tags WHERE playlist_id = $1", playlistID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tags []string
        for rows.Next() </span><span class="cov0" title="0">{
                var tag string
                if err := rows.Scan(&amp;tag); err == nil </span><span class="cov0" title="0">{
                        tags = append(tags, tag)
                }</span>
        }
        <span class="cov0" title="0">return tags, nil</span>
}

func (s *PlaylistService) getPlaylistCollaborators(ctx context.Context, playlistID int64) ([]int64, error) <span class="cov0" title="0">{
        rows, err := s.db.QueryContext(ctx,
                "SELECT user_id FROM playlist_collaborators WHERE playlist_id = $1", playlistID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var collaborators []int64
        for rows.Next() </span><span class="cov0" title="0">{
                var userID int64
                if err := rows.Scan(&amp;userID); err == nil </span><span class="cov0" title="0">{
                        collaborators = append(collaborators, userID)
                }</span>
        }
        <span class="cov0" title="0">return collaborators, nil</span>
}

func (s *PlaylistService) buildSmartPlaylistQuery(criteria *SmartPlaylistCriteria) (string, []interface{}) <span class="cov0" title="0">{
        baseQuery := "SELECT DISTINCT mi.id FROM media_items mi WHERE "
        var conditions []string
        var args []interface{}
        argIndex := 1

        logic := "AND"
        if criteria.Logic == "OR" </span><span class="cov0" title="0">{
                logic = "OR"
        }</span>

        <span class="cov0" title="0">for _, rule := range criteria.Rules </span><span class="cov0" title="0">{
                condition, ruleArgs := s.buildRuleCondition(rule, &amp;argIndex)
                if condition != "" </span><span class="cov0" title="0">{
                        conditions = append(conditions, condition)
                        args = append(args, ruleArgs...)
                }</span>
        }

        <span class="cov0" title="0">if len(conditions) == 0 </span><span class="cov0" title="0">{
                return "SELECT id FROM media_items LIMIT 0", []interface{}{}
        }</span>

        <span class="cov0" title="0">query := baseQuery + "(" + strings.Join(conditions, " "+logic+" ") + ")"

        if criteria.Order != "" </span><span class="cov0" title="0">{
                query += " ORDER BY " + s.getOrderClause(criteria.Order)
        }</span>

        <span class="cov0" title="0">if criteria.Limit &gt; 0 </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" LIMIT %d", criteria.Limit)
        }</span>

        <span class="cov0" title="0">return query, args</span>
}

func (s *PlaylistService) buildRuleCondition(rule SmartRule, argIndex *int) (string, []interface{}) <span class="cov0" title="0">{
        var condition string
        var args []interface{}

        switch rule.Field </span>{
        case "genre":<span class="cov0" title="0">
                if rule.Operator == "equals" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.genre = $%d", *argIndex)
                        args = append(args, rule.Value)
                        *argIndex++
                }</span> else<span class="cov0" title="0"> if rule.Operator == "contains" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.genre ILIKE $%d", *argIndex)
                        args = append(args, "%"+rule.Value.(string)+"%")
                        *argIndex++
                }</span>
        case "artist":<span class="cov0" title="0">
                if rule.Operator == "equals" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.artist = $%d", *argIndex)
                        args = append(args, rule.Value)
                        *argIndex++
                }</span> else<span class="cov0" title="0"> if rule.Operator == "contains" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.artist ILIKE $%d", *argIndex)
                        args = append(args, "%"+rule.Value.(string)+"%")
                        *argIndex++
                }</span>
        case "year":<span class="cov0" title="0">
                if rule.Operator == "equals" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.year = $%d", *argIndex)
                        args = append(args, rule.Value)
                        *argIndex++
                }</span> else<span class="cov0" title="0"> if rule.Operator == "greater_than" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.year &gt; $%d", *argIndex)
                        args = append(args, rule.Value)
                        *argIndex++
                }</span> else<span class="cov0" title="0"> if rule.Operator == "less_than" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.year &lt; $%d", *argIndex)
                        args = append(args, rule.Value)
                        *argIndex++
                }</span>
        case "rating":<span class="cov0" title="0">
                if rule.Operator == "greater_than" </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("mi.rating &gt; $%d", *argIndex)
                        args = append(args, rule.Value)
                        *argIndex++
                }</span>
        }

        <span class="cov0" title="0">return condition, args</span>
}

func (s *PlaylistService) getOrderClause(order string) string <span class="cov0" title="0">{
        switch order </span>{
        case "added_desc":<span class="cov0" title="0">
                return "mi.created_at DESC"</span>
        case "added_asc":<span class="cov0" title="0">
                return "mi.created_at ASC"</span>
        case "play_count_desc":<span class="cov0" title="0">
                return "mi.play_count DESC"</span>
        case "rating_desc":<span class="cov0" title="0">
                return "mi.rating DESC"</span>
        case "random":<span class="cov0" title="0">
                return "RANDOM()"</span>
        case "title_asc":<span class="cov0" title="0">
                return "mi.title ASC"</span>
        case "artist_asc":<span class="cov0" title="0">
                return "mi.artist ASC, mi.album ASC, mi.track_number ASC"</span>
        default:<span class="cov0" title="0">
                return "mi.created_at DESC"</span>
        }
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package services

import (
        "catalogizer/filesystem"
        "context"
        "crypto/md5"
        "fmt"
        "path/filepath"
        "strings"
        "time"

        "go.uber.org/zap"
)

// LocalProtocolHandler handles rename detection for local filesystem
type LocalProtocolHandler struct {
        logger *zap.Logger
}

func NewLocalProtocolHandler(logger *zap.Logger) *LocalProtocolHandler <span class="cov0" title="0">{
        return &amp;LocalProtocolHandler{logger: logger}
}</span>

func (h *LocalProtocolHandler) GetFileIdentifier(ctx context.Context, path string, size int64, isDir bool) (string, error) <span class="cov0" title="0">{
        // For local filesystem, use inode information if available
        // Fallback to path + size + modification time
        return fmt.Sprintf("local:%s:%d:%t", path, size, isDir), nil
}</span>

func (h *LocalProtocolHandler) PerformMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string, isDir bool) error <span class="cov0" title="0">{
        // Local filesystem moves are handled by the OS file system watcher
        // No explicit move operation needed here
        return nil
}</span>

func (h *LocalProtocolHandler) ValidateMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        // Basic validation - ensure paths are different and target doesn't exist
        if oldPath == newPath </span><span class="cov0" title="0">{
                return fmt.Errorf("source and destination paths are the same")
        }</span>

        <span class="cov0" title="0">exists, err := client.FileExists(ctx, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if destination exists: %w", err)
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("destination path already exists: %s", newPath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *LocalProtocolHandler) GetMoveWindow() time.Duration <span class="cov0" title="0">{
        // Local filesystem operations are very fast
        return 2 * time.Second
}</span>

func (h *LocalProtocolHandler) SupportsRealTimeNotification() bool <span class="cov0" title="0">{
        return true // Local filesystem supports inotify/fsnotify
}</span>

// SMBProtocolHandler handles rename detection for SMB protocol
type SMBProtocolHandler struct {
        logger *zap.Logger
}

func NewSMBProtocolHandler(logger *zap.Logger) *SMBProtocolHandler <span class="cov0" title="0">{
        return &amp;SMBProtocolHandler{logger: logger}
}</span>

func (h *SMBProtocolHandler) GetFileIdentifier(ctx context.Context, path string, size int64, isDir bool) (string, error) <span class="cov0" title="0">{
        // For SMB, use file path, size, and directory flag
        // SMB doesn't have reliable inode-like identifiers across all implementations
        return fmt.Sprintf("smb:%s:%d:%t", path, size, isDir), nil
}</span>

func (h *SMBProtocolHandler) PerformMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string, isDir bool) error <span class="cov0" title="0">{
        // For SMB, perform copy + delete since not all SMB servers support native move
        if isDir </span><span class="cov0" title="0">{
                return h.moveDirectory(ctx, client, oldPath, newPath)
        }</span>
        <span class="cov0" title="0">return h.moveFile(ctx, client, oldPath, newPath)</span>
}

func (h *SMBProtocolHandler) moveFile(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        // Copy file content
        if err := client.CopyFile(ctx, oldPath, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        // Delete original file
        <span class="cov0" title="0">if err := client.DeleteFile(ctx, oldPath); err != nil </span><span class="cov0" title="0">{
                // Attempt to clean up the copy if deletion fails
                client.DeleteFile(ctx, newPath)
                return fmt.Errorf("failed to delete original file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *SMBProtocolHandler) moveDirectory(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        // List directory contents
        files, err := client.ListDirectory(ctx, oldPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list directory contents: %w", err)
        }</span>

        // Create destination directory
        <span class="cov0" title="0">if err := client.CreateDirectory(ctx, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Move each file/subdirectory
        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                oldItemPath := filepath.Join(oldPath, file.Name)
                newItemPath := filepath.Join(newPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        if err := h.moveDirectory(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to move subdirectory %s: %w", file.Name, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := h.moveFile(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to move file %s: %w", file.Name, err)
                        }</span>
                }
        }

        // Delete original directory
        <span class="cov0" title="0">if err := client.DeleteDirectory(ctx, oldPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete original directory: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *SMBProtocolHandler) ValidateMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if oldPath == newPath </span><span class="cov0" title="0">{
                return fmt.Errorf("source and destination paths are the same")
        }</span>

        <span class="cov0" title="0">exists, err := client.FileExists(ctx, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if destination exists: %w", err)
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("destination path already exists: %s", newPath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *SMBProtocolHandler) GetMoveWindow() time.Duration <span class="cov0" title="0">{
        // SMB operations can be slower, especially over network
        return 10 * time.Second
}</span>

func (h *SMBProtocolHandler) SupportsRealTimeNotification() bool <span class="cov0" title="0">{
        return false // SMB typically uses polling for change detection
}</span>

// FTPProtocolHandler handles rename detection for FTP protocol
type FTPProtocolHandler struct {
        logger *zap.Logger
}

func NewFTPProtocolHandler(logger *zap.Logger) *FTPProtocolHandler <span class="cov0" title="0">{
        return &amp;FTPProtocolHandler{logger: logger}
}</span>

func (h *FTPProtocolHandler) GetFileIdentifier(ctx context.Context, path string, size int64, isDir bool) (string, error) <span class="cov0" title="0">{
        // For FTP, use path + size + directory flag
        // Some FTP servers provide modification time which could be added
        return fmt.Sprintf("ftp:%s:%d:%t", path, size, isDir), nil
}</span>

func (h *FTPProtocolHandler) PerformMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string, isDir bool) error <span class="cov0" title="0">{
        // FTP doesn't typically support atomic moves, so use copy + delete
        if isDir </span><span class="cov0" title="0">{
                return h.moveDirectory(ctx, client, oldPath, newPath)
        }</span>
        <span class="cov0" title="0">return h.moveFile(ctx, client, oldPath, newPath)</span>
}

func (h *FTPProtocolHandler) moveFile(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if err := client.CopyFile(ctx, oldPath, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file via FTP: %w", err)
        }</span>

        <span class="cov0" title="0">if err := client.DeleteFile(ctx, oldPath); err != nil </span><span class="cov0" title="0">{
                client.DeleteFile(ctx, newPath) // Cleanup on failure
                return fmt.Errorf("failed to delete original file via FTP: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *FTPProtocolHandler) moveDirectory(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        files, err := client.ListDirectory(ctx, oldPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list FTP directory: %w", err)
        }</span>

        <span class="cov0" title="0">if err := client.CreateDirectory(ctx, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create FTP directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                oldItemPath := filepath.Join(oldPath, file.Name)
                newItemPath := filepath.Join(newPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        if err := h.moveDirectory(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := h.moveFile(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return client.DeleteDirectory(ctx, oldPath)</span>
}

func (h *FTPProtocolHandler) ValidateMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if oldPath == newPath </span><span class="cov0" title="0">{
                return fmt.Errorf("source and destination paths are the same")
        }</span>

        <span class="cov0" title="0">exists, err := client.FileExists(ctx, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check FTP destination: %w", err)
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("FTP destination already exists: %s", newPath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *FTPProtocolHandler) GetMoveWindow() time.Duration <span class="cov0" title="0">{
        // FTP operations can be slow, especially for large files
        return 30 * time.Second
}</span>

func (h *FTPProtocolHandler) SupportsRealTimeNotification() bool <span class="cov0" title="0">{
        return false // FTP requires polling
}</span>

// NFSProtocolHandler handles rename detection for NFS protocol
type NFSProtocolHandler struct {
        logger *zap.Logger
}

func NewNFSProtocolHandler(logger *zap.Logger) *NFSProtocolHandler <span class="cov0" title="0">{
        return &amp;NFSProtocolHandler{logger: logger}
}</span>

func (h *NFSProtocolHandler) GetFileIdentifier(ctx context.Context, path string, size int64, isDir bool) (string, error) <span class="cov0" title="0">{
        // NFS can potentially provide inode information
        // For now, use path + size + directory flag
        return fmt.Sprintf("nfs:%s:%d:%t", path, size, isDir), nil
}</span>

func (h *NFSProtocolHandler) PerformMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string, isDir bool) error <span class="cov0" title="0">{
        // NFS supports native rename operations in most cases
        // For simplicity, use copy + delete approach
        if isDir </span><span class="cov0" title="0">{
                return h.moveDirectory(ctx, client, oldPath, newPath)
        }</span>
        <span class="cov0" title="0">return h.moveFile(ctx, client, oldPath, newPath)</span>
}

func (h *NFSProtocolHandler) moveFile(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if err := client.CopyFile(ctx, oldPath, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file via NFS: %w", err)
        }</span>

        <span class="cov0" title="0">if err := client.DeleteFile(ctx, oldPath); err != nil </span><span class="cov0" title="0">{
                client.DeleteFile(ctx, newPath)
                return fmt.Errorf("failed to delete original file via NFS: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *NFSProtocolHandler) moveDirectory(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        files, err := client.ListDirectory(ctx, oldPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list NFS directory: %w", err)
        }</span>

        <span class="cov0" title="0">if err := client.CreateDirectory(ctx, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create NFS directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                oldItemPath := filepath.Join(oldPath, file.Name)
                newItemPath := filepath.Join(newPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        if err := h.moveDirectory(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := h.moveFile(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return client.DeleteDirectory(ctx, oldPath)</span>
}

func (h *NFSProtocolHandler) ValidateMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if oldPath == newPath </span><span class="cov0" title="0">{
                return fmt.Errorf("source and destination paths are the same")
        }</span>

        <span class="cov0" title="0">exists, err := client.FileExists(ctx, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check NFS destination: %w", err)
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("NFS destination already exists: %s", newPath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *NFSProtocolHandler) GetMoveWindow() time.Duration <span class="cov0" title="0">{
        // NFS operations are generally fast
        return 5 * time.Second
}</span>

func (h *NFSProtocolHandler) SupportsRealTimeNotification() bool <span class="cov0" title="0">{
        // NFS can support inotify if mounted locally, but generally uses polling
        return false
}</span>

// WebDAVProtocolHandler handles rename detection for WebDAV protocol
type WebDAVProtocolHandler struct {
        logger *zap.Logger
}

func NewWebDAVProtocolHandler(logger *zap.Logger) *WebDAVProtocolHandler <span class="cov0" title="0">{
        return &amp;WebDAVProtocolHandler{logger: logger}
}</span>

func (h *WebDAVProtocolHandler) GetFileIdentifier(ctx context.Context, path string, size int64, isDir bool) (string, error) <span class="cov0" title="0">{
        // WebDAV can provide ETags for some servers
        // For now, use path + size + directory flag
        pathHash := h.hashString(path)
        return fmt.Sprintf("webdav:%s:%d:%t", pathHash, size, isDir), nil
}</span>

func (h *WebDAVProtocolHandler) hashString(s string) string <span class="cov0" title="0">{
        hash := md5.Sum([]byte(s))
        return fmt.Sprintf("%x", hash)
}</span>

func (h *WebDAVProtocolHandler) PerformMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string, isDir bool) error <span class="cov0" title="0">{
        // WebDAV supports MOVE method, but not all implementations support it
        // Use copy + delete as fallback
        if isDir </span><span class="cov0" title="0">{
                return h.moveDirectory(ctx, client, oldPath, newPath)
        }</span>
        <span class="cov0" title="0">return h.moveFile(ctx, client, oldPath, newPath)</span>
}

func (h *WebDAVProtocolHandler) moveFile(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if err := client.CopyFile(ctx, oldPath, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file via WebDAV: %w", err)
        }</span>

        <span class="cov0" title="0">if err := client.DeleteFile(ctx, oldPath); err != nil </span><span class="cov0" title="0">{
                client.DeleteFile(ctx, newPath)
                return fmt.Errorf("failed to delete original file via WebDAV: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *WebDAVProtocolHandler) moveDirectory(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        files, err := client.ListDirectory(ctx, oldPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list WebDAV directory: %w", err)
        }</span>

        <span class="cov0" title="0">if err := client.CreateDirectory(ctx, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create WebDAV directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                oldItemPath := filepath.Join(oldPath, file.Name)
                newItemPath := filepath.Join(newPath, file.Name)

                if file.IsDir </span><span class="cov0" title="0">{
                        if err := h.moveDirectory(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := h.moveFile(ctx, client, oldItemPath, newItemPath); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return client.DeleteDirectory(ctx, oldPath)</span>
}

func (h *WebDAVProtocolHandler) ValidateMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error <span class="cov0" title="0">{
        if oldPath == newPath </span><span class="cov0" title="0">{
                return fmt.Errorf("source and destination paths are the same")
        }</span>

        <span class="cov0" title="0">exists, err := client.FileExists(ctx, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check WebDAV destination: %w", err)
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV destination already exists: %s", newPath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *WebDAVProtocolHandler) GetMoveWindow() time.Duration <span class="cov0" title="0">{
        // WebDAV operations depend on network latency
        return 15 * time.Second
}</span>

func (h *WebDAVProtocolHandler) SupportsRealTimeNotification() bool <span class="cov0" title="0">{
        return false // WebDAV requires polling
}</span>

// ProtocolHandlerFactory creates protocol handlers based on configuration
type ProtocolHandlerFactory struct {
        logger *zap.Logger
}

func NewProtocolHandlerFactory(logger *zap.Logger) *ProtocolHandlerFactory <span class="cov0" title="0">{
        return &amp;ProtocolHandlerFactory{logger: logger}
}</span>

func (f *ProtocolHandlerFactory) CreateHandler(protocol string) (ProtocolHandler, error) <span class="cov0" title="0">{
        switch strings.ToLower(protocol) </span>{
        case "local":<span class="cov0" title="0">
                return NewLocalProtocolHandler(f.logger), nil</span>
        case "smb":<span class="cov0" title="0">
                return NewSMBProtocolHandler(f.logger), nil</span>
        case "ftp":<span class="cov0" title="0">
                return NewFTPProtocolHandler(f.logger), nil</span>
        case "nfs":<span class="cov0" title="0">
                return NewNFSProtocolHandler(f.logger), nil</span>
        case "webdav":<span class="cov0" title="0">
                return NewWebDAVProtocolHandler(f.logger), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported protocol: %s", protocol)</span>
        }
}

func (f *ProtocolHandlerFactory) GetSupportedProtocols() []string <span class="cov0" title="0">{
        return []string{"local", "smb", "ftp", "nfs", "webdav"}
}</span>

// ProtocolCapabilities provides information about protocol capabilities
type ProtocolCapabilities struct {
        Protocol                     string        `json:"protocol"`
        SupportsRealTimeNotification bool          `json:"supports_realtime_notification"`
        MoveWindow                   time.Duration `json:"move_window"`
        SupportsAtomicMove           bool          `json:"supports_atomic_move"`
        RequiresPolling              bool          `json:"requires_polling"`
}

func GetProtocolCapabilities(protocol string, logger *zap.Logger) (*ProtocolCapabilities, error) <span class="cov0" title="0">{
        factory := NewProtocolHandlerFactory(logger)
        handler, err := factory.CreateHandler(protocol)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ProtocolCapabilities{
                Protocol:                     protocol,
                SupportsRealTimeNotification: handler.SupportsRealTimeNotification(),
                MoveWindow:                   handler.GetMoveWindow(),
                SupportsAtomicMove:           protocol == "local" || protocol == "nfs",
                RequiresPolling:              !handler.SupportsRealTimeNotification(),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "go.uber.org/zap"
)

// Advanced reader service with Kindle/Moon Reader Pro-like experience
type ReaderService struct {
        db                  *sql.DB
        logger              *zap.Logger
        cacheService        *CacheService
        translationService  *TranslationService
        localizationService *LocalizationService
}

// Reading session structure
type ReadingSession struct {
        ID              string          `json:"id"`
        UserID          int64           `json:"user_id"`
        BookID          string          `json:"book_id"`
        DeviceID        string          `json:"device_id"`
        DeviceName      string          `json:"device_name"`
        StartedAt       time.Time       `json:"started_at"`
        LastActiveAt    time.Time       `json:"last_active_at"`
        CurrentPosition ReadingPosition `json:"current_position"`
        ReadingSettings ReadingSettings `json:"reading_settings"`
        SyncStatus      SyncStatus      `json:"sync_status"`
        ReadingStats    ReadingStats    `json:"reading_stats"`
        IsActive        bool            `json:"is_active"`
}

// Reading position with multiple granularities
type ReadingPosition struct {
        BookID          string          `json:"book_id"`
        ChapterID       string          `json:"chapter_id,omitempty"`
        PageNumber      int             `json:"page_number"`
        WordOffset      int             `json:"word_offset"`
        CharacterOffset int             `json:"character_offset"`
        PercentComplete float64         `json:"percent_complete"`
        Location        string          `json:"location,omitempty"` // Kindle location equivalent
        CFI             string          `json:"cfi,omitempty"`      // EPUB Canonical Fragment Identifier
        Timestamp       time.Time       `json:"timestamp"`
        PositionContext PositionContext `json:"position_context"`
        Confidence      float64         `json:"confidence"`
}

type PositionContext struct {
        SurroundingText string `json:"surrounding_text"`
        ParagraphStart  string `json:"paragraph_start"`
        SentenceStart   string `json:"sentence_start"`
        ChapterTitle    string `json:"chapter_title,omitempty"`
        SectionTitle    string `json:"section_title,omitempty"`
}

// Reading settings for personalization
type ReadingSettings struct {
        FontFamily      string                `json:"font_family"`
        FontSize        int                   `json:"font_size"`
        LineHeight      float64               `json:"line_height"`
        TextAlign       string                `json:"text_align"`
        Theme           string                `json:"theme"`
        BackgroundColor string                `json:"background_color"`
        TextColor       string                `json:"text_color"`
        PageMargins     PageMargins           `json:"page_margins"`
        ColumnsPerPage  int                   `json:"columns_per_page"`
        PageTransition  string                `json:"page_transition"`
        AutoScroll      bool                  `json:"auto_scroll"`
        AutoScrollSpeed int                   `json:"auto_scroll_speed"`
        ReadingMode     string                `json:"reading_mode"` // day, night, sepia, etc.
        Brightness      float64               `json:"brightness"`
        BlueLight       BlueLightFilter       `json:"blue_light_filter"`
        Hyphenation     bool                  `json:"hyphenation"`
        Justification   bool                  `json:"justification"`
        StatusBar       StatusBarSettings     `json:"status_bar"`
        Gestures        GestureSettings       `json:"gestures"`
        Accessibility   AccessibilitySettings `json:"accessibility"`
}

type PageMargins struct {
        Top    int `json:"top"`
        Bottom int `json:"bottom"`
        Left   int `json:"left"`
        Right  int `json:"right"`
}

type BlueLightFilter struct {
        Enabled      bool    `json:"enabled"`
        Intensity    float64 `json:"intensity"`
        AutoSchedule bool    `json:"auto_schedule"`
        StartTime    string  `json:"start_time"`
        EndTime      string  `json:"end_time"`
}

type StatusBarSettings struct {
        Visible        bool   `json:"visible"`
        ShowProgress   bool   `json:"show_progress"`
        ShowTime       bool   `json:"show_time"`
        ShowBattery    bool   `json:"show_battery"`
        ShowPageNumber bool   `json:"show_page_number"`
        Position       string `json:"position"`
}

type GestureSettings struct {
        TapToTurn        bool     `json:"tap_to_turn"`
        SwipeToTurn      bool     `json:"swipe_to_turn"`
        VolumeKeys       bool     `json:"volume_keys"`
        TapZones         TapZones `json:"tap_zones"`
        SwipeSensitivity float64  `json:"swipe_sensitivity"`
}

type TapZones struct {
        LeftTurn   bool `json:"left_turn"`
        RightTurn  bool `json:"right_turn"`
        CenterMenu bool `json:"center_menu"`
}

type AccessibilitySettings struct {
        TextToSpeech    TTSSettings `json:"text_to_speech"`
        HighContrast    bool        `json:"high_contrast"`
        LargeText       bool        `json:"large_text"`
        ScreenReader    bool        `json:"screen_reader"`
        VoiceNavigation bool        `json:"voice_navigation"`
}

type TTSSettings struct {
        Enabled       bool    `json:"enabled"`
        Voice         string  `json:"voice"`
        Speed         float64 `json:"speed"`
        Pitch         float64 `json:"pitch"`
        AutoPlay      bool    `json:"auto_play"`
        HighlightText bool    `json:"highlight_text"`
}

// Sync status for cross-device reading
type SyncStatus struct {
        LastSyncAt      time.Time      `json:"last_sync_at"`
        IsSynced        bool           `json:"is_synced"`
        ConflictExists  bool           `json:"conflict_exists"`
        ConflictDetails []SyncConflict `json:"conflict_details,omitempty"`
        SyncVersion     int64          `json:"sync_version"`
}

type SyncConflict struct {
        DeviceID     string          `json:"device_id"`
        DeviceName   string          `json:"device_name"`
        Position     ReadingPosition `json:"position"`
        Timestamp    time.Time       `json:"timestamp"`
        ConflictType string          `json:"conflict_type"`
}

// Reading statistics and analytics
type ReadingStats struct {
        TotalReadingTime int64               `json:"total_reading_time_seconds"`
        SessionTime      int64               `json:"session_time_seconds"`
        PagesRead        int                 `json:"pages_read"`
        WordsRead        int                 `json:"words_read"`
        ReadingSpeed     float64             `json:"reading_speed_wpm"`
        AverageSpeed     float64             `json:"average_speed_wpm"`
        DailyGoal        int                 `json:"daily_goal_minutes"`
        DailyProgress    int                 `json:"daily_progress_minutes"`
        WeeklyStats      WeeklyReadingStats  `json:"weekly_stats"`
        MonthlyStats     MonthlyReadingStats `json:"monthly_stats"`
        ReadingStreak    int                 `json:"reading_streak_days"`
        LongestStreak    int                 `json:"longest_streak_days"`
        BooksCompleted   int                 `json:"books_completed"`
        PagesPerSession  float64             `json:"pages_per_session"`
}

type WeeklyReadingStats struct {
        Week          string `json:"week"`
        TotalTime     int64  `json:"total_time_seconds"`
        PagesRead     int    `json:"pages_read"`
        SessionsCount int    `json:"sessions_count"`
        DaysActive    int    `json:"days_active"`
}

type MonthlyReadingStats struct {
        Month          string  `json:"month"`
        TotalTime      int64   `json:"total_time_seconds"`
        PagesRead      int     `json:"pages_read"`
        BooksCompleted int     `json:"books_completed"`
        AverageDaily   float64 `json:"average_daily_minutes"`
}

// Bookmarks and annotations
type Bookmark struct {
        ID        string          `json:"id"`
        UserID    int64           `json:"user_id"`
        BookID    string          `json:"book_id"`
        Position  ReadingPosition `json:"position"`
        Title     string          `json:"title"`
        Note      string          `json:"note,omitempty"`
        Tags      []string        `json:"tags,omitempty"`
        Color     string          `json:"color,omitempty"`
        CreatedAt time.Time       `json:"created_at"`
        UpdatedAt time.Time       `json:"updated_at"`
        IsPublic  bool            `json:"is_public"`
        ShareURL  string          `json:"share_url,omitempty"`
}

type Highlight struct {
        ID            string          `json:"id"`
        UserID        int64           `json:"user_id"`
        BookID        string          `json:"book_id"`
        StartPosition ReadingPosition `json:"start_position"`
        EndPosition   ReadingPosition `json:"end_position"`
        SelectedText  string          `json:"selected_text"`
        Note          string          `json:"note,omitempty"`
        Color         string          `json:"color"`
        Type          string          `json:"type"` // highlight, underline, strikethrough
        Tags          []string        `json:"tags,omitempty"`
        CreatedAt     time.Time       `json:"created_at"`
        UpdatedAt     time.Time       `json:"updated_at"`
        IsPublic      bool            `json:"is_public"`
        ShareURL      string          `json:"share_url,omitempty"`
}

type Annotation struct {
        ID          string          `json:"id"`
        UserID      int64           `json:"user_id"`
        BookID      string          `json:"book_id"`
        Position    ReadingPosition `json:"position"`
        Type        string          `json:"type"` // note, drawing, voice, image
        Content     string          `json:"content"`
        ContentType string          `json:"content_type"`
        ContentURL  string          `json:"content_url,omitempty"`
        Tags        []string        `json:"tags,omitempty"`
        CreatedAt   time.Time       `json:"created_at"`
        UpdatedAt   time.Time       `json:"updated_at"`
        IsPublic    bool            `json:"is_public"`
        ShareURL    string          `json:"share_url,omitempty"`
}

// Reading requests and responses
type StartReadingRequest struct {
        UserID                 int64            `json:"user_id"`
        BookID                 string           `json:"book_id"`
        DeviceInfo             DeviceInfo       `json:"device_info"`
        ReadingSettings        *ReadingSettings `json:"reading_settings,omitempty"`
        ResumeFromLastPosition bool             `json:"resume_from_last_position"`
}

type ReaderUpdatePositionRequest struct {
        SessionID   string          `json:"session_id"`
        Position    ReadingPosition `json:"position"`
        ReadingTime int64           `json:"reading_time_seconds"`
        PagesRead   int             `json:"pages_read"`
        WordsRead   int             `json:"words_read"`
        AutoSync    bool            `json:"auto_sync"`
}

type CreateBookmarkRequest struct {
        UserID   int64           `json:"user_id"`
        BookID   string          `json:"book_id"`
        Position ReadingPosition `json:"position"`
        Title    string          `json:"title"`
        Note     string          `json:"note,omitempty"`
        Tags     []string        `json:"tags,omitempty"`
        Color    string          `json:"color,omitempty"`
        IsPublic bool            `json:"is_public"`
}

type CreateHighlightRequest struct {
        UserID        int64           `json:"user_id"`
        BookID        string          `json:"book_id"`
        StartPosition ReadingPosition `json:"start_position"`
        EndPosition   ReadingPosition `json:"end_position"`
        SelectedText  string          `json:"selected_text"`
        Note          string          `json:"note,omitempty"`
        Color         string          `json:"color"`
        Type          string          `json:"type"`
        Tags          []string        `json:"tags,omitempty"`
        IsPublic      bool            `json:"is_public"`
}

type ReaderDeviceInfo struct {
        DeviceID   string `json:"device_id"`
        DeviceName string `json:"device_name"`
        DeviceType string `json:"device_type"`
        ScreenSize string `json:"screen_size,omitempty"`
        OS         string `json:"os,omitempty"`
        AppVersion string `json:"app_version,omitempty"`
}

// Book content structure for reading
type BookContent struct {
        BookID            string       `json:"book_id"`
        Format            string       `json:"format"` // epub, pdf, mobi, txt
        Chapters          []Chapter    `json:"chapters"`
        TableOfContents   []TOCEntry   `json:"table_of_contents"`
        Metadata          BookMetadata `json:"metadata"`
        TotalPages        int          `json:"total_pages"`
        TotalWords        int          `json:"total_words"`
        EstimatedReadTime int          `json:"estimated_read_time_minutes"`
}

type BookChapter struct {
        ID          string    `json:"id"`
        Title       string    `json:"title"`
        Number      int       `json:"number"`
        Content     string    `json:"content"`
        HTMLContent string    `json:"html_content,omitempty"`
        WordCount   int       `json:"word_count"`
        PageCount   int       `json:"page_count"`
        StartPage   int       `json:"start_page"`
        EndPage     int       `json:"end_page"`
        Sections    []Section `json:"sections,omitempty"`
}

type Section struct {
        ID            string `json:"id"`
        Title         string `json:"title"`
        Content       string `json:"content"`
        Level         int    `json:"level"`
        StartPosition int    `json:"start_position"`
        EndPosition   int    `json:"end_position"`
}

func NewReaderService(
        db *sql.DB,
        logger *zap.Logger,
        cacheService *CacheService,
        translationService *TranslationService,
        localizationService *LocalizationService,
) *ReaderService <span class="cov0" title="0">{
        return &amp;ReaderService{
                db:                  db,
                logger:              logger,
                cacheService:        cacheService,
                translationService:  translationService,
                localizationService: localizationService,
        }
}</span>

// Start a new reading session
func (s *ReaderService) StartReading(ctx context.Context, req *StartReadingRequest) (*ReadingSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting reading session",
                zap.Int64("user_id", req.UserID),
                zap.String("book_id", req.BookID),
                zap.String("device_id", req.DeviceInfo.DeviceID))

        // Generate session ID
        sessionID := s.generateSessionID(req.UserID, req.BookID, req.DeviceInfo.DeviceID)

        // Get last reading position if resuming
        var position ReadingPosition
        if req.ResumeFromLastPosition </span><span class="cov0" title="0">{
                if lastPos, err := s.getLastReadingPosition(ctx, req.UserID, req.BookID); err == nil </span><span class="cov0" title="0">{
                        position = *lastPos
                }</span>
        }

        // Get user's reading settings
        <span class="cov0" title="0">settings := s.getDefaultReadingSettings()
        if req.ReadingSettings != nil </span><span class="cov0" title="0">{
                settings = *req.ReadingSettings
        }</span> else<span class="cov0" title="0"> if userSettings, err := s.getUserReadingSettings(ctx, req.UserID); err == nil </span><span class="cov0" title="0">{
                settings = *userSettings
        }</span>

        // Create reading session
        <span class="cov0" title="0">session := &amp;ReadingSession{
                ID:              sessionID,
                UserID:          req.UserID,
                BookID:          req.BookID,
                DeviceID:        req.DeviceInfo.DeviceID,
                DeviceName:      req.DeviceInfo.DeviceName,
                StartedAt:       time.Now(),
                LastActiveAt:    time.Now(),
                CurrentPosition: position,
                ReadingSettings: settings,
                SyncStatus:      SyncStatus{IsSynced: true, SyncVersion: 1},
                ReadingStats:    s.initializeReadingStats(ctx, req.UserID, req.BookID),
                IsActive:        true,
        }

        // Store session in database
        if err := s.storeReadingSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store reading session: %w", err)
        }</span>

        // Update user's reading history
        <span class="cov0" title="0">s.updateReadingHistory(ctx, req.UserID, req.BookID, time.Now())

        s.logger.Info("Reading session started successfully",
                zap.String("session_id", sessionID),
                zap.Float64("resume_percent", position.PercentComplete))

        return session, nil</span>
}

// Update reading position
func (s *ReaderService) UpdatePosition(ctx context.Context, req *ReaderUpdatePositionRequest) (*ReadingSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Updating reading position",
                zap.String("session_id", req.SessionID),
                zap.Float64("percent_complete", req.Position.PercentComplete))

        // Get current session
        session, err := s.getReadingSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reading session: %w", err)
        }</span>

        // Update position and stats
        <span class="cov0" title="0">session.CurrentPosition = req.Position
        session.LastActiveAt = time.Now()

        // Update reading statistics
        s.updateReadingStats(&amp;session.ReadingStats, req.ReadingTime, req.PagesRead, req.WordsRead)

        // Handle auto-sync if enabled
        if req.AutoSync </span><span class="cov0" title="0">{
                if err := s.syncAcrossDevices(ctx, session); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to sync across devices", zap.Error(err))
                }</span>
        }

        // Store updated session
        <span class="cov0" title="0">if err := s.storeReadingSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update reading session: %w", err)
        }</span>

        // Store position for future resume
        <span class="cov0" title="0">if err := s.storeReadingPosition(ctx, session.UserID, session.BookID, req.Position); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to store reading position", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

// Create a bookmark
func (s *ReaderService) CreateBookmark(ctx context.Context, req *CreateBookmarkRequest) (*Bookmark, error) <span class="cov0" title="0">{
        s.logger.Info("Creating bookmark",
                zap.Int64("user_id", req.UserID),
                zap.String("book_id", req.BookID),
                zap.String("title", req.Title))

        bookmark := &amp;Bookmark{
                ID:        s.generateBookmarkID(req.UserID, req.BookID, req.Position),
                UserID:    req.UserID,
                BookID:    req.BookID,
                Position:  req.Position,
                Title:     req.Title,
                Note:      req.Note,
                Tags:      req.Tags,
                Color:     req.Color,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                IsPublic:  req.IsPublic,
        }

        if req.IsPublic </span><span class="cov0" title="0">{
                bookmark.ShareURL = s.generateShareURL("bookmark", bookmark.ID)
        }</span>

        // Store bookmark
        <span class="cov0" title="0">if err := s.storeBookmark(ctx, bookmark); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store bookmark: %w", err)
        }</span>

        <span class="cov0" title="0">return bookmark, nil</span>
}

// Create a highlight
func (s *ReaderService) CreateHighlight(ctx context.Context, req *CreateHighlightRequest) (*Highlight, error) <span class="cov0" title="0">{
        s.logger.Info("Creating highlight",
                zap.Int64("user_id", req.UserID),
                zap.String("book_id", req.BookID),
                zap.String("text", req.SelectedText[:min(50, len(req.SelectedText))]))

        highlight := &amp;Highlight{
                ID:            s.generateHighlightID(req.UserID, req.BookID, req.StartPosition),
                UserID:        req.UserID,
                BookID:        req.BookID,
                StartPosition: req.StartPosition,
                EndPosition:   req.EndPosition,
                SelectedText:  req.SelectedText,
                Note:          req.Note,
                Color:         req.Color,
                Type:          req.Type,
                Tags:          req.Tags,
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
                IsPublic:      req.IsPublic,
        }

        if req.IsPublic </span><span class="cov0" title="0">{
                highlight.ShareURL = s.generateShareURL("highlight", highlight.ID)
        }</span>

        // Store highlight
        <span class="cov0" title="0">if err := s.storeHighlight(ctx, highlight); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store highlight: %w", err)
        }</span>

        <span class="cov0" title="0">return highlight, nil</span>
}

// Get user's bookmarks for a book
func (s *ReaderService) GetBookmarks(ctx context.Context, userID int64, bookID string) ([]Bookmark, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, book_id, position_data, title, note, tags, color,
                       created_at, updated_at, is_public, share_url
                FROM reading_bookmarks
                WHERE user_id = ? AND book_id = ?
                ORDER BY created_at ASC
        `

        rows, err := s.db.QueryContext(ctx, query, userID, bookID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var bookmarks []Bookmark
        for rows.Next() </span><span class="cov0" title="0">{
                var bookmark Bookmark
                var positionJSON, tagsJSON string
                var shareURL sql.NullString

                err := rows.Scan(
                        &amp;bookmark.ID, &amp;bookmark.UserID, &amp;bookmark.BookID,
                        &amp;positionJSON, &amp;bookmark.Title, &amp;bookmark.Note,
                        &amp;tagsJSON, &amp;bookmark.Color, &amp;bookmark.CreatedAt,
                        &amp;bookmark.UpdatedAt, &amp;bookmark.IsPublic, &amp;shareURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse position JSON
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(positionJSON), &amp;bookmark.Position); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse tags JSON
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(tagsJSON), &amp;bookmark.Tags); err != nil </span><span class="cov0" title="0">{
                        bookmark.Tags = []string{}
                }</span>

                <span class="cov0" title="0">if shareURL.Valid </span><span class="cov0" title="0">{
                        bookmark.ShareURL = shareURL.String
                }</span>

                <span class="cov0" title="0">bookmarks = append(bookmarks, bookmark)</span>
        }

        <span class="cov0" title="0">return bookmarks, nil</span>
}

// Get user's highlights for a book
func (s *ReaderService) GetHighlights(ctx context.Context, userID int64, bookID string) ([]Highlight, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, book_id, start_position_data, end_position_data,
                       selected_text, note, color, type, tags, created_at, updated_at,
                       is_public, share_url
                FROM reading_highlights
                WHERE user_id = ? AND book_id = ?
                ORDER BY start_position_data-&gt;&gt;'$.page_number' ASC
        `

        rows, err := s.db.QueryContext(ctx, query, userID, bookID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var highlights []Highlight
        for rows.Next() </span><span class="cov0" title="0">{
                var highlight Highlight
                var startPosJSON, endPosJSON, tagsJSON string
                var shareURL sql.NullString

                err := rows.Scan(
                        &amp;highlight.ID, &amp;highlight.UserID, &amp;highlight.BookID,
                        &amp;startPosJSON, &amp;endPosJSON, &amp;highlight.SelectedText,
                        &amp;highlight.Note, &amp;highlight.Color, &amp;highlight.Type,
                        &amp;tagsJSON, &amp;highlight.CreatedAt, &amp;highlight.UpdatedAt,
                        &amp;highlight.IsPublic, &amp;shareURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse position JSONs
                <span class="cov0" title="0">json.Unmarshal([]byte(startPosJSON), &amp;highlight.StartPosition)
                json.Unmarshal([]byte(endPosJSON), &amp;highlight.EndPosition)

                // Parse tags JSON
                if err := json.Unmarshal([]byte(tagsJSON), &amp;highlight.Tags); err != nil </span><span class="cov0" title="0">{
                        highlight.Tags = []string{}
                }</span>

                <span class="cov0" title="0">if shareURL.Valid </span><span class="cov0" title="0">{
                        highlight.ShareURL = shareURL.String
                }</span>

                <span class="cov0" title="0">highlights = append(highlights, highlight)</span>
        }

        <span class="cov0" title="0">return highlights, nil</span>
}

// Get reading statistics for a user
func (s *ReaderService) GetReadingStats(ctx context.Context, userID int64, period string) (*ReadingStats, error) <span class="cov0" title="0">{
        var stats ReadingStats

        // Get total reading statistics
        query := `
                SELECT
                        COALESCE(SUM(total_reading_time), 0) as total_time,
                        COALESCE(SUM(pages_read), 0) as total_pages,
                        COALESCE(SUM(words_read), 0) as total_words,
                        COALESCE(AVG(reading_speed), 0) as avg_speed,
                        COUNT(DISTINCT book_id) as books_read
                FROM reading_sessions
                WHERE user_id = ? AND started_at &gt;= ?
        `

        var startDate time.Time
        switch period </span>{
        case "day":<span class="cov0" title="0">
                startDate = time.Now().AddDate(0, 0, -1)</span>
        case "week":<span class="cov0" title="0">
                startDate = time.Now().AddDate(0, 0, -7)</span>
        case "month":<span class="cov0" title="0">
                startDate = time.Now().AddDate(0, -1, 0)</span>
        case "year":<span class="cov0" title="0">
                startDate = time.Now().AddDate(-1, 0, 0)</span>
        default:<span class="cov0" title="0">
                startDate = time.Time{}</span> // All time
        }

        <span class="cov0" title="0">err := s.db.QueryRowContext(ctx, query, userID, startDate).Scan(
                &amp;stats.TotalReadingTime,
                &amp;stats.PagesRead,
                &amp;stats.WordsRead,
                &amp;stats.AverageSpeed,
                &amp;stats.BooksCompleted,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Calculate reading streak
        <span class="cov0" title="0">stats.ReadingStreak = s.calculateReadingStreak(ctx, userID)

        // Get daily goal progress
        stats.DailyGoal = s.getUserDailyGoal(ctx, userID)
        stats.DailyProgress = s.getTodayReadingTime(ctx, userID)

        return &amp;stats, nil</span>
}

// Sync reading progress across devices
func (s *ReaderService) SyncAcrossDevices(ctx context.Context, userID int64, bookID string) error <span class="cov0" title="0">{
        s.logger.Info("Syncing reading progress across devices",
                zap.Int64("user_id", userID),
                zap.String("book_id", bookID))

        // Get all active sessions for this book
        sessions, err := s.getActiveSessionsForBook(ctx, userID, bookID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(sessions) &lt;= 1 </span><span class="cov0" title="0">{
                return nil // No sync needed
        }</span>

        // Find the most recent position
        <span class="cov0" title="0">var latestSession *ReadingSession
        var latestTime time.Time

        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.CurrentPosition.Timestamp.After(latestTime) </span><span class="cov0" title="0">{
                        latestTime = session.CurrentPosition.Timestamp
                        latestSession = &amp;session
                }</span>
        }

        <span class="cov0" title="0">if latestSession == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Update all other sessions with the latest position
        <span class="cov0" title="0">for _, session := range sessions </span><span class="cov0" title="0">{
                if session.ID != latestSession.ID </span><span class="cov0" title="0">{
                        session.CurrentPosition = latestSession.CurrentPosition
                        session.SyncStatus.LastSyncAt = time.Now()
                        session.SyncStatus.IsSynced = true
                        session.SyncStatus.SyncVersion++

                        if err := s.storeReadingSession(ctx, &amp;session); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to sync session",
                                        zap.String("session_id", session.ID),
                                        zap.Error(err))
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper methods
func (s *ReaderService) generateSessionID(userID int64, bookID, deviceID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("session_%d_%s_%s_%d", userID, bookID, deviceID, time.Now().Unix())
}</span>

func (s *ReaderService) generateBookmarkID(userID int64, bookID string, position ReadingPosition) string <span class="cov0" title="0">{
        return fmt.Sprintf("bookmark_%d_%s_%d_%d", userID, bookID, position.PageNumber, time.Now().Unix())
}</span>

func (s *ReaderService) generateHighlightID(userID int64, bookID string, position ReadingPosition) string <span class="cov0" title="0">{
        return fmt.Sprintf("highlight_%d_%s_%d_%d", userID, bookID, position.PageNumber, time.Now().Unix())
}</span>

func (s *ReaderService) generateShareURL(itemType, itemID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("https://catalogizer.com/share/%s/%s", itemType, itemID)
}</span>

func (s *ReaderService) getDefaultReadingSettings() ReadingSettings <span class="cov0" title="0">{
        return ReadingSettings{
                FontFamily:      "serif",
                FontSize:        16,
                LineHeight:      1.5,
                TextAlign:       "justify",
                Theme:           "light",
                BackgroundColor: "#ffffff",
                TextColor:       "#000000",
                PageMargins:     PageMargins{Top: 20, Bottom: 20, Left: 15, Right: 15},
                ColumnsPerPage:  1,
                PageTransition:  "slide",
                AutoScroll:      false,
                AutoScrollSpeed: 5,
                ReadingMode:     "day",
                Brightness:      1.0,
                BlueLight:       BlueLightFilter{Enabled: false, Intensity: 0.3},
                Hyphenation:     true,
                Justification:   true,
                StatusBar:       StatusBarSettings{Visible: true, ShowProgress: true, Position: "bottom"},
                Gestures:        GestureSettings{TapToTurn: true, SwipeToTurn: true, VolumeKeys: false},
                Accessibility:   AccessibilitySettings{},
        }
}</span>

func (s *ReaderService) getUserReadingSettings(ctx context.Context, userID int64) (*ReadingSettings, error) <span class="cov0" title="0">{
        query := `SELECT settings_data FROM user_reading_settings WHERE user_id = ?`

        var settingsJSON string
        err := s.db.QueryRowContext(ctx, query, userID).Scan(&amp;settingsJSON)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var settings ReadingSettings
        if err := json.Unmarshal([]byte(settingsJSON), &amp;settings); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;settings, nil</span>
}

func (s *ReaderService) initializeReadingStats(ctx context.Context, userID int64, bookID string) ReadingStats <span class="cov0" title="0">{
        // Get existing stats or create new ones
        stats := ReadingStats{
                DailyGoal: s.getUserDailyGoal(ctx, userID),
        }

        // Calculate current streak
        stats.ReadingStreak = s.calculateReadingStreak(ctx, userID)

        return stats
}</span>

func (s *ReaderService) updateReadingStats(stats *ReadingStats, readingTime int64, pages, words int) <span class="cov0" title="0">{
        stats.SessionTime += readingTime
        stats.TotalReadingTime += readingTime
        stats.PagesRead += pages
        stats.WordsRead += words

        // Calculate reading speed (words per minute)
        if readingTime &gt; 0 </span><span class="cov0" title="0">{
                stats.ReadingSpeed = float64(words) / (float64(readingTime) / 60.0)
        }</span>

        // Update daily progress
        <span class="cov0" title="0">stats.DailyProgress += int(readingTime / 60)</span> // Convert to minutes
}

func (s *ReaderService) getLastReadingPosition(ctx context.Context, userID int64, bookID string) (*ReadingPosition, error) <span class="cov0" title="0">{
        query := `
                SELECT position_data
                FROM reading_positions
                WHERE user_id = ? AND book_id = ?
                ORDER BY timestamp DESC
                LIMIT 1
        `

        var positionJSON string
        err := s.db.QueryRowContext(ctx, query, userID, bookID).Scan(&amp;positionJSON)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var position ReadingPosition
        if err := json.Unmarshal([]byte(positionJSON), &amp;position); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;position, nil</span>
}

func (s *ReaderService) storeReadingSession(ctx context.Context, session *ReadingSession) error <span class="cov0" title="0">{
        sessionJSON, _ := json.Marshal(session)
        positionJSON, _ := json.Marshal(session.CurrentPosition)
        settingsJSON, _ := json.Marshal(session.ReadingSettings)
        statsJSON, _ := json.Marshal(session.ReadingStats)

        query := `
                INSERT OR REPLACE INTO reading_sessions (
                        id, user_id, book_id, device_id, device_name, started_at, last_active_at,
                        current_position, reading_settings, reading_stats, is_active, session_data
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.ExecContext(ctx, query,
                session.ID, session.UserID, session.BookID, session.DeviceID, session.DeviceName,
                session.StartedAt, session.LastActiveAt, string(positionJSON), string(settingsJSON),
                string(statsJSON), session.IsActive, string(sessionJSON),
        )

        return err
}</span>

func (s *ReaderService) getReadingSession(ctx context.Context, sessionID string) (*ReadingSession, error) <span class="cov0" title="0">{
        query := `SELECT session_data FROM reading_sessions WHERE id = ?`

        var sessionJSON string
        err := s.db.QueryRowContext(ctx, query, sessionID).Scan(&amp;sessionJSON)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var session ReadingSession
        if err := json.Unmarshal([]byte(sessionJSON), &amp;session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;session, nil</span>
}

func (s *ReaderService) storeReadingPosition(ctx context.Context, userID int64, bookID string, position ReadingPosition) error <span class="cov0" title="0">{
        positionJSON, _ := json.Marshal(position)

        query := `
                INSERT OR REPLACE INTO reading_positions (
                        user_id, book_id, position_data, page_number, percent_complete, timestamp
                ) VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.ExecContext(ctx, query,
                userID, bookID, string(positionJSON), position.PageNumber,
                position.PercentComplete, position.Timestamp,
        )

        return err
}</span>

func (s *ReaderService) storeBookmark(ctx context.Context, bookmark *Bookmark) error <span class="cov0" title="0">{
        positionJSON, _ := json.Marshal(bookmark.Position)
        tagsJSON, _ := json.Marshal(bookmark.Tags)

        query := `
                INSERT OR REPLACE INTO reading_bookmarks (
                        id, user_id, book_id, position_data, title, note, tags, color,
                        created_at, updated_at, is_public, share_url
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.ExecContext(ctx, query,
                bookmark.ID, bookmark.UserID, bookmark.BookID, string(positionJSON),
                bookmark.Title, bookmark.Note, string(tagsJSON), bookmark.Color,
                bookmark.CreatedAt, bookmark.UpdatedAt, bookmark.IsPublic, bookmark.ShareURL,
        )

        return err
}</span>

func (s *ReaderService) storeHighlight(ctx context.Context, highlight *Highlight) error <span class="cov0" title="0">{
        startPosJSON, _ := json.Marshal(highlight.StartPosition)
        endPosJSON, _ := json.Marshal(highlight.EndPosition)
        tagsJSON, _ := json.Marshal(highlight.Tags)

        query := `
                INSERT OR REPLACE INTO reading_highlights (
                        id, user_id, book_id, start_position_data, end_position_data,
                        selected_text, note, color, type, tags, created_at, updated_at,
                        is_public, share_url
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.ExecContext(ctx, query,
                highlight.ID, highlight.UserID, highlight.BookID, string(startPosJSON), string(endPosJSON),
                highlight.SelectedText, highlight.Note, highlight.Color, highlight.Type, string(tagsJSON),
                highlight.CreatedAt, highlight.UpdatedAt, highlight.IsPublic, highlight.ShareURL,
        )

        return err
}</span>

func (s *ReaderService) updateReadingHistory(ctx context.Context, userID int64, bookID string, timestamp time.Time) <span class="cov0" title="0">{
        query := `
                INSERT OR REPLACE INTO reading_history (
                        user_id, book_id, last_read_at, read_count
                ) VALUES (?, ?, ?, COALESCE((SELECT read_count FROM reading_history WHERE user_id = ? AND book_id = ?), 0) + 1)
        `

        s.db.ExecContext(ctx, query, userID, bookID, timestamp, userID, bookID)
}</span>

func (s *ReaderService) syncAcrossDevices(ctx context.Context, session *ReadingSession) error <span class="cov0" title="0">{
        return s.SyncAcrossDevices(ctx, session.UserID, session.BookID)
}</span>

func (s *ReaderService) getActiveSessionsForBook(ctx context.Context, userID int64, bookID string) ([]ReadingSession, error) <span class="cov0" title="0">{
        query := `SELECT session_data FROM reading_sessions WHERE user_id = ? AND book_id = ? AND is_active = 1`

        rows, err := s.db.QueryContext(ctx, query, userID, bookID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var sessions []ReadingSession
        for rows.Next() </span><span class="cov0" title="0">{
                var sessionJSON string
                if err := rows.Scan(&amp;sessionJSON); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var session ReadingSession
                if err := json.Unmarshal([]byte(sessionJSON), &amp;session); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">sessions = append(sessions, session)</span>
        }

        <span class="cov0" title="0">return sessions, nil</span>
}

func (s *ReaderService) calculateReadingStreak(ctx context.Context, userID int64) int <span class="cov0" title="0">{
        query := `
                SELECT DATE(last_read_at) as read_date
                FROM reading_history
                WHERE user_id = ?
                ORDER BY last_read_at DESC
        `

        rows, err := s.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        streak := 0
        expectedDate := time.Now().Truncate(24 * time.Hour)

        for rows.Next() </span><span class="cov0" title="0">{
                var readDate time.Time
                if err := rows.Scan(&amp;readDate); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if readDate.Equal(expectedDate) </span><span class="cov0" title="0">{
                        streak++
                        expectedDate = expectedDate.AddDate(0, 0, -1)
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">return streak</span>
}

func (s *ReaderService) getUserDailyGoal(ctx context.Context, userID int64) int <span class="cov0" title="0">{
        query := `SELECT daily_goal_minutes FROM user_reading_goals WHERE user_id = ?`

        var goal int
        err := s.db.QueryRowContext(ctx, query, userID).Scan(&amp;goal)
        if err != nil </span><span class="cov0" title="0">{
                return 30 // Default 30 minutes
        }</span>

        <span class="cov0" title="0">return goal</span>
}

func (s *ReaderService) getTodayReadingTime(ctx context.Context, userID int64) int <span class="cov0" title="0">{
        today := time.Now().Truncate(24 * time.Hour)
        tomorrow := today.AddDate(0, 0, 1)

        query := `
                SELECT COALESCE(SUM(session_time), 0) / 60 as minutes
                FROM reading_sessions
                WHERE user_id = ? AND started_at &gt;= ? AND started_at &lt; ?
        `

        var minutes int
        err := s.db.QueryRowContext(ctx, query, userID, today, tomorrow).Scan(&amp;minutes)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return minutes</span>
}

func minInt(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "sort"
        "strings"
        "time"

        "catalogizer/models"
)

type RecommendationService struct {
        mediaRecognitionService   *MediaRecognitionService
        duplicateDetectionService *DuplicateDetectionService
        tmdbBaseURL               string
        omdbBaseURL               string
        lastfmBaseURL             string
        igdbBaseURL               string
        googleBooksBaseURL        string
        steamBaseURL              string
        githubBaseURL             string
        tmdbAPIKey                string
        omdbAPIKey                string
        lastfmAPIKey              string
        igdbClientID              string
        igdbClientSecret          string
        httpClient                *http.Client
}

type SimilarItemsRequest struct {
        MediaID             string                 `json:"media_id"`
        MediaMetadata       *models.MediaMetadata  `json:"media_metadata"`
        MaxLocalItems       int                    `json:"max_local_items,omitempty"`
        MaxExternalItems    int                    `json:"max_external_items,omitempty"`
        IncludeExternal     bool                   `json:"include_external,omitempty"`
        SimilarityThreshold float64                `json:"similarity_threshold,omitempty"`
        Filters             *RecommendationFilters `json:"filters,omitempty"`
}

type RecommendationFilters struct {
        GenreFilter    []string     `json:"genre_filter,omitempty"`
        YearRange      *YearRange   `json:"year_range,omitempty"`
        RatingRange    *RatingRange `json:"rating_range,omitempty"`
        LanguageFilter []string     `json:"language_filter,omitempty"`
        ExcludeWatched bool         `json:"exclude_watched,omitempty"`
        ExcludeOwned   bool         `json:"exclude_owned,omitempty"`
        MinConfidence  float64      `json:"min_confidence,omitempty"`
}

type YearRange struct {
        StartYear int `json:"start_year"`
        EndYear   int `json:"end_year"`
}

type RatingRange struct {
        MinRating float64 `json:"min_rating"`
        MaxRating float64 `json:"max_rating"`
}

type SimilarItemsResponse struct {
        LocalItems    []*LocalSimilarItem    `json:"local_items"`
        ExternalItems []*ExternalSimilarItem `json:"external_items"`
        TotalFound    int                    `json:"total_found"`
        GeneratedAt   time.Time              `json:"generated_at"`
        Algorithms    []string               `json:"algorithms_used"`
        Performance   *RecommendationStats   `json:"performance"`
}

type LocalSimilarItem struct {
        MediaID           string                `json:"media_id"`
        MediaMetadata     *models.MediaMetadata `json:"media_metadata"`
        SimilarityScore   float64               `json:"similarity_score"`
        SimilarityReasons []string              `json:"similarity_reasons"`
        DetailLink        string                `json:"detail_link"`
        PlayLink          string                `json:"play_link,omitempty"`
        DownloadLink      string                `json:"download_link,omitempty"`
        LastAccessed      *time.Time            `json:"last_accessed,omitempty"`
        UserRating        *float64              `json:"user_rating,omitempty"`
        IsWatched         bool                  `json:"is_watched"`
        IsOwned           bool                  `json:"is_owned"`
}

type ExternalSimilarItem struct {
        ExternalID        string            `json:"external_id"`
        Title             string            `json:"title"`
        Subtitle          string            `json:"subtitle,omitempty"`
        Description       string            `json:"description"`
        CoverArt          string            `json:"cover_art,omitempty"`
        Year              string            `json:"year,omitempty"`
        Genre             string            `json:"genre,omitempty"`
        Rating            float64           `json:"rating,omitempty"`
        Provider          string            `json:"provider"`
        ExternalLink      string            `json:"external_link"`
        SimilarityScore   float64           `json:"similarity_score"`
        SimilarityReasons []string          `json:"similarity_reasons"`
        AvailabilityInfo  *AvailabilityInfo `json:"availability_info,omitempty"`
        PriceInfo         *PriceInfo        `json:"price_info,omitempty"`
}

type AvailabilityInfo struct {
        IsAvailable       bool     `json:"is_available"`
        StreamingServices []string `json:"streaming_services,omitempty"`
        PurchaseOptions   []string `json:"purchase_options,omitempty"`
        RentalOptions     []string `json:"rental_options,omitempty"`
        Region            string   `json:"region,omitempty"`
}

type PriceInfo struct {
        PurchasePrice string    `json:"purchase_price,omitempty"`
        RentalPrice   string    `json:"rental_price,omitempty"`
        Currency      string    `json:"currency,omitempty"`
        LastUpdated   time.Time `json:"last_updated"`
}

type RecommendationStats struct {
        LocalSearchTime    time.Duration `json:"local_search_time"`
        ExternalSearchTime time.Duration `json:"external_search_time"`
        TotalTime          time.Duration `json:"total_time"`
        LocalItemsFound    int           `json:"local_items_found"`
        ExternalItemsFound int           `json:"external_items_found"`
        CacheHitRatio      float64       `json:"cache_hit_ratio"`
        APICallsCount      int           `json:"api_calls_count"`
}

func NewRecommendationService(
        mediaRecognitionService *MediaRecognitionService,
        duplicateDetectionService *DuplicateDetectionService,
) *RecommendationService <span class="cov0" title="0">{
        return &amp;RecommendationService{
                mediaRecognitionService:   mediaRecognitionService,
                duplicateDetectionService: duplicateDetectionService,
                tmdbBaseURL:               "https://api.themoviedb.org/3",
                omdbBaseURL:               "http://www.omdbapi.com",
                lastfmBaseURL:             "http://ws.audioscrobbler.com/2.0",
                igdbBaseURL:               "https://api.igdb.com/v4",
                googleBooksBaseURL:        "https://www.googleapis.com/books/v1",
                steamBaseURL:              "https://store.steampowered.com/api",
                githubBaseURL:             "https://api.github.com",
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }
}</span>

func (rs *RecommendationService) GetSimilarItems(ctx context.Context, req *SimilarItemsRequest) (*SimilarItemsResponse, error) <span class="cov0" title="0">{
        startTime := time.Now()

        // Set defaults
        if req.MaxLocalItems == 0 </span><span class="cov0" title="0">{
                req.MaxLocalItems = 10
        }</span>
        <span class="cov0" title="0">if req.MaxExternalItems == 0 </span><span class="cov0" title="0">{
                req.MaxExternalItems = 5
        }</span>
        <span class="cov0" title="0">if req.SimilarityThreshold == 0 </span><span class="cov0" title="0">{
                req.SimilarityThreshold = 0.3
        }</span>

        <span class="cov0" title="0">response := &amp;SimilarItemsResponse{
                LocalItems:    make([]*LocalSimilarItem, 0),
                ExternalItems: make([]*ExternalSimilarItem, 0),
                GeneratedAt:   time.Now(),
                Algorithms:    []string{"content_similarity", "metadata_matching", "collaborative_filtering"},
                Performance:   &amp;RecommendationStats{},
        }

        // Find local similar items first
        localStartTime := time.Now()
        localItems, err := rs.findLocalSimilarItems(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find local similar items: %w", err)
        }</span>
        <span class="cov0" title="0">response.LocalItems = localItems
        response.Performance.LocalSearchTime = time.Since(localStartTime)
        response.Performance.LocalItemsFound = len(localItems)

        // Find external similar items if requested and needed
        if req.IncludeExternal &amp;&amp; len(localItems) &lt; req.MaxLocalItems </span><span class="cov0" title="0">{
                externalStartTime := time.Now()
                externalItems, err := rs.findExternalSimilarItems(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the entire request
                        fmt.Printf("Warning: failed to find external similar items: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        response.ExternalItems = externalItems
                        response.Performance.ExternalItemsFound = len(externalItems)
                }</span>
                <span class="cov0" title="0">response.Performance.ExternalSearchTime = time.Since(externalStartTime)</span>
        }

        <span class="cov0" title="0">response.TotalFound = len(response.LocalItems) + len(response.ExternalItems)
        response.Performance.TotalTime = time.Since(startTime)

        return response, nil</span>
}

func (rs *RecommendationService) findLocalSimilarItems(ctx context.Context, req *SimilarItemsRequest) ([]*LocalSimilarItem, error) <span class="cov0" title="0">{
        // This would normally query the local database/catalog
        // For now, we'll simulate finding similar items

        var allLocalMedia []*models.MediaMetadata

        // In a real implementation, this would query the database
        // For demonstration, we'll create some mock similar items
        allLocalMedia = rs.generateMockLocalMedia(req.MediaMetadata)

        var similarItems []*LocalSimilarItem

        for _, media := range allLocalMedia </span><span class="cov0" title="0">{
                // Skip the same item by ID comparison
                if media.ID == req.MediaMetadata.ID </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Calculate similarity
                <span class="cov0" title="0">similarity, reasons := rs.calculateLocalSimilarity(req.MediaMetadata, media)

                // Apply filters
                if !rs.passesFilters(media, similarity, req.Filters) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Apply similarity threshold
                <span class="cov0" title="0">if similarity &lt; req.SimilarityThreshold </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">similarItem := &amp;LocalSimilarItem{
                        MediaID:           rs.generateMediaID(media),
                        MediaMetadata:     media,
                        SimilarityScore:   similarity,
                        SimilarityReasons: reasons,
                        DetailLink:        rs.generateDetailLink(media),
                        PlayLink:          rs.generatePlayLink(media),
                        DownloadLink:      rs.generateDownloadLink(media),
                        IsOwned:           true, // Local items are owned
                }

                similarItems = append(similarItems, similarItem)</span>
        }

        // Sort by similarity score (descending)
        <span class="cov0" title="0">sort.Slice(similarItems, func(i, j int) bool </span><span class="cov0" title="0">{
                return similarItems[i].SimilarityScore &gt; similarItems[j].SimilarityScore
        }</span>)

        // Limit results
        <span class="cov0" title="0">if len(similarItems) &gt; req.MaxLocalItems </span><span class="cov0" title="0">{
                similarItems = similarItems[:req.MaxLocalItems]
        }</span>

        <span class="cov0" title="0">return similarItems, nil</span>
}

func (rs *RecommendationService) findExternalSimilarItems(ctx context.Context, req *SimilarItemsRequest) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        var externalItems []*ExternalSimilarItem

        // Use MediaType field to find type-specific similar items
        if req.MediaMetadata != nil &amp;&amp; req.MediaMetadata.MediaType != "" </span><span class="cov0" title="0">{
                switch strings.ToLower(req.MediaMetadata.MediaType) </span>{
                case "movie", "tv_show", "documentary", "anime":<span class="cov0" title="0">
                        if movieItems, err := rs.findSimilarMovies(ctx, req.MediaMetadata); err == nil </span><span class="cov0" title="0">{
                                externalItems = append(externalItems, movieItems...)
                        }</span>
                case "music", "audiobook", "podcast":<span class="cov0" title="0">
                        if musicItems, err := rs.findSimilarMusic(ctx, req.MediaMetadata); err == nil </span><span class="cov0" title="0">{
                                externalItems = append(externalItems, musicItems...)
                        }</span>
                default:<span class="cov0" title="0">
                        // For unknown types, try both movie and music
                        if movieItems, err := rs.findSimilarMovies(ctx, req.MediaMetadata); err == nil </span><span class="cov0" title="0">{
                                externalItems = append(externalItems, movieItems...)
                        }</span>
                        <span class="cov0" title="0">if musicItems, err := rs.findSimilarMusic(ctx, req.MediaMetadata); err == nil </span><span class="cov0" title="0">{
                                externalItems = append(externalItems, musicItems...)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If no MediaType specified, try finding similar items across all types
                if movieItems, err := rs.findSimilarMovies(ctx, req.MediaMetadata); err == nil </span><span class="cov0" title="0">{
                        externalItems = append(externalItems, movieItems...)
                }</span>
                <span class="cov0" title="0">if musicItems, err := rs.findSimilarMusic(ctx, req.MediaMetadata); err == nil </span><span class="cov0" title="0">{
                        externalItems = append(externalItems, musicItems...)
                }</span>
        }

        // Apply filters to external items
        <span class="cov0" title="0">var filteredItems []*ExternalSimilarItem
        for _, item := range externalItems </span><span class="cov0" title="0">{
                if rs.passesExternalFilters(item, req.Filters) </span><span class="cov0" title="0">{
                        filteredItems = append(filteredItems, item)
                }</span>
        }

        // Sort by similarity score (descending)
        <span class="cov0" title="0">sort.Slice(filteredItems, func(i, j int) bool </span><span class="cov0" title="0">{
                return filteredItems[i].SimilarityScore &gt; filteredItems[j].SimilarityScore
        }</span>)

        // Limit results
        <span class="cov0" title="0">if len(filteredItems) &gt; req.MaxExternalItems </span><span class="cov0" title="0">{
                filteredItems = filteredItems[:req.MaxExternalItems]
        }</span>

        <span class="cov0" title="0">return filteredItems, nil</span>
}

func (rs *RecommendationService) findSimilarMovies(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        var items []*ExternalSimilarItem

        // TMDb similar movies
        tmdbItems, err := rs.getTMDbSimilarMovies(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, tmdbItems...)
        }</span>

        // OMDb recommendations (genre-based)
        <span class="cov0" title="0">omdbItems, err := rs.getOMDbSimilarMovies(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, omdbItems...)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) findSimilarMusic(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        var items []*ExternalSimilarItem

        // Last.fm similar artists and tracks
        lastfmItems, err := rs.getLastFmSimilarMusic(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, lastfmItems...)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) findSimilarBooks(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        var items []*ExternalSimilarItem

        // Google Books similar books
        googleItems, err := rs.getGoogleBooksSimilar(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, googleItems...)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) findSimilarGames(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        var items []*ExternalSimilarItem

        // IGDB similar games
        igdbItems, err := rs.getIGDBSimilarGames(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, igdbItems...)
        }</span>

        // Steam recommendations
        <span class="cov0" title="0">steamItems, err := rs.getSteamSimilarGames(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, steamItems...)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) findSimilarSoftware(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        var items []*ExternalSimilarItem

        // GitHub similar repositories
        githubItems, err := rs.getGitHubSimilarSoftware(ctx, metadata)
        if err == nil </span><span class="cov0" title="0">{
                items = append(items, githubItems...)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

// External API integration methods
func (rs *RecommendationService) getTMDbSimilarMovies(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // First, we need to find the movie ID
        searchURL := fmt.Sprintf("%s/search/movie?api_key=%s&amp;query=%s",
                rs.tmdbBaseURL, rs.tmdbAPIKey, url.QueryEscape(metadata.Title))

        resp, err := rs.httpClient.Get(searchURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResult struct {
                Results []struct {
                        ID          int     `json:"id"`
                        Title       string  `json:"title"`
                        ReleaseDate string  `json:"release_date"`
                        Overview    string  `json:"overview"`
                        PosterPath  string  `json:"poster_path"`
                        VoteAverage float64 `json:"vote_average"`
                        GenreIDs    []int   `json:"genre_ids"`
                } `json:"results"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResult); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(searchResult.Results) == 0 </span><span class="cov0" title="0">{
                return []*ExternalSimilarItem{}, nil
        }</span>

        <span class="cov0" title="0">movieID := searchResult.Results[0].ID

        // Get similar movies
        similarURL := fmt.Sprintf("%s/movie/%d/similar?api_key=%s",
                rs.tmdbBaseURL, movieID, rs.tmdbAPIKey)

        resp2, err := rs.httpClient.Get(similarURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp2.Body.Close()

        var similarResult struct {
                Results []struct {
                        ID          int     `json:"id"`
                        Title       string  `json:"title"`
                        ReleaseDate string  `json:"release_date"`
                        Overview    string  `json:"overview"`
                        PosterPath  string  `json:"poster_path"`
                        VoteAverage float64 `json:"vote_average"`
                } `json:"results"`
        }

        if err := json.NewDecoder(resp2.Body).Decode(&amp;similarResult); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var items []*ExternalSimilarItem
        for _, movie := range similarResult.Results </span><span class="cov0" title="0">{
                item := &amp;ExternalSimilarItem{
                        ExternalID:        fmt.Sprintf("tmdb_%d", movie.ID),
                        Title:             movie.Title,
                        Description:       movie.Overview,
                        Year:              rs.extractYear(movie.ReleaseDate),
                        Rating:            movie.VoteAverage,
                        Provider:          "TMDb",
                        ExternalLink:      fmt.Sprintf("https://www.themoviedb.org/movie/%d", movie.ID),
                        SimilarityScore:   rs.calculateTMDbSimilarity(metadata, movie.Title, movie.ReleaseDate, movie.VoteAverage),
                        SimilarityReasons: []string{"genre_match", "tmdb_recommendation"},
                }

                if movie.PosterPath != "" </span><span class="cov0" title="0">{
                        item.CoverArt = fmt.Sprintf("https://image.tmdb.org/t/p/w500%s", movie.PosterPath)
                }</span>

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) getOMDbSimilarMovies(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // OMDb doesn't have a "similar" endpoint, so we'll search by genre
        // This is a simplified implementation
        searchURL := fmt.Sprintf("%s?apikey=%s&amp;s=%s&amp;type=movie",
                rs.omdbBaseURL, rs.omdbAPIKey, url.QueryEscape(metadata.Genre))

        resp, err := rs.httpClient.Get(searchURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var searchResult struct {
                Search []struct {
                        Title  string `json:"Title"`
                        Year   string `json:"Year"`
                        IMDbID string `json:"imdbID"`
                        Type   string `json:"Type"`
                        Poster string `json:"Poster"`
                } `json:"Search"`
                Response string `json:"Response"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;searchResult); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if searchResult.Response != "True" </span><span class="cov0" title="0">{
                return []*ExternalSimilarItem{}, nil
        }</span>

        <span class="cov0" title="0">var items []*ExternalSimilarItem
        for i, movie := range searchResult.Search </span><span class="cov0" title="0">{
                if i &gt;= 3 </span><span class="cov0" title="0">{ // Limit to first 3 results
                        break</span>
                }

                // Skip the same movie
                <span class="cov0" title="0">if strings.ToLower(movie.Title) == strings.ToLower(metadata.Title) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">item := &amp;ExternalSimilarItem{
                        ExternalID:        fmt.Sprintf("imdb_%s", movie.IMDbID),
                        Title:             movie.Title,
                        Year:              movie.Year,
                        Provider:          "IMDb",
                        ExternalLink:      fmt.Sprintf("https://www.imdb.com/title/%s", movie.IMDbID),
                        SimilarityScore:   rs.calculateOMDbSimilarity(metadata, movie.Title, movie.Year),
                        SimilarityReasons: []string{"genre_match", "imdb_search"},
                }

                if movie.Poster != "N/A" </span><span class="cov0" title="0">{
                        item.CoverArt = movie.Poster
                }</span>

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) getLastFmSimilarMusic(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // Get similar artists
        // Note: MediaMetadata doesn't have Artist field, using Director field which may contain artist name
        artist := metadata.Director
        if artist == "" </span><span class="cov0" title="0">{
                artist = metadata.Title // Fallback to title if no director/artist
        }</span>
        <span class="cov0" title="0">artistURL := fmt.Sprintf("%s?method=artist.getsimilar&amp;artist=%s&amp;api_key=%s&amp;format=json",
                rs.lastfmBaseURL, url.QueryEscape(artist), rs.lastfmAPIKey)

        resp, err := rs.httpClient.Get(artistURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var artistResult struct {
                SimilarArtists struct {
                        Artist []struct {
                                Name  string `json:"name"`
                                Match string `json:"match"`
                                URL   string `json:"url"`
                                Image []struct {
                                        Text string `json:"#text"`
                                        Size string `json:"size"`
                                } `json:"image"`
                        } `json:"artist"`
                } `json:"similarartists"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;artistResult); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var items []*ExternalSimilarItem
        for i, artist := range artistResult.SimilarArtists.Artist </span><span class="cov0" title="0">{
                if i &gt;= 5 </span><span class="cov0" title="0">{ // Limit to first 5 results
                        break</span>
                }

                <span class="cov0" title="0">item := &amp;ExternalSimilarItem{
                        ExternalID:        fmt.Sprintf("lastfm_artist_%s", strings.ReplaceAll(artist.Name, " ", "_")),
                        Title:             artist.Name,
                        Subtitle:          "Similar Artist",
                        Provider:          "Last.fm",
                        ExternalLink:      artist.URL,
                        SimilarityScore:   rs.parseLastFmMatch(artist.Match),
                        SimilarityReasons: []string{"artist_similarity", "lastfm_recommendation"},
                }

                // Get the largest image
                for _, img := range artist.Image </span><span class="cov0" title="0">{
                        if img.Size == "large" &amp;&amp; img.Text != "" </span><span class="cov0" title="0">{
                                item.CoverArt = img.Text
                                break</span>
                        }
                }

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) getGoogleBooksSimilar(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // Search for books by similar genre or title keywords
        // Note: MediaMetadata doesn't have Author field, using Title and Genre instead
        searchTerms := []string{
                fmt.Sprintf("intitle:%s", metadata.Title),
                fmt.Sprintf("subject:%s", metadata.Genre),
        }

        var items []*ExternalSimilarItem

        for _, term := range searchTerms </span><span class="cov0" title="0">{
                if term == "inauthor:" || term == "subject:" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">searchURL := fmt.Sprintf("%s/volumes?q=%s&amp;maxResults=3",
                        rs.googleBooksBaseURL, url.QueryEscape(term))

                resp, err := rs.httpClient.Get(searchURL)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var result struct {
                        Items []struct {
                                ID         string `json:"id"`
                                VolumeInfo struct {
                                        Title         string   `json:"title"`
                                        Authors       []string `json:"authors"`
                                        Description   string   `json:"description"`
                                        Categories    []string `json:"categories"`
                                        AverageRating float64  `json:"averageRating"`
                                        PublishedDate string   `json:"publishedDate"`
                                        ImageLinks    struct {
                                                Thumbnail string `json:"thumbnail"`
                                        } `json:"imageLinks"`
                                        CanonicalVolumeLink string `json:"canonicalVolumeLink"`
                                } `json:"volumeInfo"`
                        } `json:"items"`
                }

                if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                        resp.Body.Close()
                        continue</span>
                }
                <span class="cov0" title="0">resp.Body.Close()

                for _, book := range result.Items </span><span class="cov0" title="0">{
                        // Skip the same book
                        if strings.ToLower(book.VolumeInfo.Title) == strings.ToLower(metadata.Title) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">author := ""
                        if len(book.VolumeInfo.Authors) &gt; 0 </span><span class="cov0" title="0">{
                                author = book.VolumeInfo.Authors[0]
                        }</span>

                        <span class="cov0" title="0">item := &amp;ExternalSimilarItem{
                                ExternalID:        fmt.Sprintf("google_books_%s", book.ID),
                                Title:             book.VolumeInfo.Title,
                                Subtitle:          author,
                                Description:       book.VolumeInfo.Description,
                                Year:              rs.extractYear(book.VolumeInfo.PublishedDate),
                                Rating:            book.VolumeInfo.AverageRating,
                                Provider:          "Google Books",
                                ExternalLink:      book.VolumeInfo.CanonicalVolumeLink,
                                SimilarityScore:   rs.calculateGoogleBooksSimilarity(metadata, book.VolumeInfo.Title, author),
                                SimilarityReasons: []string{"author_match", "genre_match"},
                        }

                        if book.VolumeInfo.ImageLinks.Thumbnail != "" </span><span class="cov0" title="0">{
                                item.CoverArt = book.VolumeInfo.ImageLinks.Thumbnail
                        }</span>

                        <span class="cov0" title="0">items = append(items, item)</span>
                }

                <span class="cov0" title="0">if len(items) &gt;= 5 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) getIGDBSimilarGames(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // IGDB requires OAuth token - simplified implementation
        // In a real implementation, you'd get an OAuth token first

        // Mock similar games for demonstration
        var items []*ExternalSimilarItem

        // This would normally use IGDB's similar games endpoint
        similarGames := []struct {
                ID     int
                Name   string
                Genre  string
                Rating float64
                URL    string
        }{
                {1, "Similar Game 1", metadata.Genre, 8.5, "https://www.igdb.com/games/similar-game-1"},
                {2, "Similar Game 2", metadata.Genre, 7.8, "https://www.igdb.com/games/similar-game-2"},
        }

        for _, game := range similarGames </span><span class="cov0" title="0">{
                item := &amp;ExternalSimilarItem{
                        ExternalID:        fmt.Sprintf("igdb_%d", game.ID),
                        Title:             game.Name,
                        Genre:             game.Genre,
                        Rating:            game.Rating,
                        Provider:          "IGDB",
                        ExternalLink:      game.URL,
                        SimilarityScore:   0.8, // Mock score
                        SimilarityReasons: []string{"genre_match", "igdb_recommendation"},
                }

                items = append(items, item)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) getSteamSimilarGames(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // Steam doesn't have a public recommendations API
        // This would normally require Steam Web API key and additional processing

        // Mock implementation
        var items []*ExternalSimilarItem

        // This is just for demonstration
        steamGames := []struct {
                ID    string
                Name  string
                Genre string
                Price string
        }{
                {"123456", "Steam Similar Game 1", metadata.Genre, "$19.99"},
                {"789012", "Steam Similar Game 2", metadata.Genre, "$29.99"},
        }

        for _, game := range steamGames </span><span class="cov0" title="0">{
                item := &amp;ExternalSimilarItem{
                        ExternalID:        fmt.Sprintf("steam_%s", game.ID),
                        Title:             game.Name,
                        Genre:             game.Genre,
                        Provider:          "Steam",
                        ExternalLink:      fmt.Sprintf("https://store.steampowered.com/app/%s", game.ID),
                        SimilarityScore:   0.7, // Mock score
                        SimilarityReasons: []string{"genre_match", "steam_recommendation"},
                        PriceInfo: &amp;PriceInfo{
                                PurchasePrice: game.Price,
                                Currency:      "USD",
                                LastUpdated:   time.Now(),
                        },
                }

                items = append(items, item)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (rs *RecommendationService) getGitHubSimilarSoftware(ctx context.Context, metadata *models.MediaMetadata) ([]*ExternalSimilarItem, error) <span class="cov0" title="0">{
        // Search for similar repositories by topic or language
        searchQuery := fmt.Sprintf("topic:%s", strings.ToLower(metadata.Genre))
        searchURL := fmt.Sprintf("%s/search/repositories?q=%s&amp;sort=stars&amp;order=desc&amp;per_page=5",
                rs.githubBaseURL, url.QueryEscape(searchQuery))

        resp, err := rs.httpClient.Get(searchURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var result struct {
                Items []struct {
                        ID              int    `json:"id"`
                        Name            string `json:"name"`
                        FullName        string `json:"full_name"`
                        Description     string `json:"description"`
                        Language        string `json:"language"`
                        StargazersCount int    `json:"stargazers_count"`
                        HTMLURL         string `json:"html_url"`
                } `json:"items"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var items []*ExternalSimilarItem
        for _, repo := range result.Items </span><span class="cov0" title="0">{
                // Skip if same name
                if strings.ToLower(repo.Name) == strings.ToLower(metadata.Title) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">item := &amp;ExternalSimilarItem{
                        ExternalID:        fmt.Sprintf("github_%d", repo.ID),
                        Title:             repo.Name,
                        Subtitle:          repo.FullName,
                        Description:       repo.Description,
                        Provider:          "GitHub",
                        ExternalLink:      repo.HTMLURL,
                        SimilarityScore:   rs.calculateGitHubSimilarity(metadata, repo.Name, repo.Language, repo.StargazersCount),
                        SimilarityReasons: []string{"topic_match", "github_stars"},
                }

                items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items, nil</span>
}

// Helper methods for similarity calculation
func (rs *RecommendationService) calculateLocalSimilarity(original, candidate *models.MediaMetadata) (float64, []string) <span class="cov0" title="0">{
        var score float64
        var reasons []string

        // Use basic text similarity as a foundation
        titleSimilarity := rs.duplicateDetectionService.calculateTextSimilarity(original.Title, candidate.Title)
        score = titleSimilarity * 0.5

        if titleSimilarity &gt; 0.8 </span><span class="cov0" title="0">{
                reasons = append(reasons, "high_title_similarity")
        }</span>

        // Additional similarity factors
        // Note: MediaType field doesn't exist in MediaMetadata, skipping this comparison
        // if original.MediaType == candidate.MediaType {
        //         score += 0.1
        //         reasons = append(reasons, "same_media_type")
        // }

        <span class="cov0" title="0">if original.Genre == candidate.Genre &amp;&amp; original.Genre != "" </span><span class="cov0" title="0">{
                score += 0.15
                reasons = append(reasons, "same_genre")
        }</span>

        <span class="cov0" title="0">if original.Year != nil &amp;&amp; candidate.Year != nil &amp;&amp; *original.Year == *candidate.Year </span><span class="cov0" title="0">{
                score += 0.1
                reasons = append(reasons, "same_year")
        }</span>

        // Note: Artist field doesn't exist, using Director instead
        <span class="cov0" title="0">if original.Director == candidate.Director &amp;&amp; original.Director != "" </span><span class="cov0" title="0">{
                score += 0.2
                reasons = append(reasons, "same_director")
        }</span>

        // Note: Author field doesn't exist, using Producer instead
        <span class="cov0" title="0">if original.Producer == candidate.Producer &amp;&amp; original.Producer != "" </span><span class="cov0" title="0">{
                score += 0.2
                reasons = append(reasons, "same_producer")
        }</span>

        // Note: Developer field doesn't exist in MediaMetadata
        // if original.Developer == candidate.Developer &amp;&amp; original.Developer != "" {
        //         score += 0.15
        //         reasons = append(reasons, "same_developer")
        // }

        // Normalize score to [0, 1]
        <span class="cov0" title="0">if score &gt; 1.0 </span><span class="cov0" title="0">{
                score = 1.0
        }</span>

        <span class="cov0" title="0">return score, reasons</span>
}

func (rs *RecommendationService) calculateTMDbSimilarity(original *models.MediaMetadata, title, releaseDate string, rating float64) float64 <span class="cov0" title="0">{
        score := 0.5 // Base score for TMDb recommendation

        // Year similarity (Year is *int, candidateYear is string)
        if original.Year != nil </span><span class="cov0" title="0">{
                candidateYear := rs.extractYear(releaseDate)
                if candidateYear != "" &amp;&amp; fmt.Sprintf("%d", *original.Year) == candidateYear </span><span class="cov0" title="0">{
                        score += 0.2
                }</span>
        }

        // Rating similarity (if original has rating)
        <span class="cov0" title="0">if original.Rating != nil &amp;&amp; *original.Rating &gt; 0 </span><span class="cov0" title="0">{
                ratingDiff := abs(*original.Rating - rating)
                if ratingDiff &lt; 1.0 </span><span class="cov0" title="0">{
                        score += 0.1
                }</span>
        }

        // Title similarity
        <span class="cov0" title="0">titleSim := rs.duplicateDetectionService.calculateTextSimilarity(original.Title, title)
        score += titleSim * 0.2

        return score</span>
}

func (rs *RecommendationService) calculateOMDbSimilarity(original *models.MediaMetadata, title, year string) float64 <span class="cov0" title="0">{
        score := 0.4 // Base score for OMDb search

        // Year similarity (Year is *int, year parameter is string)
        if original.Year != nil &amp;&amp; year != "" &amp;&amp; fmt.Sprintf("%d", *original.Year) == year </span><span class="cov0" title="0">{
                score += 0.3
        }</span>

        // Title similarity
        <span class="cov0" title="0">titleSim := rs.duplicateDetectionService.calculateTextSimilarity(original.Title, title)
        score += titleSim * 0.3

        return score</span>
}

func (rs *RecommendationService) calculateGoogleBooksSimilarity(original *models.MediaMetadata, title, author string) float64 <span class="cov0" title="0">{
        score := 0.4 // Base score

        // Author similarity (using Producer as fallback for author)
        if original.Producer != "" &amp;&amp; author != "" </span><span class="cov0" title="0">{
                authorSim := rs.duplicateDetectionService.calculateTextSimilarity(original.Producer, author)
                score += authorSim * 0.4
        }</span>

        // Title similarity
        <span class="cov0" title="0">titleSim := rs.duplicateDetectionService.calculateTextSimilarity(original.Title, title)
        score += titleSim * 0.2

        return score</span>
}

func (rs *RecommendationService) calculateGitHubSimilarity(original *models.MediaMetadata, name, language string, stars int) float64 <span class="cov0" title="0">{
        score := 0.3 // Base score

        // Name similarity
        nameSim := rs.duplicateDetectionService.calculateTextSimilarity(original.Title, name)
        score += nameSim * 0.3

        // Language/genre similarity
        if original.Genre != "" &amp;&amp; language != "" </span><span class="cov0" title="0">{
                langSim := rs.duplicateDetectionService.calculateTextSimilarity(original.Genre, language)
                score += langSim * 0.2
        }</span>

        // Stars boost (popular repositories)
        <span class="cov0" title="0">if stars &gt; 1000 </span><span class="cov0" title="0">{
                score += 0.1
        }</span>
        <span class="cov0" title="0">if stars &gt; 10000 </span><span class="cov0" title="0">{
                score += 0.1
        }</span>

        <span class="cov0" title="0">return score</span>
}

// Utility methods
func (rs *RecommendationService) passesFilters(media *models.MediaMetadata, similarity float64, filters *RecommendationFilters) bool <span class="cov0" title="0">{
        if filters == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        // Minimum confidence check
        <span class="cov0" title="0">if similarity &lt; filters.MinConfidence </span><span class="cov0" title="0">{
                return false
        }</span>

        // Genre filter
        <span class="cov0" title="0">if len(filters.GenreFilter) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, genre := range filters.GenreFilter </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(media.Genre), strings.ToLower(genre)) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Year range filter (Year is *int, not string)
        <span class="cov0" title="0">if filters.YearRange != nil &amp;&amp; media.Year != nil </span><span class="cov0" title="0">{
                year := *media.Year
                if year &lt; filters.YearRange.StartYear || year &gt; filters.YearRange.EndYear </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Rating range filter (Rating is *float64)
        <span class="cov0" title="0">if filters.RatingRange != nil &amp;&amp; media.Rating != nil &amp;&amp; *media.Rating &gt; 0 </span><span class="cov0" title="0">{
                if *media.Rating &lt; filters.RatingRange.MinRating || *media.Rating &gt; filters.RatingRange.MaxRating </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Language filter
        <span class="cov0" title="0">if len(filters.LanguageFilter) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, lang := range filters.LanguageFilter </span><span class="cov0" title="0">{
                        if strings.EqualFold(media.Language, lang) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (rs *RecommendationService) passesExternalFilters(item *ExternalSimilarItem, filters *RecommendationFilters) bool <span class="cov0" title="0">{
        if filters == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        // Genre filter
        <span class="cov0" title="0">if len(filters.GenreFilter) &gt; 0 </span><span class="cov0" title="0">{
                found := false
                for _, genre := range filters.GenreFilter </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(item.Genre), strings.ToLower(genre)) </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Year range filter
        <span class="cov0" title="0">if filters.YearRange != nil </span><span class="cov0" title="0">{
                year := parseYear(item.Year)
                if year != 0 &amp;&amp; (year &lt; filters.YearRange.StartYear || year &gt; filters.YearRange.EndYear) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Rating range filter
        <span class="cov0" title="0">if filters.RatingRange != nil &amp;&amp; item.Rating &gt; 0 </span><span class="cov0" title="0">{
                if item.Rating &lt; filters.RatingRange.MinRating || item.Rating &gt; filters.RatingRange.MaxRating </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// Link generation methods
func (rs *RecommendationService) generateDetailLink(media *models.MediaMetadata) string <span class="cov0" title="0">{
        mediaID := rs.generateMediaID(media)
        return fmt.Sprintf("/detail/%s", mediaID)
}</span>

func (rs *RecommendationService) generatePlayLink(media *models.MediaMetadata) string <span class="cov0" title="0">{
        // Note: MediaType doesn't exist in MediaMetadata, returning play link for all media
        mediaID := rs.generateMediaID(media)
        return fmt.Sprintf("/play/%s", mediaID)
}</span>

func (rs *RecommendationService) generateDownloadLink(media *models.MediaMetadata) string <span class="cov0" title="0">{
        mediaID := rs.generateMediaID(media)
        return fmt.Sprintf("/download/%s", mediaID)
}</span>

func (rs *RecommendationService) generateMediaID(media *models.MediaMetadata) string <span class="cov0" title="0">{
        // Generate a unique ID based on media ID (FilePath doesn't exist in MediaMetadata)
        return fmt.Sprintf("%d", media.ID)
}</span>

// Mock data generation for testing
func (rs *RecommendationService) generateMockLocalMedia(original *models.MediaMetadata) []*models.MediaMetadata <span class="cov0" title="0">{
        var mockMedia []*models.MediaMetadata

        // Create mock similar items based on genre
        // Note: This is simplified since MediaMetadata doesn't have MediaType, Artist, Author, FilePath, etc.
        year2022 := 2022
        year2023 := 2023
        rating82 := 8.2
        rating78 := 7.8
        rating85 := 8.5
        duration240 := 240
        duration195 := 195

        mockMedia = append(mockMedia, []*models.MediaMetadata{
                {
                        Title:    "Similar Movie 1",
                        Year:     original.Year,
                        Genre:    original.Genre,
                        Director: "Similar Director",
                        Rating:   &amp;rating82,
                },
                {
                        Title:    "Another " + original.Genre + " Film",
                        Year:     &amp;year2022,
                        Genre:    original.Genre,
                        Director: "Another Director",
                        Rating:   &amp;rating78,
                },
                {
                        Title:    "Similar Track",
                        Year:     original.Year,
                        Genre:    original.Genre,
                        Producer: "Similar Producer",
                        Duration: &amp;duration240,
                        Rating:   &amp;rating85,
                },
                {
                        Title:    "Another Media Item",
                        Year:     &amp;year2023,
                        Genre:    original.Genre,
                        Producer: "Different Producer",
                        Duration: &amp;duration195,
                },
        }...)

        return mockMedia
}</span>

// Utility helper functions
func (rs *RecommendationService) extractYear(dateStr string) string <span class="cov0" title="0">{
        if len(dateStr) &gt;= 4 </span><span class="cov0" title="0">{
                return dateStr[:4]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (rs *RecommendationService) parseLastFmMatch(matchStr string) float64 <span class="cov0" title="0">{
        // Last.fm match is typically a decimal string like "0.85"
        if matchStr == "" </span><span class="cov0" title="0">{
                return 0.5
        }</span>
        // This would normally parse the string to float
        // For simplicity, returning a mock value
        <span class="cov0" title="0">return 0.7</span>
}

func parseYear(yearStr string) int <span class="cov0" title="0">{
        if yearStr == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        // This would normally parse the year string to int
        // For simplicity, returning a mock value
        <span class="cov0" title="0">return 2023</span>
}

func abs(x float64) float64 <span class="cov0" title="0">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                return -x
        }</span>
        <span class="cov0" title="0">return x</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package services

import (
        "context"
        "database/sql"
        "fmt"
        "path/filepath"
        "sync"
        "time"

        "go.uber.org/zap"
)

// RenameEvent represents a file/directory rename operation
type RenameEvent struct {
        ID            int64      `json:"id"`
        StorageRootID int64      `json:"storage_root_id"`
        OldPath       string     `json:"old_path"`
        NewPath       string     `json:"new_path"`
        IsDirectory   bool       `json:"is_directory"`
        Size          int64      `json:"size"`
        FileHash      *string    `json:"file_hash,omitempty"`
        DetectedAt    time.Time  `json:"detected_at"`
        ProcessedAt   *time.Time `json:"processed_at,omitempty"`
        Status        string     `json:"status"` // pending, processed, failed
}

// PendingMove tracks a potential move operation
type PendingMove struct {
        Path        string
        StorageRoot string
        Size        int64
        FileHash    *string
        IsDirectory bool
        DeletedAt   time.Time
        FileID      int64
}

// RenameTracker efficiently detects and handles file/directory renames
type RenameTracker struct {
        db              *sql.DB
        logger          *zap.Logger
        PendingMoves    map[string]*PendingMove // key: storageRoot:hash:size
        PendingMovesMu  sync.RWMutex
        cleanupInterval time.Duration
        moveWindow      time.Duration // time window to detect moves
        stopCh          chan struct{}
        wg              sync.WaitGroup
}

// NewRenameTracker creates a new rename tracker
func NewRenameTracker(db *sql.DB, logger *zap.Logger) *RenameTracker <span class="cov8" title="10">{
        return &amp;RenameTracker{
                db:              db,
                logger:          logger,
                PendingMoves:    make(map[string]*PendingMove),
                cleanupInterval: 30 * time.Second,
                moveWindow:      5 * time.Second, // moves should happen within 5 seconds
                stopCh:          make(chan struct{}),
        }
}</span>

// Start begins the rename tracking service
func (rt *RenameTracker) Start() error <span class="cov1" title="1">{
        rt.logger.Info("Starting rename tracker service")

        // Start cleanup worker
        rt.wg.Add(1)
        go rt.cleanupWorker()

        // Create rename tracking tables if they don't exist
        if err := rt.InitializeTables(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize rename tracking tables: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Stop stops the rename tracking service
func (rt *RenameTracker) Stop() <span class="cov1" title="1">{
        rt.logger.Info("Stopping rename tracker service")
        close(rt.stopCh)
        rt.wg.Wait()
        rt.logger.Info("Rename tracker service stopped")
}</span>

// TrackDelete tracks a file/directory deletion for potential move detection
func (rt *RenameTracker) TrackDelete(ctx context.Context, fileID int64, path, storageRoot string, size int64, fileHash *string, isDirectory bool) <span class="cov7" title="7">{
        // Create move tracking key
        key := rt.CreateMoveKey(storageRoot, fileHash, size, isDirectory)

        rt.PendingMovesMu.Lock()
        rt.PendingMoves[key] = &amp;PendingMove{
                Path:        path,
                StorageRoot: storageRoot,
                Size:        size,
                FileHash:    fileHash,
                IsDirectory: isDirectory,
                DeletedAt:   time.Now(),
                FileID:      fileID,
        }
        rt.PendingMovesMu.Unlock()

        rt.logger.Debug("Tracking potential move deletion",
                zap.String("path", path),
                zap.String("storage_root", storageRoot),
                zap.Int64("file_id", fileID))
}</span>

// DetectCreate checks if a file creation is actually a move from a deletion
func (rt *RenameTracker) DetectCreate(ctx context.Context, newPath, storageRoot string, size int64, fileHash *string, isDirectory bool) (*PendingMove, bool) <span class="cov4" title="3">{
        key := rt.CreateMoveKey(storageRoot, fileHash, size, isDirectory)

        rt.PendingMovesMu.Lock()
        pendingMove, exists := rt.PendingMoves[key]
        if exists </span><span class="cov3" title="2">{
                delete(rt.PendingMoves, key)
        }</span>
        <span class="cov4" title="3">rt.PendingMovesMu.Unlock()

        if !exists </span><span class="cov1" title="1">{
                return nil, false
        }</span>

        // Check if the move happened within the time window
        <span class="cov3" title="2">if time.Since(pendingMove.DeletedAt) &gt; rt.moveWindow </span><span class="cov1" title="1">{
                rt.logger.Debug("Move window expired",
                        zap.String("old_path", pendingMove.Path),
                        zap.String("new_path", newPath),
                        zap.Duration("elapsed", time.Since(pendingMove.DeletedAt)))
                return nil, false
        }</span>

        <span class="cov1" title="1">rt.logger.Info("Detected file/directory move",
                zap.String("old_path", pendingMove.Path),
                zap.String("new_path", newPath),
                zap.String("storage_root", storageRoot),
                zap.Bool("is_directory", isDirectory))

        return pendingMove, true</span>
}

// ProcessMove handles a detected move operation efficiently
func (rt *RenameTracker) ProcessMove(ctx context.Context, oldMove *PendingMove, newPath string) error <span class="cov3" title="2">{
        tx, err := rt.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov3" title="2">defer tx.Rollback()

        // Record the rename event
        renameEventID, err := rt.recordRenameEvent(tx, oldMove, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to record rename event: %w", err)
        }</span>

        <span class="cov3" title="2">if oldMove.IsDirectory </span><span class="cov1" title="1">{
                // Handle directory move - update all child paths
                err = rt.moveDirectory(tx, oldMove.Path, newPath, oldMove.StorageRoot)
        }</span> else<span class="cov1" title="1"> {
                // Handle file move - update single file
                err = rt.moveFile(tx, oldMove.FileID, newPath)
        }</span>

        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                // Mark rename event as failed
                rt.markRenameEventStatus(tx, renameEventID, "failed")
                return fmt.Errorf("failed to process move: %w", err)
        }</span>

        // Mark rename event as processed
        <span class="cov3" title="2">if err = rt.markRenameEventStatus(tx, renameEventID, "processed"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark rename event as processed: %w", err)
        }</span>

        <span class="cov3" title="2">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit move transaction: %w", err)
        }</span>

        <span class="cov3" title="2">rt.logger.Info("Successfully processed move operation",
                zap.String("old_path", oldMove.Path),
                zap.String("new_path", newPath),
                zap.Bool("is_directory", oldMove.IsDirectory),
                zap.Int64("rename_event_id", renameEventID))

        return nil</span>
}

// moveFile updates a single file's path and metadata
func (rt *RenameTracker) moveFile(tx *sql.Tx, fileID int64, newPath string) error <span class="cov1" title="1">{
        // Extract new filename and directory info
        newName := filepath.Base(newPath)
        newDir := filepath.Dir(newPath)

        // Get parent directory ID
        var parentID *int64
        if newDir != "/" &amp;&amp; newDir != "." </span><span class="cov0" title="0">{
                parentQuery := `SELECT id FROM files WHERE path = ? AND is_directory = true LIMIT 1`
                err := tx.QueryRow(parentQuery, newDir).Scan(&amp;parentID)
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get parent directory: %w", err)
                }</span>
        }

        // Update file record
        <span class="cov1" title="1">updateQuery := `
                UPDATE files
                SET path = ?, name = ?, parent_id = ?, updated_at = CURRENT_TIMESTAMP,
                    last_scan_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := tx.Exec(updateQuery, newPath, newName, parentID, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update file path: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// moveDirectory updates a directory and all its children
func (rt *RenameTracker) moveDirectory(tx *sql.Tx, oldPath, newPath, storageRoot string) error <span class="cov1" title="1">{
        // Get all files/directories that need to be updated
        query := `
                SELECT id, path, is_directory
                FROM files
                WHERE storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)
                  AND (path = ? OR path LIKE ?)
                ORDER BY LENGTH(path) ASC` // Process parents before children

        oldPathPattern := oldPath + "/%"
        rows, err := tx.Query(query, storageRoot, oldPath, oldPathPattern)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query directory contents: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        type fileUpdate struct {
                ID          int64
                OldPath     string
                IsDirectory bool
        }

        var updates []fileUpdate
        for rows.Next() </span><span class="cov3" title="2">{
                var update fileUpdate
                if err := rows.Scan(&amp;update.ID, &amp;update.OldPath, &amp;update.IsDirectory); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan file for update: %w", err)
                }</span>
                <span class="cov3" title="2">updates = append(updates, update)</span>
        }

        // Update each file/directory path
        <span class="cov1" title="1">for _, update := range updates </span><span class="cov3" title="2">{
                var updatedPath string
                if update.OldPath == oldPath </span><span class="cov1" title="1">{
                        // This is the directory itself
                        updatedPath = newPath
                }</span> else<span class="cov1" title="1"> {
                        // This is a child - replace the old path prefix with new path
                        relativePath := update.OldPath[len(oldPath):]
                        updatedPath = newPath + relativePath
                }</span>

                // Update the file record
                <span class="cov3" title="2">newName := filepath.Base(updatedPath)
                newDir := filepath.Dir(updatedPath)

                // Get parent directory ID
                var parentID *int64
                if newDir != "/" &amp;&amp; newDir != "." &amp;&amp; newDir != newPath </span><span class="cov0" title="0">{
                        parentQuery := `SELECT id FROM files WHERE path = ? AND is_directory = true LIMIT 1`
                        err := tx.QueryRow(parentQuery, newDir).Scan(&amp;parentID)
                        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get parent directory for %s: %w", updatedPath, err)
                        }</span>
                }

                <span class="cov3" title="2">updateQuery := `
                        UPDATE files
                        SET path = ?, name = ?, parent_id = ?, updated_at = CURRENT_TIMESTAMP,
                            last_scan_at = CURRENT_TIMESTAMP
                        WHERE id = ?`

                _, err := tx.Exec(updateQuery, updatedPath, newName, parentID, update.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update path for file ID %d: %w", update.ID, err)
                }</span>

                <span class="cov3" title="2">rt.logger.Debug("Updated file path",
                        zap.String("old_path", update.OldPath),
                        zap.String("new_path", updatedPath),
                        zap.Int64("file_id", update.ID))</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// recordRenameEvent creates a record of the rename operation
func (rt *RenameTracker) recordRenameEvent(tx *sql.Tx, oldMove *PendingMove, newPath string) (int64, error) <span class="cov3" title="2">{
        query := `
                INSERT INTO rename_events (storage_root_id, old_path, new_path, is_directory, size, file_hash, detected_at, status)
                VALUES ((SELECT id FROM storage_roots WHERE name = ?), ?, ?, ?, ?, ?, ?, 'pending')`

        result, err := tx.Exec(query, oldMove.StorageRoot, oldMove.Path, newPath, oldMove.IsDirectory, oldMove.Size, oldMove.FileHash, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to insert rename event: %w", err)
        }</span>

        <span class="cov3" title="2">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get rename event ID: %w", err)
        }</span>

        <span class="cov3" title="2">return id, nil</span>
}

// markRenameEventStatus updates the status of a rename event
func (rt *RenameTracker) markRenameEventStatus(tx *sql.Tx, eventID int64, status string) error <span class="cov3" title="2">{
        query := `UPDATE rename_events SET status = ?, processed_at = CURRENT_TIMESTAMP WHERE id = ?`
        _, err := tx.Exec(query, status, eventID)
        return err
}</span>

// createMoveKey creates a unique key for tracking potential moves
func (rt *RenameTracker) CreateMoveKey(storageRoot string, fileHash *string, size int64, isDirectory bool) string <span class="cov10" title="14">{
        hashStr := "nil"
        if fileHash != nil </span><span class="cov9" title="12">{
                hashStr = *fileHash
        }</span>

        <span class="cov10" title="14">dirStr := "false"
        if isDirectory </span><span class="cov1" title="1">{
                dirStr = "true"
        }</span>

        <span class="cov10" title="14">return fmt.Sprintf("%s:%s:%d:%s", storageRoot, hashStr, size, dirStr)</span>
}

// cleanupWorker periodically cleans up expired pending moves
func (rt *RenameTracker) cleanupWorker() <span class="cov1" title="1">{
        defer rt.wg.Done()

        ticker := time.NewTicker(rt.cleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-rt.stopCh:<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rt.cleanupExpiredMoves()</span>
                }
        }
}

// cleanupExpiredMoves removes pending moves that have exceeded the time window
func (rt *RenameTracker) cleanupExpiredMoves() <span class="cov1" title="1">{
        rt.PendingMovesMu.Lock()
        defer rt.PendingMovesMu.Unlock()

        now := time.Now()
        expiredKeys := make([]string, 0)

        for key, move := range rt.PendingMoves </span><span class="cov3" title="2">{
                if now.Sub(move.DeletedAt) &gt; rt.moveWindow </span><span class="cov3" title="2">{
                        expiredKeys = append(expiredKeys, key)
                }</span>
        }

        <span class="cov1" title="1">for _, key := range expiredKeys </span><span class="cov3" title="2">{
                move := rt.PendingMoves[key]
                delete(rt.PendingMoves, key)

                rt.logger.Debug("Cleaned up expired pending move",
                        zap.String("path", move.Path),
                        zap.String("storage_root", move.StorageRoot),
                        zap.Duration("age", now.Sub(move.DeletedAt)))
        }</span>

        <span class="cov1" title="1">if len(expiredKeys) &gt; 0 </span><span class="cov1" title="1">{
                rt.logger.Debug("Cleaned up expired pending moves", zap.Int("count", len(expiredKeys)))
        }</span>
}

// GetRenameEvents returns recent rename events for monitoring
func (rt *RenameTracker) GetRenameEvents(ctx context.Context, limit int) ([]RenameEvent, error) <span class="cov1" title="1">{
        query := `
                SELECT re.id, re.storage_root_id, re.old_path, re.new_path, re.is_directory,
                       re.size, re.file_hash, re.detected_at, re.processed_at, re.status
                FROM rename_events re
                ORDER BY re.detected_at DESC
                LIMIT ?`

        rows, err := rt.db.QueryContext(ctx, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query rename events: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        var events []RenameEvent
        for rows.Next() </span><span class="cov3" title="2">{
                var event RenameEvent
                err := rows.Scan(
                        &amp;event.ID, &amp;event.StorageRootID, &amp;event.OldPath, &amp;event.NewPath,
                        &amp;event.IsDirectory, &amp;event.Size, &amp;event.FileHash, &amp;event.DetectedAt,
                        &amp;event.ProcessedAt, &amp;event.Status,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan rename event: %w", err)
                }</span>
                <span class="cov3" title="2">events = append(events, event)</span>
        }

        <span class="cov1" title="1">return events, nil</span>
}

// GetStatistics returns statistics about rename detection
func (rt *RenameTracker) GetStatistics() map[string]interface{} <span class="cov1" title="1">{
        rt.PendingMovesMu.RLock()
        pendingCount := len(rt.PendingMoves)
        rt.PendingMovesMu.RUnlock()

        stats := map[string]interface{}{
                "pending_moves": pendingCount,
                "move_window":   rt.moveWindow.String(),
        }

        // Get database statistics
        var totalRenames, successfulRenames int
        rt.db.QueryRow("SELECT COUNT(*) FROM rename_events").Scan(&amp;totalRenames)
        rt.db.QueryRow("SELECT COUNT(*) FROM rename_events WHERE status = 'processed'").Scan(&amp;successfulRenames)

        stats["total_renames"] = totalRenames
        stats["successful_renames"] = successfulRenames

        if totalRenames &gt; 0 </span><span class="cov1" title="1">{
                stats["success_rate"] = float64(successfulRenames) / float64(totalRenames) * 100
        }</span> else<span class="cov0" title="0"> {
                stats["success_rate"] = 0.0
        }</span>

        <span class="cov1" title="1">return stats</span>
}

// InitializeTables creates the rename tracking tables
func (rt *RenameTracker) InitializeTables() error <span class="cov6" title="5">{
        query := `
                CREATE TABLE IF NOT EXISTS rename_events (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        storage_root_id INTEGER NOT NULL,
                        old_path TEXT NOT NULL,
                        new_path TEXT NOT NULL,
                        is_directory BOOLEAN NOT NULL,
                        size INTEGER NOT NULL,
                        file_hash TEXT,
                        detected_at TIMESTAMP NOT NULL,
                        processed_at TIMESTAMP,
                        status TEXT NOT NULL DEFAULT 'pending',
                        FOREIGN KEY (storage_root_id) REFERENCES storage_roots (id)
                );

                CREATE INDEX IF NOT EXISTS idx_rename_events_storage_root ON rename_events(storage_root_id);
                CREATE INDEX IF NOT EXISTS idx_rename_events_detected_at ON rename_events(detected_at);
                CREATE INDEX IF NOT EXISTS idx_rename_events_status ON rename_events(status);
        `

        _, err := rt.db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create rename tracking tables: %w", err)
        }</span>

        <span class="cov6" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package services

import (
        "catalogizer/internal/config"
        "catalogizer/internal/models"
        "context"
        "fmt"
        "io"
        "net"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/hirochachacha/go-smb2"
        "go.uber.org/zap"
)

// SMBServiceInterface defines the interface for SMB operations
type SMBServiceInterface interface {
        GetHosts() []string
        ListFiles(hostName, path string) ([]os.FileInfo, error)
        DownloadFile(hostName, remotePath, localPath string) error
        UploadFile(hostName, localPath, remotePath string) error
        CopyFile(sourceHost, sourcePath, destHost, destPath string) error
        CreateRemoteDir(share *smb2.Share, path string) error
        FileExists(hostName, path string) (bool, error)
        ListDirectory(hostName, path string) ([]*models.FileInfo, error)
        IsConnected(hostName string) bool
        GetFileSize(hostName, path string) (int64, error)
        CreateDirectory(hostName, path string) error
        DeleteDirectory(hostName, path string) error
        DirectoryExists(hostName, path string) (bool, error)
        IsValidSMBPath(path string) bool
        ParseSMBPath(path string) models.SMBPath
}

type SMBService struct {
        config *config.Config
        logger *zap.Logger
}

func NewSMBService(cfg *config.Config, logger *zap.Logger) *SMBService <span class="cov0" title="0">{
        return &amp;SMBService{
                config: cfg,
                logger: logger,
        }
}</span>

func (s *SMBService) getConnection(hostName string) (*smb2.Session, error) <span class="cov0" title="0">{
        var smbHost *config.SMBHost
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        smbHost = &amp;host
                        break</span>
                }
        }

        <span class="cov0" title="0">if smbHost == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SMB host not found: %s", hostName)
        }</span>

        <span class="cov0" title="0">conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", smbHost.Host, smbHost.Port))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to SMB host: %w", err)
        }</span>

        <span class="cov0" title="0">d := &amp;smb2.Dialer{
                Initiator: &amp;smb2.NTLMInitiator{
                        User:     smbHost.Username,
                        Password: smbHost.Password,
                        Domain:   smbHost.Domain,
                },
        }

        session, err := d.Dial(conn)
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to create SMB session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *SMBService) ListFiles(hostName, path string) ([]os.FileInfo, error) <span class="cov0" title="0">{
        session, err := s.getConnection(hostName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        var smbHost *config.SMBHost
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        smbHost = &amp;host
                        break</span>
                }
        }

        <span class="cov0" title="0">share, err := session.Mount(smbHost.Share)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to mount share: %w", err)
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        files, err := share.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read directory: %w", err)
        }</span>

        <span class="cov0" title="0">return files, nil</span>
}

func (s *SMBService) DownloadFile(hostName, remotePath, localPath string) error <span class="cov0" title="0">{
        session, err := s.getConnection(hostName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        var smbHost *config.SMBHost
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        smbHost = &amp;host
                        break</span>
                }
        }

        <span class="cov0" title="0">share, err := session.Mount(smbHost.Share)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mount share: %w", err)
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        // Create local directory if it doesn't exist
        if err := os.MkdirAll(filepath.Dir(localPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local directory: %w", err)
        }</span>

        // Open remote file
        <span class="cov0" title="0">remoteFile, err := share.Open(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open remote file: %w", err)
        }</span>
        <span class="cov0" title="0">defer remoteFile.Close()

        // Create local file
        localFile, err := os.Create(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local file: %w", err)
        }</span>
        <span class="cov0" title="0">defer localFile.Close()

        // Copy data in chunks
        buf := make([]byte, s.config.SMB.ChunkSize)
        _, err = io.CopyBuffer(localFile, remoteFile, buf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("File downloaded successfully",
                zap.String("remote", remotePath),
                zap.String("local", localPath))

        return nil</span>
}

func (s *SMBService) UploadFile(hostName, localPath, remotePath string) error <span class="cov0" title="0">{
        session, err := s.getConnection(hostName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        var smbHost *config.SMBHost
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        smbHost = &amp;host
                        break</span>
                }
        }

        <span class="cov0" title="0">share, err := session.Mount(smbHost.Share)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mount share: %w", err)
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        // Create remote directory if it doesn't exist
        remoteDir := filepath.Dir(remotePath)
        if remoteDir != "." &amp;&amp; remoteDir != "/" </span><span class="cov0" title="0">{
                if err := s.CreateRemoteDir(share, remoteDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create remote directory: %w", err)
                }</span>
        }

        // Open local file
        <span class="cov0" title="0">localFile, err := os.Open(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open local file: %w", err)
        }</span>
        <span class="cov0" title="0">defer localFile.Close()

        // Create remote file
        remoteFile, err := share.Create(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create remote file: %w", err)
        }</span>
        <span class="cov0" title="0">defer remoteFile.Close()

        // Copy data in chunks
        buf := make([]byte, s.config.SMB.ChunkSize)
        _, err = io.CopyBuffer(remoteFile, localFile, buf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("File uploaded successfully",
                zap.String("local", localPath),
                zap.String("remote", remotePath))

        return nil</span>
}

func (s *SMBService) CopyFile(sourceHost, sourcePath, destHost, destPath string) error <span class="cov0" title="0">{
        _, cancel := context.WithTimeout(context.Background(), time.Duration(s.config.SMB.Timeout)*time.Second)
        defer cancel()

        // Create a temporary file for the transfer
        tempFile, err := os.CreateTemp(s.config.Catalog.TempDir, "smb_copy_*")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp file: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempFile.Name())
        defer tempFile.Close()

        // Download from source
        if err := s.DownloadFile(sourceHost, sourcePath, tempFile.Name()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download from source: %w", err)
        }</span>

        // Upload to destination
        <span class="cov0" title="0">if err := s.UploadFile(destHost, tempFile.Name(), destPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload to destination: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("File copied successfully",
                zap.String("source", fmt.Sprintf("%s:%s", sourceHost, sourcePath)),
                zap.String("destination", fmt.Sprintf("%s:%s", destHost, destPath)))

        return nil</span>
}

func (s *SMBService) CreateRemoteDir(share *smb2.Share, path string) error <span class="cov0" title="0">{
        parts := strings.Split(path, "/")
        currentPath := ""

        for _, part := range parts </span><span class="cov0" title="0">{
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if currentPath == "" </span><span class="cov0" title="0">{
                        currentPath = part
                }</span> else<span class="cov0" title="0"> {
                        currentPath = currentPath + "/" + part
                }</span>

                // Try to create the directory (ignore error if it already exists)
                <span class="cov0" title="0">err := share.Mkdir(currentPath, 0755)
                if err != nil &amp;&amp; !strings.Contains(err.Error(), "already exists") </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %w", currentPath, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SMBService) FileExists(hostName, path string) (bool, error) <span class="cov0" title="0">{
        session, err := s.getConnection(hostName)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        var smbHost *config.SMBHost
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        smbHost = &amp;host
                        break</span>
                }
        }

        <span class="cov0" title="0">share, err := session.Mount(smbHost.Share)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to mount share: %w", err)
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        _, err = share.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to stat file: %w", err)</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

func (s *SMBService) GetHosts() []string <span class="cov0" title="0">{
        var hosts []string
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                hosts = append(hosts, host.Name)
        }</span>
        <span class="cov0" title="0">return hosts</span>
}

// IsValidSMBPath checks if the given path is a valid SMB path
func (s *SMBService) IsValidSMBPath(path string) bool <span class="cov0" title="0">{
        // Basic validation for SMB paths like \\host\share\path
        if !strings.HasPrefix(path, "\\\\") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">parts := strings.Split(strings.TrimPrefix(path, "\\\\"), "\\")
        return len(parts) &gt;= 2 &amp;&amp; parts[0] != "" &amp;&amp; parts[1] != ""</span>
}

// ParseSMBPath parses an SMB path into its components
func (s *SMBService) ParseSMBPath(path string) models.SMBPath <span class="cov0" title="0">{
        smbPath := models.SMBPath{Valid: false}

        if !s.IsValidSMBPath(path) </span><span class="cov0" title="0">{
                return smbPath
        }</span>

        // Remove leading \\ and split
        <span class="cov0" title="0">parts := strings.Split(strings.TrimPrefix(path, "\\\\"), "\\")
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return smbPath
        }</span>

        <span class="cov0" title="0">smbPath.Server = parts[0]
        smbPath.Share = parts[1]
        if len(parts) &gt; 2 </span><span class="cov0" title="0">{
                smbPath.Path = strings.Join(parts[2:], "\\")
        }</span>
        <span class="cov0" title="0">smbPath.Valid = true

        return smbPath</span>
}

// Connect establishes a connection to an SMB host (stub implementation)
func (s *SMBService) Connect(hostName string) error <span class="cov0" title="0">{
        // Check if host exists in config
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        return nil // Connection successful
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("SMB host not found: %s", hostName)</span>
}

// ListDirectory lists files in a directory on an SMB host
func (s *SMBService) ListDirectory(hostName, path string) ([]*models.FileInfo, error) <span class="cov0" title="0">{
        files, err := s.ListFiles(hostName, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result []*models.FileInfo
        for _, file := range files </span><span class="cov0" title="0">{
                fileInfo := &amp;models.FileInfo{
                        Name:         file.Name(),
                        Path:         path + "/" + file.Name(),
                        IsDirectory:  file.IsDir(),
                        Size:         file.Size(),
                        LastModified: file.ModTime(),
                }
                result = append(result, fileInfo)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// IsConnected checks if connected to an SMB host
func (s *SMBService) IsConnected(hostName string) bool <span class="cov0" title="0">{
        for _, host := range s.config.SMB.Hosts </span><span class="cov0" title="0">{
                if host.Name == hostName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetFileSize gets the size of a file on an SMB host
func (s *SMBService) GetFileSize(hostName, path string) (int64, error) <span class="cov0" title="0">{
        files, err := s.ListFiles(hostName, path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("file not found")
        }</span>
        <span class="cov0" title="0">return files[0].Size(), nil</span>
}

// CreateDirectory creates a directory on an SMB host
func (s *SMBService) CreateDirectory(hostName, path string) error <span class="cov0" title="0">{
        // This is a stub implementation
        return fmt.Errorf("CreateDirectory not implemented")
}</span>

// DeleteDirectory deletes a directory on an SMB host
func (s *SMBService) DeleteDirectory(hostName, path string) error <span class="cov0" title="0">{
        // This is a stub implementation
        return fmt.Errorf("DeleteDirectory not implemented")
}</span>

// DirectoryExists checks if a directory exists on an SMB host
func (s *SMBService) DirectoryExists(hostName, path string) (bool, error) <span class="cov0" title="0">{
        // This is a stub implementation
        return false, fmt.Errorf("DirectoryExists not implemented")
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package services

import (
        "context"
        "fmt"
        "net"
        "strings"
        "time"

        "github.com/hirochachacha/go-smb2"
        "go.uber.org/zap"
)

// SMBShareInfo represents an SMB share
type SMBShareInfo struct {
        Host        string  `json:"host"`
        ShareName   string  `json:"share_name"`
        Path        string  `json:"path"`
        Writable    bool    `json:"writable"`
        Description *string `json:"description"`
}

// SMBFileEntry represents a file or directory in an SMB share
type SMBFileEntry struct {
        Name        string  `json:"name"`
        Path        string  `json:"path"`
        IsDirectory bool    `json:"is_directory"`
        Size        *int64  `json:"size"`
        Modified    *string `json:"modified"`
}

// SMBConnectionConfig represents SMB connection parameters
type SMBConnectionConfig struct {
        Host     string  `json:"host"`
        Port     int     `json:"port"`
        Share    string  `json:"share"`
        Username string  `json:"username"`
        Password string  `json:"password"`
        Domain   *string `json:"domain"`
}

// SMBDiscoveryService provides SMB share discovery and testing
type SMBDiscoveryService struct {
        logger  *zap.Logger
        timeout time.Duration
}

// NewSMBDiscoveryService creates a new SMB discovery service
func NewSMBDiscoveryService(logger *zap.Logger) *SMBDiscoveryService <span class="cov3" title="2">{
        return &amp;SMBDiscoveryService{
                logger:  logger,
                timeout: 10 * time.Second,
        }
}</span>

// DiscoverShares discovers available SMB shares on a host
func (s *SMBDiscoveryService) DiscoverShares(ctx context.Context, host string, username, password string, domain *string) ([]SMBShareInfo, error) <span class="cov0" title="0">{
        s.logger.Info("Discovering SMB shares", zap.String("host", host), zap.String("username", username))

        // Establish connection
        conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:445", host), s.timeout)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to connect to SMB host", zap.String("host", host), zap.Error(err))
                return nil, fmt.Errorf("failed to connect to SMB host %s: %w", host, err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create SMB session
        d := &amp;smb2.Dialer{
                Initiator: &amp;smb2.NTLMInitiator{
                        User:     username,
                        Password: password,
                        Domain:   getStringValue(domain),
                },
        }

        session, err := d.Dial(conn)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create SMB session", zap.String("host", host), zap.Error(err))
                return nil, fmt.Errorf("failed to create SMB session: %w", err)
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        // Try to enumerate shares using IPC$ administrative share
        shares, err := s.enumerateShares(session, host)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to enumerate shares via IPC$, falling back to common shares", zap.Error(err))
                // Fallback to common share names
                return s.getCommonShares(ctx, host, username, password, domain), nil
        }</span>

        <span class="cov0" title="0">return shares, nil</span>
}

// enumerateShares attempts to enumerate shares using administrative interfaces
func (s *SMBDiscoveryService) enumerateShares(session *smb2.Session, host string) ([]SMBShareInfo, error) <span class="cov0" title="0">{
        // This is a simplified implementation. In practice, you might need to use
        // Windows administrative APIs through SMB to enumerate shares properly.
        // For now, we'll try to mount IPC$ and see if we can get share information.

        // Try common administrative share names to detect existence
        commonShares := []string{
                "C$", "D$", "E$", "F$", "admin$", "print$", "ipc$",
                "shared", "public", "media", "downloads", "documents",
                "music", "videos", "pictures", "backup", "data",
        }

        var availableShares []SMBShareInfo

        for _, shareName := range commonShares </span><span class="cov0" title="0">{
                if s.testShareAccess(session, shareName) </span><span class="cov0" title="0">{
                        availableShares = append(availableShares, SMBShareInfo{
                                Host:        host,
                                ShareName:   shareName,
                                Path:        fmt.Sprintf("\\\\%s\\%s", host, shareName),
                                Writable:    false, // We don't test write access here
                                Description: getShareDescription(shareName),
                        })
                }</span>
        }

        <span class="cov0" title="0">return availableShares, nil</span>
}

// testShareAccess tests if a share can be accessed
func (s *SMBDiscoveryService) testShareAccess(session *smb2.Session, shareName string) bool <span class="cov0" title="0">{
        share, err := session.Mount(shareName)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        // Try to list the root directory
        _, err = share.ReadDir(".")
        return err == nil</span>
}

// getCommonShares returns common share names to try
func (s *SMBDiscoveryService) getCommonShares(ctx context.Context, host, username, password string, domain *string) []SMBShareInfo <span class="cov1" title="1">{
        commonShares := []SMBShareInfo{
                {Host: host, ShareName: "shared", Path: fmt.Sprintf("\\\\%s\\shared", host), Description: smbStringPtr("Shared folder")},
                {Host: host, ShareName: "public", Path: fmt.Sprintf("\\\\%s\\public", host), Description: smbStringPtr("Public folder")},
                {Host: host, ShareName: "media", Path: fmt.Sprintf("\\\\%s\\media", host), Description: smbStringPtr("Media files")},
                {Host: host, ShareName: "downloads", Path: fmt.Sprintf("\\\\%s\\downloads", host), Description: smbStringPtr("Downloads")},
                {Host: host, ShareName: "documents", Path: fmt.Sprintf("\\\\%s\\documents", host), Description: smbStringPtr("Documents")},
                {Host: host, ShareName: "music", Path: fmt.Sprintf("\\\\%s\\music", host), Description: smbStringPtr("Music files")},
                {Host: host, ShareName: "videos", Path: fmt.Sprintf("\\\\%s\\videos", host), Description: smbStringPtr("Video files")},
                {Host: host, ShareName: "pictures", Path: fmt.Sprintf("\\\\%s\\pictures", host), Description: smbStringPtr("Pictures")},
                {Host: host, ShareName: "backup", Path: fmt.Sprintf("\\\\%s\\backup", host), Description: smbStringPtr("Backup files")},
        }

        // Test which ones are actually accessible
        var accessibleShares []SMBShareInfo
        for _, share := range commonShares </span><span class="cov9" title="9">{
                if s.TestConnection(ctx, SMBConnectionConfig{
                        Host:     host,
                        Port:     445,
                        Share:    share.ShareName,
                        Username: username,
                        Password: password,
                        Domain:   domain,
                }) </span><span class="cov0" title="0">{
                        accessibleShares = append(accessibleShares, share)
                }</span>
        }

        // If no shares are accessible (e.g., host unreachable), return common shares as suggestions
        <span class="cov1" title="1">if len(accessibleShares) == 0 </span><span class="cov1" title="1">{
                return commonShares
        }</span>

        <span class="cov0" title="0">return accessibleShares</span>
}

// TestConnection tests an SMB connection with the provided credentials
func (s *SMBDiscoveryService) TestConnection(ctx context.Context, config SMBConnectionConfig) bool <span class="cov10" title="10">{
        s.logger.Info("Testing SMB connection",
                zap.String("host", config.Host),
                zap.String("share", config.Share),
                zap.String("username", config.Username))

        // Establish connection
        conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", config.Host, config.Port), s.timeout)
        if err != nil </span><span class="cov10" title="10">{
                s.logger.Debug("Failed to connect to SMB host", zap.String("host", config.Host), zap.Error(err))
                return false
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create SMB session
        d := &amp;smb2.Dialer{
                Initiator: &amp;smb2.NTLMInitiator{
                        User:     config.Username,
                        Password: config.Password,
                        Domain:   getStringValue(config.Domain),
                },
        }

        session, err := d.Dial(conn)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to create SMB session", zap.String("host", config.Host), zap.Error(err))
                return false
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        // Try to mount the share
        share, err := session.Mount(config.Share)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to mount SMB share", zap.String("share", config.Share), zap.Error(err))
                return false
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        // Try to list the root directory
        _, err = share.ReadDir(".")
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to read SMB share directory", zap.String("share", config.Share), zap.Error(err))
                return false
        }</span>

        <span class="cov0" title="0">s.logger.Info("SMB connection test successful", zap.String("host", config.Host), zap.String("share", config.Share))
        return true</span>
}

// BrowseShare browses files and directories in an SMB share
func (s *SMBDiscoveryService) BrowseShare(ctx context.Context, config SMBConnectionConfig, path string) ([]SMBFileEntry, error) <span class="cov0" title="0">{
        s.logger.Info("Browsing SMB share",
                zap.String("host", config.Host),
                zap.String("share", config.Share),
                zap.String("path", path))

        // Establish connection
        conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", config.Host, config.Port), s.timeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to SMB host %s: %w", config.Host, err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create SMB session
        d := &amp;smb2.Dialer{
                Initiator: &amp;smb2.NTLMInitiator{
                        User:     config.Username,
                        Password: config.Password,
                        Domain:   getStringValue(config.Domain),
                },
        }

        session, err := d.Dial(conn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create SMB session: %w", err)
        }</span>
        <span class="cov0" title="0">defer session.Logoff()

        // Mount the share
        share, err := session.Mount(config.Share)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to mount SMB share: %w", err)
        }</span>
        <span class="cov0" title="0">defer share.Umount()

        // List directory contents
        entries, err := share.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read directory %s: %w", path, err)
        }</span>

        // Convert to our format
        <span class="cov0" title="0">var fileEntries []SMBFileEntry
        for _, entry := range entries </span><span class="cov0" title="0">{
                var size *int64
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        entrySize := entry.Size()
                        size = &amp;entrySize
                }</span>

                <span class="cov0" title="0">modTime := entry.ModTime().Format("2006-01-02 15:04:05")

                fileEntries = append(fileEntries, SMBFileEntry{
                        Name:        entry.Name(),
                        Path:        path + "/" + entry.Name(),
                        IsDirectory: entry.IsDir(),
                        Size:        size,
                        Modified:    &amp;modTime,
                })</span>
        }

        <span class="cov0" title="0">return fileEntries, nil</span>
}

// Helper functions
func getStringValue(s *string) string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *s</span>
}

func smbStringPtr(s string) *string <span class="cov9" title="9">{
        return &amp;s
}</span>

func getShareDescription(shareName string) *string <span class="cov0" title="0">{
        descriptions := map[string]string{
                "C$":        "System drive (administrative)",
                "D$":        "Data drive (administrative)",
                "E$":        "Additional drive (administrative)",
                "F$":        "Additional drive (administrative)",
                "admin$":    "Administrative share",
                "print$":    "Printer drivers",
                "ipc$":      "Inter-process communication",
                "shared":    "Shared folder",
                "public":    "Public folder",
                "media":     "Media files",
                "downloads": "Downloads",
                "documents": "Documents",
                "music":     "Music files",
                "videos":    "Video files",
                "pictures":  "Pictures",
                "backup":    "Backup files",
                "data":      "Data files",
        }

        if desc, exists := descriptions[strings.ToLower(shareName)]; exists </span><span class="cov0" title="0">{
                return &amp;desc
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package services

import (
        "context"
        "database/sql"
        "fmt"
        "io"
        "net/http"
        "regexp"
        "strconv"
        "strings"
        "time"

        "go.uber.org/zap"
)

// SubtitleService handles subtitle management, downloading, and translation
type SubtitleService struct {
        db                 *sql.DB
        logger             *zap.Logger
        translationService *TranslationService
        cacheService       *CacheService
        httpClient         *http.Client
        apiKeys            map[string]string
        cacheDir           string
}

// SubtitleProvider represents different subtitle providers
type SubtitleProvider string

const (
        ProviderOpenSubtitles SubtitleProvider = "opensubtitles"
        ProviderSubDB         SubtitleProvider = "subdb"
        ProviderYifySubtitles SubtitleProvider = "yifysubtitles"
        ProviderSubscene      SubtitleProvider = "subscene"
        ProviderAddic7ed      SubtitleProvider = "addic7ed"
)

// SubtitleSearchRequest represents a subtitle search request
type SubtitleSearchRequest struct {
        MediaPath     string             `json:"media_path"`
        Title         *string            `json:"title,omitempty"`
        Year          *int               `json:"year,omitempty"`
        Season        *int               `json:"season,omitempty"`
        Episode       *int               `json:"episode,omitempty"`
        Languages     []string           `json:"languages"`
        FileHash      *string            `json:"file_hash,omitempty"`
        FileSize      *int64             `json:"file_size,omitempty"`
        Providers     []SubtitleProvider `json:"providers,omitempty"`
        ForceDownload bool               `json:"force_download"`
}

// SubtitleSearchResult represents a subtitle search result
type SubtitleSearchResult struct {
        ID                string           `json:"id"`
        Provider          SubtitleProvider `json:"provider"`
        Language          string           `json:"language"`
        LanguageCode      string           `json:"language_code"`
        Title             string           `json:"title"`
        DownloadURL       string           `json:"download_url"`
        Format            string           `json:"format"`
        Encoding          string           `json:"encoding"`
        UploadDate        time.Time        `json:"upload_date"`
        Downloads         int              `json:"downloads"`
        Rating            float64          `json:"rating"`
        Comments          int              `json:"comments"`
        IsHearingImpaired bool             `json:"is_hearing_impaired"`
        FrameRate         *float64         `json:"frame_rate,omitempty"`
        FileHash          *string          `json:"file_hash,omitempty"`
        MovieHash         *string          `json:"movie_hash,omitempty"`
        MatchScore        float64          `json:"match_score"`
}

// SubtitleSyncResult represents subtitle synchronization verification
type SubtitleSyncResult struct {
        IsValid        bool        `json:"is_valid"`
        SyncOffset     float64     `json:"sync_offset"` // Milliseconds
        Confidence     float64     `json:"confidence"`  // 0-1
        DetectedFrames int         `json:"detected_frames"`
        SamplePoints   []SyncPoint `json:"sample_points"`
        Recommendation string      `json:"recommendation"`
}

// SyncPoint represents a point used for sync verification
type SyncPoint struct {
        SubtitleTime float64 `json:"subtitle_time"`
        VideoTime    float64 `json:"video_time"`
        Text         string  `json:"text"`
        Confidence   float64 `json:"confidence"`
}

// SubtitleDownloadRequest represents a subtitle download request
type SubtitleDownloadRequest struct {
        MediaItemID   int64    `json:"media_item_id"`
        ResultID      string   `json:"result_id"`
        Language      string   `json:"language"`
        VerifySync    bool     `json:"verify_sync"`
        AutoTranslate []string `json:"auto_translate,omitempty"` // Languages to auto-translate to
}

// SubtitleTranslationRequest represents a subtitle translation request
type SubtitleTranslationRequest struct {
        SubtitleID     string `json:"subtitle_id"`
        SourceLanguage string `json:"source_language"`
        TargetLanguage string `json:"target_language"`
        UseCache       bool   `json:"use_cache"`
}

// SubtitleLine represents a single subtitle line
type SubtitleLine struct {
        Index     int    `json:"index"`
        StartTime string `json:"start_time"`
        EndTime   string `json:"end_time"`
        Text      string `json:"text"`
}

// NewSubtitleService creates a new subtitle service
func NewSubtitleService(db *sql.DB, logger *zap.Logger, cacheService *CacheService) *SubtitleService <span class="cov0" title="0">{
        return &amp;SubtitleService{
                db:                 db,
                logger:             logger,
                translationService: NewTranslationService(logger),
                cacheService:       cacheService,
                httpClient:         &amp;http.Client{Timeout: 30 * time.Second},
                apiKeys:            make(map[string]string),
                cacheDir:           "./cache/subtitles",
        }
}</span>

// SearchSubtitles searches for subtitles across multiple providers
func (s *SubtitleService) SearchSubtitles(ctx context.Context, request *SubtitleSearchRequest) ([]SubtitleSearchResult, error) <span class="cov0" title="0">{
        s.logger.Info("Searching subtitles",
                zap.String("media_path", request.MediaPath),
                zap.Strings("languages", request.Languages))

        var allResults []SubtitleSearchResult

        // Default providers if none specified
        providers := request.Providers
        if len(providers) == 0 </span><span class="cov0" title="0">{
                providers = []SubtitleProvider{
                        ProviderOpenSubtitles,
                        ProviderSubDB,
                        ProviderYifySubtitles,
                }
        }</span>

        // Search each provider in parallel
        <span class="cov0" title="0">resultsChan := make(chan []SubtitleSearchResult, len(providers))
        errorsChan := make(chan error, len(providers))

        for _, provider := range providers </span><span class="cov0" title="0">{
                go func(p SubtitleProvider) </span><span class="cov0" title="0">{
                        results, err := s.searchProvider(ctx, p, request)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Provider search failed",
                                        zap.String("provider", string(p)),
                                        zap.Error(err))
                                errorsChan &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">resultsChan &lt;- results</span>
                }(provider)
        }

        // Collect results
        <span class="cov0" title="0">for i := 0; i &lt; len(providers); i++ </span><span class="cov0" title="0">{
                select </span>{
                case results := &lt;-resultsChan:<span class="cov0" title="0">
                        allResults = append(allResults, results...)</span>
                case &lt;-errorsChan:<span class="cov0" title="0"></span>
                        // Log error but continue with other providers
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                }
        }

        // Sort by match score and rating
        <span class="cov0" title="0">s.sortSubtitleResults(allResults)

        s.logger.Info("Subtitle search completed",
                zap.Int("total_results", len(allResults)))

        return allResults, nil</span>
}

// DownloadSubtitle downloads a subtitle and optionally verifies sync
func (s *SubtitleService) DownloadSubtitle(ctx context.Context, request *SubtitleDownloadRequest) (*SubtitleTrack, error) <span class="cov0" title="0">{
        s.logger.Info("Downloading subtitle",
                zap.Int64("media_item_id", request.MediaItemID),
                zap.String("result_id", request.ResultID))

        // Get download info from cache or provider
        result, err := s.getDownloadInfo(ctx, request.ResultID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get download info: %w", err)
        }</span>

        // Download subtitle content
        <span class="cov0" title="0">content, encoding, err := s.downloadContent(ctx, result.DownloadURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to download subtitle content: %w", err)
        }</span>

        // Parse and validate subtitle format
        <span class="cov0" title="0">_, err = s.parseSubtitle(content, result.Format)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse subtitle: %w", err)
        }</span>

        // Create subtitle track
        <span class="cov0" title="0">track := &amp;SubtitleTrack{
                ID:           generateSubtitleID(),
                Language:     result.Language,
                LanguageCode: result.LanguageCode,
                Source:       "downloaded",
                Format:       result.Format,
                Content:      &amp;content,
                IsDefault:    false,
                IsForced:     false,
                Encoding:     encoding,
                SyncOffset:   0.0,
                CreatedAt:    time.Now(),
                VerifiedSync: false,
        }

        // Verify synchronization if requested
        if request.VerifySync </span><span class="cov0" title="0">{
                syncResult, err := s.verifySynchronization(ctx, request.MediaItemID, track)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to verify subtitle sync", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        track.VerifiedSync = syncResult.IsValid
                        track.SyncOffset = syncResult.SyncOffset
                }</span>
        }

        // Save to database
        <span class="cov0" title="0">if err := s.saveSubtitleTrack(ctx, request.MediaItemID, track); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save subtitle track: %w", err)
        }</span>

        // Auto-translate to requested languages
        <span class="cov0" title="0">if len(request.AutoTranslate) &gt; 0 </span><span class="cov0" title="0">{
                go s.autoTranslateSubtitle(ctx, track, request.AutoTranslate)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Subtitle downloaded successfully",
                zap.String("subtitle_id", track.ID),
                zap.String("language", track.Language))

        return track, nil</span>
}

// TranslateSubtitle translates a subtitle to another language
func (s *SubtitleService) TranslateSubtitle(ctx context.Context, request *SubtitleTranslationRequest) (*SubtitleTrack, error) <span class="cov0" title="0">{
        s.logger.Info("Translating subtitle",
                zap.String("subtitle_id", request.SubtitleID),
                zap.String("target_language", request.TargetLanguage))

        // Check cache first
        if request.UseCache </span><span class="cov0" title="0">{
                if cached := s.getCachedTranslation(ctx, request.SubtitleID, request.TargetLanguage); cached != nil </span><span class="cov0" title="0">{
                        return cached, nil
                }</span>
        }

        // Get original subtitle
        <span class="cov0" title="0">original, err := s.getSubtitleTrack(ctx, request.SubtitleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get original subtitle: %w", err)
        }</span>

        // Parse subtitle for translation
        <span class="cov0" title="0">lines, err := s.parseSubtitleLines(*original.Content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse subtitle lines: %w", err)
        }</span>

        // Translate each line
        <span class="cov0" title="0">translatedLines, err := s.translateLines(ctx, lines, request.SourceLanguage, request.TargetLanguage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to translate lines: %w", err)
        }</span>

        // Reconstruct subtitle content
        <span class="cov0" title="0">translatedContent, err := s.reconstructSubtitle(original.Format, translatedLines)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to reconstruct subtitle: %w", err)
        }</span>

        // Create translated subtitle track
        <span class="cov0" title="0">translatedTrack := &amp;SubtitleTrack{
                ID:           generateSubtitleID(),
                Language:     getLanguageName(request.TargetLanguage),
                LanguageCode: request.TargetLanguage,
                Source:       "translated",
                Format:       original.Format,
                Content:      &amp;translatedContent,
                IsDefault:    false,
                IsForced:     false,
                Encoding:     original.Encoding,
                SyncOffset:   original.SyncOffset,
                CreatedAt:    time.Now(),
                VerifiedSync: original.VerifiedSync,
        }

        // Save translated subtitle
        if err := s.saveCachedTranslation(ctx, request.SubtitleID, request.TargetLanguage, translatedTrack); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to cache translation", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return translatedTrack, nil</span>
}

// GetSubtitles returns all subtitles for a media item
func (s *SubtitleService) GetSubtitles(ctx context.Context, mediaItemID int64) ([]SubtitleTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, language, language_code, source, format, path, content,
                       is_default, is_forced, encoding, sync_offset, created_at, verified_sync
                FROM subtitle_tracks WHERE media_item_id = ?
                ORDER BY is_default DESC, language`

        rows, err := s.db.QueryContext(ctx, query, mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query subtitles: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var subtitles []SubtitleTrack
        for rows.Next() </span><span class="cov0" title="0">{
                var track SubtitleTrack
                var content sql.NullString
                var path sql.NullString

                err := rows.Scan(
                        &amp;track.ID, &amp;track.Language, &amp;track.LanguageCode, &amp;track.Source,
                        &amp;track.Format, &amp;path, &amp;content, &amp;track.IsDefault, &amp;track.IsForced,
                        &amp;track.Encoding, &amp;track.SyncOffset, &amp;track.CreatedAt, &amp;track.VerifiedSync,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan subtitle: %w", err)
                }</span>

                <span class="cov0" title="0">if path.Valid </span><span class="cov0" title="0">{
                        track.Path = &amp;path.String
                }</span>
                <span class="cov0" title="0">if content.Valid </span><span class="cov0" title="0">{
                        track.Content = &amp;content.String
                }</span>

                <span class="cov0" title="0">subtitles = append(subtitles, track)</span>
        }

        <span class="cov0" title="0">return subtitles, nil</span>
}

// VerifySynchronization checks if subtitles are properly synchronized with video
func (s *SubtitleService) verifySynchronization(ctx context.Context, mediaItemID int64, track *SubtitleTrack) (*SubtitleSyncResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Verifying subtitle synchronization",
                zap.Int64("media_item_id", mediaItemID),
                zap.String("subtitle_id", track.ID))

        // Get video metadata
        videoInfo, err := s.getVideoInfo(ctx, mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get video info: %w", err)
        }</span>

        // Parse subtitle timing
        <span class="cov0" title="0">lines, err := s.parseSubtitleLines(*track.Content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse subtitle lines: %w", err)
        }</span>

        // Analyze timing patterns
        <span class="cov0" title="0">samplePoints := s.extractSamplePoints(lines, videoInfo.Duration)

        // Calculate sync offset and confidence
        syncOffset, confidence := s.calculateSyncOffset(samplePoints, videoInfo)

        result := &amp;SubtitleSyncResult{
                IsValid:        confidence &gt; 0.7, // 70% confidence threshold
                SyncOffset:     syncOffset,
                Confidence:     confidence,
                DetectedFrames: len(samplePoints),
                SamplePoints:   samplePoints,
        }

        if result.IsValid </span><span class="cov0" title="0">{
                result.Recommendation = "Subtitle synchronization is good"
        }</span> else<span class="cov0" title="0"> if confidence &gt; 0.4 </span><span class="cov0" title="0">{
                result.Recommendation = fmt.Sprintf("Subtitle may need %+.1fs offset", syncOffset/1000)
        }</span> else<span class="cov0" title="0"> {
                result.Recommendation = "Subtitle synchronization is poor"
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Provider-specific search implementations
func (s *SubtitleService) searchProvider(ctx context.Context, provider SubtitleProvider, request *SubtitleSearchRequest) ([]SubtitleSearchResult, error) <span class="cov0" title="0">{
        switch provider </span>{
        case ProviderOpenSubtitles:<span class="cov0" title="0">
                return s.searchOpenSubtitles(ctx, request)</span>
        case ProviderSubDB:<span class="cov0" title="0">
                return s.searchSubDB(ctx, request)</span>
        case ProviderYifySubtitles:<span class="cov0" title="0">
                return s.searchYifySubtitles(ctx, request)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported provider: %s", provider)</span>
        }
}

func (s *SubtitleService) searchOpenSubtitles(ctx context.Context, request *SubtitleSearchRequest) ([]SubtitleSearchResult, error) <span class="cov0" title="0">{
        // Implementation for OpenSubtitles API
        // This is a simplified version - real implementation would use their API

        s.logger.Debug("Searching OpenSubtitles", zap.String("title", getStringValue(request.Title)))

        // Mock results for demonstration
        results := []SubtitleSearchResult{
                {
                        ID:           "os_1",
                        Provider:     ProviderOpenSubtitles,
                        Language:     "English",
                        LanguageCode: "en",
                        Title:        "Sample Movie (2024)",
                        DownloadURL:  "https://dl.opensubtitles.org/sample1.srt",
                        Format:       "srt",
                        Encoding:     "utf-8",
                        UploadDate:   time.Now().AddDate(0, 0, -7),
                        Downloads:    1500,
                        Rating:       4.2,
                        Comments:     23,
                        MatchScore:   0.95,
                },
        }

        return results, nil
}</span>

func (s *SubtitleService) searchSubDB(ctx context.Context, request *SubtitleSearchRequest) ([]SubtitleSearchResult, error) <span class="cov0" title="0">{
        // Implementation for SubDB
        s.logger.Debug("Searching SubDB")
        return []SubtitleSearchResult{}, nil
}</span>

func (s *SubtitleService) searchYifySubtitles(ctx context.Context, request *SubtitleSearchRequest) ([]SubtitleSearchResult, error) <span class="cov0" title="0">{
        // Implementation for YifySubtitles
        s.logger.Debug("Searching YifySubtitles")
        return []SubtitleSearchResult{}, nil
}</span>

// Helper functions
func (s *SubtitleService) downloadContent(ctx context.Context, url string) (string, string, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        content, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Detect encoding
        <span class="cov0" title="0">encoding := detectEncoding(content)

        return string(content), encoding, nil</span>
}

func (s *SubtitleService) parseSubtitle(content, format string) (interface{}, error) <span class="cov0" title="0">{
        switch strings.ToLower(format) </span>{
        case "srt":<span class="cov0" title="0">
                return s.parseSRT(content)</span>
        case "vtt":<span class="cov0" title="0">
                return s.parseVTT(content)</span>
        case "ass", "ssa":<span class="cov0" title="0">
                return s.parseASS(content)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported subtitle format: %s", format)</span>
        }
}

func (s *SubtitleService) parseSRT(content string) ([]SubtitleLine, error) <span class="cov0" title="0">{
        var lines []SubtitleLine

        // Simple SRT parser
        re := regexp.MustCompile(`(\d+)\s*\n(\d{2}:\d{2}:\d{2},\d{3}) --&gt; (\d{2}:\d{2}:\d{2},\d{3})\s*\n((?:[^\n]*\n?)+?)(?:\n|$)`)
        matches := re.FindAllStringSubmatch(content, -1)

        for i, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 5 </span><span class="cov0" title="0">{
                        text := strings.TrimSpace(match[4])

                        lines = append(lines, SubtitleLine{
                                Index:     i + 1,
                                StartTime: match[2],
                                EndTime:   match[3],
                                Text:      text,
                        })
                }</span>
        }

        <span class="cov0" title="0">return lines, nil</span>
}

func (s *SubtitleService) parseVTT(content string) (interface{}, error) <span class="cov0" title="0">{
        // WebVTT parser implementation
        return nil, fmt.Errorf("VTT parsing not implemented")
}</span>

func (s *SubtitleService) parseASS(content string) (interface{}, error) <span class="cov0" title="0">{
        // ASS/SSA parser implementation
        return nil, fmt.Errorf("ASS parsing not implemented")
}</span>

func parseTimestamp(timestamp string) (float64, error) <span class="cov0" title="0">{
        // Parse SRT timestamp format: 00:01:23,456
        re := regexp.MustCompile(`(\d{2}):(\d{2}):(\d{2}),(\d{3})`)
        matches := re.FindStringSubmatch(timestamp)

        if len(matches) != 5 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid timestamp format")
        }</span>

        <span class="cov0" title="0">hours, _ := strconv.Atoi(matches[1])
        minutes, _ := strconv.Atoi(matches[2])
        seconds, _ := strconv.Atoi(matches[3])
        milliseconds, _ := strconv.Atoi(matches[4])

        total := float64(hours*3600+minutes*60+seconds) + float64(milliseconds)/1000.0
        return total, nil</span>
}

func detectEncoding(data []byte) string <span class="cov0" title="0">{
        // Simple encoding detection - in practice you'd use a more sophisticated library
        if len(data) &gt; 3 &amp;&amp; data[0] == 0xEF &amp;&amp; data[1] == 0xBB &amp;&amp; data[2] == 0xBF </span><span class="cov0" title="0">{
                return "utf-8"
        }</span>
        <span class="cov0" title="0">return "utf-8"</span> // Default assumption
}

func generateSubtitleID() string <span class="cov0" title="0">{
        return fmt.Sprintf("sub_%d", time.Now().UnixNano())
}</span>

func getSubtitleStringValue(s *string) string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *s</span>
}

func (s *SubtitleService) sortSubtitleResults(results []SubtitleSearchResult) <span class="cov0" title="0">{
        // Sort by match score descending, then by rating
        for i := 0; i &lt; len(results)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(results); j++ </span><span class="cov0" title="0">{
                        if results[i].MatchScore &lt; results[j].MatchScore ||
                                (results[i].MatchScore == results[j].MatchScore &amp;&amp; results[i].Rating &lt; results[j].Rating) </span><span class="cov0" title="0">{
                                results[i], results[j] = results[j], results[i]
                        }</span>
                }
        }
}

// Additional helper methods

// getDownloadInfo retrieves download information for a subtitle result
func (s *SubtitleService) getDownloadInfo(ctx context.Context, resultID string) (*SubtitleSearchResult, error) <span class="cov0" title="0">{
        // Try to get from cache first
        cacheKey := fmt.Sprintf("subtitle_download_info:%s", resultID)

        var result SubtitleSearchResult
        found, err := s.cacheService.Get(ctx, cacheKey, &amp;result)
        if err == nil &amp;&amp; found </span><span class="cov0" title="0">{
                s.logger.Debug("Retrieved subtitle download info from cache",
                        zap.String("result_id", resultID))
                return &amp;result, nil
        }</span>

        // If not in cache, this is an error - download info should have been cached
        // during search
        <span class="cov0" title="0">s.logger.Warn("Subtitle download info not found in cache",
                zap.String("result_id", resultID))

        return nil, fmt.Errorf("subtitle download info not found for result ID: %s", resultID)</span>
}

// saveSubtitleTrack saves a subtitle track to the database
func (s *SubtitleService) saveSubtitleTrack(ctx context.Context, mediaItemID int64, track *SubtitleTrack) error <span class="cov0" title="0">{
        query := `
                INSERT INTO subtitle_tracks
                (id, media_item_id, language, language_code, source, format, content,
                 is_default, is_forced, encoding, sync_offset, verified_sync, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        _, err := s.db.ExecContext(ctx, query,
                track.ID, mediaItemID, track.Language, track.LanguageCode, track.Source,
                track.Format, track.Content, track.IsDefault, track.IsForced,
                track.Encoding, track.SyncOffset, track.VerifiedSync, track.CreatedAt)

        return err
}</span>

// autoTranslateSubtitle automatically translates a subtitle to multiple languages
func (s *SubtitleService) autoTranslateSubtitle(ctx context.Context, track *SubtitleTrack, targetLanguages []string) <span class="cov0" title="0">{
        for _, lang := range targetLanguages </span><span class="cov0" title="0">{
                request := &amp;SubtitleTranslationRequest{
                        SubtitleID:     track.ID,
                        SourceLanguage: track.LanguageCode,
                        TargetLanguage: lang,
                        UseCache:       true,
                }

                _, err := s.TranslateSubtitle(ctx, request)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Auto-translation failed",
                                zap.String("subtitle_id", track.ID),
                                zap.String("target_language", lang),
                                zap.Error(err))
                }</span>
        }
}

// getCachedTranslation retrieves a cached translation
func (s *SubtitleService) getCachedTranslation(ctx context.Context, subtitleID, targetLanguage string) *SubtitleTrack <span class="cov0" title="0">{
        // Create cache key
        cacheKey := fmt.Sprintf("subtitle_translation:%s:%s", subtitleID, targetLanguage)

        var track SubtitleTrack
        found, err := s.cacheService.Get(ctx, cacheKey, &amp;track)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Error retrieving cached translation",
                        zap.String("subtitle_id", subtitleID),
                        zap.String("target_language", targetLanguage),
                        zap.Error(err))
                return nil
        }</span>

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                s.logger.Debug("Cached translation not found",
                        zap.String("subtitle_id", subtitleID),
                        zap.String("target_language", targetLanguage))
                return nil
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Retrieved cached translation",
                zap.String("subtitle_id", subtitleID),
                zap.String("target_language", targetLanguage))

        return &amp;track</span>
}

// getSubtitleTrack retrieves a subtitle track by ID
func (s *SubtitleService) getSubtitleTrack(ctx context.Context, subtitleID string) (*SubtitleTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, language, language_code, source, format, path, content,
                       is_default, is_forced, encoding, sync_offset, created_at, verified_sync
                FROM subtitle_tracks WHERE id = ?`

        var track SubtitleTrack
        var content sql.NullString
        var path sql.NullString

        err := s.db.QueryRowContext(ctx, query, subtitleID).Scan(
                &amp;track.ID, &amp;track.Language, &amp;track.LanguageCode, &amp;track.Source,
                &amp;track.Format, &amp;path, &amp;content, &amp;track.IsDefault, &amp;track.IsForced,
                &amp;track.Encoding, &amp;track.SyncOffset, &amp;track.CreatedAt, &amp;track.VerifiedSync,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get subtitle track: %w", err)
        }</span>

        <span class="cov0" title="0">if path.Valid </span><span class="cov0" title="0">{
                track.Path = &amp;path.String
        }</span>
        <span class="cov0" title="0">if content.Valid </span><span class="cov0" title="0">{
                track.Content = &amp;content.String
        }</span>

        <span class="cov0" title="0">return &amp;track, nil</span>
}

// saveCachedTranslation saves a translation to cache
func (s *SubtitleService) saveCachedTranslation(ctx context.Context, subtitleID, targetLanguage string, track *SubtitleTrack) error <span class="cov0" title="0">{
        // Create cache key
        cacheKey := fmt.Sprintf("subtitle_translation:%s:%s", subtitleID, targetLanguage)

        // Cache for 30 days (translations are expensive to generate)
        ttl := 30 * 24 * time.Hour

        err := s.cacheService.Set(ctx, cacheKey, track, ttl)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to save cached translation",
                        zap.String("subtitle_id", subtitleID),
                        zap.String("target_language", targetLanguage),
                        zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Saved cached translation",
                zap.String("subtitle_id", subtitleID),
                zap.String("target_language", targetLanguage))

        return nil</span>
}

// parseSubtitleLines parses subtitle content into lines
func (s *SubtitleService) parseSubtitleLines(content string) ([]SubtitleLine, error) <span class="cov0" title="0">{
        // For now, assume SRT format
        return s.parseSRT(content)
}</span>

// translateLines translates subtitle lines using the translation service
func (s *SubtitleService) translateLines(ctx context.Context, lines []SubtitleLine, sourceLang, targetLang string) ([]SubtitleLine, error) <span class="cov0" title="0">{
        translatedLines := make([]SubtitleLine, len(lines))

        for i, line := range lines </span><span class="cov0" title="0">{
                request := TranslationRequest{
                        Text:           line.Text,
                        SourceLanguage: sourceLang,
                        TargetLanguage: targetLang,
                        Context:        "subtitle",
                }

                result, err := s.translationService.TranslateText(ctx, request)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to translate line %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">translatedLines[i] = SubtitleLine{
                        Index:     line.Index,
                        StartTime: line.StartTime,
                        EndTime:   line.EndTime,
                        Text:      result.TranslatedText,
                }</span>
        }

        <span class="cov0" title="0">return translatedLines, nil</span>
}

// reconstructSubtitle reconstructs subtitle content from lines
func (s *SubtitleService) reconstructSubtitle(format string, lines []SubtitleLine) (string, error) <span class="cov0" title="0">{
        switch strings.ToLower(format) </span>{
        case "srt":<span class="cov0" title="0">
                return s.reconstructSRT(lines), nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported format for reconstruction: %s", format)</span>
        }
}

// reconstructSRT reconstructs SRT format from subtitle lines
func (s *SubtitleService) reconstructSRT(lines []SubtitleLine) string <span class="cov0" title="0">{
        var builder strings.Builder

        for _, line := range lines </span><span class="cov0" title="0">{
                builder.WriteString(fmt.Sprintf("%d\n", line.Index))
                builder.WriteString(fmt.Sprintf("%s --&gt; %s\n", line.StartTime, line.EndTime))
                builder.WriteString(line.Text)
                builder.WriteString("\n\n")
        }</span>

        <span class="cov0" title="0">return builder.String()</span>
}

// VideoInfo represents video metadata for sync verification
type VideoInfo struct {
        Duration  float64 // Duration in seconds
        FrameRate float64
        Width     int
        Height    int
}

// getVideoInfo retrieves video metadata for sync verification
func (s *SubtitleService) getVideoInfo(ctx context.Context, mediaItemID int64) (*VideoInfo, error) <span class="cov0" title="0">{
        // Query video metadata from file_metadata table
        query := `
                SELECT key, value
                FROM file_metadata
                WHERE file_id = ? AND key IN ('duration', 'frame_rate', 'width', 'height', 'resolution')
        `

        rows, err := s.db.QueryContext(ctx, query, mediaItemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query video metadata: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        videoInfo := &amp;VideoInfo{
                Duration:  0,
                FrameRate: 24.0, // Default frame rate
                Width:     1920,  // Default resolution
                Height:    1080,
        }

        metadataMap := make(map[string]string)
        for rows.Next() </span><span class="cov0" title="0">{
                var key, value string
                if err := rows.Scan(&amp;key, &amp;value); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">metadataMap[key] = value</span>
        }

        // Parse duration
        <span class="cov0" title="0">if durationStr, ok := metadataMap["duration"]; ok </span><span class="cov0" title="0">{
                if duration, err := strconv.ParseFloat(durationStr, 64); err == nil </span><span class="cov0" title="0">{
                        videoInfo.Duration = duration
                }</span>
        }

        // Parse frame rate
        <span class="cov0" title="0">if frameRateStr, ok := metadataMap["frame_rate"]; ok </span><span class="cov0" title="0">{
                if frameRate, err := strconv.ParseFloat(frameRateStr, 64); err == nil </span><span class="cov0" title="0">{
                        videoInfo.FrameRate = frameRate
                }</span>
        }

        // Parse width
        <span class="cov0" title="0">if widthStr, ok := metadataMap["width"]; ok </span><span class="cov0" title="0">{
                if width, err := strconv.Atoi(widthStr); err == nil </span><span class="cov0" title="0">{
                        videoInfo.Width = width
                }</span>
        }

        // Parse height
        <span class="cov0" title="0">if heightStr, ok := metadataMap["height"]; ok </span><span class="cov0" title="0">{
                if height, err := strconv.Atoi(heightStr); err == nil </span><span class="cov0" title="0">{
                        videoInfo.Height = height
                }</span>
        }

        // Parse resolution string (e.g., "1920x1080")
        <span class="cov0" title="0">if resolutionStr, ok := metadataMap["resolution"]; ok </span><span class="cov0" title="0">{
                parts := regexp.MustCompile(`(\d+)x(\d+)`).FindStringSubmatch(resolutionStr)
                if len(parts) == 3 </span><span class="cov0" title="0">{
                        if width, err := strconv.Atoi(parts[1]); err == nil </span><span class="cov0" title="0">{
                                videoInfo.Width = width
                        }</span>
                        <span class="cov0" title="0">if height, err := strconv.Atoi(parts[2]); err == nil </span><span class="cov0" title="0">{
                                videoInfo.Height = height
                        }</span>
                }
        }

        <span class="cov0" title="0">s.logger.Debug("Retrieved video info",
                zap.Int64("media_item_id", mediaItemID),
                zap.Float64("duration", videoInfo.Duration),
                zap.Float64("frame_rate", videoInfo.FrameRate),
                zap.Int("width", videoInfo.Width),
                zap.Int("height", videoInfo.Height))

        return videoInfo, nil</span>
}

// extractSamplePoints extracts sample points for sync verification
func (s *SubtitleService) extractSamplePoints(lines []SubtitleLine, duration float64) []SyncPoint <span class="cov0" title="0">{
        var points []SyncPoint

        // Extract sample points at regular intervals
        sampleInterval := len(lines) / 10
        if sampleInterval == 0 </span><span class="cov0" title="0">{
                sampleInterval = 1
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; len(lines); i += sampleInterval </span><span class="cov0" title="0">{
                line := lines[i]
                // Parse timestamp
                time, _ := parseTimestamp(line.StartTime)

                points = append(points, SyncPoint{
                        SubtitleTime: time,
                        VideoTime:    time,
                        Text:         line.Text,
                        Confidence:   0.8,
                })
        }</span>

        <span class="cov0" title="0">return points</span>
}

// calculateSyncOffset calculates sync offset and confidence
func (s *SubtitleService) calculateSyncOffset(points []SyncPoint, videoInfo *VideoInfo) (float64, float64) <span class="cov0" title="0">{
        if len(points) == 0 </span><span class="cov0" title="0">{
                return 0, 0
        }</span>

        // Simple implementation - calculate average offset
        <span class="cov0" title="0">var totalOffset float64
        for _, point := range points </span><span class="cov0" title="0">{
                totalOffset += point.SubtitleTime - point.VideoTime
        }</span>

        <span class="cov0" title="0">avgOffset := totalOffset / float64(len(points))
        confidence := 0.8 // Default confidence

        return avgOffset * 1000, confidence</span> // Convert to milliseconds
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package services

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "time"

        "go.uber.org/zap"
)

// TranslationService handles AI-powered text translation
type TranslationService struct {
        logger     *zap.Logger
        httpClient *http.Client
        providers  map[string]TranslationProvider
        cache      map[string]*TranslationResult // Simple in-memory cache
}

// TranslationProvider represents a translation API provider
type TranslationProvider interface {
        Translate(ctx context.Context, request *TranslationRequest) (*TranslationResult, error)
        GetName() string
        GetSupportedLanguages() []string
        IsAvailable() bool
}

// TranslationRequest represents a translation request
type TranslationRequest struct {
        Text           string            `json:"text"`
        SourceLanguage string            `json:"source_language"`
        TargetLanguage string            `json:"target_language"`
        Context        string            `json:"context,omitempty"` // "lyrics", "subtitle", "general"
        Metadata       map[string]string `json:"metadata,omitempty"`
}

// TranslationResult represents a translation result
type TranslationResult struct {
        OriginalText     string    `json:"original_text"`
        TranslatedText   string    `json:"translated_text"`
        SourceLanguage   string    `json:"source_language"`
        TargetLanguage   string    `json:"target_language"`
        Provider         string    `json:"provider"`
        Confidence       float64   `json:"confidence"`
        DetectedLanguage *string   `json:"detected_language,omitempty"`
        Alternatives     []string  `json:"alternatives,omitempty"`
        ProcessingTime   float64   `json:"processing_time"` // Milliseconds
        CachedAt         time.Time `json:"cached_at"`
}

// BatchTranslationRequest represents a batch translation request
type BatchTranslationRequest struct {
        Texts          []string `json:"texts"`
        SourceLanguage string   `json:"source_language"`
        TargetLanguage string   `json:"target_language"`
        Context        string   `json:"context,omitempty"`
        PreserveFormat bool     `json:"preserve_format"`
}

// BatchTranslationResult represents a batch translation result
type BatchTranslationResult struct {
        Results      []TranslationResult `json:"results"`
        TotalTime    float64             `json:"total_time"`
        SuccessCount int                 `json:"success_count"`
        Provider     string              `json:"provider"`
}

// LanguageDetectionRequest represents a language detection request
type LanguageDetectionRequest struct {
        Text string `json:"text"`
}

// LanguageDetectionResult represents a language detection result
type LanguageDetectionResult struct {
        Language   string  `json:"language"`
        Code       string  `json:"code"`
        Confidence float64 `json:"confidence"`
        Provider   string  `json:"provider"`
}

// SupportedLanguage represents a supported language
type SupportedLanguage struct {
        Code       string `json:"code"`
        Name       string `json:"name"`
        NativeName string `json:"native_name"`
        Flag       string `json:"flag"`      // Unicode flag emoji
        Direction  string `json:"direction"` // "ltr" or "rtl"
        IsPopular  bool   `json:"is_popular"`
}

// NewTranslationService creates a new translation service
func NewTranslationService(logger *zap.Logger) *TranslationService <span class="cov0" title="0">{
        service := &amp;TranslationService{
                logger:     logger,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                providers:  make(map[string]TranslationProvider),
                cache:      make(map[string]*TranslationResult),
        }

        // Initialize providers
        service.initializeProviders()

        return service
}</span>

// TranslateText translates text using the best available provider
func (s *TranslationService) TranslateText(ctx context.Context, request TranslationRequest) (*TranslationResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Translating text",
                zap.String("source_lang", request.SourceLanguage),
                zap.String("target_lang", request.TargetLanguage),
                zap.String("context", request.Context))

        // Check cache first
        cacheKey := s.generateCacheKey(&amp;request)
        if cached, exists := s.cache[cacheKey]; exists </span><span class="cov0" title="0">{
                s.logger.Debug("Using cached translation")
                return cached, nil
        }</span>

        // Get available providers in priority order
        <span class="cov0" title="0">providers := s.getAvailableProviders()
        if len(providers) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no translation providers available")
        }</span>

        <span class="cov0" title="0">var lastError error
        startTime := time.Now()

        // Try providers in order until one succeeds
        for _, provider := range providers </span><span class="cov0" title="0">{
                result, err := provider.Translate(ctx, &amp;request)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Provider failed",
                                zap.String("provider", provider.GetName()),
                                zap.Error(err))
                        lastError = err
                        continue</span>
                }

                // Calculate processing time
                <span class="cov0" title="0">result.ProcessingTime = float64(time.Since(startTime).Nanoseconds()) / 1e6
                result.CachedAt = time.Now()

                // Cache the result
                s.cache[cacheKey] = result

                s.logger.Info("Translation completed",
                        zap.String("provider", result.Provider),
                        zap.Float64("confidence", result.Confidence),
                        zap.Float64("processing_time_ms", result.ProcessingTime))

                return result, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("all translation providers failed, last error: %w", lastError)</span>
}

// TranslateBatch translates multiple texts in a single request
func (s *TranslationService) TranslateBatch(ctx context.Context, request *BatchTranslationRequest) (*BatchTranslationResult, error) <span class="cov0" title="0">{
        s.logger.Info("Translating batch",
                zap.Int("text_count", len(request.Texts)),
                zap.String("source_lang", request.SourceLanguage),
                zap.String("target_lang", request.TargetLanguage))

        startTime := time.Now()
        var results []TranslationResult
        successCount := 0

        // Translate each text
        for _, text := range request.Texts </span><span class="cov0" title="0">{
                translationRequest := TranslationRequest{
                        Text:           text,
                        SourceLanguage: request.SourceLanguage,
                        TargetLanguage: request.TargetLanguage,
                        Context:        request.Context,
                }

                result, err := s.TranslateText(ctx, translationRequest)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to translate text in batch", zap.Error(err))
                        // Add empty result to maintain order
                        results = append(results, TranslationResult{
                                OriginalText:   text,
                                TranslatedText: text, // Fallback to original
                                SourceLanguage: request.SourceLanguage,
                                TargetLanguage: request.TargetLanguage,
                                Provider:       "fallback",
                                Confidence:     0.0,
                        })
                }</span> else<span class="cov0" title="0"> {
                        results = append(results, *result)
                        successCount++
                }</span>
        }

        <span class="cov0" title="0">totalTime := float64(time.Since(startTime).Nanoseconds()) / 1e6

        batchResult := &amp;BatchTranslationResult{
                Results:      results,
                TotalTime:    totalTime,
                SuccessCount: successCount,
                Provider:     "batch",
        }

        return batchResult, nil</span>
}

// DetectLanguage detects the language of the given text
func (s *TranslationService) DetectLanguage(ctx context.Context, request *LanguageDetectionRequest) (*LanguageDetectionResult, error) <span class="cov0" title="0">{
        s.logger.Debug("Detecting language", zap.String("text_preview", s.getTextPreview(request.Text)))

        // Get available providers
        providers := s.getAvailableProviders()
        if len(providers) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no language detection providers available")
        }</span>

        // Use first available provider for language detection
        // In practice, you might want to try multiple providers and compare results
        <span class="cov0" title="0">provider := providers[0]

        // For now, use a simple heuristic approach
        detectedLang := s.simpleLanguageDetection(request.Text)

        result := &amp;LanguageDetectionResult{
                Language:   getLanguageName(detectedLang),
                Code:       detectedLang,
                Confidence: 0.8, // Mock confidence
                Provider:   provider.GetName(),
        }

        return result, nil</span>
}

// GetSupportedLanguages returns all supported languages
func (s *TranslationService) GetSupportedLanguages() []SupportedLanguage <span class="cov0" title="0">{
        return []SupportedLanguage{
                {Code: "en", Name: "English", NativeName: "English", Flag: "", Direction: "ltr", IsPopular: true},
                {Code: "es", Name: "Spanish", NativeName: "Espaol", Flag: "", Direction: "ltr", IsPopular: true},
                {Code: "fr", Name: "French", NativeName: "Franais", Flag: "", Direction: "ltr", IsPopular: true},
                {Code: "de", Name: "German", NativeName: "Deutsch", Flag: "", Direction: "ltr", IsPopular: true},
                {Code: "it", Name: "Italian", NativeName: "Italiano", Flag: "", Direction: "ltr", IsPopular: true},
                {Code: "pt", Name: "Portuguese", NativeName: "Portugus", Flag: "", Direction: "ltr", IsPopular: true},
                {Code: "ru", Name: "Russian", NativeName: "", Flag: "", Direction: "ltr", IsPopular: true},
                {Code: "ja", Name: "Japanese", NativeName: "", Flag: "", Direction: "ltr", IsPopular: true},
                {Code: "ko", Name: "Korean", NativeName: "", Flag: "", Direction: "ltr", IsPopular: true},
                {Code: "zh", Name: "Chinese", NativeName: "", Flag: "", Direction: "ltr", IsPopular: true},
                {Code: "ar", Name: "Arabic", NativeName: "", Flag: "", Direction: "rtl", IsPopular: true},
                {Code: "hi", Name: "Hindi", NativeName: "", Flag: "", Direction: "ltr", IsPopular: true},
                {Code: "th", Name: "Thai", NativeName: "", Flag: "", Direction: "ltr", IsPopular: false},
                {Code: "vi", Name: "Vietnamese", NativeName: "Ting Vit", Flag: "", Direction: "ltr", IsPopular: false},
                {Code: "tr", Name: "Turkish", NativeName: "Trke", Flag: "", Direction: "ltr", IsPopular: false},
                {Code: "pl", Name: "Polish", NativeName: "Polski", Flag: "", Direction: "ltr", IsPopular: false},
                {Code: "nl", Name: "Dutch", NativeName: "Nederlands", Flag: "", Direction: "ltr", IsPopular: false},
                {Code: "sv", Name: "Swedish", NativeName: "Svenska", Flag: "", Direction: "ltr", IsPopular: false},
                {Code: "da", Name: "Danish", NativeName: "Dansk", Flag: "", Direction: "ltr", IsPopular: false},
                {Code: "no", Name: "Norwegian", NativeName: "Norsk", Flag: "", Direction: "ltr", IsPopular: false},
        }
}</span>

// Initialize providers
func (s *TranslationService) initializeProviders() <span class="cov0" title="0">{
        // Initialize free translation providers
        s.providers["google_translate_free"] = NewGoogleTranslateFreeProvider(s.httpClient, s.logger)
        s.providers["libre_translate"] = NewLibreTranslateProvider(s.httpClient, s.logger)
        s.providers["mymemory"] = NewMyMemoryProvider(s.httpClient, s.logger)

        // Note: In production, you would also initialize paid providers like:
        // s.providers["google_translate_api"] = NewGoogleTranslateAPIProvider(apiKey, s.httpClient, s.logger)
        // s.providers["azure_translator"] = NewAzureTranslatorProvider(apiKey, s.httpClient, s.logger)
        // s.providers["aws_translate"] = NewAWSTranslateProvider(credentials, s.httpClient, s.logger)
}</span>

// Get available providers in priority order
func (s *TranslationService) getAvailableProviders() []TranslationProvider <span class="cov0" title="0">{
        var available []TranslationProvider

        // Priority order: paid providers first, then free providers
        providerNames := []string{
                "google_translate_api",  // Paid (if configured)
                "azure_translator",      // Paid (if configured)
                "aws_translate",         // Paid (if configured)
                "google_translate_free", // Free
                "libre_translate",       // Free
                "mymemory",              // Free
        }

        for _, name := range providerNames </span><span class="cov0" title="0">{
                if provider, exists := s.providers[name]; exists &amp;&amp; provider.IsAvailable() </span><span class="cov0" title="0">{
                        available = append(available, provider)
                }</span>
        }

        <span class="cov0" title="0">return available</span>
}

// Generate cache key for translation request
func (s *TranslationService) generateCacheKey(request *TranslationRequest) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s_%s_%s_%s",
                request.SourceLanguage,
                request.TargetLanguage,
                request.Context,
                s.hashText(request.Text))
}</span>

// Simple text hashing for cache keys
func (s *TranslationService) hashText(text string) string <span class="cov0" title="0">{
        if len(text) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s...%s_%d", text[:20], text[len(text)-20:], len(text))
        }</span>
        <span class="cov0" title="0">return text</span>
}

// Simple language detection (in practice, use a proper language detection library)
func (s *TranslationService) simpleLanguageDetection(text string) string <span class="cov0" title="0">{
        text = strings.ToLower(text)

        // Simple keyword-based detection
        if strings.Contains(text, "the ") || strings.Contains(text, " and ") || strings.Contains(text, " is ") </span><span class="cov0" title="0">{
                return "en"
        }</span>
        <span class="cov0" title="0">if strings.Contains(text, " el ") || strings.Contains(text, " la ") || strings.Contains(text, " es ") </span><span class="cov0" title="0">{
                return "es"
        }</span>
        <span class="cov0" title="0">if strings.Contains(text, " le ") || strings.Contains(text, " la ") || strings.Contains(text, " est ") </span><span class="cov0" title="0">{
                return "fr"
        }</span>
        <span class="cov0" title="0">if strings.Contains(text, " der ") || strings.Contains(text, " die ") || strings.Contains(text, " ist ") </span><span class="cov0" title="0">{
                return "de"
        }</span>

        // Default to English
        <span class="cov0" title="0">return "en"</span>
}

// Get text preview for logging
func (s *TranslationService) getTextPreview(text string) string <span class="cov0" title="0">{
        if len(text) &gt; 100 </span><span class="cov0" title="0">{
                return text[:100] + "..."
        }</span>
        <span class="cov0" title="0">return text</span>
}

// Helper function to get language name from code
func getLanguageName(code string) string <span class="cov0" title="0">{
        languages := map[string]string{
                "en": "English",
                "es": "Spanish",
                "fr": "French",
                "de": "German",
                "it": "Italian",
                "pt": "Portuguese",
                "ru": "Russian",
                "ja": "Japanese",
                "ko": "Korean",
                "zh": "Chinese",
                "ar": "Arabic",
                "hi": "Hindi",
                "th": "Thai",
                "vi": "Vietnamese",
                "tr": "Turkish",
                "pl": "Polish",
                "nl": "Dutch",
                "sv": "Swedish",
                "da": "Danish",
                "no": "Norwegian",
        }

        if name, exists := languages[code]; exists </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov0" title="0">return code</span>
}

// Provider implementations would be in separate files
// Here are the interfaces they would implement:

// GoogleTranslateFreeProvider implements free Google Translate
type GoogleTranslateFreeProvider struct {
        httpClient *http.Client
        logger     *zap.Logger
        baseURL    string
}

func NewGoogleTranslateFreeProvider(httpClient *http.Client, logger *zap.Logger) *GoogleTranslateFreeProvider <span class="cov0" title="0">{
        return &amp;GoogleTranslateFreeProvider{
                httpClient: httpClient,
                logger:     logger,
                baseURL:    "https://translate.googleapis.com/translate_a/single",
        }
}</span>

func (p *GoogleTranslateFreeProvider) Translate(ctx context.Context, request *TranslationRequest) (*TranslationResult, error) <span class="cov0" title="0">{
        // Implementation would make HTTP request to Google Translate
        // This is a mock implementation
        return &amp;TranslationResult{
                OriginalText:   request.Text,
                TranslatedText: "[GT] " + request.Text, // Mock translation
                SourceLanguage: request.SourceLanguage,
                TargetLanguage: request.TargetLanguage,
                Provider:       "google_translate_free",
                Confidence:     0.9,
        }, nil
}</span>

func (p *GoogleTranslateFreeProvider) GetName() string <span class="cov0" title="0">{
        return "google_translate_free"
}</span>

func (p *GoogleTranslateFreeProvider) GetSupportedLanguages() []string <span class="cov0" title="0">{
        return []string{"en", "es", "fr", "de", "it", "pt", "ru", "ja", "ko", "zh", "ar", "hi"}
}</span>

func (p *GoogleTranslateFreeProvider) IsAvailable() bool <span class="cov0" title="0">{
        return true // Would check actual availability
}</span>

// LibreTranslateProvider implements LibreTranslate
type LibreTranslateProvider struct {
        httpClient *http.Client
        logger     *zap.Logger
        baseURL    string
}

func NewLibreTranslateProvider(httpClient *http.Client, logger *zap.Logger) *LibreTranslateProvider <span class="cov0" title="0">{
        return &amp;LibreTranslateProvider{
                httpClient: httpClient,
                logger:     logger,
                baseURL:    "https://libretranslate.de/translate",
        }
}</span>

func (p *LibreTranslateProvider) Translate(ctx context.Context, request *TranslationRequest) (*TranslationResult, error) <span class="cov0" title="0">{
        // Mock implementation
        return &amp;TranslationResult{
                OriginalText:   request.Text,
                TranslatedText: "[LT] " + request.Text, // Mock translation
                SourceLanguage: request.SourceLanguage,
                TargetLanguage: request.TargetLanguage,
                Provider:       "libre_translate",
                Confidence:     0.85,
        }, nil
}</span>

func (p *LibreTranslateProvider) GetName() string <span class="cov0" title="0">{
        return "libre_translate"
}</span>

func (p *LibreTranslateProvider) GetSupportedLanguages() []string <span class="cov0" title="0">{
        return []string{"en", "es", "fr", "de", "it", "pt", "ru", "ja", "zh", "ar"}
}</span>

func (p *LibreTranslateProvider) IsAvailable() bool <span class="cov0" title="0">{
        return true
}</span>

// MyMemoryProvider implements MyMemory translation
type MyMemoryProvider struct {
        httpClient *http.Client
        logger     *zap.Logger
        baseURL    string
}

func NewMyMemoryProvider(httpClient *http.Client, logger *zap.Logger) *MyMemoryProvider <span class="cov0" title="0">{
        return &amp;MyMemoryProvider{
                httpClient: httpClient,
                logger:     logger,
                baseURL:    "https://api.mymemory.translated.net/get",
        }
}</span>

func (p *MyMemoryProvider) Translate(ctx context.Context, request *TranslationRequest) (*TranslationResult, error) <span class="cov0" title="0">{
        // Mock implementation
        return &amp;TranslationResult{
                OriginalText:   request.Text,
                TranslatedText: "[MM] " + request.Text, // Mock translation
                SourceLanguage: request.SourceLanguage,
                TargetLanguage: request.TargetLanguage,
                Provider:       "mymemory",
                Confidence:     0.8,
        }, nil
}</span>

func (p *MyMemoryProvider) GetName() string <span class="cov0" title="0">{
        return "mymemory"
}</span>

func (p *MyMemoryProvider) GetSupportedLanguages() []string <span class="cov0" title="0">{
        return []string{"en", "es", "fr", "de", "it", "pt", "ru"}
}</span>

func (p *MyMemoryProvider) IsAvailable() bool <span class="cov0" title="0">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package services

import (
        "catalogizer/filesystem"
        "context"
        "database/sql"
        "fmt"
        "path/filepath"
        "sync"
        "time"

        "go.uber.org/zap"
)

// UniversalRenameTracker handles rename detection across all supported protocols
type UniversalRenameTracker struct {
        db               *sql.DB
        logger           *zap.Logger
        pendingMoves     map[string]*UniversalPendingMove // key: protocol:storageRoot:hash:size
        pendingMovesMu   sync.RWMutex
        cleanupInterval  time.Duration
        moveWindow       time.Duration
        stopCh           chan struct{}
        wg               sync.WaitGroup
        protocolHandlers map[string]ProtocolHandler
}

// UniversalPendingMove tracks a potential move operation across any protocol
type UniversalPendingMove struct {
        Path         string
        StorageRoot  string
        Protocol     string
        Size         int64
        FileHash     *string
        IsDirectory  bool
        DeletedAt    time.Time
        FileID       int64
        ProtocolData map[string]interface{} // Protocol-specific metadata
}

// ProtocolHandler defines protocol-specific operations for rename handling
type ProtocolHandler interface {
        // GetFileIdentifier creates a unique identifier for a file in this protocol
        GetFileIdentifier(ctx context.Context, path string, size int64, isDir bool) (string, error)

        // PerformMove executes the actual move operation for this protocol
        PerformMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string, isDir bool) error

        // ValidateMove checks if a move operation is valid for this protocol
        ValidateMove(ctx context.Context, client filesystem.FileSystemClient, oldPath, newPath string) error

        // GetMoveWindow returns the protocol-specific move detection window
        GetMoveWindow() time.Duration

        // SupportsRealTimeNotification indicates if the protocol supports real-time change notifications
        SupportsRealTimeNotification() bool
}

// NewUniversalRenameTracker creates a new universal rename tracker
func NewUniversalRenameTracker(db *sql.DB, logger *zap.Logger) *UniversalRenameTracker <span class="cov0" title="0">{
        tracker := &amp;UniversalRenameTracker{
                db:               db,
                logger:           logger,
                pendingMoves:     make(map[string]*UniversalPendingMove),
                cleanupInterval:  30 * time.Second,
                moveWindow:       10 * time.Second, // Default window, can be overridden per protocol
                stopCh:           make(chan struct{}),
                protocolHandlers: make(map[string]ProtocolHandler),
        }

        // Register default protocol handlers
        tracker.RegisterProtocolHandler("local", NewLocalProtocolHandler(logger))
        tracker.RegisterProtocolHandler("smb", NewSMBProtocolHandler(logger))
        tracker.RegisterProtocolHandler("ftp", NewFTPProtocolHandler(logger))
        tracker.RegisterProtocolHandler("nfs", NewNFSProtocolHandler(logger))
        tracker.RegisterProtocolHandler("webdav", NewWebDAVProtocolHandler(logger))

        return tracker
}</span>

// RegisterProtocolHandler registers a protocol-specific handler
func (rt *UniversalRenameTracker) RegisterProtocolHandler(protocol string, handler ProtocolHandler) <span class="cov0" title="0">{
        rt.protocolHandlers[protocol] = handler
}</span>

// Start begins the universal rename tracking service
func (rt *UniversalRenameTracker) Start() error <span class="cov0" title="0">{
        rt.logger.Info("Starting universal rename tracker service")

        // Start cleanup worker
        rt.wg.Add(1)
        go rt.cleanupWorker()

        // Create rename tracking tables if they don't exist
        if err := rt.InitializeTables(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize rename tracking tables: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the universal rename tracking service
func (rt *UniversalRenameTracker) Stop() <span class="cov0" title="0">{
        rt.logger.Info("Stopping universal rename tracker service")
        close(rt.stopCh)
        rt.wg.Wait()
        rt.logger.Info("Universal rename tracker service stopped")
}</span>

// TrackDelete tracks a file/directory deletion for potential move detection
func (rt *UniversalRenameTracker) TrackDelete(ctx context.Context, fileID int64, path, storageRoot, protocol string, size int64, fileHash *string, isDirectory bool, protocolData map[string]interface{}) <span class="cov0" title="0">{
        handler, exists := rt.protocolHandlers[protocol]
        if !exists </span><span class="cov0" title="0">{
                rt.logger.Warn("No handler for protocol", zap.String("protocol", protocol))
                return
        }</span>

        // Get protocol-specific file identifier
        <span class="cov0" title="0">identifier, err := handler.GetFileIdentifier(ctx, path, size, isDirectory)
        if err != nil </span><span class="cov0" title="0">{
                rt.logger.Error("Failed to get file identifier",
                        zap.String("protocol", protocol),
                        zap.String("path", path),
                        zap.Error(err))
                identifier = rt.createFallbackKey(protocol, storageRoot, fileHash, size, isDirectory)
        }</span>

        <span class="cov0" title="0">key := fmt.Sprintf("%s:%s:%s", protocol, storageRoot, identifier)

        rt.pendingMovesMu.Lock()
        rt.pendingMoves[key] = &amp;UniversalPendingMove{
                Path:         path,
                StorageRoot:  storageRoot,
                Protocol:     protocol,
                Size:         size,
                FileHash:     fileHash,
                IsDirectory:  isDirectory,
                DeletedAt:    time.Now(),
                FileID:       fileID,
                ProtocolData: protocolData,
        }
        rt.pendingMovesMu.Unlock()

        rt.logger.Debug("Tracking potential universal move deletion",
                zap.String("path", path),
                zap.String("storage_root", storageRoot),
                zap.String("protocol", protocol),
                zap.Int64("file_id", fileID))</span>
}

// DetectCreate checks if a file creation is actually a move from a deletion
func (rt *UniversalRenameTracker) DetectCreate(ctx context.Context, newPath, storageRoot, protocol string, size int64, fileHash *string, isDirectory bool, protocolData map[string]interface{}) (*UniversalPendingMove, bool) <span class="cov0" title="0">{
        handler, exists := rt.protocolHandlers[protocol]
        if !exists </span><span class="cov0" title="0">{
                rt.logger.Warn("No handler for protocol", zap.String("protocol", protocol))
                return nil, false
        }</span>

        // Get protocol-specific file identifier
        <span class="cov0" title="0">identifier, err := handler.GetFileIdentifier(ctx, newPath, size, isDirectory)
        if err != nil </span><span class="cov0" title="0">{
                rt.logger.Error("Failed to get file identifier for create detection",
                        zap.String("protocol", protocol),
                        zap.String("path", newPath),
                        zap.Error(err))
                identifier = rt.createFallbackKey(protocol, storageRoot, fileHash, size, isDirectory)
        }</span>

        <span class="cov0" title="0">key := fmt.Sprintf("%s:%s:%s", protocol, storageRoot, identifier)

        rt.pendingMovesMu.Lock()
        pendingMove, exists := rt.pendingMoves[key]
        if exists </span><span class="cov0" title="0">{
                delete(rt.pendingMoves, key)
        }</span>
        <span class="cov0" title="0">rt.pendingMovesMu.Unlock()

        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Check if the move happened within the protocol-specific time window
        <span class="cov0" title="0">moveWindow := handler.GetMoveWindow()
        if time.Since(pendingMove.DeletedAt) &gt; moveWindow </span><span class="cov0" title="0">{
                rt.logger.Debug("Move window expired",
                        zap.String("protocol", protocol),
                        zap.String("old_path", pendingMove.Path),
                        zap.String("new_path", newPath),
                        zap.Duration("elapsed", time.Since(pendingMove.DeletedAt)),
                        zap.Duration("window", moveWindow))
                return nil, false
        }</span>

        <span class="cov0" title="0">rt.logger.Info("Detected universal file/directory move",
                zap.String("old_path", pendingMove.Path),
                zap.String("new_path", newPath),
                zap.String("storage_root", storageRoot),
                zap.String("protocol", protocol),
                zap.Bool("is_directory", isDirectory))

        return pendingMove, true</span>
}

// ProcessMove handles a detected move operation efficiently across protocols
func (rt *UniversalRenameTracker) ProcessMove(ctx context.Context, client filesystem.FileSystemClient, oldMove *UniversalPendingMove, newPath string) error <span class="cov0" title="0">{
        handler, exists := rt.protocolHandlers[oldMove.Protocol]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no handler for protocol: %s", oldMove.Protocol)
        }</span>

        // Validate the move operation
        <span class="cov0" title="0">if err := handler.ValidateMove(ctx, client, oldMove.Path, newPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("move validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">tx, err := rt.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Record the rename event
        renameEventID, err := rt.recordUniversalRenameEvent(tx, oldMove, newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to record rename event: %w", err)
        }</span>

        // Perform protocol-specific move if needed
        <span class="cov0" title="0">if handler.SupportsRealTimeNotification() </span><span class="cov0" title="0">{
                // For protocols with real-time notifications, just update database
                if oldMove.IsDirectory </span><span class="cov0" title="0">{
                        err = rt.moveDirectory(tx, oldMove.Path, newPath, oldMove.StorageRoot)
                }</span> else<span class="cov0" title="0"> {
                        err = rt.moveFile(tx, oldMove.FileID, newPath)
                }</span>
        } else<span class="cov0" title="0"> {
                // For polling-based protocols, perform actual file system move
                if err = handler.PerformMove(ctx, client, oldMove.Path, newPath, oldMove.IsDirectory); err != nil </span><span class="cov0" title="0">{
                        rt.markRenameEventStatus(tx, renameEventID, "failed")
                        return fmt.Errorf("failed to perform protocol move: %w", err)
                }</span>

                <span class="cov0" title="0">if oldMove.IsDirectory </span><span class="cov0" title="0">{
                        err = rt.moveDirectory(tx, oldMove.Path, newPath, oldMove.StorageRoot)
                }</span> else<span class="cov0" title="0"> {
                        err = rt.moveFile(tx, oldMove.FileID, newPath)
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                rt.markRenameEventStatus(tx, renameEventID, "failed")
                return fmt.Errorf("failed to process move: %w", err)
        }</span>

        // Mark rename event as processed
        <span class="cov0" title="0">if err = rt.markRenameEventStatus(tx, renameEventID, "processed"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark rename event as processed: %w", err)
        }</span>

        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit move transaction: %w", err)
        }</span>

        <span class="cov0" title="0">rt.logger.Info("Successfully processed universal move operation",
                zap.String("old_path", oldMove.Path),
                zap.String("new_path", newPath),
                zap.String("protocol", oldMove.Protocol),
                zap.Bool("is_directory", oldMove.IsDirectory),
                zap.Int64("rename_event_id", renameEventID))

        return nil</span>
}

// createFallbackKey creates a fallback key when protocol-specific identification fails
func (rt *UniversalRenameTracker) createFallbackKey(protocol, storageRoot string, fileHash *string, size int64, isDirectory bool) string <span class="cov0" title="0">{
        hashStr := "nil"
        if fileHash != nil </span><span class="cov0" title="0">{
                hashStr = *fileHash
        }</span>

        <span class="cov0" title="0">dirStr := "false"
        if isDirectory </span><span class="cov0" title="0">{
                dirStr = "true"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("fallback:%s:%s:%d:%s", protocol, hashStr, size, dirStr)</span>
}

// moveFile updates a single file's path and metadata
func (rt *UniversalRenameTracker) moveFile(tx *sql.Tx, fileID int64, newPath string) error <span class="cov0" title="0">{
        newName := filepath.Base(newPath)
        newDir := filepath.Dir(newPath)

        var parentID *int64
        if newDir != "/" &amp;&amp; newDir != "." </span><span class="cov0" title="0">{
                parentQuery := `SELECT id FROM files WHERE path = ? AND is_directory = true LIMIT 1`
                err := tx.QueryRow(parentQuery, newDir).Scan(&amp;parentID)
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get parent directory: %w", err)
                }</span>
        }

        <span class="cov0" title="0">updateQuery := `
                UPDATE files
                SET path = ?, name = ?, parent_id = ?, modified_at = CURRENT_TIMESTAMP,
                    last_scan_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := tx.Exec(updateQuery, newPath, newName, parentID, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update file path: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// moveDirectory updates a directory and all its children
func (rt *UniversalRenameTracker) moveDirectory(tx *sql.Tx, oldPath, newPath, storageRootName string) error <span class="cov0" title="0">{
        query := `
                SELECT id, path, is_directory
                FROM files
                WHERE storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)
                  AND (path = ? OR path LIKE ?)
                ORDER BY LENGTH(path) ASC`

        oldPathPattern := oldPath + "/%"
        rows, err := tx.Query(query, storageRootName, oldPath, oldPathPattern)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query directory contents: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        type fileUpdate struct {
                ID          int64
                OldPath     string
                IsDirectory bool
        }

        var updates []fileUpdate
        for rows.Next() </span><span class="cov0" title="0">{
                var update fileUpdate
                if err := rows.Scan(&amp;update.ID, &amp;update.OldPath, &amp;update.IsDirectory); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan file for update: %w", err)
                }</span>
                <span class="cov0" title="0">updates = append(updates, update)</span>
        }

        <span class="cov0" title="0">for _, update := range updates </span><span class="cov0" title="0">{
                var updatedPath string
                if update.OldPath == oldPath </span><span class="cov0" title="0">{
                        updatedPath = newPath
                }</span> else<span class="cov0" title="0"> {
                        relativePath := update.OldPath[len(oldPath):]
                        updatedPath = newPath + relativePath
                }</span>

                <span class="cov0" title="0">if err := rt.moveFile(tx, update.ID, updatedPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update path for file ID %d: %w", update.ID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// recordUniversalRenameEvent creates a record of the rename operation
func (rt *UniversalRenameTracker) recordUniversalRenameEvent(tx *sql.Tx, oldMove *UniversalPendingMove, newPath string) (int64, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO universal_rename_events (storage_root_id, protocol, old_path, new_path, is_directory, size, file_hash, detected_at, status)
                VALUES ((SELECT id FROM storage_roots WHERE name = ?), ?, ?, ?, ?, ?, ?, ?, 'pending')`

        result, err := tx.Exec(query, oldMove.StorageRoot, oldMove.Protocol, oldMove.Path, newPath, oldMove.IsDirectory, oldMove.Size, oldMove.FileHash, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to insert universal rename event: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get rename event ID: %w", err)
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

// markRenameEventStatus updates the status of a rename event
func (rt *UniversalRenameTracker) markRenameEventStatus(tx *sql.Tx, eventID int64, status string) error <span class="cov0" title="0">{
        query := `UPDATE universal_rename_events SET status = ?, processed_at = CURRENT_TIMESTAMP WHERE id = ?`
        _, err := tx.Exec(query, status, eventID)
        return err
}</span>

// cleanupWorker periodically cleans up expired pending moves
func (rt *UniversalRenameTracker) cleanupWorker() <span class="cov0" title="0">{
        defer rt.wg.Done()

        ticker := time.NewTicker(rt.cleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-rt.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rt.cleanupExpiredMoves()</span>
                }
        }
}

// cleanupExpiredMoves removes pending moves that have exceeded their protocol-specific time windows
func (rt *UniversalRenameTracker) cleanupExpiredMoves() <span class="cov0" title="0">{
        rt.pendingMovesMu.Lock()
        defer rt.pendingMovesMu.Unlock()

        now := time.Now()
        expiredKeys := make([]string, 0)

        for key, move := range rt.pendingMoves </span><span class="cov0" title="0">{
                handler, exists := rt.protocolHandlers[move.Protocol]
                if !exists </span><span class="cov0" title="0">{
                        // Use default window if no handler
                        if now.Sub(move.DeletedAt) &gt; rt.moveWindow </span><span class="cov0" title="0">{
                                expiredKeys = append(expiredKeys, key)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">moveWindow := handler.GetMoveWindow()
                if now.Sub(move.DeletedAt) &gt; moveWindow </span><span class="cov0" title="0">{
                        expiredKeys = append(expiredKeys, key)
                }</span>
        }

        <span class="cov0" title="0">for _, key := range expiredKeys </span><span class="cov0" title="0">{
                move := rt.pendingMoves[key]
                delete(rt.pendingMoves, key)

                rt.logger.Debug("Cleaned up expired universal pending move",
                        zap.String("path", move.Path),
                        zap.String("storage_root", move.StorageRoot),
                        zap.String("protocol", move.Protocol),
                        zap.Duration("age", now.Sub(move.DeletedAt)))
        }</span>

        <span class="cov0" title="0">if len(expiredKeys) &gt; 0 </span><span class="cov0" title="0">{
                rt.logger.Debug("Cleaned up expired universal pending moves", zap.Int("count", len(expiredKeys)))
        }</span>
}

// GetStatistics returns statistics about universal rename detection
func (rt *UniversalRenameTracker) GetStatistics() map[string]interface{} <span class="cov0" title="0">{
        rt.pendingMovesMu.RLock()

        // Count pending moves by protocol
        pendingByProtocol := make(map[string]int)
        totalPending := 0

        for _, move := range rt.pendingMoves </span><span class="cov0" title="0">{
                pendingByProtocol[move.Protocol]++
                totalPending++
        }</span>

        <span class="cov0" title="0">rt.pendingMovesMu.RUnlock()

        stats := map[string]interface{}{
                "total_pending_moves": totalPending,
                "pending_by_protocol": pendingByProtocol,
                "supported_protocols": rt.getSupportedProtocols(),
        }

        // Get database statistics
        var totalRenames, successfulRenames int
        rt.db.QueryRow("SELECT COUNT(*) FROM universal_rename_events").Scan(&amp;totalRenames)
        rt.db.QueryRow("SELECT COUNT(*) FROM universal_rename_events WHERE status = 'processed'").Scan(&amp;successfulRenames)

        stats["total_renames"] = totalRenames
        stats["successful_renames"] = successfulRenames

        if totalRenames &gt; 0 </span><span class="cov0" title="0">{
                stats["success_rate"] = float64(successfulRenames) / float64(totalRenames) * 100
        }</span> else<span class="cov0" title="0"> {
                stats["success_rate"] = 0.0
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// getSupportedProtocols returns a list of supported protocols
func (rt *UniversalRenameTracker) getSupportedProtocols() []string <span class="cov0" title="0">{
        protocols := make([]string, 0, len(rt.protocolHandlers))
        for protocol := range rt.protocolHandlers </span><span class="cov0" title="0">{
                protocols = append(protocols, protocol)
        }</span>
        <span class="cov0" title="0">return protocols</span>
}

// InitializeTables creates the universal rename tracking tables
func (rt *UniversalRenameTracker) InitializeTables() error <span class="cov0" title="0">{
        query := `
                CREATE TABLE IF NOT EXISTS universal_rename_events (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        storage_root_id INTEGER NOT NULL,
                        protocol TEXT NOT NULL,
                        old_path TEXT NOT NULL,
                        new_path TEXT NOT NULL,
                        is_directory BOOLEAN NOT NULL,
                        size INTEGER NOT NULL,
                        file_hash TEXT,
                        detected_at TIMESTAMP NOT NULL,
                        processed_at TIMESTAMP,
                        status TEXT NOT NULL DEFAULT 'pending',
                        FOREIGN KEY (storage_root_id) REFERENCES storage_roots (id)
                );

                CREATE INDEX IF NOT EXISTS idx_universal_rename_events_storage_root ON universal_rename_events(storage_root_id);
                CREATE INDEX IF NOT EXISTS idx_universal_rename_events_protocol ON universal_rename_events(protocol);
                CREATE INDEX IF NOT EXISTS idx_universal_rename_events_detected_at ON universal_rename_events(detected_at);
                CREATE INDEX IF NOT EXISTS idx_universal_rename_events_status ON universal_rename_events(status);
        `

        _, err := rt.db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create universal rename tracking tables: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package services

import (
        "catalogizer/filesystem"
        "catalogizer/models"
        "context"
        "database/sql"
        "fmt"
        "path/filepath"
        "sync"
        "time"

        "go.uber.org/zap"
)

// UniversalScanner handles file system scanning across all supported protocols
type UniversalScanner struct {
        db               *sql.DB
        logger           *zap.Logger
        renameTracker    *UniversalRenameTracker
        clientFactory    filesystem.ClientFactory
        scanQueue        chan ScanJob
        workers          int
        stopCh           chan struct{}
        wg               sync.WaitGroup
        protocolScanners map[string]ProtocolScanner
        activeScansMu    sync.RWMutex
        activeScans      map[string]*ScanStatus
}

// ScanJob represents a scan operation for any protocol
type ScanJob struct {
        ID              string
        StorageRoot     *models.StorageRoot
        Path            string
        Priority        int
        ScanType        string // full, incremental, verify
        MaxDepth        int
        IncludePatterns []string
        ExcludePatterns []string
        Context         context.Context
}

// ScanStatus tracks the status of an active scan
type ScanStatus struct {
        JobID           string
        StorageRootName string
        Protocol        string
        StartTime       time.Time
        CurrentPath     string
        FilesProcessed  int64
        FilesFound      int64
        FilesUpdated    int64
        FilesDeleted    int64
        ErrorCount      int64
        Status          string // running, completed, failed, cancelled
        mu              sync.RWMutex
}

// ProtocolScanner defines protocol-specific scanning behavior
type ProtocolScanner interface {
        // ScanPath performs a scan of the specified path
        ScanPath(ctx context.Context, client filesystem.FileSystemClient, job ScanJob, status *ScanStatus) error

        // GetScanStrategy returns the optimal scanning strategy for this protocol
        GetScanStrategy() ScanStrategy

        // SupportsIncrementalScan indicates if the protocol supports incremental scanning
        SupportsIncrementalScan() bool

        // GetOptimalBatchSize returns the optimal batch size for database operations
        GetOptimalBatchSize() int
}

// ScanStrategy defines how scanning should be performed
type ScanStrategy struct {
        UseRecursiveListing     bool
        BatchSize               int
        ParallelDirectories     bool
        ChecksumCalculation     bool
        MetadataExtraction      bool
        RealTimeChangeDetection bool
}

// NewUniversalScanner creates a new universal file system scanner
func NewUniversalScanner(db *sql.DB, logger *zap.Logger, renameTracker *UniversalRenameTracker, clientFactory filesystem.ClientFactory) *UniversalScanner <span class="cov0" title="0">{
        scanner := &amp;UniversalScanner{
                db:               db,
                logger:           logger,
                renameTracker:    renameTracker,
                clientFactory:    clientFactory,
                scanQueue:        make(chan ScanJob, 1000),
                workers:          4,
                stopCh:           make(chan struct{}),
                protocolScanners: make(map[string]ProtocolScanner),
                activeScans:      make(map[string]*ScanStatus),
        }

        // Register protocol scanners
        scanner.RegisterProtocolScanner("local", NewLocalScanner(logger))
        scanner.RegisterProtocolScanner("smb", NewSMBScanner(logger))
        scanner.RegisterProtocolScanner("ftp", NewFTPScanner(logger))
        scanner.RegisterProtocolScanner("nfs", NewNFSScanner(logger))
        scanner.RegisterProtocolScanner("webdav", NewWebDAVScanner(logger))

        return scanner
}</span>

// RegisterProtocolScanner registers a protocol-specific scanner
func (s *UniversalScanner) RegisterProtocolScanner(protocol string, scanner ProtocolScanner) <span class="cov0" title="0">{
        s.protocolScanners[protocol] = scanner
}</span>

// Start begins the universal scanning service
func (s *UniversalScanner) Start() error <span class="cov0" title="0">{
        s.logger.Info("Starting universal scanner service", zap.Int("workers", s.workers))

        // Start worker goroutines
        for i := 0; i &lt; s.workers; i++ </span><span class="cov0" title="0">{
                s.wg.Add(1)
                go s.scanWorker(i)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the universal scanning service
func (s *UniversalScanner) Stop() <span class="cov0" title="0">{
        s.logger.Info("Stopping universal scanner service")
        close(s.stopCh)
        s.wg.Wait()
        s.logger.Info("Universal scanner service stopped")
}</span>

// QueueScan adds a scan job to the queue
func (s *UniversalScanner) QueueScan(job ScanJob) error <span class="cov0" title="0">{
        select </span>{
        case s.scanQueue &lt;- job:<span class="cov0" title="0">
                s.logger.Debug("Queued scan job",
                        zap.String("job_id", job.ID),
                        zap.String("storage_root", job.StorageRoot.Name),
                        zap.String("protocol", job.StorageRoot.Protocol),
                        zap.String("path", job.Path))
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("scan queue is full")</span>
        }
}

// scanWorker processes scan jobs
func (s *UniversalScanner) scanWorker(workerID int) <span class="cov0" title="0">{
        defer s.wg.Done()

        s.logger.Info("Universal scan worker started", zap.Int("worker_id", workerID))

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-s.stopCh:<span class="cov0" title="0">
                        return</span>
                case job := &lt;-s.scanQueue:<span class="cov0" title="0">
                        s.processScanJob(job, workerID)</span>
                }
        }
}

// processScanJob processes a single scan job
func (s *UniversalScanner) processScanJob(job ScanJob, workerID int) <span class="cov0" title="0">{
        s.logger.Debug("Processing scan job",
                zap.Int("worker_id", workerID),
                zap.String("job_id", job.ID),
                zap.String("storage_root", job.StorageRoot.Name),
                zap.String("protocol", job.StorageRoot.Protocol))

        // Create scan status
        status := &amp;ScanStatus{
                JobID:           job.ID,
                StorageRootName: job.StorageRoot.Name,
                Protocol:        job.StorageRoot.Protocol,
                StartTime:       time.Now(),
                Status:          "running",
        }

        // Track active scan
        s.activeScansMu.Lock()
        s.activeScans[job.ID] = status
        s.activeScansMu.Unlock()

        // Cleanup on completion
        defer func() </span><span class="cov0" title="0">{
                s.activeScansMu.Lock()
                delete(s.activeScans, job.ID)
                s.activeScansMu.Unlock()
        }</span>()

        // Get protocol scanner
        <span class="cov0" title="0">protocolScanner, exists := s.protocolScanners[job.StorageRoot.Protocol]
        if !exists </span><span class="cov0" title="0">{
                s.logger.Error("No scanner for protocol",
                        zap.String("protocol", job.StorageRoot.Protocol),
                        zap.String("job_id", job.ID))
                status.updateStatus("failed")
                return
        }</span>

        // Create filesystem client
        <span class="cov0" title="0">client, err := s.clientFactory.CreateClient(&amp;filesystem.StorageConfig{
                ID:       job.StorageRoot.Name,
                Name:     job.StorageRoot.Name,
                Protocol: job.StorageRoot.Protocol,
                Settings: s.storageRootToSettings(job.StorageRoot),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create filesystem client",
                        zap.String("protocol", job.StorageRoot.Protocol),
                        zap.String("job_id", job.ID),
                        zap.Error(err))
                status.updateStatus("failed")
                return
        }</span>

        // Connect to filesystem
        <span class="cov0" title="0">if err := client.Connect(job.Context); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to connect to filesystem",
                        zap.String("protocol", job.StorageRoot.Protocol),
                        zap.String("job_id", job.ID),
                        zap.Error(err))
                status.updateStatus("failed")
                return
        }</span>
        <span class="cov0" title="0">defer client.Disconnect(job.Context)

        // Perform the scan
        if err := protocolScanner.ScanPath(job.Context, client, job, status); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Scan failed",
                        zap.String("job_id", job.ID),
                        zap.Error(err))
                status.updateStatus("failed")
                return
        }</span>

        <span class="cov0" title="0">status.updateStatus("completed")
        s.logger.Info("Scan completed successfully",
                zap.String("job_id", job.ID),
                zap.String("storage_root", job.StorageRoot.Name),
                zap.Int64("files_processed", status.FilesProcessed),
                zap.Duration("duration", time.Since(status.StartTime)))</span>
}

// GetActiveScanStatus returns the status of an active scan
func (s *UniversalScanner) GetActiveScanStatus(jobID string) (*ScanStatus, bool) <span class="cov0" title="0">{
        s.activeScansMu.RLock()
        defer s.activeScansMu.RUnlock()
        status, exists := s.activeScans[jobID]
        return status, exists
}</span>

// GetAllActiveScanStatuses returns all active scan statuses
func (s *UniversalScanner) GetAllActiveScanStatuses() map[string]*ScanStatus <span class="cov0" title="0">{
        s.activeScansMu.RLock()
        defer s.activeScansMu.RUnlock()

        statuses := make(map[string]*ScanStatus)
        for id, status := range s.activeScans </span><span class="cov0" title="0">{
                // Create a copy to avoid race conditions
                statusCopy := &amp;ScanStatus{
                        JobID:           status.JobID,
                        StorageRootName: status.StorageRootName,
                        Protocol:        status.Protocol,
                        StartTime:       status.StartTime,
                        CurrentPath:     status.CurrentPath,
                        FilesProcessed:  status.FilesProcessed,
                        FilesFound:      status.FilesFound,
                        FilesUpdated:    status.FilesUpdated,
                        FilesDeleted:    status.FilesDeleted,
                        ErrorCount:      status.ErrorCount,
                        Status:          status.Status,
                }
                statuses[id] = statusCopy
        }</span>
        <span class="cov0" title="0">return statuses</span>
}

// storageRootToSettings converts StorageRoot to filesystem settings
func (s *UniversalScanner) storageRootToSettings(root *models.StorageRoot) map[string]interface{} <span class="cov0" title="0">{
        settings := make(map[string]interface{})

        switch root.Protocol </span>{
        case "local":<span class="cov0" title="0">
                if root.Path != nil </span><span class="cov0" title="0">{
                        settings["base_path"] = *root.Path
                }</span>

        case "smb":<span class="cov0" title="0">
                if root.Host != nil </span><span class="cov0" title="0">{
                        settings["host"] = *root.Host
                }</span>
                <span class="cov0" title="0">if root.Port != nil </span><span class="cov0" title="0">{
                        settings["port"] = *root.Port
                }</span>
                <span class="cov0" title="0">if root.Path != nil </span><span class="cov0" title="0">{
                        settings["share"] = *root.Path
                }</span>
                <span class="cov0" title="0">if root.Username != nil </span><span class="cov0" title="0">{
                        settings["username"] = *root.Username
                }</span>
                <span class="cov0" title="0">if root.Password != nil </span><span class="cov0" title="0">{
                        settings["password"] = *root.Password
                }</span>
                <span class="cov0" title="0">if root.Domain != nil </span><span class="cov0" title="0">{
                        settings["domain"] = *root.Domain
                }</span>

        case "ftp":<span class="cov0" title="0">
                if root.Host != nil </span><span class="cov0" title="0">{
                        settings["host"] = *root.Host
                }</span>
                <span class="cov0" title="0">if root.Port != nil </span><span class="cov0" title="0">{
                        settings["port"] = *root.Port
                }</span>
                <span class="cov0" title="0">if root.Username != nil </span><span class="cov0" title="0">{
                        settings["username"] = *root.Username
                }</span>
                <span class="cov0" title="0">if root.Password != nil </span><span class="cov0" title="0">{
                        settings["password"] = *root.Password
                }</span>

        case "nfs":<span class="cov0" title="0">
                if root.Host != nil </span><span class="cov0" title="0">{
                        settings["host"] = *root.Host
                }</span>
                <span class="cov0" title="0">if root.Path != nil </span><span class="cov0" title="0">{
                        settings["export_path"] = *root.Path
                }</span>
                <span class="cov0" title="0">if root.MountPoint != nil </span><span class="cov0" title="0">{
                        settings["mount_point"] = *root.MountPoint
                }</span>
                <span class="cov0" title="0">if root.Options != nil </span><span class="cov0" title="0">{
                        settings["options"] = *root.Options
                }</span>

        case "webdav":<span class="cov0" title="0">
                if root.URL != nil </span><span class="cov0" title="0">{
                        settings["url"] = *root.URL
                }</span>
                <span class="cov0" title="0">if root.Username != nil </span><span class="cov0" title="0">{
                        settings["username"] = *root.Username
                }</span>
                <span class="cov0" title="0">if root.Password != nil </span><span class="cov0" title="0">{
                        settings["password"] = *root.Password
                }</span>
        }

        <span class="cov0" title="0">return settings</span>
}

// updateStatus safely updates the scan status
func (s *ScanStatus) updateStatus(newStatus string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.Status = newStatus
}</span>

// updateCurrentPath safely updates the current path being scanned
func (s *ScanStatus) updateCurrentPath(path string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.CurrentPath = path
}</span>

// incrementCounters safely increments the various counters
func (s *ScanStatus) incrementCounters(processed, found, updated, deleted, errors int64) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.FilesProcessed += processed
        s.FilesFound += found
        s.FilesUpdated += updated
        s.FilesDeleted += deleted
        s.ErrorCount += errors
}</span>

// GetSnapshot returns a thread-safe snapshot of the scan status
func (s *ScanStatus) GetSnapshot() ScanStatus <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return ScanStatus{
                JobID:           s.JobID,
                StorageRootName: s.StorageRootName,
                Protocol:        s.Protocol,
                StartTime:       s.StartTime,
                CurrentPath:     s.CurrentPath,
                FilesProcessed:  s.FilesProcessed,
                FilesFound:      s.FilesFound,
                FilesUpdated:    s.FilesUpdated,
                FilesDeleted:    s.FilesDeleted,
                ErrorCount:      s.ErrorCount,
                Status:          s.Status,
        }
}</span>

// LocalScanner implements protocol-specific scanning for local filesystem
type LocalScanner struct {
        logger *zap.Logger
}

func NewLocalScanner(logger *zap.Logger) *LocalScanner <span class="cov0" title="0">{
        return &amp;LocalScanner{logger: logger}
}</span>

func (s *LocalScanner) ScanPath(ctx context.Context, client filesystem.FileSystemClient, job ScanJob, status *ScanStatus) error <span class="cov0" title="0">{
        return s.scanDirectory(ctx, client, job.Path, job, status, 0)
}</span>

func (s *LocalScanner) scanDirectory(ctx context.Context, client filesystem.FileSystemClient, path string, job ScanJob, status *ScanStatus, depth int) error <span class="cov0" title="0">{
        if depth &gt; job.MaxDepth </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">status.updateCurrentPath(path)

        files, err := client.ListDirectory(ctx, path)
        if err != nil </span><span class="cov0" title="0">{
                status.incrementCounters(0, 0, 0, 0, 1)
                return fmt.Errorf("failed to list directory %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">fullPath := filepath.Join(path, file.Name)

                // Process file/directory
                if err := s.processFileInfo(ctx, client, fullPath, file, job, status); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to process file",
                                zap.String("path", fullPath),
                                zap.Error(err))
                        status.incrementCounters(0, 0, 0, 0, 1)
                }</span>

                // Recurse into subdirectories
                <span class="cov0" title="0">if file.IsDir </span><span class="cov0" title="0">{
                        if err := s.scanDirectory(ctx, client, fullPath, job, status, depth+1); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to scan subdirectory",
                                        zap.String("path", fullPath),
                                        zap.Error(err))
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *LocalScanner) processFileInfo(ctx context.Context, client filesystem.FileSystemClient, path string, file *filesystem.FileInfo, job ScanJob, status *ScanStatus) error <span class="cov0" title="0">{
        // Implementation would update database with file information
        // For now, just increment counters
        status.incrementCounters(1, 1, 0, 0, 0)
        return nil
}</span>

func (s *LocalScanner) GetScanStrategy() ScanStrategy <span class="cov0" title="0">{
        return ScanStrategy{
                UseRecursiveListing:     true,
                BatchSize:               1000,
                ParallelDirectories:     true,
                ChecksumCalculation:     true,
                MetadataExtraction:      true,
                RealTimeChangeDetection: true,
        }
}</span>

func (s *LocalScanner) SupportsIncrementalScan() bool <span class="cov0" title="0">{
        return true
}</span>

func (s *LocalScanner) GetOptimalBatchSize() int <span class="cov0" title="0">{
        return 1000
}</span>

// SMBScanner implements protocol-specific scanning for SMB
type SMBScanner struct {
        logger *zap.Logger
}

func NewSMBScanner(logger *zap.Logger) *SMBScanner <span class="cov0" title="0">{
        return &amp;SMBScanner{logger: logger}
}</span>

func (s *SMBScanner) ScanPath(ctx context.Context, client filesystem.FileSystemClient, job ScanJob, status *ScanStatus) error <span class="cov0" title="0">{
        // SMB-specific scanning logic
        return s.scanDirectory(ctx, client, job.Path, job, status, 0)
}</span>

func (s *SMBScanner) scanDirectory(ctx context.Context, client filesystem.FileSystemClient, path string, job ScanJob, status *ScanStatus, depth int) error <span class="cov0" title="0">{
        // Similar to LocalScanner but with SMB-specific optimizations
        if depth &gt; job.MaxDepth </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">status.updateCurrentPath(path)

        files, err := client.ListDirectory(ctx, path)
        if err != nil </span><span class="cov0" title="0">{
                status.incrementCounters(0, 0, 0, 0, 1)
                return fmt.Errorf("failed to list SMB directory %s: %w", path, err)
        }</span>

        // Process files in batches for better SMB performance
        <span class="cov0" title="0">batchSize := s.GetOptimalBatchSize()
        for i := 0; i &lt; len(files); i += batchSize </span><span class="cov0" title="0">{
                end := i + batchSize
                if end &gt; len(files) </span><span class="cov0" title="0">{
                        end = len(files)
                }</span>

                <span class="cov0" title="0">batch := files[i:end]
                for _, file := range batch </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        default:<span class="cov0" title="0"></span>
                        }

                        <span class="cov0" title="0">fullPath := filepath.Join(path, file.Name)
                        status.incrementCounters(1, 1, 0, 0, 0)

                        if file.IsDir </span><span class="cov0" title="0">{
                                if err := s.scanDirectory(ctx, client, fullPath, job, status, depth+1); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("Failed to scan SMB subdirectory",
                                                zap.String("path", fullPath),
                                                zap.Error(err))
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SMBScanner) GetScanStrategy() ScanStrategy <span class="cov0" title="0">{
        return ScanStrategy{
                UseRecursiveListing:     false, // SMB benefits from controlled recursion
                BatchSize:               500,   // Smaller batches for network efficiency
                ParallelDirectories:     false, // Avoid overwhelming SMB server
                ChecksumCalculation:     false, // Expensive over network
                MetadataExtraction:      true,
                RealTimeChangeDetection: false,
        }
}</span>

func (s *SMBScanner) SupportsIncrementalScan() bool <span class="cov0" title="0">{
        return true
}</span>

func (s *SMBScanner) GetOptimalBatchSize() int <span class="cov0" title="0">{
        return 500
}</span>

// Similar implementations for FTP, NFS, and WebDAV scanners...

type FTPScanner struct {
        logger *zap.Logger
}

func NewFTPScanner(logger *zap.Logger) *FTPScanner <span class="cov0" title="0">{
        return &amp;FTPScanner{logger: logger}
}</span>

func (s *FTPScanner) ScanPath(ctx context.Context, client filesystem.FileSystemClient, job ScanJob, status *ScanStatus) error <span class="cov0" title="0">{
        // FTP-specific scanning logic
        return nil
}</span>

func (s *FTPScanner) GetScanStrategy() ScanStrategy <span class="cov0" title="0">{
        return ScanStrategy{
                UseRecursiveListing:     false,
                BatchSize:               100,
                ParallelDirectories:     false,
                ChecksumCalculation:     false,
                MetadataExtraction:      false,
                RealTimeChangeDetection: false,
        }
}</span>

func (s *FTPScanner) SupportsIncrementalScan() bool <span class="cov0" title="0">{
        return false
}</span>

func (s *FTPScanner) GetOptimalBatchSize() int <span class="cov0" title="0">{
        return 100
}</span>

type NFSScanner struct {
        logger *zap.Logger
}

func NewNFSScanner(logger *zap.Logger) *NFSScanner <span class="cov0" title="0">{
        return &amp;NFSScanner{logger: logger}
}</span>

func (s *NFSScanner) ScanPath(ctx context.Context, client filesystem.FileSystemClient, job ScanJob, status *ScanStatus) error <span class="cov0" title="0">{
        // NFS-specific scanning logic
        return nil
}</span>

func (s *NFSScanner) GetScanStrategy() ScanStrategy <span class="cov0" title="0">{
        return ScanStrategy{
                UseRecursiveListing:     true,
                BatchSize:               800,
                ParallelDirectories:     true,
                ChecksumCalculation:     true,
                MetadataExtraction:      true,
                RealTimeChangeDetection: false,
        }
}</span>

func (s *NFSScanner) SupportsIncrementalScan() bool <span class="cov0" title="0">{
        return true
}</span>

func (s *NFSScanner) GetOptimalBatchSize() int <span class="cov0" title="0">{
        return 800
}</span>

type WebDAVScanner struct {
        logger *zap.Logger
}

func NewWebDAVScanner(logger *zap.Logger) *WebDAVScanner <span class="cov0" title="0">{
        return &amp;WebDAVScanner{logger: logger}
}</span>

func (s *WebDAVScanner) ScanPath(ctx context.Context, client filesystem.FileSystemClient, job ScanJob, status *ScanStatus) error <span class="cov0" title="0">{
        // WebDAV-specific scanning logic
        return nil
}</span>

func (s *WebDAVScanner) GetScanStrategy() ScanStrategy <span class="cov0" title="0">{
        return ScanStrategy{
                UseRecursiveListing:     false,
                BatchSize:               200,
                ParallelDirectories:     false,
                ChecksumCalculation:     false,
                MetadataExtraction:      true,
                RealTimeChangeDetection: false,
        }
}</span>

func (s *WebDAVScanner) SupportsIncrementalScan() bool <span class="cov0" title="0">{
        return false
}</span>

func (s *WebDAVScanner) GetOptimalBatchSize() int <span class="cov0" title="0">{
        return 200
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "go.uber.org/zap"
)

type VideoPlayerService struct {
        db                 *sql.DB
        logger             *zap.Logger
        mediaPlayerService *MediaPlayerService
        positionService    *PlaybackPositionService
        subtitleService    *SubtitleService
        coverArtService    *CoverArtService
        translationService *TranslationService
}

type VideoPlaybackSession struct {
        ID               string          `json:"id"`
        UserID           int64           `json:"user_id"`
        CurrentVideo     *VideoContent   `json:"current_video"`
        Playlist         []VideoContent  `json:"playlist"`
        PlaylistIndex    int             `json:"playlist_index"`
        PlayMode         VideoPlayMode   `json:"play_mode"`
        AutoPlay         bool            `json:"auto_play"`
        AutoPlayNext     bool            `json:"auto_play_next"`
        Volume           float64         `json:"volume"`
        IsMuted          bool            `json:"is_muted"`
        PlaybackSpeed    float64         `json:"playback_speed"`
        PlaybackState    PlaybackState   `json:"playback_state"`
        Position         int64           `json:"position"`
        Duration         int64           `json:"duration"`
        BufferedRanges   []BufferedRange `json:"buffered_ranges"`
        SubtitleTracks   []SubtitleTrack `json:"subtitle_tracks"`
        ActiveSubtitle   *int64          `json:"active_subtitle"`
        AudioTracks      []AudioTrack    `json:"audio_tracks"`
        ActiveAudioTrack *int64          `json:"active_audio_track"`
        VideoQuality     VideoQuality    `json:"video_quality"`
        DeviceInfo       DeviceInfo      `json:"device_info"`
        ViewingProgress  ViewingProgress `json:"viewing_progress"`
        Chapters         []Chapter       `json:"chapters"`
        Bookmarks        []VideoBookmark `json:"bookmarks"`
        WatchParty       *WatchPartyInfo `json:"watch_party"`
        LastActivity     time.Time       `json:"last_activity"`
        CreatedAt        time.Time       `json:"created_at"`
        UpdatedAt        time.Time       `json:"updated_at"`
}

type VideoContent struct {
        ID                int64            `json:"id"`
        Title             string           `json:"title"`
        OriginalTitle     string           `json:"original_title"`
        Description       string           `json:"description"`
        Type              VideoType        `json:"type"`
        FilePath          string           `json:"file_path"`
        FileSize          int64            `json:"file_size"`
        Duration          int64            `json:"duration"`
        Resolution        string           `json:"resolution"`
        AspectRatio       string           `json:"aspect_ratio"`
        FrameRate         float64          `json:"frame_rate"`
        Bitrate           int64            `json:"bitrate"`
        Codec             string           `json:"codec"`
        HDR               bool             `json:"hdr"`
        DolbyVision       bool             `json:"dolby_vision"`
        DolbyAtmos        bool             `json:"dolby_atmos"`
        Year              int              `json:"year"`
        ReleaseDate       *time.Time       `json:"release_date"`
        Genres            []string         `json:"genres"`
        Directors         []string         `json:"directors"`
        Actors            []string         `json:"actors"`
        Writers           []string         `json:"writers"`
        Rating            *float64         `json:"rating"`
        IMDbID            string           `json:"imdb_id"`
        TMDbID            string           `json:"tmdb_id"`
        Language          string           `json:"language"`
        Country           string           `json:"country"`
        PlayCount         int64            `json:"play_count"`
        LastPlayed        *time.Time       `json:"last_played"`
        DateAdded         time.Time        `json:"date_added"`
        UserRating        *int             `json:"user_rating"`
        IsFavorite        bool             `json:"is_favorite"`
        WatchedPercentage float64          `json:"watched_percentage"`
        CoverArt          *CoverArt        `json:"cover_art"`
        Backdrop          *CoverArt        `json:"backdrop"`
        Trailer           *TrailerInfo     `json:"trailer"`
        SeriesInfo        *SeriesInfo      `json:"series_info"`
        EpisodeInfo       *EpisodeInfo     `json:"episode_info"`
        MovieInfo         *MovieInfo       `json:"movie_info"`
        Thumbnails        []VideoThumbnail `json:"thumbnails"`
        VideoStreams      []VideoStream    `json:"video_streams"`
        AudioStreams      []AudioStream    `json:"audio_streams"`
        SubtitleStreams   []SubtitleStream `json:"subtitle_streams"`
}

type VideoType string

const (
        VideoTypeMovie   VideoType = "movie"
        VideoTypeEpisode VideoType = "episode"
        VideoTypeClip    VideoType = "clip"
        VideoTypeTrailer VideoType = "trailer"
        VideoTypeOther   VideoType = "other"
)

type VideoPlayMode string

const (
        VideoPlayModeSingle   VideoPlayMode = "single"
        VideoPlayModeEpisode  VideoPlayMode = "episode"
        VideoPlayModeSeason   VideoPlayMode = "season"
        VideoPlayModeSeries   VideoPlayMode = "series"
        VideoPlayModePlaylist VideoPlayMode = "playlist"
)

type VideoQuality string

const (
        Quality480p  VideoQuality = "480p"
        Quality720p  VideoQuality = "720p"
        Quality1080p VideoQuality = "1080p"
        Quality1440p VideoQuality = "1440p"
        Quality2160p VideoQuality = "2160p" // 4K
        Quality4320p VideoQuality = "4320p" // 8K
        QualityAuto  VideoQuality = "auto"
)

type ViewingProgress struct {
        StartedAt        time.Time `json:"started_at"`
        TotalWatchTime   int64     `json:"total_watch_time"`
        SessionWatchTime int64     `json:"session_watch_time"`
        PauseCount       int       `json:"pause_count"`
        SeekCount        int       `json:"seek_count"`
        RewindCount      int       `json:"rewind_count"`
        FastForwardCount int       `json:"fast_forward_count"`
        QualityChanges   int       `json:"quality_changes"`
        BufferingEvents  int       `json:"buffering_events"`
        TotalBufferTime  int64     `json:"total_buffer_time"`
}

type VideoChapter struct {
        ID        int64     `json:"id"`
        Title     string    `json:"title"`
        StartTime int64     `json:"start_time"`
        EndTime   int64     `json:"end_time"`
        Thumbnail *CoverArt `json:"thumbnail"`
}

type VideoBookmark struct {
        ID          int64     `json:"id"`
        UserID      int64     `json:"user_id"`
        VideoID     int64     `json:"video_id"`
        Position    int64     `json:"position"`
        Title       string    `json:"title"`
        Description string    `json:"description"`
        Thumbnail   *CoverArt `json:"thumbnail"`
        CreatedAt   time.Time `json:"created_at"`
}

type WatchPartyInfo struct {
        ID           string    `json:"id"`
        HostUserID   int64     `json:"host_user_id"`
        Participants []int64   `json:"participants"`
        SyncEnabled  bool      `json:"sync_enabled"`
        ChatEnabled  bool      `json:"chat_enabled"`
        CreatedAt    time.Time `json:"created_at"`
}

type TrailerInfo struct {
        URL      string `json:"url"`
        Provider string `json:"provider"`
        Quality  string `json:"quality"`
        Duration int64  `json:"duration"`
}

type SeriesInfo struct {
        ID            int64      `json:"id"`
        Title         string     `json:"title"`
        Description   string     `json:"description"`
        TotalSeasons  int        `json:"total_seasons"`
        TotalEpisodes int        `json:"total_episodes"`
        Status        string     `json:"status"`
        FirstAired    *time.Time `json:"first_aired"`
        LastAired     *time.Time `json:"last_aired"`
        Network       string     `json:"network"`
        Creator       []string   `json:"creator"`
}

type EpisodeInfo struct {
        SeriesID      int64      `json:"series_id"`
        SeasonNumber  int        `json:"season_number"`
        EpisodeNumber int        `json:"episode_number"`
        AirDate       *time.Time `json:"air_date"`
        Runtime       int        `json:"runtime"`
        GuestStars    []string   `json:"guest_stars"`
        NextEpisodeID *int64     `json:"next_episode_id"`
        PrevEpisodeID *int64     `json:"prev_episode_id"`
}

type MovieInfo struct {
        Budget              int64    `json:"budget"`
        Revenue             int64    `json:"revenue"`
        Runtime             int      `json:"runtime"`
        Collection          string   `json:"collection"`
        Studio              []string `json:"studio"`
        ProductionCompanies []string `json:"production_companies"`
}

type VideoThumbnail struct {
        ID        int64     `json:"id"`
        VideoID   int64     `json:"video_id"`
        Position  int64     `json:"position"`
        URL       string    `json:"url"`
        Width     int       `json:"width"`
        Height    int       `json:"height"`
        CreatedAt time.Time `json:"created_at"`
}

type VideoStream struct {
        ID       int64   `json:"id"`
        Index    int     `json:"index"`
        Codec    string  `json:"codec"`
        Width    int     `json:"width"`
        Height   int     `json:"height"`
        Bitrate  int64   `json:"bitrate"`
        FPS      float64 `json:"fps"`
        Language string  `json:"language"`
        Title    string  `json:"title"`
        Default  bool    `json:"default"`
}

type AudioStream struct {
        ID       int64  `json:"id"`
        Index    int    `json:"index"`
        Codec    string `json:"codec"`
        Channels int    `json:"channels"`
        Bitrate  int64  `json:"bitrate"`
        Language string `json:"language"`
        Title    string `json:"title"`
        Default  bool   `json:"default"`
}

type SubtitleStream struct {
        ID       int64  `json:"id"`
        Index    int    `json:"index"`
        Codec    string `json:"codec"`
        Language string `json:"language"`
        Title    string `json:"title"`
        Default  bool   `json:"default"`
        Forced   bool   `json:"forced"`
        External bool   `json:"external"`
        FilePath string `json:"file_path"`
}

type PlayVideoRequest struct {
        UserID       int64         `json:"user_id"`
        VideoID      int64         `json:"video_id"`
        PlayMode     VideoPlayMode `json:"play_mode"`
        StartTime    *int64        `json:"start_time"`
        Quality      VideoQuality  `json:"quality"`
        DeviceInfo   DeviceInfo    `json:"device_info"`
        AutoPlay     bool          `json:"auto_play"`
        SeriesID     *int64        `json:"series_id"`
        SeasonNumber *int          `json:"season_number"`
        PlaylistID   *int64        `json:"playlist_id"`
}

type PlaySeriesRequest struct {
        UserID       int64        `json:"user_id"`
        SeriesID     int64        `json:"series_id"`
        SeasonNumber *int         `json:"season_number"`
        StartEpisode *int         `json:"start_episode"`
        Quality      VideoQuality `json:"quality"`
        DeviceInfo   DeviceInfo   `json:"device_info"`
        AutoPlay     bool         `json:"auto_play"`
}

type UpdateVideoPlaybackRequest struct {
        SessionID      string         `json:"session_id"`
        Position       *int64         `json:"position"`
        State          *PlaybackState `json:"state"`
        Volume         *float64       `json:"volume"`
        IsMuted        *bool          `json:"is_muted"`
        PlaybackSpeed  *float64       `json:"playback_speed"`
        Quality        *VideoQuality  `json:"quality"`
        ActiveSubtitle *int64         `json:"active_subtitle"`
        ActiveAudio    *int64         `json:"active_audio"`
}

type VideoSeekRequest struct {
        SessionID string `json:"session_id"`
        Position  int64  `json:"position"`
}

type CreateVideoBookmarkRequest struct {
        SessionID   string `json:"session_id"`
        Title       string `json:"title"`
        Description string `json:"description"`
}

type WatchHistoryRequest struct {
        UserID    int64      `json:"user_id"`
        StartDate *time.Time `json:"start_date"`
        EndDate   *time.Time `json:"end_date"`
        VideoType *VideoType `json:"video_type"`
        Limit     int        `json:"limit"`
        Offset    int        `json:"offset"`
}

type WatchHistory struct {
        ID             int64        `json:"id"`
        UserID         int64        `json:"user_id"`
        VideoID        int64        `json:"video_id"`
        VideoContent   VideoContent `json:"video_content"`
        WatchedAt      time.Time    `json:"watched_at"`
        WatchDuration  int64        `json:"watch_duration"`
        CompletionRate float64      `json:"completion_rate"`
        StoppedAt      int64        `json:"stopped_at"`
        DeviceInfo     string       `json:"device_info"`
        Quality        string       `json:"quality"`
}

func NewVideoPlayerService(
        db *sql.DB,
        logger *zap.Logger,
        mediaPlayerService *MediaPlayerService,
        positionService *PlaybackPositionService,
        subtitleService *SubtitleService,
        coverArtService *CoverArtService,
        translationService *TranslationService,
) *VideoPlayerService <span class="cov0" title="0">{
        return &amp;VideoPlayerService{
                db:                 db,
                logger:             logger,
                mediaPlayerService: mediaPlayerService,
                positionService:    positionService,
                subtitleService:    subtitleService,
                coverArtService:    coverArtService,
                translationService: translationService,
        }
}</span>

func (s *VideoPlayerService) PlayVideo(ctx context.Context, req *PlayVideoRequest) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting video playback",
                zap.Int64("user_id", req.UserID),
                zap.Int64("video_id", req.VideoID),
                zap.String("play_mode", string(req.PlayMode)))

        video, err := s.getVideoContent(ctx, req.VideoID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get video content: %w", err)
        }</span>

        <span class="cov0" title="0">session := &amp;VideoPlaybackSession{
                ID:            generateSessionID(),
                UserID:        req.UserID,
                CurrentVideo:  video,
                Playlist:      []VideoContent{*video},
                PlaylistIndex: 0,
                PlayMode:      req.PlayMode,
                AutoPlay:      req.AutoPlay,
                AutoPlayNext:  true,
                Volume:        1.0,
                IsMuted:       false,
                PlaybackSpeed: 1.0,
                PlaybackState: PlaybackStatePlaying,
                Position:      0,
                Duration:      video.Duration,
                VideoQuality:  req.Quality,
                DeviceInfo:    req.DeviceInfo,
                ViewingProgress: ViewingProgress{
                        StartedAt: time.Now(),
                },
                LastActivity: time.Now(),
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        if req.StartTime != nil </span><span class="cov0" title="0">{
                session.Position = *req.StartTime
        }</span> else<span class="cov0" title="0"> {
                position, err := s.positionService.GetPosition(ctx, req.UserID, req.VideoID)
                if err == nil &amp;&amp; position != nil &amp;&amp; position.PercentComplete &lt; 90 </span><span class="cov0" title="0">{
                        session.Position = position.Position
                }</span>
        }

        <span class="cov0" title="0">if err := s.loadVideoStreams(ctx, session, video.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load video streams", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.loadSubtitles(ctx, session, video.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load subtitles", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.loadChapters(ctx, session, video.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load chapters", zap.Error(err))
        }</span>

        <span class="cov0" title="0">switch req.PlayMode </span>{
        case VideoPlayModeEpisode:<span class="cov0" title="0">
                if video.EpisodeInfo != nil </span><span class="cov0" title="0">{
                        if err := s.loadEpisodePlaylist(ctx, session, video.EpisodeInfo.SeriesID, video.EpisodeInfo.SeasonNumber); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load episode playlist", zap.Error(err))
                        }</span>
                }
        case VideoPlayModeSeason:<span class="cov0" title="0">
                if req.SeasonNumber != nil &amp;&amp; video.SeriesInfo != nil </span><span class="cov0" title="0">{
                        if err := s.loadSeasonPlaylist(ctx, session, video.SeriesInfo.ID, *req.SeasonNumber); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load season playlist", zap.Error(err))
                        }</span>
                }
        case VideoPlayModeSeries:<span class="cov0" title="0">
                if req.SeriesID != nil </span><span class="cov0" title="0">{
                        if err := s.loadSeriesPlaylist(ctx, session, *req.SeriesID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load series playlist", zap.Error(err))
                        }</span>
                }
        case VideoPlayModePlaylist:<span class="cov0" title="0">
                if req.PlaylistID != nil </span><span class="cov0" title="0">{
                        if err := s.loadVideoPlaylist(ctx, session, *req.PlaylistID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to load video playlist", zap.Error(err))
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := s.saveVideoSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.recordVideoPlayback(ctx, req.UserID, video.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to record playback", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *VideoPlayerService) PlaySeries(ctx context.Context, req *PlaySeriesRequest) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Info("Starting series playback",
                zap.Int64("user_id", req.UserID),
                zap.Int64("series_id", req.SeriesID))

        _, err := s.getSeriesInfo(ctx, req.SeriesID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get series info: %w", err)
        }</span>

        <span class="cov0" title="0">seasonNumber := 1
        if req.SeasonNumber != nil </span><span class="cov0" title="0">{
                seasonNumber = *req.SeasonNumber
        }</span>

        <span class="cov0" title="0">episodes, err := s.getSeasonEpisodes(ctx, req.SeriesID, seasonNumber)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get season episodes: %w", err)
        }</span>

        <span class="cov0" title="0">if len(episodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no episodes found for season %d", seasonNumber)
        }</span>

        <span class="cov0" title="0">startIndex := 0
        if req.StartEpisode != nil &amp;&amp; *req.StartEpisode &lt; len(episodes) </span><span class="cov0" title="0">{
                startIndex = *req.StartEpisode
        }</span>

        <span class="cov0" title="0">session := &amp;VideoPlaybackSession{
                ID:            generateSessionID(),
                UserID:        req.UserID,
                CurrentVideo:  &amp;episodes[startIndex],
                Playlist:      episodes,
                PlaylistIndex: startIndex,
                PlayMode:      VideoPlayModeSeries,
                AutoPlay:      req.AutoPlay,
                AutoPlayNext:  true,
                Volume:        1.0,
                IsMuted:       false,
                PlaybackSpeed: 1.0,
                PlaybackState: PlaybackStatePlaying,
                Position:      0,
                Duration:      episodes[startIndex].Duration,
                VideoQuality:  req.Quality,
                DeviceInfo:    req.DeviceInfo,
                ViewingProgress: ViewingProgress{
                        StartedAt: time.Now(),
                },
                LastActivity: time.Now(),
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        position, err := s.positionService.GetPosition(ctx, req.UserID, episodes[startIndex].ID)
        if err == nil &amp;&amp; position != nil &amp;&amp; position.PercentComplete &lt; 90 </span><span class="cov0" title="0">{
                session.Position = position.Position
        }</span>

        <span class="cov0" title="0">if err := s.loadVideoStreams(ctx, session, episodes[startIndex].ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load video streams", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.loadSubtitles(ctx, session, episodes[startIndex].ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load subtitles", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.saveVideoSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *VideoPlayerService) GetVideoSession(ctx context.Context, sessionID string) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting video session", zap.String("session_id", sessionID))

        query := `
                SELECT session_data, updated_at
                FROM video_playback_sessions
                WHERE id = $1 AND expires_at &gt; NOW()
        `

        var sessionData string
        var updatedAt time.Time
        err := s.db.QueryRowContext(ctx, query, sessionID).Scan(&amp;sessionData, &amp;updatedAt)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session not found or expired")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get session: %w", err)
        }</span>

        <span class="cov0" title="0">var session VideoPlaybackSession
        if err := json.Unmarshal([]byte(sessionData), &amp;session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal session: %w", err)
        }</span>

        <span class="cov0" title="0">session.UpdatedAt = updatedAt
        return &amp;session, nil</span>
}

func (s *VideoPlayerService) UpdateVideoPlayback(ctx context.Context, req *UpdateVideoPlaybackRequest) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Updating video playback", zap.String("session_id", req.SessionID))

        session, err := s.GetVideoSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Position != nil </span><span class="cov0" title="0">{
                oldPosition := session.Position
                session.Position = *req.Position
                session.ViewingProgress.SessionWatchTime += *req.Position - oldPosition

                if err := s.positionService.UpdatePosition(ctx, &amp;UpdatePositionRequest{
                        UserID:          session.UserID,
                        MediaItemID:     session.CurrentVideo.ID,
                        Position:        *req.Position,
                        Duration:        session.Duration,
                        DeviceInfo:      session.DeviceInfo.DeviceName,
                        PlaybackQuality: string(session.VideoQuality),
                }); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to update position", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">if req.State != nil </span><span class="cov0" title="0">{
                session.PlaybackState = *req.State
                if *req.State == PlaybackStatePaused </span><span class="cov0" title="0">{
                        session.ViewingProgress.PauseCount++
                }</span>
        }

        <span class="cov0" title="0">if req.Volume != nil </span><span class="cov0" title="0">{
                session.Volume = *req.Volume
        }</span>

        <span class="cov0" title="0">if req.IsMuted != nil </span><span class="cov0" title="0">{
                session.IsMuted = *req.IsMuted
        }</span>

        <span class="cov0" title="0">if req.PlaybackSpeed != nil </span><span class="cov0" title="0">{
                session.PlaybackSpeed = *req.PlaybackSpeed
        }</span>

        <span class="cov0" title="0">if req.Quality != nil </span><span class="cov0" title="0">{
                if session.VideoQuality != *req.Quality </span><span class="cov0" title="0">{
                        session.ViewingProgress.QualityChanges++
                }</span>
                <span class="cov0" title="0">session.VideoQuality = *req.Quality</span>
        }

        <span class="cov0" title="0">if req.ActiveSubtitle != nil </span><span class="cov0" title="0">{
                session.ActiveSubtitle = req.ActiveSubtitle
        }</span>

        <span class="cov0" title="0">if req.ActiveAudio != nil </span><span class="cov0" title="0">{
                session.ActiveAudioTrack = req.ActiveAudio
        }</span>

        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveVideoSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *VideoPlayerService) NextVideo(ctx context.Context, sessionID string) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Skipping to next video", zap.String("session_id", sessionID))

        session, err := s.GetVideoSession(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if session.PlaylistIndex &gt;= len(session.Playlist)-1 </span><span class="cov0" title="0">{
                session.PlaybackState = PlaybackStateStopped
                return session, nil
        }</span>

        <span class="cov0" title="0">session.PlaylistIndex++
        session.CurrentVideo = &amp;session.Playlist[session.PlaylistIndex]
        session.Position = 0
        session.Duration = session.CurrentVideo.Duration

        position, err := s.positionService.GetPosition(ctx, session.UserID, session.CurrentVideo.ID)
        if err == nil &amp;&amp; position != nil &amp;&amp; position.PercentComplete &lt; 90 </span><span class="cov0" title="0">{
                session.Position = position.Position
        }</span>

        <span class="cov0" title="0">if err := s.loadVideoStreams(ctx, session, session.CurrentVideo.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load video streams", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.loadSubtitles(ctx, session, session.CurrentVideo.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load subtitles", zap.Error(err))
        }</span>

        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveVideoSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.recordVideoPlayback(ctx, session.UserID, session.CurrentVideo.ID); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to record playback", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *VideoPlayerService) PreviousVideo(ctx context.Context, sessionID string) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Skipping to previous video", zap.String("session_id", sessionID))

        session, err := s.GetVideoSession(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if session.Position &gt; 10000 </span><span class="cov0" title="0">{
                session.Position = 0
        }</span> else<span class="cov0" title="0"> if session.PlaylistIndex &gt; 0 </span><span class="cov0" title="0">{
                session.PlaylistIndex--
                session.CurrentVideo = &amp;session.Playlist[session.PlaylistIndex]
                session.Duration = session.CurrentVideo.Duration

                position, err := s.positionService.GetPosition(ctx, session.UserID, session.CurrentVideo.ID)
                if err == nil &amp;&amp; position != nil &amp;&amp; position.PercentComplete &lt; 90 </span><span class="cov0" title="0">{
                        session.Position = position.Position
                }</span> else<span class="cov0" title="0"> {
                        session.Position = 0
                }</span>

                <span class="cov0" title="0">if err := s.loadVideoStreams(ctx, session, session.CurrentVideo.ID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to load video streams", zap.Error(err))
                }</span>

                <span class="cov0" title="0">if err := s.loadSubtitles(ctx, session, session.CurrentVideo.ID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to load subtitles", zap.Error(err))
                }</span>
        } else<span class="cov0" title="0"> {
                session.Position = 0
        }</span>

        <span class="cov0" title="0">session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveVideoSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *VideoPlayerService) SeekVideo(ctx context.Context, req *VideoSeekRequest) (*VideoPlaybackSession, error) <span class="cov0" title="0">{
        s.logger.Debug("Seeking in video",
                zap.String("session_id", req.SessionID),
                zap.Int64("position", req.Position))

        session, err := s.GetVideoSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Position &lt; 0 </span><span class="cov0" title="0">{
                req.Position = 0
        }</span>
        <span class="cov0" title="0">if req.Position &gt; session.Duration </span><span class="cov0" title="0">{
                req.Position = session.Duration
        }</span>

        <span class="cov0" title="0">if req.Position &lt; session.Position </span><span class="cov0" title="0">{
                session.ViewingProgress.RewindCount++
        }</span> else<span class="cov0" title="0"> if req.Position &gt; session.Position+5000 </span><span class="cov0" title="0">{
                session.ViewingProgress.FastForwardCount++
        }</span>

        <span class="cov0" title="0">session.ViewingProgress.SeekCount++
        session.Position = req.Position
        session.LastActivity = time.Now()
        session.UpdatedAt = time.Now()

        if err := s.saveVideoSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *VideoPlayerService) CreateVideoBookmark(ctx context.Context, req *CreateVideoBookmarkRequest) (*VideoBookmark, error) <span class="cov0" title="0">{
        s.logger.Info("Creating video bookmark", zap.String("session_id", req.SessionID))

        session, err := s.GetVideoSession(ctx, req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">thumbnail, err := s.generateThumbnail(ctx, session.CurrentVideo.ID, session.Position)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to generate thumbnail", zap.Error(err))
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO video_bookmarks (user_id, video_id, position, title, description, thumbnail_url, created_at)
                VALUES ($1, $2, $3, $4, $5, $6, NOW())
                RETURNING id, created_at
        `

        var bookmark VideoBookmark
        var thumbnailURL string
        if thumbnail != nil &amp;&amp; thumbnail.URL != nil </span><span class="cov0" title="0">{
                thumbnailURL = *thumbnail.URL
        }</span>

        <span class="cov0" title="0">err = s.db.QueryRowContext(ctx, query,
                session.UserID, session.CurrentVideo.ID, session.Position,
                req.Title, req.Description, thumbnailURL).Scan(
                &amp;bookmark.ID, &amp;bookmark.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create bookmark: %w", err)
        }</span>

        <span class="cov0" title="0">bookmark.UserID = session.UserID
        bookmark.VideoID = session.CurrentVideo.ID
        bookmark.Position = session.Position
        bookmark.Title = req.Title
        bookmark.Description = req.Description
        bookmark.Thumbnail = thumbnail

        return &amp;bookmark, nil</span>
}

func (s *VideoPlayerService) GetWatchHistory(ctx context.Context, req *WatchHistoryRequest) ([]WatchHistory, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting watch history", zap.Int64("user_id", req.UserID))

        baseQuery := `
                SELECT vh.id, vh.user_id, vh.video_id, vh.watched_at, vh.watch_duration,
                           vh.completion_rate, vh.stopped_at, vh.device_info, vh.quality
                FROM video_watch_history vh
                WHERE vh.user_id = $1
        `

        args := []interface{}{req.UserID}
        argIndex := 2

        if req.StartDate != nil </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" AND vh.watched_at &gt;= $%d", argIndex)
                args = append(args, *req.StartDate)
                argIndex++
        }</span>

        <span class="cov0" title="0">if req.EndDate != nil </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" AND vh.watched_at &lt;= $%d", argIndex)
                args = append(args, *req.EndDate)
                argIndex++
        }</span>

        <span class="cov0" title="0">if req.VideoType != nil </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" AND mi.type = $%d", argIndex)
                args = append(args, string(*req.VideoType))
                argIndex++
                baseQuery = strings.Replace(baseQuery, "FROM video_watch_history vh",
                        "FROM video_watch_history vh INNER JOIN media_items mi ON vh.video_id = mi.id", 1)
        }</span>

        <span class="cov0" title="0">baseQuery += " ORDER BY vh.watched_at DESC"

        if req.Limit &gt; 0 </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" LIMIT $%d", argIndex)
                args = append(args, req.Limit)
                argIndex++
        }</span>

        <span class="cov0" title="0">if req.Offset &gt; 0 </span><span class="cov0" title="0">{
                baseQuery += fmt.Sprintf(" OFFSET $%d", argIndex)
                args = append(args, req.Offset)
        }</span>

        <span class="cov0" title="0">rows, err := s.db.QueryContext(ctx, baseQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get watch history: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var history []WatchHistory
        var videoIDs []int64

        for rows.Next() </span><span class="cov0" title="0">{
                var item WatchHistory
                err := rows.Scan(
                        &amp;item.ID, &amp;item.UserID, &amp;item.VideoID, &amp;item.WatchedAt,
                        &amp;item.WatchDuration, &amp;item.CompletionRate, &amp;item.StoppedAt,
                        &amp;item.DeviceInfo, &amp;item.Quality,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">history = append(history, item)
                videoIDs = append(videoIDs, item.VideoID)</span>
        }

        <span class="cov0" title="0">videoMap, err := s.getVideoContentsMap(ctx, videoIDs)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load video contents", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                for i := range history </span><span class="cov0" title="0">{
                        if video, exists := videoMap[history[i].VideoID]; exists </span><span class="cov0" title="0">{
                                history[i].VideoContent = video
                        }</span>
                }
        }

        <span class="cov0" title="0">return history, nil</span>
}

func (s *VideoPlayerService) GetContinueWatching(ctx context.Context, userID int64, limit int) ([]VideoContent, error) <span class="cov0" title="0">{
        s.logger.Debug("Getting continue watching", zap.Int64("user_id", userID))

        query := `
                SELECT DISTINCT pp.media_item_id
                FROM playback_positions pp
                INNER JOIN media_items mi ON pp.media_item_id = mi.id
                WHERE pp.user_id = $1
                  AND mi.type = 'video'
                  AND pp.percent_complete BETWEEN 5 AND 90
                  AND pp.last_played &gt; NOW() - INTERVAL '30 days'
                ORDER BY pp.last_played DESC
                LIMIT $2
        `

        rows, err := s.db.QueryContext(ctx, query, userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get continue watching: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var videoIDs []int64
        for rows.Next() </span><span class="cov0" title="0">{
                var videoID int64
                if err := rows.Scan(&amp;videoID); err == nil </span><span class="cov0" title="0">{
                        videoIDs = append(videoIDs, videoID)
                }</span>
        }

        <span class="cov0" title="0">videos, err := s.getVideoContents(ctx, videoIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get video contents: %w", err)
        }</span>

        <span class="cov0" title="0">return videos, nil</span>
}

func (s *VideoPlayerService) getVideoContent(ctx context.Context, videoID int64) (*VideoContent, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, original_title, description, type, file_path, file_size,
                           duration, resolution, aspect_ratio, frame_rate, bitrate, codec,
                           hdr, dolby_vision, dolby_atmos, year, release_date, genres,
                           directors, actors, writers, rating, imdb_id, tmdb_id, language,
                           country, play_count, last_played, date_added, user_rating,
                           is_favorite, watched_percentage
                FROM media_items
                WHERE id = $1 AND type = 'video'
        `

        var video VideoContent
        var releaseDate sql.NullTime
        var lastPlayed sql.NullTime
        var genresJSON, directorsJSON, actorsJSON, writersJSON sql.NullString
        var rating sql.NullFloat64
        var userRating sql.NullInt64

        err := s.db.QueryRowContext(ctx, query, videoID).Scan(
                &amp;video.ID, &amp;video.Title, &amp;video.OriginalTitle, &amp;video.Description,
                &amp;video.Type, &amp;video.FilePath, &amp;video.FileSize, &amp;video.Duration,
                &amp;video.Resolution, &amp;video.AspectRatio, &amp;video.FrameRate, &amp;video.Bitrate,
                &amp;video.Codec, &amp;video.HDR, &amp;video.DolbyVision, &amp;video.DolbyAtmos,
                &amp;video.Year, &amp;releaseDate, &amp;genresJSON, &amp;directorsJSON, &amp;actorsJSON,
                &amp;writersJSON, &amp;rating, &amp;video.IMDbID, &amp;video.TMDbID, &amp;video.Language,
                &amp;video.Country, &amp;video.PlayCount, &amp;lastPlayed, &amp;video.DateAdded,
                &amp;userRating, &amp;video.IsFavorite, &amp;video.WatchedPercentage,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if releaseDate.Valid </span><span class="cov0" title="0">{
                video.ReleaseDate = &amp;releaseDate.Time
        }</span>
        <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                video.LastPlayed = &amp;lastPlayed.Time
        }</span>
        <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                video.Rating = &amp;rating.Float64
        }</span>
        <span class="cov0" title="0">if userRating.Valid </span><span class="cov0" title="0">{
                ratingInt := int(userRating.Int64)
                video.UserRating = &amp;ratingInt
        }</span>

        <span class="cov0" title="0">if genresJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(genresJSON.String), &amp;video.Genres)
        }</span>
        <span class="cov0" title="0">if directorsJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(directorsJSON.String), &amp;video.Directors)
        }</span>
        <span class="cov0" title="0">if actorsJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(actorsJSON.String), &amp;video.Actors)
        }</span>
        <span class="cov0" title="0">if writersJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(writersJSON.String), &amp;video.Writers)
        }</span>

        <span class="cov0" title="0">if err := s.loadVideoMetadata(ctx, &amp;video); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to load video metadata", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return &amp;video, nil</span>
}

func (s *VideoPlayerService) getVideoContents(ctx context.Context, videoIDs []int64) ([]VideoContent, error) <span class="cov0" title="0">{
        if len(videoIDs) == 0 </span><span class="cov0" title="0">{
                return []VideoContent{}, nil
        }</span>

        <span class="cov0" title="0">videoMap, err := s.getVideoContentsMap(ctx, videoIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var videos []VideoContent
        for _, id := range videoIDs </span><span class="cov0" title="0">{
                if video, exists := videoMap[id]; exists </span><span class="cov0" title="0">{
                        videos = append(videos, video)
                }</span>
        }

        <span class="cov0" title="0">return videos, nil</span>
}

func (s *VideoPlayerService) getVideoContentsMap(ctx context.Context, videoIDs []int64) (map[int64]VideoContent, error) <span class="cov0" title="0">{
        if len(videoIDs) == 0 </span><span class="cov0" title="0">{
                return make(map[int64]VideoContent), nil
        }</span>

        <span class="cov0" title="0">placeholders := make([]string, len(videoIDs))
        args := make([]interface{}, len(videoIDs))
        for i, id := range videoIDs </span><span class="cov0" title="0">{
                placeholders[i] = fmt.Sprintf("$%d", i+1)
                args[i] = id
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT id, title, original_title, description, type, file_path, file_size,
                           duration, resolution, aspect_ratio, frame_rate, bitrate, codec,
                           hdr, dolby_vision, dolby_atmos, year, release_date, genres,
                           directors, actors, writers, rating, imdb_id, tmdb_id, language,
                           country, play_count, last_played, date_added, user_rating,
                           is_favorite, watched_percentage
                FROM media_items
                WHERE id IN (%s) AND type = 'video'
        `, strings.Join(placeholders, ","))

        rows, err := s.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        videoMap := make(map[int64]VideoContent)
        for rows.Next() </span><span class="cov0" title="0">{
                var video VideoContent
                var releaseDate sql.NullTime
                var lastPlayed sql.NullTime
                var genresJSON, directorsJSON, actorsJSON, writersJSON sql.NullString
                var rating sql.NullFloat64
                var userRating sql.NullInt64

                err := rows.Scan(
                        &amp;video.ID, &amp;video.Title, &amp;video.OriginalTitle, &amp;video.Description,
                        &amp;video.Type, &amp;video.FilePath, &amp;video.FileSize, &amp;video.Duration,
                        &amp;video.Resolution, &amp;video.AspectRatio, &amp;video.FrameRate, &amp;video.Bitrate,
                        &amp;video.Codec, &amp;video.HDR, &amp;video.DolbyVision, &amp;video.DolbyAtmos,
                        &amp;video.Year, &amp;releaseDate, &amp;genresJSON, &amp;directorsJSON, &amp;actorsJSON,
                        &amp;writersJSON, &amp;rating, &amp;video.IMDbID, &amp;video.TMDbID, &amp;video.Language,
                        &amp;video.Country, &amp;video.PlayCount, &amp;lastPlayed, &amp;video.DateAdded,
                        &amp;userRating, &amp;video.IsFavorite, &amp;video.WatchedPercentage,
                )

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if releaseDate.Valid </span><span class="cov0" title="0">{
                        video.ReleaseDate = &amp;releaseDate.Time
                }</span>
                <span class="cov0" title="0">if lastPlayed.Valid </span><span class="cov0" title="0">{
                        video.LastPlayed = &amp;lastPlayed.Time
                }</span>
                <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                        video.Rating = &amp;rating.Float64
                }</span>
                <span class="cov0" title="0">if userRating.Valid </span><span class="cov0" title="0">{
                        ratingInt := int(userRating.Int64)
                        video.UserRating = &amp;ratingInt
                }</span>

                <span class="cov0" title="0">if genresJSON.Valid </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(genresJSON.String), &amp;video.Genres)
                }</span>
                <span class="cov0" title="0">if directorsJSON.Valid </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(directorsJSON.String), &amp;video.Directors)
                }</span>
                <span class="cov0" title="0">if actorsJSON.Valid </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(actorsJSON.String), &amp;video.Actors)
                }</span>
                <span class="cov0" title="0">if writersJSON.Valid </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(writersJSON.String), &amp;video.Writers)
                }</span>

                <span class="cov0" title="0">videoMap[video.ID] = video</span>
        }

        <span class="cov0" title="0">return videoMap, nil</span>
}

func (s *VideoPlayerService) getSeriesInfo(ctx context.Context, seriesID int64) (*SeriesInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, description, total_seasons, total_episodes, status,
                           first_aired, last_aired, network, creator
                FROM series
                WHERE id = $1
        `

        var series SeriesInfo
        var firstAired, lastAired sql.NullTime
        var creatorJSON sql.NullString

        err := s.db.QueryRowContext(ctx, query, seriesID).Scan(
                &amp;series.ID, &amp;series.Title, &amp;series.Description, &amp;series.TotalSeasons,
                &amp;series.TotalEpisodes, &amp;series.Status, &amp;firstAired, &amp;lastAired,
                &amp;series.Network, &amp;creatorJSON,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if firstAired.Valid </span><span class="cov0" title="0">{
                series.FirstAired = &amp;firstAired.Time
        }</span>
        <span class="cov0" title="0">if lastAired.Valid </span><span class="cov0" title="0">{
                series.LastAired = &amp;lastAired.Time
        }</span>
        <span class="cov0" title="0">if creatorJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(creatorJSON.String), &amp;series.Creator)
        }</span>

        <span class="cov0" title="0">return &amp;series, nil</span>
}

func (s *VideoPlayerService) getSeasonEpisodes(ctx context.Context, seriesID int64, seasonNumber int) ([]VideoContent, error) <span class="cov0" title="0">{
        query := `
                SELECT mi.id
                FROM media_items mi
                INNER JOIN episodes e ON mi.id = e.media_item_id
                WHERE e.series_id = $1 AND e.season_number = $2 AND mi.type = 'video'
                ORDER BY e.episode_number ASC
        `

        rows, err := s.db.QueryContext(ctx, query, seriesID, seasonNumber)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var episodeIDs []int64
        for rows.Next() </span><span class="cov0" title="0">{
                var episodeID int64
                if err := rows.Scan(&amp;episodeID); err == nil </span><span class="cov0" title="0">{
                        episodeIDs = append(episodeIDs, episodeID)
                }</span>
        }

        <span class="cov0" title="0">return s.getVideoContents(ctx, episodeIDs)</span>
}

func (s *VideoPlayerService) loadVideoMetadata(ctx context.Context, video *VideoContent) error <span class="cov0" title="0">{
        if err := s.loadSeriesInfo(ctx, video); err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to load series info", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.loadEpisodeInfo(ctx, video); err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to load episode info", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := s.loadMovieInfo(ctx, video); err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to load movie info", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *VideoPlayerService) loadSeriesInfo(ctx context.Context, video *VideoContent) error <span class="cov0" title="0">{
        if video.Type != VideoTypeEpisode </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := `
                SELECT s.id, s.title, s.description, s.total_seasons, s.total_episodes,
                           s.status, s.first_aired, s.last_aired, s.network, s.creator
                FROM series s
                INNER JOIN episodes e ON s.id = e.series_id
                WHERE e.media_item_id = $1
        `

        var series SeriesInfo
        var firstAired, lastAired sql.NullTime
        var creatorJSON sql.NullString

        err := s.db.QueryRowContext(ctx, query, video.ID).Scan(
                &amp;series.ID, &amp;series.Title, &amp;series.Description, &amp;series.TotalSeasons,
                &amp;series.TotalEpisodes, &amp;series.Status, &amp;firstAired, &amp;lastAired,
                &amp;series.Network, &amp;creatorJSON,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if firstAired.Valid </span><span class="cov0" title="0">{
                series.FirstAired = &amp;firstAired.Time
        }</span>
        <span class="cov0" title="0">if lastAired.Valid </span><span class="cov0" title="0">{
                series.LastAired = &amp;lastAired.Time
        }</span>
        <span class="cov0" title="0">if creatorJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(creatorJSON.String), &amp;series.Creator)
        }</span>

        <span class="cov0" title="0">video.SeriesInfo = &amp;series
        return nil</span>
}

func (s *VideoPlayerService) loadEpisodeInfo(ctx context.Context, video *VideoContent) error <span class="cov0" title="0">{
        if video.Type != VideoTypeEpisode </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := `
                SELECT series_id, season_number, episode_number, air_date, runtime, guest_stars,
                           next_episode_id, prev_episode_id
                FROM episodes
                WHERE media_item_id = $1
        `

        var episode EpisodeInfo
        var airDate sql.NullTime
        var guestStarsJSON sql.NullString
        var nextEpisodeID, prevEpisodeID sql.NullInt64

        err := s.db.QueryRowContext(ctx, query, video.ID).Scan(
                &amp;episode.SeriesID, &amp;episode.SeasonNumber, &amp;episode.EpisodeNumber,
                &amp;airDate, &amp;episode.Runtime, &amp;guestStarsJSON, &amp;nextEpisodeID, &amp;prevEpisodeID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if airDate.Valid </span><span class="cov0" title="0">{
                episode.AirDate = &amp;airDate.Time
        }</span>
        <span class="cov0" title="0">if guestStarsJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(guestStarsJSON.String), &amp;episode.GuestStars)
        }</span>
        <span class="cov0" title="0">if nextEpisodeID.Valid </span><span class="cov0" title="0">{
                nextID := nextEpisodeID.Int64
                episode.NextEpisodeID = &amp;nextID
        }</span>
        <span class="cov0" title="0">if prevEpisodeID.Valid </span><span class="cov0" title="0">{
                prevID := prevEpisodeID.Int64
                episode.PrevEpisodeID = &amp;prevID
        }</span>

        <span class="cov0" title="0">video.EpisodeInfo = &amp;episode
        return nil</span>
}

func (s *VideoPlayerService) loadMovieInfo(ctx context.Context, video *VideoContent) error <span class="cov0" title="0">{
        if video.Type != VideoTypeMovie </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := `
                SELECT budget, revenue, runtime, collection, studio, production_companies
                FROM movies
                WHERE media_item_id = $1
        `

        var movie MovieInfo
        var studioJSON, companiesJSON sql.NullString

        err := s.db.QueryRowContext(ctx, query, video.ID).Scan(
                &amp;movie.Budget, &amp;movie.Revenue, &amp;movie.Runtime, &amp;movie.Collection,
                &amp;studioJSON, &amp;companiesJSON,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if studioJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(studioJSON.String), &amp;movie.Studio)
        }</span>
        <span class="cov0" title="0">if companiesJSON.Valid </span><span class="cov0" title="0">{
                json.Unmarshal([]byte(companiesJSON.String), &amp;movie.ProductionCompanies)
        }</span>

        <span class="cov0" title="0">video.MovieInfo = &amp;movie
        return nil</span>
}

func (s *VideoPlayerService) loadVideoStreams(ctx context.Context, session *VideoPlaybackSession, videoID int64) error <span class="cov0" title="0">{
        query := `
                SELECT id, stream_index, codec, width, height, bitrate, fps, language, title, is_default
                FROM video_streams
                WHERE media_item_id = $1
                ORDER BY stream_index ASC
        `

        rows, err := s.db.QueryContext(ctx, query, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var videoStreams []VideoStream
        for rows.Next() </span><span class="cov0" title="0">{
                var stream VideoStream
                err := rows.Scan(
                        &amp;stream.ID, &amp;stream.Index, &amp;stream.Codec, &amp;stream.Width, &amp;stream.Height,
                        &amp;stream.Bitrate, &amp;stream.FPS, &amp;stream.Language, &amp;stream.Title, &amp;stream.Default,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">videoStreams = append(videoStreams, stream)</span>
        }

        <span class="cov0" title="0">session.CurrentVideo.VideoStreams = videoStreams

        audioQuery := `
                SELECT id, stream_index, codec, channels, bitrate, language, title, is_default
                FROM audio_streams
                WHERE media_item_id = $1
                ORDER BY stream_index ASC
        `

        audioRows, err := s.db.QueryContext(ctx, audioQuery, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer audioRows.Close()

        var audioStreams []AudioStream
        var audioTracks []AudioTrack
        for audioRows.Next() </span><span class="cov0" title="0">{
                var stream AudioStream
                err := audioRows.Scan(
                        &amp;stream.ID, &amp;stream.Index, &amp;stream.Codec, &amp;stream.Channels,
                        &amp;stream.Bitrate, &amp;stream.Language, &amp;stream.Title, &amp;stream.Default,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">audioStreams = append(audioStreams, stream)

                audioTrack := AudioTrack{
                        ID:        fmt.Sprintf("%d", stream.ID),
                        Language:  stream.Language,
                        Title:     &amp;stream.Title,
                        Codec:     stream.Codec,
                        Channels:  stream.Channels,
                        Bitrate:   &amp;stream.Bitrate,
                        IsDefault: stream.Default,
                }
                audioTracks = append(audioTracks, audioTrack)

                if stream.Default &amp;&amp; session.ActiveAudioTrack == nil </span><span class="cov0" title="0">{
                        session.ActiveAudioTrack = &amp;stream.ID
                }</span>
        }

        <span class="cov0" title="0">session.CurrentVideo.AudioStreams = audioStreams
        session.AudioTracks = audioTracks

        return nil</span>
}

func (s *VideoPlayerService) loadSubtitles(ctx context.Context, session *VideoPlaybackSession, videoID int64) error <span class="cov0" title="0">{
        subtitleStreams, err := s.getSubtitleStreams(ctx, videoID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get subtitle streams", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                session.CurrentVideo.SubtitleStreams = subtitleStreams
        }</span>

        <span class="cov0" title="0">subtitleTracks, err := s.getSubtitleTracks(ctx, videoID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("Failed to get subtitle tracks", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                session.SubtitleTracks = subtitleTracks

                // Set active subtitle to the default track if available
                for i, track := range subtitleTracks </span><span class="cov0" title="0">{
                        if track.IsDefault &amp;&amp; session.ActiveSubtitle == nil </span><span class="cov0" title="0">{
                                // Use track index as the active subtitle identifier
                                // Since SubtitleTrack.ID is string but ActiveSubtitle expects *int64,
                                // we use the track index (position in array) as the identifier
                                trackIndex := int64(i)
                                session.ActiveSubtitle = &amp;trackIndex
                                s.logger.Debug("Set default subtitle track",
                                        zap.Int64("index", trackIndex),
                                        zap.String("language", track.Language))
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *VideoPlayerService) getSubtitleStreams(ctx context.Context, videoID int64) ([]SubtitleStream, error) <span class="cov0" title="0">{
        query := `
                SELECT id, stream_index, codec, language, title, is_default, is_forced, is_external, file_path
                FROM subtitle_streams
                WHERE media_item_id = $1
                ORDER BY stream_index ASC
        `

        rows, err := s.db.QueryContext(ctx, query, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var streams []SubtitleStream
        for rows.Next() </span><span class="cov0" title="0">{
                var stream SubtitleStream
                err := rows.Scan(
                        &amp;stream.ID, &amp;stream.Index, &amp;stream.Codec, &amp;stream.Language,
                        &amp;stream.Title, &amp;stream.Default, &amp;stream.Forced, &amp;stream.External, &amp;stream.FilePath,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">streams = append(streams, stream)</span>
        }

        <span class="cov0" title="0">return streams, nil</span>
}

func (s *VideoPlayerService) getSubtitleTracks(ctx context.Context, videoID int64) ([]SubtitleTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, language, language_code, source, format, path, content,
                           is_default, is_forced, encoding, sync_offset, created_at, verified_sync
                FROM subtitle_tracks
                WHERE media_item_id = $1
                ORDER BY is_default DESC, language ASC
        `

        rows, err := s.db.QueryContext(ctx, query, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tracks []SubtitleTrack
        for rows.Next() </span><span class="cov0" title="0">{
                var track SubtitleTrack
                var path sql.NullString
                var content sql.NullString

                err := rows.Scan(
                        &amp;track.ID, &amp;track.Language, &amp;track.LanguageCode, &amp;track.Source,
                        &amp;track.Format, &amp;path, &amp;content, &amp;track.IsDefault, &amp;track.IsForced,
                        &amp;track.Encoding, &amp;track.SyncOffset, &amp;track.CreatedAt, &amp;track.VerifiedSync,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if path.Valid </span><span class="cov0" title="0">{
                        track.Path = &amp;path.String
                }</span>
                <span class="cov0" title="0">if content.Valid </span><span class="cov0" title="0">{
                        track.Content = &amp;content.String
                }</span>

                <span class="cov0" title="0">tracks = append(tracks, track)</span>
        }

        <span class="cov0" title="0">return tracks, nil</span>
}

func (s *VideoPlayerService) loadChapters(ctx context.Context, session *VideoPlaybackSession, videoID int64) error <span class="cov0" title="0">{
        query := `
                SELECT id, title, start_time, end_time, thumbnail_url
                FROM video_chapters
                WHERE media_item_id = $1
                ORDER BY start_time ASC
        `

        rows, err := s.db.QueryContext(ctx, query, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var chapters []Chapter
        for rows.Next() </span><span class="cov0" title="0">{
                var chapter Chapter
                var thumbnailURL sql.NullString
                err := rows.Scan(
                        &amp;chapter.ID, &amp;chapter.Title, &amp;chapter.StartTime, &amp;chapter.EndTime, &amp;thumbnailURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if thumbnailURL.Valid </span><span class="cov0" title="0">{
                        chapter.Thumbnail = &amp;thumbnailURL.String
                }</span>

                <span class="cov0" title="0">chapters = append(chapters, chapter)</span>
        }

        <span class="cov0" title="0">session.Chapters = chapters
        return nil</span>
}

func (s *VideoPlayerService) loadEpisodePlaylist(ctx context.Context, session *VideoPlaybackSession, seriesID int64, seasonNumber int) error <span class="cov0" title="0">{
        episodes, err := s.getSeasonEpisodes(ctx, seriesID, seasonNumber)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.Playlist = episodes
        for i, episode := range episodes </span><span class="cov0" title="0">{
                if episode.ID == session.CurrentVideo.ID </span><span class="cov0" title="0">{
                        session.PlaylistIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *VideoPlayerService) loadSeasonPlaylist(ctx context.Context, session *VideoPlaybackSession, seriesID int64, seasonNumber int) error <span class="cov0" title="0">{
        return s.loadEpisodePlaylist(ctx, session, seriesID, seasonNumber)
}</span>

func (s *VideoPlayerService) loadSeriesPlaylist(ctx context.Context, session *VideoPlaybackSession, seriesID int64) error <span class="cov0" title="0">{
        query := `
                SELECT mi.id
                FROM media_items mi
                INNER JOIN episodes e ON mi.id = e.media_item_id
                WHERE e.series_id = $1 AND mi.type = 'video'
                ORDER BY e.season_number ASC, e.episode_number ASC
        `

        rows, err := s.db.QueryContext(ctx, query, seriesID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var episodeIDs []int64
        for rows.Next() </span><span class="cov0" title="0">{
                var episodeID int64
                if err := rows.Scan(&amp;episodeID); err == nil </span><span class="cov0" title="0">{
                        episodeIDs = append(episodeIDs, episodeID)
                }</span>
        }

        <span class="cov0" title="0">episodes, err := s.getVideoContents(ctx, episodeIDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.Playlist = episodes
        for i, episode := range episodes </span><span class="cov0" title="0">{
                if episode.ID == session.CurrentVideo.ID </span><span class="cov0" title="0">{
                        session.PlaylistIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *VideoPlayerService) loadVideoPlaylist(ctx context.Context, session *VideoPlaybackSession, playlistID int64) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *VideoPlayerService) generateThumbnail(ctx context.Context, videoID, position int64) (*CoverArt, error) <span class="cov0" title="0">{
        video, err := s.getVideoContent(ctx, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">thumbnailRequest := &amp;VideoThumbnailRequest{
                MediaItemID: videoID,
                VideoPath:   video.FilePath,
                Timestamps:  []float64{float64(position)},
                Quality:     QualityThumbnail,
                Count:       1,
        }

        thumbnails, err := s.coverArtService.GenerateVideoThumbnails(ctx, thumbnailRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(thumbnails) &gt; 0 </span><span class="cov0" title="0">{
                return thumbnails[0], nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("failed to generate thumbnail")</span>
}

func (s *VideoPlayerService) saveVideoSession(ctx context.Context, session *VideoPlaybackSession) error <span class="cov0" title="0">{
        sessionData, err := json.Marshal(session)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal session: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO video_playback_sessions (id, user_id, session_data, expires_at, updated_at)
                VALUES ($1, $2, $3, NOW() + INTERVAL '24 hours', NOW())
                ON CONFLICT (id)
                DO UPDATE SET
                        session_data = EXCLUDED.session_data,
                        expires_at = NOW() + INTERVAL '24 hours',
                        updated_at = NOW()
        `

        _, err = s.db.ExecContext(ctx, query, session.ID, session.UserID, string(sessionData))
        return err</span>
}

func (s *VideoPlayerService) recordVideoPlayback(ctx context.Context, userID, videoID int64) error <span class="cov0" title="0">{
        query := `
                UPDATE media_items
                SET play_count = play_count + 1, last_played = NOW()
                WHERE id = $1
        `

        _, err := s.db.ExecContext(ctx, query, videoID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">historyQuery := `
                INSERT INTO video_watch_history (user_id, video_id, watched_at, watch_duration, completion_rate, stopped_at, device_info, quality)
                VALUES ($1, $2, NOW(), 0, 0, 0, '', '')
        `

        _, err = s.db.ExecContext(ctx, historyQuery, userID, videoID)
        return err</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package smb

import (
        "context"
        "fmt"
        "sync"
        "time"

        "go.uber.org/zap"
)

// ConnectionState represents the state of an SMB connection
type ConnectionState int

const (
        StateConnected ConnectionState = iota
        StateDisconnected
        StateReconnecting
        StateOffline
)

func (s ConnectionState) String() string <span class="cov0" title="0">{
        switch s </span>{
        case StateConnected:<span class="cov0" title="0">
                return "connected"</span>
        case StateDisconnected:<span class="cov0" title="0">
                return "disconnected"</span>
        case StateReconnecting:<span class="cov0" title="0">
                return "reconnecting"</span>
        case StateOffline:<span class="cov0" title="0">
                return "offline"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// SMBSource represents a configured SMB source with resilience capabilities
type SMBSource struct {
        ID                  string          `json:"id"`
        Name                string          `json:"name"`
        Path                string          `json:"path"`
        Username            string          `json:"username"`
        Password            string          `json:"password"`
        Domain              string          `json:"domain"`
        State               ConnectionState `json:"state"`
        LastConnected       time.Time       `json:"last_connected"`
        LastError           string          `json:"last_error,omitempty"`
        RetryAttempts       int             `json:"retry_attempts"`
        MaxRetryAttempts    int             `json:"max_retry_attempts"`
        RetryDelay          time.Duration   `json:"retry_delay"`
        ConnectionTimeout   time.Duration   `json:"connection_timeout"`
        HealthCheckInterval time.Duration   `json:"health_check_interval"`
        IsEnabled           bool            `json:"is_enabled"`
        mutex               sync.RWMutex
}

// ResilientSMBManager manages multiple SMB sources with automatic recovery
type ResilientSMBManager struct {
        sources       map[string]*SMBSource
        logger        *zap.Logger
        offlineCache  *OfflineCache
        healthChecker *HealthChecker
        eventChannel  chan SMBEvent
        stopChannel   chan struct{}
        wg            sync.WaitGroup
        mutex         sync.RWMutex
        startTime     time.Time
}

// SMBEvent represents events from SMB operations
type SMBEvent struct {
        Type      EventType   `json:"type"`
        SourceID  string      `json:"source_id"`
        Path      string      `json:"path,omitempty"`
        Error     error       `json:"error,omitempty"`
        Timestamp time.Time   `json:"timestamp"`
        Data      interface{} `json:"data,omitempty"`
}

type EventType int

const (
        EventConnected EventType = iota
        EventDisconnected
        EventReconnecting
        EventOffline
        EventFileChange
        EventError
        EventHealthCheck
)

func (e EventType) String() string <span class="cov0" title="0">{
        switch e </span>{
        case EventConnected:<span class="cov0" title="0">
                return "connected"</span>
        case EventDisconnected:<span class="cov0" title="0">
                return "disconnected"</span>
        case EventReconnecting:<span class="cov0" title="0">
                return "reconnecting"</span>
        case EventOffline:<span class="cov0" title="0">
                return "offline"</span>
        case EventFileChange:<span class="cov0" title="0">
                return "file_change"</span>
        case EventError:<span class="cov0" title="0">
                return "error"</span>
        case EventHealthCheck:<span class="cov0" title="0">
                return "health_check"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// OfflineCache stores metadata when SMB sources are unavailable
type OfflineCache struct {
        entries map[string]*CacheEntry
        maxSize int
        mutex   sync.RWMutex
        logger  *zap.Logger
}

type CacheEntry struct {
        Path        string                 `json:"path"`
        Metadata    map[string]interface{} `json:"metadata"`
        LastSeen    time.Time              `json:"last_seen"`
        IsAvailable bool                   `json:"is_available"`
        SourceID    string                 `json:"source_id"`
}

// HealthChecker periodically checks SMB source health
type HealthChecker struct {
        manager  *ResilientSMBManager
        interval time.Duration
        timeout  time.Duration
        logger   *zap.Logger
        ticker   *time.Ticker
        ctx      context.Context
        cancel   context.CancelFunc
}

// NewResilientSMBManager creates a new resilient SMB manager
func NewResilientSMBManager(logger *zap.Logger, cacheSize int) *ResilientSMBManager <span class="cov0" title="0">{
        manager := &amp;ResilientSMBManager{
                sources:      make(map[string]*SMBSource),
                logger:       logger,
                offlineCache: NewOfflineCache(cacheSize, logger),
                eventChannel: make(chan SMBEvent, 100),
                stopChannel:  make(chan struct{}),
                startTime:    time.Now(),
        }

        manager.healthChecker = NewHealthChecker(manager, 60*time.Second, 30*time.Second, logger)
        return manager
}</span>

// NewOfflineCache creates a new offline cache
func NewOfflineCache(maxSize int, logger *zap.Logger) *OfflineCache <span class="cov0" title="0">{
        return &amp;OfflineCache{
                entries: make(map[string]*CacheEntry),
                maxSize: maxSize,
                logger:  logger,
        }
}</span>

// NewHealthChecker creates a new health checker
func NewHealthChecker(manager *ResilientSMBManager, interval, timeout time.Duration, logger *zap.Logger) *HealthChecker <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        return &amp;HealthChecker{
                manager:  manager,
                interval: interval,
                timeout:  timeout,
                logger:   logger,
                ctx:      ctx,
                cancel:   cancel,
        }
}</span>

// AddSource adds a new SMB source to the manager
func (m *ResilientSMBManager) AddSource(source *SMBSource) error <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if source.ID == "" </span><span class="cov0" title="0">{
                source.ID = fmt.Sprintf("smb_%d", time.Now().Unix())
        }</span>

        // Set default values
        <span class="cov0" title="0">if source.MaxRetryAttempts == 0 </span><span class="cov0" title="0">{
                source.MaxRetryAttempts = 5
        }</span>
        <span class="cov0" title="0">if source.RetryDelay == 0 </span><span class="cov0" title="0">{
                source.RetryDelay = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if source.ConnectionTimeout == 0 </span><span class="cov0" title="0">{
                source.ConnectionTimeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if source.HealthCheckInterval == 0 </span><span class="cov0" title="0">{
                source.HealthCheckInterval = 60 * time.Second
        }</span>

        <span class="cov0" title="0">source.State = StateDisconnected
        source.IsEnabled = true

        m.sources[source.ID] = source

        // Try initial connection
        go m.connectSource(source)

        m.logger.Info("SMB source added",
                zap.String("id", source.ID),
                zap.String("name", source.Name),
                zap.String("path", source.Path))

        return nil</span>
}

// RemoveSource removes an SMB source from the manager
func (m *ResilientSMBManager) RemoveSource(sourceID string) error <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        source, exists := m.sources[sourceID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("source not found: %s", sourceID)
        }</span>

        <span class="cov0" title="0">source.IsEnabled = false
        delete(m.sources, sourceID)

        m.logger.Info("SMB source removed", zap.String("id", sourceID))
        return nil</span>
}

// Start begins monitoring all SMB sources
func (m *ResilientSMBManager) Start() error <span class="cov0" title="0">{
        m.logger.Info("Starting resilient SMB manager")

        // Start health checker
        m.healthChecker.Start()

        // Start event processor
        m.wg.Add(1)
        go m.processEvents()

        // Start monitoring existing sources
        m.mutex.RLock()
        sources := make([]*SMBSource, 0, len(m.sources))
        for _, source := range m.sources </span><span class="cov0" title="0">{
                if source.IsEnabled </span><span class="cov0" title="0">{
                        sources = append(sources, source)
                }</span>
        }
        <span class="cov0" title="0">m.mutex.RUnlock()

        for _, source := range sources </span><span class="cov0" title="0">{
                go m.monitorSource(source)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop shuts down the SMB manager
func (m *ResilientSMBManager) Stop() error <span class="cov0" title="0">{
        m.logger.Info("Stopping resilient SMB manager")

        // Stop health checker
        m.healthChecker.Stop()

        // Signal shutdown
        close(m.stopChannel)

        // Wait for goroutines to finish
        m.wg.Wait()

        return nil
}</span>

// connectSource attempts to connect to an SMB source
func (m *ResilientSMBManager) connectSource(source *SMBSource) error <span class="cov0" title="0">{
        source.mutex.Lock()
        defer source.mutex.Unlock()

        if !source.IsEnabled </span><span class="cov0" title="0">{
                return fmt.Errorf("source is disabled")
        }</span>

        <span class="cov0" title="0">source.State = StateReconnecting
        m.sendEvent(SMBEvent{
                Type:      EventReconnecting,
                SourceID:  source.ID,
                Timestamp: time.Now(),
        })

        // Simulate connection attempt (replace with actual SMB connection logic)
        ctx, cancel := context.WithTimeout(context.Background(), source.ConnectionTimeout)
        defer cancel()

        err := m.attemptConnection(ctx, source)
        if err != nil </span><span class="cov0" title="0">{
                source.State = StateDisconnected
                source.LastError = err.Error()
                source.RetryAttempts++

                m.logger.Error("Failed to connect to SMB source",
                        zap.String("id", source.ID),
                        zap.String("path", source.Path),
                        zap.Error(err),
                        zap.Int("retry_attempts", source.RetryAttempts))

                m.sendEvent(SMBEvent{
                        Type:      EventDisconnected,
                        SourceID:  source.ID,
                        Error:     err,
                        Timestamp: time.Now(),
                })

                // Schedule retry if not exceeded max attempts
                if source.RetryAttempts &lt; source.MaxRetryAttempts </span><span class="cov0" title="0">{
                        go m.scheduleRetry(source)
                }</span> else<span class="cov0" title="0"> {
                        source.State = StateOffline
                        m.sendEvent(SMBEvent{
                                Type:      EventOffline,
                                SourceID:  source.ID,
                                Timestamp: time.Now(),
                        })
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        // Connection successful
        <span class="cov0" title="0">source.State = StateConnected
        source.LastConnected = time.Now()
        source.LastError = ""
        source.RetryAttempts = 0

        m.logger.Info("Successfully connected to SMB source",
                zap.String("id", source.ID),
                zap.String("path", source.Path))

        m.sendEvent(SMBEvent{
                Type:      EventConnected,
                SourceID:  source.ID,
                Timestamp: time.Now(),
        })

        return nil</span>
}

// attemptConnection performs the actual SMB connection
func (m *ResilientSMBManager) attemptConnection(ctx context.Context, source *SMBSource) error <span class="cov0" title="0">{
        // This is a placeholder for actual SMB connection logic
        // In a real implementation, you would:
        // 1. Parse the SMB URL
        // 2. Create SMB connection with credentials
        // 3. Test connectivity with a simple operation
        // 4. Set up file system watcher

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("connection timeout: %s", source.Path)</span>
        case &lt;-time.After(100 * time.Millisecond):<span class="cov0" title="0"> // Simulate connection time
                // Simulate random connection failures for testing
                if time.Now().Unix()%7 == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("simulated connection failure")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// scheduleRetry schedules a retry attempt for a failed source
func (m *ResilientSMBManager) scheduleRetry(source *SMBSource) <span class="cov0" title="0">{
        delay := source.RetryDelay * time.Duration(source.RetryAttempts)
        if delay &gt; 5*time.Minute </span><span class="cov0" title="0">{
                delay = 5 * time.Minute // Cap maximum delay
        }</span>

        <span class="cov0" title="0">m.logger.Info("Scheduling retry for SMB source",
                zap.String("id", source.ID),
                zap.Duration("delay", delay),
                zap.Int("attempt", source.RetryAttempts+1))

        timer := time.NewTimer(delay)
        defer timer.Stop()

        select </span>{
        case &lt;-timer.C:<span class="cov0" title="0">
                m.connectSource(source)</span>
        case &lt;-m.stopChannel:<span class="cov0" title="0">
                return</span>
        }
}

// monitorSource continuously monitors an SMB source
func (m *ResilientSMBManager) monitorSource(source *SMBSource) <span class="cov0" title="0">{
        m.wg.Add(1)
        defer m.wg.Done()

        ticker := time.NewTicker(10 * time.Second) // Monitor every 10 seconds
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if source.IsEnabled &amp;&amp; source.State == StateConnected </span><span class="cov0" title="0">{
                                m.checkSourceHealth(source)
                        }</span>
                case &lt;-m.stopChannel:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// checkSourceHealth performs a health check on an SMB source
func (m *ResilientSMBManager) checkSourceHealth(source *SMBSource) <span class="cov0" title="0">{
        // Simulate health check (replace with actual SMB operation)
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        err := m.performHealthCheck(ctx, source)

        m.sendEvent(SMBEvent{
                Type:      EventHealthCheck,
                SourceID:  source.ID,
                Error:     err,
                Timestamp: time.Now(),
        })

        if err != nil </span><span class="cov0" title="0">{
                m.logger.Warn("SMB source health check failed",
                        zap.String("id", source.ID),
                        zap.Error(err))

                source.mutex.Lock()
                source.State = StateDisconnected
                source.LastError = err.Error()
                source.mutex.Unlock()

                // Attempt reconnection
                go m.connectSource(source)
        }</span>
}

// performHealthCheck performs the actual health check operation
func (m *ResilientSMBManager) performHealthCheck(ctx context.Context, source *SMBSource) error <span class="cov0" title="0">{
        // This is a placeholder for actual health check logic
        // In a real implementation, you would:
        // 1. Try to list a directory
        // 2. Check if the connection is still alive
        // 3. Verify read/write permissions

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("health check timeout")</span>
        case &lt;-time.After(50 * time.Millisecond):<span class="cov0" title="0"> // Simulate check time
                // Simulate random health check failures
                if time.Now().Unix()%20 == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("simulated health check failure")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// processEvents processes SMB events
func (m *ResilientSMBManager) processEvents() <span class="cov0" title="0">{
        defer m.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case event := &lt;-m.eventChannel:<span class="cov0" title="0">
                        m.handleEvent(event)</span>
                case &lt;-m.stopChannel:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// handleEvent handles individual SMB events
func (m *ResilientSMBManager) handleEvent(event SMBEvent) <span class="cov0" title="0">{
        m.logger.Debug("Processing SMB event",
                zap.String("type", event.Type.String()),
                zap.String("source_id", event.SourceID))

        switch event.Type </span>{
        case EventConnected:<span class="cov0" title="0">
                m.onSourceConnected(event.SourceID)</span>
        case EventDisconnected:<span class="cov0" title="0">
                m.onSourceDisconnected(event.SourceID, event.Error)</span>
        case EventOffline:<span class="cov0" title="0">
                m.onSourceOffline(event.SourceID)</span>
        case EventFileChange:<span class="cov0" title="0">
                m.onFileChange(event.SourceID, event.Path)</span>
        case EventError:<span class="cov0" title="0">
                m.onError(event.SourceID, event.Error)</span>
        }
}

// sendEvent sends an event to the event channel
func (m *ResilientSMBManager) sendEvent(event SMBEvent) <span class="cov0" title="0">{
        select </span>{
        case m.eventChannel &lt;- event:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                m.logger.Warn("Event channel full, dropping event",
                        zap.String("type", event.Type.String()),
                        zap.String("source_id", event.SourceID))</span>
        }
}

// Event handlers
func (m *ResilientSMBManager) onSourceConnected(sourceID string) <span class="cov0" title="0">{
        // Source reconnected, process any cached changes
        m.offlineCache.ProcessCachedChanges(sourceID)
}</span>

func (m *ResilientSMBManager) onSourceDisconnected(sourceID string, err error) <span class="cov0" title="0">{
        // Source disconnected, enable offline mode
        m.offlineCache.EnableOfflineMode(sourceID)
}</span>

func (m *ResilientSMBManager) onSourceOffline(sourceID string) <span class="cov0" title="0">{
        // Source is offline, full offline mode
        m.logger.Warn("SMB source is now offline", zap.String("source_id", sourceID))
}</span>

func (m *ResilientSMBManager) onFileChange(sourceID, path string) <span class="cov0" title="0">{
        // Handle file change, with offline caching if needed
        if m.isSourceConnected(sourceID) </span><span class="cov0" title="0">{
                // Process change immediately
                m.processFileChange(sourceID, path)
        }</span> else<span class="cov0" title="0"> {
                // Cache change for later processing
                m.offlineCache.CacheChange(sourceID, path)
        }</span>
}

func (m *ResilientSMBManager) onError(sourceID string, err error) <span class="cov0" title="0">{
        m.logger.Error("SMB source error",
                zap.String("source_id", sourceID),
                zap.Error(err))
}</span>

// Utility methods
func (m *ResilientSMBManager) isSourceConnected(sourceID string) bool <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        source, exists := m.sources[sourceID]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">source.mutex.RLock()
        defer source.mutex.RUnlock()

        return source.State == StateConnected</span>
}

func (m *ResilientSMBManager) processFileChange(sourceID, path string) <span class="cov0" title="0">{
        // Process file change logic here
        m.logger.Info("Processing file change",
                zap.String("source_id", sourceID),
                zap.String("path", path))
}</span>

// GetSourceStatus returns the status of all sources
func (m *ResilientSMBManager) GetSourceStatus() map[string]interface{} <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        status := make(map[string]interface{})
        for id, source := range m.sources </span><span class="cov0" title="0">{
                source.mutex.RLock()
                status[id] = map[string]interface{}{
                        "name":           source.Name,
                        "path":           source.Path,
                        "state":          source.State.String(),
                        "last_connected": source.LastConnected,
                        "last_error":     source.LastError,
                        "retry_attempts": source.RetryAttempts,
                        "is_enabled":     source.IsEnabled,
                }
                source.mutex.RUnlock()
        }</span>

        <span class="cov0" title="0">return status</span>
}

// GetStartTime returns when the manager was started
func (m *ResilientSMBManager) GetStartTime() time.Time <span class="cov0" title="0">{
        return m.startTime
}</span>

// ForceReconnect forces a reconnection attempt for a specific source
func (m *ResilientSMBManager) ForceReconnect(sourceID string) error <span class="cov0" title="0">{
        m.mutex.RLock()
        source, exists := m.sources[sourceID]
        m.mutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("source not found: %s", sourceID)
        }</span>

        <span class="cov0" title="0">if !source.IsEnabled </span><span class="cov0" title="0">{
                return fmt.Errorf("source is disabled: %s", sourceID)
        }</span>

        // Reset retry attempts to allow reconnection
        <span class="cov0" title="0">source.mutex.Lock()
        source.RetryAttempts = 0
        source.mutex.Unlock()

        // Trigger reconnection
        go m.connectSource(source)

        m.logger.Info("Force reconnect initiated", zap.String("source_id", sourceID))
        return nil</span>
}

// UpdateSource updates an existing SMB source
func (m *ResilientSMBManager) UpdateSource(sourceID string, updates interface{}) error <span class="cov0" title="0">{
        m.mutex.RLock()
        _, exists := m.sources[sourceID]
        m.mutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("source not found: %s", sourceID)
        }</span>

        // This would handle the actual update logic
        // For now, just log the update attempt
        <span class="cov0" title="0">m.logger.Info("SMB source update requested",
                zap.String("source_id", sourceID))

        return nil</span>
}

// OfflineCache methods
func (c *OfflineCache) CacheChange(sourceID, path string) <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        // Evict oldest entries if cache is full
        if len(c.entries) &gt;= c.maxSize </span><span class="cov0" title="0">{
                c.evictOldest()
        }</span>

        <span class="cov0" title="0">key := fmt.Sprintf("%s:%s", sourceID, path)
        c.entries[key] = &amp;CacheEntry{
                Path:        path,
                LastSeen:    time.Now(),
                IsAvailable: false,
                SourceID:    sourceID,
                Metadata:    make(map[string]interface{}),
        }

        c.logger.Debug("Cached file change",
                zap.String("source_id", sourceID),
                zap.String("path", path))</span>
}

func (c *OfflineCache) ProcessCachedChanges(sourceID string) <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        processed := 0
        for _, entry := range c.entries </span><span class="cov0" title="0">{
                if entry.SourceID == sourceID &amp;&amp; !entry.IsAvailable </span><span class="cov0" title="0">{
                        // Process cached change
                        c.logger.Info("Processing cached change",
                                zap.String("source_id", sourceID),
                                zap.String("path", entry.Path))

                        entry.IsAvailable = true
                        processed++
                }</span>
        }

        <span class="cov0" title="0">c.logger.Info("Processed cached changes",
                zap.String("source_id", sourceID),
                zap.Int("count", processed))</span>
}

func (c *OfflineCache) EnableOfflineMode(sourceID string) <span class="cov0" title="0">{
        c.logger.Info("Enabling offline mode for source", zap.String("source_id", sourceID))
}</span>

func (c *OfflineCache) evictOldest() <span class="cov0" title="0">{
        var oldestKey string
        var oldestTime time.Time

        for key, entry := range c.entries </span><span class="cov0" title="0">{
                if oldestKey == "" || entry.LastSeen.Before(oldestTime) </span><span class="cov0" title="0">{
                        oldestKey = key
                        oldestTime = entry.LastSeen
                }</span>
        }

        <span class="cov0" title="0">if oldestKey != "" </span><span class="cov0" title="0">{
                delete(c.entries, oldestKey)
                c.logger.Debug("Evicted cache entry", zap.String("key", oldestKey))
        }</span>
}

// HealthChecker methods
func (h *HealthChecker) Start() <span class="cov0" title="0">{
        h.ticker = time.NewTicker(h.interval)
        go h.run()
}</span>

func (h *HealthChecker) Stop() <span class="cov0" title="0">{
        if h.ticker != nil </span><span class="cov0" title="0">{
                h.ticker.Stop()
        }</span>
        <span class="cov0" title="0">h.cancel()</span>
}

func (h *HealthChecker) run() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-h.ticker.C:<span class="cov0" title="0">
                        h.performHealthChecks()</span>
                case &lt;-h.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (h *HealthChecker) performHealthChecks() <span class="cov0" title="0">{
        h.manager.mutex.RLock()
        sources := make([]*SMBSource, 0, len(h.manager.sources))
        for _, source := range h.manager.sources </span><span class="cov0" title="0">{
                if source.IsEnabled </span><span class="cov0" title="0">{
                        sources = append(sources, source)
                }</span>
        }
        <span class="cov0" title="0">h.manager.mutex.RUnlock()

        for _, source := range sources </span><span class="cov0" title="0">{
                go h.manager.checkSourceHealth(source)
        }</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package tests

import (
        "database/sql"
        "testing"

        "github.com/stretchr/testify/assert"
        "go.uber.org/zap"

        "catalogizer/internal/services"
        _ "github.com/mattn/go-sqlite3"
)

func TestDuplicateDetectionService_BasicCreation(t *testing.T) <span class="cov0" title="0">{
        db, _ := sql.Open("sqlite3", ":memory:")
        logger := zap.NewNop()
        
        // Create cache service first
        cacheService := services.NewCacheService(db, logger)
        
        // Test service creation
        service := services.NewDuplicateDetectionService(db, logger, cacheService)
        assert.NotNil(t, service, "DuplicateDetectionService should be created successfully")
}</span>

func TestDuplicateDetectionService_DetectDuplicates(t *testing.T) <span class="cov0" title="0">{
        db, _ := sql.Open("sqlite3", ":memory:")
        logger := zap.NewNop()
        
        // Create cache service first
        cacheService := services.NewCacheService(db, logger)
        
        service := services.NewDuplicateDetectionService(db, logger, cacheService)
        
        // Test duplicate detection request
        req := &amp;services.DuplicateDetectionRequest{
                MediaTypes:       []services.MediaType{services.MediaTypeVideo},
                MinSimilarity:    0.8,
                DetectionMethods: []string{"hash", "metadata"},
                IncludeExisting:  false,
                BatchSize:        100,
                UserID:          1,
        }
        
        // This should not crash, though may not find duplicates without data
        groups, err := service.DetectDuplicates(nil, req)
        assert.NoError(t, err, "DetectDuplicates should not error")
        assert.NotNil(t, groups, "Should return groups array")
}</pre>
		
		<pre class="file" id="file76" style="display: none">package tests

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/http/httptest"
        "strings"
        "time"

        "go.uber.org/zap"
)

// Comprehensive mock servers for media recognition APIs
type MediaRecognitionMockServers struct {
        logger            *zap.Logger
        tmdbServer        *httptest.Server
        omdbServer        *httptest.Server
        lastfmServer      *httptest.Server
        musicbrainzServer *httptest.Server
        acoustidServer    *httptest.Server
        igdbServer        *httptest.Server
        steamServer       *httptest.Server
        githubServer      *httptest.Server
        googlebooksServer *httptest.Server
        openlibraryServer *httptest.Server
        crossrefServer    *httptest.Server
        ocrServer         *httptest.Server
        wingetServer      *httptest.Server
        flatpakServer     *httptest.Server
        snapcraftServer   *httptest.Server
        homebrewServer    *httptest.Server

        // Request logging
        requestLogs []RequestLog
}

type RequestLog struct {
        Timestamp  time.Time         `json:"timestamp"`
        Method     string            `json:"method"`
        URL        string            `json:"url"`
        Headers    map[string]string `json:"headers"`
        Body       string            `json:"body"`
        Response   string            `json:"response"`
        StatusCode int               `json:"status_code"`
        ServerType string            `json:"server_type"`
}

func NewMediaRecognitionMockServers(logger *zap.Logger) *MediaRecognitionMockServers <span class="cov0" title="0">{
        m := &amp;MediaRecognitionMockServers{
                logger:      logger,
                requestLogs: make([]RequestLog, 0),
        }

        m.setupTMDbServer()
        m.setupOMDbServer()
        m.setupLastFMServer()
        m.setupMusicBrainzServer()
        m.setupAcoustIDServer()
        m.setupIGDBServer()
        m.setupSteamServer()
        m.setupGitHubServer()
        m.setupGoogleBooksServer()
        m.setupOpenLibraryServer()
        m.setupCrossrefServer()
        m.setupOCRServer()
        m.setupWingetServer()
        m.setupFlatpakServer()
        m.setupSnapcraftServer()
        m.setupHomebrewServer()

        return m
}</span>

// TMDb Mock Server
func (m *MediaRecognitionMockServers) setupTMDbServer() <span class="cov0" title="0">{
        m.tmdbServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "tmdb")

                path := r.URL.Path
                query := r.URL.Query().Get("query")

                if strings.Contains(path, "/search/multi") </span><span class="cov0" title="0">{
                        m.handleTMDbSearch(w, r, query)
                }</span> else<span class="cov0" title="0"> if strings.Contains(path, "/movie/") </span><span class="cov0" title="0">{
                        m.handleTMDbMovieDetails(w, r)
                }</span> else<span class="cov0" title="0"> if strings.Contains(path, "/tv/") </span><span class="cov0" title="0">{
                        m.handleTMDbTVDetails(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Not found", http.StatusNotFound)
                }</span>
        }))
}

func (m *MediaRecognitionMockServers) handleTMDbSearch(w http.ResponseWriter, r *http.Request, query string) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "page":          1,
                "total_pages":   1,
                "total_results": 1,
                "results": []map[string]interface{}{
                        {
                                "id":                12345,
                                "title":             fmt.Sprintf("Mock Movie: %s", query),
                                "name":              fmt.Sprintf("Mock TV Show: %s", query),
                                "media_type":        "movie",
                                "overview":          "This is a mock movie/TV show for testing purposes.",
                                "release_date":      "2023-01-01",
                                "first_air_date":    "2023-01-01",
                                "genre_ids":         []int{28, 12, 878},
                                "vote_average":      8.5,
                                "vote_count":        1500,
                                "poster_path":       "/mock_poster.jpg",
                                "backdrop_path":     "/mock_backdrop.jpg",
                                "popularity":        95.5,
                                "adult":             false,
                                "original_language": "en",
                        },
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

func (m *MediaRecognitionMockServers) handleTMDbMovieDetails(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "id":             12345,
                "title":          "Mock Movie Details",
                "original_title": "Mock Movie Details",
                "overview":       "Detailed mock movie information for testing.",
                "release_date":   "2023-01-01",
                "runtime":        125,
                "vote_average":   8.5,
                "vote_count":     1500,
                "poster_path":    "/mock_poster.jpg",
                "backdrop_path":  "/mock_backdrop.jpg",
                "imdb_id":        "tt1234567",
                "budget":         150000000,
                "revenue":        500000000,
                "status":         "Released",
                "tagline":        "The ultimate mock movie experience",
                "genres": []map[string]interface{}{
                        {"id": 28, "name": "Action"},
                        {"id": 12, "name": "Adventure"},
                        {"id": 878, "name": "Science Fiction"},
                },
                "production_companies": []map[string]interface{}{
                        {
                                "id":             1,
                                "name":           "Mock Studios",
                                "logo_path":      "/mock_logo.png",
                                "origin_country": "US",
                        },
                },
                "production_countries": []map[string]interface{}{
                        {"iso_3166_1": "US", "name": "United States of America"},
                },
                "spoken_languages": []map[string]interface{}{
                        {"iso_639_1": "en", "name": "English", "english_name": "English"},
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

func (m *MediaRecognitionMockServers) handleTMDbTVDetails(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "id":                 12345,
                "name":               "Mock TV Series",
                "original_name":      "Mock TV Series",
                "overview":           "Detailed mock TV series information for testing.",
                "first_air_date":     "2023-01-01",
                "last_air_date":      "2023-12-31",
                "vote_average":       8.7,
                "vote_count":         2000,
                "poster_path":        "/mock_tv_poster.jpg",
                "backdrop_path":      "/mock_tv_backdrop.jpg",
                "number_of_episodes": 24,
                "number_of_seasons":  2,
                "status":             "Ended",
                "type":               "Scripted",
                "external_ids": map[string]interface{}{
                        "imdb_id": "tt7654321",
                        "tvdb_id": 98765,
                },
                "genres": []map[string]interface{}{
                        {"id": 18, "name": "Drama"},
                        {"id": 80, "name": "Crime"},
                },
                "created_by": []map[string]interface{}{
                        {
                                "id":           1,
                                "name":         "Mock Creator",
                                "profile_path": "/mock_creator.jpg",
                        },
                },
                "networks": []map[string]interface{}{
                        {
                                "id":             1,
                                "name":           "Mock Network",
                                "logo_path":      "/mock_network.png",
                                "origin_country": "US",
                        },
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

// OMDb Mock Server
func (m *MediaRecognitionMockServers) setupOMDbServer() <span class="cov0" title="0">{
        m.omdbServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "omdb")

                title := r.URL.Query().Get("t")
                if title == "" </span><span class="cov0" title="0">{
                        title = "Mock Title"
                }</span>

                <span class="cov0" title="0">response := map[string]interface{}{
                        "Title":    title,
                        "Year":     "2023",
                        "Rated":    "PG-13",
                        "Released": "01 Jan 2023",
                        "Runtime":  "125 min",
                        "Genre":    "Action, Adventure, Sci-Fi",
                        "Director": "Mock Director",
                        "Writer":   "Mock Writer",
                        "Actors":   "Mock Actor 1, Mock Actor 2, Mock Actor 3",
                        "Plot":     "A comprehensive mock plot for testing purposes.",
                        "Language": "English",
                        "Country":  "USA",
                        "Awards":   "Won 2 Oscars. Another 15 wins &amp; 30 nominations.",
                        "Poster":   "https://example.com/mock_poster.jpg",
                        "Ratings": []map[string]string{
                                {"Source": "Internet Movie Database", "Value": "8.5/10"},
                                {"Source": "Rotten Tomatoes", "Value": "85%"},
                                {"Source": "Metacritic", "Value": "78/100"},
                        },
                        "Metascore":  "78",
                        "imdbRating": "8.5",
                        "imdbVotes":  "150,000",
                        "imdbID":     "tt1234567",
                        "Type":       "movie",
                        "DVD":        "01 Jun 2023",
                        "BoxOffice":  "$500,000,000",
                        "Production": "Mock Studios",
                        "Website":    "https://example.com/mock-movie",
                        "Response":   "True",
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)</span>
        }))
}

// Last.fm Mock Server
func (m *MediaRecognitionMockServers) setupLastFMServer() <span class="cov0" title="0">{
        m.lastfmServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "lastfm")

                method := r.URL.Query().Get("method")
                track := r.URL.Query().Get("track")
                artist := r.URL.Query().Get("artist")

                if method == "track.search" </span><span class="cov0" title="0">{
                        m.handleLastFMTrackSearch(w, r, track)
                }</span> else<span class="cov0" title="0"> if method == "track.getInfo" </span><span class="cov0" title="0">{
                        m.handleLastFMTrackInfo(w, r, track, artist)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method not supported", http.StatusBadRequest)
                }</span>
        }))
}

func (m *MediaRecognitionMockServers) handleLastFMTrackSearch(w http.ResponseWriter, r *http.Request, track string) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "results": map[string]interface{}{
                        "trackmatches": map[string]interface{}{
                                "track": []map[string]interface{}{
                                        {
                                                "name":       fmt.Sprintf("Mock Track: %s", track),
                                                "artist":     "Mock Artist",
                                                "url":        "https://last.fm/music/mock-artist/mock-track",
                                                "streamable": "1",
                                                "listeners":  "50000",
                                                "mbid":       "mock-mbid-12345",
                                                "image": []map[string]string{
                                                        {"#text": "https://example.com/mock_small.jpg", "size": "small"},
                                                        {"#text": "https://example.com/mock_medium.jpg", "size": "medium"},
                                                        {"#text": "https://example.com/mock_large.jpg", "size": "large"},
                                                },
                                        },
                                },
                        },
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

func (m *MediaRecognitionMockServers) handleLastFMTrackInfo(w http.ResponseWriter, r *http.Request, track, artist string) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "track": map[string]interface{}{
                        "name":      track,
                        "mbid":      "mock-mbid-12345",
                        "url":       "https://last.fm/music/mock-artist/mock-track",
                        "duration":  "240000",
                        "listeners": "50000",
                        "playcount": "500000",
                        "streamable": map[string]string{
                                "#text":     "1",
                                "fulltrack": "0",
                        },
                        "artist": map[string]string{
                                "name": artist,
                                "mbid": "mock-artist-mbid",
                                "url":  "https://last.fm/music/mock-artist",
                        },
                        "album": map[string]interface{}{
                                "artist": artist,
                                "title":  "Mock Album",
                                "mbid":   "mock-album-mbid",
                                "url":    "https://last.fm/music/mock-artist/mock-album",
                                "image": []map[string]string{
                                        {"#text": "https://example.com/mock_album_small.jpg", "size": "small"},
                                        {"#text": "https://example.com/mock_album_medium.jpg", "size": "medium"},
                                        {"#text": "https://example.com/mock_album_large.jpg", "size": "large"},
                                },
                        },
                        "toptags": map[string]interface{}{
                                "tag": []map[string]string{
                                        {"name": "rock", "url": "https://last.fm/tag/rock"},
                                        {"name": "alternative", "url": "https://last.fm/tag/alternative"},
                                        {"name": "indie", "url": "https://last.fm/tag/indie"},
                                },
                        },
                        "wiki": map[string]string{
                                "published": "01 Jan 2023, 12:00",
                                "summary":   "This is a mock track summary for testing purposes.",
                                "content":   "Extended mock content about this track with detailed information for testing.",
                        },
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

// MusicBrainz Mock Server
func (m *MediaRecognitionMockServers) setupMusicBrainzServer() <span class="cov0" title="0">{
        m.musicbrainzServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "musicbrainz")

                path := r.URL.Path
                if strings.Contains(path, "/recording") </span><span class="cov0" title="0">{
                        m.handleMusicBrainzRecordingSearch(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Not found", http.StatusNotFound)
                }</span>
        }))
}

func (m *MediaRecognitionMockServers) handleMusicBrainzRecordingSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "recordings": []map[string]interface{}{
                        {
                                "id":             "mock-recording-id-12345",
                                "score":          95,
                                "title":          "Mock Recording Title",
                                "length":         240000,
                                "disambiguation": "",
                                "artist-credit": []map[string]interface{}{
                                        {
                                                "name": "Mock Artist",
                                                "artist": map[string]interface{}{
                                                        "id":        "mock-artist-id",
                                                        "name":      "Mock Artist",
                                                        "sort-name": "Artist, Mock",
                                                        "type":      "Person",
                                                },
                                        },
                                },
                                "releases": []map[string]interface{}{
                                        {
                                                "id":      "mock-release-id",
                                                "title":   "Mock Album",
                                                "status":  "Official",
                                                "date":    "2023",
                                                "country": "US",
                                        },
                                },
                                "tags": []map[string]interface{}{
                                        {"count": 5, "name": "rock"},
                                        {"count": 3, "name": "alternative"},
                                },
                                "genres": []map[string]interface{}{
                                        {"count": 8, "name": "rock"},
                                        {"count": 4, "name": "pop"},
                                },
                                "isrcs": []string{"USMOCK2300001"},
                        },
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

// AcoustID Mock Server
func (m *MediaRecognitionMockServers) setupAcoustIDServer() <span class="cov0" title="0">{
        m.acoustidServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "acoustid")

                r.ParseForm()
                fingerprint := r.Form.Get("fingerprint")

                if fingerprint == "" </span><span class="cov0" title="0">{
                        http.Error(w, "Fingerprint required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">response := map[string]interface{}{
                        "status": "ok",
                        "results": []map[string]interface{}{
                                {
                                        "id":    "mock-acoustid-" + fingerprint[:8],
                                        "score": 0.95,
                                        "recordings": []map[string]interface{}{
                                                {
                                                        "id":       "mock-recording-id-12345",
                                                        "title":    "Mock Track from Fingerprint",
                                                        "duration": 240.5,
                                                        "artists": []map[string]interface{}{
                                                                {
                                                                        "id":   "mock-artist-id",
                                                                        "name": "Mock Artist",
                                                                },
                                                        },
                                                        "releases": []map[string]interface{}{
                                                                {
                                                                        "id":      "mock-release-id",
                                                                        "title":   "Mock Album",
                                                                        "date":    "2023",
                                                                        "country": "US",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)</span>
        }))
}

// IGDB Mock Server
func (m *MediaRecognitionMockServers) setupIGDBServer() <span class="cov0" title="0">{
        m.igdbServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "igdb")

                if r.Method != "POST" </span><span class="cov0" title="0">{
                        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                        return
                }</span>

                <span class="cov0" title="0">response := []map[string]interface{}{
                        {
                                "id":                 12345,
                                "name":               "Mock Game Title",
                                "summary":            "This is a comprehensive mock game for testing purposes with detailed gameplay mechanics.",
                                "storyline":          "An epic storyline that spans across multiple dimensions and realities.",
                                "first_release_date": 1672531200, // Unix timestamp for 2023-01-01
                                "category":           0,
                                "status":             6,
                                "rating":             85.5,
                                "rating_count":       1500,
                                "aggregated_rating":  88.2,
                                "total_rating":       86.8,
                                "popularity":         95.7,
                                "cover": map[string]interface{}{
                                        "id":       1,
                                        "url":      "//images.igdb.com/igdb/image/upload/t_cover_big/mock_cover.jpg",
                                        "image_id": "mock_cover",
                                        "width":    264,
                                        "height":   374,
                                },
                                "screenshots": []map[string]interface{}{
                                        {
                                                "id":       1,
                                                "url":      "//images.igdb.com/igdb/image/upload/t_screenshot_med/mock_screenshot1.jpg",
                                                "image_id": "mock_screenshot1",
                                                "width":    1920,
                                                "height":   1080,
                                        },
                                },
                                "genres": []map[string]interface{}{
                                        {"id": 12, "name": "Role-playing (RPG)", "slug": "role-playing-rpg"},
                                        {"id": 31, "name": "Adventure", "slug": "adventure"},
                                },
                                "themes": []map[string]interface{}{
                                        {"id": 1, "name": "Action", "slug": "action"},
                                        {"id": 17, "name": "Fantasy", "slug": "fantasy"},
                                },
                                "platforms": []map[string]interface{}{
                                        {
                                                "id":           6,
                                                "name":         "PC (Microsoft Windows)",
                                                "abbreviation": "PC",
                                                "category":     4,
                                                "generation":   8,
                                        },
                                        {
                                                "id":           48,
                                                "name":         "PlayStation 4",
                                                "abbreviation": "PS4",
                                                "category":     1,
                                                "generation":   8,
                                        },
                                },
                                "involved_companies": []map[string]interface{}{
                                        {
                                                "id":        1,
                                                "developer": true,
                                                "publisher": false,
                                                "company": map[string]interface{}{
                                                        "id":   1,
                                                        "name": "Mock Game Studios",
                                                        "slug": "mock-game-studios",
                                                },
                                        },
                                        {
                                                "id":        2,
                                                "developer": false,
                                                "publisher": true,
                                                "company": map[string]interface{}{
                                                        "id":   2,
                                                        "name": "Mock Publishers",
                                                        "slug": "mock-publishers",
                                                },
                                        },
                                },
                                "external_games": []map[string]interface{}{
                                        {
                                                "id":       1,
                                                "category": 1, // Steam
                                                "uid":      "12345",
                                                "url":      "https://store.steampowered.com/app/12345/",
                                        },
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)</span>
        }))
}

// GitHub Mock Server
func (m *MediaRecognitionMockServers) setupGitHubServer() <span class="cov0" title="0">{
        m.githubServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "github")

                path := r.URL.Path
                if strings.Contains(path, "/search/repositories") </span><span class="cov0" title="0">{
                        m.handleGitHubRepositorySearch(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Not found", http.StatusNotFound)
                }</span>
        }))
}

func (m *MediaRecognitionMockServers) handleGitHubRepositorySearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query().Get("q")

        response := map[string]interface{}{
                "total_count":        1,
                "incomplete_results": false,
                "items": []map[string]interface{}{
                        {
                                "id":               12345,
                                "name":             fmt.Sprintf("mock-%s", strings.ReplaceAll(query, " ", "-")),
                                "full_name":        fmt.Sprintf("mockuser/mock-%s", strings.ReplaceAll(query, " ", "-")),
                                "description":      fmt.Sprintf("Mock repository for %s - comprehensive testing implementation", query),
                                "html_url":         fmt.Sprintf("https://github.com/mockuser/mock-%s", strings.ReplaceAll(query, " ", "-")),
                                "stargazers_count": 1250,
                                "forks_count":      234,
                                "language":         "Go",
                                "license": map[string]interface{}{
                                        "key":     "mit",
                                        "name":    "MIT License",
                                        "spdx_id": "MIT",
                                },
                                "owner": map[string]interface{}{
                                        "login":      "mockuser",
                                        "id":         67890,
                                        "avatar_url": "https://avatars.githubusercontent.com/u/67890?v=4",
                                        "type":       "User",
                                },
                                "created_at":     "2020-01-01T00:00:00Z",
                                "updated_at":     "2023-12-01T00:00:00Z",
                                "pushed_at":      "2023-12-01T00:00:00Z",
                                "default_branch": "main",
                                "topics":         []string{"mock", "testing", "api", "software"},
                        },
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

// Google Books Mock Server
func (m *MediaRecognitionMockServers) setupGoogleBooksServer() <span class="cov0" title="0">{
        m.googlebooksServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "googlebooks")

                query := r.URL.Query().Get("q")

                response := map[string]interface{}{
                        "kind":       "books#volumes",
                        "totalItems": 1,
                        "items": []map[string]interface{}{
                                {
                                        "kind":     "books#volume",
                                        "id":       "mock-book-id-12345",
                                        "etag":     "mock-etag",
                                        "selfLink": "https://www.googleapis.com/books/v1/volumes/mock-book-id-12345",
                                        "volumeInfo": map[string]interface{}{
                                                "title":         fmt.Sprintf("Mock Book: %s", query),
                                                "subtitle":      "A Comprehensive Guide to Testing",
                                                "authors":       []string{"Mock Author", "Test Writer"},
                                                "publisher":     "Mock Publishing House",
                                                "publishedDate": "2023-01-01",
                                                "description":   "This is a comprehensive mock book designed for testing purposes. It contains detailed information about various testing methodologies and best practices.",
                                                "industryIdentifiers": []map[string]interface{}{
                                                        {
                                                                "type":       "ISBN_13",
                                                                "identifier": "9781234567890",
                                                        },
                                                        {
                                                                "type":       "ISBN_10",
                                                                "identifier": "1234567890",
                                                        },
                                                },
                                                "readingModes": map[string]bool{
                                                        "text":  true,
                                                        "image": true,
                                                },
                                                "pageCount":      456,
                                                "printType":      "BOOK",
                                                "categories":     []string{"Computers", "Testing", "Software Engineering"},
                                                "averageRating":  4.5,
                                                "ratingsCount":   125,
                                                "maturityRating": "NOT_MATURE",
                                                "imageLinks": map[string]string{
                                                        "smallThumbnail": "https://example.com/mock_book_small.jpg",
                                                        "thumbnail":      "https://example.com/mock_book_medium.jpg",
                                                        "small":          "https://example.com/mock_book_small.jpg",
                                                        "medium":         "https://example.com/mock_book_medium.jpg",
                                                        "large":          "https://example.com/mock_book_large.jpg",
                                                },
                                                "language":            "en",
                                                "previewLink":         "https://books.google.com/books?id=mock-book-id-12345",
                                                "infoLink":            "https://books.google.com/books?id=mock-book-id-12345",
                                                "canonicalVolumeLink": "https://books.google.com/books/about/Mock_Book.html?id=mock-book-id-12345",
                                        },
                                        "saleInfo": map[string]interface{}{
                                                "country":     "US",
                                                "saleability": "FOR_SALE",
                                                "isEbook":     true,
                                                "listPrice": map[string]interface{}{
                                                        "amount":       29.99,
                                                        "currencyCode": "USD",
                                                },
                                                "retailPrice": map[string]interface{}{
                                                        "amount":       24.99,
                                                        "currencyCode": "USD",
                                                },
                                                "buyLink": "https://books.google.com/books?id=mock-book-id-12345&amp;buy",
                                        },
                                        "accessInfo": map[string]interface{}{
                                                "country":                "US",
                                                "viewability":            "PARTIAL",
                                                "embeddable":             true,
                                                "publicDomain":           false,
                                                "textToSpeechPermission": "ALLOWED",
                                                "epub": map[string]interface{}{
                                                        "isAvailable": true,
                                                },
                                                "pdf": map[string]interface{}{
                                                        "isAvailable": true,
                                                },
                                                "webReaderLink":       "https://books.google.com/books/reader?id=mock-book-id-12345",
                                                "accessViewStatus":    "SAMPLE",
                                                "quoteSharingAllowed": true,
                                        },
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

// Open Library Mock Server
func (m *MediaRecognitionMockServers) setupOpenLibraryServer() <span class="cov0" title="0">{
        m.openlibraryServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "openlibrary")

                query := r.URL.Query().Get("q")

                response := map[string]interface{}{
                        "numFound":      1,
                        "start":         0,
                        "numFoundExact": true,
                        "docs": []map[string]interface{}{
                                {
                                        "key":                    "/works/OL12345W",
                                        "type":                   "work",
                                        "title":                  fmt.Sprintf("Mock Open Library Book: %s", query),
                                        "title_suggest":          fmt.Sprintf("Mock Open Library Book: %s", query),
                                        "subtitle":               "An Open Source Testing Guide",
                                        "author_name":            []string{"Mock Author", "Open Contributor"},
                                        "author_key":             []string{"/authors/OL123A", "/authors/OL456A"},
                                        "publisher":              []string{"Open Source Press", "Community Publishers"},
                                        "publish_date":           []string{"2023", "January 2023"},
                                        "publish_year":           []int{2023},
                                        "first_publish_year":     2023,
                                        "number_of_pages_median": 340,
                                        "edition_count":          3,
                                        "edition_key":            []string{"/books/OL123M", "/books/OL456M", "/books/OL789M"},
                                        "isbn":                   []string{"9780987654321", "0987654321"},
                                        "lccn":                   []string{"2023123456"},
                                        "oclc":                   []string{"1234567890"},
                                        "subject":                []string{"Testing", "Software Development", "Open Source", "Programming"},
                                        "place":                  []string{"San Francisco", "California"},
                                        "person":                 []string{"Linus Torvalds", "Richard Stallman"},
                                        "language":               []string{"eng"},
                                        "id_goodreads":           []string{"12345678"},
                                        "id_librarything":        []string{"987654"},
                                        "cover_i":                98765,
                                        "cover_edition_key":      "/books/OL123M",
                                        "first_sentence":         []string{"This comprehensive guide introduces the fundamentals of testing in open source environments."},
                                        "ebook_count_i":          2,
                                        "ebook_access":           "borrowable",
                                        "has_fulltext":           true,
                                        "public_scan_b":          true,
                                        "last_modified_i":        time.Now().Unix(),
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

// Crossref Mock Server
func (m *MediaRecognitionMockServers) setupCrossrefServer() <span class="cov0" title="0">{
        m.crossrefServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "crossref")

                query := r.URL.Query().Get("query")

                response := map[string]interface{}{
                        "status": "ok",
                        "message": map[string]interface{}{
                                "total-results":  1,
                                "items-per-page": 20,
                                "items": []map[string]interface{}{
                                        {
                                                "indexed": map[string]interface{}{
                                                        "date-parts": [][]int{{2023, 1, 15}},
                                                        "date-time":  "2023-01-15T10:30:00Z",
                                                        "timestamp":  1673779800000,
                                                },
                                                "reference-count": 25,
                                                "publisher":       "Mock Academic Press",
                                                "issue":           "1",
                                                "content-domain": map[string]interface{}{
                                                        "domain":                []string{"mockacademic.org"},
                                                        "crossmark-restriction": false,
                                                },
                                                "published": map[string]interface{}{
                                                        "date-parts": [][]int{{2023, 1, 1}},
                                                },
                                                "abstract": fmt.Sprintf("This is a comprehensive academic paper about %s, providing detailed analysis and research findings.", query),
                                                "DOI":      "10.1000/mock-doi-12345",
                                                "type":     "journal-article",
                                                "created": map[string]interface{}{
                                                        "date-parts": [][]int{{2023, 1, 1}},
                                                        "date-time":  "2023-01-01T00:00:00Z",
                                                        "timestamp":  1672531200000,
                                                },
                                                "page":                   "1-25",
                                                "source":                 "Crossref",
                                                "is-referenced-by-count": 15,
                                                "title":                  []string{fmt.Sprintf("Mock Academic Paper: %s", query)},
                                                "prefix":                 "10.1000",
                                                "volume":                 "45",
                                                "author": []map[string]interface{}{
                                                        {
                                                                "given":    "John",
                                                                "family":   "MockResearcher",
                                                                "sequence": "first",
                                                                "affiliation": []map[string]interface{}{
                                                                        {"name": "Mock University, Department of Computer Science"},
                                                                },
                                                        },
                                                        {
                                                                "given":    "Jane",
                                                                "family":   "TestScientist",
                                                                "sequence": "additional",
                                                                "affiliation": []map[string]interface{}{
                                                                        {"name": "Research Institute of Technology"},
                                                                },
                                                        },
                                                },
                                                "member":          "1000",
                                                "container-title": []string{"Journal of Mock Research"},
                                                "language":        "en",
                                                "deposited": map[string]interface{}{
                                                        "date-parts": [][]int{{2023, 1, 15}},
                                                        "date-time":  "2023-01-15T10:30:00Z",
                                                        "timestamp":  1673779800000,
                                                },
                                                "score": 95.5,
                                                "issued": map[string]interface{}{
                                                        "date-parts": [][]int{{2023, 1, 1}},
                                                },
                                                "references-count": 25,
                                                "URL":              "https://mockacademic.org/articles/mock-doi-12345",
                                                "ISSN":             []string{"1234-5678", "9876-5432"},
                                                "subject":          []string{"Computer Science", "Software Engineering", "Testing"},
                                        },
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

// OCR Mock Server
func (m *MediaRecognitionMockServers) setupOCRServer() <span class="cov0" title="0">{
        m.ocrServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "ocr")

                response := map[string]interface{}{
                        "ParsedResults": []map[string]interface{}{
                                {
                                        "TextOverlay": map[string]interface{}{
                                                "Lines": []map[string]interface{}{
                                                        {
                                                                "LineText": "Mock Book Title",
                                                                "Words": []map[string]interface{}{
                                                                        {
                                                                                "WordText": "Mock",
                                                                                "Left":     50,
                                                                                "Top":      100,
                                                                                "Height":   30,
                                                                                "Width":    80,
                                                                        },
                                                                        {
                                                                                "WordText": "Book",
                                                                                "Left":     140,
                                                                                "Top":      100,
                                                                                "Height":   30,
                                                                                "Width":    80,
                                                                        },
                                                                        {
                                                                                "WordText": "Title",
                                                                                "Left":     230,
                                                                                "Top":      100,
                                                                                "Height":   30,
                                                                                "Width":    80,
                                                                        },
                                                                },
                                                        },
                                                        {
                                                                "LineText": "By Mock Author",
                                                                "Words": []map[string]interface{}{
                                                                        {
                                                                                "WordText": "By",
                                                                                "Left":     50,
                                                                                "Top":      150,
                                                                                "Height":   25,
                                                                                "Width":    30,
                                                                        },
                                                                        {
                                                                                "WordText": "Mock",
                                                                                "Left":     90,
                                                                                "Top":      150,
                                                                                "Height":   25,
                                                                                "Width":    60,
                                                                        },
                                                                        {
                                                                                "WordText": "Author",
                                                                                "Left":     160,
                                                                                "Top":      150,
                                                                                "Height":   25,
                                                                                "Width":    80,
                                                                        },
                                                                },
                                                        },
                                                        {
                                                                "LineText": "ISBN: 978-1234567890",
                                                                "Words": []map[string]interface{}{
                                                                        {
                                                                                "WordText": "ISBN:",
                                                                                "Left":     50,
                                                                                "Top":      200,
                                                                                "Height":   20,
                                                                                "Width":    50,
                                                                        },
                                                                        {
                                                                                "WordText": "978-1234567890",
                                                                                "Left":     110,
                                                                                "Top":      200,
                                                                                "Height":   20,
                                                                                "Width":    150,
                                                                        },
                                                                },
                                                        },
                                                },
                                                "HasOverlay": true,
                                                "Message":    "Total lines: 3",
                                        },
                                        "FileParseExitCode": 1,
                                        "ParsedText":        "Mock Book Title\nBy Mock Author\nISBN: 978-1234567890\n\nThis is sample text content from a book page that has been processed through OCR. The text includes chapter headings, author information, and ISBN details that can be extracted for book recognition purposes.",
                                        "ErrorMessage":      "",
                                        "ErrorDetails":      "",
                                },
                        },
                        "OCRExitCode":                  1,
                        "IsErroredOnProcessing":        false,
                        "ProcessingTimeInMilliseconds": "1250",
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

// Package manager mock servers
func (m *MediaRecognitionMockServers) setupWingetServer() <span class="cov0" title="0">{
        m.wingetServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "winget")

                query := r.URL.Query().Get("query")

                response := []map[string]interface{}{
                        {
                                "PackageIdentifier": "MockSoftware.TestApp",
                                "PackageName":       fmt.Sprintf("Mock %s", query),
                                "PackageVersion":    "1.2.3",
                                "Publisher":         "Mock Software Inc.",
                                "Description":       fmt.Sprintf("A comprehensive mock application for %s testing purposes.", query),
                                "License":           "MIT",
                                "Tags":              []string{"mock", "testing", "software"},
                                "Homepage":          "https://mocksoft.com/testapp",
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

func (m *MediaRecognitionMockServers) setupFlatpakServer() <span class="cov0" title="0">{
        m.flatpakServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "flatpak")

                query := r.URL.Query().Get("q")

                response := []map[string]interface{}{
                        {
                                "flatpakAppId":   "org.mocksoft.TestApp",
                                "name":           fmt.Sprintf("Mock %s", query),
                                "summary":        fmt.Sprintf("Mock application for %s testing", query),
                                "description":    fmt.Sprintf("A comprehensive Flatpak application designed for testing %s functionality.", query),
                                "developerName":  "Mock Software Foundation",
                                "projectLicense": "GPL-3.0+",
                                "categories":     []string{"Development", "Education"},
                                "screenshots": []string{
                                        "https://example.com/mock_screenshot1.png",
                                        "https://example.com/mock_screenshot2.png",
                                },
                                "iconDesktopUrl":        "https://example.com/mock_icon.png",
                                "downloadFlatpakRefUrl": "https://dl.flathub.org/repo/appstream/org.mocksoft.TestApp.flatpakref",
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

func (m *MediaRecognitionMockServers) setupSnapcraftServer() <span class="cov0" title="0">{
        m.snapcraftServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "snapcraft")

                query := r.URL.Query().Get("q")

                response := map[string]interface{}{
                        "_embedded": []map[string]interface{}{
                                {
                                        "name":        fmt.Sprintf("mock-%s", strings.ReplaceAll(strings.ToLower(query), " ", "-")),
                                        "title":       fmt.Sprintf("Mock %s", query),
                                        "summary":     fmt.Sprintf("A mock snap package for %s testing", query),
                                        "description": fmt.Sprintf("Comprehensive snap package designed for testing %s functionality with all necessary components.", query),
                                        "publisher": map[string]interface{}{
                                                "display-name": "Mock Software Publishers",
                                                "username":     "mockpublisher",
                                                "validation":   "verified",
                                        },
                                        "license":     "MIT",
                                        "version":     "1.2.3",
                                        "revision":    42,
                                        "confinement": "strict",
                                        "grade":       "stable",
                                        "categories": []map[string]interface{}{
                                                {"name": "development"},
                                                {"name": "education"},
                                        },
                                        "screenshots": []string{
                                                "https://example.com/snap_screenshot1.png",
                                                "https://example.com/snap_screenshot2.png",
                                        },
                                        "media": []map[string]interface{}{
                                                {
                                                        "type": "icon",
                                                        "url":  "https://example.com/snap_icon.png",
                                                },
                                        },
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

func (m *MediaRecognitionMockServers) setupHomebrewServer() <span class="cov0" title="0">{
        m.homebrewServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "homebrew")

                // Extract formula name from path
                pathParts := strings.Split(r.URL.Path, "/")
                formulaName := "mock-formula"
                if len(pathParts) &gt; 3 </span><span class="cov0" title="0">{
                        formulaName = strings.TrimSuffix(pathParts[len(pathParts)-1], ".json")
                }</span>

                <span class="cov0" title="0">response := map[string]interface{}{
                        "name":               formulaName,
                        "full_name":          fmt.Sprintf("mock/%s", formulaName),
                        "tap":                "homebrew/core",
                        "oldname":            nil,
                        "aliases":            []string{},
                        "versioned_formulae": []string{},
                        "desc":               fmt.Sprintf("Mock Homebrew formula for %s testing purposes", formulaName),
                        "license":            "MIT",
                        "homepage":           "https://mocksoft.com/homebrew-formula",
                        "versions": map[string]interface{}{
                                "stable": "1.2.3",
                                "head":   "HEAD",
                                "bottle": true,
                        },
                        "urls": map[string]interface{}{
                                "stable": map[string]interface{}{
                                        "url":      fmt.Sprintf("https://github.com/mocksoft/%s/archive/v1.2.3.tar.gz", formulaName),
                                        "tag":      "v1.2.3",
                                        "revision": "abc123def456",
                                },
                        },
                        "revision":       0,
                        "version_scheme": 0,
                        "bottle": map[string]interface{}{
                                "stable": map[string]interface{}{
                                        "rebuild":  0,
                                        "root_url": "https://homebrew.bintray.com/bottles",
                                        "files": map[string]interface{}{
                                                "monterey": map[string]interface{}{
                                                        "cellar": "/usr/local/Cellar",
                                                        "url":    fmt.Sprintf("https://homebrew.bintray.com/bottles/%s-1.2.3.monterey.bottle.tar.gz", formulaName),
                                                        "sha256": "mock_sha256_hash_for_monterey_bottle",
                                                },
                                                "big_sur": map[string]interface{}{
                                                        "cellar": "/usr/local/Cellar",
                                                        "url":    fmt.Sprintf("https://homebrew.bintray.com/bottles/%s-1.2.3.big_sur.bottle.tar.gz", formulaName),
                                                        "sha256": "mock_sha256_hash_for_big_sur_bottle",
                                                },
                                        },
                                },
                        },
                        "dependencies":             []string{"mock-dependency-1", "mock-dependency-2"},
                        "test_dependencies":        []string{"mock-test-dep"},
                        "recommended_dependencies": []string{},
                        "optional_dependencies":    []string{},
                        "build_dependencies":       []string{"cmake", "pkg-config"},
                        "conflicts_with":           []string{},
                        "caveats":                  nil,
                        "installed":                []string{},
                        "linked_keg":               nil,
                        "pinned":                   false,
                        "outdated":                 false,
                        "deprecated":               false,
                        "deprecation_date":         nil,
                        "deprecation_reason":       nil,
                        "disabled":                 false,
                        "disable_date":             nil,
                        "disable_reason":           nil,
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)</span>
        }))
}

// Steam Mock Server
func (m *MediaRecognitionMockServers) setupSteamServer() <span class="cov0" title="0">{
        m.steamServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                m.logRequest(r, "steam")

                // Mock Steam app details
                response := map[string]interface{}{
                        "12345": map[string]interface{}{
                                "success": true,
                                "data": map[string]interface{}{
                                        "type":                 "game",
                                        "name":                 "Mock Steam Game",
                                        "steam_appid":          12345,
                                        "required_age":         0,
                                        "is_free":              false,
                                        "detailed_description": "A comprehensive mock Steam game for testing purposes with detailed gameplay mechanics and storyline.",
                                        "about_the_game":       "Experience the ultimate mock gaming adventure with cutting-edge graphics and immersive gameplay.",
                                        "short_description":    "The definitive mock game experience.",
                                        "supported_languages":  "English&lt;strong&gt;*&lt;/strong&gt;, French, German, Spanish&lt;br&gt;&lt;strong&gt;*&lt;/strong&gt;languages with full audio support",
                                        "header_image":         "https://cdn.akamai.steamstatic.com/steam/apps/12345/header.jpg",
                                        "website":              "https://mockgame.com",
                                        "pc_requirements": map[string]interface{}{
                                                "minimum":     "&lt;strong&gt;Minimum:&lt;/strong&gt;&lt;br&gt;&lt;ul class=\"bb_ul\"&gt;&lt;li&gt;&lt;strong&gt;OS:&lt;/strong&gt; Windows 10 64-bit&lt;li&gt;&lt;strong&gt;Processor:&lt;/strong&gt; Intel Core i5-8400 / AMD Ryzen 5 2600&lt;li&gt;&lt;strong&gt;Memory:&lt;/strong&gt; 8 GB RAM&lt;li&gt;&lt;strong&gt;Graphics:&lt;/strong&gt; NVIDIA GTX 1060 / AMD RX 580&lt;li&gt;&lt;strong&gt;DirectX:&lt;/strong&gt; Version 12&lt;li&gt;&lt;strong&gt;Storage:&lt;/strong&gt; 50 GB available space&lt;/ul&gt;",
                                                "recommended": "&lt;strong&gt;Recommended:&lt;/strong&gt;&lt;br&gt;&lt;ul class=\"bb_ul\"&gt;&lt;li&gt;&lt;strong&gt;OS:&lt;/strong&gt; Windows 11 64-bit&lt;li&gt;&lt;strong&gt;Processor:&lt;/strong&gt; Intel Core i7-10700K / AMD Ryzen 7 3700X&lt;li&gt;&lt;strong&gt;Memory:&lt;/strong&gt; 16 GB RAM&lt;li&gt;&lt;strong&gt;Graphics:&lt;/strong&gt; NVIDIA RTX 3070 / AMD RX 6700 XT&lt;li&gt;&lt;strong&gt;DirectX:&lt;/strong&gt; Version 12&lt;li&gt;&lt;strong&gt;Storage:&lt;/strong&gt; 50 GB available space (SSD recommended)&lt;/ul&gt;",
                                        },
                                        "developers": []string{"Mock Game Studios"},
                                        "publishers": []string{"Mock Publishers"},
                                        "platforms": map[string]bool{
                                                "windows": true,
                                                "mac":     false,
                                                "linux":   true,
                                        },
                                        "metacritic": map[string]interface{}{
                                                "score": 85,
                                                "url":   "https://www.metacritic.com/game/pc/mock-steam-game",
                                        },
                                        "categories": []map[string]interface{}{
                                                {"id": 2, "description": "Single-player"},
                                                {"id": 1, "description": "Multi-player"},
                                                {"id": 22, "description": "Steam Achievements"},
                                                {"id": 29, "description": "Steam Trading Cards"},
                                        },
                                        "genres": []map[string]interface{}{
                                                {"id": "1", "description": "Action"},
                                                {"id": "25", "description": "Adventure"},
                                                {"id": "23", "description": "Indie"},
                                        },
                                        "screenshots": []map[string]interface{}{
                                                {
                                                        "id":             1,
                                                        "path_thumbnail": "https://cdn.akamai.steamstatic.com/steam/apps/12345/ss_1_thumbnail.jpg",
                                                        "path_full":      "https://cdn.akamai.steamstatic.com/steam/apps/12345/ss_1.jpg",
                                                },
                                        },
                                        "release_date": map[string]interface{}{
                                                "coming_soon": false,
                                                "date":        "Jan 1, 2023",
                                        },
                                },
                        },
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>))
}

// Request logging functionality
func (m *MediaRecognitionMockServers) logRequest(r *http.Request, serverType string) <span class="cov0" title="0">{
        headers := make(map[string]string)
        for name, values := range r.Header </span><span class="cov0" title="0">{
                headers[name] = strings.Join(values, ", ")
        }</span>

        <span class="cov0" title="0">body := ""
        if r.Body != nil </span><span class="cov0" title="0">{
                bodyBytes := make([]byte, r.ContentLength)
                r.Body.Read(bodyBytes)
                body = string(bodyBytes)
        }</span>

        <span class="cov0" title="0">log := RequestLog{
                Timestamp:  time.Now(),
                Method:     r.Method,
                URL:        r.URL.String(),
                Headers:    headers,
                Body:       body,
                ServerType: serverType,
        }

        m.requestLogs = append(m.requestLogs, log)</span>
}

// Get request logs for analysis
func (m *MediaRecognitionMockServers) GetRequestLogs() []RequestLog <span class="cov0" title="0">{
        return m.requestLogs
}</span>

// Clear request logs
func (m *MediaRecognitionMockServers) ClearRequestLogs() <span class="cov0" title="0">{
        m.requestLogs = make([]RequestLog, 0)
}</span>

// Get server URLs for configuration
func (m *MediaRecognitionMockServers) GetURLs() map[string]string <span class="cov0" title="0">{
        return map[string]string{
                "tmdb":        m.tmdbServer.URL,
                "omdb":        m.omdbServer.URL,
                "lastfm":      m.lastfmServer.URL,
                "musicbrainz": m.musicbrainzServer.URL,
                "acoustid":    m.acoustidServer.URL,
                "igdb":        m.igdbServer.URL,
                "steam":       m.steamServer.URL,
                "github":      m.githubServer.URL,
                "googlebooks": m.googlebooksServer.URL,
                "openlibrary": m.openlibraryServer.URL,
                "crossref":    m.crossrefServer.URL,
                "ocr":         m.ocrServer.URL,
                "winget":      m.wingetServer.URL,
                "flatpak":     m.flatpakServer.URL,
                "snapcraft":   m.snapcraftServer.URL,
                "homebrew":    m.homebrewServer.URL,
        }
}</span>

// Close all mock servers
func (m *MediaRecognitionMockServers) Close() <span class="cov0" title="0">{
        if m.tmdbServer != nil </span><span class="cov0" title="0">{
                m.tmdbServer.Close()
        }</span>
        <span class="cov0" title="0">if m.omdbServer != nil </span><span class="cov0" title="0">{
                m.omdbServer.Close()
        }</span>
        <span class="cov0" title="0">if m.lastfmServer != nil </span><span class="cov0" title="0">{
                m.lastfmServer.Close()
        }</span>
        <span class="cov0" title="0">if m.musicbrainzServer != nil </span><span class="cov0" title="0">{
                m.musicbrainzServer.Close()
        }</span>
        <span class="cov0" title="0">if m.acoustidServer != nil </span><span class="cov0" title="0">{
                m.acoustidServer.Close()
        }</span>
        <span class="cov0" title="0">if m.igdbServer != nil </span><span class="cov0" title="0">{
                m.igdbServer.Close()
        }</span>
        <span class="cov0" title="0">if m.steamServer != nil </span><span class="cov0" title="0">{
                m.steamServer.Close()
        }</span>
        <span class="cov0" title="0">if m.githubServer != nil </span><span class="cov0" title="0">{
                m.githubServer.Close()
        }</span>
        <span class="cov0" title="0">if m.googlebooksServer != nil </span><span class="cov0" title="0">{
                m.googlebooksServer.Close()
        }</span>
        <span class="cov0" title="0">if m.openlibraryServer != nil </span><span class="cov0" title="0">{
                m.openlibraryServer.Close()
        }</span>
        <span class="cov0" title="0">if m.crossrefServer != nil </span><span class="cov0" title="0">{
                m.crossrefServer.Close()
        }</span>
        <span class="cov0" title="0">if m.ocrServer != nil </span><span class="cov0" title="0">{
                m.ocrServer.Close()
        }</span>
        <span class="cov0" title="0">if m.wingetServer != nil </span><span class="cov0" title="0">{
                m.wingetServer.Close()
        }</span>
        <span class="cov0" title="0">if m.flatpakServer != nil </span><span class="cov0" title="0">{
                m.flatpakServer.Close()
        }</span>
        <span class="cov0" title="0">if m.snapcraftServer != nil </span><span class="cov0" title="0">{
                m.snapcraftServer.Close()
        }</span>
        <span class="cov0" title="0">if m.homebrewServer != nil </span><span class="cov0" title="0">{
                m.homebrewServer.Close()
        }</span>
}

// Helper function to simulate network delays for realistic testing
func (m *MediaRecognitionMockServers) simulateNetworkDelay() <span class="cov0" title="0">{
        // Simulate 50-200ms network delay
        delay := time.Duration(50+time.Now().UnixNano()%150) * time.Millisecond
        time.Sleep(delay)
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package tests

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/http/httptest"
        "strings"
        "time"

        "github.com/gorilla/mux"
)

type MockServer struct {
        Server        *httptest.Server
        RequestLog    []MockRequest
        ResponseDelay time.Duration
}

type MockRequest struct {
        Method    string              `json:"method"`
        URL       string              `json:"url"`
        Headers   map[string]string   `json:"headers"`
        Body      string              `json:"body"`
        Timestamp time.Time           `json:"timestamp"`
        Query     map[string][]string `json:"query"`
}

type MockResponse struct {
        StatusCode int               `json:"status_code"`
        Headers    map[string]string `json:"headers"`
        Body       interface{}       `json:"body"`
        Delay      time.Duration     `json:"delay"`
}

func NewMockServer() *MockServer <span class="cov0" title="0">{
        mock := &amp;MockServer{
                RequestLog: make([]MockRequest, 0),
        }

        router := mux.NewRouter()
        mock.setupRoutes(router)

        mock.Server = httptest.NewServer(router)
        return mock
}</span>

func (m *MockServer) Close() <span class="cov0" title="0">{
        m.Server.Close()
}</span>

func (m *MockServer) URL() string <span class="cov0" title="0">{
        return m.Server.URL
}</span>

func (m *MockServer) GetRequestLog() []MockRequest <span class="cov0" title="0">{
        return m.RequestLog
}</span>

func (m *MockServer) ClearRequestLog() <span class="cov0" title="0">{
        m.RequestLog = make([]MockRequest, 0)
}</span>

func (m *MockServer) SetResponseDelay(delay time.Duration) <span class="cov0" title="0">{
        m.ResponseDelay = delay
}</span>

func (m *MockServer) logRequest(r *http.Request, body string) <span class="cov0" title="0">{
        headers := make(map[string]string)
        for key, values := range r.Header </span><span class="cov0" title="0">{
                headers[key] = strings.Join(values, ", ")
        }</span>

        <span class="cov0" title="0">request := MockRequest{
                Method:    r.Method,
                URL:       r.URL.String(),
                Headers:   headers,
                Body:      body,
                Timestamp: time.Now(),
                Query:     r.URL.Query(),
        }

        m.RequestLog = append(m.RequestLog, request)</span>
}

func (m *MockServer) respondWithDelay(w http.ResponseWriter, response MockResponse) <span class="cov0" title="0">{
        if m.ResponseDelay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(m.ResponseDelay)
        }</span>
        <span class="cov0" title="0">if response.Delay &gt; 0 </span><span class="cov0" title="0">{
                time.Sleep(response.Delay)
        }</span>

        <span class="cov0" title="0">for key, value := range response.Headers </span><span class="cov0" title="0">{
                w.Header().Set(key, value)
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)
        json.NewEncoder(w).Encode(response.Body)</span>
}

func (m *MockServer) setupRoutes(router *mux.Router) <span class="cov0" title="0">{
        // OpenSubtitles API Mock
        router.HandleFunc("/opensubtitles/api/v1/login", m.mockOpenSubtitlesLogin).Methods("POST")
        router.HandleFunc("/opensubtitles/api/v1/subtitles", m.mockOpenSubtitlesSearch).Methods("GET")
        router.HandleFunc("/opensubtitles/api/v1/download", m.mockOpenSubtitlesDownload).Methods("POST")

        // SubDB API Mock
        router.HandleFunc("/subdb", m.mockSubDBSearch).Methods("GET")

        // YifySubtitles API Mock
        router.HandleFunc("/yifysubtitles/api/v1/subtitles", m.mockYifySubtitlesSearch).Methods("GET")

        // Genius API Mock
        router.HandleFunc("/genius/api/search", m.mockGeniusSearch).Methods("GET")
        router.HandleFunc("/genius/api/songs/{id}/lyrics", m.mockGeniusLyrics).Methods("GET")

        // Musixmatch API Mock
        router.HandleFunc("/musixmatch/ws/1.1/track.search", m.mockMusixmatchSearch).Methods("GET")
        router.HandleFunc("/musixmatch/ws/1.1/track.lyrics.get", m.mockMusixmatchLyrics).Methods("GET")

        // AZLyrics Mock
        router.HandleFunc("/azlyrics/{artist}/{song}", m.mockAZLyrics).Methods("GET")

        // MusicBrainz API Mock
        router.HandleFunc("/musicbrainz/ws/2/recording", m.mockMusicBrainzSearch).Methods("GET")
        router.HandleFunc("/musicbrainz/ws/2/release", m.mockMusicBrainzRelease).Methods("GET")

        // Last.FM API Mock
        router.HandleFunc("/lastfm/2.0", m.mockLastFMAPI).Methods("GET")

        // iTunes API Mock
        router.HandleFunc("/itunes/search", m.mockiTunesSearch).Methods("GET")

        // Spotify API Mock
        router.HandleFunc("/spotify/v1/search", m.mockSpotifySearch).Methods("GET")
        router.HandleFunc("/spotify/api/token", m.mockSpotifyToken).Methods("POST")

        // Discogs API Mock
        router.HandleFunc("/discogs/database/search", m.mockDiscogsSearch).Methods("GET")

        // Google Translate Mock
        router.HandleFunc("/google/translate/v2", m.mockGoogleTranslate).Methods("POST")
        router.HandleFunc("/google/translate/v2/detect", m.mockGoogleDetect).Methods("POST")

        // LibreTranslate Mock
        router.HandleFunc("/libretranslate/translate", m.mockLibreTranslate).Methods("POST")
        router.HandleFunc("/libretranslate/detect", m.mockLibreDetect).Methods("POST")

        // MyMemory Translation Mock
        router.HandleFunc("/mymemory/get", m.mockMyMemoryTranslate).Methods("GET")

        // Setlist.fm API Mock
        router.HandleFunc("/setlistfm/rest/1.0/search/setlists", m.mockSetlistFMSearch).Methods("GET")
}</span>

// OpenSubtitles API Mocks

func (m *MockServer) mockOpenSubtitlesLogin(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "token": "mock_opensubtitles_token_12345",
                        "user": map[string]interface{}{
                                "allowed_downloads": 200,
                                "level":             "VIP",
                                "user_id":           12345,
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockOpenSubtitlesSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        imdbID := r.URL.Query().Get("imdb_id")
        languages := r.URL.Query().Get("languages")

        if imdbID == "" </span><span class="cov0" title="0">{
                response := MockResponse{
                        StatusCode: 400,
                        Body: map[string]interface{}{
                                "message": "imdb_id parameter is required",
                        },
                }
                m.respondWithDelay(w, response)
                return
        }</span>

        <span class="cov0" title="0">subtitles := []map[string]interface{}{
                {
                        "id":           "subtitle_123",
                        "type":         "subtitle",
                        "language":     strings.Split(languages, ",")[0],
                        "filename":     "movie.srt",
                        "url":          fmt.Sprintf("%s/opensubtitles/files/subtitle_123.srt", m.URL()),
                        "download_url": fmt.Sprintf("%s/opensubtitles/api/v1/download", m.URL()),
                        "fps":          23.976,
                        "file_id":      123456,
                        "rating":       8.5,
                        "downloads":    15420,
                },
                {
                        "id":           "subtitle_124",
                        "type":         "subtitle",
                        "language":     "en",
                        "filename":     "movie_eng.srt",
                        "url":          fmt.Sprintf("%s/opensubtitles/files/subtitle_124.srt", m.URL()),
                        "download_url": fmt.Sprintf("%s/opensubtitles/api/v1/download", m.URL()),
                        "fps":          23.976,
                        "file_id":      123457,
                        "rating":       9.0,
                        "downloads":    25830,
                },
        }

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "total_pages": 1,
                        "total_count": len(subtitles),
                        "per_page":    60,
                        "page":        1,
                        "data":        subtitles,
                },
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockOpenSubtitlesDownload(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "link":           fmt.Sprintf("%s/opensubtitles/files/subtitle.srt", m.URL()),
                        "file_name":      "subtitle.srt",
                        "requests":       199,
                        "remaining":      199,
                        "message":        "Download successful",
                        "reset_time":     "24:00:00",
                        "reset_time_utc": time.Now().Add(24 * time.Hour).Format(time.RFC3339),
                },
        }
        m.respondWithDelay(w, response)
}</span>

// SubDB API Mock

func (m *MockServer) mockSubDBSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        action := r.URL.Query().Get("action")
        hash := r.URL.Query().Get("hash")

        if action != "search" || hash == "" </span><span class="cov0" title="0">{
                w.WriteHeader(404)
                return
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Headers: map[string]string{
                        "Content-Type": "text/plain",
                },
                Body: "en,es,fr,de",
        }
        m.respondWithDelay(w, response)</span>
}

// Genius API Mocks

func (m *MockServer) mockGeniusSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        query := r.URL.Query().Get("q")
        if query == "" </span><span class="cov0" title="0">{
                response := MockResponse{
                        StatusCode: 400,
                        Body: map[string]interface{}{
                                "error": "Missing required parameter: q",
                        },
                }
                m.respondWithDelay(w, response)
                return
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "meta": map[string]interface{}{
                                "status": 200,
                        },
                        "response": map[string]interface{}{
                                "hits": []map[string]interface{}{
                                        {
                                                "type":  "song",
                                                "index": "song",
                                                "result": map[string]interface{}{
                                                        "id":                  123456,
                                                        "title":               "Test Song",
                                                        "title_with_featured": "Test Song (feat. Test Artist)",
                                                        "full_title":          "Test Song by Test Artist",
                                                        "artist_names":        "Test Artist",
                                                        "primary_artist": map[string]interface{}{
                                                                "id":   98765,
                                                                "name": "Test Artist",
                                                                "url":  fmt.Sprintf("%s/genius/artists/98765", m.URL()),
                                                        },
                                                        "url":                          fmt.Sprintf("%s/genius/songs/123456", m.URL()),
                                                        "song_art_image_thumbnail_url": fmt.Sprintf("%s/images/song_art_123456_thumb.jpg", m.URL()),
                                                        "song_art_image_url":           fmt.Sprintf("%s/images/song_art_123456.jpg", m.URL()),
                                                },
                                        },
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockGeniusLyrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        songID := mux.Vars(r)["id"]

        mockLyrics := `[Verse 1]
This is a test song
With some mock lyrics
For testing purposes only

[Chorus]
La la la la la
Test test test
Mock lyrics here

[Verse 2]
More test lyrics
In a structured format
With timestamps if needed

[Outro]
End of mock song`

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "meta": map[string]interface{}{
                                "status": 200,
                        },
                        "response": map[string]interface{}{
                                "song": map[string]interface{}{
                                        "id":     songID,
                                        "lyrics": mockLyrics,
                                        "title":  "Test Song",
                                        "artist": "Test Artist",
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

// Google Translate Mocks

func (m *MockServer) mockGoogleTranslate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        var reqData map[string]interface{}
        json.Unmarshal([]byte(body), &amp;reqData)

        text := "Mock translated text"
        if q, ok := reqData["q"].(string); ok </span><span class="cov0" title="0">{
                text = fmt.Sprintf("Translated: %s", q)
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "data": map[string]interface{}{
                                "translations": []map[string]interface{}{
                                        {
                                                "translatedText":         text,
                                                "detectedSourceLanguage": "en",
                                        },
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockGoogleDetect(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "data": map[string]interface{}{
                                "detections": [][]map[string]interface{}{
                                        {
                                                {
                                                        "language":   "en",
                                                        "isReliable": true,
                                                        "confidence": 0.95,
                                                },
                                        },
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

// LibreTranslate Mocks

func (m *MockServer) mockLibreTranslate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        var reqData map[string]interface{}
        json.Unmarshal([]byte(body), &amp;reqData)

        text := "Mock LibreTranslate result"
        if q, ok := reqData["q"].(string); ok </span><span class="cov0" title="0">{
                text = fmt.Sprintf("LibreTranslated: %s", q)
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "translatedText": text,
                },
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockLibreDetect(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: []map[string]interface{}{
                        {
                                "confidence": 0.92,
                                "language":   "en",
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

// MyMemory Translation Mock

func (m *MockServer) mockMyMemoryTranslate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        q := r.URL.Query().Get("q")

        text := "Mock MyMemory translation"
        if q != "" </span><span class="cov0" title="0">{
                text = fmt.Sprintf("MyMemory: %s", q)
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "responseData": map[string]interface{}{
                                "translatedText": text,
                                "match":          0.85,
                        },
                        "quotaFinished":   false,
                        "mtLangSupported": true,
                        "responseDetails": "",
                        "responseStatus":  200,
                        "responderId":     "MyMemory",
                },
        }
        m.respondWithDelay(w, response)</span>
}

// Music API Mocks

func (m *MockServer) mockMusicBrainzSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        format := r.URL.Query().Get("fmt")

        if format != "json" </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/xml")
                w.WriteHeader(200)
                w.Write([]byte(`&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;metadata/&gt;`))
                return
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "recordings": []map[string]interface{}{
                                {
                                        "id":    "test-recording-id-123",
                                        "title": "Test Recording",
                                        "artist-credit": []map[string]interface{}{
                                                {
                                                        "name": "Test Artist",
                                                        "artist": map[string]interface{}{
                                                                "id":   "test-artist-id-456",
                                                                "name": "Test Artist",
                                                        },
                                                },
                                        },
                                        "releases": []map[string]interface{}{
                                                {
                                                        "id":    "test-release-id-789",
                                                        "title": "Test Album",
                                                        "date":  "2023-01-01",
                                                },
                                        },
                                },
                        },
                        "count":  1,
                        "offset": 0,
                },
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockLastFMAPI(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        method := r.URL.Query().Get("method")
        format := r.URL.Query().Get("format")

        if format != "json" </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/xml")
                w.WriteHeader(200)
                w.Write([]byte(`&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;lfm status="ok"&gt;&lt;/lfm&gt;`))
                return
        }</span>

        <span class="cov0" title="0">var responseBody interface{}

        switch method </span>{
        case "album.getinfo":<span class="cov0" title="0">
                responseBody = map[string]interface{}{
                        "album": map[string]interface{}{
                                "name":   "Test Album",
                                "artist": "Test Artist",
                                "image": []map[string]interface{}{
                                        {
                                                "#text": fmt.Sprintf("%s/images/album_small.jpg", m.URL()),
                                                "size":  "small",
                                        },
                                        {
                                                "#text": fmt.Sprintf("%s/images/album_large.jpg", m.URL()),
                                                "size":  "large",
                                        },
                                },
                        },
                }</span>
        case "track.getinfo":<span class="cov0" title="0">
                responseBody = map[string]interface{}{
                        "track": map[string]interface{}{
                                "name": "Test Track",
                                "artist": map[string]interface{}{
                                        "name": "Test Artist",
                                },
                                "album": map[string]interface{}{
                                        "title": "Test Album",
                                        "image": []map[string]interface{}{
                                                {
                                                        "#text": fmt.Sprintf("%s/images/track_large.jpg", m.URL()),
                                                        "size":  "large",
                                                },
                                        },
                                },
                        },
                }</span>
        default:<span class="cov0" title="0">
                responseBody = map[string]interface{}{
                        "error":   6,
                        "message": "Invalid method",
                }</span>
        }

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body:       responseBody,
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockiTunesSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        results := []map[string]interface{}{
                {
                        "trackId":        123456789,
                        "trackName":      "Test Song",
                        "artistName":     "Test Artist",
                        "collectionName": "Test Album",
                        "artworkUrl30":   fmt.Sprintf("%s/images/itunes_30.jpg", m.URL()),
                        "artworkUrl60":   fmt.Sprintf("%s/images/itunes_60.jpg", m.URL()),
                        "artworkUrl100":  fmt.Sprintf("%s/images/itunes_100.jpg", m.URL()),
                        "artworkUrl500":  fmt.Sprintf("%s/images/itunes_500.jpg", m.URL()),
                        "releaseDate":    "2023-01-01T00:00:00Z",
                        "kind":           "song",
                        "trackPrice":     0.99,
                        "currency":       "USD",
                },
        }

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "resultCount": len(results),
                        "results":     results,
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockSpotifyToken(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "access_token": "mock_spotify_access_token_12345",
                        "token_type":   "Bearer",
                        "expires_in":   3600,
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockSpotifySearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        searchType := r.URL.Query().Get("type")

        var results interface{}

        if strings.Contains(searchType, "track") </span><span class="cov0" title="0">{
                results = map[string]interface{}{
                        "tracks": map[string]interface{}{
                                "items": []map[string]interface{}{
                                        {
                                                "id":   "test_track_id_123",
                                                "name": "Test Track",
                                                "artists": []map[string]interface{}{
                                                        {
                                                                "id":   "test_artist_id_456",
                                                                "name": "Test Artist",
                                                        },
                                                },
                                                "album": map[string]interface{}{
                                                        "id":   "test_album_id_789",
                                                        "name": "Test Album",
                                                        "images": []map[string]interface{}{
                                                                {
                                                                        "url":    fmt.Sprintf("%s/images/spotify_640.jpg", m.URL()),
                                                                        "height": 640,
                                                                        "width":  640,
                                                                },
                                                                {
                                                                        "url":    fmt.Sprintf("%s/images/spotify_300.jpg", m.URL()),
                                                                        "height": 300,
                                                                        "width":  300,
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                }
        }</span>

        <span class="cov0" title="0">response := MockResponse{
                StatusCode: 200,
                Body:       results,
        }
        m.respondWithDelay(w, response)</span>
}

func (m *MockServer) mockDiscogsSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "results": []map[string]interface{}{
                                {
                                        "id":          123456,
                                        "title":       "Test Artist - Test Album",
                                        "type":        "release",
                                        "thumb":       fmt.Sprintf("%s/images/discogs_thumb.jpg", m.URL()),
                                        "cover_image": fmt.Sprintf("%s/images/discogs_cover.jpg", m.URL()),
                                        "year":        2023,
                                },
                        },
                        "pagination": map[string]interface{}{
                                "page":     1,
                                "pages":    1,
                                "per_page": 50,
                                "items":    1,
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

// Additional mocks for other services

func (m *MockServer) mockMusixmatchSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "message": map[string]interface{}{
                                "header": map[string]interface{}{
                                        "status_code": 200,
                                },
                                "body": map[string]interface{}{
                                        "track_list": []map[string]interface{}{
                                                {
                                                        "track": map[string]interface{}{
                                                                "track_id":      123456,
                                                                "track_name":    "Test Song",
                                                                "artist_name":   "Test Artist",
                                                                "album_name":    "Test Album",
                                                                "has_lyrics":    1,
                                                                "has_subtitles": 1,
                                                                "has_richsync":  1,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockMusixmatchLyrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        mockLyrics := `This is a test song
With mock lyrics from Musixmatch
Line by line format
For testing purposes`

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "message": map[string]interface{}{
                                "header": map[string]interface{}{
                                        "status_code": 200,
                                },
                                "body": map[string]interface{}{
                                        "lyrics": map[string]interface{}{
                                                "lyrics_id":           123456,
                                                "lyrics_body":         mockLyrics,
                                                "script_tracking_url": "",
                                                "pixel_tracking_url":  "",
                                                "lyrics_copyright":    "Mock Copyright",
                                        },
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockAZLyrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        artist := mux.Vars(r)["artist"]
        song := mux.Vars(r)["song"]

        mockHTML := fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;%s - %s Lyrics&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div class="lyrics"&gt;
This is a test song&lt;br&gt;
With mock lyrics from AZLyrics&lt;br&gt;
Artist: %s&lt;br&gt;
Song: %s&lt;br&gt;
For testing purposes only
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`, artist, song, artist, song)

        w.Header().Set("Content-Type", "text/html")
        w.WriteHeader(200)
        w.Write([]byte(mockHTML))
}</span>

func (m *MockServer) mockYifySubtitlesSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        subtitles := []map[string]interface{}{
                {
                        "id":        "yify_123",
                        "language":  "English",
                        "lang_code": "en",
                        "url":       fmt.Sprintf("%s/yifysubtitles/files/subtitle_en.srt", m.URL()),
                        "rating":    "good",
                        "downloads": 1250,
                },
                {
                        "id":        "yify_124",
                        "language":  "Spanish",
                        "lang_code": "es",
                        "url":       fmt.Sprintf("%s/yifysubtitles/files/subtitle_es.srt", m.URL()),
                        "rating":    "good",
                        "downloads": 890,
                },
        }

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "success": true,
                        "data":    subtitles,
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockMusicBrainzRelease(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "id":    "test-release-id-789",
                        "title": "Test Album",
                        "date":  "2023-01-01",
                        "cover-art-archive": map[string]interface{}{
                                "artwork": true,
                                "count":   1,
                                "front":   true,
                                "back":    false,
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) mockSetlistFMSearch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        body := m.readBody(r)
        m.logRequest(r, body)

        artistName := r.URL.Query().Get("artistName")

        response := MockResponse{
                StatusCode: 200,
                Body: map[string]interface{}{
                        "type":         "setlists",
                        "itemsPerPage": 20,
                        "page":         1,
                        "total":        1,
                        "setlist": []map[string]interface{}{
                                {
                                        "id":        "test-setlist-123",
                                        "versionId": "test-version-456",
                                        "eventDate": "01-01-2023",
                                        "artist": map[string]interface{}{
                                                "mbid": "test-artist-mbid-789",
                                                "name": artistName,
                                        },
                                        "venue": map[string]interface{}{
                                                "id":   "test-venue-123",
                                                "name": "Test Venue",
                                                "city": map[string]interface{}{
                                                        "id":   "test-city-456",
                                                        "name": "Test City",
                                                        "country": map[string]interface{}{
                                                                "code": "US",
                                                                "name": "United States",
                                                        },
                                                },
                                        },
                                        "sets": map[string]interface{}{
                                                "set": []map[string]interface{}{
                                                        {
                                                                "song": []map[string]interface{}{
                                                                        {
                                                                                "name": "Test Song 1",
                                                                        },
                                                                        {
                                                                                "name": "Test Song 2",
                                                                        },
                                                                        {
                                                                                "name": "Test Song 3",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
        m.respondWithDelay(w, response)
}</span>

func (m *MockServer) readBody(r *http.Request) string <span class="cov0" title="0">{
        if r.Body == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">buf := make([]byte, r.ContentLength)
        r.Body.Read(buf)
        return string(buf)</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package main

import (
        "catalogizer/internal/config"
        "catalogizer/internal/handlers"
        "catalogizer/internal/middleware"
        "catalogizer/internal/services"
        "context"
        "database/sql"
        "flag"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"
        _ "github.com/mattn/go-sqlite3"
        "go.uber.org/zap"
)

// @title Catalog API
// @version 2.0
// @description REST API for browsing and searching multi-protocol file catalog (SMB, FTP, NFS, WebDAV, Local)
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /

// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

func main() <span class="cov0" title="0">{
        // Parse command line flags
        testMode := flag.Bool("test-mode", false, "Run in test mode with additional logging")
        flag.Parse()

        // Initialize logger
        logger, _ := zap.NewProduction()
        defer logger.Sync()

        if *testMode </span><span class="cov0" title="0">{
                logger.Info("Running in test mode")
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to load configuration:", err)
        }</span>

        // Initialize database
        // Use the Database field as the path for SQLite
        <span class="cov0" title="0">dbPath := cfg.Database.Database
        if dbPath == "" </span><span class="cov0" title="0">{
                dbPath = "./data/catalogizer.db" // Default path
        }</span>
        <span class="cov0" title="0">db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to connect to database:", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Initialize services
        catalogService := services.NewCatalogService(cfg, logger)
        catalogService.SetDB(db)
        smbService := services.NewSMBService(cfg, logger)
        smbDiscoveryService := services.NewSMBDiscoveryService(logger)

        // Initialize handlers
        catalogHandler := handlers.NewCatalogHandler(catalogService, smbService, logger)
        downloadHandler := handlers.NewDownloadHandler(catalogService, smbService, cfg.Catalog.TempDir, cfg.Catalog.MaxArchiveSize, cfg.Catalog.DownloadChunkSize, logger)
        copyHandler := handlers.NewCopyHandler(catalogService, smbService, cfg.Catalog.TempDir, logger)
        smbDiscoveryHandler := handlers.NewSMBDiscoveryHandler(smbDiscoveryService, logger)

        // Setup Gin router
        router := gin.Default()

        // Middleware
        router.Use(middleware.CORS())
        router.Use(middleware.Logger(logger))
        router.Use(middleware.ErrorHandler())
        router.Use(middleware.RequestID())

        // Health check
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"status": "healthy", "time": time.Now().UTC()})
        }</span>)

        // API routes
        <span class="cov0" title="0">api := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Catalog browsing endpoints
                api.GET("/catalog", catalogHandler.ListRoot)
                api.GET("/catalog/*path", catalogHandler.ListPath)
                api.GET("/catalog-info/*path", catalogHandler.GetFileInfo)

                // Search endpoints
                api.GET("/search", catalogHandler.Search)
                api.GET("/search/duplicates", catalogHandler.SearchDuplicates)

                // Download endpoints
                api.GET("/download/file/:id", downloadHandler.DownloadFile)
                api.GET("/download/directory/*path", downloadHandler.DownloadDirectory)
                api.POST("/download/archive", downloadHandler.DownloadArchive)

                // File operations
                api.POST("/copy/storage", copyHandler.CopyToStorage)
                api.POST("/copy/local", copyHandler.CopyToLocal)
                api.POST("/copy/upload", copyHandler.CopyFromLocal)
                api.GET("/storage/list/*path", copyHandler.ListStoragePath)
                api.GET("/storage/roots", copyHandler.GetStorageRoots)

                // Statistics and sorting
                api.GET("/stats/directories/by-size", catalogHandler.GetDirectoriesBySize)
                api.GET("/stats/duplicates/count", catalogHandler.GetDuplicatesCount)

                // SMB Discovery endpoints
                smbGroup := api.Group("/smb")
                </span><span class="cov0" title="0">{
                        smbGroup.POST("/discover", smbDiscoveryHandler.DiscoverShares)
                        smbGroup.GET("/discover", smbDiscoveryHandler.DiscoverSharesGET)
                        smbGroup.POST("/test", smbDiscoveryHandler.TestConnection)
                        smbGroup.GET("/test", smbDiscoveryHandler.TestConnectionGET)
                        smbGroup.POST("/browse", smbDiscoveryHandler.BrowseShare)
                }</span>
        }

        // Create HTTP server
        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:         cfg.GetServerAddress(),
                Handler:      router,
                ReadTimeout:  time.Duration(cfg.Server.ReadTimeout) * time.Second,
                WriteTimeout: time.Duration(cfg.Server.WriteTimeout) * time.Second,
                IdleTimeout:  time.Duration(cfg.Server.IdleTimeout) * time.Second,
        }

        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                logger.Info("Starting catalog API server", zap.String("address", cfg.GetServerAddress()))
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to start server", zap.Error(err))
                }</span>
        }()

        // Wait for interrupt signal to gracefully shutdown the server
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit
        logger.Info("Shutting down server...")

        // The context is used to inform the server it has 30 seconds to finish
        // the request it is currently handling
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Server forced to shutdown", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Info("Server exited")</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package middleware

import (
        "net/http"
        "strings"
        "time"

        "catalogizer/utils"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
)

// JWTMiddleware handles JWT authentication
type JWTMiddleware struct {
        secretKey []byte
}

// Claims represents JWT claims
type Claims struct {
        Username string `json:"username"`
        jwt.RegisteredClaims
}

// NewJWTMiddleware creates a new JWT middleware
func NewJWTMiddleware(secretKey string) *JWTMiddleware <span class="cov0" title="0">{
        return &amp;JWTMiddleware{
                secretKey: []byte(secretKey),
        }
}</span>

// RequireAuth returns a middleware that requires valid JWT authentication
func (m *JWTMiddleware) RequireAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusUnauthorized, "Authorization header required", nil)
                        c.Abort()
                        return
                }</span>

                // Extract token from "Bearer &lt;token&gt;"
                <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusUnauthorized, "Invalid authorization header format", nil)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">tokenString := parts[1]

                // Parse and validate token
                claims := &amp;Claims{}
                token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        return m.secretKey, nil
                }</span>)

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusUnauthorized, "Invalid token", err)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                        utils.SendErrorResponse(c, http.StatusUnauthorized, "Invalid token", nil)
                        c.Abort()
                        return
                }</span>

                // Set user info in context
                <span class="cov0" title="0">c.Set("username", claims.Username)
                c.Set("user_id", claims.Subject)

                c.Next()</span>
        }
}

// GenerateToken generates a new JWT token
func (m *JWTMiddleware) GenerateToken(username, userID string, expirationHours int) (string, error) <span class="cov0" title="0">{
        claims := &amp;Claims{
                Username: username,
                RegisteredClaims: jwt.RegisteredClaims{
                        Subject:   userID,
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Duration(expirationHours) * time.Hour)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        Issuer:    "catalog-api",
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(m.secretKey)
}</span>

// ValidateToken validates a JWT token and returns claims
func (m *JWTMiddleware) ValidateToken(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        claims := &amp;Claims{}
        token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return m.secretKey, nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                return nil, jwt.ErrTokenNotValidYet
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// RequestID adds a unique request ID to each request
func RequestID() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = uuid.New().String()
                }</span>

                <span class="cov0" title="0">c.Header("X-Request-ID", requestID)
                c.Set("request_id", requestID)
                c.Next()</span>
        }
}

// RateLimiter implements basic rate limiting
func RateLimiter(requestsPerMinute int) gin.HandlerFunc <span class="cov0" title="0">{
        // This is a simplified rate limiter
        // In production, you'd want to use Redis or similar for distributed rate limiting
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Placeholder for rate limiting logic
                c.Next()
        }</span>
}

// CORS handles Cross-Origin Resource Sharing
func CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Credentials", "true")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Header("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "time"
)

// User represents a system user with role-based permissions
type User struct {
        ID                  int        `json:"id" db:"id"`
        Username            string     `json:"username" db:"username"`
        Email               string     `json:"email" db:"email"`
        PasswordHash        string     `json:"-" db:"password_hash"` // Never include in JSON
        Salt                string     `json:"-" db:"salt"`          // Never include in JSON
        RoleID              int        `json:"role_id" db:"role_id"`
        Role                *Role      `json:"role,omitempty"`
        FirstName           *string    `json:"first_name" db:"first_name"`
        LastName            *string    `json:"last_name" db:"last_name"`
        DisplayName         *string    `json:"display_name" db:"display_name"`
        AvatarURL           *string    `json:"avatar_url" db:"avatar_url"`
        TimeZone            *string    `json:"time_zone" db:"time_zone"`
        Language            *string    `json:"language" db:"language"`
        Settings            string     `json:"settings" db:"settings"`
        IsActive            bool       `json:"is_active" db:"is_active"`
        IsLocked            bool       `json:"is_locked" db:"is_locked"`
        LockedUntil         *time.Time `json:"locked_until,omitempty" db:"locked_until"`
        FailedLoginAttempts int        `json:"failed_login_attempts" db:"failed_login_attempts"`
        LastLoginAt         *time.Time `json:"last_login_at" db:"last_login_at"`
        LastLoginIP         *string    `json:"last_login_ip,omitempty" db:"last_login_ip"`
        CreatedAt           time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt           time.Time  `json:"updated_at" db:"updated_at"`
}

// Role represents a user role with specific permissions
type Role struct {
        ID          int         `json:"id" db:"id"`
        Name        string      `json:"name" db:"name"`
        Description *string     `json:"description" db:"description"`
        Permissions Permissions `json:"permissions" db:"permissions"`
        IsSystem    bool        `json:"is_system" db:"is_system"`
        CreatedAt   time.Time   `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time   `json:"updated_at" db:"updated_at"`
}

// Permissions represents a list of permission strings
type Permissions []string

// Value implements the driver.Valuer interface for database storage
func (p Permissions) Value() (driver.Value, error) <span class="cov0" title="0">{
        if len(p) == 0 </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>
        <span class="cov0" title="0">return json.Marshal(p)</span>
}

// Scan implements the sql.Scanner interface for database retrieval
func (p *Permissions) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *p = Permissions{}
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), p)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, p)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// HasPermission checks if the permissions include a specific permission
func (p Permissions) HasPermission(permission string) bool <span class="cov0" title="0">{
        // Check for wildcard permission
        for _, perm := range p </span><span class="cov0" title="0">{
                if perm == "*" </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if perm == permission </span><span class="cov0" title="0">{
                        return true
                }</span>
                // Check for wildcard patterns (e.g., "media.*" matches "media.view")
                <span class="cov0" title="0">if len(perm) &gt; 0 &amp;&amp; perm[len(perm)-1] == '*' </span><span class="cov0" title="0">{
                        prefix := perm[:len(perm)-1]
                        if len(permission) &gt;= len(prefix) &amp;&amp; permission[:len(prefix)] == prefix </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// HasAnyPermission checks if the permissions include any of the specified permissions
func (p Permissions) HasAnyPermission(permissions []string) bool <span class="cov0" title="0">{
        for _, permission := range permissions </span><span class="cov0" title="0">{
                if p.HasPermission(permission) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// UserPreferences represents user-specific preferences
type UserPreferences struct {
        Theme                string            `json:"theme,omitempty"`
        Language             string            `json:"language,omitempty"`
        Timezone             string            `json:"timezone,omitempty"`
        MediaPlayerSettings  MediaPlayerPrefs  `json:"media_player,omitempty"`
        NotificationSettings NotificationPrefs `json:"notifications,omitempty"`
        PrivacySettings      PrivacyPrefs      `json:"privacy,omitempty"`
        UISettings           UIPrefs           `json:"ui,omitempty"`
}

// MediaPlayerPrefs represents media player preferences
type MediaPlayerPrefs struct {
        AutoPlay       bool    `json:"auto_play"`
        DefaultQuality string  `json:"default_quality"`
        Volume         float64 `json:"volume"`
        Subtitles      bool    `json:"subtitles"`
        SkipIntro      bool    `json:"skip_intro"`
}

// NotificationPrefs represents notification preferences
type NotificationPrefs struct {
        EmailNotifications bool `json:"email_notifications"`
        PushNotifications  bool `json:"push_notifications"`
        SyncNotifications  bool `json:"sync_notifications"`
        ErrorNotifications bool `json:"error_notifications"`
}

// PrivacyPrefs represents privacy preferences
type PrivacyPrefs struct {
        ShareUsageData      bool `json:"share_usage_data"`
        LocationTracking    bool `json:"location_tracking"`
        AnalyticsTracking   bool `json:"analytics_tracking"`
        PersonalizedContent bool `json:"personalized_content"`
}

// UIPrefs represents UI preferences
type UIPrefs struct {
        DensityMode     string `json:"density_mode"` // compact, comfortable, spacious
        GridSize        int    `json:"grid_size"`    // items per row
        ShowThumbnails  bool   `json:"show_thumbnails"`
        ShowMetadata    bool   `json:"show_metadata"`
        DefaultSortBy   string `json:"default_sort_by"`
        DefaultSortDesc bool   `json:"default_sort_desc"`
}

// UserSettings represents user-specific settings
type UserSettings struct {
        DefaultShare         string                 `json:"default_share,omitempty"`
        AutoSync             bool                   `json:"auto_sync"`
        SyncIntervalMinutes  int                    `json:"sync_interval_minutes"`
        DownloadQuality      string                 `json:"download_quality"`
        CacheSettings        CacheSettings          `json:"cache,omitempty"`
        ConversionSettings   ConversionSettings     `json:"conversion,omitempty"`
        BackupSettings       BackupSettings         `json:"backup,omitempty"`
        SecuritySettings     SecuritySettings       `json:"security,omitempty"`
        ExperimentalFeatures map[string]interface{} `json:"experimental_features,omitempty"`
}

// CacheSettings represents caching preferences
type CacheSettings struct {
        MaxCacheSize    int64 `json:"max_cache_size"` // bytes
        CacheThumbnails bool  `json:"cache_thumbnails"`
        CacheMetadata   bool  `json:"cache_metadata"`
        CacheTimeout    int   `json:"cache_timeout"` // minutes
}

// ConversionSettings represents format conversion preferences
type ConversionSettings struct {
        DefaultVideoFormat string `json:"default_video_format"`
        DefaultAudioFormat string `json:"default_audio_format"`
        DefaultQuality     string `json:"default_quality"`
        MaxConcurrentJobs  int    `json:"max_concurrent_jobs"`
}

// BackupSettings represents backup preferences
type BackupSettings struct {
        AutoBackup       bool   `json:"auto_backup"`
        BackupInterval   string `json:"backup_interval"`  // daily, weekly, monthly
        BackupRetention  int    `json:"backup_retention"` // days
        BackupLocation   string `json:"backup_location"`
        BackupEncryption bool   `json:"backup_encryption"`
}

// SecuritySettings represents security preferences
type SecuritySettings struct {
        TwoFactorEnabled   bool     `json:"two_factor_enabled"`
        SessionTimeout     int      `json:"session_timeout"`      // minutes
        RequirePasswordFor []string `json:"require_password_for"` // actions requiring password
        LoginNotifications bool     `json:"login_notifications"`
}

// Value implements the driver.Valuer interface for UserPreferences
func (up UserPreferences) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(up)
}</span>

// Scan implements the sql.Scanner interface for UserPreferences
func (up *UserPreferences) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *up = UserPreferences{}
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), up)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, up)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface for UserSettings
func (us UserSettings) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(us)
}</span>

// Scan implements the sql.Scanner interface for UserSettings
func (us *UserSettings) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *us = UserSettings{}
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), us)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, us)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// UserSession represents an active user session
type UserSession struct {
        ID             int        `json:"id" db:"id"`
        UserID         int        `json:"user_id" db:"user_id"`
        SessionToken   string     `json:"session_token" db:"session_token"`
        RefreshToken   *string    `json:"refresh_token,omitempty" db:"refresh_token"`
        DeviceInfo     DeviceInfo `json:"device_info" db:"device_info"`
        IPAddress      *string    `json:"ip_address,omitempty" db:"ip_address"`
        UserAgent      *string    `json:"user_agent,omitempty" db:"user_agent"`
        IsActive       bool       `json:"is_active" db:"is_active"`
        ExpiresAt      time.Time  `json:"expires_at" db:"expires_at"`
        CreatedAt      time.Time  `json:"created_at" db:"created_at"`
        LastActivityAt time.Time  `json:"last_activity_at" db:"last_activity_at"`
}

// DeviceInfo represents information about the user's device
type DeviceInfo struct {
        DeviceType      string  `json:"device_type"` // mobile, tablet, desktop, tv
        Platform        string  `json:"platform"`    // android, ios, windows, macos, linux
        PlatformVersion string  `json:"platform_version"`
        AppVersion      string  `json:"app_version"`
        DeviceModel     *string `json:"device_model,omitempty"`
        DeviceName      *string `json:"device_name,omitempty"`
        ScreenSize      *string `json:"screen_size,omitempty"`
        IsEmulator      bool    `json:"is_emulator"`
}

// Value implements the driver.Valuer interface for DeviceInfo
func (di DeviceInfo) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(di)
}</span>

// Scan implements the sql.Scanner interface for DeviceInfo
func (di *DeviceInfo) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *di = DeviceInfo{}
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), di)</span>
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, di)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// UserSummary represents a summary view of user information
type UserSummary struct {
        ID                 int        `json:"id" db:"id"`
        Username           string     `json:"username" db:"username"`
        Email              string     `json:"email" db:"email"`
        DisplayName        *string    `json:"display_name" db:"display_name"`
        RoleName           string     `json:"role_name" db:"role_name"`
        RoleDisplayName    string     `json:"role_display_name" db:"role_display_name"`
        IsActive           bool       `json:"is_active" db:"is_active"`
        LastLoginAt        *time.Time `json:"last_login_at" db:"last_login_at"`
        TotalMediaAccesses int        `json:"total_media_accesses" db:"total_media_accesses"`
        TotalFavorites     int        `json:"total_favorites" db:"total_favorites"`
        CreatedAt          time.Time  `json:"created_at" db:"created_at"`
}

// CreateUserRequest represents a request to create a new user
type CreateUserRequest struct {
        Username                string           `json:"username" validate:"required,min=3,max=50"`
        Email                   string           `json:"email" validate:"required,email"`
        Password                string           `json:"password" validate:"required,min=8"`
        RoleID                  int              `json:"role_id" validate:"required"`
        FirstName               *string          `json:"first_name"`
        LastName                *string          `json:"last_name"`
        TimeZone                *string          `json:"time_zone"`
        Language                *string          `json:"language"`
        IsActive                *bool            `json:"is_active"`
        DisplayName             *string          `json:"display_name"`
        LocationTrackingEnabled *bool            `json:"location_tracking_enabled"`
        AnalyticsEnabled        *bool            `json:"analytics_enabled"`
        Preferences             *UserPreferences `json:"preferences"`
        Settings                *UserSettings    `json:"settings"`
}

// UpdateUserRequest represents a request to update user information
type UpdateUserRequest struct {
        Username                *string          `json:"username" validate:"omitempty,min=3,max=50"`
        Email                   *string          `json:"email" validate:"omitempty,email"`
        RoleID                  *int             `json:"role_id"`
        FirstName               *string          `json:"first_name"`
        LastName                *string          `json:"last_name"`
        TimeZone                *string          `json:"time_zone"`
        Language                *string          `json:"language"`
        DisplayName             *string          `json:"display_name"`
        AvatarURL               *string          `json:"avatar_url"`
        LocationTrackingEnabled *bool            `json:"location_tracking_enabled"`
        AnalyticsEnabled        *bool            `json:"analytics_enabled"`
        IsActive                *bool            `json:"is_active"`
        Preferences             *UserPreferences `json:"preferences"`
        Settings                *UserSettings    `json:"settings"`
}

// CreateRoleRequest represents a request to create a new role
type CreateRoleRequest struct {
        Name        string   `json:"name" validate:"required,min=2,max=50"`
        Description *string  `json:"description"`
        Permissions []string `json:"permissions" validate:"required"`
}

// UpdateRoleRequest represents a request to update role information
type UpdateRoleRequest struct {
        Name        *string  `json:"name" validate:"omitempty,min=2,max=50"`
        Description *string  `json:"description"`
        Permissions []string `json:"permissions"`
}

// ChangePasswordRequest represents a request to change user password
type ChangePasswordRequest struct {
        CurrentPassword string `json:"current_password" validate:"required"`
        NewPassword     string `json:"new_password" validate:"required,min=8"`
}

// LoginRequest represents a login request
type LoginRequest struct {
        Username   string     `json:"username" validate:"required"`
        Password   string     `json:"password" validate:"required"`
        DeviceInfo DeviceInfo `json:"device_info"`
        RememberMe bool       `json:"remember_me"`
}

// LoginResponse represents a login response
type LoginResponse struct {
        User         User      `json:"user"`
        SessionToken string    `json:"session_token"`
        RefreshToken string    `json:"refresh_token"`
        ExpiresAt    time.Time `json:"expires_at"`
}

// RefreshTokenRequest represents a token refresh request
type RefreshTokenRequest struct {
        RefreshToken string `json:"refresh_token" validate:"required"`
}

// UserListResponse represents a paginated list of users
type UserListResponse struct {
        Users      []UserSummary `json:"users"`
        Total      int           `json:"total"`
        Page       int           `json:"page"`
        PageSize   int           `json:"page_size"`
        TotalPages int           `json:"total_pages"`
}

// Common permission constants
const (
        // System permissions
        PermissionSystemAdmin  = "system.admin"
        PermissionSystemConfig = "system.configure"

        // User management permissions
        PermissionUserView   = "user.view"
        PermissionUserCreate = "user.create"
        PermissionUserUpdate = "user.update"
        PermissionUserDelete = "user.delete"
        PermissionUserManage = "user.manage" // includes all user operations

        // Media permissions
        PermissionMediaView     = "media.view"
        PermissionMediaUpload   = "media.upload"
        PermissionMediaEdit     = "media.edit"
        PermissionMediaDelete   = "media.delete"
        PermissionMediaShare    = "media.share"
        PermissionMediaDownload = "media.download"
        PermissionMediaConvert  = "media.convert"
        PermissionMediaManage   = "media.manage" // includes all media operations

        // Share permissions
        PermissionShareView    = "share.view"
        PermissionShareCreate  = "share.create"
        PermissionShareEdit    = "share.edit"
        PermissionShareDelete  = "share.delete"
        PermissionShareManage  = "share.manage" // includes all share operations
        PermissionViewShares   = "share.view"
        PermissionEditShares   = "share.edit"
        PermissionDeleteShares = "share.delete"

        // Analytics permissions
        PermissionAnalyticsView   = "analytics.view"
        PermissionAnalyticsExport = "analytics.export"
        PermissionAnalyticsManage = "analytics.manage"
        PermissionViewAnalytics   = "analytics.view"

        // Favorites permissions
        PermissionFavoriteView   = "favorite.view"
        PermissionFavoriteCreate = "favorite.create"
        PermissionFavoriteDelete = "favorite.delete"

        // Profile permissions
        PermissionProfileView   = "profile.view"
        PermissionProfileUpdate = "profile.update"

        // Sync permissions
        PermissionSyncView    = "sync.view"
        PermissionSyncCreate  = "sync.create"
        PermissionSyncExecute = "sync.execute"
        PermissionSyncManage  = "sync.manage"

        // Conversion permissions
        PermissionConversionView   = "conversion.view"
        PermissionConversionCreate = "conversion.create"
        PermissionConversionManage = "conversion.manage"

        // Report permissions
        PermissionReportView   = "report.view"
        PermissionReportCreate = "report.create"
        PermissionReportExport = "report.export"

        // Wildcard permission
        PermissionWildcard = "*"
)

// Utility functions

// IsAccountLocked checks if the user account is currently locked
func (u *User) IsAccountLocked() bool <span class="cov0" title="0">{
        return u.IsLocked || (u.LockedUntil != nil &amp;&amp; u.LockedUntil.After(time.Now()))
}</span>

// CanLogin checks if the user can login (active and not locked)
func (u *User) CanLogin() bool <span class="cov0" title="0">{
        return u.IsActive &amp;&amp; !u.IsAccountLocked()
}</span>

// HasPermission checks if the user has a specific permission
func (u *User) HasPermission(permission string) bool <span class="cov0" title="0">{
        if u.Role == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return u.Role.Permissions.HasPermission(permission)</span>
}

// HasAnyPermission checks if the user has any of the specified permissions
func (u *User) HasAnyPermission(permissions []string) bool <span class="cov0" title="0">{
        if u.Role == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return u.Role.Permissions.HasAnyPermission(permissions)</span>
}

// IsAdmin checks if the user is an administrator
func (u *User) IsAdmin() bool <span class="cov0" title="0">{
        return u.HasPermission(PermissionSystemAdmin) || u.HasPermission(PermissionWildcard)
}</span>

// GetDefaultPreferences returns default user preferences
func GetDefaultPreferences() UserPreferences <span class="cov0" title="0">{
        return UserPreferences{
                Theme:    "auto",
                Language: "en",
                Timezone: "UTC",
                MediaPlayerSettings: MediaPlayerPrefs{
                        AutoPlay:       false,
                        DefaultQuality: "auto",
                        Volume:         0.8,
                        Subtitles:      false,
                        SkipIntro:      false,
                },
                NotificationSettings: NotificationPrefs{
                        EmailNotifications: true,
                        PushNotifications:  true,
                        SyncNotifications:  true,
                        ErrorNotifications: true,
                },
                PrivacySettings: PrivacyPrefs{
                        ShareUsageData:      true,
                        LocationTracking:    true,
                        AnalyticsTracking:   true,
                        PersonalizedContent: true,
                },
                UISettings: UIPrefs{
                        DensityMode:     "comfortable",
                        GridSize:        4,
                        ShowThumbnails:  true,
                        ShowMetadata:    true,
                        DefaultSortBy:   "name",
                        DefaultSortDesc: false,
                },
        }
}</span>

// GetDefaultSettings returns default user settings
func GetDefaultSettings() UserSettings <span class="cov0" title="0">{
        return UserSettings{
                AutoSync:            true,
                SyncIntervalMinutes: 60,
                DownloadQuality:     "original",
                CacheSettings: CacheSettings{
                        MaxCacheSize:    1024 * 1024 * 1024, // 1GB
                        CacheThumbnails: true,
                        CacheMetadata:   true,
                        CacheTimeout:    60, // 1 hour
                },
                ConversionSettings: ConversionSettings{
                        DefaultVideoFormat: "mp4",
                        DefaultAudioFormat: "mp3",
                        DefaultQuality:     "high",
                        MaxConcurrentJobs:  3,
                },
                BackupSettings: BackupSettings{
                        AutoBackup:       false,
                        BackupInterval:   "weekly",
                        BackupRetention:  30,
                        BackupEncryption: true,
                },
                SecuritySettings: SecuritySettings{
                        TwoFactorEnabled:   false,
                        SessionTimeout:     1440, // 24 hours in minutes
                        RequirePasswordFor: []string{"delete", "share"},
                        LoginNotifications: true,
                },
                ExperimentalFeatures: make(map[string]interface{}),
        }
}</span>

// Analytics and Reporting Models

// MediaAccessLog represents a log entry for media access
type MediaAccessLog struct {
        ID               int            `json:"id" db:"id"`
        UserID           int            `json:"user_id" db:"user_id"`
        MediaID          int            `json:"media_id" db:"media_id"`
        Action           string         `json:"action" db:"action"`
        DeviceInfo       *DeviceInfo    `json:"device_info,omitempty" db:"device_info"`
        Location         *Location      `json:"location,omitempty" db:"location"`
        IPAddress        *string        `json:"ip_address,omitempty" db:"ip_address"`
        UserAgent        *string        `json:"user_agent,omitempty" db:"user_agent"`
        PlaybackDuration *time.Duration `json:"playback_duration,omitempty" db:"playback_duration"`
        AccessTime       time.Time      `json:"access_time" db:"access_time"`
}

// AnalyticsEvent represents a general analytics event
type AnalyticsEvent struct {
        ID            int         `json:"id" db:"id"`
        UserID        int         `json:"user_id" db:"user_id"`
        EventType     string      `json:"event_type" db:"event_type"`
        EventCategory string      `json:"event_category" db:"event_category"`
        Data          string      `json:"data" db:"data"`
        DeviceInfo    *DeviceInfo `json:"device_info,omitempty" db:"device_info"`
        Location      *Location   `json:"location,omitempty" db:"location"`
        IPAddress     *string     `json:"ip_address,omitempty" db:"ip_address"`
        UserAgent     *string     `json:"user_agent,omitempty" db:"user_agent"`
        Timestamp     time.Time   `json:"timestamp" db:"timestamp"`
}

// Location represents geographic coordinates
type Location struct {
        Latitude  float64  `json:"latitude"`
        Longitude float64  `json:"longitude"`
        Country   *string  `json:"country,omitempty"`
        City      *string  `json:"city,omitempty"`
        Accuracy  *float64 `json:"accuracy,omitempty"`
}

// AnalyticsEventRequest represents a request to track an analytics event
type AnalyticsEventRequest struct {
        EventType  string                 `json:"event_type"`
        EntityType string                 `json:"entity_type,omitempty"`
        EntityID   int                    `json:"entity_id,omitempty"`
        Metadata   map[string]interface{} `json:"metadata,omitempty"`
        SessionID  string                 `json:"session_id,omitempty"`
}

// AnalyticsFilters represents filters for analytics queries
type AnalyticsFilters struct {
        StartDate   *time.Time `json:"start_date,omitempty"`
        EndDate     *time.Time `json:"end_date,omitempty"`
        EventTypes  []string   `json:"event_types,omitempty"`
        EntityTypes []string   `json:"entity_types,omitempty"`
        Limit       int        `json:"limit,omitempty"`
        Offset      int        `json:"offset,omitempty"`
}

// AnalyticsData represents aggregated analytics data
type AnalyticsData struct {
        TotalEvents    int64                    `json:"total_events"`
        EventBreakdown map[string]int           `json:"event_breakdown"`
        Trends         map[string][]interface{} `json:"trends"`
        TopEntities    []map[string]interface{} `json:"top_entities"`
}

// DashboardMetrics represents dashboard metrics
type DashboardMetrics struct {
        TotalUsers       int64 `json:"total_users"`
        ActiveUsers      int64 `json:"active_users"`
        TotalMediaItems  int64 `json:"total_media_items"`
        TotalStorageUsed int64 `json:"total_storage_used"`
        RecentActivity   int64 `json:"recent_activity"`
}

// RealtimeMetrics represents realtime metrics
type RealtimeMetrics struct {
        ActiveUsers    int     `json:"active_users"`
        CurrentStreams int     `json:"current_streams"`
        RecentEvents   int     `json:"recent_events"`
        SystemLoad     float64 `json:"system_load"`
}

// ReportRequest represents a request to generate a report
type ReportRequest struct {
        ReportType string                 `json:"report_type"`
        Params     map[string]interface{} `json:"params,omitempty"`
}

// UserAnalytics represents analytics data for a user
type UserAnalytics struct {
        UserID               int                `json:"user_id"`
        StartDate            time.Time          `json:"start_date"`
        EndDate              time.Time          `json:"end_date"`
        TotalMediaAccesses   int                `json:"total_media_accesses"`
        TotalEvents          int                `json:"total_events"`
        UniqueMediaAccessed  int                `json:"unique_media_accessed"`
        TotalPlaybackTime    time.Duration      `json:"total_playback_time"`
        MostAccessedMedia    []MediaAccessCount `json:"most_accessed_media"`
        PreferredAccessTimes map[string]int     `json:"preferred_access_times"`
        DeviceUsage          map[string]int     `json:"device_usage"`
        LocationAnalysis     map[string]int     `json:"location_analysis"`
}

// SystemAnalytics represents system-wide analytics
type SystemAnalytics struct {
        StartDate              time.Time              `json:"start_date"`
        EndDate                time.Time              `json:"end_date"`
        TotalUsers             int                    `json:"total_users"`
        ActiveUsers            int                    `json:"active_users"`
        TotalMediaAccesses     int                    `json:"total_media_accesses"`
        TotalEvents            int                    `json:"total_events"`
        TopAccessedMedia       []MediaAccessCount     `json:"top_accessed_media"`
        UserGrowthData         []UserGrowthPoint      `json:"user_growth_data"`
        AverageSessionDuration time.Duration          `json:"average_session_duration"`
        PeakUsageHours         map[string]int         `json:"peak_usage_hours"`
        PopularFileTypes       map[string]int         `json:"popular_file_types"`
        GeographicDistribution map[string]interface{} `json:"geographic_distribution"`
}

// MediaAnalytics represents analytics for specific media
type MediaAnalytics struct {
        MediaID             int                    `json:"media_id"`
        StartDate           time.Time              `json:"start_date"`
        EndDate             time.Time              `json:"end_date"`
        TotalAccesses       int                    `json:"total_accesses"`
        UniqueUsers         int                    `json:"unique_users"`
        TotalPlaybackTime   time.Duration          `json:"total_playback_time"`
        AveragePlaybackTime time.Duration          `json:"average_playback_time"`
        AccessPatterns      map[string]interface{} `json:"access_patterns"`
        UserRetention       float64                `json:"user_retention"`
        PopularTimeRanges   map[string]int         `json:"popular_time_ranges"`
        DevicePreferences   map[string]int         `json:"device_preferences"`
}

// MediaAccessCount represents media access statistics
type MediaAccessCount struct {
        MediaID     int `json:"media_id"`
        AccessCount int `json:"access_count"`
}

// UserGrowthPoint represents a point in user growth data
type UserGrowthPoint struct {
        Date      time.Time `json:"date"`
        UserCount int       `json:"user_count"`
}

// SessionData represents session information for analytics
type SessionData struct {
        UserID    int           `json:"user_id"`
        StartTime time.Time     `json:"start_time"`
        EndTime   time.Time     `json:"end_time"`
        Duration  time.Duration `json:"duration"`
}

// AnalyticsReport represents a generated analytics report
type AnalyticsReport struct {
        Type      string    `json:"type"`
        Data      string    `json:"data"`
        CreatedAt time.Time `json:"created_at"`
        Status    string    `json:"status"`
}

// Favorites Models

// Favorite represents a user's favorite item
type Favorite struct {
        ID         int        `json:"id" db:"id"`
        UserID     int        `json:"user_id" db:"user_id"`
        EntityType string     `json:"entity_type" db:"entity_type"`
        EntityID   int        `json:"entity_id" db:"entity_id"`
        Category   *string    `json:"category,omitempty" db:"category"`
        Notes      *string    `json:"notes,omitempty" db:"notes"`
        Tags       *[]string  `json:"tags,omitempty" db:"tags"`
        IsPublic   bool       `json:"is_public" db:"is_public"`
        CreatedAt  time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt  *time.Time `json:"updated_at,omitempty" db:"updated_at"`
}

// FavoriteCategory represents a category for organizing favorites
type FavoriteCategory struct {
        ID          int        `json:"id" db:"id"`
        UserID      int        `json:"user_id" db:"user_id"`
        Name        string     `json:"name" db:"name"`
        Description *string    `json:"description,omitempty" db:"description"`
        Color       *string    `json:"color,omitempty" db:"color"`
        Icon        *string    `json:"icon,omitempty" db:"icon"`
        IsPublic    bool       `json:"is_public" db:"is_public"`
        CreatedAt   time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt   *time.Time `json:"updated_at,omitempty" db:"updated_at"`
}

// FavoriteShare represents sharing of favorites between users
type FavoriteShare struct {
        ID           int              `json:"id" db:"id"`
        FavoriteID   int              `json:"favorite_id" db:"favorite_id"`
        SharedByUser int              `json:"shared_by_user" db:"shared_by_user"`
        SharedWith   []int            `json:"shared_with" db:"shared_with"`
        Permissions  SharePermissions `json:"permissions" db:"permissions"`
        CreatedAt    time.Time        `json:"created_at" db:"created_at"`
        IsActive     bool             `json:"is_active" db:"is_active"`
}

// SharePermissions represents permissions for shared favorites
type SharePermissions struct {
        CanView   bool `json:"can_view"`
        CanEdit   bool `json:"can_edit"`
        CanDelete bool `json:"can_delete"`
        CanShare  bool `json:"can_share"`
}

// FavoriteStatistics represents statistics about user's favorites
type FavoriteStatistics struct {
        UserID                int            `json:"user_id"`
        TotalFavorites        int            `json:"total_favorites"`
        FavoritesByEntityType map[string]int `json:"favorites_by_entity_type"`
        FavoritesByCategory   map[string]int `json:"favorites_by_category"`
        RecentFavorites       []Favorite     `json:"recent_favorites"`
}

// RecommendedFavorite represents a recommended favorite item
type RecommendedFavorite struct {
        Favorite        Favorite  `json:"favorite"`
        RecommendReason string    `json:"recommend_reason"`
        RecommendScore  float64   `json:"recommend_score"`
        RecommendedAt   time.Time `json:"recommended_at"`
}

// Request/Response Models

// UpdateFavoriteRequest represents a request to update a favorite
type UpdateFavoriteRequest struct {
        Category *string   `json:"category,omitempty"`
        Notes    *string   `json:"notes,omitempty"`
        Tags     *[]string `json:"tags,omitempty"`
        IsPublic *bool     `json:"is_public,omitempty"`
}

// UpdateFavoriteCategoryRequest represents a request to update a favorite category
type UpdateFavoriteCategoryRequest struct {
        Name        string  `json:"name,omitempty"`
        Description *string `json:"description,omitempty"`
        Color       *string `json:"color,omitempty"`
        Icon        *string `json:"icon,omitempty"`
        IsPublic    *bool   `json:"is_public,omitempty"`
}

// BulkFavoriteRequest represents a request to add multiple favorites
type BulkFavoriteRequest struct {
        EntityType string    `json:"entity_type"`
        EntityID   int       `json:"entity_id"`
        Category   *string   `json:"category,omitempty"`
        Notes      *string   `json:"notes,omitempty"`
        Tags       *[]string `json:"tags,omitempty"`
        IsPublic   bool      `json:"is_public"`
}

// BulkFavoriteRemoveRequest represents a request to remove multiple favorites
type BulkFavoriteRemoveRequest struct {
        EntityType string `json:"entity_type"`
        EntityID   int    `json:"entity_id"`
}

// Reporting Models

// GeneratedReport represents a generated report
type GeneratedReport struct {
        Type        string                 `json:"type"`
        Format      string                 `json:"format"`
        Content     []byte                 `json:"content"`
        GeneratedAt time.Time              `json:"generated_at"`
        Parameters  map[string]interface{} `json:"parameters"`
}

// UserAnalyticsReport represents a user analytics report
type UserAnalyticsReport struct {
        User               *User                  `json:"user"`
        StartDate          time.Time              `json:"start_date"`
        EndDate            time.Time              `json:"end_date"`
        TotalMediaAccesses int                    `json:"total_media_accesses"`
        TotalEvents        int                    `json:"total_events"`
        MediaAccessLogs    []MediaAccessLog       `json:"media_access_logs"`
        Events             []AnalyticsEvent       `json:"events"`
        AccessPatterns     map[string]interface{} `json:"access_patterns"`
        DeviceUsage        map[string]int         `json:"device_usage"`
        LocationAnalysis   map[string]int         `json:"location_analysis"`
        TimePatterns       map[string]interface{} `json:"time_patterns"`
        PopularContent     []MediaAccessCount     `json:"popular_content"`
}

// SystemOverviewReport represents a system overview report
type SystemOverviewReport struct {
        StartDate          time.Time          `json:"start_date"`
        EndDate            time.Time          `json:"end_date"`
        TotalUsers         int                `json:"total_users"`
        ActiveUsers        int                `json:"active_users"`
        TotalMediaAccesses int                `json:"total_media_accesses"`
        TotalEvents        int                `json:"total_events"`
        TopAccessedMedia   []MediaAccessCount `json:"top_accessed_media"`
        UserGrowthData     []UserGrowthPoint  `json:"user_growth_data"`
        SystemHealth       SystemHealth       `json:"system_health"`
        UsageStatistics    UsageStatistics    `json:"usage_statistics"`
        PerformanceMetrics PerformanceMetrics `json:"performance_metrics"`
}

// MediaAnalyticsReport represents a media analytics report
type MediaAnalyticsReport struct {
        MediaID        int                    `json:"media_id"`
        StartDate      time.Time              `json:"start_date"`
        EndDate        time.Time              `json:"end_date"`
        TotalAccesses  int                    `json:"total_accesses"`
        UniqueUsers    int                    `json:"unique_users"`
        AccessLogs     []MediaAccessLog       `json:"access_logs"`
        AccessPatterns map[string]interface{} `json:"access_patterns"`
        UserEngagement UserEngagement         `json:"user_engagement"`
        GeographicData map[string]int         `json:"geographic_data"`
        DeviceAnalysis map[string]int         `json:"device_analysis"`
        TimeAnalysis   map[string]int         `json:"time_analysis"`
}

// UserActivityReport represents a user activity report
type UserActivityReport struct {
        StartDate      time.Time             `json:"start_date"`
        EndDate        time.Time             `json:"end_date"`
        UserActivities []UserActivitySummary `json:"user_activities"`
        TotalUsers     int                   `json:"total_users"`
        TotalAccesses  int                   `json:"total_accesses"`
        Summary        ActivitySummary       `json:"summary"`
}

// SecurityAuditReport represents a security audit report
type SecurityAuditReport struct {
        StartDate           time.Time          `json:"start_date"`
        EndDate             time.Time          `json:"end_date"`
        FailedLoginAttempts int                `json:"failed_login_attempts"`
        SuccessfulLogins    int                `json:"successful_logins"`
        SuspiciousActivity  []SecurityIncident `json:"suspicious_activity"`
        SecurityMetrics     SecurityMetrics    `json:"security_metrics"`
}

// PerformanceMetricsReport represents a performance metrics report
type PerformanceMetricsReport struct {
        StartDate              time.Time     `json:"start_date"`
        EndDate                time.Time     `json:"end_date"`
        AverageSessionDuration time.Duration `json:"average_session_duration"`
        TotalSessions          int           `json:"total_sessions"`
        ResponseTimes          ResponseTimes `json:"response_times"`
        SystemLoad             SystemLoad    `json:"system_load"`
        ErrorRates             ErrorRates    `json:"error_rates"`
}

// Supporting Types for Reports

type SystemHealthScore struct {
        Score  float64 `json:"score"`
        Status string  `json:"status"`
}

type UsageStatistics struct {
        PeakHours    []int   `json:"peak_hours"`
        AverageDaily int     `json:"average_daily"`
        GrowthRate   float64 `json:"growth_rate"`
}

type PerformanceMetrics struct {
        ResponseTime float64 `json:"response_time"`
        Throughput   int     `json:"throughput"`
        ErrorRate    float64 `json:"error_rate"`
}

type UserEngagement struct {
        AverageSessionTime float64 `json:"average_session_time"`
        ReturnRate         float64 `json:"return_rate"`
        InteractionDepth   float64 `json:"interaction_depth"`
}

type UserActivitySummary struct {
        User              *User     `json:"user"`
        TotalAccesses     int       `json:"total_accesses"`
        LastActivity      time.Time `json:"last_activity"`
        MostActiveHour    int       `json:"most_active_hour"`
        PreferredDevices  []string  `json:"preferred_devices"`
        AccessedLocations []string  `json:"accessed_locations"`
}

type ActivitySummary struct {
        TotalUsers       int     `json:"total_users"`
        TotalAccesses    int     `json:"total_accesses"`
        AverageAccesses  float64 `json:"average_accesses"`
        MostActiveUsers  int     `json:"most_active_users"`
        LeastActiveUsers int     `json:"least_active_users"`
}

type SecurityIncident struct {
        Type        string    `json:"type"`
        Description string    `json:"description"`
        Severity    string    `json:"severity"`
        UserID      *int      `json:"user_id,omitempty"`
        IPAddress   *string   `json:"ip_address,omitempty"`
        Timestamp   time.Time `json:"timestamp"`
}

type SecurityMetrics struct {
        ThreatLevel        string  `json:"threat_level"`
        VulnerabilityCount int     `json:"vulnerability_count"`
        SecurityScore      float64 `json:"security_score"`
}

type ResponseTimes struct {
        Average float64 `json:"average"`
        Min     float64 `json:"min"`
        Max     float64 `json:"max"`
        P95     float64 `json:"p95"`
        P99     float64 `json:"p99"`
}

type SystemLoad struct {
        CPU     float64 `json:"cpu"`
        Memory  float64 `json:"memory"`
        Disk    float64 `json:"disk"`
        Network float64 `json:"network"`
}

type ErrorRates struct {
        HTTP4xx  float64 `json:"http_4xx"`
        HTTP5xx  float64 `json:"http_5xx"`
        Timeouts float64 `json:"timeouts"`
        Total    float64 `json:"total"`
}

// Conversion Models

// ConversionJob represents a media conversion job
type ConversionJob struct {
        ID             int            `json:"id" db:"id"`
        UserID         int            `json:"user_id" db:"user_id"`
        SourcePath     string         `json:"source_path" db:"source_path"`
        TargetPath     string         `json:"target_path" db:"target_path"`
        SourceFormat   string         `json:"source_format" db:"source_format"`
        TargetFormat   string         `json:"target_format" db:"target_format"`
        ConversionType string         `json:"conversion_type" db:"conversion_type"`
        Quality        string         `json:"quality" db:"quality"`
        Settings       *string        `json:"settings,omitempty" db:"settings"`
        Priority       int            `json:"priority" db:"priority"`
        Status         string         `json:"status" db:"status"`
        CreatedAt      time.Time      `json:"created_at" db:"created_at"`
        StartedAt      *time.Time     `json:"started_at,omitempty" db:"started_at"`
        CompletedAt    *time.Time     `json:"completed_at,omitempty" db:"completed_at"`
        ScheduledFor   *time.Time     `json:"scheduled_for,omitempty" db:"scheduled_for"`
        Duration       *time.Duration `json:"duration,omitempty" db:"duration"`
        ErrorMessage   *string        `json:"error_message,omitempty" db:"error_message"`
}

// ConversionRequest represents a request to create a conversion job
type ConversionRequest struct {
        SourcePath     string     `json:"source_path"`
        TargetPath     string     `json:"target_path"`
        SourceFormat   string     `json:"source_format"`
        TargetFormat   string     `json:"target_format"`
        ConversionType string     `json:"conversion_type"`
        Quality        string     `json:"quality"`
        Settings       *string    `json:"settings,omitempty"`
        Priority       int        `json:"priority"`
        ScheduledFor   *time.Time `json:"scheduled_for,omitempty"`
}

// ConversionStatistics represents conversion statistics
type ConversionStatistics struct {
        StartDate       time.Time      `json:"start_date"`
        EndDate         time.Time      `json:"end_date"`
        TotalJobs       int            `json:"total_jobs"`
        ByStatus        map[string]int `json:"by_status"`
        ByType          map[string]int `json:"by_type"`
        ByFormat        map[string]int `json:"by_format"`
        AverageDuration *time.Duration `json:"average_duration,omitempty"`
        SuccessRate     float64        `json:"success_rate"`
}

// SupportedFormats represents supported conversion formats
type SupportedFormats struct {
        Video    VideoFormats    `json:"video"`
        Audio    AudioFormats    `json:"audio"`
        Document DocumentFormats `json:"document"`
        Image    ImageFormats    `json:"image"`
}

// VideoFormats represents supported video formats
type VideoFormats struct {
        Input  []string `json:"input"`
        Output []string `json:"output"`
}

// AudioFormats represents supported audio formats
type AudioFormats struct {
        Input  []string `json:"input"`
        Output []string `json:"output"`
}

// DocumentFormats represents supported document formats
type DocumentFormats struct {
        Input  []string `json:"input"`
        Output []string `json:"output"`
}

// ImageFormats represents supported image formats
type ImageFormats struct {
        Input  []string `json:"input"`
        Output []string `json:"output"`
}

// FormatPopularity represents format usage statistics
type FormatPopularity struct {
        Format string `json:"format"`
        Count  int    `json:"count"`
}

// Conversion Status Constants
const (
        ConversionStatusPending   = "pending"
        ConversionStatusRunning   = "running"
        ConversionStatusCompleted = "completed"
        ConversionStatusFailed    = "failed"
        ConversionStatusCancelled = "cancelled"
)

// Conversion Type Constants
const (
        ConversionTypeVideo    = "video"
        ConversionTypeAudio    = "audio"
        ConversionTypeDocument = "document"
        ConversionTypeImage    = "image"
)

// Sync and Backup Models

// SyncEndpoint represents a sync endpoint configuration
type SyncEndpoint struct {
        ID            int        `json:"id" db:"id"`
        UserID        int        `json:"user_id" db:"user_id"`
        Name          string     `json:"name" db:"name"`
        Type          string     `json:"type" db:"type"`
        URL           string     `json:"url" db:"url"`
        Username      string     `json:"username" db:"username"`
        Password      string     `json:"-" db:"password"` // Never include in JSON
        SyncDirection string     `json:"sync_direction" db:"sync_direction"`
        LocalPath     string     `json:"local_path" db:"local_path"`
        RemotePath    string     `json:"remote_path" db:"remote_path"`
        SyncSettings  *string    `json:"sync_settings,omitempty" db:"sync_settings"`
        Status        string     `json:"status" db:"status"`
        CreatedAt     time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt     time.Time  `json:"updated_at" db:"updated_at"`
        LastSyncAt    *time.Time `json:"last_sync_at,omitempty" db:"last_sync_at"`
}

// SyncSession represents a sync session
type SyncSession struct {
        ID           int            `json:"id" db:"id"`
        EndpointID   int            `json:"endpoint_id" db:"endpoint_id"`
        UserID       int            `json:"user_id" db:"user_id"`
        Status       string         `json:"status" db:"status"`
        SyncType     string         `json:"sync_type" db:"sync_type"`
        StartedAt    time.Time      `json:"started_at" db:"started_at"`
        CompletedAt  *time.Time     `json:"completed_at,omitempty" db:"completed_at"`
        Duration     *time.Duration `json:"duration,omitempty" db:"duration"`
        TotalFiles   int            `json:"total_files" db:"total_files"`
        SyncedFiles  int            `json:"synced_files" db:"synced_files"`
        FailedFiles  int            `json:"failed_files" db:"failed_files"`
        SkippedFiles int            `json:"skipped_files" db:"skipped_files"`
        ErrorMessage *string        `json:"error_message,omitempty" db:"error_message"`
}

// SyncSchedule represents a scheduled sync
type SyncSchedule struct {
        ID         int        `json:"id" db:"id"`
        EndpointID int        `json:"endpoint_id" db:"endpoint_id"`
        UserID     int        `json:"user_id" db:"user_id"`
        Frequency  string     `json:"frequency" db:"frequency"`
        LastRun    *time.Time `json:"last_run,omitempty" db:"last_run"`
        NextRun    *time.Time `json:"next_run,omitempty" db:"next_run"`
        IsActive   bool       `json:"is_active" db:"is_active"`
        CreatedAt  time.Time  `json:"created_at" db:"created_at"`
}

// SyncStatistics represents sync statistics
type SyncStatistics struct {
        StartDate        time.Time      `json:"start_date"`
        EndDate          time.Time      `json:"end_date"`
        TotalSessions    int            `json:"total_sessions"`
        TotalFilesSynced int            `json:"total_files_synced"`
        TotalFilesFailed int            `json:"total_files_failed"`
        ByStatus         map[string]int `json:"by_status"`
        ByType           map[string]int `json:"by_type"`
        AverageDuration  *time.Duration `json:"average_duration,omitempty"`
        SuccessRate      float64        `json:"success_rate"`
}

// UpdateSyncEndpointRequest represents a request to update a sync endpoint
type UpdateSyncEndpointRequest struct {
        Name          string  `json:"name,omitempty"`
        URL           string  `json:"url,omitempty"`
        Username      string  `json:"username,omitempty"`
        Password      string  `json:"password,omitempty"`
        SyncDirection string  `json:"sync_direction,omitempty"`
        LocalPath     string  `json:"local_path,omitempty"`
        RemotePath    string  `json:"remote_path,omitempty"`
        SyncSettings  *string `json:"sync_settings,omitempty"`
        IsActive      *bool   `json:"is_active,omitempty"`
}

// Sync Status Constants
const (
        SyncStatusActive   = "active"
        SyncStatusInactive = "inactive"
        SyncStatusError    = "error"
)

// Sync Session Status Constants
const (
        SyncSessionStatusRunning   = "running"
        SyncSessionStatusCompleted = "completed"
        SyncSessionStatusFailed    = "failed"
        SyncSessionStatusCancelled = "cancelled"
)

// Sync Type Constants
const (
        SyncTypeWebDAV       = "webdav"
        SyncTypeCloudStorage = "cloud_storage"
        SyncTypeLocal        = "local"
        SyncTypeManual       = "manual"
        SyncTypeScheduled    = "scheduled"
)

// Sync Direction Constants
const (
        SyncDirectionUpload        = "upload"
        SyncDirectionDownload      = "download"
        SyncDirectionBidirectional = "bidirectional"
)

// Sync Frequency Constants
const (
        SyncFrequencyHourly  = "hourly"
        SyncFrequencyDaily   = "daily"
        SyncFrequencyWeekly  = "weekly"
        SyncFrequencyMonthly = "monthly"
)

// Error and Crash Reporting Models

// ErrorReport represents an error report
type ErrorReport struct {
        ID          int                    `json:"id" db:"id"`
        UserID      int                    `json:"user_id" db:"user_id"`
        Level       string                 `json:"level" db:"level"`
        Message     string                 `json:"message" db:"message"`
        ErrorCode   string                 `json:"error_code" db:"error_code"`
        Component   string                 `json:"component" db:"component"`
        StackTrace  string                 `json:"stack_trace" db:"stack_trace"`
        Context     map[string]interface{} `json:"context" db:"context"`
        SystemInfo  map[string]interface{} `json:"system_info" db:"system_info"`
        UserAgent   string                 `json:"user_agent" db:"user_agent"`
        URL         string                 `json:"url" db:"url"`
        Fingerprint string                 `json:"fingerprint" db:"fingerprint"`
        Status      string                 `json:"status" db:"status"`
        ReportedAt  time.Time              `json:"reported_at" db:"reported_at"`
        ResolvedAt  *time.Time             `json:"resolved_at,omitempty" db:"resolved_at"`
}

// CrashReport represents a crash report
type CrashReport struct {
        ID          int                    `json:"id" db:"id"`
        UserID      int                    `json:"user_id" db:"user_id"`
        Signal      string                 `json:"signal" db:"signal"`
        Message     string                 `json:"message" db:"message"`
        StackTrace  string                 `json:"stack_trace" db:"stack_trace"`
        Context     map[string]interface{} `json:"context" db:"context"`
        SystemInfo  map[string]interface{} `json:"system_info" db:"system_info"`
        Fingerprint string                 `json:"fingerprint" db:"fingerprint"`
        Status      string                 `json:"status" db:"status"`
        ReportedAt  time.Time              `json:"reported_at" db:"reported_at"`
        ResolvedAt  *time.Time             `json:"resolved_at,omitempty" db:"resolved_at"`
}

// ErrorReportRequest represents a request to create an error report
type ErrorReportRequest struct {
        Level      string                 `json:"level" validate:"required"`
        Message    string                 `json:"message" validate:"required"`
        ErrorCode  string                 `json:"error_code,omitempty"`
        Component  string                 `json:"component,omitempty"`
        StackTrace string                 `json:"stack_trace,omitempty"`
        Context    map[string]interface{} `json:"context,omitempty"`
        UserAgent  string                 `json:"user_agent,omitempty"`
        URL        string                 `json:"url,omitempty"`
}

// CrashReportRequest represents a request to create a crash report
type CrashReportRequest struct {
        Signal     string                 `json:"signal" validate:"required"`
        Message    string                 `json:"message" validate:"required"`
        StackTrace string                 `json:"stack_trace,omitempty"`
        Context    map[string]interface{} `json:"context,omitempty"`
}

// ErrorReportFilters represents filters for error report queries
type ErrorReportFilters struct {
        Level     string     `json:"level,omitempty"`
        Component string     `json:"component,omitempty"`
        Status    string     `json:"status,omitempty"`
        StartDate *time.Time `json:"start_date,omitempty"`
        EndDate   *time.Time `json:"end_date,omitempty"`
        Limit     int        `json:"limit,omitempty"`
        Offset    int        `json:"offset,omitempty"`
}

// CrashReportFilters represents filters for crash report queries
type CrashReportFilters struct {
        Signal    string     `json:"signal,omitempty"`
        Status    string     `json:"status,omitempty"`
        StartDate *time.Time `json:"start_date,omitempty"`
        EndDate   *time.Time `json:"end_date,omitempty"`
        Limit     int        `json:"limit,omitempty"`
        Offset    int        `json:"offset,omitempty"`
}

// ExportFilters represents filters for report export
type ExportFilters struct {
        Format         string     `json:"format"`
        Level          string     `json:"level,omitempty"`
        Component      string     `json:"component,omitempty"`
        Signal         string     `json:"signal,omitempty"`
        StartDate      *time.Time `json:"start_date,omitempty"`
        EndDate        *time.Time `json:"end_date,omitempty"`
        Limit          int        `json:"limit,omitempty"`
        IncludeErrors  bool       `json:"include_errors"`
        IncludeCrashes bool       `json:"include_crashes"`
}

// ErrorStatistics represents error reporting statistics
type ErrorStatistics struct {
        TotalErrors       int            `json:"total_errors"`
        ErrorsByLevel     map[string]int `json:"errors_by_level"`
        ErrorsByComponent map[string]int `json:"errors_by_component"`
        RecentErrors      int            `json:"recent_errors"`
        ResolvedErrors    int            `json:"resolved_errors"`
        AvgResolutionTime float64        `json:"avg_resolution_time"`
}

// CrashStatistics represents crash reporting statistics
type CrashStatistics struct {
        TotalCrashes      int            `json:"total_crashes"`
        CrashesBySignal   map[string]int `json:"crashes_by_signal"`
        RecentCrashes     int            `json:"recent_crashes"`
        ResolvedCrashes   int            `json:"resolved_crashes"`
        AvgResolutionTime float64        `json:"avg_resolution_time"`
        CrashRate         float64        `json:"crash_rate"`
}

// SystemHealth represents system health status
type SystemHealth struct {
        Score     float64                `json:"score"`
        Status    string                 `json:"status"`
        CheckedAt time.Time              `json:"checked_at"`
        Metrics   map[string]interface{} `json:"metrics"`
}

// TopError represents frequently occurring errors
type TopError struct {
        Fingerprint string    `json:"fingerprint"`
        Count       int       `json:"count"`
        LastSeen    time.Time `json:"last_seen"`
        FirstSeen   time.Time `json:"first_seen"`
        Message     string    `json:"message"`
        Component   string    `json:"component"`
        Level       string    `json:"level"`
}

// TopCrash represents frequently occurring crashes
type TopCrash struct {
        Fingerprint string    `json:"fingerprint"`
        Count       int       `json:"count"`
        LastSeen    time.Time `json:"last_seen"`
        FirstSeen   time.Time `json:"first_seen"`
        Message     string    `json:"message"`
        Signal      string    `json:"signal"`
}

// CrashTrend represents crash trends over time
type CrashTrend struct {
        Date  time.Time `json:"date"`
        Count int       `json:"count"`
}

// Error Status Constants
const (
        ErrorStatusNew        = "new"
        ErrorStatusInProgress = "in_progress"
        ErrorStatusResolved   = "resolved"
        ErrorStatusIgnored    = "ignored"
)

// Crash Status Constants
const (
        CrashStatusNew        = "new"
        CrashStatusInProgress = "in_progress"
        CrashStatusResolved   = "resolved"
        CrashStatusIgnored    = "ignored"
)

// Error Level Constants
const (
        ErrorLevelDebug   = "debug"
        ErrorLevelInfo    = "info"
        ErrorLevelWarning = "warning"
        ErrorLevelError   = "error"
        ErrorLevelFatal   = "fatal"
)

// Signal Constants
const (
        SignalSIGABRT = "SIGABRT"
        SignalSIGFPE  = "SIGFPE"
        SignalSIGILL  = "SIGILL"
        SignalSIGINT  = "SIGINT"
        SignalSIGSEGV = "SIGSEGV"
        SignalSIGTERM = "SIGTERM"
)

// Log Management Models

// LogCollection represents a collection of logs
type LogCollection struct {
        ID          int                    `json:"id" db:"id"`
        UserID      int                    `json:"user_id" db:"user_id"`
        Name        string                 `json:"name" db:"name"`
        Description string                 `json:"description" db:"description"`
        Components  []string               `json:"components" db:"components"`
        LogLevel    string                 `json:"log_level" db:"log_level"`
        StartTime   *time.Time             `json:"start_time,omitempty" db:"start_time"`
        EndTime     *time.Time             `json:"end_time,omitempty" db:"end_time"`
        CreatedAt   time.Time              `json:"created_at" db:"created_at"`
        CompletedAt *time.Time             `json:"completed_at,omitempty" db:"completed_at"`
        Status      string                 `json:"status" db:"status"`
        EntryCount  int                    `json:"entry_count" db:"entry_count"`
        Filters     map[string]interface{} `json:"filters,omitempty" db:"filters"`
}

// LogEntry represents a single log entry
type LogEntry struct {
        ID           int                    `json:"id" db:"id"`
        CollectionID int                    `json:"collection_id" db:"collection_id"`
        Timestamp    time.Time              `json:"timestamp" db:"timestamp"`
        Level        string                 `json:"level" db:"level"`
        Component    string                 `json:"component" db:"component"`
        Message      string                 `json:"message" db:"message"`
        Context      map[string]interface{} `json:"context,omitempty" db:"context"`
}

// LogShare represents a shared log collection
type LogShare struct {
        ID           int        `json:"id" db:"id"`
        CollectionID int        `json:"collection_id" db:"collection_id"`
        UserID       int        `json:"user_id" db:"user_id"`
        ShareToken   string     `json:"share_token" db:"share_token"`
        ShareType    string     `json:"share_type" db:"share_type"`
        ExpiresAt    time.Time  `json:"expires_at" db:"expires_at"`
        CreatedAt    time.Time  `json:"created_at" db:"created_at"`
        AccessedAt   *time.Time `json:"accessed_at,omitempty" db:"accessed_at"`
        IsActive     bool       `json:"is_active" db:"is_active"`
        Permissions  []string   `json:"permissions" db:"permissions"`
        Recipients   []string   `json:"recipients,omitempty" db:"recipients"`
}

// LogCollectionRequest represents a request to create a log collection
type LogCollectionRequest struct {
        Name        string                 `json:"name" validate:"required"`
        Description string                 `json:"description,omitempty"`
        Components  []string               `json:"components" validate:"required"`
        LogLevel    string                 `json:"log_level,omitempty"`
        StartTime   *time.Time             `json:"start_time,omitempty"`
        EndTime     *time.Time             `json:"end_time,omitempty"`
        Filters     map[string]interface{} `json:"filters,omitempty"`
}

// LogShareRequest represents a request to create a log share
type LogShareRequest struct {
        CollectionID int        `json:"collection_id" validate:"required"`
        ShareType    string     `json:"share_type" validate:"required"`
        ExpiresAt    *time.Time `json:"expires_at,omitempty"`
        Permissions  []string   `json:"permissions" validate:"required"`
        Recipients   []string   `json:"recipients,omitempty"`
}

// LogEntryFilters represents filters for log entry queries
type LogEntryFilters struct {
        Level     string     `json:"level,omitempty"`
        Component string     `json:"component,omitempty"`
        Search    string     `json:"search,omitempty"`
        StartTime *time.Time `json:"start_time,omitempty"`
        EndTime   *time.Time `json:"end_time,omitempty"`
        Limit     int        `json:"limit,omitempty"`
        Offset    int        `json:"offset,omitempty"`
}

// LogStreamFilters represents filters for log streaming
type LogStreamFilters struct {
        Level     string `json:"level,omitempty"`
        Component string `json:"component,omitempty"`
        Search    string `json:"search,omitempty"`
}

// LogAnalysis represents log analysis results
type LogAnalysis struct {
        CollectionID       int            `json:"collection_id"`
        TotalEntries       int            `json:"total_entries"`
        EntriesByLevel     map[string]int `json:"entries_by_level"`
        EntriesByComponent map[string]int `json:"entries_by_component"`
        ErrorPatterns      map[string]int `json:"error_patterns"`
        TimeRange          *TimeRange     `json:"time_range"`
        Insights           []string       `json:"insights"`
}

// TimeRange represents a time range
type TimeRange struct {
        Start time.Time `json:"start"`
        End   time.Time `json:"end"`
}

// LogStatistics represents log management statistics
type LogStatistics struct {
        TotalCollections    int            `json:"total_collections"`
        TotalEntries        int            `json:"total_entries"`
        ActiveShares        int            `json:"active_shares"`
        CollectionsByStatus map[string]int `json:"collections_by_status"`
        RecentCollections   int            `json:"recent_collections"`
}

// Log Collection Status Constants
const (
        LogCollectionStatusPending    = "pending"
        LogCollectionStatusInProgress = "in_progress"
        LogCollectionStatusCompleted  = "completed"
        LogCollectionStatusFailed     = "failed"
)

// Log Share Type Constants
const (
        LogShareTypePublic   = "public"
        LogShareTypePrivate  = "private"
        LogShareTypeInternal = "internal"
)

// Log Level Constants
const (
        LogLevelDebug   = "debug"
        LogLevelInfo    = "info"
        LogLevelWarning = "warning"
        LogLevelError   = "error"
        LogLevelFatal   = "fatal"
)

// Configuration and Installer Models

// SystemConfiguration represents the complete system configuration
type SystemConfiguration struct {
        Version          string                  `json:"version" db:"version"`
        CreatedAt        time.Time               `json:"created_at" db:"created_at"`
        UpdatedAt        time.Time               `json:"updated_at" db:"updated_at"`
        Database         *DatabaseConfig         `json:"database,omitempty"`
        Storage          *StorageConfig          `json:"storage,omitempty"`
        Network          *NetworkConfig          `json:"network,omitempty"`
        Authentication   *AuthenticationConfig   `json:"authentication,omitempty"`
        Features         *FeatureConfig          `json:"features,omitempty"`
        ExternalServices *ExternalServicesConfig `json:"external_services,omitempty"`
}

// DatabaseConfig represents database configuration
type DatabaseConfig struct {
        Type     string `json:"type"`
        Host     string `json:"host,omitempty"`
        Port     int    `json:"port,omitempty"`
        Name     string `json:"name"`
        Username string `json:"username,omitempty"`
        Password string `json:"password,omitempty"`
}

// StorageConfig represents storage configuration
type StorageConfig struct {
        MediaDirectory     string `json:"media_directory"`
        ThumbnailDirectory string `json:"thumbnail_directory"`
        TempDirectory      string `json:"temp_directory"`
        MaxFileSize        int64  `json:"max_file_size"`
        StorageQuota       int64  `json:"storage_quota,omitempty"`
}

// NetworkConfig represents network configuration
type NetworkConfig struct {
        Host  string       `json:"host"`
        Port  int          `json:"port"`
        HTTPS *HTTPSConfig `json:"https,omitempty"`
        CORS  *CORSConfig  `json:"cors,omitempty"`
}

// HTTPSConfig represents HTTPS configuration
type HTTPSConfig struct {
        Enabled  bool   `json:"enabled"`
        CertPath string `json:"cert_path,omitempty"`
        KeyPath  string `json:"key_path,omitempty"`
}

// CORSConfig represents CORS configuration
type CORSConfig struct {
        AllowedOrigins []string `json:"allowed_origins"`
        AllowedMethods []string `json:"allowed_methods,omitempty"`
        AllowedHeaders []string `json:"allowed_headers,omitempty"`
}

// AuthenticationConfig represents authentication configuration
type AuthenticationConfig struct {
        JWTSecret                string        `json:"jwt_secret"`
        SessionTimeout           time.Duration `json:"session_timeout"`
        EnableRegistration       bool          `json:"enable_registration"`
        RequireEmailVerification bool          `json:"require_email_verification"`
        AdminEmail               string        `json:"admin_email,omitempty"`
}

// FeatureConfig represents feature toggles
type FeatureConfig struct {
        MediaConversion bool `json:"media_conversion"`
        WebDAVSync      bool `json:"webdav_sync"`
        StressTesting   bool `json:"stress_testing"`
        ErrorReporting  bool `json:"error_reporting"`
        LogManagement   bool `json:"log_management"`
}

// ExternalServicesConfig represents external service configurations
type ExternalServicesConfig struct {
        SMTP      *SMTPConfig  `json:"smtp,omitempty"`
        Slack     *SlackConfig `json:"slack,omitempty"`
        Analytics bool         `json:"analytics"`
}

// SMTPConfig represents SMTP configuration
type SMTPConfig struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Username string `json:"username"`
        Password string `json:"password"`
}

// SlackConfig represents Slack integration configuration
type SlackConfig struct {
        WebhookURL string `json:"webhook_url"`
}

// WizardStep represents a setup wizard step
type WizardStep struct {
        ID           string                 `json:"id"`
        Name         string                 `json:"name"`
        Description  string                 `json:"description"`
        Type         string                 `json:"type"`
        Required     bool                   `json:"required"`
        Order        int                    `json:"order"`
        Fields       []*WizardField         `json:"fields,omitempty"`
        Content      map[string]interface{} `json:"content,omitempty"`
        Validation   map[string]interface{} `json:"validation,omitempty"`
        Dependencies []string               `json:"dependencies,omitempty"`
}

// WizardField represents a field in a wizard step
type WizardField struct {
        Name         string                 `json:"name"`
        Label        string                 `json:"label"`
        Type         string                 `json:"type"`
        Required     bool                   `json:"required"`
        DefaultValue interface{}            `json:"default_value,omitempty"`
        Options      []string               `json:"options,omitempty"`
        Validation   map[string]interface{} `json:"validation,omitempty"`
        ShowWhen     map[string]interface{} `json:"show_when,omitempty"`
        Generate     bool                   `json:"generate,omitempty"`
}

// WizardProgress represents wizard completion progress
type WizardProgress struct {
        UserID      int                    `json:"user_id" db:"user_id"`
        CurrentStep string                 `json:"current_step" db:"current_step"`
        StepData    map[string]interface{} `json:"step_data" db:"step_data"`
        AllData     map[string]interface{} `json:"all_data" db:"all_data"`
        UpdatedAt   time.Time              `json:"updated_at" db:"updated_at"`
}

// WizardStepValidation represents validation results for a wizard step
type WizardStepValidation struct {
        StepID   string            `json:"step_id"`
        Valid    bool              `json:"valid"`
        Errors   map[string]string `json:"errors"`
        Warnings map[string]string `json:"warnings"`
}

// ConfigurationSchema represents the configuration schema
type ConfigurationSchema struct {
        Version  string           `json:"version"`
        Sections []*ConfigSection `json:"sections"`
}

// ConfigSection represents a configuration section
type ConfigSection struct {
        Name        string         `json:"name"`
        Key         string         `json:"key"`
        Description string         `json:"description"`
        Fields      []*ConfigField `json:"fields"`
}

// ConfigField represents a configuration field
type ConfigField struct {
        Name         string      `json:"name"`
        Label        string      `json:"label"`
        Type         string      `json:"type"`
        Required     bool        `json:"required"`
        DefaultValue interface{} `json:"default_value,omitempty"`
        Description  string      `json:"description,omitempty"`
}

// ConfigurationTest represents configuration test results
type ConfigurationTest struct {
        TestedAt      time.Time              `json:"tested_at"`
        OverallStatus string                 `json:"overall_status"`
        Results       map[string]*TestResult `json:"results"`
}

// TestResult represents a single test result
type TestResult struct {
        Status  string `json:"status"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
}

// ConfigurationHistory represents configuration history
type ConfigurationHistory struct {
        ID        int       `json:"id" db:"id"`
        Version   string    `json:"version" db:"version"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
        UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

// ConfigurationBackup represents a configuration backup
type ConfigurationBackup struct {
        ID            int                  `json:"id" db:"id"`
        Name          string               `json:"name" db:"name"`
        Version       string               `json:"version" db:"version"`
        Configuration *SystemConfiguration `json:"configuration,omitempty" db:"configuration"`
        CreatedAt     time.Time            `json:"created_at" db:"created_at"`
}

// ConfigurationTemplate represents a configuration template
type ConfigurationTemplate struct {
        ID            int                  `json:"id" db:"id"`
        Name          string               `json:"name" db:"name"`
        Description   string               `json:"description" db:"description"`
        Category      string               `json:"category" db:"category"`
        Configuration *SystemConfiguration `json:"configuration" db:"configuration"`
        CreatedAt     time.Time            `json:"created_at" db:"created_at"`
}

// ConfigurationStatistics represents configuration statistics
type ConfigurationStatistics struct {
        TotalConfigurations int       `json:"total_configurations"`
        TotalBackups        int       `json:"total_backups"`
        TotalTemplates      int       `json:"total_templates"`
        WizardCompletions   int       `json:"wizard_completions"`
        LastUpdate          time.Time `json:"last_update"`
}

// Wizard Step Type Constants
const (
        WizardStepTypeInfo     = "info"
        WizardStepTypeForm     = "form"
        WizardStepTypeSummary  = "summary"
        WizardStepTypeComplete = "complete"
)

// Field Type Constants
const (
        FieldTypeText      = "text"
        FieldTypePassword  = "password"
        FieldTypeEmail     = "email"
        FieldTypeNumber    = "number"
        FieldTypeCheckbox  = "checkbox"
        FieldTypeSelect    = "select"
        FieldTypeTextarea  = "textarea"
        FieldTypeFile      = "file"
        FieldTypeDirectory = "directory"
)

// Test Status Constants
const (
        TestStatusPassed  = "passed"
        TestStatusFailed  = "failed"
        TestStatusWarning = "warning"
)

// Configuration Category Constants
const (
        ConfigCategoryEnvironment = "Environment"
        ConfigCategoryPerformance = "Performance"
        ConfigCategorySecurity    = "Security"
        ConfigCategoryDevelopment = "Development"
)

// Common Error Variables
var (
        ErrUnauthorized = errors.New("unauthorized")
        ErrForbidden    = errors.New("forbidden")
        ErrNotFound     = errors.New("not found")
        ErrConflict     = errors.New("conflict")
)
</pre>
		
		<pre class="file" id="file82" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
)

type AnalyticsRepository struct {
        db *sql.DB
}

func NewAnalyticsRepository(db *sql.DB) *AnalyticsRepository <span class="cov0" title="0">{
        return &amp;AnalyticsRepository{db: db}
}</span>

func (r *AnalyticsRepository) LogMediaAccess(access *models.MediaAccessLog) error <span class="cov0" title="0">{
        query := `
                INSERT INTO media_access_logs (user_id, media_id, action, device_info, location,
                                                                          ip_address, user_agent, playback_duration, access_time)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        var deviceInfoJSON, locationJSON *string

        if access.DeviceInfo != nil </span><span class="cov0" title="0">{
                data, err := json.Marshal(access.DeviceInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal device info: %w", err)
                }</span>
                <span class="cov0" title="0">deviceInfoStr := string(data)
                deviceInfoJSON = &amp;deviceInfoStr</span>
        }

        <span class="cov0" title="0">if access.Location != nil </span><span class="cov0" title="0">{
                data, err := json.Marshal(access.Location)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal location: %w", err)
                }</span>
                <span class="cov0" title="0">locationStr := string(data)
                locationJSON = &amp;locationStr</span>
        }

        <span class="cov0" title="0">var playbackDurationSeconds *int64
        if access.PlaybackDuration != nil </span><span class="cov0" title="0">{
                seconds := int64(access.PlaybackDuration.Seconds())
                playbackDurationSeconds = &amp;seconds
        }</span>

        <span class="cov0" title="0">_, err := r.db.Exec(query,
                access.UserID, access.MediaID, access.Action, deviceInfoJSON, locationJSON,
                access.IPAddress, access.UserAgent, playbackDurationSeconds, access.AccessTime)

        return err</span>
}

func (r *AnalyticsRepository) LogEvent(event *models.AnalyticsEvent) error <span class="cov0" title="0">{
        query := `
                INSERT INTO analytics_events (user_id, event_type, event_category, data,
                                                                         device_info, location, ip_address, user_agent, timestamp)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        var deviceInfoJSON, locationJSON *string

        if event.DeviceInfo != nil </span><span class="cov0" title="0">{
                data, err := json.Marshal(event.DeviceInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal device info: %w", err)
                }</span>
                <span class="cov0" title="0">deviceInfoStr := string(data)
                deviceInfoJSON = &amp;deviceInfoStr</span>
        }

        <span class="cov0" title="0">if event.Location != nil </span><span class="cov0" title="0">{
                data, err := json.Marshal(event.Location)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal location: %w", err)
                }</span>
                <span class="cov0" title="0">locationStr := string(data)
                locationJSON = &amp;locationStr</span>
        }

        <span class="cov0" title="0">_, err := r.db.Exec(query,
                event.UserID, event.EventType, event.EventCategory, event.Data,
                deviceInfoJSON, locationJSON, event.IPAddress, event.UserAgent, event.Timestamp)

        return err</span>
}

func (r *AnalyticsRepository) GetMediaAccessLogs(userID int, mediaID *int, limit, offset int) ([]models.MediaAccessLog, error) <span class="cov0" title="0">{
        var query string
        var args []interface{}

        if mediaID != nil </span><span class="cov0" title="0">{
                if userID &gt; 0 </span><span class="cov0" title="0">{
                        query = `
                                SELECT id, user_id, media_id, action, device_info, location, ip_address,
                                           user_agent, playback_duration, access_time
                                FROM media_access_logs
                                WHERE user_id = ? AND media_id = ?
                                ORDER BY access_time DESC
                                LIMIT ? OFFSET ?
                        `
                        args = []interface{}{userID, *mediaID, limit, offset}
                }</span> else<span class="cov0" title="0"> {
                        query = `
                                SELECT id, user_id, media_id, action, device_info, location, ip_address,
                                           user_agent, playback_duration, access_time
                                FROM media_access_logs
                                WHERE media_id = ?
                                ORDER BY access_time DESC
                                LIMIT ? OFFSET ?
                        `
                        args = []interface{}{*mediaID, limit, offset}
                }</span>
        } else<span class="cov0" title="0"> if userID &gt; 0 </span><span class="cov0" title="0">{
                query = `
                        SELECT id, user_id, media_id, action, device_info, location, ip_address,
                                   user_agent, playback_duration, access_time
                        FROM media_access_logs
                        WHERE user_id = ?
                        ORDER BY access_time DESC
                        LIMIT ? OFFSET ?
                `
                args = []interface{}{userID, limit, offset}
        }</span> else<span class="cov0" title="0"> {
                query = `
                        SELECT id, user_id, media_id, action, device_info, location, ip_address,
                                   user_agent, playback_duration, access_time
                        FROM media_access_logs
                        ORDER BY access_time DESC
                        LIMIT ? OFFSET ?
                `
                args = []interface{}{limit, offset}
        }</span>

        <span class="cov0" title="0">rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get media access logs: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var logs []models.MediaAccessLog
        for rows.Next() </span><span class="cov0" title="0">{
                var log models.MediaAccessLog
                var deviceInfoJSON, locationJSON sql.NullString
                var playbackDurationSeconds sql.NullInt64

                err := rows.Scan(
                        &amp;log.ID, &amp;log.UserID, &amp;log.MediaID, &amp;log.Action, &amp;deviceInfoJSON,
                        &amp;locationJSON, &amp;log.IPAddress, &amp;log.UserAgent, &amp;playbackDurationSeconds,
                        &amp;log.AccessTime)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan media access log: %w", err)
                }</span>

                <span class="cov0" title="0">if deviceInfoJSON.Valid </span><span class="cov0" title="0">{
                        var deviceInfo models.DeviceInfo
                        if err := json.Unmarshal([]byte(deviceInfoJSON.String), &amp;deviceInfo); err == nil </span><span class="cov0" title="0">{
                                log.DeviceInfo = &amp;deviceInfo
                        }</span>
                }

                <span class="cov0" title="0">if locationJSON.Valid </span><span class="cov0" title="0">{
                        var location models.Location
                        if err := json.Unmarshal([]byte(locationJSON.String), &amp;location); err == nil </span><span class="cov0" title="0">{
                                log.Location = &amp;location
                        }</span>
                }

                <span class="cov0" title="0">if playbackDurationSeconds.Valid </span><span class="cov0" title="0">{
                        duration := time.Duration(playbackDurationSeconds.Int64) * time.Second
                        log.PlaybackDuration = &amp;duration
                }</span>

                <span class="cov0" title="0">logs = append(logs, log)</span>
        }

        <span class="cov0" title="0">return logs, nil</span>
}

func (r *AnalyticsRepository) GetUserMediaAccessLogs(userID int, startDate, endDate time.Time) ([]models.MediaAccessLog, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, media_id, action, device_info, location, ip_address,
                           user_agent, playback_duration, access_time
                FROM media_access_logs
                WHERE user_id = ? AND access_time BETWEEN ? AND ?
                ORDER BY access_time DESC
        `

        rows, err := r.db.Query(query, userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user media access logs: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanMediaAccessLogs(rows)</span>
}

func (r *AnalyticsRepository) GetUserEvents(userID int, startDate, endDate time.Time) ([]models.AnalyticsEvent, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, event_type, event_category, data, device_info, location,
                           ip_address, user_agent, timestamp
                FROM analytics_events
                WHERE user_id = ? AND timestamp BETWEEN ? AND ?
                ORDER BY timestamp DESC
        `

        rows, err := r.db.Query(query, userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user events: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanAnalyticsEvents(rows)</span>
}

func (r *AnalyticsRepository) GetTotalUsers() (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM users`
        var count int
        err := r.db.QueryRow(query).Scan(&amp;count)
        return count, err
}</span>

func (r *AnalyticsRepository) GetActiveUsers(startDate, endDate time.Time) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(DISTINCT user_id)
                FROM media_access_logs
                WHERE access_time BETWEEN ? AND ?
        `
        var count int
        err := r.db.QueryRow(query, startDate, endDate).Scan(&amp;count)
        return count, err
}</span>

func (r *AnalyticsRepository) GetTotalMediaAccesses(startDate, endDate time.Time) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*)
                FROM media_access_logs
                WHERE access_time BETWEEN ? AND ?
        `
        var count int
        err := r.db.QueryRow(query, startDate, endDate).Scan(&amp;count)
        return count, err
}</span>

func (r *AnalyticsRepository) GetTotalEvents(startDate, endDate time.Time) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*)
                FROM analytics_events
                WHERE timestamp BETWEEN ? AND ?
        `
        var count int
        err := r.db.QueryRow(query, startDate, endDate).Scan(&amp;count)
        return count, err
}</span>

func (r *AnalyticsRepository) GetTopAccessedMedia(startDate, endDate time.Time, limit int) ([]models.MediaAccessCount, error) <span class="cov0" title="0">{
        query := `
                SELECT media_id, COUNT(*) as access_count
                FROM media_access_logs
                WHERE access_time BETWEEN ? AND ?
                GROUP BY media_id
                ORDER BY access_count DESC
                LIMIT ?
        `

        rows, err := r.db.Query(query, startDate, endDate, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top accessed media: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []models.MediaAccessCount
        for rows.Next() </span><span class="cov0" title="0">{
                var result models.MediaAccessCount
                err := rows.Scan(&amp;result.MediaID, &amp;result.AccessCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan media access count: %w", err)
                }</span>
                <span class="cov0" title="0">results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

func (r *AnalyticsRepository) GetUserGrowthData(startDate, endDate time.Time) ([]models.UserGrowthPoint, error) <span class="cov0" title="0">{
        query := `
                SELECT DATE(created_at) as date, COUNT(*) as user_count
                FROM users
                WHERE created_at BETWEEN ? AND ?
                GROUP BY DATE(created_at)
                ORDER BY date ASC
        `

        rows, err := r.db.Query(query, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user growth data: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []models.UserGrowthPoint
        for rows.Next() </span><span class="cov0" title="0">{
                var result models.UserGrowthPoint
                var dateStr string
                err := rows.Scan(&amp;dateStr, &amp;result.UserCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user growth point: %w", err)
                }</span>

                <span class="cov0" title="0">date, err := time.Parse("2006-01-02", dateStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse date: %w", err)
                }</span>
                <span class="cov0" title="0">result.Date = date

                results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

func (r *AnalyticsRepository) GetSessionData(startDate, endDate time.Time) ([]models.SessionData, error) <span class="cov0" title="0">{
        query := `
                SELECT user_id,
                           MIN(last_activity_at) as session_start,
                           MAX(last_activity_at) as session_end,
                           (julianday(MAX(last_activity_at)) - julianday(MIN(last_activity_at))) * 24 * 60 * 60 as duration_seconds
                FROM user_sessions
                WHERE created_at BETWEEN ? AND ? AND is_active = 1
                GROUP BY user_id, DATE(created_at)
                ORDER BY session_start ASC
        `

        rows, err := r.db.Query(query, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get session data: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []models.SessionData
        for rows.Next() </span><span class="cov0" title="0">{
                var result models.SessionData
                var durationSeconds float64

                err := rows.Scan(&amp;result.UserID, &amp;result.StartTime, &amp;result.EndTime, &amp;durationSeconds)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan session data: %w", err)
                }</span>

                <span class="cov0" title="0">result.Duration = time.Duration(durationSeconds) * time.Second
                results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

func (r *AnalyticsRepository) GetAllMediaAccessLogs(startDate, endDate time.Time) ([]models.MediaAccessLog, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, media_id, action, device_info, location, ip_address,
                           user_agent, playback_duration, access_time
                FROM media_access_logs
                WHERE access_time BETWEEN ? AND ?
                ORDER BY access_time DESC
        `

        rows, err := r.db.Query(query, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all media access logs: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanMediaAccessLogs(rows)</span>
}

func (r *AnalyticsRepository) GetFileTypeData(startDate, endDate time.Time) (map[string]int, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        CASE
                                WHEN LOWER(data) LIKE '%"file_type":"video%' THEN 'video'
                                WHEN LOWER(data) LIKE '%"file_type":"audio%' THEN 'audio'
                                WHEN LOWER(data) LIKE '%"file_type":"image%' THEN 'image'
                                WHEN LOWER(data) LIKE '%"file_type":"document%' THEN 'document'
                                ELSE 'other'
                        END as file_type,
                        COUNT(*) as count
                FROM analytics_events
                WHERE timestamp BETWEEN ? AND ? AND event_type = 'media_access'
                GROUP BY file_type
                ORDER BY count DESC
        `

        rows, err := r.db.Query(query, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file type data: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        fileTypes := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var fileType string
                var count int
                err := rows.Scan(&amp;fileType, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan file type data: %w", err)
                }</span>
                <span class="cov0" title="0">fileTypes[fileType] = count</span>
        }

        <span class="cov0" title="0">return fileTypes, nil</span>
}

func (r *AnalyticsRepository) GetGeographicData(startDate, endDate time.Time) (map[string]interface{}, error) <span class="cov0" title="0">{
        query := `
                SELECT location, COUNT(*) as access_count
                FROM media_access_logs
                WHERE access_time BETWEEN ? AND ? AND location IS NOT NULL
                GROUP BY location
                ORDER BY access_count DESC
                LIMIT 100
        `

        rows, err := r.db.Query(query, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get geographic data: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var locations []map[string]interface{}
        countryCount := make(map[string]int)

        for rows.Next() </span><span class="cov0" title="0">{
                var locationJSON string
                var accessCount int

                err := rows.Scan(&amp;locationJSON, &amp;accessCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan geographic data: %w", err)
                }</span>

                <span class="cov0" title="0">var location models.Location
                if err := json.Unmarshal([]byte(locationJSON), &amp;location); err == nil </span><span class="cov0" title="0">{
                        locationData := map[string]interface{}{
                                "latitude":     location.Latitude,
                                "longitude":    location.Longitude,
                                "access_count": accessCount,
                        }

                        if location.Country != nil </span><span class="cov0" title="0">{
                                locationData["country"] = *location.Country
                                countryCount[*location.Country] += accessCount
                        }</span>

                        <span class="cov0" title="0">if location.City != nil </span><span class="cov0" title="0">{
                                locationData["city"] = *location.City
                        }</span>

                        <span class="cov0" title="0">locations = append(locations, locationData)</span>
                }
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "locations": locations,
                "countries": countryCount,
        }, nil</span>
}

func (r *AnalyticsRepository) scanMediaAccessLogs(rows *sql.Rows) ([]models.MediaAccessLog, error) <span class="cov0" title="0">{
        var logs []models.MediaAccessLog

        for rows.Next() </span><span class="cov0" title="0">{
                var log models.MediaAccessLog
                var deviceInfoJSON, locationJSON sql.NullString
                var playbackDurationSeconds sql.NullInt64

                err := rows.Scan(
                        &amp;log.ID, &amp;log.UserID, &amp;log.MediaID, &amp;log.Action, &amp;deviceInfoJSON,
                        &amp;locationJSON, &amp;log.IPAddress, &amp;log.UserAgent, &amp;playbackDurationSeconds,
                        &amp;log.AccessTime)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan media access log: %w", err)
                }</span>

                <span class="cov0" title="0">if deviceInfoJSON.Valid </span><span class="cov0" title="0">{
                        var deviceInfo models.DeviceInfo
                        if err := json.Unmarshal([]byte(deviceInfoJSON.String), &amp;deviceInfo); err == nil </span><span class="cov0" title="0">{
                                log.DeviceInfo = &amp;deviceInfo
                        }</span>
                }

                <span class="cov0" title="0">if locationJSON.Valid </span><span class="cov0" title="0">{
                        var location models.Location
                        if err := json.Unmarshal([]byte(locationJSON.String), &amp;location); err == nil </span><span class="cov0" title="0">{
                                log.Location = &amp;location
                        }</span>
                }

                <span class="cov0" title="0">if playbackDurationSeconds.Valid </span><span class="cov0" title="0">{
                        duration := time.Duration(playbackDurationSeconds.Int64) * time.Second
                        log.PlaybackDuration = &amp;duration
                }</span>

                <span class="cov0" title="0">logs = append(logs, log)</span>
        }

        <span class="cov0" title="0">return logs, nil</span>
}

func (r *AnalyticsRepository) scanAnalyticsEvents(rows *sql.Rows) ([]models.AnalyticsEvent, error) <span class="cov0" title="0">{
        var events []models.AnalyticsEvent

        for rows.Next() </span><span class="cov0" title="0">{
                var event models.AnalyticsEvent
                var deviceInfoJSON, locationJSON sql.NullString

                err := rows.Scan(
                        &amp;event.ID, &amp;event.UserID, &amp;event.EventType, &amp;event.EventCategory,
                        &amp;event.Data, &amp;deviceInfoJSON, &amp;locationJSON, &amp;event.IPAddress,
                        &amp;event.UserAgent, &amp;event.Timestamp)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan analytics event: %w", err)
                }</span>

                <span class="cov0" title="0">if deviceInfoJSON.Valid </span><span class="cov0" title="0">{
                        var deviceInfo models.DeviceInfo
                        if err := json.Unmarshal([]byte(deviceInfoJSON.String), &amp;deviceInfo); err == nil </span><span class="cov0" title="0">{
                                event.DeviceInfo = &amp;deviceInfo
                        }</span>
                }

                <span class="cov0" title="0">if locationJSON.Valid </span><span class="cov0" title="0">{
                        var location models.Location
                        if err := json.Unmarshal([]byte(locationJSON.String), &amp;location); err == nil </span><span class="cov0" title="0">{
                                event.Location = &amp;location
                        }</span>
                }

                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
)

type ConfigurationRepository struct {
        db *sql.DB
}

func NewConfigurationRepository(db *sql.DB) *ConfigurationRepository <span class="cov0" title="0">{
        return &amp;ConfigurationRepository{db: db}
}</span>

func (r *ConfigurationRepository) SaveConfiguration(config *models.SystemConfiguration) error <span class="cov0" title="0">{
        configJSON, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT OR REPLACE INTO system_configuration (
                        id, version, configuration, created_at, updated_at
                ) VALUES (1, ?, ?, ?, ?)`

        _, err = r.db.Exec(query, config.Version, string(configJSON), config.CreatedAt, config.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) GetConfiguration() (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        query := `
                SELECT version, configuration, created_at, updated_at
                FROM system_configuration
                WHERE id = 1`

        var version, configJSON string
        var createdAt, updatedAt time.Time

        err := r.db.QueryRow(query).Scan(&amp;version, &amp;configJSON, &amp;createdAt, &amp;updatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get configuration: %w", err)
        }</span>

        <span class="cov0" title="0">var config models.SystemConfiguration
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">config.Version = version
        config.CreatedAt = createdAt
        config.UpdatedAt = updatedAt

        return &amp;config, nil</span>
}

func (r *ConfigurationRepository) SaveWizardProgress(progress *models.WizardProgress) error <span class="cov0" title="0">{
        stepDataJSON, err := json.Marshal(progress.StepData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal step data: %w", err)
        }</span>

        <span class="cov0" title="0">allDataJSON, err := json.Marshal(progress.AllData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal all data: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT OR REPLACE INTO wizard_progress (
                        user_id, current_step, step_data, all_data, updated_at
                ) VALUES (?, ?, ?, ?, ?)`

        _, err = r.db.Exec(query,
                progress.UserID, progress.CurrentStep, string(stepDataJSON),
                string(allDataJSON), progress.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save wizard progress: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) GetWizardProgress(userID int) (*models.WizardProgress, error) <span class="cov0" title="0">{
        query := `
                SELECT user_id, current_step, step_data, all_data, updated_at
                FROM wizard_progress
                WHERE user_id = ?`

        var progress models.WizardProgress
        var stepDataJSON, allDataJSON string

        err := r.db.QueryRow(query, userID).Scan(
                &amp;progress.UserID, &amp;progress.CurrentStep, &amp;stepDataJSON,
                &amp;allDataJSON, &amp;progress.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get wizard progress: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(stepDataJSON), &amp;progress.StepData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal step data: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(allDataJSON), &amp;progress.AllData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal all data: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;progress, nil</span>
}

func (r *ConfigurationRepository) DeleteWizardProgress(userID int) error <span class="cov0" title="0">{
        query := "DELETE FROM wizard_progress WHERE user_id = ?"
        _, err := r.db.Exec(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete wizard progress: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) MarkWizardCompleted(userID int) error <span class="cov0" title="0">{
        query := `
                INSERT OR REPLACE INTO wizard_completion (
                        user_id, completed_at
                ) VALUES (?, ?)`

        _, err := r.db.Exec(query, userID, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark wizard as completed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) IsWizardCompleted(userID int) (bool, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*)
                FROM wizard_completion
                WHERE user_id = ?`

        var count int
        err := r.db.QueryRow(query, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check wizard completion: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (r *ConfigurationRepository) GetConfigurationHistory(limit int) ([]*models.ConfigurationHistory, error) <span class="cov0" title="0">{
        query := `
                SELECT id, version, created_at, updated_at
                FROM system_configuration_history
                ORDER BY created_at DESC
                LIMIT ?`

        rows, err := r.db.Query(query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get configuration history: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var history []*models.ConfigurationHistory
        for rows.Next() </span><span class="cov0" title="0">{
                var entry models.ConfigurationHistory
                err := rows.Scan(&amp;entry.ID, &amp;entry.Version, &amp;entry.CreatedAt, &amp;entry.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan configuration history: %w", err)
                }</span>
                <span class="cov0" title="0">history = append(history, &amp;entry)</span>
        }

        <span class="cov0" title="0">return history, nil</span>
}

func (r *ConfigurationRepository) SaveConfigurationHistory(config *models.SystemConfiguration) error <span class="cov0" title="0">{
        configJSON, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO system_configuration_history (
                        version, configuration, created_at, updated_at
                ) VALUES (?, ?, ?, ?)`

        _, err = r.db.Exec(query, config.Version, string(configJSON), config.CreatedAt, config.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration history: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) CreateConfigurationBackup(name string, config *models.SystemConfiguration) error <span class="cov0" title="0">{
        configJSON, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO configuration_backups (
                        name, version, configuration, created_at
                ) VALUES (?, ?, ?, ?)`

        _, err = r.db.Exec(query, name, config.Version, string(configJSON), time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create configuration backup: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) GetConfigurationBackups() ([]*models.ConfigurationBackup, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, version, created_at
                FROM configuration_backups
                ORDER BY created_at DESC`

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get configuration backups: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var backups []*models.ConfigurationBackup
        for rows.Next() </span><span class="cov0" title="0">{
                var backup models.ConfigurationBackup
                err := rows.Scan(&amp;backup.ID, &amp;backup.Name, &amp;backup.Version, &amp;backup.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan configuration backup: %w", err)
                }</span>
                <span class="cov0" title="0">backups = append(backups, &amp;backup)</span>
        }

        <span class="cov0" title="0">return backups, nil</span>
}

func (r *ConfigurationRepository) RestoreConfigurationBackup(backupID int) (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        query := `
                SELECT configuration
                FROM configuration_backups
                WHERE id = ?`

        var configJSON string
        err := r.db.QueryRow(query, backupID).Scan(&amp;configJSON)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get configuration backup: %w", err)
        }</span>

        <span class="cov0" title="0">var config models.SystemConfiguration
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
        }</span>

        // Update timestamps
        <span class="cov0" title="0">config.UpdatedAt = time.Now()

        // Save as current configuration
        if err := r.SaveConfiguration(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to restore configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (r *ConfigurationRepository) DeleteConfigurationBackup(backupID int) error <span class="cov0" title="0">{
        query := "DELETE FROM configuration_backups WHERE id = ?"
        _, err := r.db.Exec(query, backupID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete configuration backup: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) GetConfigurationTemplates() ([]*models.ConfigurationTemplate, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, category, configuration, created_at
                FROM configuration_templates
                ORDER BY category, name`

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get configuration templates: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var templates []*models.ConfigurationTemplate
        for rows.Next() </span><span class="cov0" title="0">{
                var template models.ConfigurationTemplate
                var configJSON string

                err := rows.Scan(
                        &amp;template.ID, &amp;template.Name, &amp;template.Description,
                        &amp;template.Category, &amp;configJSON, &amp;template.CreatedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan configuration template: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(configJSON), &amp;template.Configuration); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal template configuration: %w", err)
                }</span>

                <span class="cov0" title="0">templates = append(templates, &amp;template)</span>
        }

        <span class="cov0" title="0">return templates, nil</span>
}

func (r *ConfigurationRepository) CreateConfigurationTemplate(template *models.ConfigurationTemplate) error <span class="cov0" title="0">{
        configJSON, err := json.Marshal(template.Configuration)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO configuration_templates (
                        name, description, category, configuration, created_at
                ) VALUES (?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                template.Name, template.Description, template.Category,
                string(configJSON), template.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create configuration template: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">template.ID = int(id)
        return nil</span>
}

func (r *ConfigurationRepository) DeleteConfigurationTemplate(templateID int) error <span class="cov0" title="0">{
        query := "DELETE FROM configuration_templates WHERE id = ?"
        _, err := r.db.Exec(query, templateID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete configuration template: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) ApplyConfigurationTemplate(templateID int) (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        query := `
                SELECT configuration
                FROM configuration_templates
                WHERE id = ?`

        var configJSON string
        err := r.db.QueryRow(query, templateID).Scan(&amp;configJSON)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get configuration template: %w", err)
        }</span>

        <span class="cov0" title="0">var config models.SystemConfiguration
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
        }</span>

        // Update timestamps
        <span class="cov0" title="0">config.CreatedAt = time.Now()
        config.UpdatedAt = time.Now()

        // Save as current configuration
        if err := r.SaveConfiguration(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply template: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (r *ConfigurationRepository) CleanupOldHistory(olderThan time.Time) error <span class="cov0" title="0">{
        query := "DELETE FROM system_configuration_history WHERE created_at &lt; ?"
        _, err := r.db.Exec(query, olderThan)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old configuration history: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ConfigurationRepository) GetConfigurationStatistics() (*models.ConfigurationStatistics, error) <span class="cov0" title="0">{
        stats := &amp;models.ConfigurationStatistics{}

        // Total configurations in history
        err := r.db.QueryRow("SELECT COUNT(*) FROM system_configuration_history").Scan(&amp;stats.TotalConfigurations)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total configurations: %w", err)
        }</span>

        // Total backups
        <span class="cov0" title="0">err = r.db.QueryRow("SELECT COUNT(*) FROM configuration_backups").Scan(&amp;stats.TotalBackups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total backups: %w", err)
        }</span>

        // Total templates
        <span class="cov0" title="0">err = r.db.QueryRow("SELECT COUNT(*) FROM configuration_templates").Scan(&amp;stats.TotalTemplates)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total templates: %w", err)
        }</span>

        // Wizard completions
        <span class="cov0" title="0">err = r.db.QueryRow("SELECT COUNT(*) FROM wizard_completion").Scan(&amp;stats.WizardCompletions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get wizard completions: %w", err)
        }</span>

        // Last configuration update
        <span class="cov0" title="0">err = r.db.QueryRow("SELECT updated_at FROM system_configuration WHERE id = 1").Scan(&amp;stats.LastUpdate)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get last update: %w", err)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// SaveWizardSession saves a wizard session
func (r *ConfigurationRepository) SaveWizardSession(session *models.WizardSession) error <span class="cov0" title="0">{
        query := `
                INSERT OR REPLACE INTO wizard_sessions (
                        session_id, user_id, current_step, total_steps, step_data,
                        configuration, started_at, last_activity, is_completed, config_type
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        stepDataJSON, err := json.Marshal(session.StepData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal step data: %w", err)
        }</span>

        <span class="cov0" title="0">configJSON, err := json.Marshal(session.Configuration)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = r.db.Exec(query,
                session.SessionID, session.UserID, session.CurrentStep, session.TotalSteps,
                string(stepDataJSON), string(configJSON), session.StartedAt,
                session.LastActivity, session.IsCompleted, session.ConfigType)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save wizard session: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetWizardSession retrieves a wizard session by session ID
func (r *ConfigurationRepository) GetWizardSession(sessionID string) (*models.WizardSession, error) <span class="cov0" title="0">{
        query := `
                SELECT session_id, user_id, current_step, total_steps, step_data,
                           configuration, started_at, last_activity, is_completed, config_type
                FROM wizard_sessions WHERE session_id = ?`

        session := &amp;models.WizardSession{}
        var stepDataJSON, configJSON string

        err := r.db.QueryRow(query, sessionID).Scan(
                &amp;session.SessionID, &amp;session.UserID, &amp;session.CurrentStep, &amp;session.TotalSteps,
                &amp;stepDataJSON, &amp;configJSON, &amp;session.StartedAt, &amp;session.LastActivity,
                &amp;session.IsCompleted, &amp;session.ConfigType)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("wizard session not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get wizard session: %w", err)</span>
        }

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(stepDataJSON), &amp;session.StepData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal step data: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(configJSON), &amp;session.Configuration); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

// SaveConfigurationProfile saves a configuration profile
func (r *ConfigurationRepository) SaveConfigurationProfile(profile *models.ConfigurationProfile) error <span class="cov0" title="0">{
        query := `
                INSERT OR REPLACE INTO configuration_profiles (
                        profile_id, name, description, user_id, configuration,
                        created_at, updated_at, is_active, tags
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`

        configJSON, err := json.Marshal(profile.Configuration)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">tagsJSON, err := json.Marshal(profile.Tags)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal tags: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = r.db.Exec(query,
                profile.ProfileID, profile.Name, profile.Description, profile.UserID,
                string(configJSON), profile.CreatedAt, profile.UpdatedAt,
                profile.IsActive, string(tagsJSON))

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration profile: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetConfigurationProfile retrieves a configuration profile by profile ID
func (r *ConfigurationRepository) GetConfigurationProfile(profileID string) (*models.ConfigurationProfile, error) <span class="cov0" title="0">{
        query := `
                SELECT profile_id, name, description, user_id, configuration,
                           created_at, updated_at, is_active, tags
                FROM configuration_profiles WHERE profile_id = ?`

        profile := &amp;models.ConfigurationProfile{}
        var configJSON, tagsJSON string

        err := r.db.QueryRow(query, profileID).Scan(
                &amp;profile.ProfileID, &amp;profile.Name, &amp;profile.Description, &amp;profile.UserID,
                &amp;configJSON, &amp;profile.CreatedAt, &amp;profile.UpdatedAt, &amp;profile.IsActive, &amp;tagsJSON)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("configuration profile not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get configuration profile: %w", err)</span>
        }

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(configJSON), &amp;profile.Configuration); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(tagsJSON), &amp;profile.Tags); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal tags: %w", err)
        }</span>

        <span class="cov0" title="0">return profile, nil</span>
}

// GetUserConfigurationProfiles retrieves all configuration profiles for a user
func (r *ConfigurationRepository) GetUserConfigurationProfiles(userID int) ([]*models.ConfigurationProfile, error) <span class="cov0" title="0">{
        query := `
                SELECT profile_id, name, description, user_id, configuration,
                           created_at, updated_at, is_active, tags
                FROM configuration_profiles WHERE user_id = ? ORDER BY created_at DESC`

        rows, err := r.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user configuration profiles: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var profiles []*models.ConfigurationProfile
        for rows.Next() </span><span class="cov0" title="0">{
                profile := &amp;models.ConfigurationProfile{}
                var configJSON, tagsJSON string

                err := rows.Scan(
                        &amp;profile.ProfileID, &amp;profile.Name, &amp;profile.Description, &amp;profile.UserID,
                        &amp;configJSON, &amp;profile.CreatedAt, &amp;profile.UpdatedAt, &amp;profile.IsActive, &amp;tagsJSON)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan configuration profile: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(configJSON), &amp;profile.Configuration); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(tagsJSON), &amp;profile.Tags); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal tags: %w", err)
                }</span>

                <span class="cov0" title="0">profiles = append(profiles, profile)</span>
        }

        <span class="cov0" title="0">return profiles, nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package repository

import (
        "database/sql"
        "fmt"
        "time"

        "catalogizer/models"
)

type ConversionRepository struct {
        db *sql.DB
}

func NewConversionRepository(db *sql.DB) *ConversionRepository <span class="cov0" title="0">{
        return &amp;ConversionRepository{db: db}
}</span>

func (r *ConversionRepository) CreateJob(job *models.ConversionJob) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO conversion_jobs (user_id, source_path, target_path, source_format, target_format,
                                                                        conversion_type, quality, settings, priority, status, created_at, scheduled_for)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query,
                job.UserID, job.SourcePath, job.TargetPath, job.SourceFormat, job.TargetFormat,
                job.ConversionType, job.Quality, job.Settings, job.Priority, job.Status,
                job.CreatedAt, job.ScheduledFor)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create conversion job: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get job ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *ConversionRepository) GetJob(jobID int) (*models.ConversionJob, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, source_path, target_path, source_format, target_format,
                           conversion_type, quality, settings, priority, status, created_at,
                           started_at, completed_at, scheduled_for, duration, error_message
                FROM conversion_jobs
                WHERE id = ?
        `

        job := &amp;models.ConversionJob{}
        var settings, errorMessage sql.NullString
        var startedAt, completedAt, scheduledFor sql.NullTime
        var durationSeconds sql.NullInt64

        err := r.db.QueryRow(query, jobID).Scan(
                &amp;job.ID, &amp;job.UserID, &amp;job.SourcePath, &amp;job.TargetPath, &amp;job.SourceFormat, &amp;job.TargetFormat,
                &amp;job.ConversionType, &amp;job.Quality, &amp;settings, &amp;job.Priority, &amp;job.Status, &amp;job.CreatedAt,
                &amp;startedAt, &amp;completedAt, &amp;scheduledFor, &amp;durationSeconds, &amp;errorMessage)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("job not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get job: %w", err)</span>
        }

        <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                job.Settings = &amp;settings.String
        }</span>

        <span class="cov0" title="0">if errorMessage.Valid </span><span class="cov0" title="0">{
                job.ErrorMessage = &amp;errorMessage.String
        }</span>

        <span class="cov0" title="0">if startedAt.Valid </span><span class="cov0" title="0">{
                job.StartedAt = &amp;startedAt.Time
        }</span>

        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                job.CompletedAt = &amp;completedAt.Time
        }</span>

        <span class="cov0" title="0">if scheduledFor.Valid </span><span class="cov0" title="0">{
                job.ScheduledFor = &amp;scheduledFor.Time
        }</span>

        <span class="cov0" title="0">if durationSeconds.Valid </span><span class="cov0" title="0">{
                duration := time.Duration(durationSeconds.Int64) * time.Second
                job.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">return job, nil</span>
}

func (r *ConversionRepository) UpdateJob(job *models.ConversionJob) error <span class="cov0" title="0">{
        query := `
                UPDATE conversion_jobs
                SET status = ?, started_at = ?, completed_at = ?, duration = ?, error_message = ?, updated_at = ?
                WHERE id = ?
        `

        var startedAt, completedAt sql.NullTime
        var durationSeconds sql.NullInt64
        var errorMessage sql.NullString

        if job.StartedAt != nil </span><span class="cov0" title="0">{
                startedAt = sql.NullTime{Time: *job.StartedAt, Valid: true}
        }</span>

        <span class="cov0" title="0">if job.CompletedAt != nil </span><span class="cov0" title="0">{
                completedAt = sql.NullTime{Time: *job.CompletedAt, Valid: true}
        }</span>

        <span class="cov0" title="0">if job.Duration != nil </span><span class="cov0" title="0">{
                durationSeconds = sql.NullInt64{Int64: int64(job.Duration.Seconds()), Valid: true}
        }</span>

        <span class="cov0" title="0">if job.ErrorMessage != nil </span><span class="cov0" title="0">{
                errorMessage = sql.NullString{String: *job.ErrorMessage, Valid: true}
        }</span>

        <span class="cov0" title="0">_, err := r.db.Exec(query, job.Status, startedAt, completedAt, durationSeconds, errorMessage, time.Now(), job.ID)
        return err</span>
}

func (r *ConversionRepository) GetUserJobs(userID int, status *string, limit, offset int) ([]models.ConversionJob, error) <span class="cov0" title="0">{
        whereClause := "WHERE user_id = ?"
        args := []interface{}{userID}

        if status != nil </span><span class="cov0" title="0">{
                whereClause += " AND status = ?"
                args = append(args, *status)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT id, user_id, source_path, target_path, source_format, target_format,
                           conversion_type, quality, settings, priority, status, created_at,
                           started_at, completed_at, scheduled_for, duration, error_message
                FROM conversion_jobs
                %s
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `, whereClause)

        args = append(args, limit, offset)

        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user jobs: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanJobs(rows)</span>
}

func (r *ConversionRepository) GetJobsByStatus(status string, limit, offset int) ([]models.ConversionJob, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, source_path, target_path, source_format, target_format,
                           conversion_type, quality, settings, priority, status, created_at,
                           started_at, completed_at, scheduled_for, duration, error_message
                FROM conversion_jobs
                WHERE status = ?
                ORDER BY priority DESC, created_at ASC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.Query(query, status, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get jobs by status: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanJobs(rows)</span>
}

func (r *ConversionRepository) GetStatistics(userID *int, startDate, endDate time.Time) (*models.ConversionStatistics, error) <span class="cov0" title="0">{
        whereClause := "WHERE created_at BETWEEN ? AND ?"
        args := []interface{}{startDate, endDate}

        if userID != nil </span><span class="cov0" title="0">{
                whereClause += " AND user_id = ?"
                args = append(args, *userID)
        }</span>

        // Get total counts by status
        <span class="cov0" title="0">statusQuery := fmt.Sprintf(`
                SELECT status, COUNT(*) as count
                FROM conversion_jobs
                %s
                GROUP BY status
        `, whereClause)

        statusRows, err := r.db.Query(statusQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get status statistics: %w", err)
        }</span>
        <span class="cov0" title="0">defer statusRows.Close()

        stats := &amp;models.ConversionStatistics{
                StartDate: startDate,
                EndDate:   endDate,
                ByStatus:  make(map[string]int),
                ByType:    make(map[string]int),
                ByFormat:  make(map[string]int),
        }

        for statusRows.Next() </span><span class="cov0" title="0">{
                var status string
                var count int
                err := statusRows.Scan(&amp;status, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan status stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ByStatus[status] = count
                stats.TotalJobs += count</span>
        }

        // Get counts by conversion type
        <span class="cov0" title="0">typeQuery := fmt.Sprintf(`
                SELECT conversion_type, COUNT(*) as count
                FROM conversion_jobs
                %s
                GROUP BY conversion_type
        `, whereClause)

        typeRows, err := r.db.Query(typeQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get type statistics: %w", err)
        }</span>
        <span class="cov0" title="0">defer typeRows.Close()

        for typeRows.Next() </span><span class="cov0" title="0">{
                var convType string
                var count int
                err := typeRows.Scan(&amp;convType, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan type stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ByType[convType] = count</span>
        }

        // Get counts by target format
        <span class="cov0" title="0">formatQuery := fmt.Sprintf(`
                SELECT target_format, COUNT(*) as count
                FROM conversion_jobs
                %s
                GROUP BY target_format
                ORDER BY count DESC
                LIMIT 10
        `, whereClause)

        formatRows, err := r.db.Query(formatQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get format statistics: %w", err)
        }</span>
        <span class="cov0" title="0">defer formatRows.Close()

        for formatRows.Next() </span><span class="cov0" title="0">{
                var format string
                var count int
                err := formatRows.Scan(&amp;format, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan format stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ByFormat[format] = count</span>
        }

        // Get average duration for completed jobs
        <span class="cov0" title="0">durationQuery := fmt.Sprintf(`
                SELECT AVG(duration) as avg_duration
                FROM conversion_jobs
                %s AND status = 'completed' AND duration IS NOT NULL
        `, whereClause)

        var avgDurationSeconds sql.NullFloat64
        err = r.db.QueryRow(durationQuery, args...).Scan(&amp;avgDurationSeconds)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get duration statistics: %w", err)
        }</span>

        <span class="cov0" title="0">if avgDurationSeconds.Valid </span><span class="cov0" title="0">{
                avgDuration := time.Duration(avgDurationSeconds.Float64) * time.Second
                stats.AverageDuration = &amp;avgDuration
        }</span>

        // Calculate success rate
        <span class="cov0" title="0">if completed, ok := stats.ByStatus[models.ConversionStatusCompleted]; ok </span><span class="cov0" title="0">{
                if failed, failedOk := stats.ByStatus[models.ConversionStatusFailed]; failedOk </span><span class="cov0" title="0">{
                        total := completed + failed
                        if total &gt; 0 </span><span class="cov0" title="0">{
                                stats.SuccessRate = float64(completed) / float64(total) * 100
                        }</span>
                } else<span class="cov0" title="0"> if completed &gt; 0 </span><span class="cov0" title="0">{
                        stats.SuccessRate = 100.0
                }</span>
        }

        <span class="cov0" title="0">return stats, nil</span>
}

func (r *ConversionRepository) CleanupJobs(olderThan time.Time) error <span class="cov0" title="0">{
        query := `
                DELETE FROM conversion_jobs
                WHERE completed_at &lt; ? AND status IN ('completed', 'failed', 'cancelled')
        `

        _, err := r.db.Exec(query, olderThan)
        return err
}</span>

func (r *ConversionRepository) GetActiveJobsCount() (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM conversion_jobs WHERE status IN ('pending', 'running')`
        var count int
        err := r.db.QueryRow(query).Scan(&amp;count)
        return count, err
}</span>

func (r *ConversionRepository) GetJobsCountByUser(userID int) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM conversion_jobs WHERE user_id = ?`
        var count int
        err := r.db.QueryRow(query, userID).Scan(&amp;count)
        return count, err
}</span>

func (r *ConversionRepository) GetPopularFormats(limit int) ([]models.FormatPopularity, error) <span class="cov0" title="0">{
        query := `
                SELECT target_format, COUNT(*) as count
                FROM conversion_jobs
                WHERE status = 'completed'
                GROUP BY target_format
                ORDER BY count DESC
                LIMIT ?
        `

        rows, err := r.db.Query(query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get popular formats: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var formats []models.FormatPopularity
        for rows.Next() </span><span class="cov0" title="0">{
                var format models.FormatPopularity
                err := rows.Scan(&amp;format.Format, &amp;format.Count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan format popularity: %w", err)
                }</span>
                <span class="cov0" title="0">formats = append(formats, format)</span>
        }

        <span class="cov0" title="0">return formats, nil</span>
}

func (r *ConversionRepository) scanJobs(rows *sql.Rows) ([]models.ConversionJob, error) <span class="cov0" title="0">{
        var jobs []models.ConversionJob

        for rows.Next() </span><span class="cov0" title="0">{
                var job models.ConversionJob
                var settings, errorMessage sql.NullString
                var startedAt, completedAt, scheduledFor sql.NullTime
                var durationSeconds sql.NullInt64

                err := rows.Scan(
                        &amp;job.ID, &amp;job.UserID, &amp;job.SourcePath, &amp;job.TargetPath, &amp;job.SourceFormat, &amp;job.TargetFormat,
                        &amp;job.ConversionType, &amp;job.Quality, &amp;settings, &amp;job.Priority, &amp;job.Status, &amp;job.CreatedAt,
                        &amp;startedAt, &amp;completedAt, &amp;scheduledFor, &amp;durationSeconds, &amp;errorMessage)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan job: %w", err)
                }</span>

                <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                        job.Settings = &amp;settings.String
                }</span>

                <span class="cov0" title="0">if errorMessage.Valid </span><span class="cov0" title="0">{
                        job.ErrorMessage = &amp;errorMessage.String
                }</span>

                <span class="cov0" title="0">if startedAt.Valid </span><span class="cov0" title="0">{
                        job.StartedAt = &amp;startedAt.Time
                }</span>

                <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                        job.CompletedAt = &amp;completedAt.Time
                }</span>

                <span class="cov0" title="0">if scheduledFor.Valid </span><span class="cov0" title="0">{
                        job.ScheduledFor = &amp;scheduledFor.Time
                }</span>

                <span class="cov0" title="0">if durationSeconds.Valid </span><span class="cov0" title="0">{
                        duration := time.Duration(durationSeconds.Int64) * time.Second
                        job.Duration = &amp;duration
                }</span>

                <span class="cov0" title="0">jobs = append(jobs, job)</span>
        }

        <span class="cov0" title="0">return jobs, nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
)

type CrashReportingRepository struct {
        db *sql.DB
}

func NewCrashReportingRepository(db *sql.DB) *CrashReportingRepository <span class="cov0" title="0">{
        return &amp;CrashReportingRepository{db: db}
}</span>

func (r *CrashReportingRepository) CreateCrashReport(report *models.CrashReport) error <span class="cov0" title="0">{
        contextJSON, err := json.Marshal(report.Context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal context: %w", err)
        }</span>

        <span class="cov0" title="0">systemInfoJSON, err := json.Marshal(report.SystemInfo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal system info: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO crash_reports (
                        user_id, signal, message, stack_trace, context, system_info,
                        fingerprint, status, reported_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                report.UserID, report.Signal, report.Message, report.StackTrace,
                string(contextJSON), string(systemInfoJSON), report.Fingerprint,
                report.Status, report.ReportedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create crash report: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">report.ID = int(id)
        return nil</span>
}

func (r *CrashReportingRepository) GetCrashReport(id int) (*models.CrashReport, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, signal, message, stack_trace, context, system_info,
                           fingerprint, status, reported_at, resolved_at
                FROM crash_reports WHERE id = ?`

        var report models.CrashReport
        var contextJSON, systemInfoJSON string
        var resolvedAt sql.NullTime

        err := r.db.QueryRow(query, id).Scan(
                &amp;report.ID, &amp;report.UserID, &amp;report.Signal, &amp;report.Message,
                &amp;report.StackTrace, &amp;contextJSON, &amp;systemInfoJSON,
                &amp;report.Fingerprint, &amp;report.Status, &amp;report.ReportedAt, &amp;resolvedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crash report: %w", err)
        }</span>

        <span class="cov0" title="0">if resolvedAt.Valid </span><span class="cov0" title="0">{
                report.ResolvedAt = &amp;resolvedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;report.Context); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal context: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(systemInfoJSON), &amp;report.SystemInfo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal system info: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;report, nil</span>
}

func (r *CrashReportingRepository) UpdateCrashReport(report *models.CrashReport) error <span class="cov0" title="0">{
        contextJSON, err := json.Marshal(report.Context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal context: %w", err)
        }</span>

        <span class="cov0" title="0">systemInfoJSON, err := json.Marshal(report.SystemInfo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal system info: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE crash_reports SET
                        signal = ?, message = ?, stack_trace = ?, context = ?,
                        system_info = ?, fingerprint = ?, status = ?, resolved_at = ?
                WHERE id = ?`

        _, err = r.db.Exec(query,
                report.Signal, report.Message, report.StackTrace,
                string(contextJSON), string(systemInfoJSON), report.Fingerprint,
                report.Status, report.ResolvedAt, report.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update crash report: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *CrashReportingRepository) GetCrashReportsByUser(userID int, filters *models.CrashReportFilters) ([]*models.CrashReport, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, signal, message, stack_trace, context, system_info,
                           fingerprint, status, reported_at, resolved_at
                FROM crash_reports
                WHERE user_id = ?`

        args := []interface{}{userID}

        if filters != nil </span><span class="cov0" title="0">{
                if filters.Signal != "" </span><span class="cov0" title="0">{
                        query += " AND signal = ?"
                        args = append(args, filters.Signal)
                }</span>

                <span class="cov0" title="0">if filters.Status != "" </span><span class="cov0" title="0">{
                        query += " AND status = ?"
                        args = append(args, filters.Status)
                }</span>

                <span class="cov0" title="0">if filters.StartDate != nil </span><span class="cov0" title="0">{
                        query += " AND reported_at &gt;= ?"
                        args = append(args, *filters.StartDate)
                }</span>

                <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                        query += " AND reported_at &lt;= ?"
                        args = append(args, *filters.EndDate)
                }</span>
        }

        <span class="cov0" title="0">query += " ORDER BY reported_at DESC"

        if filters != nil &amp;&amp; filters.Limit &gt; 0 </span><span class="cov0" title="0">{
                query += " LIMIT ?"
                args = append(args, filters.Limit)

                if filters.Offset &gt; 0 </span><span class="cov0" title="0">{
                        query += " OFFSET ?"
                        args = append(args, filters.Offset)
                }</span>
        }

        <span class="cov0" title="0">rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crash reports: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reports []*models.CrashReport
        for rows.Next() </span><span class="cov0" title="0">{
                var report models.CrashReport
                var contextJSON, systemInfoJSON string
                var resolvedAt sql.NullTime

                err := rows.Scan(
                        &amp;report.ID, &amp;report.UserID, &amp;report.Signal, &amp;report.Message,
                        &amp;report.StackTrace, &amp;contextJSON, &amp;systemInfoJSON,
                        &amp;report.Fingerprint, &amp;report.Status, &amp;report.ReportedAt, &amp;resolvedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan crash report: %w", err)
                }</span>

                <span class="cov0" title="0">if resolvedAt.Valid </span><span class="cov0" title="0">{
                        report.ResolvedAt = &amp;resolvedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;report.Context); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal context: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(systemInfoJSON), &amp;report.SystemInfo); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal system info: %w", err)
                }</span>

                <span class="cov0" title="0">reports = append(reports, &amp;report)</span>
        }

        <span class="cov0" title="0">return reports, nil</span>
}

func (r *CrashReportingRepository) DeleteCrashReport(id int) error <span class="cov0" title="0">{
        query := "DELETE FROM crash_reports WHERE id = ?"
        _, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete crash report: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CrashReportingRepository) GetRecentCrashCount(duration time.Duration) (int, error) <span class="cov0" title="0">{
        since := time.Now().Add(-duration)
        query := `
                SELECT COUNT(*)
                FROM crash_reports
                WHERE reported_at &gt; ?`

        var count int
        err := r.db.QueryRow(query, since).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get recent crash count: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

func (r *CrashReportingRepository) GetCrashStatistics(userID int) (*models.CrashStatistics, error) <span class="cov0" title="0">{
        stats := &amp;models.CrashStatistics{}

        // Total crashes
        err := r.db.QueryRow("SELECT COUNT(*) FROM crash_reports WHERE user_id = ?", userID).Scan(&amp;stats.TotalCrashes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total crashes: %w", err)
        }</span>

        // Crashes by signal
        <span class="cov0" title="0">signalQuery := `
                SELECT signal, COUNT(*)
                FROM crash_reports
                WHERE user_id = ?
                GROUP BY signal`

        rows, err := r.db.Query(signalQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crash signals: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        stats.CrashesBySignal = make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var signal string
                var count int
                if err := rows.Scan(&amp;signal, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan crash signal: %w", err)
                }</span>
                <span class="cov0" title="0">stats.CrashesBySignal[signal] = count</span>
        }

        // Recent crashes (last 24 hours)
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM crash_reports
                WHERE user_id = ? AND reported_at &gt; datetime('now', '-1 day')`, userID).Scan(&amp;stats.RecentCrashes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent crashes: %w", err)
        }</span>

        // Resolved crashes
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM crash_reports
                WHERE user_id = ? AND status = ?`, userID, models.CrashStatusResolved).Scan(&amp;stats.ResolvedCrashes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get resolved crashes: %w", err)
        }</span>

        // Average resolution time (in hours)
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT AVG(
                        CASE
                                WHEN resolved_at IS NOT NULL
                                THEN (julianday(resolved_at) - julianday(reported_at)) * 24
                                ELSE NULL
                        END
                )
                FROM crash_reports
                WHERE user_id = ? AND resolved_at IS NOT NULL`, userID).Scan(&amp;stats.AvgResolutionTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get average resolution time: %w", err)
        }</span>

        // Crash rate (crashes per day over last 30 days)
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT CAST(COUNT(*) AS FLOAT) / 30
                FROM crash_reports
                WHERE user_id = ? AND reported_at &gt; datetime('now', '-30 days')`, userID).Scan(&amp;stats.CrashRate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crash rate: %w", err)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (r *CrashReportingRepository) GetCrashesByFingerprint(fingerprint string, limit int) ([]*models.CrashReport, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, signal, message, stack_trace, context, system_info,
                           fingerprint, status, reported_at, resolved_at
                FROM crash_reports
                WHERE fingerprint = ?
                ORDER BY reported_at DESC
                LIMIT ?`

        rows, err := r.db.Query(query, fingerprint, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crashes by fingerprint: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reports []*models.CrashReport
        for rows.Next() </span><span class="cov0" title="0">{
                var report models.CrashReport
                var contextJSON, systemInfoJSON string
                var resolvedAt sql.NullTime

                err := rows.Scan(
                        &amp;report.ID, &amp;report.UserID, &amp;report.Signal, &amp;report.Message,
                        &amp;report.StackTrace, &amp;contextJSON, &amp;systemInfoJSON,
                        &amp;report.Fingerprint, &amp;report.Status, &amp;report.ReportedAt, &amp;resolvedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan crash report: %w", err)
                }</span>

                <span class="cov0" title="0">if resolvedAt.Valid </span><span class="cov0" title="0">{
                        report.ResolvedAt = &amp;resolvedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;report.Context); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal context: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(systemInfoJSON), &amp;report.SystemInfo); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal system info: %w", err)
                }</span>

                <span class="cov0" title="0">reports = append(reports, &amp;report)</span>
        }

        <span class="cov0" title="0">return reports, nil</span>
}

func (r *CrashReportingRepository) CleanupOldReports(olderThan time.Time) error <span class="cov0" title="0">{
        query := "DELETE FROM crash_reports WHERE reported_at &lt; ?"
        _, err := r.db.Exec(query, olderThan)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old crash reports: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CrashReportingRepository) GetTopCrashes(userID int, limit int, timeRange time.Duration) ([]*models.TopCrash, error) <span class="cov0" title="0">{
        since := time.Now().Add(-timeRange)
        query := `
                SELECT fingerprint, COUNT(*) as count, MAX(reported_at) as last_seen,
                           MIN(reported_at) as first_seen, message, signal
                FROM crash_reports
                WHERE user_id = ? AND reported_at &gt; ?
                GROUP BY fingerprint
                ORDER BY count DESC
                LIMIT ?`

        rows, err := r.db.Query(query, userID, since, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top crashes: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var topCrashes []*models.TopCrash
        for rows.Next() </span><span class="cov0" title="0">{
                var topCrash models.TopCrash
                err := rows.Scan(
                        &amp;topCrash.Fingerprint, &amp;topCrash.Count, &amp;topCrash.LastSeen,
                        &amp;topCrash.FirstSeen, &amp;topCrash.Message, &amp;topCrash.Signal)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan top crash: %w", err)
                }</span>

                <span class="cov0" title="0">topCrashes = append(topCrashes, &amp;topCrash)</span>
        }

        <span class="cov0" title="0">return topCrashes, nil</span>
}

func (r *CrashReportingRepository) GetCrashTrends(userID int, days int) ([]*models.CrashTrend, error) <span class="cov0" title="0">{
        query := `
                SELECT DATE(reported_at) as date, COUNT(*) as count
                FROM crash_reports
                WHERE user_id = ? AND reported_at &gt; datetime('now', '-' || ? || ' days')
                GROUP BY DATE(reported_at)
                ORDER BY date ASC`

        rows, err := r.db.Query(query, userID, days)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crash trends: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var trends []*models.CrashTrend
        for rows.Next() </span><span class="cov0" title="0">{
                var trend models.CrashTrend
                var dateStr string
                err := rows.Scan(&amp;dateStr, &amp;trend.Count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan crash trend: %w", err)
                }</span>

                <span class="cov0" title="0">date, err := time.Parse("2006-01-02", dateStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse date: %w", err)
                }</span>
                <span class="cov0" title="0">trend.Date = date

                trends = append(trends, &amp;trend)</span>
        }

        <span class="cov0" title="0">return trends, nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
)

type ErrorReportingRepository struct {
        db *sql.DB
}

func NewErrorReportingRepository(db *sql.DB) *ErrorReportingRepository <span class="cov0" title="0">{
        return &amp;ErrorReportingRepository{db: db}
}</span>

func (r *ErrorReportingRepository) CreateErrorReport(report *models.ErrorReport) error <span class="cov0" title="0">{
        contextJSON, err := json.Marshal(report.Context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal context: %w", err)
        }</span>

        <span class="cov0" title="0">systemInfoJSON, err := json.Marshal(report.SystemInfo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal system info: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO error_reports (
                        user_id, level, message, error_code, component, stack_trace,
                        context, system_info, user_agent, url, fingerprint, status, reported_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                report.UserID, report.Level, report.Message, report.ErrorCode,
                report.Component, report.StackTrace, string(contextJSON),
                string(systemInfoJSON), report.UserAgent, report.URL,
                report.Fingerprint, report.Status, report.ReportedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create error report: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">report.ID = int(id)
        return nil</span>
}

func (r *ErrorReportingRepository) GetErrorReport(id int) (*models.ErrorReport, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, level, message, error_code, component, stack_trace,
                           context, system_info, user_agent, url, fingerprint, status,
                           reported_at, resolved_at
                FROM error_reports WHERE id = ?`

        var report models.ErrorReport
        var contextJSON, systemInfoJSON string
        var resolvedAt sql.NullTime

        err := r.db.QueryRow(query, id).Scan(
                &amp;report.ID, &amp;report.UserID, &amp;report.Level, &amp;report.Message,
                &amp;report.ErrorCode, &amp;report.Component, &amp;report.StackTrace,
                &amp;contextJSON, &amp;systemInfoJSON, &amp;report.UserAgent, &amp;report.URL,
                &amp;report.Fingerprint, &amp;report.Status, &amp;report.ReportedAt, &amp;resolvedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get error report: %w", err)
        }</span>

        <span class="cov0" title="0">if resolvedAt.Valid </span><span class="cov0" title="0">{
                report.ResolvedAt = &amp;resolvedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;report.Context); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal context: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(systemInfoJSON), &amp;report.SystemInfo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal system info: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;report, nil</span>
}

func (r *ErrorReportingRepository) UpdateErrorReport(report *models.ErrorReport) error <span class="cov0" title="0">{
        contextJSON, err := json.Marshal(report.Context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal context: %w", err)
        }</span>

        <span class="cov0" title="0">systemInfoJSON, err := json.Marshal(report.SystemInfo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal system info: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE error_reports SET
                        level = ?, message = ?, error_code = ?, component = ?,
                        stack_trace = ?, context = ?, system_info = ?, user_agent = ?,
                        url = ?, fingerprint = ?, status = ?, resolved_at = ?
                WHERE id = ?`

        _, err = r.db.Exec(query,
                report.Level, report.Message, report.ErrorCode, report.Component,
                report.StackTrace, string(contextJSON), string(systemInfoJSON),
                report.UserAgent, report.URL, report.Fingerprint, report.Status,
                report.ResolvedAt, report.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update error report: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ErrorReportingRepository) GetErrorReportsByUser(userID int, filters *models.ErrorReportFilters) ([]*models.ErrorReport, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, level, message, error_code, component, stack_trace,
                           context, system_info, user_agent, url, fingerprint, status,
                           reported_at, resolved_at
                FROM error_reports
                WHERE user_id = ?`

        args := []interface{}{userID}

        if filters != nil </span><span class="cov0" title="0">{
                if filters.Level != "" </span><span class="cov0" title="0">{
                        query += " AND level = ?"
                        args = append(args, filters.Level)
                }</span>

                <span class="cov0" title="0">if filters.Component != "" </span><span class="cov0" title="0">{
                        query += " AND component = ?"
                        args = append(args, filters.Component)
                }</span>

                <span class="cov0" title="0">if filters.Status != "" </span><span class="cov0" title="0">{
                        query += " AND status = ?"
                        args = append(args, filters.Status)
                }</span>

                <span class="cov0" title="0">if filters.StartDate != nil </span><span class="cov0" title="0">{
                        query += " AND reported_at &gt;= ?"
                        args = append(args, *filters.StartDate)
                }</span>

                <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                        query += " AND reported_at &lt;= ?"
                        args = append(args, *filters.EndDate)
                }</span>
        }

        <span class="cov0" title="0">query += " ORDER BY reported_at DESC"

        if filters != nil &amp;&amp; filters.Limit &gt; 0 </span><span class="cov0" title="0">{
                query += " LIMIT ?"
                args = append(args, filters.Limit)

                if filters.Offset &gt; 0 </span><span class="cov0" title="0">{
                        query += " OFFSET ?"
                        args = append(args, filters.Offset)
                }</span>
        }

        <span class="cov0" title="0">rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get error reports: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reports []*models.ErrorReport
        for rows.Next() </span><span class="cov0" title="0">{
                var report models.ErrorReport
                var contextJSON, systemInfoJSON string
                var resolvedAt sql.NullTime

                err := rows.Scan(
                        &amp;report.ID, &amp;report.UserID, &amp;report.Level, &amp;report.Message,
                        &amp;report.ErrorCode, &amp;report.Component, &amp;report.StackTrace,
                        &amp;contextJSON, &amp;systemInfoJSON, &amp;report.UserAgent, &amp;report.URL,
                        &amp;report.Fingerprint, &amp;report.Status, &amp;report.ReportedAt, &amp;resolvedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan error report: %w", err)
                }</span>

                <span class="cov0" title="0">if resolvedAt.Valid </span><span class="cov0" title="0">{
                        report.ResolvedAt = &amp;resolvedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;report.Context); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal context: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(systemInfoJSON), &amp;report.SystemInfo); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal system info: %w", err)
                }</span>

                <span class="cov0" title="0">reports = append(reports, &amp;report)</span>
        }

        <span class="cov0" title="0">return reports, nil</span>
}

func (r *ErrorReportingRepository) DeleteErrorReport(id int) error <span class="cov0" title="0">{
        query := "DELETE FROM error_reports WHERE id = ?"
        _, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete error report: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ErrorReportingRepository) GetErrorCountInLastHour(userID int) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*)
                FROM error_reports
                WHERE user_id = ? AND reported_at &gt; datetime('now', '-1 hour')`

        var count int
        err := r.db.QueryRow(query, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get error count: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

func (r *ErrorReportingRepository) GetRecentErrorCount(duration time.Duration) (int, error) <span class="cov0" title="0">{
        since := time.Now().Add(-duration)
        query := `
                SELECT COUNT(*)
                FROM error_reports
                WHERE reported_at &gt; ?`

        var count int
        err := r.db.QueryRow(query, since).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get recent error count: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

func (r *ErrorReportingRepository) GetErrorStatistics(userID int) (*models.ErrorStatistics, error) <span class="cov0" title="0">{
        stats := &amp;models.ErrorStatistics{}

        // Total errors
        err := r.db.QueryRow("SELECT COUNT(*) FROM error_reports WHERE user_id = ?", userID).Scan(&amp;stats.TotalErrors)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total errors: %w", err)
        }</span>

        // Errors by level
        <span class="cov0" title="0">levelQuery := `
                SELECT level, COUNT(*)
                FROM error_reports
                WHERE user_id = ?
                GROUP BY level`

        rows, err := r.db.Query(levelQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get error levels: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        stats.ErrorsByLevel = make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var level string
                var count int
                if err := rows.Scan(&amp;level, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan error level: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ErrorsByLevel[level] = count</span>
        }

        // Errors by component
        <span class="cov0" title="0">componentQuery := `
                SELECT component, COUNT(*)
                FROM error_reports
                WHERE user_id = ?
                GROUP BY component
                ORDER BY COUNT(*) DESC
                LIMIT 10`

        rows, err = r.db.Query(componentQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get error components: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        stats.ErrorsByComponent = make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var component string
                var count int
                if err := rows.Scan(&amp;component, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan error component: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ErrorsByComponent[component] = count</span>
        }

        // Recent errors (last 24 hours)
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM error_reports
                WHERE user_id = ? AND reported_at &gt; datetime('now', '-1 day')`, userID).Scan(&amp;stats.RecentErrors)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent errors: %w", err)
        }</span>

        // Resolved errors
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM error_reports
                WHERE user_id = ? AND status = ?`, userID, models.ErrorStatusResolved).Scan(&amp;stats.ResolvedErrors)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get resolved errors: %w", err)
        }</span>

        // Average resolution time (in hours)
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT AVG(
                        CASE
                                WHEN resolved_at IS NOT NULL
                                THEN (julianday(resolved_at) - julianday(reported_at)) * 24
                                ELSE NULL
                        END
                )
                FROM error_reports
                WHERE user_id = ? AND resolved_at IS NOT NULL`, userID).Scan(&amp;stats.AvgResolutionTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get average resolution time: %w", err)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (r *ErrorReportingRepository) GetErrorsByFingerprint(fingerprint string, limit int) ([]*models.ErrorReport, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, level, message, error_code, component, stack_trace,
                           context, system_info, user_agent, url, fingerprint, status,
                           reported_at, resolved_at
                FROM error_reports
                WHERE fingerprint = ?
                ORDER BY reported_at DESC
                LIMIT ?`

        rows, err := r.db.Query(query, fingerprint, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get errors by fingerprint: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reports []*models.ErrorReport
        for rows.Next() </span><span class="cov0" title="0">{
                var report models.ErrorReport
                var contextJSON, systemInfoJSON string
                var resolvedAt sql.NullTime

                err := rows.Scan(
                        &amp;report.ID, &amp;report.UserID, &amp;report.Level, &amp;report.Message,
                        &amp;report.ErrorCode, &amp;report.Component, &amp;report.StackTrace,
                        &amp;contextJSON, &amp;systemInfoJSON, &amp;report.UserAgent, &amp;report.URL,
                        &amp;report.Fingerprint, &amp;report.Status, &amp;report.ReportedAt, &amp;resolvedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan error report: %w", err)
                }</span>

                <span class="cov0" title="0">if resolvedAt.Valid </span><span class="cov0" title="0">{
                        report.ResolvedAt = &amp;resolvedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;report.Context); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal context: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(systemInfoJSON), &amp;report.SystemInfo); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal system info: %w", err)
                }</span>

                <span class="cov0" title="0">reports = append(reports, &amp;report)</span>
        }

        <span class="cov0" title="0">return reports, nil</span>
}

func (r *ErrorReportingRepository) CleanupOldReports(olderThan time.Time) error <span class="cov0" title="0">{
        query := "DELETE FROM error_reports WHERE reported_at &lt; ?"
        _, err := r.db.Exec(query, olderThan)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old error reports: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ErrorReportingRepository) GetTopErrors(userID int, limit int, timeRange time.Duration) ([]*models.TopError, error) <span class="cov0" title="0">{
        since := time.Now().Add(-timeRange)
        query := `
                SELECT fingerprint, COUNT(*) as count, MAX(reported_at) as last_seen,
                           MIN(reported_at) as first_seen, message, component, level
                FROM error_reports
                WHERE user_id = ? AND reported_at &gt; ?
                GROUP BY fingerprint
                ORDER BY count DESC
                LIMIT ?`

        rows, err := r.db.Query(query, userID, since, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top errors: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var topErrors []*models.TopError
        for rows.Next() </span><span class="cov0" title="0">{
                var topError models.TopError
                err := rows.Scan(
                        &amp;topError.Fingerprint, &amp;topError.Count, &amp;topError.LastSeen,
                        &amp;topError.FirstSeen, &amp;topError.Message, &amp;topError.Component, &amp;topError.Level)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan top error: %w", err)
                }</span>

                <span class="cov0" title="0">topErrors = append(topErrors, &amp;topError)</span>
        }

        <span class="cov0" title="0">return topErrors, nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"

        "catalogizer/models"
)

type FavoritesRepository struct {
        db *sql.DB
}

func NewFavoritesRepository(db *sql.DB) *FavoritesRepository <span class="cov0" title="0">{
        return &amp;FavoritesRepository{db: db}
}</span>

func (r *FavoritesRepository) CreateFavorite(favorite *models.Favorite) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO favorites (user_id, entity_type, entity_id, category, notes, tags, is_public, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        var tagsJSON *string
        if favorite.Tags != nil &amp;&amp; len(*favorite.Tags) &gt; 0 </span><span class="cov0" title="0">{
                data, err := json.Marshal(*favorite.Tags)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to marshal tags: %w", err)
                }</span>
                <span class="cov0" title="0">tagsStr := string(data)
                tagsJSON = &amp;tagsStr</span>
        }

        <span class="cov0" title="0">result, err := r.db.Exec(query,
                favorite.UserID, favorite.EntityType, favorite.EntityID,
                favorite.Category, favorite.Notes, tagsJSON, favorite.IsPublic, favorite.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create favorite: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get favorite ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *FavoritesRepository) GetFavorite(userID int, entityType string, entityID int) (*models.Favorite, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                WHERE user_id = ? AND entity_type = ? AND entity_id = ?
        `

        favorite := &amp;models.Favorite{}
        var tagsJSON sql.NullString
        var updatedAt sql.NullTime

        err := r.db.QueryRow(query, userID, entityType, entityID).Scan(
                &amp;favorite.ID, &amp;favorite.UserID, &amp;favorite.EntityType, &amp;favorite.EntityID,
                &amp;favorite.Category, &amp;favorite.Notes, &amp;tagsJSON, &amp;favorite.IsPublic,
                &amp;favorite.CreatedAt, &amp;updatedAt)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get favorite: %w", err)</span>
        }

        <span class="cov0" title="0">if tagsJSON.Valid </span><span class="cov0" title="0">{
                var tags []string
                if err := json.Unmarshal([]byte(tagsJSON.String), &amp;tags); err == nil </span><span class="cov0" title="0">{
                        favorite.Tags = &amp;tags
                }</span>
        }

        <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                favorite.UpdatedAt = &amp;updatedAt.Time
        }</span>

        <span class="cov0" title="0">return favorite, nil</span>
}

func (r *FavoritesRepository) GetFavoriteByID(favoriteID int) (*models.Favorite, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                WHERE id = ?
        `

        favorite := &amp;models.Favorite{}
        var tagsJSON sql.NullString
        var updatedAt sql.NullTime

        err := r.db.QueryRow(query, favoriteID).Scan(
                &amp;favorite.ID, &amp;favorite.UserID, &amp;favorite.EntityType, &amp;favorite.EntityID,
                &amp;favorite.Category, &amp;favorite.Notes, &amp;tagsJSON, &amp;favorite.IsPublic,
                &amp;favorite.CreatedAt, &amp;updatedAt)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("favorite not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get favorite: %w", err)</span>
        }

        <span class="cov0" title="0">if tagsJSON.Valid </span><span class="cov0" title="0">{
                var tags []string
                if err := json.Unmarshal([]byte(tagsJSON.String), &amp;tags); err == nil </span><span class="cov0" title="0">{
                        favorite.Tags = &amp;tags
                }</span>
        }

        <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                favorite.UpdatedAt = &amp;updatedAt.Time
        }</span>

        <span class="cov0" title="0">return favorite, nil</span>
}

func (r *FavoritesRepository) UpdateFavorite(favorite *models.Favorite) error <span class="cov0" title="0">{
        query := `
                UPDATE favorites
                SET category = ?, notes = ?, tags = ?, is_public = ?, updated_at = ?
                WHERE id = ?
        `

        var tagsJSON *string
        if favorite.Tags != nil &amp;&amp; len(*favorite.Tags) &gt; 0 </span><span class="cov0" title="0">{
                data, err := json.Marshal(*favorite.Tags)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal tags: %w", err)
                }</span>
                <span class="cov0" title="0">tagsStr := string(data)
                tagsJSON = &amp;tagsStr</span>
        }

        <span class="cov0" title="0">_, err := r.db.Exec(query,
                favorite.Category, favorite.Notes, tagsJSON, favorite.IsPublic,
                favorite.UpdatedAt, favorite.ID)

        return err</span>
}

func (r *FavoritesRepository) DeleteFavorite(favoriteID int) error <span class="cov0" title="0">{
        query := `DELETE FROM favorites WHERE id = ?`
        _, err := r.db.Exec(query, favoriteID)
        return err
}</span>

func (r *FavoritesRepository) GetUserFavorites(userID int, entityType *string, category *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        whereClause := "WHERE user_id = ?"
        args := []interface{}{userID}

        if entityType != nil </span><span class="cov0" title="0">{
                whereClause += " AND entity_type = ?"
                args = append(args, *entityType)
        }</span>

        <span class="cov0" title="0">if category != nil </span><span class="cov0" title="0">{
                whereClause += " AND category = ?"
                args = append(args, *category)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                %s
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `, whereClause)

        args = append(args, limit, offset)

        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user favorites: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavorites(rows)</span>
}

func (r *FavoritesRepository) GetPublicFavorites(entityType *string, category *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        whereClause := "WHERE is_public = 1"
        args := []interface{}{}

        if entityType != nil </span><span class="cov0" title="0">{
                whereClause += " AND entity_type = ?"
                args = append(args, *entityType)
        }</span>

        <span class="cov0" title="0">if category != nil </span><span class="cov0" title="0">{
                whereClause += " AND category = ?"
                args = append(args, *category)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                %s
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `, whereClause)

        args = append(args, limit, offset)

        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get public favorites: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavorites(rows)</span>
}

func (r *FavoritesRepository) SearchFavorites(userID int, query string, entityType *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        searchPattern := "%" + query + "%"
        whereClause := "WHERE user_id = ? AND (notes LIKE ? OR tags LIKE ?)"
        args := []interface{}{userID, searchPattern, searchPattern}

        if entityType != nil </span><span class="cov0" title="0">{
                whereClause += " AND entity_type = ?"
                args = append(args, *entityType)
        }</span>

        <span class="cov0" title="0">sqlQuery := fmt.Sprintf(`
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                %s
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `, whereClause)

        args = append(args, limit, offset)

        rows, err := r.db.Query(sqlQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search favorites: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavorites(rows)</span>
}

func (r *FavoritesRepository) CountUserFavorites(userID int, entityType *string) (int, error) <span class="cov0" title="0">{
        whereClause := "WHERE user_id = ?"
        args := []interface{}{userID}

        if entityType != nil </span><span class="cov0" title="0">{
                whereClause += " AND entity_type = ?"
                args = append(args, *entityType)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf("SELECT COUNT(*) FROM favorites %s", whereClause)

        var count int
        err := r.db.QueryRow(query, args...).Scan(&amp;count)
        return count, err</span>
}

func (r *FavoritesRepository) GetFavoritesCountByEntityType(userID int) (map[string]int, error) <span class="cov0" title="0">{
        query := `
                SELECT entity_type, COUNT(*) as count
                FROM favorites
                WHERE user_id = ?
                GROUP BY entity_type
                ORDER BY count DESC
        `

        rows, err := r.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get favorites count by entity type: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        counts := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var entityType string
                var count int
                err := rows.Scan(&amp;entityType, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan entity type count: %w", err)
                }</span>
                <span class="cov0" title="0">counts[entityType] = count</span>
        }

        <span class="cov0" title="0">return counts, nil</span>
}

func (r *FavoritesRepository) GetFavoritesCountByCategory(userID int) (map[string]int, error) <span class="cov0" title="0">{
        query := `
                SELECT COALESCE(category, 'uncategorized') as category, COUNT(*) as count
                FROM favorites
                WHERE user_id = ?
                GROUP BY category
                ORDER BY count DESC
        `

        rows, err := r.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get favorites count by category: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        counts := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var category string
                var count int
                err := rows.Scan(&amp;category, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan category count: %w", err)
                }</span>
                <span class="cov0" title="0">counts[category] = count</span>
        }

        <span class="cov0" title="0">return counts, nil</span>
}

func (r *FavoritesRepository) GetRecentFavorites(userID int, limit int) ([]models.Favorite, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                WHERE user_id = ?
                ORDER BY created_at DESC
                LIMIT ?
        `

        rows, err := r.db.Query(query, userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent favorites: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavorites(rows)</span>
}

func (r *FavoritesRepository) GetSimilarFavorites(userID int, entityType string, limit int) ([]models.Favorite, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, entity_type, entity_id, category, notes, tags, is_public, created_at, updated_at
                FROM favorites
                WHERE user_id != ? AND entity_type = ? AND is_public = 1
                ORDER BY created_at DESC
                LIMIT ?
        `

        rows, err := r.db.Query(query, userID, entityType, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get similar favorites: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavorites(rows)</span>
}

func (r *FavoritesRepository) CreateFavoriteCategory(category *models.FavoriteCategory) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO favorite_categories (user_id, name, description, color, icon, is_public, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query,
                category.UserID, category.Name, category.Description, category.Color,
                category.Icon, category.IsPublic, category.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create favorite category: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get category ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *FavoritesRepository) GetFavoriteCategories(userID int, entityType *string) ([]models.FavoriteCategory, error) <span class="cov0" title="0">{
        whereClause := "WHERE user_id = ?"
        args := []interface{}{userID}

        if entityType != nil </span><span class="cov0" title="0">{
                whereClause += " AND entity_type = ?"
                args = append(args, *entityType)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT id, user_id, name, description, color, icon, is_public, created_at, updated_at
                FROM favorite_categories
                %s
                ORDER BY name ASC
        `, whereClause)

        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get favorite categories: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavoriteCategories(rows)</span>
}

func (r *FavoritesRepository) GetFavoriteCategoryByID(categoryID int) (*models.FavoriteCategory, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, description, color, icon, is_public, created_at, updated_at
                FROM favorite_categories
                WHERE id = ?
        `

        category := &amp;models.FavoriteCategory{}
        var updatedAt sql.NullTime

        err := r.db.QueryRow(query, categoryID).Scan(
                &amp;category.ID, &amp;category.UserID, &amp;category.Name, &amp;category.Description,
                &amp;category.Color, &amp;category.Icon, &amp;category.IsPublic, &amp;category.CreatedAt, &amp;updatedAt)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("category not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get category: %w", err)</span>
        }

        <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                category.UpdatedAt = &amp;updatedAt.Time
        }</span>

        <span class="cov0" title="0">return category, nil</span>
}

func (r *FavoritesRepository) UpdateFavoriteCategory(category *models.FavoriteCategory) error <span class="cov0" title="0">{
        query := `
                UPDATE favorite_categories
                SET name = ?, description = ?, color = ?, icon = ?, is_public = ?, updated_at = ?
                WHERE id = ?
        `

        _, err := r.db.Exec(query,
                category.Name, category.Description, category.Color, category.Icon,
                category.IsPublic, category.UpdatedAt, category.ID)

        return err
}</span>

func (r *FavoritesRepository) DeleteFavoriteCategory(categoryID int) error <span class="cov0" title="0">{
        query := `DELETE FROM favorite_categories WHERE id = ?`
        _, err := r.db.Exec(query, categoryID)
        return err
}</span>

func (r *FavoritesRepository) CountFavoritesByCategory(categoryID int) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM favorites WHERE category = (SELECT name FROM favorite_categories WHERE id = ?)`
        var count int
        err := r.db.QueryRow(query, categoryID).Scan(&amp;count)
        return count, err
}</span>

func (r *FavoritesRepository) CreateFavoriteShare(share *models.FavoriteShare) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO favorite_shares (favorite_id, shared_by_user, shared_with, permissions, created_at, is_active)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        sharedWithJSON, err := json.Marshal(share.SharedWith)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to marshal shared_with: %w", err)
        }</span>

        <span class="cov0" title="0">permissionsJSON, err := json.Marshal(share.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to marshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">result, err := r.db.Exec(query,
                share.FavoriteID, share.SharedByUser, string(sharedWithJSON),
                string(permissionsJSON), share.CreatedAt, share.IsActive)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create favorite share: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get share ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *FavoritesRepository) GetFavoriteShareByID(shareID int) (*models.FavoriteShare, error) <span class="cov0" title="0">{
        query := `
                SELECT id, favorite_id, shared_by_user, shared_with, permissions, created_at, is_active
                FROM favorite_shares
                WHERE id = ?
        `

        share := &amp;models.FavoriteShare{}
        var sharedWithJSON, permissionsJSON string

        err := r.db.QueryRow(query, shareID).Scan(
                &amp;share.ID, &amp;share.FavoriteID, &amp;share.SharedByUser, &amp;sharedWithJSON,
                &amp;permissionsJSON, &amp;share.CreatedAt, &amp;share.IsActive)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("share not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get share: %w", err)</span>
        }

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(sharedWithJSON), &amp;share.SharedWith); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal shared_with: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(permissionsJSON), &amp;share.Permissions); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">return share, nil</span>
}

func (r *FavoritesRepository) GetSharedFavorites(userID int, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        query := `
                SELECT f.id, f.user_id, f.entity_type, f.entity_id, f.category, f.notes, f.tags, f.is_public, f.created_at, f.updated_at
                FROM favorites f
                INNER JOIN favorite_shares fs ON f.id = fs.favorite_id
                WHERE JSON_EXTRACT(fs.shared_with, '$') LIKE ? AND fs.is_active = 1
                ORDER BY f.created_at DESC
                LIMIT ? OFFSET ?
        `

        userIDPattern := fmt.Sprintf("%%\"%d\"%%", userID)

        rows, err := r.db.Query(query, userIDPattern, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get shared favorites: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanFavorites(rows)</span>
}

func (r *FavoritesRepository) RevokeFavoriteShare(shareID int) error <span class="cov0" title="0">{
        query := `UPDATE favorite_shares SET is_active = 0 WHERE id = ?`
        _, err := r.db.Exec(query, shareID)
        return err
}</span>

func (r *FavoritesRepository) scanFavorites(rows *sql.Rows) ([]models.Favorite, error) <span class="cov0" title="0">{
        var favorites []models.Favorite

        for rows.Next() </span><span class="cov0" title="0">{
                var favorite models.Favorite
                var tagsJSON sql.NullString
                var updatedAt sql.NullTime

                err := rows.Scan(
                        &amp;favorite.ID, &amp;favorite.UserID, &amp;favorite.EntityType, &amp;favorite.EntityID,
                        &amp;favorite.Category, &amp;favorite.Notes, &amp;tagsJSON, &amp;favorite.IsPublic,
                        &amp;favorite.CreatedAt, &amp;updatedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan favorite: %w", err)
                }</span>

                <span class="cov0" title="0">if tagsJSON.Valid </span><span class="cov0" title="0">{
                        var tags []string
                        if err := json.Unmarshal([]byte(tagsJSON.String), &amp;tags); err == nil </span><span class="cov0" title="0">{
                                favorite.Tags = &amp;tags
                        }</span>
                }

                <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                        favorite.UpdatedAt = &amp;updatedAt.Time
                }</span>

                <span class="cov0" title="0">favorites = append(favorites, favorite)</span>
        }

        <span class="cov0" title="0">return favorites, nil</span>
}

func (r *FavoritesRepository) scanFavoriteCategories(rows *sql.Rows) ([]models.FavoriteCategory, error) <span class="cov0" title="0">{
        var categories []models.FavoriteCategory

        for rows.Next() </span><span class="cov0" title="0">{
                var category models.FavoriteCategory
                var updatedAt sql.NullTime

                err := rows.Scan(
                        &amp;category.ID, &amp;category.UserID, &amp;category.Name, &amp;category.Description,
                        &amp;category.Color, &amp;category.Icon, &amp;category.IsPublic, &amp;category.CreatedAt, &amp;updatedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan category: %w", err)
                }</span>

                <span class="cov0" title="0">if updatedAt.Valid </span><span class="cov0" title="0">{
                        category.UpdatedAt = &amp;updatedAt.Time
                }</span>

                <span class="cov0" title="0">categories = append(categories, category)</span>
        }

        <span class="cov0" title="0">return categories, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "path/filepath"
        "strings"

        "catalogizer/database"
        "catalogizer/models"
)

// FileRepository handles file-related database operations
type FileRepository struct {
        db *database.DB
}

// NewFileRepository creates a new file repository
func NewFileRepository(db *database.DB) *FileRepository <span class="cov0" title="0">{
        return &amp;FileRepository{db: db}
}</span>

// GetFileByID retrieves a file by its ID
func (r *FileRepository) GetFileByID(ctx context.Context, id int64) (*models.FileWithMetadata, error) <span class="cov0" title="0">{
        query := `
                SELECT f.id, f.storage_root_id, sr.name as storage_root_name, f.path, f.name, f.extension,
                           f.mime_type, f.file_type, f.size, f.is_directory, f.created_at, f.modified_at,
                           f.accessed_at, f.deleted, f.deleted_at, f.last_scan_at, f.last_verified_at,
                           f.md5, f.sha256, f.sha1, f.blake3, f.quick_hash, f.is_duplicate,
                           f.duplicate_group_id, f.parent_id
                FROM files f
                JOIN storage_roots sr ON f.storage_root_id = sr.id
                WHERE f.id = ?`

        var file models.File
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;file.ID, &amp;file.StorageRootID, &amp;file.StorageRootName, &amp;file.Path, &amp;file.Name,
                &amp;file.Extension, &amp;file.MimeType, &amp;file.FileType, &amp;file.Size, &amp;file.IsDirectory,
                &amp;file.CreatedAt, &amp;file.ModifiedAt, &amp;file.AccessedAt, &amp;file.Deleted,
                &amp;file.DeletedAt, &amp;file.LastScanAt, &amp;file.LastVerifiedAt, &amp;file.MD5,
                &amp;file.SHA256, &amp;file.SHA1, &amp;file.BLAKE3, &amp;file.QuickHash, &amp;file.IsDuplicate,
                &amp;file.DuplicateGroupID, &amp;file.ParentID,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("file not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get file: %w", err)</span>
        }

        // Get metadata
        <span class="cov0" title="0">metadata, err := r.getFileMetadata(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file metadata: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;models.FileWithMetadata{
                File:     file,
                Metadata: metadata,
        }, nil</span>
}

// GetDirectoryContents retrieves files and directories within a path
func (r *FileRepository) GetDirectoryContents(ctx context.Context, storageRootName, path string, pagination models.PaginationOptions, sort models.SortOptions) (*models.SearchResult, error) <span class="cov0" title="0">{
        // Build the base query
        baseQuery := `
                FROM files f
                JOIN storage_roots sr ON f.storage_root_id = sr.id
                WHERE sr.name = ? AND f.deleted = FALSE`

        args := []interface{}{storageRootName}

        // Handle path filtering
        if path == "/" || path == "" </span><span class="cov0" title="0">{
                baseQuery += " AND f.parent_id IS NULL"
        }</span> else<span class="cov0" title="0"> {
                baseQuery += " AND f.path LIKE ?"
                args = append(args, path+"/%")
                // Ensure we only get direct children, not deeper descendants
                baseQuery += " AND f.path NOT LIKE ?"
                args = append(args, path+"/%/%")
        }</span>

        // Count total records
        <span class="cov0" title="0">countQuery := "SELECT COUNT(*) " + baseQuery
        var totalCount int64
        err := r.db.QueryRowContext(ctx, countQuery, args...).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count files: %w", err)
        }</span>

        // Build the main query with sorting and pagination
        <span class="cov0" title="0">selectQuery := `
                SELECT f.id, f.storage_root_id, sr.name as storage_root_name, f.path, f.name, f.extension,
                           f.mime_type, f.file_type, f.size, f.is_directory, f.created_at, f.modified_at,
                           f.accessed_at, f.deleted, f.deleted_at, f.last_scan_at, f.last_verified_at,
                           f.md5, f.sha256, f.sha1, f.blake3, f.quick_hash, f.is_duplicate,
                           f.duplicate_group_id, f.parent_id ` + baseQuery

        // Add sorting
        selectQuery += r.buildSortClause(sort)

        // Add pagination
        selectQuery += " LIMIT ? OFFSET ?"
        offset := (pagination.Page - 1) * pagination.Limit
        args = append(args, pagination.Limit, offset)

        rows, err := r.db.QueryContext(ctx, selectQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query files: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var files []models.FileWithMetadata
        for rows.Next() </span><span class="cov0" title="0">{
                var file models.File
                err := rows.Scan(
                        &amp;file.ID, &amp;file.StorageRootID, &amp;file.StorageRootName, &amp;file.Path, &amp;file.Name,
                        &amp;file.Extension, &amp;file.MimeType, &amp;file.FileType, &amp;file.Size, &amp;file.IsDirectory,
                        &amp;file.CreatedAt, &amp;file.ModifiedAt, &amp;file.AccessedAt, &amp;file.Deleted,
                        &amp;file.DeletedAt, &amp;file.LastScanAt, &amp;file.LastVerifiedAt, &amp;file.MD5,
                        &amp;file.SHA256, &amp;file.SHA1, &amp;file.BLAKE3, &amp;file.QuickHash, &amp;file.IsDuplicate,
                        &amp;file.DuplicateGroupID, &amp;file.ParentID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan file: %w", err)
                }</span>

                <span class="cov0" title="0">files = append(files, models.FileWithMetadata{File: file})</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating rows: %w", err)
        }</span>

        <span class="cov0" title="0">totalPages := int((totalCount + int64(pagination.Limit) - 1) / int64(pagination.Limit))

        return &amp;models.SearchResult{
                Files:      files,
                TotalCount: totalCount,
                Page:       pagination.Page,
                Limit:      pagination.Limit,
                TotalPages: totalPages,
        }, nil</span>
}

// SearchFiles performs advanced file search
func (r *FileRepository) SearchFiles(ctx context.Context, filter models.SearchFilter, pagination models.PaginationOptions, sort models.SortOptions) (*models.SearchResult, error) <span class="cov0" title="0">{
        // Build the base query
        baseQuery := `
                FROM files f
                JOIN storage_roots sr ON f.storage_root_id = sr.id
                WHERE 1=1`

        args := []interface{}{}

        // Apply filters
        baseQuery, args = r.applySearchFilters(baseQuery, args, filter)

        // Count total records
        countQuery := "SELECT COUNT(*) " + baseQuery
        var totalCount int64
        err := r.db.QueryRowContext(ctx, countQuery, args...).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count search results: %w", err)
        }</span>

        // Build the main query with sorting and pagination
        <span class="cov0" title="0">selectQuery := `
                SELECT f.id, f.storage_root_id, sr.name as storage_root_name, f.path, f.name, f.extension,
                           f.mime_type, f.file_type, f.size, f.is_directory, f.created_at, f.modified_at,
                           f.accessed_at, f.deleted, f.deleted_at, f.last_scan_at, f.last_verified_at,
                           f.md5, f.sha256, f.sha1, f.blake3, f.quick_hash, f.is_duplicate,
                           f.duplicate_group_id, f.parent_id ` + baseQuery

        // Add sorting
        selectQuery += r.buildSortClause(sort)

        // Add pagination
        selectQuery += " LIMIT ? OFFSET ?"
        offset := (pagination.Page - 1) * pagination.Limit
        args = append(args, pagination.Limit, offset)

        rows, err := r.db.QueryContext(ctx, selectQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute search query: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var files []models.FileWithMetadata
        for rows.Next() </span><span class="cov0" title="0">{
                var file models.File
                err := rows.Scan(
                        &amp;file.ID, &amp;file.StorageRootID, &amp;file.StorageRootName, &amp;file.Path, &amp;file.Name,
                        &amp;file.Extension, &amp;file.MimeType, &amp;file.FileType, &amp;file.Size, &amp;file.IsDirectory,
                        &amp;file.CreatedAt, &amp;file.ModifiedAt, &amp;file.AccessedAt, &amp;file.Deleted,
                        &amp;file.DeletedAt, &amp;file.LastScanAt, &amp;file.LastVerifiedAt, &amp;file.MD5,
                        &amp;file.SHA256, &amp;file.SHA1, &amp;file.BLAKE3, &amp;file.QuickHash, &amp;file.IsDuplicate,
                        &amp;file.DuplicateGroupID, &amp;file.ParentID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan search result: %w", err)
                }</span>

                // Get metadata for search results if needed
                <span class="cov0" title="0">metadata, err := r.getFileMetadata(ctx, file.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get file metadata: %w", err)
                }</span>

                <span class="cov0" title="0">files = append(files, models.FileWithMetadata{
                        File:     file,
                        Metadata: metadata,
                })</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating search results: %w", err)
        }</span>

        <span class="cov0" title="0">totalPages := int((totalCount + int64(pagination.Limit) - 1) / int64(pagination.Limit))

        return &amp;models.SearchResult{
                Files:      files,
                TotalCount: totalCount,
                Page:       pagination.Page,
                Limit:      pagination.Limit,
                TotalPages: totalPages,
        }, nil</span>
}

// GetDirectoriesSortedBySize retrieves directories sorted by total size
func (r *FileRepository) GetDirectoriesSortedBySize(ctx context.Context, storageRootName string, pagination models.PaginationOptions, ascending bool) ([]models.DirectoryInfo, error) <span class="cov0" title="0">{
        order := "DESC"
        if ascending </span><span class="cov0" title="0">{
                order = "ASC"
        }</span>

        <span class="cov0" title="0">query := `
                WITH RECURSIVE directory_tree AS (
                        SELECT f.path, f.name, sr.name as storage_root_name,
                                   COUNT(CASE WHEN f2.is_directory = FALSE THEN 1 END) as file_count,
                                   COUNT(CASE WHEN f2.is_directory = TRUE THEN 1 END) as directory_count,
                                   COALESCE(SUM(CASE WHEN f2.is_directory = FALSE THEN f2.size ELSE 0 END), 0) as total_size,
                                   COUNT(CASE WHEN f2.is_duplicate = TRUE THEN 1 END) as duplicate_count,
                                   MAX(f.modified_at) as modified_at
                        FROM files f
                        JOIN storage_roots sr ON f.storage_root_id = sr.id
                        LEFT JOIN files f2 ON f2.path LIKE f.path || '/%' AND f2.storage_root_id = f.storage_root_id AND f2.deleted = FALSE
                        WHERE f.is_directory = TRUE AND f.deleted = FALSE AND sr.name = ?
                        GROUP BY f.path, f.name, sr.name
                )
                SELECT path, name, storage_root_name, file_count, directory_count, total_size, duplicate_count, modified_at
                FROM directory_tree
                ORDER BY total_size ` + order + `
                LIMIT ? OFFSET ?`

        offset := (pagination.Page - 1) * pagination.Limit
        rows, err := r.db.QueryContext(ctx, query, storageRootName, pagination.Limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query directories by size: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var directories []models.DirectoryInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var dir models.DirectoryInfo
                err := rows.Scan(
                        &amp;dir.Path, &amp;dir.Name, &amp;dir.StorageRootName, &amp;dir.FileCount,
                        &amp;dir.DirectoryCount, &amp;dir.TotalSize, &amp;dir.DuplicateCount, &amp;dir.ModifiedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan directory info: %w", err)
                }</span>
                <span class="cov0" title="0">directories = append(directories, dir)</span>
        }

        <span class="cov0" title="0">return directories, nil</span>
}

// GetDirectoriesSortedByDuplicates retrieves directories sorted by duplicate count
func (r *FileRepository) GetDirectoriesSortedByDuplicates(ctx context.Context, storageRootName string, pagination models.PaginationOptions, ascending bool) ([]models.DirectoryInfo, error) <span class="cov0" title="0">{
        order := "DESC"
        if ascending </span><span class="cov0" title="0">{
                order = "ASC"
        }</span>

        <span class="cov0" title="0">query := `
                WITH RECURSIVE directory_tree AS (
                        SELECT f.path, f.name, sr.name as storage_root_name,
                                   COUNT(CASE WHEN f2.is_directory = FALSE THEN 1 END) as file_count,
                                   COUNT(CASE WHEN f2.is_directory = TRUE THEN 1 END) as directory_count,
                                   COALESCE(SUM(CASE WHEN f2.is_directory = FALSE THEN f2.size ELSE 0 END), 0) as total_size,
                                   COUNT(CASE WHEN f2.is_duplicate = TRUE THEN 1 END) as duplicate_count,
                                   MAX(f.modified_at) as modified_at
                        FROM files f
                        JOIN storage_roots sr ON f.storage_root_id = sr.id
                        LEFT JOIN files f2 ON f2.path LIKE f.path || '/%' AND f2.storage_root_id = f.storage_root_id AND f2.deleted = FALSE
                        WHERE f.is_directory = TRUE AND f.deleted = FALSE AND sr.name = ?
                        GROUP BY f.path, f.name, sr.name
                )
                SELECT path, name, storage_root_name, file_count, directory_count, total_size, duplicate_count, modified_at
                FROM directory_tree
                ORDER BY duplicate_count ` + order + `
                LIMIT ? OFFSET ?`

        offset := (pagination.Page - 1) * pagination.Limit
        rows, err := r.db.QueryContext(ctx, query, storageRootName, pagination.Limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query directories by duplicates: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var directories []models.DirectoryInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var dir models.DirectoryInfo
                err := rows.Scan(
                        &amp;dir.Path, &amp;dir.Name, &amp;dir.StorageRootName, &amp;dir.FileCount,
                        &amp;dir.DirectoryCount, &amp;dir.TotalSize, &amp;dir.DuplicateCount, &amp;dir.ModifiedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan directory info: %w", err)
                }</span>
                <span class="cov0" title="0">directories = append(directories, dir)</span>
        }

        <span class="cov0" title="0">return directories, nil</span>
}

// GetStorageRoots retrieves all storage roots
func (r *FileRepository) GetStorageRoots(ctx context.Context) ([]models.StorageRoot, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, protocol, host, port, path, username, password, domain,
                           mount_point, options, url, enabled, max_depth,
                           enable_duplicate_detection, enable_metadata_extraction, include_patterns,
                           exclude_patterns, created_at, updated_at, last_scan_at
                FROM storage_roots
                ORDER BY name`

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query storage roots: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var roots []models.StorageRoot
        for rows.Next() </span><span class="cov0" title="0">{
                var root models.StorageRoot
                err := rows.Scan(
                        &amp;root.ID, &amp;root.Name, &amp;root.Protocol, &amp;root.Host, &amp;root.Port, &amp;root.Path,
                        &amp;root.Username, &amp;root.Password, &amp;root.Domain, &amp;root.MountPoint, &amp;root.Options,
                        &amp;root.URL, &amp;root.Enabled, &amp;root.MaxDepth, &amp;root.EnableDuplicateDetection,
                        &amp;root.EnableMetadataExtraction, &amp;root.IncludePatterns, &amp;root.ExcludePatterns,
                        &amp;root.CreatedAt, &amp;root.UpdatedAt, &amp;root.LastScanAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan storage root: %w", err)
                }</span>
                <span class="cov0" title="0">roots = append(roots, root)</span>
        }

        <span class="cov0" title="0">return roots, nil</span>
}

// Helper methods

func (r *FileRepository) getFileMetadata(ctx context.Context, fileID int64) ([]models.FileMetadata, error) <span class="cov0" title="0">{
        query := `
                SELECT id, file_id, key, value, data_type
                FROM file_metadata
                WHERE file_id = ?
                ORDER BY key`

        rows, err := r.db.QueryContext(ctx, query, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query file metadata: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var metadata []models.FileMetadata
        for rows.Next() </span><span class="cov0" title="0">{
                var meta models.FileMetadata
                err := rows.Scan(&amp;meta.ID, &amp;meta.FileID, &amp;meta.Key, &amp;meta.Value, &amp;meta.DataType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan metadata: %w", err)
                }</span>
                <span class="cov0" title="0">metadata = append(metadata, meta)</span>
        }

        <span class="cov0" title="0">return metadata, nil</span>
}

func (r *FileRepository) buildSortClause(sort models.SortOptions) string <span class="cov0" title="0">{
        var clause strings.Builder
        clause.WriteString(" ORDER BY ")

        switch sort.Field </span>{
        case "name":<span class="cov0" title="0">
                clause.WriteString("f.name")</span>
        case "size":<span class="cov0" title="0">
                clause.WriteString("f.size")</span>
        case "modified_at":<span class="cov0" title="0">
                clause.WriteString("f.modified_at")</span>
        case "created_at":<span class="cov0" title="0">
                clause.WriteString("f.created_at")</span>
        case "path":<span class="cov0" title="0">
                clause.WriteString("f.path")</span>
        case "extension":<span class="cov0" title="0">
                clause.WriteString("f.extension")</span>
        default:<span class="cov0" title="0">
                clause.WriteString("f.name")</span> // Default sort
        }

        <span class="cov0" title="0">if sort.Order == "desc" </span><span class="cov0" title="0">{
                clause.WriteString(" DESC")
        }</span> else<span class="cov0" title="0"> {
                clause.WriteString(" ASC")
        }</span>

        <span class="cov0" title="0">return clause.String()</span>
}

func (r *FileRepository) applySearchFilters(baseQuery string, args []interface{}, filter models.SearchFilter) (string, []interface{}) <span class="cov0" title="0">{
        if !filter.IncludeDeleted </span><span class="cov0" title="0">{
                baseQuery += " AND f.deleted = FALSE"
        }</span>

        <span class="cov0" title="0">if filter.Query != "" </span><span class="cov0" title="0">{
                baseQuery += " AND (f.name LIKE ? OR f.path LIKE ?)"
                searchPattern := "%" + filter.Query + "%"
                args = append(args, searchPattern, searchPattern)
        }</span>

        <span class="cov0" title="0">if filter.Path != "" </span><span class="cov0" title="0">{
                baseQuery += " AND f.path LIKE ?"
                args = append(args, "%"+filter.Path+"%")
        }</span>

        <span class="cov0" title="0">if filter.Name != "" </span><span class="cov0" title="0">{
                baseQuery += " AND f.name LIKE ?"
                args = append(args, "%"+filter.Name+"%")
        }</span>

        <span class="cov0" title="0">if filter.Extension != "" </span><span class="cov0" title="0">{
                baseQuery += " AND f.extension = ?"
                args = append(args, filter.Extension)
        }</span>

        <span class="cov0" title="0">if filter.FileType != "" </span><span class="cov0" title="0">{
                baseQuery += " AND f.file_type = ?"
                args = append(args, filter.FileType)
        }</span>

        <span class="cov0" title="0">if filter.MimeType != "" </span><span class="cov0" title="0">{
                baseQuery += " AND f.mime_type = ?"
                args = append(args, filter.MimeType)
        }</span>

        <span class="cov0" title="0">if len(filter.StorageRoots) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := strings.Repeat("?,", len(filter.StorageRoots))
                placeholders = placeholders[:len(placeholders)-1] // Remove trailing comma
                baseQuery += " AND sr.name IN (" + placeholders + ")"
                for _, root := range filter.StorageRoots </span><span class="cov0" title="0">{
                        args = append(args, root)
                }</span>
        }

        <span class="cov0" title="0">if filter.MinSize != nil </span><span class="cov0" title="0">{
                baseQuery += " AND f.size &gt;= ?"
                args = append(args, *filter.MinSize)
        }</span>

        <span class="cov0" title="0">if filter.MaxSize != nil </span><span class="cov0" title="0">{
                baseQuery += " AND f.size &lt;= ?"
                args = append(args, *filter.MaxSize)
        }</span>

        <span class="cov0" title="0">if filter.ModifiedAfter != nil </span><span class="cov0" title="0">{
                baseQuery += " AND f.modified_at &gt;= ?"
                args = append(args, *filter.ModifiedAfter)
        }</span>

        <span class="cov0" title="0">if filter.ModifiedBefore != nil </span><span class="cov0" title="0">{
                baseQuery += " AND f.modified_at &lt;= ?"
                args = append(args, *filter.ModifiedBefore)
        }</span>

        <span class="cov0" title="0">if filter.OnlyDuplicates </span><span class="cov0" title="0">{
                baseQuery += " AND f.is_duplicate = TRUE"
        }</span> else<span class="cov0" title="0"> if filter.ExcludeDuplicates </span><span class="cov0" title="0">{
                baseQuery += " AND f.is_duplicate = FALSE"
        }</span>

        <span class="cov0" title="0">if !filter.IncludeDirectories </span><span class="cov0" title="0">{
                baseQuery += " AND f.is_directory = FALSE"
        }</span>

        <span class="cov0" title="0">return baseQuery, args</span>
}

// UpdateFilePath updates a file's path and related metadata efficiently
func (r *FileRepository) UpdateFilePath(ctx context.Context, fileID int64, newPath string) error <span class="cov0" title="0">{
        // Extract new filename and directory info
        newName := filepath.Base(newPath)
        newDir := filepath.Dir(newPath)

        // Get parent directory ID
        var parentID *int64
        if newDir != "/" &amp;&amp; newDir != "." </span><span class="cov0" title="0">{
                parentQuery := `SELECT id FROM files WHERE path = ? AND is_directory = true LIMIT 1`
                err := r.db.QueryRowContext(ctx, parentQuery, newDir).Scan(&amp;parentID)
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get parent directory: %w", err)
                }</span>
        }

        // Update file record
        <span class="cov0" title="0">updateQuery := `
                UPDATE files
                SET path = ?, name = ?, parent_id = ?, modified_at = CURRENT_TIMESTAMP,
                    last_scan_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := r.db.ExecContext(ctx, updateQuery, newPath, newName, parentID, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update file path: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateDirectoryPaths updates a directory and all its children paths efficiently
func (r *FileRepository) UpdateDirectoryPaths(ctx context.Context, oldPath, newPath, storageRootName string) error <span class="cov0" title="0">{
        // Get all files/directories that need to be updated
        query := `
                SELECT id, path, is_directory
                FROM files
                WHERE storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)
                  AND (path = ? OR path LIKE ?)
                ORDER BY LENGTH(path) ASC` // Process parents before children

        oldPathPattern := oldPath + "/%"
        rows, err := r.db.QueryContext(ctx, query, storageRootName, oldPath, oldPathPattern)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query directory contents: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        type fileUpdate struct {
                ID          int64
                OldPath     string
                IsDirectory bool
        }

        var updates []fileUpdate
        for rows.Next() </span><span class="cov0" title="0">{
                var update fileUpdate
                if err := rows.Scan(&amp;update.ID, &amp;update.OldPath, &amp;update.IsDirectory); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan file for update: %w", err)
                }</span>
                <span class="cov0" title="0">updates = append(updates, update)</span>
        }

        // Update each file/directory path
        <span class="cov0" title="0">for _, update := range updates </span><span class="cov0" title="0">{
                var updatedPath string
                if update.OldPath == oldPath </span><span class="cov0" title="0">{
                        // This is the directory itself
                        updatedPath = newPath
                }</span> else<span class="cov0" title="0"> {
                        // This is a child - replace the old path prefix with new path
                        relativePath := update.OldPath[len(oldPath):]
                        updatedPath = newPath + relativePath
                }</span>

                // Update the file record using the existing method
                <span class="cov0" title="0">if err := r.UpdateFilePath(ctx, update.ID, updatedPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update path for file ID %d: %w", update.ID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetFileByPathAndStorage retrieves a file by path and storage root
func (r *FileRepository) GetFileByPathAndStorage(ctx context.Context, path, storageRootName string) (*models.File, error) <span class="cov0" title="0">{
        query := `
                SELECT f.id, f.storage_root_id, sr.name as storage_root_name, f.path, f.name, f.extension,
                       f.mime_type, f.file_type, f.size, f.is_directory, f.created_at, f.modified_at,
                       f.accessed_at, f.deleted, f.deleted_at, f.last_scan_at, f.last_verified_at,
                       f.md5, f.sha256, f.sha1, f.blake3, f.quick_hash, f.is_duplicate,
                       f.duplicate_group_id, f.parent_id
                FROM files f
                JOIN storage_roots sr ON f.storage_root_id = sr.id
                WHERE f.path = ? AND sr.name = ?`

        var file models.File
        err := r.db.QueryRowContext(ctx, query, path, storageRootName).Scan(
                &amp;file.ID, &amp;file.StorageRootID, &amp;file.StorageRootName, &amp;file.Path, &amp;file.Name,
                &amp;file.Extension, &amp;file.MimeType, &amp;file.FileType, &amp;file.Size, &amp;file.IsDirectory,
                &amp;file.CreatedAt, &amp;file.ModifiedAt, &amp;file.AccessedAt, &amp;file.Deleted,
                &amp;file.DeletedAt, &amp;file.LastScanAt, &amp;file.LastVerifiedAt, &amp;file.MD5,
                &amp;file.SHA256, &amp;file.SHA1, &amp;file.BLAKE3, &amp;file.QuickHash, &amp;file.IsDuplicate,
                &amp;file.DuplicateGroupID, &amp;file.ParentID,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get file: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;file, nil</span>
}

// MarkFileAsDeleted marks a file as deleted instead of removing it immediately
func (r *FileRepository) MarkFileAsDeleted(ctx context.Context, fileID int64) error <span class="cov0" title="0">{
        query := `
                UPDATE files
                SET deleted = true, deleted_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := r.db.ExecContext(ctx, query, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark file as deleted: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RestoreDeletedFile restores a file that was marked as deleted
func (r *FileRepository) RestoreDeletedFile(ctx context.Context, fileID int64) error <span class="cov0" title="0">{
        query := `
                UPDATE files
                SET deleted = false, deleted_at = NULL, last_scan_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := r.db.ExecContext(ctx, query, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restore deleted file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFilesWithHash finds files by their hash for duplicate detection and move tracking
func (r *FileRepository) GetFilesWithHash(ctx context.Context, hash string, storageRootName string) ([]models.File, error) <span class="cov0" title="0">{
        query := `
                SELECT f.id, f.storage_root_id, sr.name as storage_root_name, f.path, f.name, f.extension,
                       f.mime_type, f.file_type, f.size, f.is_directory, f.created_at, f.modified_at,
                       f.accessed_at, f.deleted, f.deleted_at, f.last_scan_at, f.last_verified_at,
                       f.md5, f.sha256, f.sha1, f.blake3, f.quick_hash, f.is_duplicate,
                       f.duplicate_group_id, f.parent_id
                FROM files f
                JOIN storage_roots sr ON f.storage_root_id = sr.id
                WHERE (f.md5 = ? OR f.sha256 = ? OR f.sha1 = ? OR f.blake3 = ? OR f.quick_hash = ?)
                  AND sr.name = ?
                  AND f.deleted = false`

        rows, err := r.db.QueryContext(ctx, query, hash, hash, hash, hash, hash, storageRootName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query files by hash: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var files []models.File
        for rows.Next() </span><span class="cov0" title="0">{
                var file models.File
                err := rows.Scan(
                        &amp;file.ID, &amp;file.StorageRootID, &amp;file.StorageRootName, &amp;file.Path, &amp;file.Name,
                        &amp;file.Extension, &amp;file.MimeType, &amp;file.FileType, &amp;file.Size, &amp;file.IsDirectory,
                        &amp;file.CreatedAt, &amp;file.ModifiedAt, &amp;file.AccessedAt, &amp;file.Deleted,
                        &amp;file.DeletedAt, &amp;file.LastScanAt, &amp;file.LastVerifiedAt, &amp;file.MD5,
                        &amp;file.SHA256, &amp;file.SHA1, &amp;file.BLAKE3, &amp;file.QuickHash, &amp;file.IsDuplicate,
                        &amp;file.DuplicateGroupID, &amp;file.ParentID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan file: %w", err)
                }</span>
                <span class="cov0" title="0">files = append(files, file)</span>
        }

        <span class="cov0" title="0">return files, nil</span>
}

// UpdateFileMetadata updates file metadata without triggering a full rescan
func (r *FileRepository) UpdateFileMetadata(ctx context.Context, fileID int64, size int64, hash *string) error <span class="cov0" title="0">{
        query := `
                UPDATE files
                SET size = ?, quick_hash = ?, last_scan_at = CURRENT_TIMESTAMP, modified_at = CURRENT_TIMESTAMP
                WHERE id = ?`

        _, err := r.db.ExecContext(ctx, query, size, hash, fileID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update file metadata: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
)

type LogManagementRepository struct {
        db *sql.DB
}

func NewLogManagementRepository(db *sql.DB) *LogManagementRepository <span class="cov0" title="0">{
        return &amp;LogManagementRepository{db: db}
}</span>

func (r *LogManagementRepository) CreateLogCollection(collection *models.LogCollection) error <span class="cov0" title="0">{
        componentsJSON, err := json.Marshal(collection.Components)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal components: %w", err)
        }</span>

        <span class="cov0" title="0">filtersJSON, err := json.Marshal(collection.Filters)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal filters: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO log_collections (
                        user_id, name, description, components, log_level, start_time,
                        end_time, created_at, status, filters
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                collection.UserID, collection.Name, collection.Description,
                string(componentsJSON), collection.LogLevel, collection.StartTime,
                collection.EndTime, collection.CreatedAt, collection.Status,
                string(filtersJSON))

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log collection: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">collection.ID = int(id)
        return nil</span>
}

func (r *LogManagementRepository) GetLogCollection(id int) (*models.LogCollection, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, description, components, log_level, start_time,
                           end_time, created_at, completed_at, status, entry_count, filters
                FROM log_collections WHERE id = ?`

        var collection models.LogCollection
        var componentsJSON, filtersJSON string
        var startTime, endTime, completedAt sql.NullTime

        err := r.db.QueryRow(query, id).Scan(
                &amp;collection.ID, &amp;collection.UserID, &amp;collection.Name,
                &amp;collection.Description, &amp;componentsJSON, &amp;collection.LogLevel,
                &amp;startTime, &amp;endTime, &amp;collection.CreatedAt, &amp;completedAt,
                &amp;collection.Status, &amp;collection.EntryCount, &amp;filtersJSON)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log collection: %w", err)
        }</span>

        <span class="cov0" title="0">if startTime.Valid </span><span class="cov0" title="0">{
                collection.StartTime = &amp;startTime.Time
        }</span>
        <span class="cov0" title="0">if endTime.Valid </span><span class="cov0" title="0">{
                collection.EndTime = &amp;endTime.Time
        }</span>
        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                collection.CompletedAt = &amp;completedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(componentsJSON), &amp;collection.Components); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal components: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(filtersJSON), &amp;collection.Filters); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal filters: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;collection, nil</span>
}

func (r *LogManagementRepository) UpdateLogCollection(collection *models.LogCollection) error <span class="cov0" title="0">{
        componentsJSON, err := json.Marshal(collection.Components)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal components: %w", err)
        }</span>

        <span class="cov0" title="0">filtersJSON, err := json.Marshal(collection.Filters)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal filters: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE log_collections SET
                        name = ?, description = ?, components = ?, log_level = ?,
                        start_time = ?, end_time = ?, completed_at = ?, status = ?,
                        entry_count = ?, filters = ?
                WHERE id = ?`

        _, err = r.db.Exec(query,
                collection.Name, collection.Description, string(componentsJSON),
                collection.LogLevel, collection.StartTime, collection.EndTime,
                collection.CompletedAt, collection.Status, collection.EntryCount,
                string(filtersJSON), collection.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update log collection: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *LogManagementRepository) GetLogCollectionsByUser(userID int, limit, offset int) ([]*models.LogCollection, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, description, components, log_level, start_time,
                           end_time, created_at, completed_at, status, entry_count, filters
                FROM log_collections
                WHERE user_id = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?`

        rows, err := r.db.Query(query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log collections: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var collections []*models.LogCollection
        for rows.Next() </span><span class="cov0" title="0">{
                var collection models.LogCollection
                var componentsJSON, filtersJSON string
                var startTime, endTime, completedAt sql.NullTime

                err := rows.Scan(
                        &amp;collection.ID, &amp;collection.UserID, &amp;collection.Name,
                        &amp;collection.Description, &amp;componentsJSON, &amp;collection.LogLevel,
                        &amp;startTime, &amp;endTime, &amp;collection.CreatedAt, &amp;completedAt,
                        &amp;collection.Status, &amp;collection.EntryCount, &amp;filtersJSON)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan log collection: %w", err)
                }</span>

                <span class="cov0" title="0">if startTime.Valid </span><span class="cov0" title="0">{
                        collection.StartTime = &amp;startTime.Time
                }</span>
                <span class="cov0" title="0">if endTime.Valid </span><span class="cov0" title="0">{
                        collection.EndTime = &amp;endTime.Time
                }</span>
                <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                        collection.CompletedAt = &amp;completedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(componentsJSON), &amp;collection.Components); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal components: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(filtersJSON), &amp;collection.Filters); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal filters: %w", err)
                }</span>

                <span class="cov0" title="0">collections = append(collections, &amp;collection)</span>
        }

        <span class="cov0" title="0">return collections, nil</span>
}

func (r *LogManagementRepository) DeleteLogCollection(id int) error <span class="cov0" title="0">{
        // First delete associated log entries
        if err := r.DeleteLogEntriesByCollection(id); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete log entries: %w", err)
        }</span>

        <span class="cov0" title="0">query := "DELETE FROM log_collections WHERE id = ?"
        _, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete log collection: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *LogManagementRepository) CreateLogEntry(entry *models.LogEntry) error <span class="cov0" title="0">{
        contextJSON, err := json.Marshal(entry.Context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal context: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO log_entries (
                        collection_id, timestamp, level, component, message, context
                ) VALUES (?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                entry.CollectionID, entry.Timestamp, entry.Level,
                entry.Component, entry.Message, string(contextJSON))

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log entry: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">entry.ID = int(id)
        return nil</span>
}

func (r *LogManagementRepository) GetLogEntries(collectionID int, filters *models.LogEntryFilters) ([]*models.LogEntry, error) <span class="cov0" title="0">{
        query := `
                SELECT id, collection_id, timestamp, level, component, message, context
                FROM log_entries
                WHERE collection_id = ?`

        args := []interface{}{collectionID}

        if filters != nil </span><span class="cov0" title="0">{
                if filters.Level != "" </span><span class="cov0" title="0">{
                        query += " AND level = ?"
                        args = append(args, filters.Level)
                }</span>

                <span class="cov0" title="0">if filters.Component != "" </span><span class="cov0" title="0">{
                        query += " AND component = ?"
                        args = append(args, filters.Component)
                }</span>

                <span class="cov0" title="0">if filters.StartTime != nil </span><span class="cov0" title="0">{
                        query += " AND timestamp &gt;= ?"
                        args = append(args, *filters.StartTime)
                }</span>

                <span class="cov0" title="0">if filters.EndTime != nil </span><span class="cov0" title="0">{
                        query += " AND timestamp &lt;= ?"
                        args = append(args, *filters.EndTime)
                }</span>

                <span class="cov0" title="0">if filters.Search != "" </span><span class="cov0" title="0">{
                        query += " AND message LIKE ?"
                        args = append(args, "%"+filters.Search+"%")
                }</span>
        }

        <span class="cov0" title="0">query += " ORDER BY timestamp ASC"

        if filters != nil &amp;&amp; filters.Limit &gt; 0 </span><span class="cov0" title="0">{
                query += " LIMIT ?"
                args = append(args, filters.Limit)

                if filters.Offset &gt; 0 </span><span class="cov0" title="0">{
                        query += " OFFSET ?"
                        args = append(args, filters.Offset)
                }</span>
        }

        <span class="cov0" title="0">rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log entries: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var entries []*models.LogEntry
        for rows.Next() </span><span class="cov0" title="0">{
                var entry models.LogEntry
                var contextJSON string

                err := rows.Scan(
                        &amp;entry.ID, &amp;entry.CollectionID, &amp;entry.Timestamp,
                        &amp;entry.Level, &amp;entry.Component, &amp;entry.Message, &amp;contextJSON)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan log entry: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;entry.Context); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal context: %w", err)
                }</span>

                <span class="cov0" title="0">entries = append(entries, &amp;entry)</span>
        }

        <span class="cov0" title="0">return entries, nil</span>
}

func (r *LogManagementRepository) DeleteLogEntriesByCollection(collectionID int) error <span class="cov0" title="0">{
        query := "DELETE FROM log_entries WHERE collection_id = ?"
        _, err := r.db.Exec(query, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete log entries: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *LogManagementRepository) GetRecentLogEntries(component string, limit int) ([]*models.LogEntry, error) <span class="cov0" title="0">{
        query := `
                SELECT id, collection_id, timestamp, level, component, message, context
                FROM log_entries
                WHERE component = ?
                ORDER BY timestamp DESC
                LIMIT ?`

        rows, err := r.db.Query(query, component, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent log entries: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var entries []*models.LogEntry
        for rows.Next() </span><span class="cov0" title="0">{
                var entry models.LogEntry
                var contextJSON string

                err := rows.Scan(
                        &amp;entry.ID, &amp;entry.CollectionID, &amp;entry.Timestamp,
                        &amp;entry.Level, &amp;entry.Component, &amp;entry.Message, &amp;contextJSON)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan log entry: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(contextJSON), &amp;entry.Context); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal context: %w", err)
                }</span>

                <span class="cov0" title="0">entries = append(entries, &amp;entry)</span>
        }

        <span class="cov0" title="0">return entries, nil</span>
}

func (r *LogManagementRepository) CreateLogShare(share *models.LogShare) error <span class="cov0" title="0">{
        permissionsJSON, err := json.Marshal(share.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">recipientsJSON, err := json.Marshal(share.Recipients)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal recipients: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO log_shares (
                        collection_id, user_id, share_token, share_type, expires_at,
                        created_at, is_active, permissions, recipients
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                share.CollectionID, share.UserID, share.ShareToken, share.ShareType,
                share.ExpiresAt, share.CreatedAt, share.IsActive,
                string(permissionsJSON), string(recipientsJSON))

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log share: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">share.ID = int(id)
        return nil</span>
}

func (r *LogManagementRepository) GetLogShare(id int) (*models.LogShare, error) <span class="cov0" title="0">{
        query := `
                SELECT id, collection_id, user_id, share_token, share_type, expires_at,
                           created_at, accessed_at, is_active, permissions, recipients
                FROM log_shares WHERE id = ?`

        var share models.LogShare
        var permissionsJSON, recipientsJSON string
        var accessedAt sql.NullTime

        err := r.db.QueryRow(query, id).Scan(
                &amp;share.ID, &amp;share.CollectionID, &amp;share.UserID, &amp;share.ShareToken,
                &amp;share.ShareType, &amp;share.ExpiresAt, &amp;share.CreatedAt, &amp;accessedAt,
                &amp;share.IsActive, &amp;permissionsJSON, &amp;recipientsJSON)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log share: %w", err)
        }</span>

        <span class="cov0" title="0">if accessedAt.Valid </span><span class="cov0" title="0">{
                share.AccessedAt = &amp;accessedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(permissionsJSON), &amp;share.Permissions); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(recipientsJSON), &amp;share.Recipients); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal recipients: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;share, nil</span>
}

func (r *LogManagementRepository) GetLogShareByToken(token string) (*models.LogShare, error) <span class="cov0" title="0">{
        query := `
                SELECT id, collection_id, user_id, share_token, share_type, expires_at,
                           created_at, accessed_at, is_active, permissions, recipients
                FROM log_shares WHERE share_token = ?`

        var share models.LogShare
        var permissionsJSON, recipientsJSON string
        var accessedAt sql.NullTime

        err := r.db.QueryRow(query, token).Scan(
                &amp;share.ID, &amp;share.CollectionID, &amp;share.UserID, &amp;share.ShareToken,
                &amp;share.ShareType, &amp;share.ExpiresAt, &amp;share.CreatedAt, &amp;accessedAt,
                &amp;share.IsActive, &amp;permissionsJSON, &amp;recipientsJSON)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log share by token: %w", err)
        }</span>

        <span class="cov0" title="0">if accessedAt.Valid </span><span class="cov0" title="0">{
                share.AccessedAt = &amp;accessedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(permissionsJSON), &amp;share.Permissions); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(recipientsJSON), &amp;share.Recipients); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal recipients: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;share, nil</span>
}

func (r *LogManagementRepository) UpdateLogShare(share *models.LogShare) error <span class="cov0" title="0">{
        permissionsJSON, err := json.Marshal(share.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">recipientsJSON, err := json.Marshal(share.Recipients)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal recipients: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE log_shares SET
                        share_type = ?, expires_at = ?, accessed_at = ?, is_active = ?,
                        permissions = ?, recipients = ?
                WHERE id = ?`

        _, err = r.db.Exec(query,
                share.ShareType, share.ExpiresAt, share.AccessedAt, share.IsActive,
                string(permissionsJSON), string(recipientsJSON), share.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update log share: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *LogManagementRepository) GetLogSharesByUser(userID int) ([]*models.LogShare, error) <span class="cov0" title="0">{
        query := `
                SELECT id, collection_id, user_id, share_token, share_type, expires_at,
                           created_at, accessed_at, is_active, permissions, recipients
                FROM log_shares
                WHERE user_id = ?
                ORDER BY created_at DESC`

        rows, err := r.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log shares: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var shares []*models.LogShare
        for rows.Next() </span><span class="cov0" title="0">{
                var share models.LogShare
                var permissionsJSON, recipientsJSON string
                var accessedAt sql.NullTime

                err := rows.Scan(
                        &amp;share.ID, &amp;share.CollectionID, &amp;share.UserID, &amp;share.ShareToken,
                        &amp;share.ShareType, &amp;share.ExpiresAt, &amp;share.CreatedAt, &amp;accessedAt,
                        &amp;share.IsActive, &amp;permissionsJSON, &amp;recipientsJSON)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan log share: %w", err)
                }</span>

                <span class="cov0" title="0">if accessedAt.Valid </span><span class="cov0" title="0">{
                        share.AccessedAt = &amp;accessedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(permissionsJSON), &amp;share.Permissions); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal permissions: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(recipientsJSON), &amp;share.Recipients); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal recipients: %w", err)
                }</span>

                <span class="cov0" title="0">shares = append(shares, &amp;share)</span>
        }

        <span class="cov0" title="0">return shares, nil</span>
}

func (r *LogManagementRepository) CleanupOldCollections(olderThan time.Time) error <span class="cov0" title="0">{
        query := "DELETE FROM log_collections WHERE created_at &lt; ?"
        _, err := r.db.Exec(query, olderThan)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old collections: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *LogManagementRepository) CleanupExpiredShares() error <span class="cov0" title="0">{
        query := "UPDATE log_shares SET is_active = 0 WHERE expires_at &lt; datetime('now') AND is_active = 1"
        _, err := r.db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup expired shares: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *LogManagementRepository) GetLogStatistics(userID int) (*models.LogStatistics, error) <span class="cov0" title="0">{
        stats := &amp;models.LogStatistics{}

        // Total collections
        err := r.db.QueryRow("SELECT COUNT(*) FROM log_collections WHERE user_id = ?", userID).Scan(&amp;stats.TotalCollections)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total collections: %w", err)
        }</span>

        // Total entries
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COALESCE(SUM(lc.entry_count), 0)
                FROM log_collections lc
                WHERE lc.user_id = ?`, userID).Scan(&amp;stats.TotalEntries)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total entries: %w", err)
        }</span>

        // Active shares
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM log_shares
                WHERE user_id = ? AND is_active = 1 AND expires_at &gt; datetime('now')`, userID).Scan(&amp;stats.ActiveShares)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active shares: %w", err)
        }</span>

        // Collections by status
        <span class="cov0" title="0">statusQuery := `
                SELECT status, COUNT(*)
                FROM log_collections
                WHERE user_id = ?
                GROUP BY status`

        rows, err := r.db.Query(statusQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get status counts: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        stats.CollectionsByStatus = make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var status string
                var count int
                if err := rows.Scan(&amp;status, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan status count: %w", err)
                }</span>
                <span class="cov0" title="0">stats.CollectionsByStatus[status] = count</span>
        }

        // Recent collections (last 7 days)
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM log_collections
                WHERE user_id = ? AND created_at &gt; datetime('now', '-7 days')`, userID).Scan(&amp;stats.RecentCollections)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent collections: %w", err)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "catalogizer/database"
        "catalogizer/internal/models"
)

// StatsRepository handles statistics-related database operations
type StatsRepository struct {
        db *database.DB
}

// NewStatsRepository creates a new stats repository
func NewStatsRepository(db *database.DB) *StatsRepository <span class="cov0" title="0">{
        return &amp;StatsRepository{db: db}
}</span>

// GetOverallStats retrieves overall catalog statistics
func (r *StatsRepository) GetOverallStats(ctx context.Context) (*models.OverallStats, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        COUNT(CASE WHEN is_directory = 0 AND deleted = 0 THEN 1 END) as total_files,
                        COUNT(CASE WHEN is_directory = 1 AND deleted = 0 THEN 1 END) as total_directories,
                        COALESCE(SUM(CASE WHEN is_directory = 0 AND deleted = 0 THEN size ELSE 0 END), 0) as total_size,
                        COUNT(CASE WHEN is_duplicate = 1 AND deleted = 0 THEN 1 END) as total_duplicates,
                        COUNT(DISTINCT duplicate_group_id) as duplicate_groups,
                        (SELECT COUNT(*) FROM storage_roots) as storage_roots_count,
                        (SELECT COUNT(*) FROM storage_roots WHERE enabled = 1) as active_storage_roots,
                        COALESCE(MAX(last_scan_at), 0) as last_scan_time
                FROM files`

        var stats models.OverallStats
        err := r.db.QueryRowContext(ctx, query).Scan(
                &amp;stats.TotalFiles,
                &amp;stats.TotalDirectories,
                &amp;stats.TotalSize,
                &amp;stats.TotalDuplicates,
                &amp;stats.DuplicateGroups,
                &amp;stats.StorageRootsCount,
                &amp;stats.ActiveStorageRoots,
                &amp;stats.LastScanTime,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get overall stats: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;stats, nil</span>
}

// GetStorageRootStats retrieves statistics for a specific storage root
func (r *StatsRepository) GetStorageRootStats(ctx context.Context, storageRootName string) (*models.StorageRootStats, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        sr.name,
                        COUNT(CASE WHEN f.is_directory = 0 AND f.deleted = 0 THEN 1 END) as total_files,
                        COUNT(CASE WHEN f.is_directory = 1 AND f.deleted = 0 THEN 1 END) as total_directories,
                        COALESCE(SUM(CASE WHEN f.is_directory = 0 AND f.deleted = 0 THEN f.size ELSE 0 END), 0) as total_size,
                        COUNT(CASE WHEN f.is_duplicate = 1 AND f.deleted = 0 THEN 1 END) as duplicate_files,
                        COUNT(DISTINCT f.duplicate_group_id) as duplicate_groups,
                        COALESCE(MAX(f.last_scan_at), 0) as last_scan_time,
                        sr.enabled as is_online
                FROM storage_roots sr
                LEFT JOIN files f ON sr.id = f.storage_root_id
                WHERE sr.name = ?
                GROUP BY sr.id, sr.name, sr.enabled`

        var stats models.StorageRootStats
        err := r.db.QueryRowContext(ctx, query, storageRootName).Scan(
                &amp;stats.Name,
                &amp;stats.TotalFiles,
                &amp;stats.TotalDirectories,
                &amp;stats.TotalSize,
                &amp;stats.DuplicateFiles,
                &amp;stats.DuplicateGroups,
                &amp;stats.LastScanTime,
                &amp;stats.IsOnline,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("storage root not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get storage root stats: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;stats, nil</span>
}

// GetFileTypeStats retrieves file type statistics
func (r *StatsRepository) GetFileTypeStats(ctx context.Context, storageRootName string, limit int) ([]models.FileTypeStats, error) <span class="cov0" title="0">{
        baseQuery := `
                SELECT
                        COALESCE(file_type, 'unknown') as file_type,
                        COALESCE(extension, 'none') as extension,
                        COUNT(*) as count,
                        SUM(size) as total_size,
                        AVG(size) as average_size
                FROM files f`

        args := []interface{}{}
        whereClause := " WHERE f.is_directory = 0 AND f.deleted = 0"

        if storageRootName != "" </span><span class="cov0" title="0">{
                whereClause += " AND f.smb_root_id = (SELECT id FROM smb_roots WHERE name = ?)"
                args = append(args, storageRootName)
        }</span>

        <span class="cov0" title="0">query := baseQuery + whereClause + `
                GROUP BY file_type, extension
                ORDER BY count DESC
                LIMIT ?`

        args = append(args, limit)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file type stats: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var stats []models.FileTypeStats
        for rows.Next() </span><span class="cov0" title="0">{
                var stat models.FileTypeStats
                err := rows.Scan(
                        &amp;stat.FileType,
                        &amp;stat.Extension,
                        &amp;stat.Count,
                        &amp;stat.TotalSize,
                        &amp;stat.AverageSize,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan file type stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats = append(stats, stat)</span>
        }

        <span class="cov0" title="0">return stats, nil</span>
}

// GetSizeDistribution retrieves file size distribution
func (r *StatsRepository) GetSizeDistribution(ctx context.Context, storageRootName string) (*models.SizeDistribution, error) <span class="cov0" title="0">{
        baseQuery := `
                SELECT
                        COUNT(CASE WHEN size = 0 THEN 1 END) as empty,
                        COUNT(CASE WHEN size &gt; 0 AND size &lt; 1024 THEN 1 END) as tiny,
                        COUNT(CASE WHEN size &gt;= 1024 AND size &lt; 1048576 THEN 1 END) as small,
                        COUNT(CASE WHEN size &gt;= 1048576 AND size &lt; 10485760 THEN 1 END) as medium,
                        COUNT(CASE WHEN size &gt;= 10485760 AND size &lt; 104857600 THEN 1 END) as large,
                        COUNT(CASE WHEN size &gt;= 104857600 AND size &lt; 1073741824 THEN 1 END) as huge,
                        COUNT(CASE WHEN size &gt;= 1073741824 THEN 1 END) as massive
                FROM files f`

        args := []interface{}{}
        whereClause := " WHERE f.is_directory = 0 AND f.deleted = 0"

        if storageRootName != "" </span><span class="cov0" title="0">{
                whereClause += " AND f.smb_root_id = (SELECT id FROM smb_roots WHERE name = ?)"
                args = append(args, storageRootName)
        }</span>

        <span class="cov0" title="0">query := baseQuery + whereClause

        var distribution models.SizeDistribution
        var empty int64
        err := r.db.QueryRowContext(ctx, query, args...).Scan(
                &amp;empty,
                &amp;distribution.Tiny,
                &amp;distribution.Small,
                &amp;distribution.Medium,
                &amp;distribution.Large,
                &amp;distribution.Huge,
                &amp;distribution.Massive,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get size distribution: %w", err)
        }</span>

        // Add empty files to tiny category
        <span class="cov0" title="0">distribution.Tiny += empty

        return &amp;distribution, nil</span>
}

// GetDuplicateStats retrieves duplicate file statistics
func (r *StatsRepository) GetDuplicateStats(ctx context.Context, storageRootName string) (*models.DuplicateStats, error) <span class="cov0" title="0">{
        baseQuery := `
                WITH duplicate_analysis AS (
                        SELECT
                                duplicate_group_id,
                                COUNT(*) as group_size,
                                MAX(size) as file_size
                        FROM files f
                        WHERE f.is_duplicate = 1 AND f.deleted = 0`

        args := []interface{}{}
        if storageRootName != "" </span><span class="cov0" title="0">{
                args = append(args, storageRootName)
        }</span>

        <span class="cov0" title="0">baseQuery += `
                        GROUP BY duplicate_group_id
                )
                SELECT
                        (SELECT COUNT(*) FROM files f WHERE f.is_duplicate = 1 AND f.deleted = 0` +
                (func() string </span><span class="cov0" title="0">{
                        if storageRootName != "" </span><span class="cov0" title="0">{
                                return " AND f.storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)"
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                })() + `) as total_duplicates,
                        COUNT(*) as duplicate_groups,
                        COALESCE(SUM((group_size - 1) * file_size), 0) as wasted_space,
                        COALESCE(MAX(group_size), 0) as largest_group,
                        COALESCE(AVG(group_size), 0) as average_group_size
                FROM duplicate_analysis`

        <span class="cov0" title="0">if storageRootName != "" </span><span class="cov0" title="0">{
                args = append(args, storageRootName) // For the subquery
        }</span>

        <span class="cov0" title="0">var stats models.DuplicateStats
        err := r.db.QueryRowContext(ctx, baseQuery, args...).Scan(
                &amp;stats.TotalDuplicates,
                &amp;stats.DuplicateGroups,
                &amp;stats.WastedSpace,
                &amp;stats.LargestDuplicateGroup,
                &amp;stats.AverageGroupSize,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get duplicate stats: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;stats, nil</span>
}

// GetTopDuplicateGroups retrieves the top duplicate groups
func (r *StatsRepository) GetTopDuplicateGroups(ctx context.Context, sortBy string, limit int, storageRootName string) ([]models.DuplicateGroupStats, error) <span class="cov0" title="0">{
        baseQuery := `
                SELECT
                        dg.id as group_id,
                        dg.file_count,
                        dg.total_size,
                        (dg.file_count - 1) * (dg.total_size / dg.file_count) as wasted_space,
                        (SELECT f.path FROM files f WHERE f.duplicate_group_id = dg.id AND f.deleted = 0 LIMIT 1) as sample_path
                FROM duplicate_groups dg`

        args := []interface{}{}
        whereClause := ""

        if storageRootName != "" </span><span class="cov0" title="0">{
                whereClause = ` WHERE EXISTS (
                        SELECT 1 FROM files f
                        WHERE f.duplicate_group_id = dg.id
                        AND f.storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)
                )`
                args = append(args, storageRootName)
        }</span>

        <span class="cov0" title="0">orderClause := " ORDER BY "
        if sortBy == "size" </span><span class="cov0" title="0">{
                orderClause += "dg.total_size DESC"
        }</span> else<span class="cov0" title="0"> {
                orderClause += "dg.file_count DESC"
        }</span>

        <span class="cov0" title="0">query := baseQuery + whereClause + orderClause + " LIMIT ?"
        args = append(args, limit)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top duplicate groups: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var groups []models.DuplicateGroupStats
        for rows.Next() </span><span class="cov0" title="0">{
                var group models.DuplicateGroupStats
                err := rows.Scan(
                        &amp;group.GroupID,
                        &amp;group.FileCount,
                        &amp;group.TotalSize,
                        &amp;group.WastedSpace,
                        &amp;group.SamplePath,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan duplicate group: %w", err)
                }</span>
                <span class="cov0" title="0">groups = append(groups, group)</span>
        }

        <span class="cov0" title="0">return groups, nil</span>
}

// GetAccessPatterns retrieves file access patterns
func (r *StatsRepository) GetAccessPatterns(ctx context.Context, storageRootName string, days int) (*models.AccessPatterns, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        // In a real scenario, you'd need to track actual access times
        baseQuery := `
                SELECT
                        COUNT(CASE WHEN accessed_at IS NOT NULL AND accessed_at &gt; ? THEN 1 END) as recently_accessed,
                        COUNT(CASE WHEN accessed_at IS NULL THEN 1 END) as never_accessed
                FROM files f`

        args := []interface{}{time.Now().AddDate(0, 0, -days).Unix()}
        whereClause := " WHERE f.is_directory = 0 AND f.deleted = 0"

        if storageRootName != "" </span><span class="cov0" title="0">{
                whereClause += " AND f.storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)"
                args = append(args, storageRootName)
        }</span>

        <span class="cov0" title="0">query := baseQuery + whereClause

        var patterns models.AccessPatterns
        err := r.db.QueryRowContext(ctx, query, args...).Scan(
                &amp;patterns.RecentlyAccessed,
                &amp;patterns.NeverAccessed,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get access patterns: %w", err)
        }</span>

        // Initialize arrays with default values
        <span class="cov0" title="0">patterns.AccessFrequency = make([]int64, days)
        patterns.PopularExtensions = []string{}
        patterns.PopularDirectories = []string{}

        return &amp;patterns, nil</span>
}

// GetGrowthTrends retrieves storage growth trends
func (r *StatsRepository) GetGrowthTrends(ctx context.Context, storageRootName string, months int) (*models.GrowthTrends, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        // In a real scenario, you'd need historical data tracking
        baseQuery := `
                SELECT
                        strftime('%Y-%m', datetime(created_at, 'unixepoch')) as month,
                        COUNT(*) as files_added,
                        SUM(size) as size_added
                FROM files f`

        args := []interface{}{}
        whereClause := " WHERE f.is_directory = 0 AND f.deleted = 0 AND created_at &gt; ?"

        monthsAgo := time.Now().AddDate(0, -months, 0).Unix()
        args = append(args, monthsAgo)

        if storageRootName != "" </span><span class="cov0" title="0">{
                whereClause += " AND f.storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)"
                args = append(args, storageRootName)
        }</span>

        <span class="cov0" title="0">query := baseQuery + whereClause + " GROUP BY month ORDER BY month"

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get growth trends: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var trends models.GrowthTrends
        var monthlyGrowth []models.MonthlyGrowth

        for rows.Next() </span><span class="cov0" title="0">{
                var growth models.MonthlyGrowth
                err := rows.Scan(
                        &amp;growth.Month,
                        &amp;growth.FilesAdded,
                        &amp;growth.SizeAdded,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan growth trend: %w", err)
                }</span>
                <span class="cov0" title="0">monthlyGrowth = append(monthlyGrowth, growth)</span>
        }

        <span class="cov0" title="0">trends.MonthlyGrowth = monthlyGrowth
        trends.TotalGrowthRate = 0.0 // Calculate based on data
        trends.FileGrowthRate = 0.0  // Calculate based on data
        trends.SizeGrowthRate = 0.0  // Calculate based on data

        return &amp;trends, nil</span>
}

// GetScanHistory retrieves scan operation history
func (r *StatsRepository) GetScanHistory(ctx context.Context, storageRootName string, limit, offset int) ([]models.ScanHistoryItem, int64, error) <span class="cov0" title="0">{
        countQuery := `
                SELECT COUNT(*)
                FROM scan_history sh
                JOIN storage_roots sr ON sh.storage_root_id = sr.id`

        selectQuery := `
                SELECT
                        sh.id,
                        sr.name as storage_root_name,
                        sh.scan_type,
                        sh.status,
                        sh.start_time,
                        sh.end_time,
                        sh.files_processed,
                        sh.files_added,
                        sh.files_updated,
                        sh.files_deleted,
                        sh.error_count,
                        sh.error_message
                FROM scan_history sh
                JOIN storage_roots sr ON sh.storage_root_id = sr.id`

        args := []interface{}{}
        whereClause := ""

        if storageRootName != "" </span><span class="cov0" title="0">{
                whereClause += " AND f.storage_root_id = (SELECT id FROM storage_roots WHERE name = ?)"
                args = append(args, storageRootName)
        }</span>

        // Get total count
        <span class="cov0" title="0">var totalCount int64
        err := r.db.QueryRowContext(ctx, countQuery+whereClause, args...).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to count scan history: %w", err)
        }</span>

        // Get paginated results
        <span class="cov0" title="0">query := selectQuery + whereClause + " ORDER BY sh.start_time DESC LIMIT ? OFFSET ?"
        args = append(args, limit, offset)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get scan history: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var history []models.ScanHistoryItem
        for rows.Next() </span><span class="cov0" title="0">{
                var item models.ScanHistoryItem
                err := rows.Scan(
                        &amp;item.ID,
                        &amp;item.SmbRootName,
                        &amp;item.ScanType,
                        &amp;item.Status,
                        &amp;item.StartTime,
                        &amp;item.EndTime,
                        &amp;item.FilesProcessed,
                        &amp;item.FilesAdded,
                        &amp;item.FilesUpdated,
                        &amp;item.FilesDeleted,
                        &amp;item.ErrorCount,
                        &amp;item.ErrorMessage,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to scan history item: %w", err)
                }</span>
                <span class="cov0" title="0">history = append(history, item)</span>
        }

        <span class="cov0" title="0">return history, totalCount, nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
)

type StressTestRepository struct {
        db *sql.DB
}

func NewStressTestRepository(db *sql.DB) *StressTestRepository <span class="cov0" title="0">{
        return &amp;StressTestRepository{db: db}
}</span>

func (r *StressTestRepository) CreateStressTest(test *models.StressTest) error <span class="cov0" title="0">{
        scenariosJSON, err := json.Marshal(test.Scenarios)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal scenarios: %w", err)
        }</span>

        <span class="cov0" title="0">configJSON, err := json.Marshal(test.Configuration)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO stress_tests (
                        name, description, type, status, scenarios, configuration,
                        concurrent_users, duration_seconds, ramp_up_time, created_by, created_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                test.Name, test.Description, test.Type, test.Status,
                string(scenariosJSON), string(configJSON),
                test.ConcurrentUsers, test.DurationSeconds, test.RampUpTime,
                test.CreatedBy, test.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stress test: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">test.ID = id
        return nil</span>
}

func (r *StressTestRepository) GetStressTest(id int) (*models.StressTest, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, type, status, scenarios, configuration,
                           concurrent_users, duration_seconds, ramp_up_time, created_by,
                           created_at, started_at, completed_at
                FROM stress_tests WHERE id = ?`

        var test models.StressTest
        var scenariosJSON, configJSON string
        var startedAt, completedAt sql.NullTime

        err := r.db.QueryRow(query, id).Scan(
                &amp;test.ID, &amp;test.Name, &amp;test.Description, &amp;test.Type, &amp;test.Status,
                &amp;scenariosJSON, &amp;configJSON, &amp;test.ConcurrentUsers,
                &amp;test.DurationSeconds, &amp;test.RampUpTime, &amp;test.CreatedBy,
                &amp;test.CreatedAt, &amp;startedAt, &amp;completedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get stress test: %w", err)
        }</span>

        <span class="cov0" title="0">if startedAt.Valid </span><span class="cov0" title="0">{
                test.StartedAt = &amp;startedAt.Time
        }</span>
        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                test.CompletedAt = &amp;completedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(scenariosJSON), &amp;test.Scenarios); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal scenarios: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(configJSON), &amp;test.Configuration); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;test, nil</span>
}

func (r *StressTestRepository) UpdateStressTest(test *models.StressTest) error <span class="cov0" title="0">{
        scenariosJSON, err := json.Marshal(test.Scenarios)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal scenarios: %w", err)
        }</span>

        <span class="cov0" title="0">configJSON, err := json.Marshal(test.Configuration)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE stress_tests SET
                        name = ?, description = ?, type = ?, status = ?,
                        scenarios = ?, configuration = ?, concurrent_users = ?,
                        duration_seconds = ?, ramp_up_time = ?, started_at = ?, completed_at = ?
                WHERE id = ?`

        _, err = r.db.Exec(query,
                test.Name, test.Description, test.Type, test.Status,
                string(scenariosJSON), string(configJSON),
                test.ConcurrentUsers, test.DurationSeconds, test.RampUpTime,
                test.StartedAt, test.CompletedAt, test.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update stress test: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *StressTestRepository) GetStressTestsByUser(userID int, limit, offset int) ([]*models.StressTest, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, type, status, scenarios, configuration,
                           concurrent_users, duration_seconds, ramp_up_time, created_by,
                           created_at, started_at, completed_at
                FROM stress_tests
                WHERE created_by = ?
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?`

        rows, err := r.db.Query(query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get stress tests: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tests []*models.StressTest
        for rows.Next() </span><span class="cov0" title="0">{
                var test models.StressTest
                var scenariosJSON, configJSON string
                var startedAt, completedAt sql.NullTime

                err := rows.Scan(
                        &amp;test.ID, &amp;test.Name, &amp;test.Description, &amp;test.Type, &amp;test.Status,
                        &amp;scenariosJSON, &amp;configJSON, &amp;test.ConcurrentUsers,
                        &amp;test.DurationSeconds, &amp;test.RampUpTime, &amp;test.CreatedBy,
                        &amp;test.CreatedAt, &amp;startedAt, &amp;completedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan stress test: %w", err)
                }</span>

                <span class="cov0" title="0">if startedAt.Valid </span><span class="cov0" title="0">{
                        test.StartedAt = &amp;startedAt.Time
                }</span>
                <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                        test.CompletedAt = &amp;completedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(scenariosJSON), &amp;test.Scenarios); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal scenarios: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(configJSON), &amp;test.Configuration); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
                }</span>

                <span class="cov0" title="0">tests = append(tests, &amp;test)</span>
        }

        <span class="cov0" title="0">return tests, nil</span>
}

func (r *StressTestRepository) DeleteStressTest(id int) error <span class="cov0" title="0">{
        // First delete associated executions
        if err := r.DeleteExecutionsByTestID(id); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete test executions: %w", err)
        }</span>

        <span class="cov0" title="0">query := "DELETE FROM stress_tests WHERE id = ?"
        _, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete stress test: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *StressTestRepository) CreateExecution(execution *models.StressTestExecution) error <span class="cov0" title="0">{
        metricsJSON, err := json.Marshal(execution.Metrics)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metrics: %w", err)
        }</span>

        <span class="cov0" title="0">resultsJSON, err := json.Marshal(execution.Results)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal results: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO stress_test_executions (
                        stress_test_id, status, started_at, metrics, results, error_message
                ) VALUES (?, ?, ?, ?, ?, ?)`

        result, err := r.db.Exec(query,
                execution.StressTestID, execution.Status, execution.StartedAt,
                string(metricsJSON), string(resultsJSON), execution.ErrorMessage)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create execution: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">execution.ID = id
        return nil</span>
}

func (r *StressTestRepository) UpdateExecution(execution *models.StressTestExecution) error <span class="cov0" title="0">{
        metricsJSON, err := json.Marshal(execution.Metrics)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metrics: %w", err)
        }</span>

        <span class="cov0" title="0">resultsJSON, err := json.Marshal(execution.Results)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal results: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE stress_test_executions SET
                        status = ?, completed_at = ?, metrics = ?, results = ?, error_message = ?
                WHERE id = ?`

        _, err = r.db.Exec(query,
                execution.Status, execution.CompletedAt,
                string(metricsJSON), string(resultsJSON),
                execution.ErrorMessage, execution.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update execution: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *StressTestRepository) GetExecution(id int) (*models.StressTestExecution, error) <span class="cov0" title="0">{
        query := `
                SELECT id, stress_test_id, status, started_at, completed_at,
                           metrics, results, error_message
                FROM stress_test_executions WHERE id = ?`

        var execution models.StressTestExecution
        var metricsJSON, resultsJSON string
        var completedAt sql.NullTime

        err := r.db.QueryRow(query, id).Scan(
                &amp;execution.ID, &amp;execution.StressTestID, &amp;execution.Status,
                &amp;execution.StartedAt, &amp;completedAt,
                &amp;metricsJSON, &amp;resultsJSON, &amp;execution.ErrorMessage)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get execution: %w", err)
        }</span>

        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                execution.CompletedAt = &amp;completedAt.Time
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(metricsJSON), &amp;execution.Metrics); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal metrics: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(resultsJSON), &amp;execution.Results); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal results: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;execution, nil</span>
}

func (r *StressTestRepository) GetExecutionsByTestID(testID int) ([]*models.StressTestExecution, error) <span class="cov0" title="0">{
        query := `
                SELECT id, stress_test_id, status, started_at, completed_at,
                           metrics, results, error_message
                FROM stress_test_executions
                WHERE stress_test_id = ?
                ORDER BY started_at DESC`

        rows, err := r.db.Query(query, testID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get executions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var executions []*models.StressTestExecution
        for rows.Next() </span><span class="cov0" title="0">{
                var execution models.StressTestExecution
                var metricsJSON, resultsJSON string
                var completedAt sql.NullTime

                err := rows.Scan(
                        &amp;execution.ID, &amp;execution.StressTestID, &amp;execution.Status,
                        &amp;execution.StartedAt, &amp;completedAt,
                        &amp;metricsJSON, &amp;resultsJSON, &amp;execution.ErrorMessage)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan execution: %w", err)
                }</span>

                <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                        execution.CompletedAt = &amp;completedAt.Time
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(metricsJSON), &amp;execution.Metrics); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal metrics: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal([]byte(resultsJSON), &amp;execution.Results); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal results: %w", err)
                }</span>

                <span class="cov0" title="0">executions = append(executions, &amp;execution)</span>
        }

        <span class="cov0" title="0">return executions, nil</span>
}

func (r *StressTestRepository) DeleteExecutionsByTestID(testID int) error <span class="cov0" title="0">{
        query := "DELETE FROM stress_test_executions WHERE stress_test_id = ?"
        _, err := r.db.Exec(query, testID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete executions: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *StressTestRepository) GetStatistics(userID int) (*models.StressTestStatistics, error) <span class="cov0" title="0">{
        stats := &amp;models.StressTestStatistics{}

        // Total tests
        err := r.db.QueryRow("SELECT COUNT(*) FROM stress_tests WHERE created_by = ?", userID).Scan(&amp;stats.TotalTests)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total tests: %w", err)
        }</span>

        // Tests by status
        <span class="cov0" title="0">statusQuery := `
                SELECT status, COUNT(*)
                FROM stress_tests
                WHERE created_by = ?
                GROUP BY status`

        rows, err := r.db.Query(statusQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get status counts: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        stats.TestsByStatus = make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var status string
                var count int
                if err := rows.Scan(&amp;status, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan status count: %w", err)
                }</span>
                <span class="cov0" title="0">stats.TestsByStatus[status] = count</span>
        }

        // Total executions
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT COUNT(*)
                FROM stress_test_executions ste
                JOIN stress_tests st ON ste.stress_test_id = st.id
                WHERE st.created_by = ?`, userID).Scan(&amp;stats.TotalExecutions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total executions: %w", err)
        }</span>

        // Average execution duration
        <span class="cov0" title="0">err = r.db.QueryRow(`
                SELECT AVG(
                        CASE
                                WHEN ste.completed_at IS NOT NULL
                                THEN (julianday(ste.completed_at) - julianday(ste.started_at)) * 24 * 60 * 60
                                ELSE NULL
                        END
                )
                FROM stress_test_executions ste
                JOIN stress_tests st ON ste.stress_test_id = st.id
                WHERE st.created_by = ? AND ste.completed_at IS NOT NULL`, userID).Scan(&amp;stats.AvgExecutionDuration)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get average duration: %w", err)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (r *StressTestRepository) CleanupOldExecutions(olderThan time.Time) error <span class="cov0" title="0">{
        query := "DELETE FROM stress_test_executions WHERE started_at &lt; ?"
        _, err := r.db.Exec(query, olderThan)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old executions: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Wrapper methods to match service expectations
func (r *StressTestRepository) CreateTest(test *models.StressTest) (int64, error) <span class="cov0" title="0">{
        err := r.CreateStressTest(test)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return test.ID, nil</span>
}

func (r *StressTestRepository) GetTest(id int) (*models.StressTest, error) <span class="cov0" title="0">{
        return r.GetStressTest(id)
}</span>

func (r *StressTestRepository) UpdateTest(test *models.StressTest) error <span class="cov0" title="0">{
        return r.UpdateStressTest(test)
}</span>

func (r *StressTestRepository) GetUserTests(userID int, limit, offset int) ([]*models.StressTest, error) <span class="cov0" title="0">{
        return r.GetStressTestsByUser(userID, limit, offset)
}</span>

func (r *StressTestRepository) DeleteTest(id int) error <span class="cov0" title="0">{
        return r.DeleteStressTest(id)
}</span>

func (r *StressTestRepository) SaveResult(result *models.StressTestResult) error <span class="cov0" title="0">{
        // This would need a table for results, but for now just return nil
        return nil
}</span>

func (r *StressTestRepository) GetResult(testID int) (*models.StressTestResult, error) <span class="cov0" title="0">{
        // This would need a table for results, but for now return nil
        return nil, fmt.Errorf("not implemented")
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package repository

import (
        "database/sql"
        "fmt"
        "time"

        "catalogizer/models"
)

type SyncRepository struct {
        db *sql.DB
}

func NewSyncRepository(db *sql.DB) *SyncRepository <span class="cov0" title="0">{
        return &amp;SyncRepository{db: db}
}</span>

func (r *SyncRepository) CreateEndpoint(endpoint *models.SyncEndpoint) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO sync_endpoints (user_id, name, type, url, username, password, sync_direction,
                                                                   local_path, remote_path, sync_settings, status, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query,
                endpoint.UserID, endpoint.Name, endpoint.Type, endpoint.URL, endpoint.Username,
                endpoint.Password, endpoint.SyncDirection, endpoint.LocalPath, endpoint.RemotePath,
                endpoint.SyncSettings, endpoint.Status, endpoint.CreatedAt, endpoint.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create sync endpoint: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get endpoint ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *SyncRepository) GetEndpoint(endpointID int) (*models.SyncEndpoint, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, type, url, username, password, sync_direction,
                           local_path, remote_path, sync_settings, status, created_at, updated_at, last_sync_at
                FROM sync_endpoints
                WHERE id = ?
        `

        endpoint := &amp;models.SyncEndpoint{}
        var syncSettings sql.NullString
        var lastSyncAt sql.NullTime

        err := r.db.QueryRow(query, endpointID).Scan(
                &amp;endpoint.ID, &amp;endpoint.UserID, &amp;endpoint.Name, &amp;endpoint.Type, &amp;endpoint.URL,
                &amp;endpoint.Username, &amp;endpoint.Password, &amp;endpoint.SyncDirection, &amp;endpoint.LocalPath,
                &amp;endpoint.RemotePath, &amp;syncSettings, &amp;endpoint.Status, &amp;endpoint.CreatedAt,
                &amp;endpoint.UpdatedAt, &amp;lastSyncAt)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("endpoint not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get endpoint: %w", err)</span>
        }

        <span class="cov0" title="0">if syncSettings.Valid </span><span class="cov0" title="0">{
                endpoint.SyncSettings = &amp;syncSettings.String
        }</span>

        <span class="cov0" title="0">if lastSyncAt.Valid </span><span class="cov0" title="0">{
                endpoint.LastSyncAt = &amp;lastSyncAt.Time
        }</span>

        <span class="cov0" title="0">return endpoint, nil</span>
}

func (r *SyncRepository) UpdateEndpoint(endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        query := `
                UPDATE sync_endpoints
                SET name = ?, type = ?, url = ?, username = ?, password = ?, sync_direction = ?,
                        local_path = ?, remote_path = ?, sync_settings = ?, status = ?, updated_at = ?, last_sync_at = ?
                WHERE id = ?
        `

        var lastSyncAt sql.NullTime
        if endpoint.LastSyncAt != nil </span><span class="cov0" title="0">{
                lastSyncAt = sql.NullTime{Time: *endpoint.LastSyncAt, Valid: true}
        }</span>

        <span class="cov0" title="0">_, err := r.db.Exec(query,
                endpoint.Name, endpoint.Type, endpoint.URL, endpoint.Username, endpoint.Password,
                endpoint.SyncDirection, endpoint.LocalPath, endpoint.RemotePath, endpoint.SyncSettings,
                endpoint.Status, endpoint.UpdatedAt, lastSyncAt, endpoint.ID)

        return err</span>
}

func (r *SyncRepository) DeleteEndpoint(endpointID int) error <span class="cov0" title="0">{
        query := `DELETE FROM sync_endpoints WHERE id = ?`
        _, err := r.db.Exec(query, endpointID)
        return err
}</span>

func (r *SyncRepository) GetUserEndpoints(userID int) ([]models.SyncEndpoint, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, type, url, username, password, sync_direction,
                           local_path, remote_path, sync_settings, status, created_at, updated_at, last_sync_at
                FROM sync_endpoints
                WHERE user_id = ?
                ORDER BY created_at DESC
        `

        rows, err := r.db.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user endpoints: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanEndpoints(rows)</span>
}

func (r *SyncRepository) CreateSession(session *models.SyncSession) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO sync_sessions (endpoint_id, user_id, status, sync_type, started_at,
                                                                  total_files, synced_files, failed_files, skipped_files)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query,
                session.EndpointID, session.UserID, session.Status, session.SyncType, session.StartedAt,
                session.TotalFiles, session.SyncedFiles, session.FailedFiles, session.SkippedFiles)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create sync session: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get session ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *SyncRepository) GetSession(sessionID int) (*models.SyncSession, error) <span class="cov0" title="0">{
        query := `
                SELECT id, endpoint_id, user_id, status, sync_type, started_at, completed_at,
                           duration, total_files, synced_files, failed_files, skipped_files, error_message
                FROM sync_sessions
                WHERE id = ?
        `

        session := &amp;models.SyncSession{}
        var completedAt sql.NullTime
        var durationSeconds sql.NullInt64
        var errorMessage sql.NullString

        err := r.db.QueryRow(query, sessionID).Scan(
                &amp;session.ID, &amp;session.EndpointID, &amp;session.UserID, &amp;session.Status, &amp;session.SyncType,
                &amp;session.StartedAt, &amp;completedAt, &amp;durationSeconds, &amp;session.TotalFiles,
                &amp;session.SyncedFiles, &amp;session.FailedFiles, &amp;session.SkippedFiles, &amp;errorMessage)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("session not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get session: %w", err)</span>
        }

        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                session.CompletedAt = &amp;completedAt.Time
        }</span>

        <span class="cov0" title="0">if durationSeconds.Valid </span><span class="cov0" title="0">{
                duration := time.Duration(durationSeconds.Int64) * time.Second
                session.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">if errorMessage.Valid </span><span class="cov0" title="0">{
                session.ErrorMessage = &amp;errorMessage.String
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (r *SyncRepository) UpdateSession(session *models.SyncSession) error <span class="cov0" title="0">{
        query := `
                UPDATE sync_sessions
                SET status = ?, completed_at = ?, duration = ?, total_files = ?, synced_files = ?,
                        failed_files = ?, skipped_files = ?, error_message = ?, updated_at = ?
                WHERE id = ?
        `

        var completedAt sql.NullTime
        var durationSeconds sql.NullInt64
        var errorMessage sql.NullString

        if session.CompletedAt != nil </span><span class="cov0" title="0">{
                completedAt = sql.NullTime{Time: *session.CompletedAt, Valid: true}
        }</span>

        <span class="cov0" title="0">if session.Duration != nil </span><span class="cov0" title="0">{
                durationSeconds = sql.NullInt64{Int64: int64(session.Duration.Seconds()), Valid: true}
        }</span>

        <span class="cov0" title="0">if session.ErrorMessage != nil </span><span class="cov0" title="0">{
                errorMessage = sql.NullString{String: *session.ErrorMessage, Valid: true}
        }</span>

        <span class="cov0" title="0">_, err := r.db.Exec(query,
                session.Status, completedAt, durationSeconds, session.TotalFiles, session.SyncedFiles,
                session.FailedFiles, session.SkippedFiles, errorMessage, time.Now(), session.ID)

        return err</span>
}

func (r *SyncRepository) GetUserSessions(userID int, limit, offset int) ([]models.SyncSession, error) <span class="cov0" title="0">{
        query := `
                SELECT id, endpoint_id, user_id, status, sync_type, started_at, completed_at,
                           duration, total_files, synced_files, failed_files, skipped_files, error_message
                FROM sync_sessions
                WHERE user_id = ?
                ORDER BY started_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.Query(query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user sessions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanSessions(rows)</span>
}

func (r *SyncRepository) CreateSchedule(schedule *models.SyncSchedule) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO sync_schedules (endpoint_id, user_id, frequency, is_active, created_at)
                VALUES (?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query,
                schedule.EndpointID, schedule.UserID, schedule.Frequency, schedule.IsActive, schedule.CreatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create sync schedule: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get schedule ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *SyncRepository) GetActiveSchedules() ([]models.SyncSchedule, error) <span class="cov0" title="0">{
        query := `
                SELECT id, endpoint_id, user_id, frequency, last_run, next_run, is_active, created_at
                FROM sync_schedules
                WHERE is_active = 1
                ORDER BY next_run ASC
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active schedules: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanSchedules(rows)</span>
}

func (r *SyncRepository) GetStatistics(userID *int, startDate, endDate time.Time) (*models.SyncStatistics, error) <span class="cov0" title="0">{
        whereClause := "WHERE started_at BETWEEN ? AND ?"
        args := []interface{}{startDate, endDate}

        if userID != nil </span><span class="cov0" title="0">{
                whereClause += " AND user_id = ?"
                args = append(args, *userID)
        }</span>

        // Get session counts by status
        <span class="cov0" title="0">statusQuery := fmt.Sprintf(`
                SELECT status, COUNT(*) as count
                FROM sync_sessions
                %s
                GROUP BY status
        `, whereClause)

        statusRows, err := r.db.Query(statusQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get status statistics: %w", err)
        }</span>
        <span class="cov0" title="0">defer statusRows.Close()

        stats := &amp;models.SyncStatistics{
                StartDate: startDate,
                EndDate:   endDate,
                ByStatus:  make(map[string]int),
                ByType:    make(map[string]int),
        }

        for statusRows.Next() </span><span class="cov0" title="0">{
                var status string
                var count int
                err := statusRows.Scan(&amp;status, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan status stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ByStatus[status] = count
                stats.TotalSessions += count</span>
        }

        // Get session counts by sync type
        <span class="cov0" title="0">typeQuery := fmt.Sprintf(`
                SELECT sync_type, COUNT(*) as count
                FROM sync_sessions
                %s
                GROUP BY sync_type
        `, whereClause)

        typeRows, err := r.db.Query(typeQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get type statistics: %w", err)
        }</span>
        <span class="cov0" title="0">defer typeRows.Close()

        for typeRows.Next() </span><span class="cov0" title="0">{
                var syncType string
                var count int
                err := typeRows.Scan(&amp;syncType, &amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan type stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ByType[syncType] = count</span>
        }

        // Get total files synced
        <span class="cov0" title="0">filesQuery := fmt.Sprintf(`
                SELECT SUM(synced_files) as total_synced, SUM(failed_files) as total_failed
                FROM sync_sessions
                %s AND status = 'completed'
        `, whereClause)

        var totalSynced, totalFailed sql.NullInt64
        err = r.db.QueryRow(filesQuery, args...).Scan(&amp;totalSynced, &amp;totalFailed)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file statistics: %w", err)
        }</span>

        <span class="cov0" title="0">if totalSynced.Valid </span><span class="cov0" title="0">{
                stats.TotalFilesSynced = int(totalSynced.Int64)
        }</span>

        <span class="cov0" title="0">if totalFailed.Valid </span><span class="cov0" title="0">{
                stats.TotalFilesFailed = int(totalFailed.Int64)
        }</span>

        // Get average duration for completed sessions
        <span class="cov0" title="0">durationQuery := fmt.Sprintf(`
                SELECT AVG(duration) as avg_duration
                FROM sync_sessions
                %s AND status = 'completed' AND duration IS NOT NULL
        `, whereClause)

        var avgDurationSeconds sql.NullFloat64
        err = r.db.QueryRow(durationQuery, args...).Scan(&amp;avgDurationSeconds)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get duration statistics: %w", err)
        }</span>

        <span class="cov0" title="0">if avgDurationSeconds.Valid </span><span class="cov0" title="0">{
                avgDuration := time.Duration(avgDurationSeconds.Float64) * time.Second
                stats.AverageDuration = &amp;avgDuration
        }</span>

        // Calculate success rate
        <span class="cov0" title="0">if completed, ok := stats.ByStatus[models.SyncSessionStatusCompleted]; ok </span><span class="cov0" title="0">{
                if failed, failedOk := stats.ByStatus[models.SyncSessionStatusFailed]; failedOk </span><span class="cov0" title="0">{
                        total := completed + failed
                        if total &gt; 0 </span><span class="cov0" title="0">{
                                stats.SuccessRate = float64(completed) / float64(total) * 100
                        }</span>
                } else<span class="cov0" title="0"> if completed &gt; 0 </span><span class="cov0" title="0">{
                        stats.SuccessRate = 100.0
                }</span>
        }

        <span class="cov0" title="0">return stats, nil</span>
}

func (r *SyncRepository) CleanupSessions(olderThan time.Time) error <span class="cov0" title="0">{
        query := `
                DELETE FROM sync_sessions
                WHERE completed_at &lt; ? AND status IN ('completed', 'failed', 'cancelled')
        `

        _, err := r.db.Exec(query, olderThan)
        return err
}</span>

func (r *SyncRepository) GetEndpointsByType(syncType string) ([]models.SyncEndpoint, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, type, url, username, password, sync_direction,
                           local_path, remote_path, sync_settings, status, created_at, updated_at, last_sync_at
                FROM sync_endpoints
                WHERE type = ? AND status = 'active'
                ORDER BY created_at DESC
        `

        rows, err := r.db.Query(query, syncType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get endpoints by type: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanEndpoints(rows)</span>
}

func (r *SyncRepository) scanEndpoints(rows *sql.Rows) ([]models.SyncEndpoint, error) <span class="cov0" title="0">{
        var endpoints []models.SyncEndpoint

        for rows.Next() </span><span class="cov0" title="0">{
                var endpoint models.SyncEndpoint
                var syncSettings sql.NullString
                var lastSyncAt sql.NullTime

                err := rows.Scan(
                        &amp;endpoint.ID, &amp;endpoint.UserID, &amp;endpoint.Name, &amp;endpoint.Type, &amp;endpoint.URL,
                        &amp;endpoint.Username, &amp;endpoint.Password, &amp;endpoint.SyncDirection, &amp;endpoint.LocalPath,
                        &amp;endpoint.RemotePath, &amp;syncSettings, &amp;endpoint.Status, &amp;endpoint.CreatedAt,
                        &amp;endpoint.UpdatedAt, &amp;lastSyncAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan endpoint: %w", err)
                }</span>

                <span class="cov0" title="0">if syncSettings.Valid </span><span class="cov0" title="0">{
                        endpoint.SyncSettings = &amp;syncSettings.String
                }</span>

                <span class="cov0" title="0">if lastSyncAt.Valid </span><span class="cov0" title="0">{
                        endpoint.LastSyncAt = &amp;lastSyncAt.Time
                }</span>

                <span class="cov0" title="0">endpoints = append(endpoints, endpoint)</span>
        }

        <span class="cov0" title="0">return endpoints, nil</span>
}

func (r *SyncRepository) scanSessions(rows *sql.Rows) ([]models.SyncSession, error) <span class="cov0" title="0">{
        var sessions []models.SyncSession

        for rows.Next() </span><span class="cov0" title="0">{
                var session models.SyncSession
                var completedAt sql.NullTime
                var durationSeconds sql.NullInt64
                var errorMessage sql.NullString

                err := rows.Scan(
                        &amp;session.ID, &amp;session.EndpointID, &amp;session.UserID, &amp;session.Status, &amp;session.SyncType,
                        &amp;session.StartedAt, &amp;completedAt, &amp;durationSeconds, &amp;session.TotalFiles,
                        &amp;session.SyncedFiles, &amp;session.FailedFiles, &amp;session.SkippedFiles, &amp;errorMessage)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan session: %w", err)
                }</span>

                <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                        session.CompletedAt = &amp;completedAt.Time
                }</span>

                <span class="cov0" title="0">if durationSeconds.Valid </span><span class="cov0" title="0">{
                        duration := time.Duration(durationSeconds.Int64) * time.Second
                        session.Duration = &amp;duration
                }</span>

                <span class="cov0" title="0">if errorMessage.Valid </span><span class="cov0" title="0">{
                        session.ErrorMessage = &amp;errorMessage.String
                }</span>

                <span class="cov0" title="0">sessions = append(sessions, session)</span>
        }

        <span class="cov0" title="0">return sessions, nil</span>
}

func (r *SyncRepository) scanSchedules(rows *sql.Rows) ([]models.SyncSchedule, error) <span class="cov0" title="0">{
        var schedules []models.SyncSchedule

        for rows.Next() </span><span class="cov0" title="0">{
                var schedule models.SyncSchedule
                var lastRun, nextRun sql.NullTime

                err := rows.Scan(
                        &amp;schedule.ID, &amp;schedule.EndpointID, &amp;schedule.UserID, &amp;schedule.Frequency,
                        &amp;lastRun, &amp;nextRun, &amp;schedule.IsActive, &amp;schedule.CreatedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan schedule: %w", err)
                }</span>

                <span class="cov0" title="0">if lastRun.Valid </span><span class="cov0" title="0">{
                        schedule.LastRun = &amp;lastRun.Time
                }</span>

                <span class="cov0" title="0">if nextRun.Valid </span><span class="cov0" title="0">{
                        schedule.NextRun = &amp;nextRun.Time
                }</span>

                <span class="cov0" title="0">schedules = append(schedules, schedule)</span>
        }

        <span class="cov0" title="0">return schedules, nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package repository

import (
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "catalogizer/models"
)

type UserRepository struct {
        db *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{db: db}
}</span>

func (r *UserRepository) Create(user *models.User) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO users (username, email, password_hash, salt, role_id, first_name, last_name,
                                                  display_name, avatar_url, time_zone, language, is_active, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        now := time.Now()
        result, err := r.db.Exec(query,
                user.Username, user.Email, user.PasswordHash, user.Salt, user.RoleID,
                user.FirstName, user.LastName, user.DisplayName, user.AvatarURL,
                user.TimeZone, user.Language, user.IsActive, now, now)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get user ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *UserRepository) GetByID(id int) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, salt, role_id, first_name, last_name,
                           display_name, avatar_url, time_zone, language, is_active, is_locked,
                           locked_until, failed_login_attempts, last_login_at, last_login_ip,
                           created_at, updated_at, settings
                FROM users WHERE id = ?
        `

        user := &amp;models.User{}
        var settings sql.NullString

        err := r.db.QueryRow(query, id).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Salt,
                &amp;user.RoleID, &amp;user.FirstName, &amp;user.LastName, &amp;user.DisplayName,
                &amp;user.AvatarURL, &amp;user.TimeZone, &amp;user.Language, &amp;user.IsActive,
                &amp;user.IsLocked, &amp;user.LockedUntil, &amp;user.FailedLoginAttempts,
                &amp;user.LastLoginAt, &amp;user.LastLoginIP, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;settings)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, errors.New("user not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                user.Settings = settings.String
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) GetByUsername(username string) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, salt, role_id, first_name, last_name,
                           display_name, avatar_url, time_zone, language, is_active, is_locked,
                           locked_until, failed_login_attempts, last_login_at, last_login_ip,
                           created_at, updated_at, settings
                FROM users WHERE username = ?
        `

        user := &amp;models.User{}
        var settings sql.NullString

        err := r.db.QueryRow(query, username).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Salt,
                &amp;user.RoleID, &amp;user.FirstName, &amp;user.LastName, &amp;user.DisplayName,
                &amp;user.AvatarURL, &amp;user.TimeZone, &amp;user.Language, &amp;user.IsActive,
                &amp;user.IsLocked, &amp;user.LockedUntil, &amp;user.FailedLoginAttempts,
                &amp;user.LastLoginAt, &amp;user.LastLoginIP, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;settings)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                user.Settings = settings.String
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) GetByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, salt, role_id, first_name, last_name,
                           display_name, avatar_url, time_zone, language, is_active, is_locked,
                           locked_until, failed_login_attempts, last_login_at, last_login_ip,
                           created_at, updated_at, settings
                FROM users WHERE email = ?
        `

        user := &amp;models.User{}
        var settings sql.NullString

        err := r.db.QueryRow(query, email).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Salt,
                &amp;user.RoleID, &amp;user.FirstName, &amp;user.LastName, &amp;user.DisplayName,
                &amp;user.AvatarURL, &amp;user.TimeZone, &amp;user.Language, &amp;user.IsActive,
                &amp;user.IsLocked, &amp;user.LockedUntil, &amp;user.FailedLoginAttempts,
                &amp;user.LastLoginAt, &amp;user.LastLoginIP, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;settings)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                user.Settings = settings.String
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) GetByUsernameOrEmail(usernameOrEmail string) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, salt, role_id, first_name, last_name,
                           display_name, avatar_url, time_zone, language, is_active, is_locked,
                           locked_until, failed_login_attempts, last_login_at, last_login_ip,
                           created_at, updated_at, settings
                FROM users WHERE username = ? OR email = ?
        `

        user := &amp;models.User{}
        var settings sql.NullString

        err := r.db.QueryRow(query, usernameOrEmail, usernameOrEmail).Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Salt,
                &amp;user.RoleID, &amp;user.FirstName, &amp;user.LastName, &amp;user.DisplayName,
                &amp;user.AvatarURL, &amp;user.TimeZone, &amp;user.Language, &amp;user.IsActive,
                &amp;user.IsLocked, &amp;user.LockedUntil, &amp;user.FailedLoginAttempts,
                &amp;user.LastLoginAt, &amp;user.LastLoginIP, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                &amp;settings)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                user.Settings = settings.String
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) Update(user *models.User) error <span class="cov0" title="0">{
        query := `
                UPDATE users SET
                        username = ?, email = ?, first_name = ?, last_name = ?, display_name = ?,
                        avatar_url = ?, time_zone = ?, language = ?, is_active = ?, settings = ?,
                        updated_at = ?
                WHERE id = ?
        `

        _, err := r.db.Exec(query,
                user.Username, user.Email, user.FirstName, user.LastName, user.DisplayName,
                user.AvatarURL, user.TimeZone, user.Language, user.IsActive, user.Settings,
                time.Now(), user.ID)

        return err
}</span>

func (r *UserRepository) UpdatePassword(userID int, passwordHash, salt string) error <span class="cov0" title="0">{
        query := `UPDATE users SET password_hash = ?, salt = ?, updated_at = ? WHERE id = ?`
        _, err := r.db.Exec(query, passwordHash, salt, time.Now(), userID)
        return err
}</span>

func (r *UserRepository) UpdateLastLogin(userID int, ipAddress string) error <span class="cov0" title="0">{
        query := `UPDATE users SET last_login_at = ?, last_login_ip = ? WHERE id = ?`
        _, err := r.db.Exec(query, time.Now(), ipAddress, userID)
        return err
}</span>

func (r *UserRepository) IncrementFailedLoginAttempts(userID int) error <span class="cov0" title="0">{
        query := `UPDATE users SET failed_login_attempts = failed_login_attempts + 1 WHERE id = ?`
        _, err := r.db.Exec(query, userID)
        return err
}</span>

func (r *UserRepository) ResetFailedLoginAttempts(userID int) error <span class="cov0" title="0">{
        query := `UPDATE users SET failed_login_attempts = 0 WHERE id = ?`
        _, err := r.db.Exec(query, userID)
        return err
}</span>

func (r *UserRepository) LockAccount(userID int, lockUntil time.Time) error <span class="cov0" title="0">{
        query := `UPDATE users SET is_locked = 1, locked_until = ? WHERE id = ?`
        _, err := r.db.Exec(query, lockUntil, userID)
        return err
}</span>

func (r *UserRepository) UnlockAccount(userID int) error <span class="cov0" title="0">{
        query := `UPDATE users SET is_locked = 0, locked_until = NULL WHERE id = ?`
        _, err := r.db.Exec(query, userID)
        return err
}</span>

func (r *UserRepository) Delete(id int) error <span class="cov0" title="0">{
        query := `DELETE FROM users WHERE id = ?`
        _, err := r.db.Exec(query, id)
        return err
}</span>

func (r *UserRepository) List(limit, offset int) ([]models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, username, email, password_hash, salt, role_id, first_name, last_name,
                           display_name, avatar_url, time_zone, language, is_active, is_locked,
                           locked_until, failed_login_attempts, last_login_at, last_login_ip,
                           created_at, updated_at, settings
                FROM users
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?
        `

        rows, err := r.db.Query(query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list users: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []models.User
        for rows.Next() </span><span class="cov0" title="0">{
                var user models.User
                var settings sql.NullString

                err := rows.Scan(
                        &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.PasswordHash, &amp;user.Salt,
                        &amp;user.RoleID, &amp;user.FirstName, &amp;user.LastName, &amp;user.DisplayName,
                        &amp;user.AvatarURL, &amp;user.TimeZone, &amp;user.Language, &amp;user.IsActive,
                        &amp;user.IsLocked, &amp;user.LockedUntil, &amp;user.FailedLoginAttempts,
                        &amp;user.LastLoginAt, &amp;user.LastLoginIP, &amp;user.CreatedAt, &amp;user.UpdatedAt,
                        &amp;settings)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user: %w", err)
                }</span>

                <span class="cov0" title="0">if settings.Valid </span><span class="cov0" title="0">{
                        user.Settings = settings.String
                }</span>

                <span class="cov0" title="0">users = append(users, user)</span>
        }

        <span class="cov0" title="0">return users, nil</span>
}

func (r *UserRepository) Count() (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM users`
        var count int
        err := r.db.QueryRow(query).Scan(&amp;count)
        return count, err
}</span>

func (r *UserRepository) GetRole(roleID int) (*models.Role, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, permissions, is_system, created_at, updated_at
                FROM roles WHERE id = ?
        `

        role := &amp;models.Role{}
        var permissionsJSON string

        err := r.db.QueryRow(query, roleID).Scan(
                &amp;role.ID, &amp;role.Name, &amp;role.Description, &amp;permissionsJSON,
                &amp;role.IsSystem, &amp;role.CreatedAt, &amp;role.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, errors.New("role not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get role: %w", err)</span>
        }

        <span class="cov0" title="0">err = json.Unmarshal([]byte(permissionsJSON), &amp;role.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">return role, nil</span>
}

func (r *UserRepository) CreateSession(session *models.UserSession) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO user_sessions (user_id, session_token, refresh_token, device_info,
                                                                  ip_address, user_agent, is_active, expires_at, created_at, last_activity_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        deviceInfoJSON, err := json.Marshal(session.DeviceInfo)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to marshal device info: %w", err)
        }</span>

        <span class="cov0" title="0">result, err := r.db.Exec(query,
                session.UserID, session.SessionToken, session.RefreshToken, string(deviceInfoJSON),
                session.IPAddress, session.UserAgent, session.IsActive, session.ExpiresAt,
                session.CreatedAt, session.LastActivityAt)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create session: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get session ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *UserRepository) GetSession(sessionID string) (*models.UserSession, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, session_token, refresh_token, device_info, ip_address,
                           user_agent, is_active, expires_at, created_at, last_activity_at
                FROM user_sessions WHERE id = ?
        `

        session := &amp;models.UserSession{}
        var deviceInfoJSON string

        err := r.db.QueryRow(query, sessionID).Scan(
                &amp;session.ID, &amp;session.UserID, &amp;session.SessionToken, &amp;session.RefreshToken,
                &amp;deviceInfoJSON, &amp;session.IPAddress, &amp;session.UserAgent, &amp;session.IsActive,
                &amp;session.ExpiresAt, &amp;session.CreatedAt, &amp;session.LastActivityAt)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, errors.New("session not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get session: %w", err)</span>
        }

        <span class="cov0" title="0">err = json.Unmarshal([]byte(deviceInfoJSON), &amp;session.DeviceInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal device info: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (r *UserRepository) GetSessionByRefreshToken(refreshToken string) (*models.UserSession, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, session_token, refresh_token, device_info, ip_address,
                           user_agent, is_active, expires_at, created_at, last_activity_at
                FROM user_sessions WHERE refresh_token = ? AND is_active = 1
        `

        session := &amp;models.UserSession{}
        var deviceInfoJSON string

        err := r.db.QueryRow(query, refreshToken).Scan(
                &amp;session.ID, &amp;session.UserID, &amp;session.SessionToken, &amp;session.RefreshToken,
                &amp;deviceInfoJSON, &amp;session.IPAddress, &amp;session.UserAgent, &amp;session.IsActive,
                &amp;session.ExpiresAt, &amp;session.CreatedAt, &amp;session.LastActivityAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal([]byte(deviceInfoJSON), &amp;session.DeviceInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal device info: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (r *UserRepository) UpdateSessionTokens(sessionID int, sessionToken, refreshToken string) error <span class="cov0" title="0">{
        query := `UPDATE user_sessions SET session_token = ?, refresh_token = ? WHERE id = ?`
        _, err := r.db.Exec(query, sessionToken, refreshToken, sessionID)
        return err
}</span>

func (r *UserRepository) UpdateSessionTokensAndExpiry(sessionID int, sessionToken, refreshToken string, expiresAt time.Time) error <span class="cov0" title="0">{
        query := `UPDATE user_sessions SET session_token = ?, refresh_token = ?, expires_at = ? WHERE id = ?`
        _, err := r.db.Exec(query, sessionToken, refreshToken, expiresAt, sessionID)
        return err
}</span>

func (r *UserRepository) UpdateSessionActivity(sessionID int) error <span class="cov0" title="0">{
        query := `UPDATE user_sessions SET last_activity_at = ? WHERE id = ?`
        _, err := r.db.Exec(query, time.Now(), sessionID)
        return err
}</span>

func (r *UserRepository) DeactivateSession(sessionID int) error <span class="cov0" title="0">{
        query := `UPDATE user_sessions SET is_active = 0 WHERE id = ?`
        _, err := r.db.Exec(query, sessionID)
        return err
}</span>

func (r *UserRepository) DeactivateAllUserSessions(userID int) error <span class="cov0" title="0">{
        query := `UPDATE user_sessions SET is_active = 0 WHERE user_id = ?`
        _, err := r.db.Exec(query, userID)
        return err
}</span>

func (r *UserRepository) GetActiveUserSessions(userID int) ([]models.UserSession, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, session_token, refresh_token, device_info, ip_address,
                           user_agent, is_active, expires_at, created_at, last_activity_at
                FROM user_sessions
                WHERE user_id = ? AND is_active = 1 AND expires_at &gt; ?
                ORDER BY last_activity_at DESC
        `

        rows, err := r.db.Query(query, userID, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active sessions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var sessions []models.UserSession
        for rows.Next() </span><span class="cov0" title="0">{
                var session models.UserSession
                var deviceInfoJSON string

                err := rows.Scan(
                        &amp;session.ID, &amp;session.UserID, &amp;session.SessionToken, &amp;session.RefreshToken,
                        &amp;deviceInfoJSON, &amp;session.IPAddress, &amp;session.UserAgent, &amp;session.IsActive,
                        &amp;session.ExpiresAt, &amp;session.CreatedAt, &amp;session.LastActivityAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan session: %w", err)
                }</span>

                <span class="cov0" title="0">err = json.Unmarshal([]byte(deviceInfoJSON), &amp;session.DeviceInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal device info: %w", err)
                }</span>

                <span class="cov0" title="0">sessions = append(sessions, session)</span>
        }

        <span class="cov0" title="0">return sessions, nil</span>
}

func (r *UserRepository) CleanupExpiredSessions() error <span class="cov0" title="0">{
        query := `DELETE FROM user_sessions WHERE expires_at &lt; ? OR (is_active = 0 AND created_at &lt; ?)`
        cutoff := time.Now().Add(-30 * 24 * time.Hour) // Remove inactive sessions older than 30 days
        _, err := r.db.Exec(query, time.Now(), cutoff)
        return err
}</span>

func (r *UserRepository) CreateRole(role *models.Role) (int, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO roles (name, description, permissions, is_system, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        permissionsJSON, err := json.Marshal(role.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to marshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        result, err := r.db.Exec(query, role.Name, role.Description, string(permissionsJSON),
                role.IsSystem, now, now)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create role: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get role ID: %w", err)
        }</span>

        <span class="cov0" title="0">return int(id), nil</span>
}

func (r *UserRepository) UpdateRole(role *models.Role) error <span class="cov0" title="0">{
        query := `
                UPDATE roles SET name = ?, description = ?, permissions = ?, updated_at = ?
                WHERE id = ? AND is_system = 0
        `

        permissionsJSON, err := json.Marshal(role.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal permissions: %w", err)
        }</span>

        <span class="cov0" title="0">result, err := r.db.Exec(query, role.Name, role.Description, string(permissionsJSON),
                time.Now(), role.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update role: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("role not found or is system role")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *UserRepository) DeleteRole(roleID int) error <span class="cov0" title="0">{
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        var userCount int
        err = tx.QueryRow("SELECT COUNT(*) FROM users WHERE role_id = ?", roleID).Scan(&amp;userCount)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check role usage: %w", err)
        }</span>

        <span class="cov0" title="0">if userCount &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("cannot delete role that is assigned to users")
        }</span>

        <span class="cov0" title="0">result, err := tx.Exec("DELETE FROM roles WHERE id = ? AND is_system = 0", roleID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete role: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("role not found or is system role")
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}

func (r *UserRepository) ListRoles() ([]models.Role, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, permissions, is_system, created_at, updated_at
                FROM roles ORDER BY is_system DESC, name ASC
        `

        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list roles: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var roles []models.Role
        for rows.Next() </span><span class="cov0" title="0">{
                var role models.Role
                var permissionsJSON string

                err := rows.Scan(&amp;role.ID, &amp;role.Name, &amp;role.Description, &amp;permissionsJSON,
                        &amp;role.IsSystem, &amp;role.CreatedAt, &amp;role.UpdatedAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan role: %w", err)
                }</span>

                <span class="cov0" title="0">err = json.Unmarshal([]byte(permissionsJSON), &amp;role.Permissions)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal permissions: %w", err)
                }</span>

                <span class="cov0" title="0">roles = append(roles, role)</span>
        }

        <span class="cov0" title="0">return roles, nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package services

import (
        "encoding/json"
        "fmt"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type AnalyticsService struct {
        analyticsRepo *repository.AnalyticsRepository
}

func NewAnalyticsService(analyticsRepo *repository.AnalyticsRepository) *AnalyticsService <span class="cov0" title="0">{
        return &amp;AnalyticsService{
                analyticsRepo: analyticsRepo,
        }
}</span>

func (s *AnalyticsService) LogMediaAccess(access *models.MediaAccessLog) error <span class="cov0" title="0">{
        return s.analyticsRepo.LogMediaAccess(access)
}</span>

func (s *AnalyticsService) LogEvent(event *models.AnalyticsEvent) error <span class="cov0" title="0">{
        return s.analyticsRepo.LogEvent(event)
}</span>

func (s *AnalyticsService) GetMediaAccessLogs(userID int, mediaID *int, limit, offset int) ([]models.MediaAccessLog, error) <span class="cov0" title="0">{
        return s.analyticsRepo.GetMediaAccessLogs(userID, mediaID, limit, offset)
}</span>

func (s *AnalyticsService) GetUserAnalytics(userID int, startDate, endDate time.Time) (*models.UserAnalytics, error) <span class="cov0" title="0">{
        logs, err := s.analyticsRepo.GetUserMediaAccessLogs(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">events, err := s.analyticsRepo.GetUserEvents(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">analytics := &amp;models.UserAnalytics{
                UserID:               userID,
                StartDate:            startDate,
                EndDate:              endDate,
                TotalMediaAccesses:   len(logs),
                TotalEvents:          len(events),
                UniqueMediaAccessed:  s.countUniqueMedia(logs),
                TotalPlaybackTime:    s.calculateTotalPlaybackTime(logs),
                MostAccessedMedia:    s.findMostAccessedMedia(logs),
                PreferredAccessTimes: s.analyzeAccessTimes(logs),
                DeviceUsage:          s.analyzeDeviceUsage(logs),
                LocationAnalysis:     s.analyzeLocations(logs),
        }

        return analytics, nil</span>
}

func (s *AnalyticsService) GetSystemAnalytics(startDate, endDate time.Time) (*models.SystemAnalytics, error) <span class="cov0" title="0">{
        totalUsers, err := s.analyticsRepo.GetTotalUsers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">activeUsers, err := s.analyticsRepo.GetActiveUsers(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">totalMediaAccesses, err := s.analyticsRepo.GetTotalMediaAccesses(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">totalEvents, err := s.analyticsRepo.GetTotalEvents(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">topMedia, err := s.analyticsRepo.GetTopAccessedMedia(startDate, endDate, 10)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">userGrowth, err := s.analyticsRepo.GetUserGrowthData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">analytics := &amp;models.SystemAnalytics{
                StartDate:              startDate,
                EndDate:                endDate,
                TotalUsers:             totalUsers,
                ActiveUsers:            activeUsers,
                TotalMediaAccesses:     totalMediaAccesses,
                TotalEvents:            totalEvents,
                TopAccessedMedia:       topMedia,
                UserGrowthData:         userGrowth,
                AverageSessionDuration: s.calculateAverageSessionDuration(startDate, endDate),
                PeakUsageHours:         s.analyzePeakUsageHours(startDate, endDate),
                PopularFileTypes:       s.analyzePopularFileTypes(startDate, endDate),
                GeographicDistribution: s.analyzeGeographicDistribution(startDate, endDate),
        }

        return analytics, nil</span>
}

func (s *AnalyticsService) GetMediaAnalytics(mediaID int, startDate, endDate time.Time) (*models.MediaAnalytics, error) <span class="cov0" title="0">{
        logs, err := s.analyticsRepo.GetMediaAccessLogs(0, &amp;mediaID, 1000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filteredLogs := s.filterLogsByDate(logs, startDate, endDate)

        analytics := &amp;models.MediaAnalytics{
                MediaID:             mediaID,
                StartDate:           startDate,
                EndDate:             endDate,
                TotalAccesses:       len(filteredLogs),
                UniqueUsers:         s.countUniqueUsers(filteredLogs),
                TotalPlaybackTime:   s.calculateTotalPlaybackTime(filteredLogs),
                AveragePlaybackTime: s.calculateAveragePlaybackTime(filteredLogs),
                AccessPatterns:      s.analyzeAccessPatterns(filteredLogs),
                UserRetention:       s.calculateUserRetention(filteredLogs),
                PopularTimeRanges:   s.analyzePopularTimeRanges(filteredLogs),
                DevicePreferences:   s.analyzeDevicePreferences(filteredLogs),
        }

        return analytics, nil</span>
}

func (s *AnalyticsService) CreateReport(reportType string, params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        switch reportType </span>{
        case "user_activity":<span class="cov0" title="0">
                return s.generateUserActivityReport(params)</span>
        case "media_popularity":<span class="cov0" title="0">
                return s.generateMediaPopularityReport(params)</span>
        case "system_overview":<span class="cov0" title="0">
                return s.generateSystemOverviewReport(params)</span>
        case "geographic_analysis":<span class="cov0" title="0">
                return s.generateGeographicAnalysisReport(params)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported report type: %s", reportType)</span>
        }
}

func (s *AnalyticsService) generateUserActivityReport(params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">systemAnalytics, err := s.GetSystemAnalytics(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "analytics": systemAnalytics,
                "summary": map[string]interface{}{
                        "period":         fmt.Sprintf("%s to %s", startDate.Format("2006-01-02"), endDate.Format("2006-01-02")),
                        "active_users":   systemAnalytics.ActiveUsers,
                        "total_accesses": systemAnalytics.TotalMediaAccesses,
                },
        }

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.AnalyticsReport{
                Type:      "user_activity",
                Data:      string(dataJSON),
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil</span>
}

func (s *AnalyticsService) generateMediaPopularityReport(params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">topMedia, err := s.analyticsRepo.GetTopAccessedMedia(startDate, endDate, 50)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "top_media": topMedia,
                "period":    fmt.Sprintf("%s to %s", startDate.Format("2006-01-02"), endDate.Format("2006-01-02")),
                "total":     len(topMedia),
        }

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.AnalyticsReport{
                Type:      "media_popularity",
                Data:      string(dataJSON),
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil</span>
}

func (s *AnalyticsService) generateSystemOverviewReport(params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">systemAnalytics, err := s.GetSystemAnalytics(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "system_analytics": systemAnalytics,
                "summary": map[string]interface{}{
                        "health_score":     s.calculateSystemHealthScore(systemAnalytics),
                        "growth_rate":      s.calculateGrowthRate(systemAnalytics.UserGrowthData),
                        "engagement_level": s.calculateEngagementLevel(systemAnalytics),
                },
        }

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.AnalyticsReport{
                Type:      "system_overview",
                Data:      string(dataJSON),
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil</span>
}

func (s *AnalyticsService) generateGeographicAnalysisReport(params map[string]interface{}) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">geographicData, err := s.analyticsRepo.GetGeographicData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "geographic_distribution": geographicData,
                "period":                  fmt.Sprintf("%s to %s", startDate.Format("2006-01-02"), endDate.Format("2006-01-02")),
                "top_locations":           s.getTopLocations(geographicData, 10),
        }

        dataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.AnalyticsReport{
                Type:      "geographic_analysis",
                Data:      string(dataJSON),
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil</span>
}

func (s *AnalyticsService) countUniqueMedia(logs []models.MediaAccessLog) int <span class="cov0" title="0">{
        mediaSet := make(map[int]bool)
        for _, log := range logs </span><span class="cov0" title="0">{
                mediaSet[log.MediaID] = true
        }</span>
        <span class="cov0" title="0">return len(mediaSet)</span>
}

func (s *AnalyticsService) countUniqueUsers(logs []models.MediaAccessLog) int <span class="cov0" title="0">{
        userSet := make(map[int]bool)
        for _, log := range logs </span><span class="cov0" title="0">{
                userSet[log.UserID] = true
        }</span>
        <span class="cov0" title="0">return len(userSet)</span>
}

func (s *AnalyticsService) calculateTotalPlaybackTime(logs []models.MediaAccessLog) time.Duration <span class="cov0" title="0">{
        var total time.Duration
        for _, log := range logs </span><span class="cov0" title="0">{
                if log.PlaybackDuration != nil </span><span class="cov0" title="0">{
                        total += *log.PlaybackDuration
                }</span>
        }
        <span class="cov0" title="0">return total</span>
}

func (s *AnalyticsService) calculateAveragePlaybackTime(logs []models.MediaAccessLog) time.Duration <span class="cov0" title="0">{
        total := s.calculateTotalPlaybackTime(logs)
        if len(logs) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return total / time.Duration(len(logs))</span>
}

func (s *AnalyticsService) findMostAccessedMedia(logs []models.MediaAccessLog) []models.MediaAccessCount <span class="cov0" title="0">{
        counts := make(map[int]int)
        for _, log := range logs </span><span class="cov0" title="0">{
                counts[log.MediaID]++
        }</span>

        <span class="cov0" title="0">var results []models.MediaAccessCount
        for mediaID, count := range counts </span><span class="cov0" title="0">{
                results = append(results, models.MediaAccessCount{
                        MediaID:     mediaID,
                        AccessCount: count,
                })
        }</span>

        <span class="cov0" title="0">return results</span>
}

func (s *AnalyticsService) analyzeAccessTimes(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        hourCounts := make(map[string]int)
        for _, log := range logs </span><span class="cov0" title="0">{
                hour := log.AccessTime.Format("15")
                hourCounts[hour]++
        }</span>
        <span class="cov0" title="0">return hourCounts</span>
}

func (s *AnalyticsService) analyzeDeviceUsage(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        deviceCounts := make(map[string]int)
        for _, log := range logs </span><span class="cov0" title="0">{
                if log.DeviceInfo != nil </span><span class="cov0" title="0">{
                        deviceModel := ""
                        if log.DeviceInfo.DeviceModel != nil </span><span class="cov0" title="0">{
                                deviceModel = *log.DeviceInfo.DeviceModel
                        }</span>
                        <span class="cov0" title="0">deviceType := fmt.Sprintf("%s %s", log.DeviceInfo.Platform, deviceModel)
                        deviceCounts[deviceType]++</span>
                }
        }
        <span class="cov0" title="0">return deviceCounts</span>
}

func (s *AnalyticsService) analyzeLocations(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        locationCounts := make(map[string]int)
        for _, log := range logs </span><span class="cov0" title="0">{
                if log.Location != nil </span><span class="cov0" title="0">{
                        location := fmt.Sprintf("%.2f,%.2f", log.Location.Latitude, log.Location.Longitude)
                        locationCounts[location]++
                }</span>
        }
        <span class="cov0" title="0">return locationCounts</span>
}

func (s *AnalyticsService) filterLogsByDate(logs []models.MediaAccessLog, startDate, endDate time.Time) []models.MediaAccessLog <span class="cov0" title="0">{
        var filtered []models.MediaAccessLog
        for _, log := range logs </span><span class="cov0" title="0">{
                if log.AccessTime.After(startDate) &amp;&amp; log.AccessTime.Before(endDate) </span><span class="cov0" title="0">{
                        filtered = append(filtered, log)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

func (s *AnalyticsService) analyzeAccessPatterns(logs []models.MediaAccessLog) map[string]interface{} <span class="cov0" title="0">{
        patterns := make(map[string]interface{})

        hourlyPatterns := s.analyzeAccessTimes(logs)
        dailyPatterns := make(map[string]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                day := log.AccessTime.Weekday().String()
                dailyPatterns[day]++
        }</span>

        <span class="cov0" title="0">patterns["hourly"] = hourlyPatterns
        patterns["daily"] = dailyPatterns

        return patterns</span>
}

func (s *AnalyticsService) calculateUserRetention(logs []models.MediaAccessLog) float64 <span class="cov0" title="0">{
        if len(logs) &lt;= 1 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">userFirstAccess := make(map[int]time.Time)
        userLastAccess := make(map[int]time.Time)

        for _, log := range logs </span><span class="cov0" title="0">{
                if first, exists := userFirstAccess[log.UserID]; !exists || log.AccessTime.Before(first) </span><span class="cov0" title="0">{
                        userFirstAccess[log.UserID] = log.AccessTime
                }</span>
                <span class="cov0" title="0">if last, exists := userLastAccess[log.UserID]; !exists || log.AccessTime.After(last) </span><span class="cov0" title="0">{
                        userLastAccess[log.UserID] = log.AccessTime
                }</span>
        }

        <span class="cov0" title="0">totalRetention := 0.0
        userCount := 0

        for userID, firstAccess := range userFirstAccess </span><span class="cov0" title="0">{
                lastAccess := userLastAccess[userID]
                retention := lastAccess.Sub(firstAccess).Hours() / 24.0
                totalRetention += retention
                userCount++
        }</span>

        <span class="cov0" title="0">if userCount == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return totalRetention / float64(userCount)</span>
}

func (s *AnalyticsService) analyzePopularTimeRanges(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        timeRanges := make(map[string]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                hour := log.AccessTime.Hour()
                var timeRange string

                switch </span>{
                case hour &gt;= 6 &amp;&amp; hour &lt; 12:<span class="cov0" title="0">
                        timeRange = "morning"</span>
                case hour &gt;= 12 &amp;&amp; hour &lt; 18:<span class="cov0" title="0">
                        timeRange = "afternoon"</span>
                case hour &gt;= 18 &amp;&amp; hour &lt; 22:<span class="cov0" title="0">
                        timeRange = "evening"</span>
                default:<span class="cov0" title="0">
                        timeRange = "night"</span>
                }

                <span class="cov0" title="0">timeRanges[timeRange]++</span>
        }

        <span class="cov0" title="0">return timeRanges</span>
}

func (s *AnalyticsService) analyzeDevicePreferences(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        return s.analyzeDeviceUsage(logs)
}</span>

func (s *AnalyticsService) calculateAverageSessionDuration(startDate, endDate time.Time) time.Duration <span class="cov0" title="0">{
        sessions, err := s.analyticsRepo.GetSessionData(startDate, endDate)
        if err != nil || len(sessions) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var totalDuration time.Duration
        for _, session := range sessions </span><span class="cov0" title="0">{
                totalDuration += session.Duration
        }</span>

        <span class="cov0" title="0">return totalDuration / time.Duration(len(sessions))</span>
}

func (s *AnalyticsService) analyzePeakUsageHours(startDate, endDate time.Time) map[string]int <span class="cov0" title="0">{
        logs, err := s.analyticsRepo.GetAllMediaAccessLogs(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]int)
        }</span>

        <span class="cov0" title="0">return s.analyzeAccessTimes(logs)</span>
}

func (s *AnalyticsService) analyzePopularFileTypes(startDate, endDate time.Time) map[string]int <span class="cov0" title="0">{
        fileTypes, err := s.analyticsRepo.GetFileTypeData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]int)
        }</span>

        <span class="cov0" title="0">return fileTypes</span>
}

func (s *AnalyticsService) analyzeGeographicDistribution(startDate, endDate time.Time) map[string]interface{} <span class="cov0" title="0">{
        geographicData, err := s.analyticsRepo.GetGeographicData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">return geographicData</span>
}

func (s *AnalyticsService) calculateSystemHealthScore(analytics *models.SystemAnalytics) float64 <span class="cov0" title="0">{
        score := 0.0

        if analytics.TotalUsers &gt; 0 </span><span class="cov0" title="0">{
                activeUserRatio := float64(analytics.ActiveUsers) / float64(analytics.TotalUsers)
                score += activeUserRatio * 40
        }</span>

        <span class="cov0" title="0">if analytics.TotalMediaAccesses &gt; 0 </span><span class="cov0" title="0">{
                score += 30
        }</span>

        <span class="cov0" title="0">if analytics.TotalEvents &gt; 0 </span><span class="cov0" title="0">{
                score += 20
        }</span>

        <span class="cov0" title="0">if analytics.AverageSessionDuration &gt; time.Minute*5 </span><span class="cov0" title="0">{
                score += 10
        }</span>

        <span class="cov0" title="0">return score</span>
}

func (s *AnalyticsService) calculateGrowthRate(growthData []models.UserGrowthPoint) float64 <span class="cov0" title="0">{
        if len(growthData) &lt; 2 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">first := growthData[0]
        last := growthData[len(growthData)-1]

        if first.UserCount == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return (float64(last.UserCount) - float64(first.UserCount)) / float64(first.UserCount) * 100</span>
}

func (s *AnalyticsService) calculateEngagementLevel(analytics *models.SystemAnalytics) string <span class="cov0" title="0">{
        if analytics.TotalUsers == 0 </span><span class="cov0" title="0">{
                return "low"
        }</span>

        <span class="cov0" title="0">accessesPerUser := float64(analytics.TotalMediaAccesses) / float64(analytics.TotalUsers)

        switch </span>{
        case accessesPerUser &gt;= 50:<span class="cov0" title="0">
                return "high"</span>
        case accessesPerUser &gt;= 20:<span class="cov0" title="0">
                return "medium"</span>
        default:<span class="cov0" title="0">
                return "low"</span>
        }
}

func (s *AnalyticsService) getTopLocations(geographicData map[string]interface{}, limit int) []map[string]interface{} <span class="cov0" title="0">{
        var locations []map[string]interface{}

        if locationsData, ok := geographicData["locations"].([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                for i, location := range locationsData </span><span class="cov0" title="0">{
                        if i &gt;= limit </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">locations = append(locations, location)</span>
                }
        }

        <span class="cov0" title="0">return locations</span>
}

// TrackEvent tracks an analytics event
func (s *AnalyticsService) TrackEvent(userID int, event *models.AnalyticsEventRequest) error <span class="cov0" title="0">{
        // Convert AnalyticsEventRequest to AnalyticsEvent
        data, _ := json.Marshal(event)
        analyticsEvent := &amp;models.AnalyticsEvent{
                UserID:    userID,
                EventType: event.EventType,
                Data:      string(data),
                Timestamp: time.Now(),
        }
        return s.LogEvent(analyticsEvent)
}</span>

// GetEventsByUser gets events for a user with filters
func (s *AnalyticsService) GetEventsByUser(userID int, filters *models.AnalyticsFilters) ([]models.AnalyticsEvent, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        return []models.AnalyticsEvent{}, nil
}</span>

// GetAnalytics gets analytics data with filters
func (s *AnalyticsService) GetAnalytics(userID int, filters *models.AnalyticsFilters) (*models.AnalyticsData, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        return &amp;models.AnalyticsData{}, nil
}</span>

// GetDashboardMetrics gets dashboard metrics
func (s *AnalyticsService) GetDashboardMetrics(userID int) (*models.DashboardMetrics, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        return &amp;models.DashboardMetrics{}, nil
}</span>

// GetRealtimeMetrics gets realtime metrics
func (s *AnalyticsService) GetRealtimeMetrics(userID int) (*models.RealtimeMetrics, error) <span class="cov0" title="0">{
        // This is a simplified implementation
        return &amp;models.RealtimeMetrics{}, nil
}</span>

// GenerateReport generates an analytics report
func (s *AnalyticsService) GenerateReport(userID int, request *models.ReportRequest) (*models.AnalyticsReport, error) <span class="cov0" title="0">{
        // Stub implementation for testing
        return &amp;models.AnalyticsReport{
                Type:      request.ReportType,
                Data:      "{}",
                CreatedAt: time.Now(),
                Status:    "completed",
        }, nil
}</span>

// CleanupOldEvents cleans up old events
func (s *AnalyticsService) CleanupOldEvents(daysOld int) error <span class="cov0" title="0">{
        // This is a simplified implementation
        return nil
}</span>

func (s *AnalyticsService) extractDateRange(params map[string]interface{}) (time.Time, time.Time, error) <span class="cov0" title="0">{
        startDateStr, ok := params["start_date"].(string)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("start_date parameter required")
        }</span>

        <span class="cov0" title="0">endDateStr, ok := params["end_date"].(string)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("end_date parameter required")
        }</span>

        <span class="cov0" title="0">startDate, err := time.Parse("2006-01-02", startDateStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("invalid start_date format")
        }</span>

        <span class="cov0" title="0">endDate, err := time.Parse("2006-01-02", endDateStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("invalid end_date format")
        }</span>

        <span class="cov0" title="0">return startDate, endDate, nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package services

import (
        "crypto/rand"
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "errors"
        "fmt"
        "strconv"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "golang.org/x/crypto/bcrypt"

        "catalogizer/models"
        "catalogizer/repository"
)

// AuthService handles authentication and authorization
type AuthService struct {
        userRepo   *repository.UserRepository
        jwtSecret  []byte
        jwtExpiry  time.Duration
        refreshExp time.Duration
}

// NewAuthService creates a new authentication service
func NewAuthService(userRepo *repository.UserRepository, jwtSecret string) *AuthService <span class="cov0" title="0">{
        return &amp;AuthService{
                userRepo:   userRepo,
                jwtSecret:  []byte(jwtSecret),
                jwtExpiry:  24 * time.Hour,     // 24 hours
                refreshExp: 7 * 24 * time.Hour, // 7 days
        }
}</span>

// JWTClaims represents the claims in our JWT tokens
type JWTClaims struct {
        UserID    int    `json:"user_id"`
        Username  string `json:"username"`
        RoleID    int    `json:"role_id"`
        SessionID string `json:"session_id"`
        jwt.RegisteredClaims
}

// AuthResult represents the result of authentication
type AuthResult struct {
        User         *models.User `json:"user"`
        SessionToken string       `json:"session_token"`
        RefreshToken string       `json:"refresh_token"`
        ExpiresAt    time.Time    `json:"expires_at"`
}

// Login authenticates a user and creates a session
func (s *AuthService) Login(req models.LoginRequest, ipAddress string, userAgent string) (*AuthResult, error) <span class="cov0" title="0">{
        // Find user by username or email
        user, err := s.userRepo.GetByUsernameOrEmail(req.Username)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid credentials")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        // Check if user can login
        <span class="cov0" title="0">if !user.CanLogin() </span><span class="cov0" title="0">{
                if user.IsLocked </span><span class="cov0" title="0">{
                        return nil, errors.New("account is temporarily locked")
                }</span>
                <span class="cov0" title="0">return nil, errors.New("account is disabled")</span>
        }

        // Verify password
        <span class="cov0" title="0">if !s.verifyPassword(req.Password, user.Salt, user.PasswordHash) </span><span class="cov0" title="0">{
                // Increment failed login attempts
                s.userRepo.IncrementFailedLoginAttempts(user.ID)
                return nil, errors.New("invalid credentials")
        }</span>

        // Reset failed login attempts on successful login
        <span class="cov0" title="0">s.userRepo.ResetFailedLoginAttempts(user.ID)

        // Create session
        session, err := s.createSession(user, req.DeviceInfo, ipAddress, userAgent, req.RememberMe)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create session: %w", err)
        }</span>

        // Update last login information
        <span class="cov0" title="0">s.userRepo.UpdateLastLogin(user.ID, ipAddress)

        // Load user role
        role, err := s.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user role: %w", err)
        }</span>
        <span class="cov0" title="0">user.Role = role

        // Generate JWT token
        token, err := s.generateJWT(user, session.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // Generate refresh token
        <span class="cov0" title="0">refreshToken, err := s.generateRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        // Update session with tokens
        <span class="cov0" title="0">err = s.userRepo.UpdateSessionTokens(session.ID, token, refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update session tokens: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;AuthResult{
                User:         user,
                SessionToken: token,
                RefreshToken: refreshToken,
                ExpiresAt:    session.ExpiresAt,
        }, nil</span>
}

// RefreshToken refreshes an authentication token
func (s *AuthService) RefreshToken(refreshToken string) (*AuthResult, error) <span class="cov0" title="0">{
        // Find session by refresh token
        session, err := s.userRepo.GetSessionByRefreshToken(refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid refresh token")
        }</span>

        // Check if session is still valid
        <span class="cov0" title="0">if !session.IsActive || session.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, errors.New("session expired")
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := s.userRepo.GetByID(session.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        // Check if user can still login
        <span class="cov0" title="0">if !user.CanLogin() </span><span class="cov0" title="0">{
                // Deactivate session
                s.userRepo.DeactivateSession(session.ID)
                return nil, errors.New("account is disabled")
        }</span>

        // Load user role
        <span class="cov0" title="0">role, err := s.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user role: %w", err)
        }</span>
        <span class="cov0" title="0">user.Role = role

        // Generate new JWT token
        newToken, err := s.generateJWT(user, session.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // Generate new refresh token
        <span class="cov0" title="0">newRefreshToken, err := s.generateRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        // Update session with new tokens and extend expiry
        <span class="cov0" title="0">newExpiry := time.Now().Add(s.refreshExp)
        err = s.userRepo.UpdateSessionTokensAndExpiry(session.ID, newToken, newRefreshToken, newExpiry)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update session: %w", err)
        }</span>

        // Update last activity
        <span class="cov0" title="0">s.userRepo.UpdateSessionActivity(session.ID)

        return &amp;AuthResult{
                User:         user,
                SessionToken: newToken,
                RefreshToken: newRefreshToken,
                ExpiresAt:    newExpiry,
        }, nil</span>
}

// Logout terminates a user session
func (s *AuthService) Logout(sessionToken string) error <span class="cov0" title="0">{
        claims, err := s.validateToken(sessionToken)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sessionID, _ := strconv.Atoi(claims.SessionID)
        return s.userRepo.DeactivateSession(sessionID)</span>
}

// LogoutAll terminates all sessions for a user
func (s *AuthService) LogoutAll(userID int) error <span class="cov0" title="0">{
        return s.userRepo.DeactivateAllUserSessions(userID)
}</span>

// ValidateToken validates a JWT token and returns the claims
func (s *AuthService) ValidateToken(tokenString string) (*JWTClaims, error) <span class="cov0" title="0">{
        return s.validateToken(tokenString)
}</span>

// GetCurrentUser gets the current user from a JWT token
func (s *AuthService) GetCurrentUser(tokenString string) (*models.User, error) <span class="cov0" title="0">{
        claims, err := s.validateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if session is still active
        <span class="cov0" title="0">session, err := s.userRepo.GetSession(claims.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("session not found")
        }</span>

        <span class="cov0" title="0">if !session.IsActive || session.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, errors.New("session expired")
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := s.userRepo.GetByID(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        // Load user role
        <span class="cov0" title="0">role, err := s.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user role: %w", err)
        }</span>
        <span class="cov0" title="0">user.Role = role

        // Update session activity
        sessionID, _ := strconv.Atoi(claims.SessionID)
        s.userRepo.UpdateSessionActivity(sessionID)

        return user, nil</span>
}

// ChangePassword changes a user's password
func (s *AuthService) ChangePassword(userID int, currentPassword, newPassword string) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>

        // Verify current password
        <span class="cov0" title="0">if !s.verifyPassword(currentPassword, user.Salt, user.PasswordHash) </span><span class="cov0" title="0">{
                return errors.New("current password is incorrect")
        }</span>

        // Generate new salt and hash
        <span class="cov0" title="0">salt, err := s.generateSalt()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov0" title="0">passwordHash, err := s.hashPassword(newPassword, salt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Update password
        <span class="cov0" title="0">err = s.userRepo.UpdatePassword(userID, passwordHash, salt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        // Deactivate all sessions except current one (force re-login on other devices)
        // This is a security best practice when password changes
        <span class="cov0" title="0">return s.userRepo.DeactivateAllUserSessions(userID)</span>
}

// ResetPassword resets a user's password (admin function)
func (s *AuthService) ResetPassword(userID int, newPassword string) error <span class="cov0" title="0">{
        // Generate new salt and hash
        salt, err := s.generateSalt()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov0" title="0">passwordHash, err := s.hashPassword(newPassword, salt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Update password
        <span class="cov0" title="0">err = s.userRepo.UpdatePassword(userID, passwordHash, salt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        // Deactivate all sessions (force re-login)
        <span class="cov0" title="0">return s.userRepo.DeactivateAllUserSessions(userID)</span>
}

// CheckPermission checks if a user has a specific permission
func (s *AuthService) CheckPermission(userID int, permission string) (bool, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">role, err := s.userRepo.GetRole(user.RoleID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get user role: %w", err)
        }</span>

        <span class="cov0" title="0">return role.Permissions.HasPermission(permission), nil</span>
}

// Private helper methods

func (s *AuthService) createSession(user *models.User, deviceInfo models.DeviceInfo, ipAddress, userAgent string, rememberMe bool) (*models.UserSession, error) <span class="cov0" title="0">{
        sessionToken, err := s.generateSessionToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set expiry based on remember me
        <span class="cov0" title="0">expiry := time.Now().Add(s.jwtExpiry)
        if rememberMe </span><span class="cov0" title="0">{
                expiry = time.Now().Add(s.refreshExp)
        }</span>

        <span class="cov0" title="0">session := &amp;models.UserSession{
                UserID:         user.ID,
                SessionToken:   sessionToken,
                DeviceInfo:     deviceInfo,
                IPAddress:      &amp;ipAddress,
                UserAgent:      &amp;userAgent,
                IsActive:       true,
                ExpiresAt:      expiry,
                CreatedAt:      time.Now(),
                LastActivityAt: time.Now(),
        }

        id, err := s.userRepo.CreateSession(session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">session.ID = id
        return session, nil</span>
}

func (s *AuthService) generateJWT(user *models.User, sessionID int) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        claims := JWTClaims{
                UserID:    user.ID,
                Username:  user.Username,
                RoleID:    user.RoleID,
                SessionID: fmt.Sprintf("%d", sessionID),
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(now.Add(s.jwtExpiry)),
                        IssuedAt:  jwt.NewNumericDate(now),
                        Issuer:    "catalogizer",
                        Subject:   fmt.Sprintf("%d", user.ID),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(s.jwtSecret)
}</span>

func (s *AuthService) validateToken(tokenString string) (*JWTClaims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return s.jwtSecret, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}

func (s *AuthService) generateSessionToken() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

func (s *AuthService) generateRefreshToken() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

func (s *AuthService) generateSalt() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 16)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

func (s *AuthService) hashPassword(password, salt string) (string, error) <span class="cov0" title="0">{
        // Combine password and salt
        combined := password + salt

        // Use bcrypt for additional security
        hash, err := bcrypt.GenerateFromPassword([]byte(combined), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(hash), nil</span>
}

func (s *AuthService) verifyPassword(password, salt, hash string) bool <span class="cov0" title="0">{
        // Combine password and salt
        combined := password + salt

        // Compare with bcrypt
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(combined))
        return err == nil
}</span>

// Session management methods

// GetActiveSessions returns all active sessions for a user
func (s *AuthService) GetActiveSessions(userID int) ([]models.UserSession, error) <span class="cov0" title="0">{
        return s.userRepo.GetActiveUserSessions(userID)
}</span>

// DeactivateSession deactivates a specific session
func (s *AuthService) DeactivateSession(sessionID int) error <span class="cov0" title="0">{
        return s.userRepo.DeactivateSession(sessionID)
}</span>

// CleanupExpiredSessions removes expired sessions from the database
func (s *AuthService) CleanupExpiredSessions() error <span class="cov0" title="0">{
        return s.userRepo.CleanupExpiredSessions()
}</span>

// UpdateSessionActivity updates the last activity time for a session
func (s *AuthService) UpdateSessionActivity(sessionID int) error <span class="cov0" title="0">{
        return s.userRepo.UpdateSessionActivity(sessionID)
}</span>

// Security utilities

// GenerateSecureToken generates a cryptographically secure random token
func (s *AuthService) GenerateSecureToken(length int) (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, length)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

// HashData creates a SHA-256 hash of the given data
func (s *AuthService) HashData(data string) string <span class="cov0" title="0">{
        hash := sha256.Sum256([]byte(data))
        return hex.EncodeToString(hash[:])
}</span>

// ValidatePassword checks if a password meets security requirements
func (s *AuthService) ValidatePassword(password string) error <span class="cov0" title="0">{
        if len(password) &lt; 8 </span><span class="cov0" title="0">{
                return errors.New("password must be at least 8 characters long")
        }</span>

        // Add more password validation rules as needed
        // - Must contain uppercase letter
        // - Must contain lowercase letter
        // - Must contain number
        // - Must contain special character

        <span class="cov0" title="0">return nil</span>
}

// Account security methods

// LockAccount locks a user account until the specified time
func (s *AuthService) LockAccount(userID int, lockUntil time.Time) error <span class="cov0" title="0">{
        return s.userRepo.LockAccount(userID, lockUntil)
}</span>

// UnlockAccount unlocks a user account
func (s *AuthService) UnlockAccount(userID int) error <span class="cov0" title="0">{
        return s.userRepo.UnlockAccount(userID)
}</span>

// CheckAccountLockout checks if an account should be locked due to failed attempts
func (s *AuthService) CheckAccountLockout(userID int) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Lock account if too many failed attempts
        <span class="cov0" title="0">maxAttempts := 5 // This should be configurable
        if user.FailedLoginAttempts &gt;= maxAttempts </span><span class="cov0" title="0">{
                lockDuration := 30 * time.Minute // This should be configurable
                lockUntil := time.Now().Add(lockDuration)
                return s.LockAccount(userID, lockUntil)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package services

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "reflect"
        "sort"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type ConfigurationService struct {
        configRepo  *repository.ConfigurationRepository
        configPath  string
        config      *models.SystemConfiguration
        wizardSteps []*models.WizardStep
        validators  map[string]ConfigValidator
}

type ConfigValidator interface {
        Validate(value interface{}) error
}

type DatabaseValidator struct{}
type NetworkValidator struct{}
type PathValidator struct{}
type EmailValidator struct{}

func NewConfigurationService(configRepo *repository.ConfigurationRepository, configPath string) *ConfigurationService <span class="cov0" title="0">{
        service := &amp;ConfigurationService{
                configRepo: configRepo,
                configPath: configPath,
                validators: make(map[string]ConfigValidator),
        }

        // Register validators
        service.validators["database"] = &amp;DatabaseValidator{}
        service.validators["network"] = &amp;NetworkValidator{}
        service.validators["path"] = &amp;PathValidator{}
        service.validators["email"] = &amp;EmailValidator{}

        // Initialize wizard steps
        service.initializeWizardSteps()

        // Load current configuration
        service.loadConfiguration()

        return service
}</span>

func (s *ConfigurationService) initializeWizardSteps() <span class="cov0" title="0">{
        s.wizardSteps = []*models.WizardStep{
                {
                        ID:          "welcome",
                        Name:        "Welcome",
                        Description: "Welcome to Catalogizer Setup Wizard",
                        Type:        models.WizardStepTypeInfo,
                        Required:    true,
                        Order:       1,
                        Content: map[string]interface{}{
                                "title":   "Welcome to Catalogizer v3.0",
                                "message": "This wizard will help you configure your media cataloging system.",
                        },
                },
                {
                        ID:          "database",
                        Name:        "Database Configuration",
                        Description: "Configure your database connection",
                        Type:        models.WizardStepTypeForm,
                        Required:    true,
                        Order:       2,
                        Fields: []*models.WizardField{
                                {
                                        Name:         "database_type",
                                        Label:        "Database Type",
                                        Type:         "select",
                                        Required:     true,
                                        Options:      []string{"sqlite", "mysql", "postgresql"},
                                        DefaultValue: "sqlite",
                                },
                                {
                                        Name:         "database_host",
                                        Label:        "Database Host",
                                        Type:         "text",
                                        Required:     false,
                                        DefaultValue: "localhost",
                                        ShowWhen:     map[string]interface{}{"database_type": []string{"mysql", "postgresql"}},
                                },
                                {
                                        Name:         "database_port",
                                        Label:        "Database Port",
                                        Type:         "number",
                                        Required:     false,
                                        DefaultValue: 3306,
                                        ShowWhen:     map[string]interface{}{"database_type": []string{"mysql", "postgresql"}},
                                },
                                {
                                        Name:         "database_name",
                                        Label:        "Database Name",
                                        Type:         "text",
                                        Required:     true,
                                        DefaultValue: "catalogizer",
                                },
                                {
                                        Name:     "database_username",
                                        Label:    "Database Username",
                                        Type:     "text",
                                        Required: false,
                                        ShowWhen: map[string]interface{}{"database_type": []string{"mysql", "postgresql"}},
                                },
                                {
                                        Name:     "database_password",
                                        Label:    "Database Password",
                                        Type:     "password",
                                        Required: false,
                                        ShowWhen: map[string]interface{}{"database_type": []string{"mysql", "postgresql"}},
                                },
                        },
                        Validation: map[string]interface{}{
                                "validator": "database",
                        },
                },
                {
                        ID:          "storage",
                        Name:        "Storage Configuration",
                        Description: "Configure storage locations and settings",
                        Type:        models.WizardStepTypeForm,
                        Required:    true,
                        Order:       3,
                        Fields: []*models.WizardField{
                                {
                                        Name:         "media_directory",
                                        Label:        "Media Directory",
                                        Type:         "directory",
                                        Required:     true,
                                        DefaultValue: "/var/lib/catalogizer/media",
                                        Validation:   map[string]interface{}{"validator": "path"},
                                },
                                {
                                        Name:         "thumbnail_directory",
                                        Label:        "Thumbnail Directory",
                                        Type:         "directory",
                                        Required:     true,
                                        DefaultValue: "/var/lib/catalogizer/thumbnails",
                                        Validation:   map[string]interface{}{"validator": "path"},
                                },
                                {
                                        Name:         "temp_directory",
                                        Label:        "Temporary Directory",
                                        Type:         "directory",
                                        Required:     true,
                                        DefaultValue: "/tmp/catalogizer",
                                        Validation:   map[string]interface{}{"validator": "path"},
                                },
                                {
                                        Name:         "max_file_size",
                                        Label:        "Maximum File Size (MB)",
                                        Type:         "number",
                                        Required:     true,
                                        DefaultValue: 1000,
                                },
                                {
                                        Name:         "storage_quota",
                                        Label:        "Storage Quota (GB, 0 = unlimited)",
                                        Type:         "number",
                                        Required:     false,
                                        DefaultValue: 0,
                                },
                        },
                },
                {
                        ID:          "network",
                        Name:        "Network Configuration",
                        Description: "Configure network and API settings",
                        Type:        models.WizardStepTypeForm,
                        Required:    true,
                        Order:       4,
                        Fields: []*models.WizardField{
                                {
                                        Name:         "server_host",
                                        Label:        "Server Host",
                                        Type:         "text",
                                        Required:     true,
                                        DefaultValue: "0.0.0.0",
                                        Validation:   map[string]interface{}{"validator": "network"},
                                },
                                {
                                        Name:         "server_port",
                                        Label:        "Server Port",
                                        Type:         "number",
                                        Required:     true,
                                        DefaultValue: 8080,
                                        Validation:   map[string]interface{}{"validator": "network"},
                                },
                                {
                                        Name:         "enable_https",
                                        Label:        "Enable HTTPS",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: false,
                                },
                                {
                                        Name:     "ssl_cert_path",
                                        Label:    "SSL Certificate Path",
                                        Type:     "file",
                                        Required: false,
                                        ShowWhen: map[string]interface{}{"enable_https": true},
                                },
                                {
                                        Name:     "ssl_key_path",
                                        Label:    "SSL Private Key Path",
                                        Type:     "file",
                                        Required: false,
                                        ShowWhen: map[string]interface{}{"enable_https": true},
                                },
                                {
                                        Name:         "cors_origins",
                                        Label:        "CORS Allowed Origins",
                                        Type:         "text",
                                        Required:     false,
                                        DefaultValue: "*",
                                },
                        },
                },
                {
                        ID:          "authentication",
                        Name:        "Authentication Setup",
                        Description: "Configure authentication and security settings",
                        Type:        models.WizardStepTypeForm,
                        Required:    true,
                        Order:       5,
                        Fields: []*models.WizardField{
                                {
                                        Name:     "jwt_secret",
                                        Label:    "JWT Secret Key",
                                        Type:     "password",
                                        Required: true,
                                        Generate: true,
                                },
                                {
                                        Name:         "session_timeout",
                                        Label:        "Session Timeout (hours)",
                                        Type:         "number",
                                        Required:     true,
                                        DefaultValue: 24,
                                },
                                {
                                        Name:         "enable_registration",
                                        Label:        "Allow User Registration",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                                {
                                        Name:         "require_email_verification",
                                        Label:        "Require Email Verification",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: false,
                                },
                                {
                                        Name:       "admin_email",
                                        Label:      "Administrator Email",
                                        Type:       "email",
                                        Required:   true,
                                        Validation: map[string]interface{}{"validator": "email"},
                                },
                        },
                },
                {
                        ID:          "features",
                        Name:        "Feature Configuration",
                        Description: "Enable and configure advanced features",
                        Type:        models.WizardStepTypeForm,
                        Required:    false,
                        Order:       6,
                        Fields: []*models.WizardField{
                                {
                                        Name:         "enable_media_conversion",
                                        Label:        "Enable Media Format Conversion",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                                {
                                        Name:         "enable_webdav_sync",
                                        Label:        "Enable WebDAV Synchronization",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: false,
                                },
                                {
                                        Name:         "enable_stress_testing",
                                        Label:        "Enable Stress Testing",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: false,
                                },
                                {
                                        Name:         "enable_error_reporting",
                                        Label:        "Enable Error Reporting",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                                {
                                        Name:         "enable_log_management",
                                        Label:        "Enable Log Management",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                        },
                },
                {
                        ID:          "external_services",
                        Name:        "External Services",
                        Description: "Configure integrations with external services",
                        Type:        models.WizardStepTypeForm,
                        Required:    false,
                        Order:       7,
                        Fields: []*models.WizardField{
                                {
                                        Name:     "smtp_host",
                                        Label:    "SMTP Host",
                                        Type:     "text",
                                        Required: false,
                                },
                                {
                                        Name:         "smtp_port",
                                        Label:        "SMTP Port",
                                        Type:         "number",
                                        Required:     false,
                                        DefaultValue: 587,
                                },
                                {
                                        Name:     "smtp_username",
                                        Label:    "SMTP Username",
                                        Type:     "text",
                                        Required: false,
                                },
                                {
                                        Name:     "smtp_password",
                                        Label:    "SMTP Password",
                                        Type:     "password",
                                        Required: false,
                                },
                                {
                                        Name:     "slack_webhook_url",
                                        Label:    "Slack Webhook URL",
                                        Type:     "text",
                                        Required: false,
                                },
                                {
                                        Name:         "enable_analytics",
                                        Label:        "Enable Analytics",
                                        Type:         "checkbox",
                                        Required:     false,
                                        DefaultValue: true,
                                },
                        },
                },
                {
                        ID:          "summary",
                        Name:        "Configuration Summary",
                        Description: "Review your configuration before applying",
                        Type:        models.WizardStepTypeSummary,
                        Required:    true,
                        Order:       8,
                },
                {
                        ID:          "complete",
                        Name:        "Setup Complete",
                        Description: "Configuration has been applied successfully",
                        Type:        models.WizardStepTypeComplete,
                        Required:    true,
                        Order:       9,
                },
        }

        // Sort steps by order
        sort.Slice(s.wizardSteps, func(i, j int) bool </span><span class="cov0" title="0">{
                return s.wizardSteps[i].Order &lt; s.wizardSteps[j].Order
        }</span>)
}

func (s *ConfigurationService) GetWizardSteps() ([]*models.WizardStep, error) <span class="cov0" title="0">{
        return s.wizardSteps, nil
}</span>

func (s *ConfigurationService) GetWizardStep(stepID string) (*models.WizardStep, error) <span class="cov0" title="0">{
        for _, step := range s.wizardSteps </span><span class="cov0" title="0">{
                if step.ID == stepID </span><span class="cov0" title="0">{
                        return step, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("wizard step not found: %s", stepID)</span>
}

func (s *ConfigurationService) ValidateWizardStep(stepID string, data map[string]interface{}) (*models.WizardStepValidation, error) <span class="cov0" title="0">{
        step, err := s.GetWizardStep(stepID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">validation := &amp;models.WizardStepValidation{
                StepID:   stepID,
                Valid:    true,
                Errors:   make(map[string]string),
                Warnings: make(map[string]string),
        }

        // Validate required fields
        for _, field := range step.Fields </span><span class="cov0" title="0">{
                value, exists := data[field.Name]

                if field.Required &amp;&amp; (!exists || s.isEmptyValue(value)) </span><span class="cov0" title="0">{
                        validation.Valid = false
                        validation.Errors[field.Name] = fmt.Sprintf("%s is required", field.Label)
                        continue</span>
                }

                // Validate field using validator
                <span class="cov0" title="0">if exists &amp;&amp; field.Validation != nil </span><span class="cov0" title="0">{
                        if validatorName, ok := field.Validation["validator"].(string); ok </span><span class="cov0" title="0">{
                                if validator, validatorExists := s.validators[validatorName]; validatorExists </span><span class="cov0" title="0">{
                                        if err := validator.Validate(value); err != nil </span><span class="cov0" title="0">{
                                                validation.Valid = false
                                                validation.Errors[field.Name] = err.Error()
                                        }</span>
                                }
                        }
                }
        }

        // Custom step validation
        <span class="cov0" title="0">if step.Validation != nil </span><span class="cov0" title="0">{
                if validatorName, ok := step.Validation["validator"].(string); ok </span><span class="cov0" title="0">{
                        if validator, exists := s.validators[validatorName]; exists </span><span class="cov0" title="0">{
                                if err := validator.Validate(data); err != nil </span><span class="cov0" title="0">{
                                        validation.Valid = false
                                        validation.Errors["_general"] = err.Error()
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return validation, nil</span>
}

func (s *ConfigurationService) SaveWizardProgress(userID int, stepID string, data map[string]interface{}) error <span class="cov0" title="0">{
        progress := &amp;models.WizardProgress{
                UserID:      userID,
                CurrentStep: stepID,
                StepData:    data,
                UpdatedAt:   time.Now(),
        }

        return s.configRepo.SaveWizardProgress(progress)
}</span>

func (s *ConfigurationService) GetWizardProgress(userID int) (*models.WizardProgress, error) <span class="cov0" title="0">{
        return s.configRepo.GetWizardProgress(userID)
}</span>

func (s *ConfigurationService) CompleteWizard(userID int, finalData map[string]interface{}) (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        // Generate the full configuration from wizard data
        config := s.generateConfiguration(finalData)

        // Validate the complete configuration
        if err := s.validateConfiguration(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        // Save configuration
        <span class="cov0" title="0">if err := s.SaveConfiguration(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save configuration: %w", err)
        }</span>

        // Mark wizard as completed
        <span class="cov0" title="0">if err := s.configRepo.MarkWizardCompleted(userID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to mark wizard as completed: %w", err)
        }</span>

        // Clean up wizard progress
        <span class="cov0" title="0">s.configRepo.DeleteWizardProgress(userID)

        return config, nil</span>
}

func (s *ConfigurationService) GetConfiguration() (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        if s.config == nil </span><span class="cov0" title="0">{
                return s.loadConfiguration()
        }</span>
        <span class="cov0" title="0">return s.config, nil</span>
}

func (s *ConfigurationService) SaveConfiguration(config *models.SystemConfiguration) error <span class="cov0" title="0">{
        // Validate configuration
        if err := s.validateConfiguration(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        // Save to database
        <span class="cov0" title="0">if err := s.configRepo.SaveConfiguration(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration to database: %w", err)
        }</span>

        // Save to file
        <span class="cov0" title="0">if err := s.saveConfigurationFile(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration file: %w", err)
        }</span>

        <span class="cov0" title="0">s.config = config
        return nil</span>
}

func (s *ConfigurationService) UpdateConfiguration(updates map[string]interface{}) (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        config, err := s.GetConfiguration()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Apply updates using reflection
        <span class="cov0" title="0">configValue := reflect.ValueOf(config).Elem()
        for key, value := range updates </span><span class="cov0" title="0">{
                field := configValue.FieldByName(s.toCamelCase(key))
                if field.IsValid() &amp;&amp; field.CanSet() </span><span class="cov0" title="0">{
                        newValue := reflect.ValueOf(value)
                        if newValue.Type().ConvertibleTo(field.Type()) </span><span class="cov0" title="0">{
                                field.Set(newValue.Convert(field.Type()))
                        }</span>
                }
        }

        <span class="cov0" title="0">return config, s.SaveConfiguration(config)</span>
}

func (s *ConfigurationService) ResetConfiguration() error <span class="cov0" title="0">{
        // Create default configuration
        config := s.createDefaultConfiguration()

        return s.SaveConfiguration(config)
}</span>

func (s *ConfigurationService) ExportConfiguration() ([]byte, error) <span class="cov0" title="0">{
        config, err := s.GetConfiguration()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return json.MarshalIndent(config, "", "  ")</span>
}

func (s *ConfigurationService) ImportConfiguration(data []byte) (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        var config models.SystemConfiguration
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse configuration: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.SaveConfiguration(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (s *ConfigurationService) GetConfigurationSchema() (*models.ConfigurationSchema, error) <span class="cov0" title="0">{
        return &amp;models.ConfigurationSchema{
                Version: "3.0.0",
                Sections: []*models.ConfigSection{
                        {
                                Name:        "Database",
                                Key:         "database",
                                Description: "Database configuration settings",
                                Fields:      s.getDatabaseFields(),
                        },
                        {
                                Name:        "Storage",
                                Key:         "storage",
                                Description: "Storage and file system settings",
                                Fields:      s.getStorageFields(),
                        },
                        {
                                Name:        "Network",
                                Key:         "network",
                                Description: "Network and API settings",
                                Fields:      s.getNetworkFields(),
                        },
                        {
                                Name:        "Authentication",
                                Key:         "authentication",
                                Description: "Authentication and security settings",
                                Fields:      s.getAuthenticationFields(),
                        },
                        {
                                Name:        "Features",
                                Key:         "features",
                                Description: "Feature toggles and advanced settings",
                                Fields:      s.getFeatureFields(),
                        },
                },
        }, nil
}</span>

func (s *ConfigurationService) TestConfiguration(config *models.SystemConfiguration) (*models.ConfigurationTest, error) <span class="cov0" title="0">{
        test := &amp;models.ConfigurationTest{
                TestedAt: time.Now(),
                Results:  make(map[string]*models.TestResult),
        }

        // Test database connection
        test.Results["database"] = s.testDatabaseConnection(config)

        // Test storage paths
        test.Results["storage"] = s.testStoragePaths(config)

        // Test network configuration
        test.Results["network"] = s.testNetworkConfiguration(config)

        // Test external services
        test.Results["external_services"] = s.testExternalServices(config)

        // Calculate overall status
        test.OverallStatus = "passed"
        for _, result := range test.Results </span><span class="cov0" title="0">{
                if result.Status == "failed" </span><span class="cov0" title="0">{
                        test.OverallStatus = "failed"
                        break</span>
                } else<span class="cov0" title="0"> if result.Status == "warning" &amp;&amp; test.OverallStatus == "passed" </span><span class="cov0" title="0">{
                        test.OverallStatus = "warning"
                }</span>
        }

        <span class="cov0" title="0">return test, nil</span>
}

// Helper methods

func (s *ConfigurationService) loadConfiguration() (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        // Try to load from database first
        config, err := s.configRepo.GetConfiguration()
        if err == nil </span><span class="cov0" title="0">{
                s.config = config
                return config, nil
        }</span>

        // Try to load from file
        <span class="cov0" title="0">if _, err := os.Stat(s.configPath); err == nil </span><span class="cov0" title="0">{
                config, err := s.loadConfigurationFile()
                if err == nil </span><span class="cov0" title="0">{
                        s.config = config
                        return config, nil
                }</span>
        }

        // Create default configuration
        <span class="cov0" title="0">config = s.createDefaultConfiguration()
        s.config = config
        return config, nil</span>
}

func (s *ConfigurationService) loadConfigurationFile() (*models.SystemConfiguration, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(s.configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var config models.SystemConfiguration
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (s *ConfigurationService) saveConfigurationFile(config *models.SystemConfiguration) error <span class="cov0" title="0">{
        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(s.configPath), 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(s.configPath, data, 0644)</span>
}

func (s *ConfigurationService) createDefaultConfiguration() *models.SystemConfiguration <span class="cov0" title="0">{
        return &amp;models.SystemConfiguration{
                Version:   "3.0.0",
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Database: &amp;models.DatabaseConfig{
                        Type: "sqlite",
                        Name: "catalogizer.db",
                },
                Storage: &amp;models.StorageConfig{
                        MediaDirectory:     "/var/lib/catalogizer/media",
                        ThumbnailDirectory: "/var/lib/catalogizer/thumbnails",
                        TempDirectory:      "/tmp/catalogizer",
                        MaxFileSize:        1000 * 1024 * 1024, // 1GB
                },
                Network: &amp;models.NetworkConfig{
                        Host: "0.0.0.0",
                        Port: 8080,
                        CORS: &amp;models.CORSConfig{
                                AllowedOrigins: []string{"*"},
                        },
                },
                Authentication: &amp;models.AuthenticationConfig{
                        SessionTimeout:           24 * time.Hour,
                        EnableRegistration:       true,
                        RequireEmailVerification: false,
                },
                Features: &amp;models.FeatureConfig{
                        MediaConversion: true,
                        ErrorReporting:  true,
                        LogManagement:   true,
                },
        }
}</span>

func (s *ConfigurationService) generateConfiguration(wizardData map[string]interface{}) *models.SystemConfiguration <span class="cov0" title="0">{
        config := s.createDefaultConfiguration()

        // Apply wizard data to configuration
        // This is a simplified implementation
        for key, value := range wizardData </span><span class="cov0" title="0">{
                switch key </span>{
                case "database_type":<span class="cov0" title="0">
                        config.Database.Type = value.(string)</span>
                case "database_host":<span class="cov0" title="0">
                        config.Database.Host = value.(string)</span>
                case "database_port":<span class="cov0" title="0">
                        if port, ok := value.(float64); ok </span><span class="cov0" title="0">{
                                config.Database.Port = int(port)
                        }</span>
                case "database_name":<span class="cov0" title="0">
                        config.Database.Name = value.(string)</span>
                case "database_username":<span class="cov0" title="0">
                        config.Database.Username = value.(string)</span>
                case "database_password":<span class="cov0" title="0">
                        config.Database.Password = value.(string)</span>
                case "media_directory":<span class="cov0" title="0">
                        config.Storage.MediaDirectory = value.(string)</span>
                case "thumbnail_directory":<span class="cov0" title="0">
                        config.Storage.ThumbnailDirectory = value.(string)</span>
                case "temp_directory":<span class="cov0" title="0">
                        config.Storage.TempDirectory = value.(string)</span>
                case "server_host":<span class="cov0" title="0">
                        config.Network.Host = value.(string)</span>
                case "server_port":<span class="cov0" title="0">
                        if port, ok := value.(float64); ok </span><span class="cov0" title="0">{
                                config.Network.Port = int(port)
                        }</span>
                case "enable_https":<span class="cov0" title="0">
                        config.Network.HTTPS = &amp;models.HTTPSConfig{
                                Enabled: value.(bool),
                        }</span>
                }
        }

        <span class="cov0" title="0">config.UpdatedAt = time.Now()
        return config</span>
}

func (s *ConfigurationService) validateConfiguration(config *models.SystemConfiguration) error <span class="cov0" title="0">{
        // Basic validation
        if config.Database == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database configuration is required")
        }</span>

        <span class="cov0" title="0">if config.Storage == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("storage configuration is required")
        }</span>

        <span class="cov0" title="0">if config.Network == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("network configuration is required")
        }</span>

        // Validate database configuration
        <span class="cov0" title="0">if config.Database.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database type is required")
        }</span>

        // Validate storage paths
        <span class="cov0" title="0">if config.Storage.MediaDirectory == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("media directory is required")
        }</span>

        // Validate network configuration
        <span class="cov0" title="0">if config.Network.Port &lt;= 0 || config.Network.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid network port: %d", config.Network.Port)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationService) isEmptyValue(value interface{}) bool <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return strings.TrimSpace(v) == ""</span>
        case []string:<span class="cov0" title="0">
                return len(v) == 0</span>
        case map[string]interface{}:<span class="cov0" title="0">
                return len(v) == 0</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (s *ConfigurationService) toCamelCase(str string) string <span class="cov0" title="0">{
        parts := strings.Split(str, "_")
        for i := range parts </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        parts[i] = strings.Title(parts[i])
                }</span>
        }
        <span class="cov0" title="0">return strings.Join(parts, "")</span>
}

func (s *ConfigurationService) getDatabaseFields() []*models.ConfigField <span class="cov0" title="0">{
        return []*models.ConfigField{
                {Name: "type", Label: "Database Type", Type: "select", Required: true},
                {Name: "host", Label: "Host", Type: "text", Required: false},
                {Name: "port", Label: "Port", Type: "number", Required: false},
                {Name: "name", Label: "Database Name", Type: "text", Required: true},
                {Name: "username", Label: "Username", Type: "text", Required: false},
                {Name: "password", Label: "Password", Type: "password", Required: false},
        }
}</span>

func (s *ConfigurationService) getStorageFields() []*models.ConfigField <span class="cov0" title="0">{
        return []*models.ConfigField{
                {Name: "media_directory", Label: "Media Directory", Type: "directory", Required: true},
                {Name: "thumbnail_directory", Label: "Thumbnail Directory", Type: "directory", Required: true},
                {Name: "temp_directory", Label: "Temporary Directory", Type: "directory", Required: true},
                {Name: "max_file_size", Label: "Max File Size (MB)", Type: "number", Required: true},
        }
}</span>

func (s *ConfigurationService) getNetworkFields() []*models.ConfigField <span class="cov0" title="0">{
        return []*models.ConfigField{
                {Name: "host", Label: "Host", Type: "text", Required: true},
                {Name: "port", Label: "Port", Type: "number", Required: true},
                {Name: "enable_https", Label: "Enable HTTPS", Type: "checkbox", Required: false},
        }
}</span>

func (s *ConfigurationService) getAuthenticationFields() []*models.ConfigField <span class="cov0" title="0">{
        return []*models.ConfigField{
                {Name: "jwt_secret", Label: "JWT Secret", Type: "password", Required: true},
                {Name: "session_timeout", Label: "Session Timeout (hours)", Type: "number", Required: true},
                {Name: "enable_registration", Label: "Enable Registration", Type: "checkbox", Required: false},
        }
}</span>

func (s *ConfigurationService) getFeatureFields() []*models.ConfigField <span class="cov0" title="0">{
        return []*models.ConfigField{
                {Name: "media_conversion", Label: "Media Conversion", Type: "checkbox", Required: false},
                {Name: "error_reporting", Label: "Error Reporting", Type: "checkbox", Required: false},
                {Name: "log_management", Label: "Log Management", Type: "checkbox", Required: false},
        }
}</span>

func (s *ConfigurationService) testDatabaseConnection(config *models.SystemConfiguration) *models.TestResult <span class="cov0" title="0">{
        // Simplified test implementation
        return &amp;models.TestResult{
                Status:  "passed",
                Message: "Database connection test passed",
        }
}</span>

func (s *ConfigurationService) testStoragePaths(config *models.SystemConfiguration) *models.TestResult <span class="cov0" title="0">{
        // Test if storage directories are accessible
        paths := []string{
                config.Storage.MediaDirectory,
                config.Storage.ThumbnailDirectory,
                config.Storage.TempDirectory,
        }

        for _, path := range paths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return &amp;models.TestResult{
                                Status:  "warning",
                                Message: fmt.Sprintf("Directory does not exist: %s", path),
                        }
                }</span>
        }

        <span class="cov0" title="0">return &amp;models.TestResult{
                Status:  "passed",
                Message: "All storage paths are accessible",
        }</span>
}

func (s *ConfigurationService) testNetworkConfiguration(config *models.SystemConfiguration) *models.TestResult <span class="cov0" title="0">{
        // Simplified network test
        if config.Network.Port &lt; 1024 &amp;&amp; os.Getuid() != 0 </span><span class="cov0" title="0">{
                return &amp;models.TestResult{
                        Status:  "warning",
                        Message: "Port below 1024 requires root privileges",
                }
        }</span>

        <span class="cov0" title="0">return &amp;models.TestResult{
                Status:  "passed",
                Message: "Network configuration is valid",
        }</span>
}

func (s *ConfigurationService) testExternalServices(config *models.SystemConfiguration) *models.TestResult <span class="cov0" title="0">{
        // Test external service connections
        return &amp;models.TestResult{
                Status:  "passed",
                Message: "External services test passed",
        }
}</span>

// Validator implementations

func (v *DatabaseValidator) Validate(value interface{}) error <span class="cov0" title="0">{
        // Database validation logic
        return nil
}</span>

func (v *NetworkValidator) Validate(value interface{}) error <span class="cov0" title="0">{
        // Network validation logic
        return nil
}</span>

func (v *PathValidator) Validate(value interface{}) error <span class="cov0" title="0">{
        // Path validation logic
        if path, ok := value.(string); ok </span><span class="cov0" title="0">{
                if !filepath.IsAbs(path) </span><span class="cov0" title="0">{
                        return fmt.Errorf("path must be absolute")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (v *EmailValidator) Validate(value interface{}) error <span class="cov0" title="0">{
        // Email validation logic
        if email, ok := value.(string); ok </span><span class="cov0" title="0">{
                if !strings.Contains(email, "@") </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid email format")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package services

import (
        "encoding/json"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type ConfigurationWizardService struct {
        repo            *repository.ConfigurationRepository
        configPath      string
        backupPath      string
        templatesPath   string
        currentSession  *models.WizardSession
        validationRules map[string]ValidationRule
        configTemplates map[string]ConfigTemplate
}

// models.WizardSession is defined in models package

type WizardStep struct {
        StepID          string                 `json:"step_id"`
        Title           string                 `json:"title"`
        Description     string                 `json:"description"`
        StepType        string                 `json:"step_type"` // input, select, multi-select, file-upload, test
        Fields          []FieldDefinition      `json:"fields"`
        Dependencies    []string               `json:"dependencies"`
        ValidationRules []string               `json:"validation_rules"`
        HelpText        string                 `json:"help_text"`
        IsOptional      bool                   `json:"is_optional"`
        SkipCondition   map[string]interface{} `json:"skip_condition,omitempty"`
}

type FieldDefinition struct {
        FieldID      string                 `json:"field_id"`
        Label        string                 `json:"label"`
        Type         string                 `json:"type"` // text, password, number, boolean, select, file, directory
        Required     bool                   `json:"required"`
        DefaultValue interface{}            `json:"default_value,omitempty"`
        Options      []FieldOption          `json:"options,omitempty"`
        Validation   string                 `json:"validation,omitempty"`
        HelpText     string                 `json:"help_text,omitempty"`
        Placeholder  string                 `json:"placeholder,omitempty"`
        MinValue     *float64               `json:"min_value,omitempty"`
        MaxValue     *float64               `json:"max_value,omitempty"`
        Pattern      string                 `json:"pattern,omitempty"`
        Dependencies map[string]interface{} `json:"dependencies,omitempty"`
}

type FieldOption struct {
        Value       string `json:"value"`
        Label       string `json:"label"`
        Description string `json:"description,omitempty"`
}

type ValidationRule struct {
        RuleID       string                 `json:"rule_id"`
        Type         string                 `json:"type"` // required, format, range, custom
        ErrorMessage string                 `json:"error_message"`
        Parameters   map[string]interface{} `json:"parameters,omitempty"`
}

type ConfigTemplate struct {
        TemplateID    string                 `json:"template_id"`
        Name          string                 `json:"name"`
        Description   string                 `json:"description"`
        Category      string                 `json:"category"`
        Steps         []WizardStep           `json:"steps"`
        DefaultValues map[string]interface{} `json:"default_values"`
        Requirements  []string               `json:"requirements"`
        PostInstall   []PostInstallAction    `json:"post_install_actions"`
}

type PostInstallAction struct {
        ActionType  string                 `json:"action_type"` // service_restart, file_create, command_run, validation
        Description string                 `json:"description"`
        Parameters  map[string]interface{} `json:"parameters"`
        Required    bool                   `json:"required"`
}

// ConfigurationProfile is defined in models package

type SystemInfo struct {
        OS              string            `json:"os"`
        Architecture    string            `json:"architecture"`
        GoVersion       string            `json:"go_version"`
        CPUCores        int               `json:"cpu_cores"`
        MemoryGB        float64           `json:"memory_gb"`
        DiskSpaceGB     float64           `json:"disk_space_gb"`
        NetworkInfo     NetworkInfo       `json:"network_info"`
        InstalledTools  []string          `json:"installed_tools"`
        EnvironmentVars map[string]string `json:"environment_vars"`
        Recommendations []string          `json:"recommendations"`
}

type NetworkInfo struct {
        Hostname    string   `json:"hostname"`
        IPAddresses []string `json:"ip_addresses"`
        DNSServers  []string `json:"dns_servers"`
        HasInternet bool     `json:"has_internet"`
}

type InstallationRequest struct {
        ConfigType     string                 `json:"config_type"`
        QuickInstall   bool                   `json:"quick_install"`
        CustomConfig   map[string]interface{} `json:"custom_config,omitempty"`
        SkipTests      bool                   `json:"skip_tests"`
        BackupExisting bool                   `json:"backup_existing"`
}

type InstallationProgress struct {
        SessionID      string    `json:"session_id"`
        CurrentAction  string    `json:"current_action"`
        Progress       float64   `json:"progress"`
        CompletedSteps []string  `json:"completed_steps"`
        FailedSteps    []string  `json:"failed_steps"`
        EstimatedTime  string    `json:"estimated_time"`
        LastUpdate     time.Time `json:"last_update"`
        IsCompleted    bool      `json:"is_completed"`
        HasErrors      bool      `json:"has_errors"`
        ErrorMessage   string    `json:"error_message,omitempty"`
}

func NewConfigurationWizardService(repo *repository.ConfigurationRepository) *ConfigurationWizardService <span class="cov0" title="0">{
        configPath := os.Getenv("CONFIG_PATH")
        if configPath == "" </span><span class="cov0" title="0">{
                configPath = "./config"
        }</span>

        <span class="cov0" title="0">service := &amp;ConfigurationWizardService{
                repo:            repo,
                configPath:      configPath,
                backupPath:      filepath.Join(configPath, "backups"),
                templatesPath:   filepath.Join(configPath, "templates"),
                validationRules: make(map[string]ValidationRule),
                configTemplates: make(map[string]ConfigTemplate),
        }

        // Initialize default templates and validation rules
        service.initializeDefaultTemplates()
        service.initializeValidationRules()

        // Ensure directories exist
        os.MkdirAll(service.configPath, 0755)
        os.MkdirAll(service.backupPath, 0755)
        os.MkdirAll(service.templatesPath, 0755)

        return service</span>
}

func (s *ConfigurationWizardService) initializeDefaultTemplates() <span class="cov0" title="0">{
        // Basic Installation Template
        s.configTemplates["basic"] = ConfigTemplate{
                TemplateID:  "basic",
                Name:        "Basic Installation",
                Description: "Quick setup for basic Catalogizer functionality",
                Category:    "installation",
                Steps: []WizardStep{
                        {
                                StepID:      "system_check",
                                Title:       "System Requirements Check",
                                Description: "Verify system meets minimum requirements",
                                StepType:    "test",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "auto_fix",
                                                Label:        "Automatically fix issues where possible",
                                                Type:         "boolean",
                                                DefaultValue: true,
                                        },
                                },
                        },
                        {
                                StepID:      "database_config",
                                Title:       "Database Configuration",
                                Description: "Configure database connection",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "db_type",
                                                Label:        "Database Type",
                                                Type:         "select",
                                                Required:     true,
                                                DefaultValue: "sqlite",
                                                Options: []FieldOption{
                                                        {Value: "sqlite", Label: "SQLite (Recommended)"},
                                                        {Value: "mysql", Label: "MySQL"},
                                                        {Value: "postgresql", Label: "PostgreSQL"},
                                                },
                                        },
                                        {
                                                FieldID:      "db_path",
                                                Label:        "Database File Path",
                                                Type:         "file",
                                                Required:     true,
                                                DefaultValue: "./catalogizer.db",
                                                Dependencies: map[string]interface{}{
                                                        "db_type": "sqlite",
                                                },
                                        },
                                        {
                                                FieldID:  "db_host",
                                                Label:    "Database Host",
                                                Type:     "text",
                                                Required: true,
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                        {
                                                FieldID:  "db_port",
                                                Label:    "Database Port",
                                                Type:     "number",
                                                MinValue: float64Ptr(1),
                                                MaxValue: float64Ptr(65535),
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                        {
                                                FieldID:  "db_name",
                                                Label:    "Database Name",
                                                Type:     "text",
                                                Required: true,
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                        {
                                                FieldID:  "db_username",
                                                Label:    "Database Username",
                                                Type:     "text",
                                                Required: true,
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                        {
                                                FieldID:  "db_password",
                                                Label:    "Database Password",
                                                Type:     "password",
                                                Required: true,
                                                Dependencies: map[string]interface{}{
                                                        "db_type": []string{"mysql", "postgresql"},
                                                },
                                        },
                                },
                        },
                        {
                                StepID:      "media_storage",
                                Title:       "Media Storage Configuration",
                                Description: "Configure where media files will be stored",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "storage_type",
                                                Label:        "Storage Type",
                                                Type:         "select",
                                                Required:     true,
                                                DefaultValue: "local",
                                                Options: []FieldOption{
                                                        {Value: "local", Label: "Local Storage"},
                                                        {Value: "s3", Label: "Amazon S3"},
                                                        {Value: "webdav", Label: "WebDAV"},
                                                        {Value: "ftp", Label: "FTP/SFTP"},
                                                },
                                        },
                                        {
                                                FieldID:      "media_path",
                                                Label:        "Media Directory Path",
                                                Type:         "directory",
                                                Required:     true,
                                                DefaultValue: "./media",
                                                Dependencies: map[string]interface{}{
                                                        "storage_type": "local",
                                                },
                                        },
                                        {
                                                FieldID:      "max_file_size",
                                                Label:        "Maximum File Size (MB)",
                                                Type:         "number",
                                                Required:     true,
                                                DefaultValue: 100,
                                                MinValue:     float64Ptr(1),
                                                MaxValue:     float64Ptr(10000),
                                        },
                                },
                        },
                        {
                                StepID:      "security_config",
                                Title:       "Security Configuration",
                                Description: "Configure authentication and security settings",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:    "jwt_secret",
                                                Label:      "JWT Secret Key",
                                                Type:       "password",
                                                Required:   true,
                                                HelpText:   "Secret key for JWT token generation (minimum 32 characters)",
                                                Validation: "min_length:32",
                                        },
                                        {
                                                FieldID:      "session_timeout",
                                                Label:        "Session Timeout (hours)",
                                                Type:         "number",
                                                Required:     true,
                                                DefaultValue: 24,
                                                MinValue:     float64Ptr(1),
                                                MaxValue:     float64Ptr(720),
                                        },
                                        {
                                                FieldID:      "enable_2fa",
                                                Label:        "Enable Two-Factor Authentication",
                                                Type:         "boolean",
                                                DefaultValue: false,
                                        },
                                        {
                                                FieldID:      "password_min_length",
                                                Label:        "Minimum Password Length",
                                                Type:         "number",
                                                Required:     true,
                                                DefaultValue: 8,
                                                MinValue:     float64Ptr(6),
                                                MaxValue:     float64Ptr(128),
                                        },
                                },
                        },
                        {
                                StepID:      "admin_user",
                                Title:       "Administrator Account",
                                Description: "Create the initial administrator account",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:     "admin_username",
                                                Label:       "Administrator Username",
                                                Type:        "text",
                                                Required:    true,
                                                Validation:  "username",
                                                Placeholder: "admin",
                                        },
                                        {
                                                FieldID:     "admin_email",
                                                Label:       "Administrator Email",
                                                Type:        "text",
                                                Required:    true,
                                                Validation:  "email",
                                                Placeholder: "admin@example.com",
                                        },
                                        {
                                                FieldID:    "admin_password",
                                                Label:      "Administrator Password",
                                                Type:       "password",
                                                Required:   true,
                                                Validation: "password_strength",
                                        },
                                        {
                                                FieldID:    "admin_password_confirm",
                                                Label:      "Confirm Password",
                                                Type:       "password",
                                                Required:   true,
                                                Validation: "password_match",
                                        },
                                },
                        },
                        {
                                StepID:      "service_config",
                                Title:       "Service Configuration",
                                Description: "Configure server and service settings",
                                StepType:    "input",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "server_port",
                                                Label:        "Server Port",
                                                Type:         "number",
                                                Required:     true,
                                                DefaultValue: 8080,
                                                MinValue:     float64Ptr(1024),
                                                MaxValue:     float64Ptr(65535),
                                        },
                                        {
                                                FieldID:      "log_level",
                                                Label:        "Log Level",
                                                Type:         "select",
                                                Required:     true,
                                                DefaultValue: "info",
                                                Options: []FieldOption{
                                                        {Value: "debug", Label: "Debug"},
                                                        {Value: "info", Label: "Info"},
                                                        {Value: "warn", Label: "Warning"},
                                                        {Value: "error", Label: "Error"},
                                                },
                                        },
                                        {
                                                FieldID:      "enable_cors",
                                                Label:        "Enable CORS",
                                                Type:         "boolean",
                                                DefaultValue: true,
                                                HelpText:     "Enable Cross-Origin Resource Sharing for web clients",
                                        },
                                        {
                                                FieldID:      "backup_enabled",
                                                Label:        "Enable Automatic Backups",
                                                Type:         "boolean",
                                                DefaultValue: true,
                                        },
                                },
                        },
                        {
                                StepID:      "final_test",
                                Title:       "Final Configuration Test",
                                Description: "Test all configurations and start services",
                                StepType:    "test",
                                Fields: []FieldDefinition{
                                        {
                                                FieldID:      "start_services",
                                                Label:        "Start services after successful test",
                                                Type:         "boolean",
                                                DefaultValue: true,
                                        },
                                },
                        },
                },
                DefaultValues: map[string]interface{}{
                        "db_type":         "sqlite",
                        "storage_type":    "local",
                        "session_timeout": 24,
                        "server_port":     8080,
                        "log_level":       "info",
                },
                Requirements: []string{"go", "sqlite3"},
                PostInstall: []PostInstallAction{
                        {
                                ActionType:  "file_create",
                                Description: "Create configuration file",
                                Parameters: map[string]interface{}{
                                        "file_path": "./config/config.json",
                                        "template":  "config_template.json",
                                },
                                Required: true,
                        },
                        {
                                ActionType:  "service_restart",
                                Description: "Restart Catalogizer service",
                                Parameters: map[string]interface{}{
                                        "service_name": "catalogizer",
                                },
                                Required: false,
                        },
                },
        }

        // Enterprise Installation Template
        s.configTemplates["enterprise"] = ConfigTemplate{
                TemplateID:   "enterprise",
                Name:         "Enterprise Installation",
                Description:  "Full enterprise setup with all features enabled",
                Category:     "installation",
                Steps:        s.getEnterpriseSteps(),
                Requirements: []string{"go", "docker", "postgresql", "redis"},
        }

        // Development Template
        s.configTemplates["development"] = ConfigTemplate{
                TemplateID:   "development",
                Name:         "Development Environment",
                Description:  "Development setup with debugging and testing tools",
                Category:     "development",
                Steps:        s.getDevelopmentSteps(),
                Requirements: []string{"go", "git", "make"},
        }
}</span>

func (s *ConfigurationWizardService) getEnterpriseSteps() []WizardStep <span class="cov0" title="0">{
        // Return enterprise-specific configuration steps
        steps := []WizardStep{
                {
                        StepID:      "infrastructure",
                        Title:       "Infrastructure Setup",
                        Description: "Configure enterprise infrastructure components",
                        StepType:    "input",
                        Fields: []FieldDefinition{
                                {
                                        FieldID:  "deployment_type",
                                        Label:    "Deployment Type",
                                        Type:     "select",
                                        Required: true,
                                        Options: []FieldOption{
                                                {Value: "kubernetes", Label: "Kubernetes Cluster"},
                                                {Value: "docker_swarm", Label: "Docker Swarm"},
                                                {Value: "standalone", Label: "Standalone Servers"},
                                        },
                                },
                                {
                                        FieldID:  "load_balancer",
                                        Label:    "Load Balancer Configuration",
                                        Type:     "select",
                                        Required: true,
                                        Options: []FieldOption{
                                                {Value: "nginx", Label: "Nginx"},
                                                {Value: "haproxy", Label: "HAProxy"},
                                                {Value: "aws_alb", Label: "AWS Application Load Balancer"},
                                        },
                                },
                        },
                },
                // Add more enterprise-specific steps...
        }
        return steps
}</span>

func (s *ConfigurationWizardService) getDevelopmentSteps() []WizardStep <span class="cov0" title="0">{
        // Return development-specific configuration steps
        steps := []WizardStep{
                {
                        StepID:      "dev_environment",
                        Title:       "Development Environment",
                        Description: "Configure development tools and settings",
                        StepType:    "input",
                        Fields: []FieldDefinition{
                                {
                                        FieldID:      "debug_mode",
                                        Label:        "Enable Debug Mode",
                                        Type:         "boolean",
                                        DefaultValue: true,
                                },
                                {
                                        FieldID:      "hot_reload",
                                        Label:        "Enable Hot Reload",
                                        Type:         "boolean",
                                        DefaultValue: true,
                                },
                        },
                },
                // Add more development-specific steps...
        }
        return steps
}</span>

func (s *ConfigurationWizardService) initializeValidationRules() <span class="cov0" title="0">{
        s.validationRules["required"] = ValidationRule{
                RuleID:       "required",
                Type:         "required",
                ErrorMessage: "This field is required",
        }

        s.validationRules["email"] = ValidationRule{
                RuleID:       "email",
                Type:         "format",
                ErrorMessage: "Please enter a valid email address",
                Parameters: map[string]interface{}{
                        "pattern": `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`,
                },
        }

        s.validationRules["username"] = ValidationRule{
                RuleID:       "username",
                Type:         "format",
                ErrorMessage: "Username can only contain letters, numbers, and underscores (3-30 characters)",
                Parameters: map[string]interface{}{
                        "pattern": `^[a-zA-Z0-9_]{3,30}$`,
                },
        }

        s.validationRules["password_strength"] = ValidationRule{
                RuleID:       "password_strength",
                Type:         "custom",
                ErrorMessage: "Password must be at least 8 characters with uppercase, lowercase, number, and special character",
                Parameters: map[string]interface{}{
                        "min_length":      8,
                        "require_upper":   true,
                        "require_lower":   true,
                        "require_number":  true,
                        "require_special": true,
                },
        }

        s.validationRules["password_match"] = ValidationRule{
                RuleID:       "password_match",
                Type:         "custom",
                ErrorMessage: "Passwords do not match",
                Parameters: map[string]interface{}{
                        "match_field": "admin_password",
                },
        }

        s.validationRules["min_length"] = ValidationRule{
                RuleID:       "min_length",
                Type:         "format",
                ErrorMessage: "Must be at least {min} characters long",
        }
}</span>

func (s *ConfigurationWizardService) StartWizard(userID int, configType string, quickInstall bool) (*models.WizardSession, error) <span class="cov0" title="0">{
        template, exists := s.configTemplates[configType]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration template '%s' not found", configType)
        }</span>

        <span class="cov0" title="0">sessionID := fmt.Sprintf("wizard-%d-%d", userID, time.Now().Unix())

        session := &amp;models.WizardSession{
                SessionID:     sessionID,
                UserID:        userID,
                CurrentStep:   0,
                TotalSteps:    len(template.Steps),
                StepData:      make(map[string]interface{}),
                Configuration: make(map[string]interface{}),
                StartedAt:     time.Now(),
                LastActivity:  time.Now(),
                IsCompleted:   false,
                ConfigType:    configType,
        }

        // Apply default values
        for key, value := range template.DefaultValues </span><span class="cov0" title="0">{
                session.Configuration[key] = value
        }</span>

        // Quick install logic
        <span class="cov0" title="0">if quickInstall </span><span class="cov0" title="0">{
                session.Configuration["quick_install"] = true
                // Skip optional steps and use defaults
        }</span>

        <span class="cov0" title="0">s.currentSession = session

        // Save session to database
        if err := s.repo.SaveWizardSession(session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save wizard session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (s *ConfigurationWizardService) GetCurrentStep(sessionID string) (*WizardStep, error) <span class="cov0" title="0">{
        session, err := s.getSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">template := s.configTemplates[session.ConfigType]
        if session.CurrentStep &gt;= len(template.Steps) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wizard completed")
        }</span>

        <span class="cov0" title="0">step := template.Steps[session.CurrentStep]

        // Check if step should be skipped
        if s.shouldSkipStep(step, session.Configuration) </span><span class="cov0" title="0">{
                // Move to next step
                session.CurrentStep++
                s.repo.SaveWizardSession(session)
                return s.GetCurrentStep(sessionID)
        }</span>

        <span class="cov0" title="0">return &amp;step, nil</span>
}

func (s *ConfigurationWizardService) shouldSkipStep(step WizardStep, config map[string]interface{}) bool <span class="cov0" title="0">{
        if step.SkipCondition == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for key, expectedValue := range step.SkipCondition </span><span class="cov0" title="0">{
                if configValue, exists := config[key]; exists </span><span class="cov0" title="0">{
                        if configValue != expectedValue </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

func (s *ConfigurationWizardService) SubmitStepData(sessionID string, stepData map[string]interface{}) error <span class="cov0" title="0">{
        session, err := s.getSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">template := s.configTemplates[session.ConfigType]
        if session.CurrentStep &gt;= len(template.Steps) </span><span class="cov0" title="0">{
                return fmt.Errorf("wizard already completed")
        }</span>

        <span class="cov0" title="0">currentStep := template.Steps[session.CurrentStep]

        // Validate step data
        if err := s.validateStepData(currentStep, stepData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        // Process step based on type
        <span class="cov0" title="0">switch currentStep.StepType </span>{
        case "test":<span class="cov0" title="0">
                if err := s.processTestStep(currentStep, stepData, session); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("test step failed: %w", err)
                }</span>
        case "input", "select", "multi-select":<span class="cov0" title="0">
                // Store the input data
                for key, value := range stepData </span><span class="cov0" title="0">{
                        session.Configuration[key] = value
                }</span>
        }

        // Store step data
        <span class="cov0" title="0">session.StepData[currentStep.StepID] = stepData
        session.LastActivity = time.Now()

        // Move to next step
        session.CurrentStep++

        // Check if wizard is completed
        if session.CurrentStep &gt;= len(template.Steps) </span><span class="cov0" title="0">{
                session.IsCompleted = true
                if err := s.finalizeConfiguration(session); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to finalize configuration: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return s.repo.SaveWizardSession(session)</span>
}

func (s *ConfigurationWizardService) validateStepData(step WizardStep, data map[string]interface{}) error <span class="cov0" title="0">{
        for _, field := range step.Fields </span><span class="cov0" title="0">{
                value, exists := data[field.FieldID]

                // Check required fields
                if field.Required &amp;&amp; (!exists || value == nil || value == "") </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s' is required", field.FieldID)
                }</span>

                <span class="cov0" title="0">if !exists || value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Type validation
                <span class="cov0" title="0">if err := s.validateFieldType(field, value); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("field '%s': %w", field.FieldID, err)
                }</span>

                // Custom validation
                <span class="cov0" title="0">if field.Validation != "" </span><span class="cov0" title="0">{
                        if err := s.validateFieldRule(field.Validation, value, data); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("field '%s': %w", field.FieldID, err)
                        }</span>
                }

                // Range validation for numbers
                <span class="cov0" title="0">if field.Type == "number" </span><span class="cov0" title="0">{
                        if numValue, ok := value.(float64); ok </span><span class="cov0" title="0">{
                                if field.MinValue != nil &amp;&amp; numValue &lt; *field.MinValue </span><span class="cov0" title="0">{
                                        return fmt.Errorf("field '%s': value must be at least %v", field.FieldID, *field.MinValue)
                                }</span>
                                <span class="cov0" title="0">if field.MaxValue != nil &amp;&amp; numValue &gt; *field.MaxValue </span><span class="cov0" title="0">{
                                        return fmt.Errorf("field '%s': value must be at most %v", field.FieldID, *field.MaxValue)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) validateFieldType(field FieldDefinition, value interface{}) error <span class="cov0" title="0">{
        switch field.Type </span>{
        case "text", "password":<span class="cov0" title="0">
                if _, ok := value.(string); !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected string value")
                }</span>
        case "number":<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case float64, int, int64:<span class="cov0" title="0"></span>
                        // Valid number types
                case string:<span class="cov0" title="0">
                        if _, err := strconv.ParseFloat(v, 64); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid number format")
                        }</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("expected number value")</span>
                }
        case "boolean":<span class="cov0" title="0">
                if _, ok := value.(bool); !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected boolean value")
                }</span>
        case "file", "directory":<span class="cov0" title="0">
                if strValue, ok := value.(string); ok </span><span class="cov0" title="0">{
                        if field.Type == "directory" </span><span class="cov0" title="0">{
                                if _, err := os.Stat(strValue); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("directory does not exist: %s", strValue)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("expected string path")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) validateFieldRule(ruleName string, value interface{}, allData map[string]interface{}) error <span class="cov0" title="0">{
        rule, exists := s.validationRules[ruleName]
        if !exists </span><span class="cov0" title="0">{
                // Handle inline rules like "min_length:32"
                if strings.Contains(ruleName, ":") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(ruleName, ":", 2)
                        ruleType, param := parts[0], parts[1]

                        switch ruleType </span>{
                        case "min_length":<span class="cov0" title="0">
                                if strValue, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        if minLen, err := strconv.Atoi(param); err == nil </span><span class="cov0" title="0">{
                                                if len(strValue) &lt; minLen </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("must be at least %d characters long", minLen)
                                                }</span>
                                        }
                                }
                        }
                }
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">switch rule.Type </span>{
        case "format":<span class="cov0" title="0">
                if pattern, ok := rule.Parameters["pattern"].(string); ok </span><span class="cov0" title="0">{
                        if strValue, ok := value.(string); ok </span><span class="cov0" title="0">{
                                matched, err := filepath.Match(pattern, strValue)
                                if err != nil || !matched </span><span class="cov0" title="0">{
                                        return errors.New(rule.ErrorMessage)
                                }</span>
                        }
                }
        case "custom":<span class="cov0" title="0">
                return s.validateCustomRule(rule, value, allData)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) validateCustomRule(rule ValidationRule, value interface{}, allData map[string]interface{}) error <span class="cov0" title="0">{
        switch rule.RuleID </span>{
        case "password_strength":<span class="cov0" title="0">
                if strValue, ok := value.(string); ok </span><span class="cov0" title="0">{
                        if len(strValue) &lt; 8 </span><span class="cov0" title="0">{
                                return fmt.Errorf("password must be at least 8 characters")
                        }</span>
                        // Add more password strength checks
                }
        case "password_match":<span class="cov0" title="0">
                if matchField, ok := rule.Parameters["match_field"].(string); ok </span><span class="cov0" title="0">{
                        if otherValue, exists := allData[matchField]; exists </span><span class="cov0" title="0">{
                                if value != otherValue </span><span class="cov0" title="0">{
                                        return fmt.Errorf("passwords do not match")
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) processTestStep(step WizardStep, data map[string]interface{}, session *models.WizardSession) error <span class="cov0" title="0">{
        switch step.StepID </span>{
        case "system_check":<span class="cov0" title="0">
                return s.performSystemCheck(data, session)</span>
        case "final_test":<span class="cov0" title="0">
                return s.performFinalTest(data, session)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown test step: %s", step.StepID)</span>
        }
}

func (s *ConfigurationWizardService) performSystemCheck(data map[string]interface{}, session *models.WizardSession) error <span class="cov0" title="0">{
        systemInfo := s.collectSystemInfo()

        // Check minimum requirements
        var issues []string

        // Check Go version
        if !strings.HasPrefix(systemInfo.GoVersion, "go1.") </span><span class="cov0" title="0">{
                issues = append(issues, "Go is not installed or not in PATH")
        }</span>

        // Check available memory (minimum 1GB)
        <span class="cov0" title="0">if systemInfo.MemoryGB &lt; 1.0 </span><span class="cov0" title="0">{
                issues = append(issues, "Insufficient memory (minimum 1GB required)")
        }</span>

        // Check available disk space (minimum 5GB)
        <span class="cov0" title="0">if systemInfo.DiskSpaceGB &lt; 5.0 </span><span class="cov0" title="0">{
                issues = append(issues, "Insufficient disk space (minimum 5GB required)")
        }</span>

        // Store system info in session
        <span class="cov0" title="0">session.Configuration["system_info"] = systemInfo

        if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                autoFix, _ := data["auto_fix"].(bool)
                if autoFix </span><span class="cov0" title="0">{
                        log.Printf("Auto-fixing system issues: %v", issues)
                        // Attempt to fix issues automatically
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("system check failed: %v", issues)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) performFinalTest(data map[string]interface{}, session *models.WizardSession) error <span class="cov0" title="0">{
        // Test database connection
        if err := s.testDatabaseConnection(session.Configuration); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database connection test failed: %w", err)
        }</span>

        // Test media storage
        <span class="cov0" title="0">if err := s.testMediaStorage(session.Configuration); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("media storage test failed: %w", err)
        }</span>

        // Test service configuration
        <span class="cov0" title="0">if err := s.testServiceConfiguration(session.Configuration); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("service configuration test failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) testDatabaseConnection(config map[string]interface{}) error <span class="cov0" title="0">{
        dbType, _ := config["db_type"].(string)

        switch dbType </span>{
        case "sqlite":<span class="cov0" title="0">
                dbPath, _ := config["db_path"].(string)
                if dbPath == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("database path not specified")
                }</span>
                // Test SQLite connection
                <span class="cov0" title="0">return s.testSQLiteConnection(dbPath)</span>
        case "mysql", "postgresql":<span class="cov0" title="0">
                // Test network database connection
                return s.testNetworkDatabaseConnection(config)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported database type: %s", dbType)</span>
        }
}

func (s *ConfigurationWizardService) testSQLiteConnection(dbPath string) error <span class="cov0" title="0">{
        // Ensure directory exists
        dir := filepath.Dir(dbPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create database directory: %w", err)
        }</span>

        // Test write access
        <span class="cov0" title="0">testFile := filepath.Join(dir, "test.tmp")
        if err := ioutil.WriteFile(testFile, []byte("test"), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no write access to database directory: %w", err)
        }</span>
        <span class="cov0" title="0">os.Remove(testFile)

        return nil</span>
}

func (s *ConfigurationWizardService) testNetworkDatabaseConnection(config map[string]interface{}) error <span class="cov0" title="0">{
        // This would contain actual database connection testing logic
        // For now, just validate required fields are present
        requiredFields := []string{"db_host", "db_port", "db_name", "db_username", "db_password"}
        for _, field := range requiredFields </span><span class="cov0" title="0">{
                if _, exists := config[field]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required database field: %s", field)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) testMediaStorage(config map[string]interface{}) error <span class="cov0" title="0">{
        storageType, _ := config["storage_type"].(string)

        switch storageType </span>{
        case "local":<span class="cov0" title="0">
                mediaPath, _ := config["media_path"].(string)
                if mediaPath == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("media path not specified")
                }</span>

                // Ensure directory exists
                <span class="cov0" title="0">if err := os.MkdirAll(mediaPath, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create media directory: %w", err)
                }</span>

                // Test write access
                <span class="cov0" title="0">testFile := filepath.Join(mediaPath, "test.tmp")
                if err := ioutil.WriteFile(testFile, []byte("test"), 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("no write access to media directory: %w", err)
                }</span>
                <span class="cov0" title="0">os.Remove(testFile)</span>

        default:<span class="cov0" title="0">
                // For other storage types, would implement specific tests
                log.Printf("Storage type %s test not implemented", storageType)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) testServiceConfiguration(config map[string]interface{}) error <span class="cov0" title="0">{
        // Test port availability
        if port, ok := config["server_port"].(float64); ok </span><span class="cov0" title="0">{
                // Would test if port is available
                if port &lt; 1024 || port &gt; 65535 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid port number: %v", port)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) finalizeConfiguration(session *models.WizardSession) error <span class="cov0" title="0">{
        // Generate final configuration file
        configData := map[string]interface{}{
                "version":       "3.0.0",
                "generated_at":  time.Now(),
                "generated_by":  "configuration_wizard",
                "user_id":       session.UserID,
                "configuration": session.Configuration,
        }

        // Write configuration file
        configFile := filepath.Join(s.configPath, "config.json")
        if err := s.writeConfigFile(configFile, configData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write configuration file: %w", err)
        }</span>

        // Execute post-install actions
        <span class="cov0" title="0">template := s.configTemplates[session.ConfigType]
        for _, action := range template.PostInstall </span><span class="cov0" title="0">{
                if err := s.executePostInstallAction(action, session); err != nil </span><span class="cov0" title="0">{
                        if action.Required </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to execute required post-install action: %w", err)
                        }</span>
                        <span class="cov0" title="0">log.Printf("Optional post-install action failed: %v", err)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ConfigurationWizardService) writeConfigFile(filename string, data map[string]interface{}) error <span class="cov0" title="0">{
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ioutil.WriteFile(filename, jsonData, 0644)</span>
}

func (s *ConfigurationWizardService) executePostInstallAction(action PostInstallAction, session *models.WizardSession) error <span class="cov0" title="0">{
        switch action.ActionType </span>{
        case "file_create":<span class="cov0" title="0">
                return s.createConfigurationFile(action.Parameters, session)</span>
        case "service_restart":<span class="cov0" title="0">
                return s.restartService(action.Parameters)</span>
        case "command_run":<span class="cov0" title="0">
                return s.runCommand(action.Parameters)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown post-install action: %s", action.ActionType)</span>
        }
}

func (s *ConfigurationWizardService) createConfigurationFile(params map[string]interface{}, session *models.WizardSession) error <span class="cov0" title="0">{
        filePath, _ := params["file_path"].(string)
        template, _ := params["template"].(string)

        if filePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("file_path parameter required")
        }</span>

        // Create directory if needed
        <span class="cov0" title="0">dir := filepath.Dir(filePath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Use template if specified, otherwise use session configuration
        <span class="cov0" title="0">var data interface{}
        if template != "" </span><span class="cov0" title="0">{
                // Load template and merge with configuration
                data = session.Configuration
        }</span> else<span class="cov0" title="0"> {
                data = session.Configuration
        }</span>

        <span class="cov0" title="0">return s.writeConfigFile(filePath, map[string]interface{}{"config": data})</span>
}

func (s *ConfigurationWizardService) restartService(params map[string]interface{}) error <span class="cov0" title="0">{
        serviceName, _ := params["service_name"].(string)
        if serviceName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("service_name parameter required")
        }</span>

        // This would contain actual service restart logic
        <span class="cov0" title="0">log.Printf("Would restart service: %s", serviceName)
        return nil</span>
}

func (s *ConfigurationWizardService) runCommand(params map[string]interface{}) error <span class="cov0" title="0">{
        command, _ := params["command"].(string)
        if command == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("command parameter required")
        }</span>

        // This would contain actual command execution logic
        <span class="cov0" title="0">log.Printf("Would run command: %s", command)
        return nil</span>
}

func (s *ConfigurationWizardService) collectSystemInfo() SystemInfo <span class="cov0" title="0">{
        info := SystemInfo{
                OS:           runtime.GOOS,
                Architecture: runtime.GOARCH,
                GoVersion:    runtime.Version(),
                CPUCores:     runtime.NumCPU(),
        }

        // Get memory info
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        info.MemoryGB = float64(m.Sys) / (1024 * 1024 * 1024)

        // Get hostname
        if hostname, err := os.Hostname(); err == nil </span><span class="cov0" title="0">{
                info.NetworkInfo.Hostname = hostname
        }</span>

        // Detect installed tools
        <span class="cov0" title="0">info.InstalledTools = s.detectInstalledTools()

        // Get environment variables
        info.EnvironmentVars = make(map[string]string)
        for _, env := range os.Environ() </span><span class="cov0" title="0">{
                parts := strings.SplitN(env, "=", 2)
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        // Only include non-sensitive environment variables
                        key := parts[0]
                        if !strings.Contains(strings.ToLower(key), "password") &amp;&amp;
                                !strings.Contains(strings.ToLower(key), "secret") &amp;&amp;
                                !strings.Contains(strings.ToLower(key), "token") </span><span class="cov0" title="0">{
                                info.EnvironmentVars[key] = parts[1]
                        }</span>
                }
        }

        // Generate recommendations
        <span class="cov0" title="0">info.Recommendations = s.generateSystemRecommendations(info)

        return info</span>
}

func (s *ConfigurationWizardService) detectInstalledTools() []string <span class="cov0" title="0">{
        var tools []string

        toolsToCheck := []string{"go", "git", "docker", "make", "npm", "node", "python", "sqlite3"}

        for _, tool := range toolsToCheck </span><span class="cov0" title="0">{
                // This would check if tool is installed
                // For now, just assume go is installed since we're running
                if tool == "go" </span><span class="cov0" title="0">{
                        tools = append(tools, tool)
                }</span>
        }

        <span class="cov0" title="0">return tools</span>
}

func (s *ConfigurationWizardService) generateSystemRecommendations(info SystemInfo) []string <span class="cov0" title="0">{
        var recommendations []string

        if info.MemoryGB &lt; 2.0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Consider upgrading system memory to at least 2GB for better performance")
        }</span>

        <span class="cov0" title="0">if info.CPUCores &lt; 2 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Consider using a multi-core processor for better concurrency")
        }</span>

        <span class="cov0" title="0">if info.OS == "windows" </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Consider using WSL2 for better compatibility with Unix-based tools")
        }</span>

        <span class="cov0" title="0">if len(info.InstalledTools) &lt; 3 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Install additional development tools like Git and Docker for full functionality")
        }</span>

        <span class="cov0" title="0">return recommendations</span>
}

func (s *ConfigurationWizardService) getSession(sessionID string) (*models.WizardSession, error) <span class="cov0" title="0">{
        if s.currentSession != nil &amp;&amp; s.currentSession.SessionID == sessionID </span><span class="cov0" title="0">{
                return s.currentSession, nil
        }</span>

        // Load from database
        <span class="cov0" title="0">session, err := s.repo.GetWizardSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session not found: %w", err)
        }</span>

        <span class="cov0" title="0">s.currentSession = session
        return session, nil</span>
}

func (s *ConfigurationWizardService) GetAvailableTemplates() []ConfigTemplate <span class="cov0" title="0">{
        var templates []ConfigTemplate
        for _, template := range s.configTemplates </span><span class="cov0" title="0">{
                templates = append(templates, template)
        }</span>
        <span class="cov0" title="0">return templates</span>
}

func (s *ConfigurationWizardService) GetWizardProgress(sessionID string) (*InstallationProgress, error) <span class="cov0" title="0">{
        session, err := s.getSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">progress := float64(session.CurrentStep) / float64(session.TotalSteps) * 100

        return &amp;InstallationProgress{
                SessionID:      sessionID,
                CurrentAction:  fmt.Sprintf("Step %d of %d", session.CurrentStep+1, session.TotalSteps),
                Progress:       progress,
                CompletedSteps: s.getCompletedSteps(session),
                LastUpdate:     session.LastActivity,
                IsCompleted:    session.IsCompleted,
        }, nil</span>
}

func (s *ConfigurationWizardService) getCompletedSteps(session *models.WizardSession) []string <span class="cov0" title="0">{
        var completed []string
        template := s.configTemplates[session.ConfigType]

        for i := 0; i &lt; session.CurrentStep &amp;&amp; i &lt; len(template.Steps); i++ </span><span class="cov0" title="0">{
                completed = append(completed, template.Steps[i].Title)
        }</span>

        <span class="cov0" title="0">return completed</span>
}

func (s *ConfigurationWizardService) SaveConfigurationProfile(userID int, profile *models.ConfigurationProfile) error <span class="cov0" title="0">{
        profile.UserID = userID
        profile.CreatedAt = time.Now()
        profile.UpdatedAt = time.Now()

        return s.repo.SaveConfigurationProfile(profile)
}</span>

func (s *ConfigurationWizardService) LoadConfigurationProfile(userID int, profileID string) (*models.ConfigurationProfile, error) <span class="cov0" title="0">{
        return s.repo.GetConfigurationProfile(profileID)
}</span>

func (s *ConfigurationWizardService) GetUserConfigurationProfiles(userID int) ([]*models.ConfigurationProfile, error) <span class="cov0" title="0">{
        return s.repo.GetUserConfigurationProfiles(userID)
}</span>

func float64Ptr(f float64) *float64 <span class="cov0" title="0">{
        return &amp;f
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package services

import (
        "encoding/json"
        "fmt"
        "image/jpeg"
        "image/png"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "catalogizer/internal/auth"
        "catalogizer/models"
        "catalogizer/repository"

        "github.com/gen2brain/go-fitz"
        "github.com/ledongthuc/pdf"
)

type ConversionService struct {
        conversionRepo *repository.ConversionRepository
        userRepo       *repository.UserRepository
        authService    *AuthService
}

func NewConversionService(conversionRepo *repository.ConversionRepository, userRepo *repository.UserRepository, authService *AuthService) *ConversionService <span class="cov0" title="0">{
        return &amp;ConversionService{
                conversionRepo: conversionRepo,
                userRepo:       userRepo,
                authService:    authService,
        }
}</span>

func (s *ConversionService) CreateConversionJob(userID int, request *models.ConversionRequest) (*models.ConversionJob, error) <span class="cov0" title="0">{
        if !s.validateConversionRequest(request) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid conversion request")
        }</span>

        <span class="cov0" title="0">job := &amp;models.ConversionJob{
                UserID:         userID,
                SourcePath:     request.SourcePath,
                TargetPath:     request.TargetPath,
                SourceFormat:   request.SourceFormat,
                TargetFormat:   request.TargetFormat,
                ConversionType: request.ConversionType,
                Quality:        request.Quality,
                Settings:       request.Settings,
                Priority:       request.Priority,
                Status:         models.ConversionStatusPending,
                CreatedAt:      time.Now(),
                ScheduledFor:   request.ScheduledFor,
        }

        id, err := s.conversionRepo.CreateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create conversion job: %w", err)
        }</span>

        <span class="cov0" title="0">job.ID = id
        return job, nil</span>
}

func (s *ConversionService) StartConversion(jobID int) error <span class="cov0" title="0">{
        job, err := s.conversionRepo.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get conversion job: %w", err)
        }</span>

        <span class="cov0" title="0">if job.Status != models.ConversionStatusPending </span><span class="cov0" title="0">{
                return fmt.Errorf("job is not in pending status")
        }</span>

        <span class="cov0" title="0">job.Status = models.ConversionStatusRunning
        job.StartedAt = &amp;time.Time{}
        *job.StartedAt = time.Now()

        err = s.conversionRepo.UpdateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update job status: %w", err)
        }</span>

        <span class="cov0" title="0">go s.processConversion(job)

        return nil</span>
}

func (s *ConversionService) processConversion(job *models.ConversionJob) <span class="cov0" title="0">{
        var err error

        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.handleConversionError(job, fmt.Errorf("conversion panic: %v", r))
                }</span>
        }()

        <span class="cov0" title="0">switch job.ConversionType </span>{
        case models.ConversionTypeVideo:<span class="cov0" title="0">
                err = s.convertVideo(job)</span>
        case models.ConversionTypeAudio:<span class="cov0" title="0">
                err = s.convertAudio(job)</span>
        case models.ConversionTypeDocument:<span class="cov0" title="0">
                err = s.convertDocument(job)</span>
        case models.ConversionTypeImage:<span class="cov0" title="0">
                err = s.convertImage(job)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unsupported conversion type: %s", job.ConversionType)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.handleConversionError(job, err)
                return
        }</span>

        <span class="cov0" title="0">s.handleConversionSuccess(job)</span>
}

func (s *ConversionService) convertVideo(job *models.ConversionJob) error <span class="cov0" title="0">{
        args := s.buildFFmpegVideoArgs(job)

        cmd := exec.Command("ffmpeg", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ffmpeg video conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) convertAudio(job *models.ConversionJob) error <span class="cov0" title="0">{
        args := s.buildFFmpegAudioArgs(job)

        cmd := exec.Command("ffmpeg", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ffmpeg audio conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) convertDocument(job *models.ConversionJob) error <span class="cov0" title="0">{
        switch </span>{
        case s.isEbookConversion(job):<span class="cov0" title="0">
                return s.convertEbook(job)</span>
        case s.isPDFConversion(job):<span class="cov0" title="0">
                return s.convertPDF(job)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported document conversion")</span>
        }
}

func (s *ConversionService) convertEbook(job *models.ConversionJob) error <span class="cov0" title="0">{
        args := []string{
                job.SourcePath,
                job.TargetPath,
        }

        if job.Settings != nil </span><span class="cov0" title="0">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov0" title="0">{
                        if cover, ok := settings["preserve_cover"].(bool); ok &amp;&amp; cover </span><span class="cov0" title="0">{
                                args = append(args, "--preserve-cover")
                        }</span>
                        <span class="cov0" title="0">if metadata, ok := settings["preserve_metadata"].(bool); ok &amp;&amp; metadata </span><span class="cov0" title="0">{
                                args = append(args, "--preserve-metadata")
                        }</span>
                }
        }

        <span class="cov0" title="0">cmd := exec.Command("ebook-convert", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ebook conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) convertPDF(job *models.ConversionJob) error <span class="cov0" title="0">{
        // Determine target format and use appropriate conversion method
        ext := strings.ToLower(filepath.Ext(job.TargetPath))
        targetFormat := strings.TrimPrefix(ext, ".")
        
        switch targetFormat </span>{
        case "jpg", "jpeg", "png", "bmp", "tiff", "gif":<span class="cov0" title="0">
                return s.convertPDFToImage(job, targetFormat)</span>
        case "txt", "text":<span class="cov0" title="0">
                return s.convertPDFToText(job)</span>
        case "html":<span class="cov0" title="0">
                return s.convertPDFToHTML(job)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported PDF conversion target format: %s", targetFormat)</span>
        }
}

// convertPDFToImage converts PDF pages to images using go-fitz library
func (s *ConversionService) convertPDFToImage(job *models.ConversionJob, format string) error <span class="cov0" title="0">{
        doc, err := fitz.New(job.SourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open PDF: %w", err)
        }</span>
        <span class="cov0" title="0">defer doc.Close()

        // Get total page count
        totalPages := doc.NumPage()

        // Parse settings to determine which pages to convert
        settings := make(map[string]interface{})
        if job.Settings != nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span>{<span class="cov0" title="0">
                        // Settings parsed successfully
                }</span>
        }

        // Determine page range
        <span class="cov0" title="0">startPage := 0
        endPage := totalPages
        
        if page, ok := settings["page"].(int); ok &amp;&amp; page &gt;= 0 &amp;&amp; page &lt; totalPages </span><span class="cov0" title="0">{
                // Single page
                startPage = page
                endPage = page + 1
        }</span> else<span class="cov0" title="0"> if start, ok := settings["start_page"].(int); ok &amp;&amp; start &gt;= 0 </span><span class="cov0" title="0">{
                startPage = start
                if end, ok := settings["end_page"].(int); ok &amp;&amp; end &gt; start &amp;&amp; end &lt;= totalPages </span><span class="cov0" title="0">{
                        endPage = end
                }</span>
        }

        // Determine DPI for quality (default 150)
        <span class="cov0" title="0">dpi := 150
        if dpiVal, ok := settings["dpi"].(int); ok &amp;&amp; dpiVal &gt; 0 </span><span class="cov0" title="0">{
                dpi = dpiVal
        }</span>

        // Convert each page
        <span class="cov0" title="0">for i := startPage; i &lt; endPage; i++ </span><span class="cov0" title="0">{
                img, err := doc.ImageDPI(i, float64(dpi))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to render page %d: %w", i+1, err)
                }</span>

                // Determine output file path
                <span class="cov0" title="0">outputPath := job.TargetPath
                if totalPages &gt; 1 </span><span class="cov0" title="0">{
                        // Add page number to filename for multi-page PDFs
                        dir := filepath.Dir(outputPath)
                        name := filepath.Base(outputPath)
                        ext := filepath.Ext(outputPath)
                        nameWithoutExt := strings.TrimSuffix(name, ext)
                        outputPath = filepath.Join(dir, fmt.Sprintf("%s_page_%d%s", nameWithoutExt, i+1, ext))
                }</span>

                // Create output file
                <span class="cov0" title="0">file, err := os.Create(outputPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create output file: %w", err)
                }</span>
                <span class="cov0" title="0">defer file.Close()

                // Encode based on format
                switch format </span>{
                case "jpg", "jpeg":<span class="cov0" title="0">
                        err = jpeg.Encode(file, img, &amp;jpeg.Options{Quality: 85})</span>
                case "png":<span class="cov0" title="0">
                        err = png.Encode(file, img)</span>
                default:<span class="cov0" title="0">
                        // For other formats, use ImageMagick as fallback
                        return s.convertPDFWithImageMagick(job, format)</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encode image: %w", err)
                }</span>

                // If this was a single page conversion, break
                <span class="cov0" title="0">if totalPages == 1 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// convertPDFToText converts PDF to plain text using pdf reader
func (s *ConversionService) convertPDFToText(job *models.ConversionJob) error <span class="cov0" title="0">{
        file, err := os.Open(job.SourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open PDF: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Get file info for pdf.NewReader
        fileInfo, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">pdfReader, err := pdf.NewReader(file, fileInfo.Size())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create PDF reader: %w", err)
        }</span>

        // Parse settings
        <span class="cov0" title="0">settings := make(map[string]interface{})
        if job.Settings != nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span>{<span class="cov0" title="0">
                        // Settings parsed successfully
                }</span>
        }

        // Determine page range
        <span class="cov0" title="0">totalPages := pdfReader.NumPage()
        startPage := 1
        endPage := totalPages

        if page, ok := settings["page"].(int); ok &amp;&amp; page &gt; 0 &amp;&amp; page &lt;= totalPages </span><span class="cov0" title="0">{
                startPage = page
                endPage = page
        }</span> else<span class="cov0" title="0"> if start, ok := settings["start_page"].(int); ok &amp;&amp; start &gt; 0 </span><span class="cov0" title="0">{
                startPage = start
                if end, ok := settings["end_page"].(int); ok &amp;&amp; end &gt;= start &amp;&amp; end &lt;= totalPages </span><span class="cov0" title="0">{
                        endPage = end
                }</span>
        }

        // Create output file
        <span class="cov0" title="0">outputFile, err := os.Create(job.TargetPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output file: %w", err)
        }</span>
        <span class="cov0" title="0">defer outputFile.Close()

        // Extract text from pages
        for i := startPage; i &lt;= endPage; i++ </span><span class="cov0" title="0">{
                page := pdfReader.Page(i)
                
                // Get fonts for the page
                fonts := make(map[string]*pdf.Font)
                fontNames := page.Fonts()
                for _, fontName := range fontNames </span><span class="cov0" title="0">{
                        font := page.Font(fontName)
                        fonts[fontName] = &amp;font
                }</span>
                
                <span class="cov0" title="0">content, err := page.GetPlainText(fonts)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to extract text from page %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">if _, err := outputFile.WriteString(content); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write text to file: %w", err)
                }</span>

                // Add page separator for multi-page PDFs
                <span class="cov0" title="0">if i &lt; endPage </span><span class="cov0" title="0">{
                        if _, err := outputFile.WriteString(fmt.Sprintf("\n\n--- Page %d ---\n\n", i+1)); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write page separator: %w", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// convertPDFToHTML converts PDF to HTML using external tools
func (s *ConversionService) convertPDFToHTML(job *models.ConversionJob) error <span class="cov0" title="0">{
        // Try pandoc first for HTML conversion
        args := []string{
                "-f", "pdf",
                "-t", "html",
                "-o", job.TargetPath,
                job.SourcePath,
        }

        cmd := exec.Command("pandoc", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Fallback to LibreOffice if pandoc is not available
        <span class="cov0" title="0">args = []string{
                "--headless",
                "--convert-to", "html",
                "--outdir", filepath.Dir(job.TargetPath),
                job.SourcePath,
        }

        cmd = exec.Command("libreoffice", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err = cmd.Run()
        if err == nil </span><span class="cov0" title="0">{
                // LibreOffice might create a different filename, rename if needed
                libreOutput := strings.TrimSuffix(job.SourcePath, filepath.Ext(job.SourcePath)) + ".html"
                if _, err := os.Stat(libreOutput); err == nil </span><span class="cov0" title="0">{
                        if libreOutput != job.TargetPath </span><span class="cov0" title="0">{
                                if err := os.Rename(libreOutput, job.TargetPath); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Warning: Failed to rename LibreOffice output: %v\n", err)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return nil</span>
        }

        // Last resort: try to convert PDF to text then wrap in HTML
        <span class="cov0" title="0">tempTextFile := job.TargetPath + ".tmp.txt"
        err = s.convertPDFToText(&amp;models.ConversionJob{
                SourcePath: job.SourcePath,
                TargetPath: tempTextFile,
                Settings:   job.Settings,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to convert PDF to text for HTML conversion: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempTextFile)

        // Read the text content
        content, err := os.ReadFile(tempTextFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read temp text file: %w", err)
        }</span>

        // Create basic HTML
        <span class="cov0" title="0">htmlContent := fmt.Sprintf(`&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;%s&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        pre { white-space: pre-wrap; word-wrap: break-word; }
        .page-break { page-break-before: always; border-top: 2px solid #ccc; margin-top: 20px; padding-top: 20px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;%s&lt;/h1&gt;
    &lt;pre&gt;%s&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;`, filepath.Base(job.SourcePath), filepath.Base(job.SourcePath), string(content))

        // Write HTML file
        return os.WriteFile(job.TargetPath, []byte(htmlContent), 0644)</span>
}

// convertPDFWithImageMagick converts PDF to image formats not directly supported by go-fitz
func (s *ConversionService) convertPDFWithImageMagick(job *models.ConversionJob, format string) error <span class="cov0" title="0">{
        args := []string{
                "-density", "150",  // DPI
                job.SourcePath,
        }

        // Parse settings for quality options
        if job.Settings != nil </span><span class="cov0" title="0">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov0" title="0">{
                        if dpi, ok := settings["dpi"].(int); ok &amp;&amp; dpi &gt; 0 </span><span class="cov0" title="0">{
                                args[1] = fmt.Sprintf("%d", dpi)
                        }</span>
                        <span class="cov0" title="0">if quality, ok := settings["quality"].(int); ok &amp;&amp; quality &gt; 0 </span><span class="cov0" title="0">{
                                args = append(args, "-quality", fmt.Sprintf("%d", quality))
                        }</span>
                }
        }

        <span class="cov0" title="0">args = append(args, job.TargetPath)

        cmd := exec.Command("convert", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("imagemagick PDF conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) convertImage(job *models.ConversionJob) error <span class="cov0" title="0">{
        args := s.buildImageMagickArgs(job)

        cmd := exec.Command("convert", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("imagemagick conversion failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ConversionService) buildFFmpegVideoArgs(job *models.ConversionJob) []string <span class="cov0" title="0">{
        args := []string{
                "-i", job.SourcePath,
                "-y", // Overwrite output file
        }

        switch job.Quality </span>{
        case "low":<span class="cov0" title="0">
                args = append(args, "-crf", "28", "-preset", "fast")</span>
        case "medium":<span class="cov0" title="0">
                args = append(args, "-crf", "23", "-preset", "medium")</span>
        case "high":<span class="cov0" title="0">
                args = append(args, "-crf", "18", "-preset", "slow")</span>
        case "lossless":<span class="cov0" title="0">
                args = append(args, "-crf", "0", "-preset", "veryslow")</span>
        default:<span class="cov0" title="0">
                args = append(args, "-crf", "23", "-preset", "medium")</span>
        }

        <span class="cov0" title="0">if job.Settings != nil </span><span class="cov0" title="0">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov0" title="0">{
                        if resolution, ok := settings["resolution"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-s", resolution)
                        }</span>
                        <span class="cov0" title="0">if framerate, ok := settings["framerate"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-r", framerate)
                        }</span>
                        <span class="cov0" title="0">if bitrate, ok := settings["bitrate"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-b:v", bitrate)
                        }</span>
                }
        }

        <span class="cov0" title="0">args = append(args, job.TargetPath)
        return args</span>
}

func (s *ConversionService) buildFFmpegAudioArgs(job *models.ConversionJob) []string <span class="cov0" title="0">{
        args := []string{
                "-i", job.SourcePath,
                "-y", // Overwrite output file
        }

        switch job.Quality </span>{
        case "low":<span class="cov0" title="0">
                args = append(args, "-ab", "96k")</span>
        case "medium":<span class="cov0" title="0">
                args = append(args, "-ab", "192k")</span>
        case "high":<span class="cov0" title="0">
                args = append(args, "-ab", "320k")</span>
        case "lossless":<span class="cov0" title="0">
                args = append(args, "-c:a", "flac")</span>
        default:<span class="cov0" title="0">
                args = append(args, "-ab", "192k")</span>
        }

        <span class="cov0" title="0">if job.Settings != nil </span><span class="cov0" title="0">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov0" title="0">{
                        if sampleRate, ok := settings["sample_rate"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-ar", sampleRate)
                        }</span>
                        <span class="cov0" title="0">if channels, ok := settings["channels"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-ac", channels)
                        }</span>
                }
        }

        <span class="cov0" title="0">args = append(args, job.TargetPath)
        return args</span>
}

func (s *ConversionService) buildImageMagickArgs(job *models.ConversionJob) []string <span class="cov0" title="0">{
        args := []string{job.SourcePath}

        if job.Settings != nil </span><span class="cov0" title="0">{
                settings := make(map[string]interface{})
                if err := json.Unmarshal([]byte(*job.Settings), &amp;settings); err == nil </span><span class="cov0" title="0">{
                        if resize, ok := settings["resize"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-resize", resize)
                        }</span>
                        <span class="cov0" title="0">if quality, ok := settings["quality"].(string); ok </span><span class="cov0" title="0">{
                                args = append(args, "-quality", quality)
                        }</span>
                        <span class="cov0" title="0">if compress, ok := settings["compress"].(bool); ok &amp;&amp; compress </span><span class="cov0" title="0">{
                                args = append(args, "-compress", "JPEG")
                        }</span>
                }
        }

        <span class="cov0" title="0">args = append(args, job.TargetPath)
        return args</span>
}

func (s *ConversionService) handleConversionSuccess(job *models.ConversionJob) <span class="cov0" title="0">{
        job.Status = models.ConversionStatusCompleted
        job.CompletedAt = &amp;time.Time{}
        *job.CompletedAt = time.Now()

        if job.StartedAt != nil </span><span class="cov0" title="0">{
                duration := job.CompletedAt.Sub(*job.StartedAt)
                job.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">err := s.conversionRepo.UpdateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update completed job %d: %v\n", job.ID, err)
        }</span>

        <span class="cov0" title="0">s.notifyUser(job, "Conversion completed successfully")</span>
}

func (s *ConversionService) handleConversionError(job *models.ConversionJob, conversionError error) <span class="cov0" title="0">{
        job.Status = models.ConversionStatusFailed
        job.CompletedAt = &amp;time.Time{}
        *job.CompletedAt = time.Now()
        errorMsg := conversionError.Error()
        job.ErrorMessage = &amp;errorMsg

        if job.StartedAt != nil </span><span class="cov0" title="0">{
                duration := job.CompletedAt.Sub(*job.StartedAt)
                job.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">err := s.conversionRepo.UpdateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update failed job %d: %v\n", job.ID, err)
        }</span>

        <span class="cov0" title="0">s.notifyUser(job, fmt.Sprintf("Conversion failed: %s", conversionError.Error()))</span>
}

func (s *ConversionService) notifyUser(job *models.ConversionJob, message string) <span class="cov0" title="0">{
        // In a full implementation, this would send notifications via email, push, etc.
        fmt.Printf("Notification for user %d: %s (Job %d)\n", job.UserID, message, job.ID)
}</span>

func (s *ConversionService) GetUserJobs(userID int, status *string, limit, offset int) ([]models.ConversionJob, error) <span class="cov0" title="0">{
        return s.conversionRepo.GetUserJobs(userID, status, limit, offset)
}</span>

func (s *ConversionService) GetJob(jobID int, userID int) (*models.ConversionJob, error) <span class="cov0" title="0">{
        job, err := s.conversionRepo.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if job.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, auth.PermissionViewMedia)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to view this job")
                }</span>
        }

        <span class="cov0" title="0">return job, nil</span>
}

func (s *ConversionService) CancelJob(jobID int, userID int) error <span class="cov0" title="0">{
        job, err := s.conversionRepo.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if job.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, auth.PermissionManageUsers)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return fmt.Errorf("unauthorized to cancel this job")
                }</span>
        }

        <span class="cov0" title="0">if job.Status != models.ConversionStatusPending &amp;&amp; job.Status != models.ConversionStatusRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot cancel job in status: %s", job.Status)
        }</span>

        <span class="cov0" title="0">job.Status = models.ConversionStatusCancelled
        job.CompletedAt = &amp;time.Time{}
        *job.CompletedAt = time.Now()

        return s.conversionRepo.UpdateJob(job)</span>
}

func (s *ConversionService) RetryJob(jobID int, userID int) error <span class="cov0" title="0">{
        job, err := s.conversionRepo.GetJob(jobID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if job.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, auth.PermissionManageUsers)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return fmt.Errorf("unauthorized to retry this job")
                }</span>
        }

        <span class="cov0" title="0">if job.Status != models.ConversionStatusFailed </span><span class="cov0" title="0">{
                return fmt.Errorf("can only retry failed jobs")
        }</span>

        <span class="cov0" title="0">job.Status = models.ConversionStatusPending
        job.StartedAt = nil
        job.CompletedAt = nil
        job.Duration = nil
        job.ErrorMessage = nil

        err = s.conversionRepo.UpdateJob(job)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.StartConversion(jobID)</span>
}

func (s *ConversionService) GetJobStatistics(userID *int, startDate, endDate time.Time) (*models.ConversionStatistics, error) <span class="cov0" title="0">{
        return s.conversionRepo.GetStatistics(userID, startDate, endDate)
}</span>

func (s *ConversionService) CleanupCompletedJobs(olderThan time.Time) error <span class="cov0" title="0">{
        return s.conversionRepo.CleanupJobs(olderThan)
}</span>

func (s *ConversionService) GetSupportedFormats() *models.SupportedFormats <span class="cov0" title="0">{
        return &amp;models.SupportedFormats{
                Video: models.VideoFormats{
                        Input:  []string{"mp4", "avi", "mkv", "mov", "wmv", "flv", "webm", "m4v", "3gp"},
                        Output: []string{"mp4", "avi", "mkv", "mov", "webm", "m4v"},
                },
                Audio: models.AudioFormats{
                        Input:  []string{"mp3", "wav", "flac", "aac", "ogg", "wma", "m4a", "opus"},
                        Output: []string{"mp3", "wav", "flac", "aac", "ogg", "m4a", "opus"},
                },
                Document: models.DocumentFormats{
                        Input:  []string{"epub", "mobi", "azw", "azw3", "pdf", "txt", "docx", "odt"},
                        Output: []string{"epub", "mobi", "pdf", "txt", "html"},
                },
                Image: models.ImageFormats{
                        Input:  []string{"jpg", "jpeg", "png", "gif", "bmp", "tiff", "webp", "svg"},
                        Output: []string{"jpg", "jpeg", "png", "gif", "bmp", "tiff", "webp"},
                },
        }
}</span>

func (s *ConversionService) validateConversionRequest(request *models.ConversionRequest) bool <span class="cov0" title="0">{
        if request.SourcePath == "" || request.TargetPath == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if request.SourceFormat == "" || request.TargetFormat == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if request.ConversionType == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if !s.isValidConversionType(request.ConversionType) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if !s.isSupportedFormat(request.ConversionType, request.SourceFormat, request.TargetFormat) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func (s *ConversionService) isValidConversionType(conversionType string) bool <span class="cov0" title="0">{
        validTypes := []string{
                models.ConversionTypeVideo,
                models.ConversionTypeAudio,
                models.ConversionTypeDocument,
                models.ConversionTypeImage,
        }

        for _, validType := range validTypes </span><span class="cov0" title="0">{
                if conversionType == validType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (s *ConversionService) isSupportedFormat(conversionType, sourceFormat, targetFormat string) bool <span class="cov0" title="0">{
        formats := s.GetSupportedFormats()

        switch conversionType </span>{
        case models.ConversionTypeVideo:<span class="cov0" title="0">
                return s.isFormatSupported(sourceFormat, formats.Video.Input) &amp;&amp; s.isFormatSupported(targetFormat, formats.Video.Output)</span>
        case models.ConversionTypeAudio:<span class="cov0" title="0">
                return s.isFormatSupported(sourceFormat, formats.Audio.Input) &amp;&amp; s.isFormatSupported(targetFormat, formats.Audio.Output)</span>
        case models.ConversionTypeDocument:<span class="cov0" title="0">
                return s.isFormatSupported(sourceFormat, formats.Document.Input) &amp;&amp; s.isFormatSupported(targetFormat, formats.Document.Output)</span>
        case models.ConversionTypeImage:<span class="cov0" title="0">
                return s.isFormatSupported(sourceFormat, formats.Image.Input) &amp;&amp; s.isFormatSupported(targetFormat, formats.Image.Output)</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (s *ConversionService) isFormatSupported(format string, supportedFormats []string) bool <span class="cov0" title="0">{
        format = strings.ToLower(format)
        for _, supported := range supportedFormats </span><span class="cov0" title="0">{
                if format == strings.ToLower(supported) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (s *ConversionService) isEbookConversion(job *models.ConversionJob) bool <span class="cov0" title="0">{
        ebookFormats := []string{"epub", "mobi", "azw", "azw3", "txt", "html"}
        return s.isFormatSupported(job.SourceFormat, ebookFormats) || s.isFormatSupported(job.TargetFormat, ebookFormats)
}</span>

func (s *ConversionService) isPDFConversion(job *models.ConversionJob) bool <span class="cov0" title="0">{
        return job.SourceFormat == "pdf" || job.TargetFormat == "pdf"
}</span>

func (s *ConversionService) GetJobQueue() ([]models.ConversionJob, error) <span class="cov0" title="0">{
        return s.conversionRepo.GetJobsByStatus(models.ConversionStatusPending, 100, 0)
}</span>

func (s *ConversionService) ProcessJobQueue() error <span class="cov0" title="0">{
        jobs, err := s.GetJobQueue()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, job := range jobs </span><span class="cov0" title="0">{
                if job.ScheduledFor != nil &amp;&amp; job.ScheduledFor.After(time.Now()) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">err := s.StartConversion(job.ID)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to start conversion job %d: %v\n", job.ID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package services

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "runtime"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type ErrorReportingService struct {
        errorRepo        *repository.ErrorReportingRepository
        crashRepo        *repository.CrashReportingRepository
        config           *ErrorReportingConfig
        httpClient       *http.Client
        enabled          bool
        crashlyticAPIKey string
}

type ErrorReportingConfig struct {
        CrashlyticsEnabled  bool   `json:"crashlytics_enabled"`
        CrashlyticsAPIKey   string `json:"crashlytics_api_key"`
        SlackWebhookURL     string `json:"slack_webhook_url"`
        EmailNotifications  bool   `json:"email_notifications"`
        SentryDSN           string `json:"sentry_dsn"`
        AutoReporting       bool   `json:"auto_reporting"`
        MaxErrorsPerHour    int    `json:"max_errors_per_hour"`
        RetentionDays       int    `json:"retention_days"`
        IncludeStackTrace   bool   `json:"include_stack_trace"`
        IncludeSystemInfo   bool   `json:"include_system_info"`
        FilterSensitiveData bool   `json:"filter_sensitive_data"`
}

func NewErrorReportingService(errorRepo *repository.ErrorReportingRepository, crashRepo *repository.CrashReportingRepository) *ErrorReportingService <span class="cov0" title="0">{
        config := &amp;ErrorReportingConfig{
                CrashlyticsEnabled:  false,
                EmailNotifications:  true,
                AutoReporting:       true,
                MaxErrorsPerHour:    100,
                RetentionDays:       30,
                IncludeStackTrace:   true,
                IncludeSystemInfo:   true,
                FilterSensitiveData: true,
        }

        return &amp;ErrorReportingService{
                errorRepo:  errorRepo,
                crashRepo:  crashRepo,
                config:     config,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
                enabled:    true,
        }
}</span>

func (s *ErrorReportingService) ReportError(userID int, errorReport *models.ErrorReportRequest) (*models.ErrorReport, error) <span class="cov0" title="0">{
        if !s.enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reporting is disabled")
        }</span>

        // Check rate limiting
        <span class="cov0" title="0">if s.config.MaxErrorsPerHour &gt; 0 </span><span class="cov0" title="0">{
                count, err := s.errorRepo.GetErrorCountInLastHour(userID)
                if err == nil &amp;&amp; count &gt;= s.config.MaxErrorsPerHour </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error reporting rate limit exceeded")
                }</span>
        }

        // Create error report
        <span class="cov0" title="0">report := &amp;models.ErrorReport{
                UserID:     userID,
                Level:      errorReport.Level,
                Message:    errorReport.Message,
                ErrorCode:  errorReport.ErrorCode,
                Component:  errorReport.Component,
                StackTrace: errorReport.StackTrace,
                Context:    errorReport.Context,
                UserAgent:  errorReport.UserAgent,
                URL:        errorReport.URL,
                ReportedAt: time.Now(),
                Status:     models.ErrorStatusNew,
        }

        // Filter sensitive data
        if s.config.FilterSensitiveData </span><span class="cov0" title="0">{
                report = s.filterSensitiveData(report)
        }</span>

        // Add system information
        <span class="cov0" title="0">if s.config.IncludeSystemInfo </span><span class="cov0" title="0">{
                report.SystemInfo = s.collectSystemInfo()
        }</span>

        // Generate fingerprint for deduplication
        <span class="cov0" title="0">report.Fingerprint = s.generateFingerprint(report)

        // Save to database
        if err := s.errorRepo.CreateErrorReport(report); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save error report: %w", err)
        }</span>

        // Send notifications asynchronously
        <span class="cov0" title="0">if s.config.AutoReporting </span><span class="cov0" title="0">{
                go s.sendNotifications(report)
        }</span>

        // Send to external services
        <span class="cov0" title="0">go s.sendToExternalServices(report)

        return report, nil</span>
}

func (s *ErrorReportingService) ReportCrash(userID int, crashReport *models.CrashReportRequest) (*models.CrashReport, error) <span class="cov0" title="0">{
        if !s.enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("crash reporting is disabled")
        }</span>

        // Create crash report
        <span class="cov0" title="0">report := &amp;models.CrashReport{
                UserID:     userID,
                Signal:     crashReport.Signal,
                Message:    crashReport.Message,
                StackTrace: crashReport.StackTrace,
                Context:    crashReport.Context,
                ReportedAt: time.Now(),
                Status:     models.CrashStatusNew,
        }

        // Add system information
        report.SystemInfo = s.collectSystemInfo()

        // Generate fingerprint for deduplication
        report.Fingerprint = s.generateCrashFingerprint(report)

        // Save to database
        if err := s.crashRepo.CreateCrashReport(report); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save crash report: %w", err)
        }</span>

        // Send critical notifications immediately
        <span class="cov0" title="0">go s.sendCrashNotifications(report)

        // Send to Crashlytics
        if s.config.CrashlyticsEnabled </span><span class="cov0" title="0">{
                go s.sendToCrashlytics(report)
        }</span>

        <span class="cov0" title="0">return report, nil</span>
}

func (s *ErrorReportingService) GetErrorReport(id int, userID int) (*models.ErrorReport, error) <span class="cov0" title="0">{
        report, err := s.errorRepo.GetErrorReport(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get error report: %w", err)
        }</span>

        // Check if user has access
        <span class="cov0" title="0">if report.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">return report, nil</span>
}

func (s *ErrorReportingService) GetCrashReport(id int, userID int) (*models.CrashReport, error) <span class="cov0" title="0">{
        report, err := s.crashRepo.GetCrashReport(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get crash report: %w", err)
        }</span>

        // Check if user has access
        <span class="cov0" title="0">if report.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">return report, nil</span>
}

func (s *ErrorReportingService) UpdateErrorStatus(id int, userID int, status string) error <span class="cov0" title="0">{
        report, err := s.errorRepo.GetErrorReport(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get error report: %w", err)
        }</span>

        <span class="cov0" title="0">if report.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">report.Status = status
        if status == models.ErrorStatusResolved </span><span class="cov0" title="0">{
                now := time.Now()
                report.ResolvedAt = &amp;now
        }</span>

        <span class="cov0" title="0">return s.errorRepo.UpdateErrorReport(report)</span>
}

func (s *ErrorReportingService) UpdateCrashStatus(id int, userID int, status string) error <span class="cov0" title="0">{
        report, err := s.crashRepo.GetCrashReport(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get crash report: %w", err)
        }</span>

        <span class="cov0" title="0">if report.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">report.Status = status
        if status == models.CrashStatusResolved </span><span class="cov0" title="0">{
                now := time.Now()
                report.ResolvedAt = &amp;now
        }</span>

        <span class="cov0" title="0">return s.crashRepo.UpdateCrashReport(report)</span>
}

func (s *ErrorReportingService) GetErrorReportsByUser(userID int, filters *models.ErrorReportFilters) ([]*models.ErrorReport, error) <span class="cov0" title="0">{
        return s.errorRepo.GetErrorReportsByUser(userID, filters)
}</span>

func (s *ErrorReportingService) GetCrashReportsByUser(userID int, filters *models.CrashReportFilters) ([]*models.CrashReport, error) <span class="cov0" title="0">{
        return s.crashRepo.GetCrashReportsByUser(userID, filters)
}</span>

func (s *ErrorReportingService) GetErrorStatistics(userID int) (*models.ErrorStatistics, error) <span class="cov0" title="0">{
        return s.errorRepo.GetErrorStatistics(userID)
}</span>

func (s *ErrorReportingService) GetCrashStatistics(userID int) (*models.CrashStatistics, error) <span class="cov0" title="0">{
        return s.crashRepo.GetCrashStatistics(userID)
}</span>

func (s *ErrorReportingService) GetSystemHealth() (*models.SystemHealth, error) <span class="cov0" title="0">{
        health := &amp;models.SystemHealth{
                CheckedAt: time.Now(),
                Status:    "healthy",
                Metrics:   make(map[string]interface{}),
        }

        // Check recent error rates
        recentErrors, err := s.errorRepo.GetRecentErrorCount(1 * time.Hour)
        if err == nil </span><span class="cov0" title="0">{
                health.Metrics["recent_errors"] = recentErrors
                if recentErrors &gt; 100 </span><span class="cov0" title="0">{
                        health.Status = "degraded"
                }</span>
        }

        // Check recent crash rates
        <span class="cov0" title="0">recentCrashes, err := s.crashRepo.GetRecentCrashCount(1 * time.Hour)
        if err == nil </span><span class="cov0" title="0">{
                health.Metrics["recent_crashes"] = recentCrashes
                if recentCrashes &gt; 5 </span><span class="cov0" title="0">{
                        health.Status = "critical"
                }</span>
        }

        // Check system resources
        <span class="cov0" title="0">var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        health.Metrics["memory_used"] = m.Alloc
        health.Metrics["memory_total"] = m.Sys
        health.Metrics["goroutines"] = runtime.NumGoroutine()

        return health, nil</span>
}

func (s *ErrorReportingService) UpdateConfiguration(config *ErrorReportingConfig) error <span class="cov0" title="0">{
        s.config = config
        return nil
}</span>

func (s *ErrorReportingService) GetConfiguration() *ErrorReportingConfig <span class="cov0" title="0">{
        return s.config
}</span>

func (s *ErrorReportingService) CleanupOldReports(olderThan time.Time) error <span class="cov0" title="0">{
        if err := s.errorRepo.CleanupOldReports(olderThan); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old error reports: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.crashRepo.CleanupOldReports(olderThan); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old crash reports: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ErrorReportingService) ExportReports(userID int, filters *models.ExportFilters) ([]byte, error) <span class="cov0" title="0">{
        var reports []interface{}

        // Get error reports
        if filters.IncludeErrors </span><span class="cov0" title="0">{
                errorReports, err := s.errorRepo.GetErrorReportsByUser(userID, &amp;models.ErrorReportFilters{
                        StartDate: filters.StartDate,
                        EndDate:   filters.EndDate,
                        Level:     filters.Level,
                        Component: filters.Component,
                        Limit:     filters.Limit,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get error reports: %w", err)
                }</span>
                <span class="cov0" title="0">for _, report := range errorReports </span><span class="cov0" title="0">{
                        reports = append(reports, report)
                }</span>
        }

        // Get crash reports
        <span class="cov0" title="0">if filters.IncludeCrashes </span><span class="cov0" title="0">{
                crashReports, err := s.crashRepo.GetCrashReportsByUser(userID, &amp;models.CrashReportFilters{
                        StartDate: filters.StartDate,
                        EndDate:   filters.EndDate,
                        Signal:    filters.Signal,
                        Limit:     filters.Limit,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get crash reports: %w", err)
                }</span>
                <span class="cov0" title="0">for _, report := range crashReports </span><span class="cov0" title="0">{
                        reports = append(reports, report)
                }</span>
        }

        // Export based on format
        <span class="cov0" title="0">switch filters.Format </span>{
        case "json":<span class="cov0" title="0">
                return json.MarshalIndent(reports, "", "  ")</span>
        case "csv":<span class="cov0" title="0">
                return s.exportToCSV(reports)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported export format: %s", filters.Format)</span>
        }
}

// Helper methods

func (s *ErrorReportingService) filterSensitiveData(report *models.ErrorReport) *models.ErrorReport <span class="cov0" title="0">{
        // Remove sensitive patterns from message and stack trace
        sensitivePatterns := []string{
                "password", "token", "key", "secret", "auth",
                "email", "phone", "ssn", "credit",
        }

        for _, pattern := range sensitivePatterns </span><span class="cov0" title="0">{
                report.Message = strings.ReplaceAll(strings.ToLower(report.Message), pattern, "[REDACTED]")
                report.StackTrace = strings.ReplaceAll(strings.ToLower(report.StackTrace), pattern, "[REDACTED]")
        }</span>

        // Filter context data
        <span class="cov0" title="0">if report.Context != nil </span><span class="cov0" title="0">{
                filteredContext := make(map[string]interface{})
                for key, value := range report.Context </span><span class="cov0" title="0">{
                        keyLower := strings.ToLower(key)
                        isSensitive := false
                        for _, pattern := range sensitivePatterns </span><span class="cov0" title="0">{
                                if strings.Contains(keyLower, pattern) </span><span class="cov0" title="0">{
                                        isSensitive = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !isSensitive </span><span class="cov0" title="0">{
                                filteredContext[key] = value
                        }</span> else<span class="cov0" title="0"> {
                                filteredContext[key] = "[REDACTED]"
                        }</span>
                }
                <span class="cov0" title="0">report.Context = filteredContext</span>
        }

        <span class="cov0" title="0">return report</span>
}

func (s *ErrorReportingService) collectSystemInfo() map[string]interface{} <span class="cov0" title="0">{
        info := make(map[string]interface{})

        info["os"] = runtime.GOOS
        info["arch"] = runtime.GOARCH
        info["go_version"] = runtime.Version()
        info["num_cpu"] = runtime.NumCPU()
        info["num_goroutine"] = runtime.NumGoroutine()

        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        info["memory_alloc"] = m.Alloc
        info["memory_total_alloc"] = m.TotalAlloc
        info["memory_sys"] = m.Sys

        if hostname, err := os.Hostname(); err == nil </span><span class="cov0" title="0">{
                info["hostname"] = hostname
        }</span>

        <span class="cov0" title="0">if wd, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                info["working_directory"] = wd
        }</span>

        <span class="cov0" title="0">return info</span>
}

func (s *ErrorReportingService) generateFingerprint(report *models.ErrorReport) string <span class="cov0" title="0">{
        // Create a unique fingerprint based on error characteristics
        data := fmt.Sprintf("%s:%s:%s", report.Level, report.Component, report.ErrorCode)
        return fmt.Sprintf("%x", data)[:16]
}</span>

func (s *ErrorReportingService) generateCrashFingerprint(report *models.CrashReport) string <span class="cov0" title="0">{
        // Create a unique fingerprint based on crash characteristics
        data := fmt.Sprintf("%s:%s", report.Signal, report.Message)
        return fmt.Sprintf("%x", data)[:16]
}</span>

func (s *ErrorReportingService) sendNotifications(report *models.ErrorReport) <span class="cov0" title="0">{
        // Send Slack notification
        if s.config.SlackWebhookURL != "" </span><span class="cov0" title="0">{
                s.sendSlackNotification(report)
        }</span>

        // Send email notification
        <span class="cov0" title="0">if s.config.EmailNotifications </span><span class="cov0" title="0">{
                s.sendEmailNotification(report)
        }</span>
}

func (s *ErrorReportingService) sendCrashNotifications(report *models.CrashReport) <span class="cov0" title="0">{
        // Send critical notifications for crashes
        if s.config.SlackWebhookURL != "" </span><span class="cov0" title="0">{
                s.sendSlackCrashNotification(report)
        }</span>

        <span class="cov0" title="0">if s.config.EmailNotifications </span><span class="cov0" title="0">{
                s.sendEmailCrashNotification(report)
        }</span>
}

func (s *ErrorReportingService) sendSlackNotification(report *models.ErrorReport) error <span class="cov0" title="0">{
        if s.config.SlackWebhookURL == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">message := map[string]interface{}{
                "text": fmt.Sprintf(" Error Report: %s", report.Message),
                "attachments": []map[string]interface{}{
                        {
                                "color": s.getColorForLevel(report.Level),
                                "fields": []map[string]interface{}{
                                        {"title": "Level", "value": report.Level, "short": true},
                                        {"title": "Component", "value": report.Component, "short": true},
                                        {"title": "Error Code", "value": report.ErrorCode, "short": true},
                                        {"title": "Time", "value": report.ReportedAt.Format(time.RFC3339), "short": true},
                                },
                        },
                },
        }

        jsonData, _ := json.Marshal(message)
        _, err := s.httpClient.Post(s.config.SlackWebhookURL, "application/json", bytes.NewBuffer(jsonData))
        return err</span>
}

func (s *ErrorReportingService) sendSlackCrashNotification(report *models.CrashReport) error <span class="cov0" title="0">{
        if s.config.SlackWebhookURL == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">message := map[string]interface{}{
                "text": fmt.Sprintf(" CRASH REPORT: %s", report.Message),
                "attachments": []map[string]interface{}{
                        {
                                "color": "danger",
                                "fields": []map[string]interface{}{
                                        {"title": "Signal", "value": report.Signal, "short": true},
                                        {"title": "Time", "value": report.ReportedAt.Format(time.RFC3339), "short": true},
                                },
                        },
                },
        }

        jsonData, _ := json.Marshal(message)
        _, err := s.httpClient.Post(s.config.SlackWebhookURL, "application/json", bytes.NewBuffer(jsonData))
        return err</span>
}

func (s *ErrorReportingService) sendEmailNotification(report *models.ErrorReport) error <span class="cov0" title="0">{
        // Email implementation would go here
        // This is a placeholder for email notification logic
        return nil
}</span>

func (s *ErrorReportingService) sendEmailCrashNotification(report *models.CrashReport) error <span class="cov0" title="0">{
        // Email implementation would go here
        // This is a placeholder for email notification logic
        return nil
}</span>

func (s *ErrorReportingService) sendToExternalServices(report *models.ErrorReport) <span class="cov0" title="0">{
        // Send to Sentry
        if s.config.SentryDSN != "" </span><span class="cov0" title="0">{
                s.sendToSentry(report)
        }</span>
}

func (s *ErrorReportingService) sendToSentry(report *models.ErrorReport) error <span class="cov0" title="0">{
        // Sentry integration would go here
        // This is a placeholder for Sentry integration
        return nil
}</span>

func (s *ErrorReportingService) sendToCrashlytics(report *models.CrashReport) error <span class="cov0" title="0">{
        if s.config.CrashlyticsAPIKey == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Crashlytics integration would go here
        // This is a placeholder for Firebase Crashlytics integration
        <span class="cov0" title="0">return nil</span>
}

func (s *ErrorReportingService) getColorForLevel(level string) string <span class="cov0" title="0">{
        switch strings.ToLower(level) </span>{
        case "error", "fatal":<span class="cov0" title="0">
                return "danger"</span>
        case "warning", "warn":<span class="cov0" title="0">
                return "warning"</span>
        case "info":<span class="cov0" title="0">
                return "good"</span>
        default:<span class="cov0" title="0">
                return "#36a64f"</span>
        }
}

func (s *ErrorReportingService) exportToCSV(reports []interface{}) ([]byte, error) <span class="cov0" title="0">{
        // CSV export implementation would go here
        // This is a placeholder for CSV export logic
        return []byte("CSV export not implemented"), nil
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">package services

import (
        "bytes"
        "encoding/csv"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type FavoritesService struct {
        favoritesRepo *repository.FavoritesRepository
        authService   *AuthService
}

func NewFavoritesService(favoritesRepo *repository.FavoritesRepository, authService *AuthService) *FavoritesService <span class="cov0" title="0">{
        return &amp;FavoritesService{
                favoritesRepo: favoritesRepo,
                authService:   authService,
        }
}</span>

func (s *FavoritesService) AddFavorite(userID int, favorite *models.Favorite) (*models.Favorite, error) <span class="cov0" title="0">{
        existing, err := s.favoritesRepo.GetFavorite(userID, favorite.EntityType, favorite.EntityID)
        if err == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                return existing, fmt.Errorf("item already in favorites")
        }</span>

        <span class="cov0" title="0">favorite.UserID = userID
        favorite.CreatedAt = time.Now()

        id, err := s.favoritesRepo.CreateFavorite(favorite)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add favorite: %w", err)
        }</span>

        <span class="cov0" title="0">favorite.ID = id
        return favorite, nil</span>
}

func (s *FavoritesService) RemoveFavorite(userID int, entityType string, entityID int) error <span class="cov0" title="0">{
        favorite, err := s.favoritesRepo.GetFavorite(userID, entityType, entityID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("favorite not found: %w", err)
        }</span>

        <span class="cov0" title="0">if favorite.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("unauthorized to remove this favorite")
        }</span>

        <span class="cov0" title="0">return s.favoritesRepo.DeleteFavorite(favorite.ID)</span>
}

func (s *FavoritesService) GetUserFavorites(userID int, entityType *string, category *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetUserFavorites(userID, entityType, category, limit, offset)
}</span>

func (s *FavoritesService) GetFavoritesByEntity(userID int, entityType string, entityID int) (*models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetFavorite(userID, entityType, entityID)
}</span>

func (s *FavoritesService) IsFavorite(userID int, entityType string, entityID int) (bool, error) <span class="cov0" title="0">{
        favorite, err := s.favoritesRepo.GetFavorite(userID, entityType, entityID)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return favorite != nil, nil</span>
}

func (s *FavoritesService) UpdateFavorite(userID int, favoriteID int, updates *models.UpdateFavoriteRequest) (*models.Favorite, error) <span class="cov0" title="0">{
        favorite, err := s.favoritesRepo.GetFavoriteByID(favoriteID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("favorite not found: %w", err)
        }</span>

        <span class="cov0" title="0">if favorite.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unauthorized to update this favorite")
        }</span>

        <span class="cov0" title="0">if updates.Category != nil </span><span class="cov0" title="0">{
                favorite.Category = updates.Category
        }</span>

        <span class="cov0" title="0">if updates.Notes != nil </span><span class="cov0" title="0">{
                favorite.Notes = updates.Notes
        }</span>

        <span class="cov0" title="0">if updates.Tags != nil </span><span class="cov0" title="0">{
                favorite.Tags = updates.Tags
        }</span>

        <span class="cov0" title="0">if updates.IsPublic != nil </span><span class="cov0" title="0">{
                favorite.IsPublic = *updates.IsPublic
        }</span>

        <span class="cov0" title="0">favorite.UpdatedAt = &amp;time.Time{}
        *favorite.UpdatedAt = time.Now()

        err = s.favoritesRepo.UpdateFavorite(favorite)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update favorite: %w", err)
        }</span>

        <span class="cov0" title="0">return favorite, nil</span>
}

func (s *FavoritesService) GetFavoriteCategories(userID int, entityType *string) ([]models.FavoriteCategory, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetFavoriteCategories(userID, entityType)
}</span>

func (s *FavoritesService) CreateFavoriteCategory(userID int, category *models.FavoriteCategory) (*models.FavoriteCategory, error) <span class="cov0" title="0">{
        category.UserID = userID
        category.CreatedAt = time.Now()

        id, err := s.favoritesRepo.CreateFavoriteCategory(category)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create category: %w", err)
        }</span>

        <span class="cov0" title="0">category.ID = id
        return category, nil</span>
}

func (s *FavoritesService) UpdateFavoriteCategory(userID int, categoryID int, updates *models.UpdateFavoriteCategoryRequest) (*models.FavoriteCategory, error) <span class="cov0" title="0">{
        category, err := s.favoritesRepo.GetFavoriteCategoryByID(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("category not found: %w", err)
        }</span>

        <span class="cov0" title="0">if category.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unauthorized to update this category")
        }</span>

        <span class="cov0" title="0">if updates.Name != "" </span><span class="cov0" title="0">{
                category.Name = updates.Name
        }</span>

        <span class="cov0" title="0">if updates.Description != nil </span><span class="cov0" title="0">{
                category.Description = updates.Description
        }</span>

        <span class="cov0" title="0">if updates.Color != nil </span><span class="cov0" title="0">{
                category.Color = updates.Color
        }</span>

        <span class="cov0" title="0">if updates.Icon != nil </span><span class="cov0" title="0">{
                category.Icon = updates.Icon
        }</span>

        <span class="cov0" title="0">if updates.IsPublic != nil </span><span class="cov0" title="0">{
                category.IsPublic = *updates.IsPublic
        }</span>

        <span class="cov0" title="0">category.UpdatedAt = &amp;time.Time{}
        *category.UpdatedAt = time.Now()

        err = s.favoritesRepo.UpdateFavoriteCategory(category)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update category: %w", err)
        }</span>

        <span class="cov0" title="0">return category, nil</span>
}

func (s *FavoritesService) DeleteFavoriteCategory(userID int, categoryID int) error <span class="cov0" title="0">{
        category, err := s.favoritesRepo.GetFavoriteCategoryByID(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("category not found: %w", err)
        }</span>

        <span class="cov0" title="0">if category.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("unauthorized to delete this category")
        }</span>

        <span class="cov0" title="0">favoritesCount, err := s.favoritesRepo.CountFavoritesByCategory(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check category usage: %w", err)
        }</span>

        <span class="cov0" title="0">if favoritesCount &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot delete category with existing favorites")
        }</span>

        <span class="cov0" title="0">return s.favoritesRepo.DeleteFavoriteCategory(categoryID)</span>
}

func (s *FavoritesService) GetPublicFavorites(entityType *string, category *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetPublicFavorites(entityType, category, limit, offset)
}</span>

func (s *FavoritesService) SearchFavorites(userID int, query string, entityType *string, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.SearchFavorites(userID, query, entityType, limit, offset)
}</span>

func (s *FavoritesService) GetFavoriteStatistics(userID int) (*models.FavoriteStatistics, error) <span class="cov0" title="0">{
        stats := &amp;models.FavoriteStatistics{
                UserID: userID,
        }

        totalCount, err := s.favoritesRepo.CountUserFavorites(userID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total favorites count: %w", err)
        }</span>
        <span class="cov0" title="0">stats.TotalFavorites = totalCount

        entityTypeCounts, err := s.favoritesRepo.GetFavoritesCountByEntityType(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get entity type counts: %w", err)
        }</span>
        <span class="cov0" title="0">stats.FavoritesByEntityType = entityTypeCounts

        categoryCounts, err := s.favoritesRepo.GetFavoritesCountByCategory(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get category counts: %w", err)
        }</span>
        <span class="cov0" title="0">stats.FavoritesByCategory = categoryCounts

        recentFavorites, err := s.favoritesRepo.GetRecentFavorites(userID, 5)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get recent favorites: %w", err)
        }</span>
        <span class="cov0" title="0">stats.RecentFavorites = recentFavorites

        return stats, nil</span>
}

func (s *FavoritesService) GetRecommendedFavorites(userID int, limit int) ([]models.RecommendedFavorite, error) <span class="cov0" title="0">{
        userFavorites, err := s.favoritesRepo.GetUserFavorites(userID, nil, nil, 100, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user favorites: %w", err)
        }</span>

        <span class="cov0" title="0">var entityTypes []string
        var categories []string

        for _, favorite := range userFavorites </span><span class="cov0" title="0">{
                entityTypes = append(entityTypes, favorite.EntityType)
                if favorite.Category != nil </span><span class="cov0" title="0">{
                        categories = append(categories, *favorite.Category)
                }</span>
        }

        <span class="cov0" title="0">entityTypes = s.removeDuplicateStrings(entityTypes)
        categories = s.removeDuplicateStrings(categories)

        var recommendations []models.RecommendedFavorite

        for _, entityType := range entityTypes </span><span class="cov0" title="0">{
                similarFavorites, err := s.favoritesRepo.GetSimilarFavorites(userID, entityType, limit/len(entityTypes))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, favorite := range similarFavorites </span><span class="cov0" title="0">{
                        recommendation := models.RecommendedFavorite{
                                Favorite:        favorite,
                                RecommendReason: fmt.Sprintf("Based on your interest in %s", entityType),
                                RecommendScore:  0.8,
                                RecommendedAt:   time.Now(),
                        }
                        recommendations = append(recommendations, recommendation)
                }</span>
        }

        <span class="cov0" title="0">if len(recommendations) &gt; limit </span><span class="cov0" title="0">{
                recommendations = recommendations[:limit]
        }</span>

        <span class="cov0" title="0">return recommendations, nil</span>
}

func (s *FavoritesService) ShareFavorite(userID int, favoriteID int, shareWith []int, permissions models.SharePermissions) (*models.FavoriteShare, error) <span class="cov0" title="0">{
        favorite, err := s.favoritesRepo.GetFavoriteByID(favoriteID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("favorite not found: %w", err)
        }</span>

        <span class="cov0" title="0">if favorite.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unauthorized to share this favorite")
        }</span>

        <span class="cov0" title="0">share := &amp;models.FavoriteShare{
                FavoriteID:   favoriteID,
                SharedByUser: userID,
                SharedWith:   shareWith,
                Permissions:  permissions,
                CreatedAt:    time.Now(),
                IsActive:     true,
        }

        id, err := s.favoritesRepo.CreateFavoriteShare(share)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create favorite share: %w", err)
        }</span>

        <span class="cov0" title="0">share.ID = id
        return share, nil</span>
}

func (s *FavoritesService) GetSharedFavorites(userID int, limit, offset int) ([]models.Favorite, error) <span class="cov0" title="0">{
        return s.favoritesRepo.GetSharedFavorites(userID, limit, offset)
}</span>

func (s *FavoritesService) RevokeFavoriteShare(userID int, shareID int) error <span class="cov0" title="0">{
        share, err := s.favoritesRepo.GetFavoriteShareByID(shareID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("share not found: %w", err)
        }</span>

        <span class="cov0" title="0">if share.SharedByUser != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("unauthorized to revoke this share")
        }</span>

        <span class="cov0" title="0">return s.favoritesRepo.RevokeFavoriteShare(shareID)</span>
}

func (s *FavoritesService) BulkAddFavorites(userID int, favorites []models.BulkFavoriteRequest) ([]models.Favorite, error) <span class="cov0" title="0">{
        var results []models.Favorite
        var errors []error

        for _, req := range favorites </span><span class="cov0" title="0">{
                favorite := &amp;models.Favorite{
                        EntityType: req.EntityType,
                        EntityID:   req.EntityID,
                        Category:   req.Category,
                        Notes:      req.Notes,
                        Tags:       req.Tags,
                        IsPublic:   req.IsPublic,
                }

                result, err := s.AddFavorite(userID, favorite)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, err)
                        continue</span>
                }

                <span class="cov0" title="0">results = append(results, *result)</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 &amp;&amp; len(results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add any favorites: %v", errors)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

func (s *FavoritesService) BulkRemoveFavorites(userID int, favorites []models.BulkFavoriteRemoveRequest) error <span class="cov0" title="0">{
        var errors []error

        for _, req := range favorites </span><span class="cov0" title="0">{
                err := s.RemoveFavorite(userID, req.EntityType, req.EntityID)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, err)
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove some favorites: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *FavoritesService) ExportFavorites(userID int, format string) ([]byte, error) <span class="cov0" title="0">{
        favorites, err := s.favoritesRepo.GetUserFavorites(userID, nil, nil, 10000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user favorites: %w", err)
        }</span>

        <span class="cov0" title="0">switch format </span>{
        case "json":<span class="cov0" title="0">
                return s.exportFavoritesToJSON(favorites)</span>
        case "csv":<span class="cov0" title="0">
                return s.exportFavoritesToCSV(favorites)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported export format: %s", format)</span>
        }
}

func (s *FavoritesService) ImportFavorites(userID int, data []byte, format string) ([]models.Favorite, error) <span class="cov0" title="0">{
        switch format </span>{
        case "json":<span class="cov0" title="0">
                return s.importFavoritesFromJSON(userID, data)</span>
        case "csv":<span class="cov0" title="0">
                return s.importFavoritesFromCSV(userID, data)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported import format: %s", format)</span>
        }
}

func (s *FavoritesService) removeDuplicateStrings(slice []string) []string <span class="cov0" title="0">{
        keys := make(map[string]bool)
        var result []string

        for _, item := range slice </span><span class="cov0" title="0">{
                if !keys[item] </span><span class="cov0" title="0">{
                        keys[item] = true
                        result = append(result, item)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func (s *FavoritesService) exportFavoritesToJSON(favorites []models.Favorite) ([]byte, error) <span class="cov0" title="0">{
        // Create export structure with metadata
        export := struct {
                Version     string              `json:"version"`
                ExportedAt  time.Time           `json:"exported_at"`
                Count       int                 `json:"count"`
                Favorites   []models.Favorite   `json:"favorites"`
                Categories  []map[string]interface{} `json:"categories,omitempty"`
        }{
                Version:    "1.0",
                ExportedAt: time.Now(),
                Count:      len(favorites),
                Favorites:  favorites,
        }

        // Marshal to JSON
        data, err := json.MarshalIndent(export, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal favorites to JSON: %w", err)
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

func (s *FavoritesService) exportFavoritesToCSV(favorites []models.Favorite) ([]byte, error) <span class="cov0" title="0">{
        // Create CSV writer
        buffer := &amp;bytes.Buffer{}
        writer := csv.NewWriter(buffer)

        // Write header
        headers := []string{
                "ID", "UserID", "EntityType", "EntityID", "Category", "Notes", 
                "Tags", "IsPublic", "CreatedAt", "UpdatedAt",
        }
        if err := writer.Write(headers); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write CSV headers: %w", err)
        }</span>

        // Write data rows
        <span class="cov0" title="0">for _, favorite := range favorites </span><span class="cov0" title="0">{
                // Handle nullable fields
                category := ""
                if favorite.Category != nil </span><span class="cov0" title="0">{
                        category = *favorite.Category
                }</span>

                <span class="cov0" title="0">notes := ""
                if favorite.Notes != nil </span><span class="cov0" title="0">{
                        notes = *favorite.Notes
                }</span>

                <span class="cov0" title="0">tags := ""
                if favorite.Tags != nil </span><span class="cov0" title="0">{
                        tags = fmt.Sprintf("%v", *favorite.Tags)
                }</span>

                <span class="cov0" title="0">updatedAt := ""
                if favorite.UpdatedAt != nil </span><span class="cov0" title="0">{
                        updatedAt = favorite.UpdatedAt.Format(time.RFC3339)
                }</span>

                <span class="cov0" title="0">record := []string{
                        fmt.Sprintf("%d", favorite.ID),
                        fmt.Sprintf("%d", favorite.UserID),
                        favorite.EntityType,
                        fmt.Sprintf("%d", favorite.EntityID),
                        category,
                        notes,
                        tags,
                        fmt.Sprintf("%t", favorite.IsPublic),
                        favorite.CreatedAt.Format(time.RFC3339),
                        updatedAt,
                }

                if err := writer.Write(record); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write CSV record: %w", err)
                }</span>
        }

        // Flush writer
        <span class="cov0" title="0">writer.Flush()
        if err := writer.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CSV writer error: %w", err)
        }</span>

        <span class="cov0" title="0">return buffer.Bytes(), nil</span>
}

func (s *FavoritesService) importFavoritesFromJSON(userID int, data []byte) ([]models.Favorite, error) <span class="cov0" title="0">{
        // Parse import data
        var importData struct {
                Version     string              `json:"version"`
                ExportedAt  time.Time           `json:"exported_at"`
                Count       int                 `json:"count"`
                Favorites   []models.Favorite   `json:"favorites"`
        }

        if err := json.Unmarshal(data, &amp;importData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse JSON data: %w", err)
        }</span>

        <span class="cov0" title="0">if len(importData.Favorites) == 0 </span><span class="cov0" title="0">{
                return []models.Favorite{}, nil
        }</span>

        // Process each favorite
        <span class="cov0" title="0">var importedFavorites []models.Favorite
        var errors []error

        for _, fav := range importData.Favorites </span><span class="cov0" title="0">{
                // Create new favorite with current user ID
                newFavorite := &amp;models.Favorite{
                        UserID:     userID, // Override with current user
                        EntityType: fav.EntityType,
                        EntityID:   fav.EntityID,
                        Category:   fav.Category,
                        Notes:      fav.Notes,
                        Tags:       fav.Tags,
                        IsPublic:   fav.IsPublic,
                }

                // Try to add favorite (will skip duplicates)
                result, err := s.AddFavorite(userID, newFavorite)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to import favorite %s %d: %w", fav.EntityType, fav.EntityID, err))
                        continue</span>
                }

                <span class="cov0" title="0">importedFavorites = append(importedFavorites, *result)</span>
        }

        // If all failed, return error
        <span class="cov0" title="0">if len(importedFavorites) == 0 &amp;&amp; len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to import any favorites: %v", errors)
        }</span>

        <span class="cov0" title="0">return importedFavorites, nil</span>
}

func (s *FavoritesService) importFavoritesFromCSV(userID int, data []byte) ([]models.Favorite, error) <span class="cov0" title="0">{
        // Parse CSV data
        reader := csv.NewReader(bytes.NewReader(data))
        
        // Read header
        headers, err := reader.Read()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read CSV headers: %w", err)
        }</span>

        // Validate headers (basic check)
        <span class="cov0" title="0">if len(headers) &lt; 9 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid CSV format: expected at least 9 columns, got %d", len(headers))
        }</span>

        // Read all records
        <span class="cov0" title="0">records, err := reader.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read CSV records: %w", err)
        }</span>

        <span class="cov0" title="0">var importedFavorites []models.Favorite
        var errors []error

        for i, record := range records </span><span class="cov0" title="0">{
                if len(record) &lt; 9 </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("record %d: insufficient columns", i+1))
                        continue</span>
                }

                // Parse entity type and ID
                <span class="cov0" title="0">entityType := record[2]
                entityIDStr := record[3]

                var entityID int
                if _, err := fmt.Sscanf(entityIDStr, "%d", &amp;entityID); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("record %d: invalid entity ID: %s", i+1, entityIDStr))
                        continue</span>
                }

                // Parse optional fields
                <span class="cov0" title="0">var category *string
                if record[4] != "" </span><span class="cov0" title="0">{
                        category = &amp;record[4]
                }</span>

                <span class="cov0" title="0">var notes *string
                if record[5] != "" </span><span class="cov0" title="0">{
                        notes = &amp;record[5]
                }</span>

                <span class="cov0" title="0">var tags *[]string
                if record[6] != "" </span><span class="cov0" title="0">{
                        // Simple comma-separated tags parsing
                        tagList := strings.Split(record[6], ",")
                        for i := range tagList </span><span class="cov0" title="0">{
                                tagList[i] = strings.TrimSpace(tagList[i])
                        }</span>
                        <span class="cov0" title="0">tags = &amp;tagList</span>
                }

                <span class="cov0" title="0">var isPublic bool
                if record[7] != "" </span><span class="cov0" title="0">{
                        if _, err := fmt.Sscanf(record[7], "%t", &amp;isPublic); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Errorf("record %d: invalid is_public value: %s", i+1, record[7]))
                                continue</span>
                        }
                }

                // Create favorite
                <span class="cov0" title="0">favorite := &amp;models.Favorite{
                        UserID:     userID,
                        EntityType: entityType,
                        EntityID:   entityID,
                        Category:   category,
                        Notes:      notes,
                        Tags:       tags,
                        IsPublic:   isPublic,
                }

                // Add favorite
                result, err := s.AddFavorite(userID, favorite)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("record %d: failed to add favorite: %w", i+1, err))
                        continue</span>
                }

                <span class="cov0" title="0">importedFavorites = append(importedFavorites, *result)</span>
        }

        // If all failed, return error
        <span class="cov0" title="0">if len(importedFavorites) == 0 &amp;&amp; len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to import any favorites: %v", errors)
        }</span>

        <span class="cov0" title="0">return importedFavorites, nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package services

import (
        "archive/zip"
        "bytes"
        "compress/gzip"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type LogManagementService struct {
        logRepo       *repository.LogManagementRepository
        config        *LogManagementConfig
        logCollectors map[string]LogCollector
}

type LogManagementConfig struct {
        LogDirectory         string   `json:"log_directory"`
        MaxLogSize           int64    `json:"max_log_size"`        // in bytes
        MaxLogFiles          int      `json:"max_log_files"`       // per component
        RetentionDays        int      `json:"retention_days"`      // how long to keep logs
        CompressionEnabled   bool     `json:"compression_enabled"` // compress old logs
        RealTimeLogging      bool     `json:"real_time_logging"`   // enable real-time log streaming
        LogLevels            []string `json:"log_levels"`          // enabled log levels
        ComponentFilters     []string `json:"component_filters"`   // enabled components
        AutoCleanup          bool     `json:"auto_cleanup"`        // automatically cleanup old logs
        MaxShareDuration     int      `json:"max_share_duration"`  // hours
        AllowExternalSharing bool     `json:"allow_external_sharing"`
}

type LogCollector interface {
        CollectLogs() ([]*models.LogEntry, error)
        GetLogPath() string
        GetComponentName() string
}

type FileLogCollector struct {
        logPath       string
        componentName string
}

type DatabaseLogCollector struct {
        logRepo       *repository.LogManagementRepository
        componentName string
}

func NewLogManagementService(logRepo *repository.LogManagementRepository) *LogManagementService <span class="cov0" title="0">{
        config := &amp;LogManagementConfig{
                LogDirectory:         "/var/log/catalogizer",
                MaxLogSize:           100 * 1024 * 1024, // 100MB
                MaxLogFiles:          10,
                RetentionDays:        30,
                CompressionEnabled:   true,
                RealTimeLogging:      true,
                LogLevels:            []string{"error", "warning", "info", "debug"},
                ComponentFilters:     []string{"api", "auth", "sync", "conversion", "stress_test"},
                AutoCleanup:          true,
                MaxShareDuration:     24, // 24 hours
                AllowExternalSharing: false,
        }

        service := &amp;LogManagementService{
                logRepo:       logRepo,
                config:        config,
                logCollectors: make(map[string]LogCollector),
        }

        // Initialize default collectors
        service.initializeCollectors()

        return service
}</span>

func (s *LogManagementService) initializeCollectors() <span class="cov0" title="0">{
        // File-based collectors
        components := []string{"api", "auth", "sync", "conversion", "stress_test", "error_reporting"}
        for _, component := range components </span><span class="cov0" title="0">{
                logPath := filepath.Join(s.config.LogDirectory, component+".log")
                s.logCollectors[component] = &amp;FileLogCollector{
                        logPath:       logPath,
                        componentName: component,
                }
        }</span>

        // Database collector for application logs
        <span class="cov0" title="0">s.logCollectors["database"] = &amp;DatabaseLogCollector{
                logRepo:       s.logRepo,
                componentName: "database",
        }</span>
}

func (s *LogManagementService) CollectLogs(userID int, request *models.LogCollectionRequest) (*models.LogCollection, error) <span class="cov0" title="0">{
        collection := &amp;models.LogCollection{
                UserID:      userID,
                Name:        request.Name,
                Description: request.Description,
                Components:  request.Components,
                LogLevel:    request.LogLevel,
                StartTime:   request.StartTime,
                EndTime:     request.EndTime,
                CreatedAt:   time.Now(),
                Status:      models.LogCollectionStatusInProgress,
                Filters:     request.Filters,
        }

        // Create the collection record
        if err := s.logRepo.CreateLogCollection(collection); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log collection: %w", err)
        }</span>

        // Start collection process
        <span class="cov0" title="0">go s.performLogCollection(collection)

        return collection, nil</span>
}

func (s *LogManagementService) performLogCollection(collection *models.LogCollection) <span class="cov0" title="0">{
        var allEntries []*models.LogEntry

        // Collect logs from each component
        for _, component := range collection.Components </span><span class="cov0" title="0">{
                collector, exists := s.logCollectors[component]
                if !exists </span><span class="cov0" title="0">{
                        s.logError(collection.ID, fmt.Sprintf("Unknown component: %s", component))
                        continue</span>
                }

                <span class="cov0" title="0">entries, err := collector.CollectLogs()
                if err != nil </span><span class="cov0" title="0">{
                        s.logError(collection.ID, fmt.Sprintf("Failed to collect logs from %s: %v", component, err))
                        continue</span>
                }

                // Filter entries
                <span class="cov0" title="0">filteredEntries := s.filterLogEntries(entries, collection)
                allEntries = append(allEntries, filteredEntries...)</span>
        }

        // Sort entries by timestamp
        <span class="cov0" title="0">sort.Slice(allEntries, func(i, j int) bool </span><span class="cov0" title="0">{
                return allEntries[i].Timestamp.Before(allEntries[j].Timestamp)
        }</span>)

        // Store collected entries
        <span class="cov0" title="0">for _, entry := range allEntries </span><span class="cov0" title="0">{
                entry.CollectionID = collection.ID
                if err := s.logRepo.CreateLogEntry(entry); err != nil </span><span class="cov0" title="0">{
                        s.logError(collection.ID, fmt.Sprintf("Failed to store log entry: %v", err))
                }</span>
        }

        // Update collection status
        <span class="cov0" title="0">collection.Status = models.LogCollectionStatusCompleted
        collection.CompletedAt = &amp;[]time.Time{time.Now()}[0]
        collection.EntryCount = len(allEntries)

        if err := s.logRepo.UpdateLogCollection(collection); err != nil </span><span class="cov0" title="0">{
                s.logError(collection.ID, fmt.Sprintf("Failed to update collection status: %v", err))
        }</span>
}

func (s *LogManagementService) GetLogCollection(id int, userID int) (*models.LogCollection, error) <span class="cov0" title="0">{
        collection, err := s.logRepo.GetLogCollection(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log collection: %w", err)
        }</span>

        <span class="cov0" title="0">if collection.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">return collection, nil</span>
}

func (s *LogManagementService) GetLogCollectionsByUser(userID int, limit, offset int) ([]*models.LogCollection, error) <span class="cov0" title="0">{
        return s.logRepo.GetLogCollectionsByUser(userID, limit, offset)
}</span>

func (s *LogManagementService) GetLogEntries(collectionID int, userID int, filters *models.LogEntryFilters) ([]*models.LogEntry, error) <span class="cov0" title="0">{
        // Verify user has access to collection
        collection, err := s.GetLogCollection(collectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if collection.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">return s.logRepo.GetLogEntries(collectionID, filters)</span>
}

func (s *LogManagementService) CreateLogShare(userID int, request *models.LogShareRequest) (*models.LogShare, error) <span class="cov0" title="0">{
        // Verify user has access to collection
        collection, err := s.GetLogCollection(request.CollectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if collection.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access denied")
        }</span>

        // Create share
        <span class="cov0" title="0">share := &amp;models.LogShare{
                CollectionID: request.CollectionID,
                UserID:       userID,
                ShareToken:   s.generateShareToken(),
                ShareType:    request.ShareType,
                ExpiresAt:    time.Now().Add(time.Duration(s.config.MaxShareDuration) * time.Hour),
                CreatedAt:    time.Now(),
                IsActive:     true,
                Permissions:  request.Permissions,
                Recipients:   request.Recipients,
        }

        if request.ExpiresAt != nil &amp;&amp; request.ExpiresAt.Before(share.ExpiresAt) </span><span class="cov0" title="0">{
                share.ExpiresAt = *request.ExpiresAt
        }</span>

        <span class="cov0" title="0">if err := s.logRepo.CreateLogShare(share); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log share: %w", err)
        }</span>

        <span class="cov0" title="0">return share, nil</span>
}

func (s *LogManagementService) GetLogShare(token string) (*models.LogShare, error) <span class="cov0" title="0">{
        share, err := s.logRepo.GetLogShareByToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log share: %w", err)
        }</span>

        <span class="cov0" title="0">if !share.IsActive || time.Now().After(share.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("share expired or inactive")
        }</span>

        <span class="cov0" title="0">return share, nil</span>
}

func (s *LogManagementService) RevokeLogShare(id int, userID int) error <span class="cov0" title="0">{
        share, err := s.logRepo.GetLogShare(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get log share: %w", err)
        }</span>

        // Verify user owns the shared collection
        <span class="cov0" title="0">collection, err := s.GetLogCollection(share.CollectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if collection.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("access denied")
        }</span>

        <span class="cov0" title="0">share.IsActive = false
        return s.logRepo.UpdateLogShare(share)</span>
}

func (s *LogManagementService) ExportLogs(collectionID int, userID int, format string) ([]byte, error) <span class="cov0" title="0">{
        // Verify access
        _, err := s.GetLogCollection(collectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get log entries
        <span class="cov0" title="0">entries, err := s.logRepo.GetLogEntries(collectionID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log entries: %w", err)
        }</span>

        <span class="cov0" title="0">switch format </span>{
        case "json":<span class="cov0" title="0">
                return json.MarshalIndent(entries, "", "  ")</span>
        case "csv":<span class="cov0" title="0">
                return s.exportToCSV(entries)</span>
        case "txt":<span class="cov0" title="0">
                return s.exportToText(entries)</span>
        case "zip":<span class="cov0" title="0">
                return s.exportToZip(entries)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported format: %s", format)</span>
        }
}

func (s *LogManagementService) StreamLogs(userID int, filters *models.LogStreamFilters) (&lt;-chan *models.LogEntry, error) <span class="cov0" title="0">{
        if !s.config.RealTimeLogging </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("real-time logging is disabled")
        }</span>

        // Create a channel for streaming
        <span class="cov0" title="0">logChannel := make(chan *models.LogEntry, 100)

        // Start streaming goroutine
        go s.streamLogEntries(logChannel, filters)

        return logChannel, nil</span>
}

func (s *LogManagementService) AnalyzeLogs(collectionID int, userID int) (*models.LogAnalysis, error) <span class="cov0" title="0">{
        // Verify access
        _, err := s.GetLogCollection(collectionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get log entries
        <span class="cov0" title="0">entries, err := s.logRepo.GetLogEntries(collectionID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get log entries: %w", err)
        }</span>

        <span class="cov0" title="0">analysis := &amp;models.LogAnalysis{
                CollectionID:       collectionID,
                TotalEntries:       len(entries),
                EntriesByLevel:     make(map[string]int),
                EntriesByComponent: make(map[string]int),
                ErrorPatterns:      make(map[string]int),
                TimeRange:          &amp;models.TimeRange{},
        }

        if len(entries) == 0 </span><span class="cov0" title="0">{
                return analysis, nil
        }</span>

        // Analyze entries
        <span class="cov0" title="0">analysis.TimeRange.Start = entries[0].Timestamp
        analysis.TimeRange.End = entries[len(entries)-1].Timestamp

        for _, entry := range entries </span><span class="cov0" title="0">{
                // Count by level
                analysis.EntriesByLevel[entry.Level]++

                // Count by component
                analysis.EntriesByComponent[entry.Component]++

                // Extract error patterns
                if entry.Level == "error" || entry.Level == "fatal" </span><span class="cov0" title="0">{
                        pattern := s.extractErrorPattern(entry.Message)
                        analysis.ErrorPatterns[pattern]++
                }</span>
        }

        // Generate insights
        <span class="cov0" title="0">analysis.Insights = s.generateInsights(entries, analysis)

        return analysis, nil</span>
}

func (s *LogManagementService) CleanupOldLogs() error <span class="cov0" title="0">{
        if !s.config.AutoCleanup </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cutoff := time.Now().AddDate(0, 0, -s.config.RetentionDays)

        // Cleanup collections
        if err := s.logRepo.CleanupOldCollections(cutoff); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup old collections: %w", err)
        }</span>

        // Cleanup shares
        <span class="cov0" title="0">if err := s.logRepo.CleanupExpiredShares(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup expired shares: %w", err)
        }</span>

        // Cleanup physical log files
        <span class="cov0" title="0">return s.cleanupPhysicalLogFiles(cutoff)</span>
}

func (s *LogManagementService) GetConfiguration() *LogManagementConfig <span class="cov0" title="0">{
        return s.config
}</span>

func (s *LogManagementService) UpdateConfiguration(config *LogManagementConfig) error <span class="cov0" title="0">{
        s.config = config
        s.initializeCollectors() // Re-initialize collectors with new config
        return nil
}</span>

func (s *LogManagementService) GetLogStatistics(userID int) (*models.LogStatistics, error) <span class="cov0" title="0">{
        return s.logRepo.GetLogStatistics(userID)
}</span>

// Helper methods

func (s *LogManagementService) filterLogEntries(entries []*models.LogEntry, collection *models.LogCollection) []*models.LogEntry <span class="cov0" title="0">{
        var filtered []*models.LogEntry

        for _, entry := range entries </span><span class="cov0" title="0">{
                // Filter by time range
                if collection.StartTime != nil &amp;&amp; entry.Timestamp.Before(*collection.StartTime) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if collection.EndTime != nil &amp;&amp; entry.Timestamp.After(*collection.EndTime) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Filter by log level
                <span class="cov0" title="0">if collection.LogLevel != "" &amp;&amp; !s.isLogLevelIncluded(entry.Level, collection.LogLevel) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Apply custom filters
                <span class="cov0" title="0">if collection.Filters != nil &amp;&amp; !s.matchesFilters(entry, collection.Filters) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">filtered = append(filtered, entry)</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

func (s *LogManagementService) isLogLevelIncluded(entryLevel, filterLevel string) bool <span class="cov0" title="0">{
        levels := map[string]int{
                "debug":   0,
                "info":    1,
                "warning": 2,
                "error":   3,
                "fatal":   4,
        }

        entryLevelNum, exists := levels[strings.ToLower(entryLevel)]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">filterLevelNum, exists := levels[strings.ToLower(filterLevel)]
        if !exists </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return entryLevelNum &gt;= filterLevelNum</span>
}

func (s *LogManagementService) matchesFilters(entry *models.LogEntry, filters map[string]interface{}) bool <span class="cov0" title="0">{
        for key, value := range filters </span><span class="cov0" title="0">{
                switch key </span>{
                case "message_contains":<span class="cov0" title="0">
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                if !strings.Contains(strings.ToLower(entry.Message), strings.ToLower(str)) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                case "component":<span class="cov0" title="0">
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                if entry.Component != str </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return true</span>
}

func (s *LogManagementService) generateShareToken() string <span class="cov0" title="0">{
        // Generate a secure random token
        return fmt.Sprintf("log_share_%d_%d", time.Now().Unix(), time.Now().Nanosecond())
}</span>

func (s *LogManagementService) exportToCSV(entries []*models.LogEntry) ([]byte, error) <span class="cov0" title="0">{
        var buffer bytes.Buffer

        // Write CSV header
        buffer.WriteString("Timestamp,Level,Component,Message,Context\n")

        // Write entries
        for _, entry := range entries </span><span class="cov0" title="0">{
                contextJSON, _ := json.Marshal(entry.Context)
                buffer.WriteString(fmt.Sprintf("%s,%s,%s,\"%s\",\"%s\"\n",
                        entry.Timestamp.Format(time.RFC3339),
                        entry.Level,
                        entry.Component,
                        strings.ReplaceAll(entry.Message, "\"", "\"\""),
                        string(contextJSON)))
        }</span>

        <span class="cov0" title="0">return buffer.Bytes(), nil</span>
}

func (s *LogManagementService) exportToText(entries []*models.LogEntry) ([]byte, error) <span class="cov0" title="0">{
        var buffer bytes.Buffer

        for _, entry := range entries </span><span class="cov0" title="0">{
                buffer.WriteString(fmt.Sprintf("[%s] [%s] [%s] %s\n",
                        entry.Timestamp.Format(time.RFC3339),
                        strings.ToUpper(entry.Level),
                        entry.Component,
                        entry.Message))
        }</span>

        <span class="cov0" title="0">return buffer.Bytes(), nil</span>
}

func (s *LogManagementService) exportToZip(entries []*models.LogEntry) ([]byte, error) <span class="cov0" title="0">{
        var buffer bytes.Buffer
        zipWriter := zip.NewWriter(&amp;buffer)

        // Create JSON file
        jsonData, err := json.MarshalIndent(entries, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">jsonFile, err := zipWriter.Create("logs.json")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">jsonFile.Write(jsonData)

        // Create text file
        textData, err := s.exportToText(entries)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">textFile, err := zipWriter.Create("logs.txt")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">textFile.Write(textData)

        zipWriter.Close()
        return buffer.Bytes(), nil</span>
}

func (s *LogManagementService) streamLogEntries(channel chan&lt;- *models.LogEntry, filters *models.LogStreamFilters) <span class="cov0" title="0">{
        defer close(channel)

        // This is a simplified implementation
        // In a real system, you would tail log files or watch for new database entries
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0"></span>
                        // Check for new log entries and send them to the channel
                        // This is a placeholder implementation
                }
        }
}

func (s *LogManagementService) extractErrorPattern(message string) string <span class="cov0" title="0">{
        // Simple pattern extraction - remove specific details to group similar errors
        // This is a simplified implementation
        words := strings.Fields(message)
        if len(words) &gt; 5 </span><span class="cov0" title="0">{
                return strings.Join(words[:5], " ") + "..."
        }</span>
        <span class="cov0" title="0">return message</span>
}

func (s *LogManagementService) generateInsights(entries []*models.LogEntry, analysis *models.LogAnalysis) []string <span class="cov0" title="0">{
        var insights []string

        // Check error rate
        errorCount := analysis.EntriesByLevel["error"] + analysis.EntriesByLevel["fatal"]
        errorRate := float64(errorCount) / float64(analysis.TotalEntries) * 100

        if errorRate &gt; 10 </span><span class="cov0" title="0">{
                insights = append(insights, fmt.Sprintf("High error rate detected: %.1f%%", errorRate))
        }</span>

        // Check for component with most errors
        <span class="cov0" title="0">maxErrors := 0
        maxComponent := ""
        for component, count := range analysis.EntriesByComponent </span><span class="cov0" title="0">{
                if count &gt; maxErrors </span><span class="cov0" title="0">{
                        maxErrors = count
                        maxComponent = component
                }</span>
        }

        <span class="cov0" title="0">if maxComponent != "" </span><span class="cov0" title="0">{
                insights = append(insights, fmt.Sprintf("Component '%s' generated the most log entries (%d)", maxComponent, maxErrors))
        }</span>

        <span class="cov0" title="0">return insights</span>
}

func (s *LogManagementService) cleanupPhysicalLogFiles(cutoff time.Time) error <span class="cov0" title="0">{
        return filepath.Walk(s.config.LogDirectory, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !info.IsDir() &amp;&amp; info.ModTime().Before(cutoff) </span><span class="cov0" title="0">{
                        // Compress old log files if compression is enabled
                        if s.config.CompressionEnabled &amp;&amp; !strings.HasSuffix(path, ".gz") </span><span class="cov0" title="0">{
                                if err := s.compressLogFile(path); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov0" title="0">return nil</span>
        })
}

func (s *LogManagementService) compressLogFile(path string) error <span class="cov0" title="0">{
        input, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer input.Close()

        output, err := os.Create(path + ".gz")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer output.Close()

        gzipWriter := gzip.NewWriter(output)
        defer gzipWriter.Close()

        _, err = io.Copy(gzipWriter, input)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Remove original file after successful compression
        <span class="cov0" title="0">return os.Remove(path)</span>
}

func (s *LogManagementService) logError(collectionID int, message string) <span class="cov0" title="0">{
        // Log error to the system log (simplified implementation)
        fmt.Printf("[ERROR] Collection %d: %s\n", collectionID, message)
}</span>

// LogCollector implementations

func (c *FileLogCollector) CollectLogs() ([]*models.LogEntry, error) <span class="cov0" title="0">{
        file, err := os.Open(c.logPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var entries []*models.LogEntry
        // This is a simplified implementation
        // In reality, you would parse the log file format

        return entries, nil</span>
}

func (c *FileLogCollector) GetLogPath() string <span class="cov0" title="0">{
        return c.logPath
}</span>

func (c *FileLogCollector) GetComponentName() string <span class="cov0" title="0">{
        return c.componentName
}</span>

func (c *DatabaseLogCollector) CollectLogs() ([]*models.LogEntry, error) <span class="cov0" title="0">{
        // Collect logs from database
        return c.logRepo.GetRecentLogEntries(c.componentName, 1000)
}</span>

func (c *DatabaseLogCollector) GetLogPath() string <span class="cov0" title="0">{
        return "database"
}</span>

func (c *DatabaseLogCollector) GetComponentName() string <span class="cov0" title="0">{
        return c.componentName
}</span>
</pre>
		
		<pre class="file" id="file102" style="display: none">package services

import (
        "bytes"
        "encoding/json"
        "fmt"
        "html/template"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"

        "github.com/jung-kurt/gofpdf"
)

type ReportingService struct {
        analyticsRepo *repository.AnalyticsRepository
        userRepo      *repository.UserRepository
}

func NewReportingService(analyticsRepo *repository.AnalyticsRepository, userRepo *repository.UserRepository) *ReportingService <span class="cov0" title="0">{
        return &amp;ReportingService{
                analyticsRepo: analyticsRepo,
                userRepo:      userRepo,
        }
}</span>

func (s *ReportingService) GenerateReport(reportType string, format string, params map[string]interface{}) (*models.GeneratedReport, error) <span class="cov0" title="0">{
        var data interface{}
        var err error

        switch reportType </span>{
        case "user_analytics":<span class="cov0" title="0">
                data, err = s.generateUserAnalyticsData(params)</span>
        case "system_overview":<span class="cov0" title="0">
                data, err = s.generateSystemOverviewData(params)</span>
        case "media_analytics":<span class="cov0" title="0">
                data, err = s.generateMediaAnalyticsData(params)</span>
        case "user_activity":<span class="cov0" title="0">
                data, err = s.generateUserActivityData(params)</span>
        case "security_audit":<span class="cov0" title="0">
                data, err = s.generateSecurityAuditData(params)</span>
        case "performance_metrics":<span class="cov0" title="0">
                data, err = s.generatePerformanceMetricsData(params)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported report type: %s", reportType)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate report data: %w", err)
        }</span>

        <span class="cov0" title="0">content, err := s.formatReport(data, format, reportType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to format report: %w", err)
        }</span>

        <span class="cov0" title="0">report := &amp;models.GeneratedReport{
                Type:        reportType,
                Format:      format,
                Content:     content,
                GeneratedAt: time.Now(),
                Parameters:  params,
        }

        return report, nil</span>
}

func (s *ReportingService) generateUserAnalyticsData(params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        userID, ok := params["user_id"].(int)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user_id parameter required")
        }</span>

        <span class="cov0" title="0">startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">mediaAccessLogs, err := s.analyticsRepo.GetUserMediaAccessLogs(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get media access logs: %w", err)
        }</span>

        <span class="cov0" title="0">events, err := s.analyticsRepo.GetUserEvents(userID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user events: %w", err)
        }</span>

        <span class="cov0" title="0">analytics := &amp;models.UserAnalyticsReport{
                User:               user,
                StartDate:          startDate,
                EndDate:            endDate,
                TotalMediaAccesses: len(mediaAccessLogs),
                TotalEvents:        len(events),
                MediaAccessLogs:    mediaAccessLogs,
                Events:             events,
                AccessPatterns:     s.analyzeUserAccessPatterns(mediaAccessLogs),
                DeviceUsage:        s.analyzeUserDeviceUsage(mediaAccessLogs),
                LocationAnalysis:   s.analyzeUserLocations(mediaAccessLogs),
                TimePatterns:       s.analyzeUserTimePatterns(mediaAccessLogs),
                PopularContent:     s.analyzeUserPopularContent(mediaAccessLogs),
        }

        return analytics, nil</span>
}

func (s *ReportingService) generateSystemOverviewData(params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">totalUsers, err := s.analyticsRepo.GetTotalUsers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total users: %w", err)
        }</span>

        <span class="cov0" title="0">activeUsers, err := s.analyticsRepo.GetActiveUsers(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active users: %w", err)
        }</span>

        <span class="cov0" title="0">totalMediaAccesses, err := s.analyticsRepo.GetTotalMediaAccesses(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total media accesses: %w", err)
        }</span>

        <span class="cov0" title="0">totalEvents, err := s.analyticsRepo.GetTotalEvents(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total events: %w", err)
        }</span>

        <span class="cov0" title="0">topMedia, err := s.analyticsRepo.GetTopAccessedMedia(startDate, endDate, 20)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top media: %w", err)
        }</span>

        <span class="cov0" title="0">userGrowth, err := s.analyticsRepo.GetUserGrowthData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user growth data: %w", err)
        }</span>

        <span class="cov0" title="0">overview := &amp;models.SystemOverviewReport{
                StartDate:          startDate,
                EndDate:            endDate,
                TotalUsers:         totalUsers,
                ActiveUsers:        activeUsers,
                TotalMediaAccesses: totalMediaAccesses,
                TotalEvents:        totalEvents,
                TopAccessedMedia:   topMedia,
                UserGrowthData:     userGrowth,
                SystemHealth:       s.calculateSystemHealth(totalUsers, activeUsers, totalMediaAccesses),
                UsageStatistics:    s.calculateUsageStatistics(startDate, endDate),
                PerformanceMetrics: s.calculatePerformanceMetrics(startDate, endDate),
        }

        return overview, nil</span>
}

func (s *ReportingService) generateMediaAnalyticsData(params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        mediaIDFloat, ok := params["media_id"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("media_id parameter required")
        }</span>
        <span class="cov0" title="0">mediaID := int(mediaIDFloat)

        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">accessLogs, err := s.analyticsRepo.GetMediaAccessLogs(0, &amp;mediaID, 10000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get media access logs: %w", err)
        }</span>

        <span class="cov0" title="0">filteredLogs := s.filterLogsByDateRange(accessLogs, startDate, endDate)

        analytics := &amp;models.MediaAnalyticsReport{
                MediaID:        mediaID,
                StartDate:      startDate,
                EndDate:        endDate,
                TotalAccesses:  len(filteredLogs),
                UniqueUsers:    s.countUniqueUsers(filteredLogs),
                AccessLogs:     filteredLogs,
                AccessPatterns: s.analyzeAccessPatterns(filteredLogs),
                UserEngagement: s.analyzeUserEngagement(filteredLogs),
                GeographicData: s.analyzeGeographicDistribution(filteredLogs),
                DeviceAnalysis: s.analyzeDeviceDistribution(filteredLogs),
                TimeAnalysis:   s.analyzeTimeDistribution(filteredLogs),
        }

        return analytics, nil</span>
}

func (s *ReportingService) generateUserActivityData(params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">allLogs, err := s.analyticsRepo.GetAllMediaAccessLogs(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all media access logs: %w", err)
        }</span>

        <span class="cov0" title="0">userActivity := make(map[int][]models.MediaAccessLog)
        for _, log := range allLogs </span><span class="cov0" title="0">{
                userActivity[log.UserID] = append(userActivity[log.UserID], log)
        }</span>

        <span class="cov0" title="0">var userActivities []models.UserActivitySummary
        for userID, logs := range userActivity </span><span class="cov0" title="0">{
                user, err := s.userRepo.GetByID(userID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">activity := models.UserActivitySummary{
                        User:              user,
                        TotalAccesses:     len(logs),
                        LastActivity:      s.getLastActivityTime(logs),
                        MostActiveHour:    s.getMostActiveHour(logs),
                        PreferredDevices:  s.getPreferredDevices(logs),
                        AccessedLocations: s.getAccessedLocations(logs),
                }

                userActivities = append(userActivities, activity)</span>
        }

        <span class="cov0" title="0">report := &amp;models.UserActivityReport{
                StartDate:      startDate,
                EndDate:        endDate,
                UserActivities: userActivities,
                TotalUsers:     len(userActivities),
                TotalAccesses:  len(allLogs),
                Summary:        s.generateActivitySummary(userActivities),
        }

        return report, nil</span>
}

func (s *ReportingService) generateSecurityAuditData(params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // For now, return basic security metrics
        // In a full implementation, this would analyze login attempts, failed authentications, etc.
        <span class="cov0" title="0">audit := &amp;models.SecurityAuditReport{
                StartDate:           startDate,
                EndDate:             endDate,
                FailedLoginAttempts: 0, // Would be calculated from actual data
                SuccessfulLogins:    0, // Would be calculated from actual data
                SuspiciousActivity:  []models.SecurityIncident{},
                SecurityMetrics:     s.calculateSecurityMetrics(startDate, endDate),
        }

        return audit, nil</span>
}

func (s *ReportingService) generatePerformanceMetricsData(params map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        startDate, endDate, err := s.extractDateRange(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sessionData, err := s.analyticsRepo.GetSessionData(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get session data: %w", err)
        }</span>

        <span class="cov0" title="0">metrics := &amp;models.PerformanceMetricsReport{
                StartDate:              startDate,
                EndDate:                endDate,
                AverageSessionDuration: s.calculateAverageSessionDuration(sessionData),
                TotalSessions:          len(sessionData),
                ResponseTimes:          s.calculateResponseTimes(startDate, endDate),
                SystemLoad:             s.calculateSystemLoad(startDate, endDate),
                ErrorRates:             s.calculateErrorRates(startDate, endDate),
        }

        return metrics, nil</span>
}

func (s *ReportingService) formatReport(data interface{}, format string, reportType string) ([]byte, error) <span class="cov0" title="0">{
        switch format </span>{
        case "json":<span class="cov0" title="0">
                return json.MarshalIndent(data, "", "  ")</span>
        case "markdown":<span class="cov0" title="0">
                return s.formatAsMarkdown(data, reportType)</span>
        case "html":<span class="cov0" title="0">
                return s.formatAsHTML(data, reportType)</span>
        case "pdf":<span class="cov0" title="0">
                return s.formatAsPDF(data, reportType)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported format: %s", format)</span>
        }
}

func (s *ReportingService) formatAsMarkdown(data interface{}, reportType string) ([]byte, error) <span class="cov0" title="0">{
        var buffer bytes.Buffer

        switch reportType </span>{
        case "user_analytics":<span class="cov0" title="0">
                report := data.(*models.UserAnalyticsReport)
                buffer.WriteString(fmt.Sprintf("# User Analytics Report\n\n"))
                displayName := ""
                if report.User.DisplayName != nil </span><span class="cov0" title="0">{
                        displayName = *report.User.DisplayName
                }</span>
                <span class="cov0" title="0">buffer.WriteString(fmt.Sprintf("**User:** %s (%s)\n", displayName, report.User.Username))
                buffer.WriteString(fmt.Sprintf("**Period:** %s to %s\n\n", report.StartDate.Format("2006-01-02"), report.EndDate.Format("2006-01-02")))
                buffer.WriteString(fmt.Sprintf("## Summary\n\n"))
                buffer.WriteString(fmt.Sprintf("- Total Media Accesses: %d\n", report.TotalMediaAccesses))
                buffer.WriteString(fmt.Sprintf("- Total Events: %d\n", report.TotalEvents))
                buffer.WriteString(fmt.Sprintf("- Account Created: %s\n\n", report.User.CreatedAt.Format("2006-01-02")))</span>

        case "system_overview":<span class="cov0" title="0">
                report := data.(*models.SystemOverviewReport)
                buffer.WriteString(fmt.Sprintf("# System Overview Report\n\n"))
                buffer.WriteString(fmt.Sprintf("**Period:** %s to %s\n\n", report.StartDate.Format("2006-01-02"), report.EndDate.Format("2006-01-02")))
                buffer.WriteString(fmt.Sprintf("## System Statistics\n\n"))
                buffer.WriteString(fmt.Sprintf("- Total Users: %d\n", report.TotalUsers))
                buffer.WriteString(fmt.Sprintf("- Active Users: %d\n", report.ActiveUsers))
                buffer.WriteString(fmt.Sprintf("- Total Media Accesses: %d\n", report.TotalMediaAccesses))
                buffer.WriteString(fmt.Sprintf("- Total Events: %d\n\n", report.TotalEvents))</span>

        default:<span class="cov0" title="0">
                buffer.WriteString(fmt.Sprintf("# %s Report\n\n", reportType))
                jsonData, _ := json.MarshalIndent(data, "", "  ")
                buffer.WriteString(fmt.Sprintf("```json\n%s\n```\n", string(jsonData)))</span>
        }

        <span class="cov0" title="0">return buffer.Bytes(), nil</span>
}

func (s *ReportingService) formatAsHTML(data interface{}, reportType string) ([]byte, error) <span class="cov0" title="0">{
        htmlTemplate := `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;{{.Title}}&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 40px; }
        .header { border-bottom: 2px solid #333; padding-bottom: 20px; margin-bottom: 30px; }
        .section { margin-bottom: 30px; }
        .metric { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 5px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="header"&gt;
        &lt;h1&gt;{{.Title}}&lt;/h1&gt;
        &lt;p&gt;Generated on: {{.GeneratedAt}}&lt;/p&gt;
        {{if .Period}}&lt;p&gt;Period: {{.Period}}&lt;/p&gt;{{end}}
    &lt;/div&gt;

    &lt;div class="content"&gt;
        {{.Content}}
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`

        tmpl, err := template.New("report").Parse(htmlTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse HTML template: %w", err)
        }</span>

        <span class="cov0" title="0">var content string
        switch reportType </span>{
        case "user_analytics":<span class="cov0" title="0">
                report := data.(*models.UserAnalyticsReport)
                displayNameHTML := ""
                if report.User.DisplayName != nil </span><span class="cov0" title="0">{
                        displayNameHTML = *report.User.DisplayName
                }</span>
                <span class="cov0" title="0">content = fmt.Sprintf(`
                        &lt;div class="section"&gt;
                                &lt;h2&gt;User Information&lt;/h2&gt;
                                &lt;div class="metric"&gt;Username: %s&lt;/div&gt;
                                &lt;div class="metric"&gt;Display Name: %s&lt;/div&gt;
                                &lt;div class="metric"&gt;Email: %s&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="section"&gt;
                                &lt;h2&gt;Activity Summary&lt;/h2&gt;
                                &lt;div class="metric"&gt;Total Media Accesses: %d&lt;/div&gt;
                                &lt;div class="metric"&gt;Total Events: %d&lt;/div&gt;
                        &lt;/div&gt;`,
                        report.User.Username, displayNameHTML, report.User.Email,
                        report.TotalMediaAccesses, report.TotalEvents)</span>

        case "system_overview":<span class="cov0" title="0">
                report := data.(*models.SystemOverviewReport)
                content = fmt.Sprintf(`
                        &lt;div class="section"&gt;
                                &lt;h2&gt;System Statistics&lt;/h2&gt;
                                &lt;div class="metric"&gt;Total Users: %d&lt;/div&gt;
                                &lt;div class="metric"&gt;Active Users: %d&lt;/div&gt;
                                &lt;div class="metric"&gt;Total Media Accesses: %d&lt;/div&gt;
                                &lt;div class="metric"&gt;Total Events: %d&lt;/div&gt;
                        &lt;/div&gt;`,
                        report.TotalUsers, report.ActiveUsers, report.TotalMediaAccesses, report.TotalEvents)</span>

        default:<span class="cov0" title="0">
                jsonData, _ := json.MarshalIndent(data, "", "  ")
                content = fmt.Sprintf("&lt;pre&gt;%s&lt;/pre&gt;", string(jsonData))</span>
        }

        <span class="cov0" title="0">templateData := struct {
                Title       string
                GeneratedAt string
                Period      string
                Content     template.HTML
        }{
                Title:       fmt.Sprintf("%s Report", reportType),
                GeneratedAt: time.Now().Format("2006-01-02 15:04:05"),
                Content:     template.HTML(content),
        }

        var buffer bytes.Buffer
        err = tmpl.Execute(&amp;buffer, templateData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute HTML template: %w", err)
        }</span>

        <span class="cov0" title="0">return buffer.Bytes(), nil</span>
}

func (s *ReportingService) formatAsPDF(data interface{}, reportType string) ([]byte, error) <span class="cov0" title="0">{
        // Create new PDF
        pdf := gofpdf.New("P", "mm", "A4", "")
        pdf.AddPage()
        
        // Set title
        pdf.SetFont("Arial", "B", 16)
        title := fmt.Sprintf("%s Report", strings.Replace(reportType, "_", " ", -1))
        pdf.Cell(40, 10, title)
        pdf.Ln(15)
        
        // Add generation timestamp
        pdf.SetFont("Arial", "I", 10)
        pdf.Cell(40, 8, fmt.Sprintf("Generated: %s", time.Now().Format("2006-01-02 15:04:05")))
        pdf.Ln(12)
        
        // Format content based on report type
        switch reportType </span>{
        case "user_analytics":<span class="cov0" title="0">
                return s.formatUserAnalyticsPDF(pdf, data)</span>
        case "system_overview":<span class="cov0" title="0">
                return s.formatSystemOverviewPDF(pdf, data)</span>
        case "media_analytics":<span class="cov0" title="0">
                return s.formatMediaAnalyticsPDF(pdf, data)</span>
        case "user_activity":<span class="cov0" title="0">
                return s.formatUserActivityPDF(pdf, data)</span>
        case "security_audit":<span class="cov0" title="0">
                return s.formatSecurityAuditPDF(pdf, data)</span>
        case "performance_metrics":<span class="cov0" title="0">
                return s.formatPerformanceMetricsPDF(pdf, data)</span>
        default:<span class="cov0" title="0">
                // Fallback to JSON representation
                pdf.SetFont("Courier", "", 10)
                jsonData, err := json.MarshalIndent(data, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal data for PDF: %w", err)
                }</span>
                
                // Split JSON into lines and add to PDF
                <span class="cov0" title="0">lines := strings.Split(string(jsonData), "\n")
                for _, line := range lines </span><span class="cov0" title="0">{
                        // Truncate long lines to fit page
                        if len(line) &gt; 80 </span><span class="cov0" title="0">{
                                for i := 0; i &lt; len(line); i += 80 </span><span class="cov0" title="0">{
                                        end := i + 80
                                        if end &gt; len(line) </span><span class="cov0" title="0">{
                                                end = len(line)
                                        }</span>
                                        <span class="cov0" title="0">pdf.Cell(40, 5, line[i:end])
                                        pdf.Ln(5)</span>
                                }
                        } else<span class="cov0" title="0"> {
                                pdf.Cell(40, 5, line)
                                pdf.Ln(5)
                        }</span>
                }
                
                // Output PDF to bytes
                <span class="cov0" title="0">return s.outputPDFToBytes(pdf)</span>
        }
}

// Helper function to output PDF to bytes
func (s *ReportingService) outputPDFToBytes(pdf *gofpdf.Fpdf) ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        if err := pdf.Output(&amp;buf); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate PDF: %w", err)
        }</span>
        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// Helper methods for specific report types
func (s *ReportingService) formatUserAnalyticsPDF(pdf *gofpdf.Fpdf, data interface{}) ([]byte, error) <span class="cov0" title="0">{
        report := data.(*models.UserAnalyticsReport)
        
        pdf.SetFont("Arial", "B", 12)
        pdf.Cell(40, 8, "User Information")
        pdf.Ln(8)
        
        pdf.SetFont("Arial", "", 10)
        pdf.Cell(40, 6, fmt.Sprintf("User ID: %d", report.User.ID))
        pdf.Ln(6)
        pdf.Cell(40, 6, fmt.Sprintf("Username: %s", report.User.Username))
        pdf.Ln(6)
        pdf.Cell(40, 6, fmt.Sprintf("Email: %s", report.User.Email))
        pdf.Ln(6)
        pdf.Cell(40, 6, fmt.Sprintf("Period: %s to %s", 
                report.StartDate.Format("2006-01-02"), 
                report.EndDate.Format("2006-01-02")))
        pdf.Ln(12)
        
        pdf.SetFont("Arial", "B", 12)
        pdf.Cell(40, 8, "Summary Statistics")
        pdf.Ln(8)
        
        pdf.SetFont("Arial", "", 10)
        pdf.Cell(40, 6, fmt.Sprintf("Total Media Accesses: %d", report.TotalMediaAccesses))
        pdf.Ln(6)
        pdf.Cell(40, 6, fmt.Sprintf("Total Events: %d", report.TotalEvents))
        pdf.Ln(6)
        pdf.Cell(40, 6, fmt.Sprintf("Access Logs: %d", len(report.MediaAccessLogs)))
        pdf.Ln(6)
        pdf.Cell(40, 6, fmt.Sprintf("User Events: %d", len(report.Events)))
        
        return s.outputPDFToBytes(pdf)
}</span>

func (s *ReportingService) formatSystemOverviewPDF(pdf *gofpdf.Fpdf, data interface{}) ([]byte, error) <span class="cov0" title="0">{
        report := data.(*models.SystemOverviewReport)
        
        pdf.SetFont("Arial", "B", 12)
        pdf.Cell(40, 8, "System Statistics")
        pdf.Ln(8)
        
        pdf.SetFont("Arial", "", 10)
        pdf.Cell(40, 6, fmt.Sprintf("Total Users: %d", report.TotalUsers))
        pdf.Ln(6)
        pdf.Cell(40, 6, fmt.Sprintf("Active Users: %d", report.ActiveUsers))
        pdf.Ln(6)
        pdf.Cell(40, 6, fmt.Sprintf("Total Media Accesses: %d", report.TotalMediaAccesses))
        pdf.Ln(6)
        pdf.Cell(40, 6, fmt.Sprintf("Total Events: %d", report.TotalEvents))
        pdf.Ln(6)
        pdf.Cell(40, 6, fmt.Sprintf("Report Period: %s to %s", 
                report.StartDate.Format("2006-01-02"), 
                report.EndDate.Format("2006-01-02")))
        
        return s.outputPDFToBytes(pdf)
}</span>

func (s *ReportingService) formatMediaAnalyticsPDF(pdf *gofpdf.Fpdf, data interface{}) ([]byte, error) <span class="cov0" title="0">{
        // Generic media analytics formatting
        pdf.SetFont("Arial", "B", 12)
        pdf.Cell(40, 8, "Media Analytics")
        pdf.Ln(8)
        
        pdf.SetFont("Arial", "", 10)
        pdf.Cell(40, 6, "Media statistics and analytics data")
        pdf.Ln(6)
        
        // Add JSON data for now (can be enhanced later)
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal media analytics data: %w", err)
        }</span>
        
        <span class="cov0" title="0">lines := strings.Split(string(jsonData), "\n")
        pdf.SetFont("Courier", "", 8)
        for _, line := range lines </span><span class="cov0" title="0">{
                if len(line) &gt; 100 </span><span class="cov0" title="0">{
                        line = line[:100] + "..."
                }</span>
                <span class="cov0" title="0">pdf.Cell(40, 3, line)
                pdf.Ln(3)</span>
        }
        
        <span class="cov0" title="0">return s.outputPDFToBytes(pdf)</span>
}

func (s *ReportingService) formatUserActivityPDF(pdf *gofpdf.Fpdf, data interface{}) ([]byte, error) <span class="cov0" title="0">{
        // Generic user activity formatting
        pdf.SetFont("Arial", "B", 12)
        pdf.Cell(40, 8, "User Activity Report")
        pdf.Ln(8)
        
        pdf.SetFont("Arial", "", 10)
        pdf.Cell(40, 6, "User activity logs and events")
        pdf.Ln(6)
        
        // Add summary information
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal user activity data: %w", err)
        }</span>
        
        <span class="cov0" title="0">pdf.SetFont("Courier", "", 8)
        text := string(jsonData)
        if len(text) &gt; 3000 </span><span class="cov0" title="0">{ // Limit text to reasonable size
                text = text[:3000] + "...[truncated]"
        }</span>
        
        <span class="cov0" title="0">lines := strings.Split(text, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if len(line) &gt; 100 </span><span class="cov0" title="0">{
                        line = line[:100] + "..."
                }</span>
                <span class="cov0" title="0">pdf.Cell(40, 3, line)
                pdf.Ln(3)</span>
        }
        
        <span class="cov0" title="0">return s.outputPDFToBytes(pdf)</span>
}

func (s *ReportingService) formatSecurityAuditPDF(pdf *gofpdf.Fpdf, data interface{}) ([]byte, error) <span class="cov0" title="0">{
        // Security audit specific formatting
        pdf.SetFont("Arial", "B", 12)
        pdf.Cell(40, 8, "Security Audit Report")
        pdf.Ln(8)
        
        pdf.SetFont("Arial", "B", 10)
        pdf.Cell(40, 6, "Security Events and Audit Information")
        pdf.Ln(10)
        
        pdf.SetFont("Arial", "", 10)
        pdf.Cell(40, 6, "This report contains security audit information")
        pdf.Ln(6)
        pdf.Cell(40, 6, fmt.Sprintf("Generated on: %s", time.Now().Format("2006-01-02 15:04:05")))
        pdf.Ln(10)
        
        // Add audit data as formatted JSON
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal security audit data: %w", err)
        }</span>
        
        <span class="cov0" title="0">pdf.SetFont("Courier", "", 8)
        lines := strings.Split(string(jsonData), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if len(line) &gt; 95 </span><span class="cov0" title="0">{
                        line = line[:95] + "..."
                }</span>
                <span class="cov0" title="0">pdf.Cell(40, 3, line)
                pdf.Ln(3)</span>
        }
        
        <span class="cov0" title="0">return s.outputPDFToBytes(pdf)</span>
}

func (s *ReportingService) formatPerformanceMetricsPDF(pdf *gofpdf.Fpdf, data interface{}) ([]byte, error) <span class="cov0" title="0">{
        // Performance metrics specific formatting
        pdf.SetFont("Arial", "B", 12)
        pdf.Cell(40, 8, "Performance Metrics Report")
        pdf.Ln(8)
        
        pdf.SetFont("Arial", "B", 10)
        pdf.Cell(40, 6, "System Performance Metrics")
        pdf.Ln(10)
        
        pdf.SetFont("Arial", "", 10)
        pdf.Cell(40, 6, "This report contains performance metrics for the system")
        pdf.Ln(6)
        pdf.Cell(40, 6, fmt.Sprintf("Generated on: %s", time.Now().Format("2006-01-02 15:04:05")))
        pdf.Ln(10)
        
        // Add performance data as formatted JSON
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal performance metrics data: %w", err)
        }</span>
        
        <span class="cov0" title="0">pdf.SetFont("Courier", "", 8)
        lines := strings.Split(string(jsonData), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if len(line) &gt; 95 </span><span class="cov0" title="0">{
                        line = line[:95] + "..."
                }</span>
                <span class="cov0" title="0">pdf.Cell(40, 3, line)
                pdf.Ln(3)</span>
        }
        
        <span class="cov0" title="0">return s.outputPDFToBytes(pdf)</span>
}

func (s *ReportingService) extractDateRange(params map[string]interface{}) (time.Time, time.Time, error) <span class="cov0" title="0">{
        startDateStr, ok := params["start_date"].(string)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("start_date parameter required")
        }</span>

        <span class="cov0" title="0">endDateStr, ok := params["end_date"].(string)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("end_date parameter required")
        }</span>

        <span class="cov0" title="0">startDate, err := time.Parse("2006-01-02", startDateStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("invalid start_date format")
        }</span>

        <span class="cov0" title="0">endDate, err := time.Parse("2006-01-02", endDateStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, time.Time{}, fmt.Errorf("invalid end_date format")
        }</span>

        <span class="cov0" title="0">return startDate, endDate, nil</span>
}

// Helper methods for analytics calculations
func (s *ReportingService) analyzeUserAccessPatterns(logs []models.MediaAccessLog) map[string]interface{} <span class="cov0" title="0">{
        patterns := make(map[string]interface{})

        hourlyAccess := make(map[int]int)
        dailyAccess := make(map[string]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                hour := log.AccessTime.Hour()
                hourlyAccess[hour]++

                day := log.AccessTime.Weekday().String()
                dailyAccess[day]++
        }</span>

        <span class="cov0" title="0">patterns["hourly"] = hourlyAccess
        patterns["daily"] = dailyAccess

        return patterns</span>
}

func (s *ReportingService) analyzeUserDeviceUsage(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        deviceUsage := make(map[string]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                if log.DeviceInfo != nil </span><span class="cov0" title="0">{
                        deviceModel := ""
                        if log.DeviceInfo.DeviceModel != nil </span><span class="cov0" title="0">{
                                deviceModel = *log.DeviceInfo.DeviceModel
                        }</span>
                        <span class="cov0" title="0">device := fmt.Sprintf("%s %s", log.DeviceInfo.Platform, deviceModel)
                        deviceUsage[device]++</span>
                }
        }

        <span class="cov0" title="0">return deviceUsage</span>
}

func (s *ReportingService) analyzeUserLocations(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        locations := make(map[string]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                if log.Location != nil </span><span class="cov0" title="0">{
                        location := fmt.Sprintf("%.2f,%.2f", log.Location.Latitude, log.Location.Longitude)
                        locations[location]++
                }</span>
        }

        <span class="cov0" title="0">return locations</span>
}

func (s *ReportingService) analyzeUserTimePatterns(logs []models.MediaAccessLog) map[string]interface{} <span class="cov0" title="0">{
        return s.analyzeUserAccessPatterns(logs) // Same as access patterns
}</span>

func (s *ReportingService) analyzeUserPopularContent(logs []models.MediaAccessLog) []models.MediaAccessCount <span class="cov0" title="0">{
        mediaCount := make(map[int]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                mediaCount[log.MediaID]++
        }</span>

        <span class="cov0" title="0">var results []models.MediaAccessCount
        for mediaID, count := range mediaCount </span><span class="cov0" title="0">{
                results = append(results, models.MediaAccessCount{
                        MediaID:     mediaID,
                        AccessCount: count,
                })
        }</span>

        <span class="cov0" title="0">return results</span>
}

func (s *ReportingService) filterLogsByDateRange(logs []models.MediaAccessLog, startDate, endDate time.Time) []models.MediaAccessLog <span class="cov0" title="0">{
        var filtered []models.MediaAccessLog

        for _, log := range logs </span><span class="cov0" title="0">{
                if log.AccessTime.After(startDate) &amp;&amp; log.AccessTime.Before(endDate) </span><span class="cov0" title="0">{
                        filtered = append(filtered, log)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

func (s *ReportingService) countUniqueUsers(logs []models.MediaAccessLog) int <span class="cov0" title="0">{
        users := make(map[int]bool)

        for _, log := range logs </span><span class="cov0" title="0">{
                users[log.UserID] = true
        }</span>

        <span class="cov0" title="0">return len(users)</span>
}

func (s *ReportingService) calculateSystemHealth(totalUsers, activeUsers, mediaAccesses int) models.SystemHealth <span class="cov0" title="0">{
        var healthScore float64

        if totalUsers &gt; 0 </span><span class="cov0" title="0">{
                activeRatio := float64(activeUsers) / float64(totalUsers)
                healthScore += activeRatio * 50
        }</span>

        <span class="cov0" title="0">if mediaAccesses &gt; 0 </span><span class="cov0" title="0">{
                healthScore += 30
        }</span>

        <span class="cov0" title="0">if activeUsers &gt; 10 </span><span class="cov0" title="0">{
                healthScore += 20
        }</span>

        <span class="cov0" title="0">var status string
        switch </span>{
        case healthScore &gt;= 80:<span class="cov0" title="0">
                status = "excellent"</span>
        case healthScore &gt;= 60:<span class="cov0" title="0">
                status = "good"</span>
        case healthScore &gt;= 40:<span class="cov0" title="0">
                status = "fair"</span>
        default:<span class="cov0" title="0">
                status = "poor"</span>
        }

        <span class="cov0" title="0">return models.SystemHealth{
                Score:  healthScore,
                Status: status,
        }</span>
}

func (s *ReportingService) calculateUsageStatistics(startDate, endDate time.Time) models.UsageStatistics <span class="cov0" title="0">{
        // Placeholder implementation
        return models.UsageStatistics{
                PeakHours:    []int{14, 15, 16, 20, 21},
                AverageDaily: 150,
                GrowthRate:   5.2,
        }
}</span>

func (s *ReportingService) calculatePerformanceMetrics(startDate, endDate time.Time) models.PerformanceMetrics <span class="cov0" title="0">{
        // Placeholder implementation
        return models.PerformanceMetrics{
                ResponseTime: 250.5,
                Throughput:   1200,
                ErrorRate:    0.02,
        }
}</span>

func (s *ReportingService) analyzeAccessPatterns(logs []models.MediaAccessLog) map[string]interface{} <span class="cov0" title="0">{
        return s.analyzeUserAccessPatterns(logs)
}</span>

func (s *ReportingService) analyzeUserEngagement(logs []models.MediaAccessLog) models.UserEngagement <span class="cov0" title="0">{
        return models.UserEngagement{
                AverageSessionTime: 15.5,
                ReturnRate:         85.2,
                InteractionDepth:   3.4,
        }
}</span>

func (s *ReportingService) analyzeGeographicDistribution(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        return s.analyzeUserLocations(logs)
}</span>

func (s *ReportingService) analyzeDeviceDistribution(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        return s.analyzeUserDeviceUsage(logs)
}</span>

func (s *ReportingService) analyzeTimeDistribution(logs []models.MediaAccessLog) map[string]int <span class="cov0" title="0">{
        timeDistribution := make(map[string]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                hour := log.AccessTime.Hour()
                var timeSlot string

                switch </span>{
                case hour &gt;= 6 &amp;&amp; hour &lt; 12:<span class="cov0" title="0">
                        timeSlot = "morning"</span>
                case hour &gt;= 12 &amp;&amp; hour &lt; 18:<span class="cov0" title="0">
                        timeSlot = "afternoon"</span>
                case hour &gt;= 18 &amp;&amp; hour &lt; 22:<span class="cov0" title="0">
                        timeSlot = "evening"</span>
                default:<span class="cov0" title="0">
                        timeSlot = "night"</span>
                }

                <span class="cov0" title="0">timeDistribution[timeSlot]++</span>
        }

        <span class="cov0" title="0">return timeDistribution</span>
}

func (s *ReportingService) getLastActivityTime(logs []models.MediaAccessLog) time.Time <span class="cov0" title="0">{
        if len(logs) == 0 </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        <span class="cov0" title="0">latest := logs[0].AccessTime
        for _, log := range logs </span><span class="cov0" title="0">{
                if log.AccessTime.After(latest) </span><span class="cov0" title="0">{
                        latest = log.AccessTime
                }</span>
        }

        <span class="cov0" title="0">return latest</span>
}

func (s *ReportingService) getMostActiveHour(logs []models.MediaAccessLog) int <span class="cov0" title="0">{
        hourCounts := make(map[int]int)

        for _, log := range logs </span><span class="cov0" title="0">{
                hour := log.AccessTime.Hour()
                hourCounts[hour]++
        }</span>

        <span class="cov0" title="0">maxCount := 0
        mostActiveHour := 0

        for hour, count := range hourCounts </span><span class="cov0" title="0">{
                if count &gt; maxCount </span><span class="cov0" title="0">{
                        maxCount = count
                        mostActiveHour = hour
                }</span>
        }

        <span class="cov0" title="0">return mostActiveHour</span>
}

func (s *ReportingService) getPreferredDevices(logs []models.MediaAccessLog) []string <span class="cov0" title="0">{
        deviceCounts := s.analyzeUserDeviceUsage(logs)

        var devices []string
        for device := range deviceCounts </span><span class="cov0" title="0">{
                devices = append(devices, device)
        }</span>

        <span class="cov0" title="0">return devices</span>
}

func (s *ReportingService) getAccessedLocations(logs []models.MediaAccessLog) []string <span class="cov0" title="0">{
        locationCounts := s.analyzeUserLocations(logs)

        var locations []string
        for location := range locationCounts </span><span class="cov0" title="0">{
                locations = append(locations, location)
        }</span>

        <span class="cov0" title="0">return locations</span>
}

func (s *ReportingService) generateActivitySummary(activities []models.UserActivitySummary) models.ActivitySummary <span class="cov0" title="0">{
        if len(activities) == 0 </span><span class="cov0" title="0">{
                return models.ActivitySummary{}
        }</span>

        <span class="cov0" title="0">totalAccesses := 0
        for _, activity := range activities </span><span class="cov0" title="0">{
                totalAccesses += activity.TotalAccesses
        }</span>

        <span class="cov0" title="0">avgAccesses := float64(totalAccesses) / float64(len(activities))

        return models.ActivitySummary{
                TotalUsers:       len(activities),
                TotalAccesses:    totalAccesses,
                AverageAccesses:  avgAccesses,
                MostActiveUsers:  len(activities), // Simplified
                LeastActiveUsers: 0,               // Simplified
        }</span>
}

func (s *ReportingService) calculateSecurityMetrics(startDate, endDate time.Time) models.SecurityMetrics <span class="cov0" title="0">{
        // Placeholder implementation
        return models.SecurityMetrics{
                ThreatLevel:        "low",
                VulnerabilityCount: 0,
                SecurityScore:      95.5,
        }
}</span>

func (s *ReportingService) calculateAverageSessionDuration(sessions []models.SessionData) time.Duration <span class="cov0" title="0">{
        if len(sessions) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var total time.Duration
        for _, session := range sessions </span><span class="cov0" title="0">{
                total += session.Duration
        }</span>

        <span class="cov0" title="0">return total / time.Duration(len(sessions))</span>
}

func (s *ReportingService) calculateResponseTimes(startDate, endDate time.Time) models.ResponseTimes <span class="cov0" title="0">{
        // Placeholder implementation
        return models.ResponseTimes{
                Average: 250.5,
                Min:     50.2,
                Max:     1200.8,
                P95:     480.3,
                P99:     850.7,
        }
}</span>

func (s *ReportingService) calculateSystemLoad(startDate, endDate time.Time) models.SystemLoad <span class="cov0" title="0">{
        // Placeholder implementation
        return models.SystemLoad{
                CPU:     45.2,
                Memory:  68.5,
                Disk:    32.1,
                Network: 15.8,
        }
}</span>

func (s *ReportingService) calculateErrorRates(startDate, endDate time.Time) models.ErrorRates <span class="cov0" title="0">{
        // Placeholder implementation
        return models.ErrorRates{
                HTTP4xx:  2.1,
                HTTP5xx:  0.3,
                Timeouts: 0.1,
                Total:    2.5,
        }
}</span>
</pre>
		
		<pre class="file" id="file103" style="display: none">package services

import (
        "context"
        "fmt"
        "io"
        "math/rand"
        "net/http"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
)

type StressTestService struct {
        stressRepo  *repository.StressTestRepository
        authService *AuthService
        activeTests map[int]*TestExecution
        testMutex   sync.RWMutex
}

type TestExecution struct {
        Test      *models.StressTest
        Context   context.Context
        Cancel    context.CancelFunc
        Workers   []*TestWorker
        Metrics   *TestMetrics
        StartTime time.Time
        IsRunning bool
        Results   *models.StressTestResult
}

type TestWorker struct {
        ID      int
        Context context.Context
        Metrics *WorkerMetrics
}

type TestMetrics struct {
        TotalRequests     int64
        SuccessfulReqs    int64
        FailedRequests    int64
        TotalResponseTime time.Duration
        MinResponseTime   time.Duration
        MaxResponseTime   time.Duration
        ErrorCounts       map[string]int64
        StatusCounts      map[int]int64
        mutex             sync.RWMutex
}

type WorkerMetrics struct {
        RequestCount    int64
        SuccessCount    int64
        ErrorCount      int64
        TotalRespTime   time.Duration
        LastRequestTime time.Time
}

func NewStressTestService(stressRepo *repository.StressTestRepository, authService *AuthService) *StressTestService <span class="cov0" title="0">{
        return &amp;StressTestService{
                stressRepo:  stressRepo,
                authService: authService,
                activeTests: make(map[int]*TestExecution),
        }
}</span>

func (s *StressTestService) CreateStressTest(userID int, test *models.StressTest) (*models.StressTest, error) <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">if err := s.validateTestConfiguration(test); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid test configuration: %w", err)
        }</span>

        <span class="cov0" title="0">test.UserID = userID
        test.CreatedAt = time.Now()
        test.Status = models.StressTestStatusPending

        id, err := s.stressRepo.CreateTest(test)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stress test: %w", err)
        }</span>

        <span class="cov0" title="0">test.ID = id
        return test, nil</span>
}

func (s *StressTestService) StartStressTest(testID int, userID int) (*models.StressTestResult, error) <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">test, err := s.stressRepo.GetTest(testID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get test: %w", err)
        }</span>

        <span class="cov0" title="0">if test.Status != models.StressTestStatusPending </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("test is not in pending status")
        }</span>

        <span class="cov0" title="0">s.testMutex.Lock()
        if _, exists := s.activeTests[testID]; exists </span><span class="cov0" title="0">{
                s.testMutex.Unlock()
                return nil, fmt.Errorf("test is already running")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), time.Duration(test.Duration)*time.Second)
        execution := &amp;TestExecution{
                Test:      test,
                Context:   ctx,
                Cancel:    cancel,
                Workers:   make([]*TestWorker, test.ConcurrentUsers),
                Metrics:   s.createTestMetrics(),
                StartTime: time.Now(),
                IsRunning: true,
        }

        s.activeTests[testID] = execution
        s.testMutex.Unlock()

        test.Status = models.StressTestStatusRunning
        test.StartedAt = &amp;execution.StartTime
        s.stressRepo.UpdateTest(test)

        go s.executeStressTest(execution)

        result := &amp;models.StressTestResult{
                TestID:    int64(testID),
                Status:    models.StressTestStatusRunning,
                StartTime: execution.StartTime,
        }

        return result, nil</span>
}

func (s *StressTestService) executeStressTest(execution *TestExecution) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                s.testMutex.Lock()
                delete(s.activeTests, int(execution.Test.ID))
                s.testMutex.Unlock()

                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.handleTestError(execution, fmt.Errorf("test panic: %v", r))
                }</span>
        }()

        <span class="cov0" title="0">var wg sync.WaitGroup

        // Start workers
        for i := 0; i &lt; execution.Test.ConcurrentUsers; i++ </span><span class="cov0" title="0">{
                worker := &amp;TestWorker{
                        ID:      i,
                        Context: execution.Context,
                        Metrics: &amp;WorkerMetrics{},
                }
                execution.Workers[i] = worker

                wg.Add(1)
                go func(w *TestWorker) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        s.runWorker(execution, w)
                }</span>(worker)
        }

        // Wait for completion or timeout
        <span class="cov0" title="0">done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                s.handleTestCompletion(execution)</span>
        case &lt;-execution.Context.Done():<span class="cov0" title="0">
                s.handleTestTimeout(execution)</span>
        }
}

func (s *StressTestService) runWorker(execution *TestExecution, worker *TestWorker) <span class="cov0" title="0">{
        client := &amp;http.Client{
                Timeout: time.Duration(execution.Test.RequestTimeout) * time.Second,
        }

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-worker.Context.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        s.executeRequest(execution, worker, client)

                        if execution.Test.RequestDelay &gt; 0 </span><span class="cov0" title="0">{
                                time.Sleep(time.Duration(execution.Test.RequestDelay) * time.Millisecond)
                        }</span>
                }
        }
}

func (s *StressTestService) executeRequest(execution *TestExecution, worker *TestWorker, client *http.Client) <span class="cov0" title="0">{
        startTime := time.Now()
        atomic.AddInt64(&amp;worker.Metrics.RequestCount, 1)
        atomic.AddInt64(&amp;execution.Metrics.TotalRequests, 1)

        scenario := s.selectRandomScenario(execution.Test.Scenarios)
        if scenario == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">req, err := s.buildRequest(scenario)
        if err != nil </span><span class="cov0" title="0">{
                s.recordError(execution, worker, err, 0)
                return
        }</span>

        <span class="cov0" title="0">resp, err := client.Do(req)
        responseTime := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                s.recordError(execution, worker, err, 0)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        s.recordResponse(execution, worker, resp, responseTime)</span>
}

func (s *StressTestService) selectRandomScenario(scenarios []models.StressTestScenario) *models.StressTestScenario <span class="cov0" title="0">{
        if len(scenarios) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">totalWeight := 0
        for _, scenario := range scenarios </span><span class="cov0" title="0">{
                totalWeight += scenario.Weight
        }</span>

        <span class="cov0" title="0">if totalWeight == 0 </span><span class="cov0" title="0">{
                return &amp;scenarios[rand.Intn(len(scenarios))]
        }</span>

        <span class="cov0" title="0">randomWeight := rand.Intn(totalWeight)
        currentWeight := 0

        for _, scenario := range scenarios </span><span class="cov0" title="0">{
                currentWeight += scenario.Weight
                if randomWeight &lt; currentWeight </span><span class="cov0" title="0">{
                        return &amp;scenario
                }</span>
        }

        <span class="cov0" title="0">return &amp;scenarios[0]</span>
}

func (s *StressTestService) buildRequest(scenario *models.StressTestScenario) (*http.Request, error) <span class="cov0" title="0">{
        var body io.Reader
        if scenario.RequestBody != nil </span><span class="cov0" title="0">{
                body = strings.NewReader(*scenario.RequestBody)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest(scenario.Method, scenario.URL, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for key, value := range scenario.Headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

func (s *StressTestService) recordResponse(execution *TestExecution, worker *TestWorker, resp *http.Response, responseTime time.Duration) <span class="cov0" title="0">{
        execution.Metrics.mutex.Lock()
        defer execution.Metrics.mutex.Unlock()

        execution.Metrics.TotalResponseTime += responseTime

        if execution.Metrics.MinResponseTime == 0 || responseTime &lt; execution.Metrics.MinResponseTime </span><span class="cov0" title="0">{
                execution.Metrics.MinResponseTime = responseTime
        }</span>

        <span class="cov0" title="0">if responseTime &gt; execution.Metrics.MaxResponseTime </span><span class="cov0" title="0">{
                execution.Metrics.MaxResponseTime = responseTime
        }</span>

        <span class="cov0" title="0">if execution.Metrics.StatusCounts == nil </span><span class="cov0" title="0">{
                execution.Metrics.StatusCounts = make(map[int]int64)
        }</span>

        <span class="cov0" title="0">execution.Metrics.StatusCounts[resp.StatusCode]++

        if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 400 </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;execution.Metrics.SuccessfulReqs, 1)
                atomic.AddInt64(&amp;worker.Metrics.SuccessCount, 1)
        }</span> else<span class="cov0" title="0"> {
                atomic.AddInt64(&amp;execution.Metrics.FailedRequests, 1)
                atomic.AddInt64(&amp;worker.Metrics.ErrorCount, 1)
        }</span>

        <span class="cov0" title="0">worker.Metrics.TotalRespTime += responseTime
        worker.Metrics.LastRequestTime = time.Now()</span>
}

func (s *StressTestService) recordError(execution *TestExecution, worker *TestWorker, err error, statusCode int) <span class="cov0" title="0">{
        execution.Metrics.mutex.Lock()
        defer execution.Metrics.mutex.Unlock()

        atomic.AddInt64(&amp;execution.Metrics.FailedRequests, 1)
        atomic.AddInt64(&amp;worker.Metrics.ErrorCount, 1)

        if execution.Metrics.ErrorCounts == nil </span><span class="cov0" title="0">{
                execution.Metrics.ErrorCounts = make(map[string]int64)
        }</span>

        <span class="cov0" title="0">execution.Metrics.ErrorCounts[err.Error()]++

        if statusCode &gt; 0 </span><span class="cov0" title="0">{
                if execution.Metrics.StatusCounts == nil </span><span class="cov0" title="0">{
                        execution.Metrics.StatusCounts = make(map[int]int64)
                }</span>
                <span class="cov0" title="0">execution.Metrics.StatusCounts[statusCode]++</span>
        }
}

func (s *StressTestService) handleTestCompletion(execution *TestExecution) <span class="cov0" title="0">{
        execution.IsRunning = false
        result := s.generateTestResult(execution, models.StressTestStatusCompleted)

        execution.Test.Status = models.StressTestStatusCompleted
        execution.Test.CompletedAt = result.CompletedAt
        s.stressRepo.UpdateTest(execution.Test)

        s.saveTestResult(result)
}</span>

func (s *StressTestService) handleTestTimeout(execution *TestExecution) <span class="cov0" title="0">{
        execution.IsRunning = false
        result := s.generateTestResult(execution, models.StressTestStatusTimeout)

        execution.Test.Status = models.StressTestStatusTimeout
        execution.Test.CompletedAt = result.CompletedAt
        s.stressRepo.UpdateTest(execution.Test)

        s.saveTestResult(result)
}</span>

func (s *StressTestService) handleTestError(execution *TestExecution, testError error) <span class="cov0" title="0">{
        execution.IsRunning = false
        result := s.generateTestResult(execution, models.StressTestStatusFailed)
        errorMsg := testError.Error()
        result.ErrorMessage = &amp;errorMsg

        execution.Test.Status = models.StressTestStatusFailed
        execution.Test.CompletedAt = result.CompletedAt
        s.stressRepo.UpdateTest(execution.Test)

        s.saveTestResult(result)
}</span>

func (s *StressTestService) generateTestResult(execution *TestExecution, status string) *models.StressTestResult <span class="cov0" title="0">{
        completedAt := time.Now()
        duration := completedAt.Sub(execution.StartTime)

        avgResponseTime := time.Duration(0)
        if execution.Metrics.TotalRequests &gt; 0 </span><span class="cov0" title="0">{
                avgResponseTime = execution.Metrics.TotalResponseTime / time.Duration(execution.Metrics.TotalRequests)
        }</span>

        <span class="cov0" title="0">requestsPerSecond := float64(0)
        if duration.Seconds() &gt; 0 </span><span class="cov0" title="0">{
                requestsPerSecond = float64(execution.Metrics.TotalRequests) / duration.Seconds()
        }</span>

        <span class="cov0" title="0">errorRate := float64(0)
        if execution.Metrics.TotalRequests &gt; 0 </span><span class="cov0" title="0">{
                errorRate = float64(execution.Metrics.FailedRequests) / float64(execution.Metrics.TotalRequests) * 100
        }</span>

        <span class="cov0" title="0">return &amp;models.StressTestResult{
                TestID:            execution.Test.ID,
                Status:            status,
                StartTime:         execution.StartTime,
                EndTime:           &amp;completedAt,
                CompletedAt:       &amp;completedAt,
                Duration:          duration,
                TotalRequests:     execution.Metrics.TotalRequests,
                SuccessfulReqs:    execution.Metrics.SuccessfulReqs,
                FailedRequests:    execution.Metrics.FailedRequests,
                RequestsPerSecond: requestsPerSecond,
                AvgResponseTime:   float64(avgResponseTime),
                MinResponseTime:   float64(execution.Metrics.MinResponseTime),
                MaxResponseTime:   float64(execution.Metrics.MaxResponseTime),
                ErrorRate:         errorRate,
                StatusCodeDist:    convertIntMapToStringInt(execution.Metrics.StatusCounts),
                ErrorDistribution: convertInt64MapToInt(execution.Metrics.ErrorCounts),
        }</span>
}

func convertIntMapToStringInt(m map[int]int64) map[string]int <span class="cov0" title="0">{
        result := make(map[string]int)
        for k, v := range m </span><span class="cov0" title="0">{
                result[fmt.Sprintf("%d", k)] = int(v)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func convertInt64MapToInt(m map[string]int64) map[string]int <span class="cov0" title="0">{
        result := make(map[string]int)
        for k, v := range m </span><span class="cov0" title="0">{
                result[k] = int(v)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (s *StressTestService) saveTestResult(result *models.StressTestResult) <span class="cov0" title="0">{
        err := s.stressRepo.SaveResult(result)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to save test result for test %d: %v\n", result.TestID, err)
        }</span>
}

func (s *StressTestService) StopStressTest(testID int, userID int) error <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">s.testMutex.RLock()
        execution, exists := s.activeTests[testID]
        s.testMutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("test is not running")
        }</span>

        <span class="cov0" title="0">execution.Cancel()

        execution.Test.Status = models.StressTestStatusCancelled
        completedAt := time.Now()
        execution.Test.CompletedAt = &amp;completedAt
        s.stressRepo.UpdateTest(execution.Test)

        return nil</span>
}

func (s *StressTestService) GetTestStatus(testID int, userID int) (*models.StressTestStatus, error) <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewAnalytics)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">test, err := s.stressRepo.GetTest(testID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">status := &amp;models.StressTestStatus{
                TestID:    int64(testID),
                Status:    test.Status,
                CreatedAt: test.CreatedAt,
                StartedAt: *test.StartedAt,
        }

        s.testMutex.RLock()
        execution, isRunning := s.activeTests[testID]
        s.testMutex.RUnlock()

        if isRunning </span><span class="cov0" title="0">{
                status.IsRunning = true
                status.ElapsedTime = time.Since(execution.StartTime)
                status.TotalRequests = execution.Metrics.TotalRequests
                status.SuccessfulReqs = execution.Metrics.SuccessfulReqs
                status.FailedRequests = execution.Metrics.FailedRequests

                if execution.Metrics.TotalRequests &gt; 0 </span><span class="cov0" title="0">{
                        status.RequestsPerSecond = float64(execution.Metrics.TotalRequests) / status.ElapsedTime.Seconds()
                        status.ErrorRate = float64(execution.Metrics.FailedRequests) / float64(execution.Metrics.TotalRequests) * 100
                }</span>
        }

        <span class="cov0" title="0">return status, nil</span>
}

func (s *StressTestService) GetTestResults(testID int, userID int) (*models.StressTestResult, error) <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewAnalytics)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">return s.stressRepo.GetResult(testID)</span>
}

func (s *StressTestService) ListUserTests(userID int, limit, offset int) ([]*models.StressTest, error) <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewAnalytics)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">return s.stressRepo.GetUserTests(userID, limit, offset)</span>
}

func (s *StressTestService) DeleteTest(testID int, userID int) error <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionSystemAdmin)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">test, err := s.stressRepo.GetTest(testID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if test.Status == models.StressTestStatusRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot delete running test")
        }</span>

        <span class="cov0" title="0">return s.stressRepo.DeleteTest(testID)</span>
}

func (s *StressTestService) GenerateLoadReport(testID int, userID int) (*models.LoadTestReport, error) <span class="cov0" title="0">{
        hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewAnalytics)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check permissions: %w", err)
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient permissions")
        }</span>

        <span class="cov0" title="0">test, err := s.stressRepo.GetTest(testID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result, err := s.stressRepo.GetResult(testID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">report := &amp;models.LoadTestReport{
                Test:            test,
                Result:          result,
                GeneratedAt:     time.Now(),
                Summary:         s.generateReportSummary(test, result),
                Recommendations: s.generateRecommendations(result),
        }

        return report, nil</span>
}

func (s *StressTestService) generateReportSummary(test *models.StressTest, result *models.StressTestResult) string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "Load test completed with %d concurrent users over %d seconds. "+
                        "Total requests: %d, Success rate: %.2f%%, Average response time: %v",
                test.ConcurrentUsers,
                test.Duration,
                result.TotalRequests,
                100-result.ErrorRate,
                result.AvgResponseTime,
        )
}</span>

func (s *StressTestService) generateRecommendations(result *models.StressTestResult) []string <span class="cov0" title="0">{
        var recommendations []string

        if result.ErrorRate &gt; 5 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "High error rate detected. Consider investigating server capacity and error handling.")
        }</span>

        <span class="cov0" title="0">if result.AvgResponseTime &gt; float64(2*time.Second) </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Average response time is high. Consider optimizing database queries and caching.")
        }</span>

        <span class="cov0" title="0">if result.RequestsPerSecond &lt; 10 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Low throughput detected. Consider scaling horizontally or optimizing server performance.")
        }</span>

        <span class="cov0" title="0">if len(recommendations) == 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "System performance appears to be within acceptable limits.")
        }</span>

        <span class="cov0" title="0">return recommendations</span>
}

func (s *StressTestService) validateTestConfiguration(test *models.StressTest) error <span class="cov0" title="0">{
        if test.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("test name is required")
        }</span>

        <span class="cov0" title="0">if test.ConcurrentUsers &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("concurrent users must be greater than 0")
        }</span>

        <span class="cov0" title="0">if test.ConcurrentUsers &gt; 1000 </span><span class="cov0" title="0">{
                return fmt.Errorf("concurrent users cannot exceed 1000")
        }</span>

        <span class="cov0" title="0">if test.Duration &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("duration must be greater than 0")
        }</span>

        <span class="cov0" title="0">if test.Duration &gt; 3600 </span><span class="cov0" title="0">{
                return fmt.Errorf("duration cannot exceed 3600 seconds")
        }</span>

        <span class="cov0" title="0">if len(test.Scenarios) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one test scenario is required")
        }</span>

        <span class="cov0" title="0">for _, scenario := range test.Scenarios </span><span class="cov0" title="0">{
                if scenario.URL == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("scenario URL is required")
                }</span>

                <span class="cov0" title="0">if scenario.Method == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("scenario method is required")
                }</span>

                <span class="cov0" title="0">if scenario.Weight &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("scenario weight cannot be negative")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *StressTestService) createTestMetrics() *TestMetrics <span class="cov0" title="0">{
        return &amp;TestMetrics{
                ErrorCounts:  make(map[string]int64),
                StatusCounts: make(map[int]int64),
        }
}</span>

func (s *StressTestService) GetSystemLoad() (*models.SystemLoadMetrics, error) <span class="cov0" title="0">{
        // This would integrate with system monitoring tools
        // For now, return placeholder data
        return &amp;models.SystemLoadMetrics{
                CPUUsage:    45.2,
                MemoryUsage: 68.5,
                DiskUsage:   32.1,
                NetworkIO:   15.8,
                ActiveTests: len(s.activeTests),
                Timestamp:   time.Now(),
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package services

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "catalogizer/models"
        "catalogizer/repository"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "cloud.google.com/go/storage"
        "google.golang.org/api/option"
)

type SyncService struct {
        syncRepo      *repository.SyncRepository
        userRepo      *repository.UserRepository
        authService   *AuthService
        webdavClients map[int]*WebDAVClient
}

func NewSyncService(syncRepo *repository.SyncRepository, userRepo *repository.UserRepository, authService *AuthService) *SyncService <span class="cov0" title="0">{
        return &amp;SyncService{
                syncRepo:      syncRepo,
                userRepo:      userRepo,
                authService:   authService,
                webdavClients: make(map[int]*WebDAVClient),
        }
}</span>

func (s *SyncService) CreateSyncEndpoint(userID int, endpoint *models.SyncEndpoint) (*models.SyncEndpoint, error) <span class="cov0" title="0">{
        endpoint.UserID = userID
        endpoint.CreatedAt = time.Now()
        endpoint.UpdatedAt = time.Now()
        endpoint.Status = models.SyncStatusActive

        if err := s.validateSyncEndpoint(endpoint); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid sync endpoint: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.testConnection(endpoint); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connection test failed: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := s.syncRepo.CreateEndpoint(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sync endpoint: %w", err)
        }</span>

        <span class="cov0" title="0">endpoint.ID = id
        return endpoint, nil</span>
}

func (s *SyncService) GetUserEndpoints(userID int) ([]models.SyncEndpoint, error) <span class="cov0" title="0">{
        return s.syncRepo.GetUserEndpoints(userID)
}</span>

func (s *SyncService) GetEndpoint(endpointID int, userID int) (*models.SyncEndpoint, error) <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to view this endpoint")
                }</span>
        }

        <span class="cov0" title="0">return endpoint, nil</span>
}

func (s *SyncService) UpdateEndpoint(endpointID int, userID int, updates *models.UpdateSyncEndpointRequest) (*models.SyncEndpoint, error) <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionEditShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to update this endpoint")
                }</span>
        }

        <span class="cov0" title="0">if updates.Name != "" </span><span class="cov0" title="0">{
                endpoint.Name = updates.Name
        }</span>

        <span class="cov0" title="0">if updates.URL != "" </span><span class="cov0" title="0">{
                endpoint.URL = updates.URL
        }</span>

        <span class="cov0" title="0">if updates.Username != "" </span><span class="cov0" title="0">{
                endpoint.Username = updates.Username
        }</span>

        <span class="cov0" title="0">if updates.Password != "" </span><span class="cov0" title="0">{
                endpoint.Password = updates.Password
        }</span>

        <span class="cov0" title="0">if updates.SyncDirection != "" </span><span class="cov0" title="0">{
                endpoint.SyncDirection = updates.SyncDirection
        }</span>

        <span class="cov0" title="0">if updates.LocalPath != "" </span><span class="cov0" title="0">{
                endpoint.LocalPath = updates.LocalPath
        }</span>

        <span class="cov0" title="0">if updates.RemotePath != "" </span><span class="cov0" title="0">{
                endpoint.RemotePath = updates.RemotePath
        }</span>

        <span class="cov0" title="0">if updates.SyncSettings != nil </span><span class="cov0" title="0">{
                endpoint.SyncSettings = updates.SyncSettings
        }</span>

        <span class="cov0" title="0">if updates.IsActive != nil </span><span class="cov0" title="0">{
                if *updates.IsActive </span><span class="cov0" title="0">{
                        endpoint.Status = models.SyncStatusActive
                }</span> else<span class="cov0" title="0"> {
                        endpoint.Status = models.SyncStatusInactive
                }</span>
        }

        <span class="cov0" title="0">endpoint.UpdatedAt = time.Now()

        if err := s.validateSyncEndpoint(endpoint); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid endpoint update: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.testConnection(endpoint); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connection test failed: %w", err)
        }</span>

        <span class="cov0" title="0">err = s.syncRepo.UpdateEndpoint(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update endpoint: %w", err)
        }</span>

        <span class="cov0" title="0">return endpoint, nil</span>
}

func (s *SyncService) DeleteEndpoint(endpointID int, userID int) error <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionDeleteShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return fmt.Errorf("unauthorized to delete this endpoint")
                }</span>
        }

        <span class="cov0" title="0">return s.syncRepo.DeleteEndpoint(endpointID)</span>
}

func (s *SyncService) StartSync(endpointID int, userID int) (*models.SyncSession, error) <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionEditShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to sync this endpoint")
                }</span>
        }

        <span class="cov0" title="0">if endpoint.Status != models.SyncStatusActive </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("endpoint is not active")
        }</span>

        <span class="cov0" title="0">session := &amp;models.SyncSession{
                EndpointID: endpointID,
                UserID:     userID,
                Status:     models.SyncSessionStatusRunning,
                StartedAt:  time.Now(),
                SyncType:   models.SyncTypeManual,
        }

        sessionID, err := s.syncRepo.CreateSession(session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sync session: %w", err)
        }</span>

        <span class="cov0" title="0">session.ID = sessionID

        go s.performSync(session, endpoint)

        return session, nil</span>
}

func (s *SyncService) performSync(session *models.SyncSession, endpoint *models.SyncEndpoint) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.handleSyncError(session, fmt.Errorf("sync panic: %v", r))
                }</span>
        }()

        <span class="cov0" title="0">var err error

        switch endpoint.Type </span>{
        case models.SyncTypeWebDAV:<span class="cov0" title="0">
                err = s.performWebDAVSync(session, endpoint)</span>
        case models.SyncTypeCloudStorage:<span class="cov0" title="0">
                err = s.performCloudSync(session, endpoint)</span>
        case models.SyncTypeLocal:<span class="cov0" title="0">
                err = s.performLocalSync(session, endpoint)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unsupported sync type: %s", endpoint.Type)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.handleSyncError(session, err)
                return
        }</span>

        <span class="cov0" title="0">s.handleSyncSuccess(session)</span>
}

func (s *SyncService) performWebDAVSync(session *models.SyncSession, endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        client, err := s.getWebDAVClient(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get WebDAV client: %w", err)
        }</span>

        <span class="cov0" title="0">switch endpoint.SyncDirection </span>{
        case models.SyncDirectionUpload:<span class="cov0" title="0">
                return s.uploadToWebDAV(session, endpoint, client)</span>
        case models.SyncDirectionDownload:<span class="cov0" title="0">
                return s.downloadFromWebDAV(session, endpoint, client)</span>
        case models.SyncDirectionBidirectional:<span class="cov0" title="0">
                if err := s.uploadToWebDAV(session, endpoint, client); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return s.downloadFromWebDAV(session, endpoint, client)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported sync direction: %s", endpoint.SyncDirection)</span>
        }
}

func (s *SyncService) uploadToWebDAV(session *models.SyncSession, endpoint *models.SyncEndpoint, client *WebDAVClient) error <span class="cov0" title="0">{
        localFiles, err := s.scanLocalFiles(endpoint.LocalPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan local files: %w", err)
        }</span>

        <span class="cov0" title="0">session.TotalFiles = len(localFiles)
        s.syncRepo.UpdateSession(session)

        for _, localFile := range localFiles </span><span class="cov0" title="0">{
                relativePath, err := filepath.Rel(endpoint.LocalPath, localFile)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">remotePath := filepath.Join(endpoint.RemotePath, relativePath)
                remotePath = filepath.ToSlash(remotePath)

                if s.shouldSkipFile(localFile, endpoint) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">remoteModTime, err := client.GetModTime(remotePath)
                if err == nil </span><span class="cov0" title="0">{
                        localInfo, err := os.Stat(localFile)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if !localInfo.ModTime().After(remoteModTime) </span><span class="cov0" title="0">{
                                session.SkippedFiles++
                                continue</span>
                        }
                }

                <span class="cov0" title="0">err = client.UploadFile(localFile, remotePath)
                if err != nil </span><span class="cov0" title="0">{
                        session.FailedFiles++
                        s.logSyncError(session, fmt.Sprintf("Failed to upload %s: %v", localFile, err))
                }</span> else<span class="cov0" title="0"> {
                        session.SyncedFiles++
                }</span>

                <span class="cov0" title="0">s.syncRepo.UpdateSession(session)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) downloadFromWebDAV(session *models.SyncSession, endpoint *models.SyncEndpoint, client *WebDAVClient) error <span class="cov0" title="0">{
        remoteFiles, err := client.ListFiles(endpoint.RemotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list remote files: %w", err)
        }</span>

        <span class="cov0" title="0">session.TotalFiles += len(remoteFiles)
        s.syncRepo.UpdateSession(session)

        for _, remoteFile := range remoteFiles </span><span class="cov0" title="0">{
                relativePath, err := filepath.Rel(endpoint.RemotePath, remoteFile.Path)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">localPath := filepath.Join(endpoint.LocalPath, relativePath)

                if s.shouldSkipRemoteFile(remoteFile, endpoint) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">localInfo, err := os.Stat(localPath)
                if err == nil </span><span class="cov0" title="0">{
                        if !remoteFile.ModTime.After(localInfo.ModTime()) </span><span class="cov0" title="0">{
                                session.SkippedFiles++
                                continue</span>
                        }
                }

                <span class="cov0" title="0">err = os.MkdirAll(filepath.Dir(localPath), 0755)
                if err != nil </span><span class="cov0" title="0">{
                        session.FailedFiles++
                        continue</span>
                }

                <span class="cov0" title="0">err = client.DownloadFile(remoteFile.Path, localPath)
                if err != nil </span><span class="cov0" title="0">{
                        session.FailedFiles++
                        s.logSyncError(session, fmt.Sprintf("Failed to download %s: %v", remoteFile.Path, err))
                }</span> else<span class="cov0" title="0"> {
                        session.SyncedFiles++
                }</span>

                <span class="cov0" title="0">s.syncRepo.UpdateSession(session)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) performCloudSync(session *models.SyncSession, endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        ctx := context.Background()
        
        switch endpoint.Type </span>{
        case "s3":<span class="cov0" title="0">
                return s.performS3Sync(ctx, session, endpoint)</span>
        case "google_drive":<span class="cov0" title="0">
                return s.performGoogleCloudStorageSync(ctx, session, endpoint)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported cloud storage type: %s", endpoint.Type)</span>
        }
}

// performS3Sync syncs files with Amazon S3
func (s *SyncService) performS3Sync(ctx context.Context, session *models.SyncSession, endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        // Parse configuration
        syncConfig := make(map[string]interface{})
        if endpoint.SyncSettings != nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(*endpoint.SyncSettings), &amp;syncConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse S3 config: %w", err)
                }</span>
        }

        // Extract S3 configuration
        <span class="cov0" title="0">bucket, ok := syncConfig["bucket"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("S3 bucket not specified")
        }</span>

        <span class="cov0" title="0">region, _ := syncConfig["region"].(string)
        if region == "" </span><span class="cov0" title="0">{
                region = "us-east-1"
        }</span>

        <span class="cov0" title="0">accessKey, ok := syncConfig["access_key"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("S3 access key not specified")
        }</span>

        <span class="cov0" title="0">secretKey, ok := syncConfig["secret_key"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("S3 secret key not specified")
        }</span>

        // Create AWS configuration
        <span class="cov0" title="0">awsCfg, err := config.LoadDefaultConfig(ctx,
                config.WithRegion(region),
                config.WithCredentialsProvider(aws.CredentialsProviderFunc(func(ctx context.Context) (aws.Credentials, error) </span><span class="cov0" title="0">{
                        return aws.Credentials{
                                AccessKeyID:     accessKey,
                                SecretAccessKey: secretKey,
                        }, nil
                }</span>)),
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create AWS config: %w", err)
        }</span>

        // Create S3 client
        <span class="cov0" title="0">client := s3.NewFromConfig(awsCfg)

        // Get source directory from sync settings
        sourceDir, ok := syncConfig["source_directory"].(string)
        if !ok </span><span class="cov0" title="0">{
                // Fallback to local path
                sourceDir = endpoint.LocalPath
                if sourceDir == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("source directory not specified")
                }</span>
        }

        // Walk through source directory and upload files
        <span class="cov0" title="0">err = filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip directories
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Calculate relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(sourceDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to calculate relative path: %w", err)
                }</span>

                // Convert to forward slashes for S3
                <span class="cov0" title="0">s3Key := filepath.ToSlash(relPath)

                // Open file
                file, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open file %s: %w", path, err)
                }</span>
                <span class="cov0" title="0">defer file.Close()

                // Upload to S3
                _, err = client.PutObject(ctx, &amp;s3.PutObjectInput{
                        Bucket: aws.String(bucket),
                        Key:    aws.String(s3Key),
                        Body:   file,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to upload %s to S3: %w", s3Key, err)
                }</span>

                // Update sync session progress
                <span class="cov0" title="0">s.updateSyncProgress(session, fmt.Sprintf("Uploaded: %s", s3Key))

                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("S3 sync failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// performGoogleCloudStorageSync syncs files with Google Cloud Storage
func (s *SyncService) performGoogleCloudStorageSync(ctx context.Context, session *models.SyncSession, endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        // Parse configuration
        syncConfig := make(map[string]interface{})
        if endpoint.SyncSettings != nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(*endpoint.SyncSettings), &amp;syncConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse Google Cloud Storage config: %w", err)
                }</span>
        }

        // Extract GCS configuration
        <span class="cov0" title="0">bucket, ok := syncConfig["bucket"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("GCS bucket not specified")
        }</span>

        <span class="cov0" title="0">credentialsFile, _ := syncConfig["credentials_file"].(string)
        
        // Create GCS client
        var client *storage.Client
        var err error
        
        if credentialsFile != "" </span><span class="cov0" title="0">{
                // Use credentials file
                client, err = storage.NewClient(ctx, option.WithCredentialsFile(credentialsFile))
        }</span> else<span class="cov0" title="0"> {
                // Use default credentials
                client, err = storage.NewClient(ctx)
        }</span>
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create GCS client: %w", err)
        }</span>
        <span class="cov0" title="0">defer client.Close()

        // Get source directory from sync settings
        sourceDir, ok := syncConfig["source_directory"].(string)
        if !ok </span><span class="cov0" title="0">{
                // Fallback to local path
                sourceDir = endpoint.LocalPath
                if sourceDir == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("source directory not specified")
                }</span>
        }

        // Walk through source directory and upload files
        <span class="cov0" title="0">err = filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip directories
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Calculate relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(sourceDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to calculate relative path: %w", err)
                }</span>

                // Convert to forward slashes for GCS
                <span class="cov0" title="0">gcsObject := filepath.ToSlash(relPath)

                // Open file
                file, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open file %s: %w", path, err)
                }</span>
                <span class="cov0" title="0">defer file.Close()

                // Create GCS object writer
                wc := client.Bucket(bucket).Object(gcsObject).NewWriter(ctx)
                defer wc.Close()

                // Copy file to GCS
                _, err = io.Copy(wc, file)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to upload %s to GCS: %w", gcsObject, err)
                }</span>

                // Close writer to complete upload
                <span class="cov0" title="0">if err := wc.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to complete upload of %s to GCS: %w", gcsObject, err)
                }</span>

                // Update sync session progress
                <span class="cov0" title="0">s.updateSyncProgress(session, fmt.Sprintf("Uploaded: %s", gcsObject))

                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Google Cloud Storage sync failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) performLocalSync(session *models.SyncSession, endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        // Parse configuration
        syncConfig := make(map[string]interface{})
        if endpoint.SyncSettings != nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(*endpoint.SyncSettings), &amp;syncConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse local sync config: %w", err)
                }</span>
        }

        // Get source directory from sync settings or endpoint local path
        <span class="cov0" title="0">sourceDir, ok := syncConfig["source_directory"].(string)
        if !ok </span><span class="cov0" title="0">{
                sourceDir = endpoint.LocalPath
                if sourceDir == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("source directory not specified")
                }</span>
        }

        // Get destination directory
        <span class="cov0" title="0">destDir, ok := syncConfig["destination_directory"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("destination directory not specified")
        }</span>

        // Get sync mode (optional)
        <span class="cov0" title="0">syncMode := "mirror" // default
        if mode, ok := syncConfig["sync_mode"].(string); ok </span><span class="cov0" title="0">{
                syncMode = mode
        }</span>

        // Verify source directory exists
        <span class="cov0" title="0">sourceInfo, err := os.Stat(sourceDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("source directory does not exist: %w", err)
        }</span>
        <span class="cov0" title="0">if !sourceInfo.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("source path is not a directory")
        }</span>

        // Create destination directory if it doesn't exist
        <span class="cov0" title="0">if err := os.MkdirAll(destDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Perform sync based on mode
        <span class="cov0" title="0">switch syncMode </span>{
        case "mirror":<span class="cov0" title="0">
                err = s.performMirrorSync(sourceDir, destDir, session)</span>
        case "incremental":<span class="cov0" title="0">
                err = s.performIncrementalSync(sourceDir, destDir, session)</span>
        case "bidirectional":<span class="cov0" title="0">
                err = s.performBidirectionalSync(sourceDir, destDir, session)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported sync mode: %s", syncMode)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("local sync failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// performMirrorSync creates exact copy of source in destination
func (s *SyncService) performMirrorSync(sourceDir, destDir string, session *models.SyncSession) error <span class="cov0" title="0">{
        // Walk through source directory
        err := filepath.Walk(sourceDir, func(sourcePath string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Calculate relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(sourceDir, sourcePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to calculate relative path: %w", err)
                }</span>

                // Build destination path
                <span class="cov0" title="0">destPath := filepath.Join(destDir, relPath)

                // Handle directories
                if info.IsDir() </span><span class="cov0" title="0">{
                        // Create destination directory
                        if err := os.MkdirAll(destPath, info.Mode()); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", destPath, err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                // Handle files
                // Check if file needs to be copied
                <span class="cov0" title="0">destInfo, err := os.Stat(destPath)
                if err == nil </span><span class="cov0" title="0">{
                        // Compare modification times
                        if !info.ModTime().After(destInfo.ModTime()) </span><span class="cov0" title="0">{
                                // Source is not newer, skip
                                return nil
                        }</span>

                        // Compare file sizes
                        <span class="cov0" title="0">if info.Size() == destInfo.Size() &amp;&amp; info.ModTime().Equal(destInfo.ModTime()) </span><span class="cov0" title="0">{
                                // Files are identical, skip
                                return nil
                        }</span>
                }

                // Copy file
                <span class="cov0" title="0">if err := s.copyFile(sourcePath, destPath, info.Mode()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to copy file %s to %s: %w", sourcePath, destPath, err)
                }</span>

                // Update sync session progress
                <span class="cov0" title="0">s.updateSyncProgress(session, fmt.Sprintf("Synced: %s", relPath))

                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mirror sync failed: %w", err)
        }</span>

        // Remove files in destination that don't exist in source
        <span class="cov0" title="0">err = s.cleanupDestination(sourceDir, destDir, session)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cleanup destination: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// performIncrementalSync only copies newer or missing files
func (s *SyncService) performIncrementalSync(sourceDir, destDir string, session *models.SyncSession) error <span class="cov0" title="0">{
        // Walk through source directory
        err := filepath.Walk(sourceDir, func(sourcePath string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip directories for incremental sync
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Calculate relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(sourceDir, sourcePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to calculate relative path: %w", err)
                }</span>

                // Build destination path
                <span class="cov0" title="0">destPath := filepath.Join(destDir, relPath)

                // Check if destination exists
                destInfo, err := os.Stat(destPath)
                if err == nil </span><span class="cov0" title="0">{
                        // File exists, check if source is newer
                        if !info.ModTime().After(destInfo.ModTime()) </span><span class="cov0" title="0">{
                                // Source is not newer, skip
                                return nil
                        }</span>
                }

                // Copy file
                <span class="cov0" title="0">if err := s.copyFile(sourcePath, destPath, info.Mode()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to copy file %s to %s: %w", sourcePath, destPath, err)
                }</span>

                // Update sync session progress
                <span class="cov0" title="0">s.updateSyncProgress(session, fmt.Sprintf("Incrementally synced: %s", relPath))

                return nil</span>
        })

        <span class="cov0" title="0">return err</span>
}

// performBidirectionalSync syncs in both directions
func (s *SyncService) performBidirectionalSync(sourceDir, destDir string, session *models.SyncSession) error <span class="cov0" title="0">{
        // For bidirectional sync, we perform incremental sync in both directions
        // First sync source to destination
        if err := s.performIncrementalSync(sourceDir, destDir, session); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("source to destination sync failed: %w", err)
        }</span>

        // Then sync destination to source
        <span class="cov0" title="0">if err := s.performIncrementalSync(destDir, sourceDir, session); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("destination to source sync failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// copyFile copies a file with proper permissions
func (s *SyncService) copyFile(src, dst string, mode os.FileMode) error <span class="cov0" title="0">{
        // Ensure destination directory exists
        if err := os.MkdirAll(filepath.Dir(dst), 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Open source file
        <span class="cov0" title="0">sourceFile, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sourceFile.Close()

        // Create destination file
        destFile, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, mode)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer destFile.Close()

        // Copy file content
        _, err = io.Copy(destFile, sourceFile)
        return err</span>
}

// cleanupDestination removes files in destination that don't exist in source
func (s *SyncService) cleanupDestination(sourceDir, destDir string, session *models.SyncSession) error <span class="cov0" title="0">{
        // Walk through destination directory
        return filepath.Walk(destDir, func(destPath string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Calculate relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(destDir, destPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to calculate relative path: %w", err)
                }</span>

                // Build corresponding source path
                <span class="cov0" title="0">sourcePath := filepath.Join(sourceDir, relPath)

                // Check if corresponding source file exists
                _, err = os.Stat(sourcePath)
                if err != nil </span><span class="cov0" title="0">{
                        // Source file doesn't exist, remove destination file
                        if info.IsDir() </span><span class="cov0" title="0">{
                                // Remove directory if it's empty
                                if err := os.Remove(destPath); err != nil </span><span class="cov0" title="0">{
                                        // Directory not empty, skip
                                        return nil
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Remove file
                                if err := os.Remove(destPath); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to remove %s: %w", destPath, err)
                                }</span>
                        }

                        // Update sync session progress
                        <span class="cov0" title="0">s.updateSyncProgress(session, fmt.Sprintf("Removed: %s", relPath))</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

func (s *SyncService) handleSyncSuccess(session *models.SyncSession) <span class="cov0" title="0">{
        session.Status = models.SyncSessionStatusCompleted
        session.CompletedAt = &amp;time.Time{}
        *session.CompletedAt = time.Now()

        if session.StartedAt != (time.Time{}) </span><span class="cov0" title="0">{
                duration := session.CompletedAt.Sub(session.StartedAt)
                session.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">s.syncRepo.UpdateSession(session)
        s.notifyUser(session, "Sync completed successfully")</span>
}

func (s *SyncService) handleSyncError(session *models.SyncSession, syncError error) <span class="cov0" title="0">{
        session.Status = models.SyncSessionStatusFailed
        session.CompletedAt = &amp;time.Time{}
        *session.CompletedAt = time.Now()
        errorMsg := syncError.Error()
        session.ErrorMessage = &amp;errorMsg

        if session.StartedAt != (time.Time{}) </span><span class="cov0" title="0">{
                duration := session.CompletedAt.Sub(session.StartedAt)
                session.Duration = &amp;duration
        }</span>

        <span class="cov0" title="0">s.syncRepo.UpdateSession(session)
        s.notifyUser(session, fmt.Sprintf("Sync failed: %s", syncError.Error()))</span>
}

func (s *SyncService) updateSyncProgress(session *models.SyncSession, message string) <span class="cov0" title="0">{
        // In a full implementation, this would update the session with current progress
        // For now, we just log the progress update
        fmt.Printf("Sync progress for session %d: %s\n", session.ID, message)
}</span>

func (s *SyncService) logSyncError(session *models.SyncSession, message string) <span class="cov0" title="0">{
        // In a full implementation, this would log to a sync error log
        fmt.Printf("Sync error for session %d: %s\n", session.ID, message)
}</span>

func (s *SyncService) notifyUser(session *models.SyncSession, message string) <span class="cov0" title="0">{
        // In a full implementation, this would send notifications
        fmt.Printf("Notification for user %d: %s (Session %d)\n", session.UserID, message, session.ID)
}</span>

func (s *SyncService) GetUserSessions(userID int, limit, offset int) ([]models.SyncSession, error) <span class="cov0" title="0">{
        return s.syncRepo.GetUserSessions(userID, limit, offset)
}</span>

func (s *SyncService) GetSession(sessionID int, userID int) (*models.SyncSession, error) <span class="cov0" title="0">{
        session, err := s.syncRepo.GetSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if session.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionViewShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to view this session")
                }</span>
        }

        <span class="cov0" title="0">return session, nil</span>
}

func (s *SyncService) ScheduleSync(endpointID int, userID int, schedule *models.SyncSchedule) (*models.SyncSchedule, error) <span class="cov0" title="0">{
        endpoint, err := s.syncRepo.GetEndpoint(endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if endpoint.UserID != userID </span><span class="cov0" title="0">{
                hasPermission, err := s.authService.CheckPermission(userID, models.PermissionEditShares)
                if err != nil || !hasPermission </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized to schedule sync for this endpoint")
                }</span>
        }

        <span class="cov0" title="0">schedule.EndpointID = endpointID
        schedule.UserID = userID
        schedule.CreatedAt = time.Now()
        schedule.IsActive = true

        id, err := s.syncRepo.CreateSchedule(schedule)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sync schedule: %w", err)
        }</span>

        <span class="cov0" title="0">schedule.ID = id
        return schedule, nil</span>
}

func (s *SyncService) GetSyncStatistics(userID *int, startDate, endDate time.Time) (*models.SyncStatistics, error) <span class="cov0" title="0">{
        return s.syncRepo.GetStatistics(userID, startDate, endDate)
}</span>

func (s *SyncService) ProcessScheduledSyncs() error <span class="cov0" title="0">{
        schedules, err := s.syncRepo.GetActiveSchedules()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, schedule := range schedules </span><span class="cov0" title="0">{
                if s.shouldRunSchedule(&amp;schedule) </span><span class="cov0" title="0">{
                        _, err := s.StartSync(schedule.EndpointID, schedule.UserID)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to start scheduled sync for endpoint %d: %v\n", schedule.EndpointID, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) shouldRunSchedule(schedule *models.SyncSchedule) bool <span class="cov0" title="0">{
        now := time.Now()

        switch schedule.Frequency </span>{
        case models.SyncFrequencyHourly:<span class="cov0" title="0">
                return schedule.LastRun == nil || schedule.LastRun.Add(time.Hour).Before(now)</span>
        case models.SyncFrequencyDaily:<span class="cov0" title="0">
                return schedule.LastRun == nil || schedule.LastRun.Add(24*time.Hour).Before(now)</span>
        case models.SyncFrequencyWeekly:<span class="cov0" title="0">
                return schedule.LastRun == nil || schedule.LastRun.Add(7*24*time.Hour).Before(now)</span>
        case models.SyncFrequencyMonthly:<span class="cov0" title="0">
                return schedule.LastRun == nil || schedule.LastRun.AddDate(0, 1, 0).Before(now)</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (s *SyncService) validateSyncEndpoint(endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        if endpoint.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("name is required")
        }</span>

        <span class="cov0" title="0">if endpoint.URL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("URL is required")
        }</span>

        <span class="cov0" title="0">if endpoint.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("type is required")
        }</span>

        <span class="cov0" title="0">if endpoint.SyncDirection == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("sync direction is required")
        }</span>

        <span class="cov0" title="0">if endpoint.LocalPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("local path is required")
        }</span>

        <span class="cov0" title="0">validTypes := []string{models.SyncTypeWebDAV, models.SyncTypeCloudStorage, models.SyncTypeLocal}
        if !s.isValidType(endpoint.Type, validTypes) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid sync type: %s", endpoint.Type)
        }</span>

        <span class="cov0" title="0">validDirections := []string{models.SyncDirectionUpload, models.SyncDirectionDownload, models.SyncDirectionBidirectional}
        if !s.isValidType(endpoint.SyncDirection, validDirections) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid sync direction: %s", endpoint.SyncDirection)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *SyncService) isValidType(value string, validValues []string) bool <span class="cov0" title="0">{
        for _, valid := range validValues </span><span class="cov0" title="0">{
                if value == valid </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (s *SyncService) testConnection(endpoint *models.SyncEndpoint) error <span class="cov0" title="0">{
        switch endpoint.Type </span>{
        case models.SyncTypeWebDAV:<span class="cov0" title="0">
                client, err := s.getWebDAVClient(endpoint)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return client.TestConnection()</span>
        default:<span class="cov0" title="0">
                return nil</span> // Skip test for other types for now
        }
}

func (s *SyncService) getWebDAVClient(endpoint *models.SyncEndpoint) (*WebDAVClient, error) <span class="cov0" title="0">{
        if client, exists := s.webdavClients[endpoint.ID]; exists </span><span class="cov0" title="0">{
                return client, nil
        }</span>

        <span class="cov0" title="0">client := NewWebDAVClient(endpoint.URL, endpoint.Username, endpoint.Password)
        s.webdavClients[endpoint.ID] = client

        return client, nil</span>
}

func (s *SyncService) scanLocalFiles(path string) ([]string, error) <span class="cov0" title="0">{
        var files []string

        err := filepath.Walk(path, func(filePath string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        files = append(files, filePath)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return files, err</span>
}

func (s *SyncService) shouldSkipFile(filePath string, endpoint *models.SyncEndpoint) bool <span class="cov0" title="0">{
        fileName := filepath.Base(filePath)

        // Skip hidden files
        if strings.HasPrefix(fileName, ".") </span><span class="cov0" title="0">{
                return true
        }</span>

        // Skip temporary files
        <span class="cov0" title="0">if strings.HasSuffix(fileName, ".tmp") || strings.HasSuffix(fileName, ".temp") </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check file size limits if configured
        <span class="cov0" title="0">if endpoint.SyncSettings != nil </span>{<span class="cov0" title="0">
                // This would parse JSON settings and check file size limits
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (s *SyncService) shouldSkipRemoteFile(file *WebDAVFile, endpoint *models.SyncEndpoint) bool <span class="cov0" title="0">{
        fileName := filepath.Base(file.Path)

        // Skip hidden files
        if strings.HasPrefix(fileName, ".") </span><span class="cov0" title="0">{
                return true
        }</span>

        // Skip temporary files
        <span class="cov0" title="0">if strings.HasSuffix(fileName, ".tmp") || strings.HasSuffix(fileName, ".temp") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (s *SyncService) calculateChecksum(filePath string) (string, error) <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        hash := md5.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return hex.EncodeToString(hash.Sum(nil)), nil</span>
}

func (s *SyncService) CleanupOldSessions(olderThan time.Time) error <span class="cov0" title="0">{
        return s.syncRepo.CleanupSessions(olderThan)
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">package services

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/studio-b12/gowebdav"
)

type WebDAVClient struct {
        client   *gowebdav.Client
        baseURL  string
        username string
        password string
}

type WebDAVFile struct {
        Path    string
        Size    int64
        ModTime time.Time
        IsDir   bool
}

func NewWebDAVClient(url, username, password string) *WebDAVClient <span class="cov0" title="0">{
        client := gowebdav.NewClient(url, username, password)

        return &amp;WebDAVClient{
                client:   client,
                baseURL:  url,
                username: username,
                password: password,
        }
}</span>

func (c *WebDAVClient) TestConnection() error <span class="cov0" title="0">{
        _, err := c.client.ReadDir("/")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WebDAV connection test failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) ListFiles(remotePath string) ([]*WebDAVFile, error) <span class="cov0" title="0">{
        files, err := c.client.ReadDir(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list files: %w", err)
        }</span>

        <span class="cov0" title="0">var webdavFiles []*WebDAVFile
        for _, file := range files </span><span class="cov0" title="0">{
                webdavFile := &amp;WebDAVFile{
                        Path:    filepath.Join(remotePath, file.Name()),
                        Size:    file.Size(),
                        ModTime: file.ModTime(),
                        IsDir:   file.IsDir(),
                }
                webdavFiles = append(webdavFiles, webdavFile)

                // Recursively list subdirectories if needed
                if file.IsDir() </span><span class="cov0" title="0">{
                        subFiles, err := c.ListFiles(webdavFile.Path)
                        if err == nil </span><span class="cov0" title="0">{
                                webdavFiles = append(webdavFiles, subFiles...)
                        }</span>
                }
        }

        <span class="cov0" title="0">return webdavFiles, nil</span>
}

func (c *WebDAVClient) UploadFile(localPath, remotePath string) error <span class="cov0" title="0">{
        // Ensure remote directory exists
        remoteDir := filepath.Dir(remotePath)
        if err := c.client.MkdirAll(remoteDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create remote directory: %w", err)
        }</span>

        // Open local file
        <span class="cov0" title="0">localFile, err := os.Open(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open local file: %w", err)
        }</span>
        <span class="cov0" title="0">defer localFile.Close()

        // Upload to WebDAV
        err = c.client.WriteStream(remotePath, localFile, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) DownloadFile(remotePath, localPath string) error <span class="cov0" title="0">{
        // Create local directory if it doesn't exist
        localDir := filepath.Dir(localPath)
        if err := os.MkdirAll(localDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local directory: %w", err)
        }</span>

        // Open remote file
        <span class="cov0" title="0">reader, err := c.client.ReadStream(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open remote file: %w", err)
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        // Create local file
        localFile, err := os.Create(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local file: %w", err)
        }</span>
        <span class="cov0" title="0">defer localFile.Close()

        // Copy data
        _, err = io.Copy(localFile, reader)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) GetModTime(remotePath string) (time.Time, error) <span class="cov0" title="0">{
        info, err := c.client.Stat(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">return info.ModTime(), nil</span>
}

func (c *WebDAVClient) DeleteFile(remotePath string) error <span class="cov0" title="0">{
        err := c.client.Remove(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) MoveFile(sourcePath, destPath string) error <span class="cov0" title="0">{
        err := c.client.Rename(sourcePath, destPath, false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to move file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) CopyFile(sourcePath, destPath string) error <span class="cov0" title="0">{
        err := c.client.Copy(sourcePath, destPath, false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) CreateDirectory(remotePath string) error <span class="cov0" title="0">{
        err := c.client.Mkdir(remotePath, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *WebDAVClient) FileExists(remotePath string) bool <span class="cov0" title="0">{
        _, err := c.client.Stat(remotePath)
        return err == nil
}</span>

func (c *WebDAVClient) GetFileSize(remotePath string) (int64, error) <span class="cov0" title="0">{
        info, err := c.client.Stat(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">return info.Size(), nil</span>
}

func (c *WebDAVClient) GetQuota() (*WebDAVQuota, error) <span class="cov0" title="0">{
        // This would require parsing PROPFIND response for quota information
        // For now, return a placeholder
        return &amp;WebDAVQuota{
                Used:      0,
                Available: -1, // Unlimited
        }, nil
}</span>

type WebDAVQuota struct {
        Used      int64 `json:"used"`
        Available int64 `json:"available"` // -1 for unlimited
}

// Batch operations for efficiency

func (c *WebDAVClient) UploadBatch(files []FileTransfer) (*BatchResult, error) <span class="cov0" title="0">{
        result := &amp;BatchResult{
                Total:     len(files),
                Succeeded: 0,
                Failed:    0,
                Errors:    make([]string, 0),
        }

        for _, file := range files </span><span class="cov0" title="0">{
                err := c.UploadFile(file.LocalPath, file.RemotePath)
                if err != nil </span><span class="cov0" title="0">{
                        result.Failed++
                        result.Errors = append(result.Errors, fmt.Sprintf("%s: %v", file.LocalPath, err))
                }</span> else<span class="cov0" title="0"> {
                        result.Succeeded++
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func (c *WebDAVClient) DownloadBatch(files []FileTransfer) (*BatchResult, error) <span class="cov0" title="0">{
        result := &amp;BatchResult{
                Total:     len(files),
                Succeeded: 0,
                Failed:    0,
                Errors:    make([]string, 0),
        }

        for _, file := range files </span><span class="cov0" title="0">{
                err := c.DownloadFile(file.RemotePath, file.LocalPath)
                if err != nil </span><span class="cov0" title="0">{
                        result.Failed++
                        result.Errors = append(result.Errors, fmt.Sprintf("%s: %v", file.RemotePath, err))
                }</span> else<span class="cov0" title="0"> {
                        result.Succeeded++
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

type FileTransfer struct {
        LocalPath  string
        RemotePath string
}

type BatchResult struct {
        Total     int      `json:"total"`
        Succeeded int      `json:"succeeded"`
        Failed    int      `json:"failed"`
        Errors    []string `json:"errors"`
}

// Sync-specific methods

func (c *WebDAVClient) SyncDirectory(localPath, remotePath string, direction string) (*SyncResult, error) <span class="cov0" title="0">{
        result := &amp;SyncResult{
                UploadedFiles:   0,
                DownloadedFiles: 0,
                SkippedFiles:    0,
                FailedFiles:     0,
                Errors:          make([]string, 0),
        }

        switch direction </span>{
        case "upload":<span class="cov0" title="0">
                return c.syncUpload(localPath, remotePath, result)</span>
        case "download":<span class="cov0" title="0">
                return c.syncDownload(localPath, remotePath, result)</span>
        case "bidirectional":<span class="cov0" title="0">
                // First upload, then download
                result, err := c.syncUpload(localPath, remotePath, result)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">return c.syncDownload(localPath, remotePath, result)</span>
        default:<span class="cov0" title="0">
                return result, fmt.Errorf("invalid sync direction: %s", direction)</span>
        }
}

func (c *WebDAVClient) syncUpload(localPath, remotePath string, result *SyncResult) (*SyncResult, error) <span class="cov0" title="0">{
        err := filepath.Walk(localPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Skip hidden files and temporary files
                <span class="cov0" title="0">if strings.HasPrefix(info.Name(), ".") || strings.HasSuffix(info.Name(), ".tmp") </span><span class="cov0" title="0">{
                        result.SkippedFiles++
                        return nil
                }</span>

                <span class="cov0" title="0">relPath, err := filepath.Rel(localPath, path)
                if err != nil </span><span class="cov0" title="0">{
                        result.FailedFiles++
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to get relative path for %s: %v", path, err))
                        return nil
                }</span>

                <span class="cov0" title="0">remoteFilePath := filepath.Join(remotePath, relPath)
                remoteFilePath = filepath.ToSlash(remoteFilePath) // Convert to forward slashes for WebDAV

                // Check if remote file exists and compare modification times
                remoteModTime, err := c.GetModTime(remoteFilePath)
                if err == nil </span><span class="cov0" title="0">{
                        // Remote file exists, check if local is newer
                        if !info.ModTime().After(remoteModTime) </span><span class="cov0" title="0">{
                                result.SkippedFiles++
                                return nil
                        }</span>
                }

                // Upload the file
                <span class="cov0" title="0">err = c.UploadFile(path, remoteFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        result.FailedFiles++
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to upload %s: %v", path, err))
                }</span> else<span class="cov0" title="0"> {
                        result.UploadedFiles++
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return result, err</span>
}

func (c *WebDAVClient) syncDownload(localPath, remotePath string, result *SyncResult) (*SyncResult, error) <span class="cov0" title="0">{
        remoteFiles, err := c.ListFiles(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return result, fmt.Errorf("failed to list remote files: %w", err)
        }</span>

        <span class="cov0" title="0">for _, remoteFile := range remoteFiles </span><span class="cov0" title="0">{
                if remoteFile.IsDir </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip hidden files and temporary files
                <span class="cov0" title="0">fileName := filepath.Base(remoteFile.Path)
                if strings.HasPrefix(fileName, ".") || strings.HasSuffix(fileName, ".tmp") </span><span class="cov0" title="0">{
                        result.SkippedFiles++
                        continue</span>
                }

                <span class="cov0" title="0">relPath, err := filepath.Rel(remotePath, remoteFile.Path)
                if err != nil </span><span class="cov0" title="0">{
                        result.FailedFiles++
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to get relative path for %s: %v", remoteFile.Path, err))
                        continue</span>
                }

                <span class="cov0" title="0">localFilePath := filepath.Join(localPath, relPath)

                // Check if local file exists and compare modification times
                localInfo, err := os.Stat(localFilePath)
                if err == nil </span><span class="cov0" title="0">{
                        // Local file exists, check if remote is newer
                        if !remoteFile.ModTime.After(localInfo.ModTime()) </span><span class="cov0" title="0">{
                                result.SkippedFiles++
                                continue</span>
                        }
                }

                // Download the file
                <span class="cov0" title="0">err = c.DownloadFile(remoteFile.Path, localFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        result.FailedFiles++
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to download %s: %v", remoteFile.Path, err))
                }</span> else<span class="cov0" title="0"> {
                        result.DownloadedFiles++
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

type SyncResult struct {
        UploadedFiles   int      `json:"uploaded_files"`
        DownloadedFiles int      `json:"downloaded_files"`
        SkippedFiles    int      `json:"skipped_files"`
        FailedFiles     int      `json:"failed_files"`
        Errors          []string `json:"errors"`
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package smb

import (
        "fmt"
        "io"
        "net"

        "github.com/hirochachacha/go-smb2"
)

// SmbClient represents an SMB client connection
type SmbClient struct {
        conn    net.Conn
        session *smb2.Session
        share   *smb2.Share
        config  *SmbConfig
}

// SmbConfig contains SMB connection configuration
type SmbConfig struct {
        Host     string
        Port     int
        Share    string
        Username string
        Password string
        Domain   string
}

// NewSmbClient creates a new SMB client
func NewSmbClient(config *SmbConfig) (*SmbClient, error) <span class="cov0" title="0">{
        // Establish TCP connection
        addr := fmt.Sprintf("%s:%d", config.Host, config.Port)
        conn, err := net.Dial("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to SMB server: %w", err)
        }</span>

        // Create SMB session
        <span class="cov0" title="0">d := &amp;smb2.Dialer{
                Initiator: &amp;smb2.NTLMInitiator{
                        User:     config.Username,
                        Password: config.Password,
                        Domain:   config.Domain,
                },
        }

        session, err := d.Dial(conn)
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to create SMB session: %w", err)
        }</span>

        // Mount share
        <span class="cov0" title="0">share, err := session.Mount(config.Share)
        if err != nil </span><span class="cov0" title="0">{
                session.Logoff()
                conn.Close()
                return nil, fmt.Errorf("failed to mount SMB share: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SmbClient{
                conn:    conn,
                session: session,
                share:   share,
                config:  config,
        }, nil</span>
}

// TestConnection tests the SMB connection
func (c *SmbClient) TestConnection() error <span class="cov0" title="0">{
        // Try to list the root directory
        _, err := c.share.ReadDir(".")
        return err
}</span>

// ReadFile reads a file from the SMB share
func (c *SmbClient) ReadFile(path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        file, err := c.share.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open SMB file %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return file, nil</span>
}

// WriteFile writes a file to the SMB share
func (c *SmbClient) WriteFile(path string, data io.Reader) error <span class="cov0" title="0">{
        file, err := c.share.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create SMB file %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        _, err = io.Copy(file, data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write SMB file %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetFileInfo gets information about a file
func (c *SmbClient) GetFileInfo(path string) (*FileInfo, error) <span class="cov0" title="0">{
        stat, err := c.share.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat SMB file %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return &amp;FileInfo{
                Name:    stat.Name(),
                Size:    stat.Size(),
                ModTime: stat.ModTime(),
                IsDir:   stat.IsDir(),
                Mode:    stat.Mode(),
        }, nil</span>
}

// ListDirectory lists files in a directory
func (c *SmbClient) ListDirectory(path string) ([]*FileInfo, error) <span class="cov0" title="0">{
        entries, err := c.share.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list SMB directory %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">var files []*FileInfo
        for _, entry := range entries </span><span class="cov0" title="0">{
                files = append(files, &amp;FileInfo{
                        Name:    entry.Name(),
                        Size:    entry.Size(),
                        ModTime: entry.ModTime(),
                        IsDir:   entry.IsDir(),
                        Mode:    entry.Mode(),
                })
        }</span>

        <span class="cov0" title="0">return files, nil</span>
}

// FileExists checks if a file exists
func (c *SmbClient) FileExists(path string) (bool, error) <span class="cov0" title="0">{
        _, err := c.share.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                if isNotExistError(err) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check SMB file existence %s: %w", path, err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// CreateDirectory creates a directory
func (c *SmbClient) CreateDirectory(path string) error <span class="cov0" title="0">{
        err := c.share.Mkdir(path, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create SMB directory %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteFile deletes a file
func (c *SmbClient) DeleteFile(path string) error <span class="cov0" title="0">{
        err := c.share.Remove(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete SMB file %s: %w", path, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CopyFile copies a file within the SMB share
func (c *SmbClient) CopyFile(srcPath, dstPath string) error <span class="cov0" title="0">{
        // Read source file
        srcFile, err := c.share.Open(srcPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file %s: %w", srcPath, err)
        }</span>
        <span class="cov0" title="0">defer srcFile.Close()

        // Create destination file
        dstFile, err := c.share.Create(dstPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination file %s: %w", dstPath, err)
        }</span>
        <span class="cov0" title="0">defer dstFile.Close()

        // Copy data
        _, err = io.Copy(dstFile, srcFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file from %s to %s: %w", srcPath, dstPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Close closes the SMB connection
func (c *SmbClient) Close() error <span class="cov0" title="0">{
        var errs []error

        if c.share != nil </span><span class="cov0" title="0">{
                if err := c.share.Umount(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to unmount share: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if c.session != nil </span><span class="cov0" title="0">{
                if err := c.session.Logoff(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to logoff session: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if c.conn != nil </span><span class="cov0" title="0">{
                if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to close connection: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors closing SMB client: %v", errs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetConfig returns the SMB configuration
func (c *SmbClient) GetConfig() *SmbConfig <span class="cov0" title="0">{
        return c.config
}</span>

// Helper function to check if error is "file not found"
func isNotExistError(err error) bool <span class="cov0" title="0">{
        // This is a simplified check - in practice you might want to check
        // for specific SMB error codes
        return err != nil &amp;&amp; (err.Error() == "file does not exist" || err.Error() == "no such file or directory")
}</span>
</pre>
		
		<pre class="file" id="file107" style="display: none">package smb

import (
        "os"
        "time"
)

// FileInfo represents file information from SMB
type FileInfo struct {
        Name    string
        Size    int64
        ModTime time.Time
        IsDir   bool
        Mode    os.FileMode
}

// CopyOperation represents a file copy operation
type CopyOperation struct {
        SourcePath        string
        DestinationPath   string
        OverwriteExisting bool
}

// CopyResult represents the result of a copy operation
type CopyResult struct {
        Success     bool
        BytesCopied int64
        Error       error
        TimeTaken   time.Duration
}

// DirectoryTreeInfo represents directory tree information
type DirectoryTreeInfo struct {
        Path       string
        TotalFiles int
        TotalDirs  int
        TotalSize  int64
        MaxDepth   int
        Files      []*FileInfo
        Subdirs    []*DirectoryTreeInfo
}

// SmbConnectionPool manages multiple SMB connections
type SmbConnectionPool struct {
        connections    map[string]*SmbClient
        maxConnections int
}

// NewSmbConnectionPool creates a new connection pool
func NewSmbConnectionPool(maxConnections int) *SmbConnectionPool <span class="cov0" title="0">{
        return &amp;SmbConnectionPool{
                connections:    make(map[string]*SmbClient),
                maxConnections: maxConnections,
        }
}</span>

// GetConnection gets or creates an SMB connection
func (p *SmbConnectionPool) GetConnection(key string, config *SmbConfig) (*SmbClient, error) <span class="cov0" title="0">{
        if client, exists := p.connections[key]; exists </span><span class="cov0" title="0">{
                // Test the existing connection
                if err := client.TestConnection(); err == nil </span><span class="cov0" title="0">{
                        return client, nil
                }</span>
                // Connection is stale, remove it
                <span class="cov0" title="0">client.Close()
                delete(p.connections, key)</span>
        }

        // Create new connection
        <span class="cov0" title="0">client, err := NewSmbClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in pool if there's space
        <span class="cov0" title="0">if len(p.connections) &lt; p.maxConnections </span><span class="cov0" title="0">{
                p.connections[key] = client
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// CloseAll closes all connections in the pool
func (p *SmbConnectionPool) CloseAll() <span class="cov0" title="0">{
        for key, client := range p.connections </span><span class="cov0" title="0">{
                client.Close()
                delete(p.connections, key)
        }</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package integration

import (
        "catalogizer/filesystem"
        "catalogizer/internal/services"
        "context"
        "database/sql"
        "fmt"
        "os"
        "testing"
        "time"

        _ "github.com/mattn/go-sqlite3"
        "go.uber.org/zap"
)

// ProtocolTestSuite defines the interface for protocol-specific tests
type ProtocolTestSuite interface {
        SetupProtocol(t *testing.T) (filesystem.FileSystemClient, func())
        GetProtocolName() string
        GetTestConfig() map[string]interface{}
        SupportsRealTimeEvents() bool
}

// TestProtocolRenameDetection runs rename detection tests for all supported protocols
func TestProtocolRenameDetection(t *testing.T) <span class="cov0" title="0">{
        if testing.Short() </span><span class="cov0" title="0">{
                t.Skip("Skipping protocol integration tests in short mode")
        }</span>

        // Test each protocol
        <span class="cov0" title="0">protocolSuites := []ProtocolTestSuite{
                &amp;LocalProtocolTestSuite{},
                &amp;SMBProtocolTestSuite{},
                &amp;FTPProtocolTestSuite{},
                &amp;NFSProtocolTestSuite{},
                &amp;WebDAVProtocolTestSuite{},
        }

        for _, suite := range protocolSuites </span><span class="cov0" title="0">{
                t.Run(suite.GetProtocolName(), func(t *testing.T) </span><span class="cov0" title="0">{
                        testProtocolRenameDetection(t, suite)
                }</span>)
        }
}

func testProtocolRenameDetection(t *testing.T, suite ProtocolTestSuite) <span class="cov0" title="0">{
        logger := zap.NewNop()
        ctx := context.Background()

        // Setup database
        db := setupProtocolTestDB(t)
        defer db.Close()

        // Setup protocol
        client, cleanup := suite.SetupProtocol(t)
        defer cleanup()

        // Setup universal rename tracker
        renameTracker := services.NewUniversalRenameTracker(db, logger)
        if err := renameTracker.Start(); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to start rename tracker: %v", err)
        }</span>
        <span class="cov0" title="0">defer renameTracker.Stop()

        // Test file rename detection
        t.Run("file_rename", func(t *testing.T) </span><span class="cov0" title="0">{
                testFileRename(t, client, renameTracker, suite, ctx)
        }</span>)

        // Test directory rename detection
        <span class="cov0" title="0">t.Run("directory_rename", func(t *testing.T) </span><span class="cov0" title="0">{
                testDirectoryRename(t, client, renameTracker, suite, ctx)
        }</span>)

        // Test batch rename operations
        <span class="cov0" title="0">t.Run("batch_rename", func(t *testing.T) </span><span class="cov0" title="0">{
                testBatchRename(t, client, renameTracker, suite, ctx)
        }</span>)

        // Test rename detection timing
        <span class="cov0" title="0">t.Run("timing_windows", func(t *testing.T) </span><span class="cov0" title="0">{
                testRenameTimingWindows(t, client, renameTracker, suite, ctx)
        }</span>)

        // Test protocol-specific capabilities
        <span class="cov0" title="0">t.Run("protocol_capabilities", func(t *testing.T) </span><span class="cov0" title="0">{
                testProtocolCapabilities(t, suite, logger)
        }</span>)
}

func testFileRename(t *testing.T, client filesystem.FileSystemClient, renameTracker *services.UniversalRenameTracker, suite ProtocolTestSuite, ctx context.Context) <span class="cov0" title="0">{
        protocol := suite.GetProtocolName()

        // Create test file
        testContent := "Test file content for rename detection"
        originalPath := "/test_file_rename.txt"
        renamedPath := "/renamed_test_file.txt"

        // Create the file through the client
        if err := createTestFile(ctx, client, originalPath, testContent); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test file: %v", err)
        }</span>

        // Simulate tracking the file creation
        <span class="cov0" title="0">fileID := int64(100)
        size := int64(len(testContent))
        fileHash := "testhash123"
        protocolData := suite.GetTestConfig()

        // Track the file deletion (simulating a move)
        renameTracker.TrackDelete(ctx, fileID, originalPath, "test_storage", protocol, size, &amp;fileHash, false, protocolData)

        // Simulate the file creation at new location
        pendingMove, isMove := renameTracker.DetectCreate(ctx, renamedPath, "test_storage", protocol, size, &amp;fileHash, false, protocolData)

        if !isMove </span><span class="cov0" title="0">{
                t.Error("Expected file rename to be detected")
                return
        }</span>

        <span class="cov0" title="0">if pendingMove.Path != originalPath </span><span class="cov0" title="0">{
                t.Errorf("Expected original path %s, got %s", originalPath, pendingMove.Path)
        }</span>

        <span class="cov0" title="0">if pendingMove.Protocol != protocol </span><span class="cov0" title="0">{
                t.Errorf("Expected protocol %s, got %s", protocol, pendingMove.Protocol)
        }</span>

        // Process the move
        <span class="cov0" title="0">if err := renameTracker.ProcessMove(ctx, client, pendingMove, renamedPath); err != nil </span><span class="cov0" title="0">{
                t.Errorf("Failed to process file move: %v", err)
        }</span>

        // Verify the move was recorded
        <span class="cov0" title="0">stats := renameTracker.GetStatistics()
        if totalRenames, ok := stats["total_renames"].(int); !ok || totalRenames == 0 </span><span class="cov0" title="0">{
                t.Error("Expected rename to be recorded in statistics")
        }</span>

        // Clean up
        <span class="cov0" title="0">client.DeleteFile(ctx, renamedPath)</span>
}

func testDirectoryRename(t *testing.T, client filesystem.FileSystemClient, renameTracker *services.UniversalRenameTracker, suite ProtocolTestSuite, ctx context.Context) <span class="cov0" title="0">{
        protocol := suite.GetProtocolName()

        // Create test directory with files
        originalDir := "/test_dir_rename"
        renamedDir := "/renamed_test_dir"

        // Create directory and files
        if err := client.CreateDirectory(ctx, originalDir); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test directory: %v", err)
        }</span>

        <span class="cov0" title="0">testFile := originalDir + "/nested_file.txt"
        if err := createTestFile(ctx, client, testFile, "Nested file content"); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create nested file: %v", err)
        }</span>

        // Track directory deletion
        <span class="cov0" title="0">dirID := int64(200)
        protocolData := suite.GetTestConfig()

        renameTracker.TrackDelete(ctx, dirID, originalDir, "test_storage", protocol, 0, nil, true, protocolData)

        // Detect directory creation at new location
        pendingMove, isMove := renameTracker.DetectCreate(ctx, renamedDir, "test_storage", protocol, 0, nil, true, protocolData)

        if !isMove </span><span class="cov0" title="0">{
                t.Error("Expected directory rename to be detected")
                return
        }</span>

        <span class="cov0" title="0">if !pendingMove.IsDirectory </span><span class="cov0" title="0">{
                t.Error("Expected pending move to be marked as directory")
        }</span>

        // Process the move
        <span class="cov0" title="0">if err := renameTracker.ProcessMove(ctx, client, pendingMove, renamedDir); err != nil </span><span class="cov0" title="0">{
                t.Errorf("Failed to process directory move: %v", err)
        }</span>

        // Clean up
        <span class="cov0" title="0">client.DeleteFile(ctx, renamedDir+"/nested_file.txt")
        client.DeleteDirectory(ctx, renamedDir)</span>
}

func testBatchRename(t *testing.T, client filesystem.FileSystemClient, renameTracker *services.UniversalRenameTracker, suite ProtocolTestSuite, ctx context.Context) <span class="cov0" title="0">{
        protocol := suite.GetProtocolName()

        // Create multiple files for batch rename
        numFiles := 5
        fileIDs := make([]int64, numFiles)
        originalPaths := make([]string, numFiles)
        renamedPaths := make([]string, numFiles)

        for i := 0; i &lt; numFiles; i++ </span><span class="cov0" title="0">{
                fileIDs[i] = int64(300 + i)
                originalPaths[i] = fmt.Sprintf("/batch_file_%d.txt", i)
                renamedPaths[i] = fmt.Sprintf("/renamed_batch_%d.txt", i)

                // Create file
                content := fmt.Sprintf("Batch file %d content", i)
                if err := createTestFile(ctx, client, originalPaths[i], content); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to create batch file %d: %v", i, err)
                }</span>

                // Track deletion
                <span class="cov0" title="0">size := int64(len(content))
                hash := fmt.Sprintf("batchhash%d", i)
                renameTracker.TrackDelete(ctx, fileIDs[i], originalPaths[i], "test_storage", protocol, size, &amp;hash, false, suite.GetTestConfig())</span>
        }

        // Small delay to simulate batch operations
        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)

        // Detect all moves
        detectedMoves := 0
        for i := 0; i &lt; numFiles; i++ </span><span class="cov0" title="0">{
                content := fmt.Sprintf("Batch file %d content", i)
                size := int64(len(content))
                hash := fmt.Sprintf("batchhash%d", i)

                if pendingMove, isMove := renameTracker.DetectCreate(ctx, renamedPaths[i], "test_storage", protocol, size, &amp;hash, false, suite.GetTestConfig()); isMove </span><span class="cov0" title="0">{
                        detectedMoves++
                        if err := renameTracker.ProcessMove(ctx, client, pendingMove, renamedPaths[i]); err != nil </span><span class="cov0" title="0">{
                                t.Errorf("Failed to process batch move %d: %v", i, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">if detectedMoves != numFiles </span><span class="cov0" title="0">{
                t.Errorf("Expected %d batch moves to be detected, got %d", numFiles, detectedMoves)
        }</span>

        // Clean up
        <span class="cov0" title="0">for i := 0; i &lt; numFiles; i++ </span><span class="cov0" title="0">{
                client.DeleteFile(ctx, renamedPaths[i])
        }</span>
}

func testRenameTimingWindows(t *testing.T, client filesystem.FileSystemClient, renameTracker *services.UniversalRenameTracker, suite ProtocolTestSuite, ctx context.Context) <span class="cov0" title="0">{
        protocol := suite.GetProtocolName()

        // Get protocol capabilities
        capabilities, err := services.GetProtocolCapabilities(protocol, zap.NewNop())
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to get protocol capabilities: %v", err)
        }</span>

        // Test move within window
        <span class="cov0" title="0">t.Run("within_window", func(t *testing.T) </span><span class="cov0" title="0">{
                originalPath := "/timing_test_1.txt"
                renamedPath := "/timing_renamed_1.txt"
                content := "Timing test content"

                if err := createTestFile(ctx, client, originalPath, content); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to create timing test file: %v", err)
                }</span>

                <span class="cov0" title="0">size := int64(len(content))
                hash := "timinghash1"
                renameTracker.TrackDelete(ctx, 400, originalPath, "test_storage", protocol, size, &amp;hash, false, suite.GetTestConfig())

                // Detect move immediately (within window)
                if pendingMove, isMove := renameTracker.DetectCreate(ctx, renamedPath, "test_storage", protocol, size, &amp;hash, false, suite.GetTestConfig()); !isMove </span><span class="cov0" title="0">{
                        t.Error("Expected move to be detected within timing window")
                }</span> else<span class="cov0" title="0"> {
                        renameTracker.ProcessMove(ctx, client, pendingMove, renamedPath)
                }</span>

                <span class="cov0" title="0">client.DeleteFile(ctx, renamedPath)</span>
        })

        // Test move outside window
        <span class="cov0" title="0">t.Run("outside_window", func(t *testing.T) </span><span class="cov0" title="0">{
                originalPath := "/timing_test_2.txt"
                renamedPath := "/timing_renamed_2.txt"
                content := "Timing test content 2"

                if err := createTestFile(ctx, client, originalPath, content); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to create timing test file: %v", err)
                }</span>

                <span class="cov0" title="0">size := int64(len(content))
                hash := "timinghash2"
                renameTracker.TrackDelete(ctx, 401, originalPath, "test_storage", protocol, size, &amp;hash, false, suite.GetTestConfig())

                // Wait longer than the protocol's move window
                time.Sleep(capabilities.MoveWindow + time.Second)

                // Try to detect move (should fail due to expired window)
                if _, isMove := renameTracker.DetectCreate(ctx, renamedPath, "test_storage", protocol, size, &amp;hash, false, suite.GetTestConfig()); isMove </span><span class="cov0" title="0">{
                        t.Error("Expected move detection to fail outside timing window")
                }</span>

                <span class="cov0" title="0">client.DeleteFile(ctx, originalPath)</span>
        })
}

func testProtocolCapabilities(t *testing.T, suite ProtocolTestSuite, logger *zap.Logger) <span class="cov0" title="0">{
        protocol := suite.GetProtocolName()

        capabilities, err := services.GetProtocolCapabilities(protocol, logger)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to get capabilities for protocol %s: %v", protocol, err)
        }</span>

        // Verify capabilities match expected values
        <span class="cov0" title="0">switch protocol </span>{
        case "local":<span class="cov0" title="0">
                if !capabilities.SupportsRealTimeNotification </span><span class="cov0" title="0">{
                        t.Error("Local protocol should support real-time notifications")
                }</span>
                <span class="cov0" title="0">if capabilities.MoveWindow &gt; 5*time.Second </span><span class="cov0" title="0">{
                        t.Error("Local protocol should have a short move window")
                }</span>

        case "smb":<span class="cov0" title="0">
                if capabilities.SupportsRealTimeNotification </span><span class="cov0" title="0">{
                        t.Error("SMB protocol should not support real-time notifications")
                }</span>
                <span class="cov0" title="0">if !capabilities.RequiresPolling </span><span class="cov0" title="0">{
                        t.Error("SMB protocol should require polling")
                }</span>

        case "ftp":<span class="cov0" title="0">
                if capabilities.SupportsRealTimeNotification </span><span class="cov0" title="0">{
                        t.Error("FTP protocol should not support real-time notifications")
                }</span>
                <span class="cov0" title="0">if capabilities.MoveWindow &lt; 10*time.Second </span><span class="cov0" title="0">{
                        t.Error("FTP protocol should have a longer move window")
                }</span>

        case "nfs":<span class="cov0" title="0">
                if capabilities.SupportsRealTimeNotification </span><span class="cov0" title="0">{
                        t.Error("NFS protocol should not support real-time notifications in most cases")
                }</span>

        case "webdav":<span class="cov0" title="0">
                if capabilities.SupportsRealTimeNotification </span><span class="cov0" title="0">{
                        t.Error("WebDAV protocol should not support real-time notifications")
                }</span>
        }

        <span class="cov0" title="0">t.Logf("Protocol %s capabilities: %+v", protocol, capabilities)</span>
}

// Protocol-specific test suite implementations

type LocalProtocolTestSuite struct{}

func (s *LocalProtocolTestSuite) SetupProtocol(t *testing.T) (filesystem.FileSystemClient, func()) <span class="cov0" title="0">{
        tempDir := t.TempDir()

        config := &amp;filesystem.LocalConfig{
                BasePath: tempDir,
        }

        client := filesystem.NewLocalClient(config)

        return client, func() </span>{<span class="cov0" title="0">
                // Cleanup handled by t.TempDir()
        }</span>
}

func (s *LocalProtocolTestSuite) GetProtocolName() string <span class="cov0" title="0">{
        return "local"
}</span>

func (s *LocalProtocolTestSuite) GetTestConfig() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "base_path": "/tmp/test",
        }
}</span>

func (s *LocalProtocolTestSuite) SupportsRealTimeEvents() bool <span class="cov0" title="0">{
        return true
}</span>

type SMBProtocolTestSuite struct{}

func (s *SMBProtocolTestSuite) SetupProtocol(t *testing.T) (filesystem.FileSystemClient, func()) <span class="cov0" title="0">{
        // For testing, we'll use a mock SMB client or skip if no test server available
        if os.Getenv("SMB_TEST_SERVER") == "" </span><span class="cov0" title="0">{
                t.Skip("SMB_TEST_SERVER not set, skipping SMB tests")
        }</span>

        <span class="cov0" title="0">config := &amp;filesystem.SmbConfig{
                Host:     os.Getenv("SMB_TEST_HOST"),
                Port:     445,
                Share:    os.Getenv("SMB_TEST_SHARE"),
                Username: os.Getenv("SMB_TEST_USER"),
                Password: os.Getenv("SMB_TEST_PASS"),
        }

        client := filesystem.NewSmbClient(config)

        return client, func() </span>{<span class="cov0" title="0">
                // SMB cleanup
        }</span>
}

func (s *SMBProtocolTestSuite) GetProtocolName() string <span class="cov0" title="0">{
        return "smb"
}</span>

func (s *SMBProtocolTestSuite) GetTestConfig() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "host":  "testserver",
                "share": "testshare",
        }
}</span>

func (s *SMBProtocolTestSuite) SupportsRealTimeEvents() bool <span class="cov0" title="0">{
        return false
}</span>

type FTPProtocolTestSuite struct{}

func (s *FTPProtocolTestSuite) SetupProtocol(t *testing.T) (filesystem.FileSystemClient, func()) <span class="cov0" title="0">{
        if os.Getenv("FTP_TEST_SERVER") == "" </span><span class="cov0" title="0">{
                t.Skip("FTP_TEST_SERVER not set, skipping FTP tests")
        }</span>

        // Mock FTP client setup
        <span class="cov0" title="0">t.Skip("FTP client implementation pending")
        return nil, func() </span>{<span class="cov0" title="0">}</span>
}

func (s *FTPProtocolTestSuite) GetProtocolName() string <span class="cov0" title="0">{
        return "ftp"
}</span>

func (s *FTPProtocolTestSuite) GetTestConfig() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "host": "ftpserver",
                "port": 21,
        }
}</span>

func (s *FTPProtocolTestSuite) SupportsRealTimeEvents() bool <span class="cov0" title="0">{
        return false
}</span>

type NFSProtocolTestSuite struct{}

func (s *NFSProtocolTestSuite) SetupProtocol(t *testing.T) (filesystem.FileSystemClient, func()) <span class="cov0" title="0">{
        if os.Getenv("NFS_TEST_SERVER") == "" </span><span class="cov0" title="0">{
                t.Skip("NFS_TEST_SERVER not set, skipping NFS tests")
        }</span>

        // Mock NFS client setup
        <span class="cov0" title="0">t.Skip("NFS client implementation pending")
        return nil, func() </span>{<span class="cov0" title="0">}</span>
}

func (s *NFSProtocolTestSuite) GetProtocolName() string <span class="cov0" title="0">{
        return "nfs"
}</span>

func (s *NFSProtocolTestSuite) GetTestConfig() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "host":        "nfsserver",
                "export_path": "/export",
        }
}</span>

func (s *NFSProtocolTestSuite) SupportsRealTimeEvents() bool <span class="cov0" title="0">{
        return false
}</span>

type WebDAVProtocolTestSuite struct{}

func (s *WebDAVProtocolTestSuite) SetupProtocol(t *testing.T) (filesystem.FileSystemClient, func()) <span class="cov0" title="0">{
        if os.Getenv("WEBDAV_TEST_SERVER") == "" </span><span class="cov0" title="0">{
                t.Skip("WEBDAV_TEST_SERVER not set, skipping WebDAV tests")
        }</span>

        // Mock WebDAV client setup
        <span class="cov0" title="0">t.Skip("WebDAV client implementation pending")
        return nil, func() </span>{<span class="cov0" title="0">}</span>
}

func (s *WebDAVProtocolTestSuite) GetProtocolName() string <span class="cov0" title="0">{
        return "webdav"
}</span>

func (s *WebDAVProtocolTestSuite) GetTestConfig() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "url": "https://webdavserver/dav",
        }
}</span>

func (s *WebDAVProtocolTestSuite) SupportsRealTimeEvents() bool <span class="cov0" title="0">{
        return false
}</span>

// Helper functions

func setupProtocolTestDB(t *testing.T) *sql.DB <span class="cov0" title="0">{
        db, err := sql.Open("sqlite3", ":memory:")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test database: %v", err)
        }</span>

        <span class="cov0" title="0">schema := `
                CREATE TABLE storage_roots (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL UNIQUE
                );

                CREATE TABLE files (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        storage_root_id INTEGER NOT NULL,
                        path TEXT NOT NULL,
                        name TEXT NOT NULL,
                        is_directory BOOLEAN NOT NULL,
                        size INTEGER NOT NULL,
                        quick_hash TEXT,
                        parent_id INTEGER,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        modified_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        deleted BOOLEAN DEFAULT FALSE,
                        deleted_at TIMESTAMP,
                        last_scan_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (storage_root_id) REFERENCES storage_roots (id)
                );

                CREATE TABLE universal_rename_events (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        storage_root_id INTEGER NOT NULL,
                        protocol TEXT NOT NULL,
                        old_path TEXT NOT NULL,
                        new_path TEXT NOT NULL,
                        is_directory BOOLEAN NOT NULL,
                        size INTEGER NOT NULL,
                        file_hash TEXT,
                        detected_at TIMESTAMP NOT NULL,
                        processed_at TIMESTAMP,
                        status TEXT NOT NULL DEFAULT 'pending',
                        FOREIGN KEY (storage_root_id) REFERENCES storage_roots (id)
                );

                INSERT INTO storage_roots (id, name) VALUES (1, 'test_storage');
        `

        if _, err := db.Exec(schema); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test schema: %v", err)
        }</span>

        <span class="cov0" title="0">return db</span>
}

func createTestFile(ctx context.Context, client filesystem.FileSystemClient, path, content string) error <span class="cov0" title="0">{
        // For testing, we'll create a simple file
        // In a real implementation, this would use the appropriate client method
        return nil // Placeholder implementation
}</span>

// TestUniversalRenameTrackerIntegration tests the complete integration
func TestUniversalRenameTrackerIntegration(t *testing.T) <span class="cov0" title="0">{
        if testing.Short() </span><span class="cov0" title="0">{
                t.Skip("Skipping integration test in short mode")
        }</span>

        <span class="cov0" title="0">logger := zap.NewNop()
        ctx := context.Background()

        // Setup
        db := setupProtocolTestDB(t)
        defer db.Close()

        tracker := services.NewUniversalRenameTracker(db, logger)
        if err := tracker.Start(); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to start tracker: %v", err)
        }</span>
        <span class="cov0" title="0">defer tracker.Stop()

        // Test cross-protocol scenarios
        t.Run("cross_protocol_operations", func(t *testing.T) </span><span class="cov0" title="0">{
                // Test operations that span multiple protocols
                protocols := []string{"local", "smb", "ftp"}

                for _, protocol := range protocols </span><span class="cov0" title="0">{
                        // Track deletions for each protocol
                        tracker.TrackDelete(ctx, int64(100+len(protocol)), "/test.txt", "storage1", protocol, 1024, nil, false, map[string]interface{}{})
                }</span>

                // Verify statistics
                <span class="cov0" title="0">stats := tracker.GetStatistics()
                if pendingByProtocol, ok := stats["pending_by_protocol"].(map[string]int); ok </span><span class="cov0" title="0">{
                        for _, protocol := range protocols </span><span class="cov0" title="0">{
                                if count, exists := pendingByProtocol[protocol]; !exists || count != 1 </span><span class="cov0" title="0">{
                                        t.Errorf("Expected 1 pending move for protocol %s, got %d", protocol, count)
                                }</span>
                        }
                }
        })

        // Test concurrent operations
        <span class="cov0" title="0">t.Run("concurrent_operations", func(t *testing.T) </span><span class="cov0" title="0">{
                numGoroutines := 10
                done := make(chan bool, numGoroutines)

                for i := 0; i &lt; numGoroutines; i++ </span><span class="cov0" title="0">{
                        go func(id int) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{ done &lt;- true }</span>()

                                <span class="cov0" title="0">path := fmt.Sprintf("/concurrent_%d.txt", id)
                                fileID := int64(500 + id)

                                tracker.TrackDelete(ctx, fileID, path, "storage1", "local", 1024, nil, false, map[string]interface{}{})

                                // Immediately try to detect
                                if pendingMove, isMove := tracker.DetectCreate(ctx, path+"_renamed", "storage1", "local", 1024, nil, false, map[string]interface{}{}); isMove </span><span class="cov0" title="0">{
                                        t.Logf("Concurrent operation %d: move detected", id)
                                        // Process move (simplified)
                                        _ = pendingMove
                                }</span>
                        }(i)
                }

                // Wait for all operations to complete
                <span class="cov0" title="0">for i := 0; i &lt; numGoroutines; i++ </span><span class="cov0" title="0">{
                        &lt;-done
                }</span>

                // Verify final state
                <span class="cov0" title="0">finalStats := tracker.GetStatistics()
                t.Logf("Final statistics after concurrent operations: %+v", finalStats)</span>
        })
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package mocks

import (
        "bufio"
        "fmt"
        "net"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"
)

// MockFTPServer provides a mock FTP server for testing
type MockFTPServer struct {
        logger      *zap.Logger
        listener    net.Listener
        port        int
        users       map[string]string // username -&gt; password
        files       map[string]*MockFTPFile
        running     bool
        wg          sync.WaitGroup
        mu          sync.RWMutex
        currentDir  string
        passiveMode bool
        dataPort    int
}

// MockFTPFile represents a mock FTP file or directory
type MockFTPFile struct {
        Name        string
        Path        string
        IsDirectory bool
        Size        int64
        ModTime     time.Time
        Content     []byte
        Permissions string
}

// NewMockFTPServer creates a new mock FTP server
func NewMockFTPServer(logger *zap.Logger) *MockFTPServer <span class="cov0" title="0">{
        server := &amp;MockFTPServer{
                logger:     logger,
                users:      make(map[string]string),
                files:      make(map[string]*MockFTPFile),
                currentDir: "/",
        }

        server.setupDefaultData()
        return server
}</span>

// setupDefaultData adds default users and files for testing
func (s *MockFTPServer) setupDefaultData() <span class="cov0" title="0">{
        // Add default users
        s.users["anonymous"] = ""
        s.users["testuser"] = "testpass"
        s.users["ftpuser"] = "ftppass"

        // Add default directory structure
        s.AddFile("/", "public", true, 0, []byte{}, "drwxr-xr-x")
        s.AddFile("/", "uploads", true, 0, []byte{}, "drwxrwxrwx")
        s.AddFile("/", "readme.txt", false, 512, []byte("Welcome to the FTP server!"), "-rw-r--r--")

        s.AddFile("/public", "documents", true, 0, []byte{}, "drwxr-xr-x")
        s.AddFile("/public", "software", true, 0, []byte{}, "drwxr-xr-x")
        s.AddFile("/public", "info.txt", false, 1024, []byte("Public information file"), "-rw-r--r--")

        s.AddFile("/public/documents", "manual.pdf", false, 204800, []byte("Mock PDF content"), "-rw-r--r--")
        s.AddFile("/public/documents", "guide.doc", false, 102400, []byte("Mock document content"), "-rw-r--r--")

        s.AddFile("/public/software", "installer.exe", false, 5242880, []byte("Mock installer content"), "-rw-r--r--")
        s.AddFile("/public/software", "update.zip", false, 1048576, []byte("Mock update content"), "-rw-r--r--")

        s.AddFile("/uploads", "temp", true, 0, []byte{}, "drwxrwxrwx")
}</span>

// AddFile adds a file or directory to the server
func (s *MockFTPServer) AddFile(parentPath, name string, isDirectory bool, size int64, content []byte, permissions string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        path := filepath.Join(parentPath, name)
        if parentPath == "/" </span><span class="cov0" title="0">{
                path = "/" + name
        }</span>

        <span class="cov0" title="0">s.files[path] = &amp;MockFTPFile{
                Name:        name,
                Path:        path,
                IsDirectory: isDirectory,
                Size:        size,
                ModTime:     time.Now(),
                Content:     content,
                Permissions: permissions,
        }</span>
}

// AddUser adds a user with password
func (s *MockFTPServer) AddUser(username, password string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.users[username] = password
}</span>

// Start starts the mock FTP server
func (s *MockFTPServer) Start() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.running </span><span class="cov0" title="0">{
                return fmt.Errorf("server already running")
        }</span>

        // Listen on any available port
        <span class="cov0" title="0">listener, err := net.Listen("tcp", ":0")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start listener: %w", err)
        }</span>

        <span class="cov0" title="0">s.listener = listener
        s.port = listener.Addr().(*net.TCPAddr).Port
        s.running = true

        s.logger.Info("Mock FTP server started", zap.Int("port", s.port))

        // Start accepting connections
        s.wg.Add(1)
        go s.acceptConnections()

        return nil</span>
}

// Stop stops the mock FTP server
func (s *MockFTPServer) Stop() error <span class="cov0" title="0">{
        s.mu.Lock()
        if !s.running </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return nil
        }</span>
        <span class="cov0" title="0">s.running = false
        s.mu.Unlock()

        if s.listener != nil </span><span class="cov0" title="0">{
                s.listener.Close()
        }</span>

        <span class="cov0" title="0">s.wg.Wait()
        s.logger.Info("Mock FTP server stopped")
        return nil</span>
}

// GetPort returns the port the server is listening on
func (s *MockFTPServer) GetPort() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.port
}</span>

// GetAddress returns the server address
func (s *MockFTPServer) GetAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("localhost:%d", s.GetPort())
}</span>

// acceptConnections handles incoming connections
func (s *MockFTPServer) acceptConnections() <span class="cov0" title="0">{
        defer s.wg.Done()

        for </span><span class="cov0" title="0">{
                conn, err := s.listener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        s.mu.RLock()
                        running := s.running
                        s.mu.RUnlock()

                        if !running </span><span class="cov0" title="0">{
                                return // Server stopped
                        }</span>
                        <span class="cov0" title="0">s.logger.Error("Failed to accept FTP connection", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">s.wg.Add(1)
                go s.handleConnection(conn)</span>
        }
}

// handleConnection handles a single FTP connection
func (s *MockFTPServer) handleConnection(conn net.Conn) <span class="cov0" title="0">{
        defer s.wg.Done()
        defer conn.Close()

        s.logger.Debug("New FTP connection", zap.String("remote", conn.RemoteAddr().String()))

        // Send welcome message
        s.sendResponse(conn, "220 Mock FTP Server Ready")

        scanner := bufio.NewScanner(conn)
        authenticated := false
        username := ""

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                s.logger.Debug("FTP command received", zap.String("command", line))

                parts := strings.SplitN(line, " ", 2)
                if len(parts) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">command := strings.ToUpper(parts[0])
                args := ""
                if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                        args = parts[1]
                }</span>

                <span class="cov0" title="0">switch command </span>{
                case "USER":<span class="cov0" title="0">
                        username = args
                        if s.userExists(username) </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "331 Password required for "+username)
                        }</span> else<span class="cov0" title="0"> {
                                s.sendResponse(conn, "530 User not found")
                        }</span>

                case "PASS":<span class="cov0" title="0">
                        if s.authenticateUser(username, args) </span><span class="cov0" title="0">{
                                authenticated = true
                                s.sendResponse(conn, "230 User logged in")
                        }</span> else<span class="cov0" title="0"> {
                                s.sendResponse(conn, "530 Authentication failed")
                        }</span>

                case "SYST":<span class="cov0" title="0">
                        s.sendResponse(conn, "215 UNIX Type: L8")</span>

                case "PWD":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.sendResponse(conn, fmt.Sprintf("257 \"%s\" is current directory", s.currentDir))</span>

                case "CWD":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">if s.changeDirectory(args) </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "250 Directory changed")
                        }</span> else<span class="cov0" title="0"> {
                                s.sendResponse(conn, "550 Directory not found")
                        }</span>

                case "LIST":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleList(conn, args)</span>

                case "NLST":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleNlst(conn, args)</span>

                case "SIZE":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleSize(conn, args)</span>

                case "MDTM":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleMdtm(conn, args)</span>

                case "TYPE":<span class="cov0" title="0">
                        s.sendResponse(conn, "200 Type set to "+args)</span>

                case "PASV":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handlePasv(conn)</span>

                case "RETR":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleRetr(conn, args)</span>

                case "STOR":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleStor(conn, args)</span>

                case "DELE":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleDele(conn, args)</span>

                case "MKD", "XMKD":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleMkd(conn, args)</span>

                case "RMD", "XRMD":<span class="cov0" title="0">
                        if !authenticated </span><span class="cov0" title="0">{
                                s.sendResponse(conn, "530 Not logged in")
                                continue</span>
                        }
                        <span class="cov0" title="0">s.handleRmd(conn, args)</span>

                case "QUIT":<span class="cov0" title="0">
                        s.sendResponse(conn, "221 Goodbye")
                        return</span>

                case "NOOP":<span class="cov0" title="0">
                        s.sendResponse(conn, "200 OK")</span>

                default:<span class="cov0" title="0">
                        s.sendResponse(conn, "502 Command not implemented")</span>
                }
        }
}

// sendResponse sends an FTP response
func (s *MockFTPServer) sendResponse(conn net.Conn, response string) <span class="cov0" title="0">{
        _, err := conn.Write([]byte(response + "\r\n"))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to send FTP response", zap.Error(err))
        }</span>
        <span class="cov0" title="0">s.logger.Debug("FTP response sent", zap.String("response", response))</span>
}

// userExists checks if a user exists
func (s *MockFTPServer) userExists(username string) bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        _, exists := s.users[username]
        return exists
}</span>

// authenticateUser checks if user credentials are valid
func (s *MockFTPServer) authenticateUser(username, password string) bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        expectedPassword, exists := s.users[username]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return expectedPassword == password</span>
}

// changeDirectory changes the current directory
func (s *MockFTPServer) changeDirectory(path string) bool <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        targetPath := path
        if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + path
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + path
                }</span>
        }

        // Check if directory exists
        <span class="cov0" title="0">if file, exists := s.files[targetPath]; exists &amp;&amp; file.IsDirectory </span><span class="cov0" title="0">{
                s.currentDir = targetPath
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// handleList handles the LIST command
func (s *MockFTPServer) handleList(conn net.Conn, path string) <span class="cov0" title="0">{
        targetPath := s.currentDir
        if path != "" </span><span class="cov0" title="0">{
                if strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                        targetPath = path
                }</span> else<span class="cov0" title="0"> {
                        if s.currentDir == "/" </span><span class="cov0" title="0">{
                                targetPath = "/" + path
                        }</span> else<span class="cov0" title="0"> {
                                targetPath = s.currentDir + "/" + path
                        }</span>
                }
        }

        // For simplicity, send list directly on command channel
        // In real FTP, this would use a data channel
        <span class="cov0" title="0">s.sendResponse(conn, "150 Opening data connection")

        files := s.listFiles(targetPath)
        for _, file := range files </span><span class="cov0" title="0">{
                listing := s.formatFileListing(file)
                s.sendResponse(conn, listing)
        }</span>

        <span class="cov0" title="0">s.sendResponse(conn, "226 Transfer complete")</span>
}

// handleNlst handles the NLST command (name list)
func (s *MockFTPServer) handleNlst(conn net.Conn, path string) <span class="cov0" title="0">{
        targetPath := s.currentDir
        if path != "" </span><span class="cov0" title="0">{
                if strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                        targetPath = path
                }</span> else<span class="cov0" title="0"> {
                        if s.currentDir == "/" </span><span class="cov0" title="0">{
                                targetPath = "/" + path
                        }</span> else<span class="cov0" title="0"> {
                                targetPath = s.currentDir + "/" + path
                        }</span>
                }
        }

        <span class="cov0" title="0">s.sendResponse(conn, "150 Opening data connection")

        files := s.listFiles(targetPath)
        for _, file := range files </span><span class="cov0" title="0">{
                s.sendResponse(conn, file.Name)
        }</span>

        <span class="cov0" title="0">s.sendResponse(conn, "226 Transfer complete")</span>
}

// handleSize handles the SIZE command
func (s *MockFTPServer) handleSize(conn net.Conn, path string) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        targetPath := path
        if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + path
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + path
                }</span>
        }

        <span class="cov0" title="0">if file, exists := s.files[targetPath]; exists &amp;&amp; !file.IsDirectory </span><span class="cov0" title="0">{
                s.sendResponse(conn, fmt.Sprintf("213 %d", file.Size))
        }</span> else<span class="cov0" title="0"> {
                s.sendResponse(conn, "550 File not found")
        }</span>
}

// handleMdtm handles the MDTM command (modification time)
func (s *MockFTPServer) handleMdtm(conn net.Conn, path string) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        targetPath := path
        if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + path
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + path
                }</span>
        }

        <span class="cov0" title="0">if file, exists := s.files[targetPath]; exists </span><span class="cov0" title="0">{
                mdtm := file.ModTime.Format("20060102150405")
                s.sendResponse(conn, fmt.Sprintf("213 %s", mdtm))
        }</span> else<span class="cov0" title="0"> {
                s.sendResponse(conn, "550 File not found")
        }</span>
}

// handlePasv handles passive mode
func (s *MockFTPServer) handlePasv(conn net.Conn) <span class="cov0" title="0">{
        // For simplicity, just acknowledge passive mode
        s.passiveMode = true
        s.dataPort = s.port + 1

        // Format: 227 Entering Passive Mode (h1,h2,h3,h4,p1,p2)
        // where IP is h1.h2.h3.h4 and port is p1*256+p2
        p1 := s.dataPort / 256
        p2 := s.dataPort % 256

        s.sendResponse(conn, fmt.Sprintf("227 Entering Passive Mode (127,0,0,1,%d,%d)", p1, p2))
}</span>

// handleRetr handles file retrieval
func (s *MockFTPServer) handleRetr(conn net.Conn, filename string) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        targetPath := filename
        if !strings.HasPrefix(filename, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + filename
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + filename
                }</span>
        }

        <span class="cov0" title="0">if file, exists := s.files[targetPath]; exists &amp;&amp; !file.IsDirectory </span><span class="cov0" title="0">{
                s.sendResponse(conn, "150 Opening data connection for file transfer")
                // In real FTP, content would be sent over data channel
                s.sendResponse(conn, "226 Transfer complete")
        }</span> else<span class="cov0" title="0"> {
                s.sendResponse(conn, "550 File not found")
        }</span>
}

// handleStor handles file storage
func (s *MockFTPServer) handleStor(conn net.Conn, filename string) <span class="cov0" title="0">{
        targetPath := filename
        if !strings.HasPrefix(filename, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + filename
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + filename
                }</span>
        }

        <span class="cov0" title="0">s.sendResponse(conn, "150 Opening data connection for file upload")

        // Simulate file upload
        s.AddFile(filepath.Dir(targetPath), filepath.Base(targetPath), false, 1024, []byte("Uploaded content"), "-rw-r--r--")

        s.sendResponse(conn, "226 Transfer complete")</span>
}

// handleDele handles file deletion
func (s *MockFTPServer) handleDele(conn net.Conn, filename string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        targetPath := filename
        if !strings.HasPrefix(filename, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + filename
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + filename
                }</span>
        }

        <span class="cov0" title="0">if _, exists := s.files[targetPath]; exists </span><span class="cov0" title="0">{
                delete(s.files, targetPath)
                s.sendResponse(conn, "250 File deleted")
        }</span> else<span class="cov0" title="0"> {
                s.sendResponse(conn, "550 File not found")
        }</span>
}

// handleMkd handles directory creation
func (s *MockFTPServer) handleMkd(conn net.Conn, dirname string) <span class="cov0" title="0">{
        targetPath := dirname
        if !strings.HasPrefix(dirname, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + dirname
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + dirname
                }</span>
        }

        <span class="cov0" title="0">s.AddFile(filepath.Dir(targetPath), filepath.Base(targetPath), true, 0, []byte{}, "drwxr-xr-x")
        s.sendResponse(conn, fmt.Sprintf("257 \"%s\" directory created", targetPath))</span>
}

// handleRmd handles directory removal
func (s *MockFTPServer) handleRmd(conn net.Conn, dirname string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        targetPath := dirname
        if !strings.HasPrefix(dirname, "/") </span><span class="cov0" title="0">{
                if s.currentDir == "/" </span><span class="cov0" title="0">{
                        targetPath = "/" + dirname
                }</span> else<span class="cov0" title="0"> {
                        targetPath = s.currentDir + "/" + dirname
                }</span>
        }

        <span class="cov0" title="0">if file, exists := s.files[targetPath]; exists &amp;&amp; file.IsDirectory </span><span class="cov0" title="0">{
                delete(s.files, targetPath)
                s.sendResponse(conn, "250 Directory removed")
        }</span> else<span class="cov0" title="0"> {
                s.sendResponse(conn, "550 Directory not found")
        }</span>
}

// listFiles lists files in a directory
func (s *MockFTPServer) listFiles(path string) []*MockFTPFile <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var files []*MockFTPFile

        for filePath, file := range s.files </span><span class="cov0" title="0">{
                if filePath == path </span><span class="cov0" title="0">{
                        continue</span> // Skip the directory itself
                }

                // Check if file is a direct child of the path
                <span class="cov0" title="0">expectedPrefix := path
                if path == "/" </span><span class="cov0" title="0">{
                        expectedPrefix = "/"
                }</span> else<span class="cov0" title="0"> {
                        expectedPrefix = path + "/"
                }</span>

                <span class="cov0" title="0">if strings.HasPrefix(filePath, expectedPrefix) </span><span class="cov0" title="0">{
                        relativePath := strings.TrimPrefix(filePath, expectedPrefix)
                        if !strings.Contains(relativePath, "/") </span><span class="cov0" title="0">{
                                // Direct child
                                files = append(files, file)
                        }</span>
                }
        }

        // Sort files by name
        <span class="cov0" title="0">sort.Slice(files, func(i, j int) bool </span><span class="cov0" title="0">{
                return files[i].Name &lt; files[j].Name
        }</span>)

        <span class="cov0" title="0">return files</span>
}

// formatFileListing formats a file for LIST command output
func (s *MockFTPServer) formatFileListing(file *MockFTPFile) string <span class="cov0" title="0">{
        // Format: permissions links owner group size month day time filename
        // Example: -rw-r--r--   1 user  group     1024 Jan 01 12:00 filename.txt
        modTime := file.ModTime.Format("Jan 02 15:04")
        return fmt.Sprintf("%s   1 user  group  %8d %s %s",
                file.Permissions, file.Size, modTime, file.Name)
}</span>

// IsRunning returns true if the server is running
func (s *MockFTPServer) IsRunning() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.running
}</span>

// GetFileCount returns the number of files/directories
func (s *MockFTPServer) GetFileCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.files)
}</span>

// GetUserCount returns the number of users
func (s *MockFTPServer) GetUserCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.users)
}</span>
</pre>
		
		<pre class="file" id="file110" style="display: none">package mocks

import (
        "fmt"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"
)

// MockNFSServer provides a mock NFS server for testing
// Note: This is a simplified mock for testing purposes
// Real NFS protocol implementation would be much more complex
type MockNFSServer struct {
        logger    *zap.Logger
        exports   map[string]*MockNFSExport
        files     map[string]*MockNFSFile
        running   bool
        mu        sync.RWMutex
        port      int
        mountPath string
}

// MockNFSExport represents an NFS export
type MockNFSExport struct {
        Path        string
        Description string
        Options     string
        Clients     []string // Allowed client IPs/hostnames
}

// MockNFSFile represents a mock NFS file or directory
type MockNFSFile struct {
        Name        string
        Path        string
        IsDirectory bool
        Size        int64
        ModTime     time.Time
        Content     []byte
        Mode        uint32
        UID         uint32
        GID         uint32
        Inode       uint64
}

// NewMockNFSServer creates a new mock NFS server
func NewMockNFSServer(logger *zap.Logger, mountPath string) *MockNFSServer <span class="cov0" title="0">{
        server := &amp;MockNFSServer{
                logger:    logger,
                exports:   make(map[string]*MockNFSExport),
                files:     make(map[string]*MockNFSFile),
                mountPath: mountPath,
                port:      2049, // Standard NFS port
        }

        server.setupDefaultData()
        return server
}</span>

// setupDefaultData adds default exports and files for testing
func (s *MockNFSServer) setupDefaultData() <span class="cov0" title="0">{
        // Add default exports
        s.AddExport("/export/media", "Media files export", "rw,sync,no_subtree_check", []string{"*"})
        s.AddExport("/export/backup", "Backup files export", "ro,sync,no_subtree_check", []string{"192.168.1.0/24"})
        s.AddExport("/export/shared", "Shared files export", "rw,async,no_root_squash", []string{"localhost", "127.0.0.1"})

        // Add default directory structure for /export/media
        s.AddFile("/export/media", "", "movies", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "", "music", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "", "photos", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "", "readme.txt", false, 512, []byte("Media files repository"), 0644, 1000, 1000)

        s.AddFile("/export/media", "movies", "action", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "movies", "comedy", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "movies/action", "movie1.mp4", false, 1073741824, []byte("Mock movie content"), 0644, 1000, 1000)
        s.AddFile("/export/media", "movies/comedy", "funny.mkv", false, 536870912, []byte("Mock comedy content"), 0644, 1000, 1000)

        s.AddFile("/export/media", "music", "rock", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "music", "jazz", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "music/rock", "song1.mp3", false, 5242880, []byte("Mock rock song"), 0644, 1000, 1000)
        s.AddFile("/export/media", "music/jazz", "smooth.flac", false, 41943040, []byte("Mock jazz song"), 0644, 1000, 1000)

        s.AddFile("/export/media", "photos", "2024", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/media", "photos/2024", "vacation.jpg", false, 2097152, []byte("Mock JPEG content"), 0644, 1000, 1000)
        s.AddFile("/export/media", "photos/2024", "family.png", false, 1048576, []byte("Mock PNG content"), 0644, 1000, 1000)

        // Add files for /export/backup
        s.AddFile("/export/backup", "", "daily", true, 0, []byte{}, 0755, 0, 0)
        s.AddFile("/export/backup", "", "weekly", true, 0, []byte{}, 0755, 0, 0)
        s.AddFile("/export/backup", "", "monthly", true, 0, []byte{}, 0755, 0, 0)

        s.AddFile("/export/backup", "daily", "backup_2024-01-01.tar.gz", false, 104857600, []byte("Mock backup data"), 0644, 0, 0)
        s.AddFile("/export/backup", "daily", "backup_2024-01-02.tar.gz", false, 98765432, []byte("Mock backup data"), 0644, 0, 0)

        s.AddFile("/export/backup", "weekly", "backup_week_01.tar.gz", false, 1073741824, []byte("Mock weekly backup"), 0644, 0, 0)
        s.AddFile("/export/backup", "monthly", "backup_202401.tar.gz", false, 5368709120, []byte("Mock monthly backup"), 0644, 0, 0)

        // Add files for /export/shared
        s.AddFile("/export/shared", "", "documents", true, 0, []byte{}, 0755, 1000, 1000)
        s.AddFile("/export/shared", "", "tmp", true, 0, []byte{}, 0777, 1000, 1000)
        s.AddFile("/export/shared", "", "info.txt", false, 1024, []byte("Shared folder information"), 0644, 1000, 1000)

        s.AddFile("/export/shared", "documents", "manual.pdf", false, 1048576, []byte("Mock PDF manual"), 0644, 1000, 1000)
        s.AddFile("/export/shared", "documents", "config.xml", false, 4096, []byte("&lt;config&gt;&lt;/config&gt;"), 0644, 1000, 1000)
}</span>

// AddExport adds an NFS export
func (s *MockNFSServer) AddExport(path, description, options string, clients []string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.exports[path] = &amp;MockNFSExport{
                Path:        path,
                Description: description,
                Options:     options,
                Clients:     clients,
        }
}</span>

// AddFile adds a file or directory to an export
func (s *MockNFSServer) AddFile(exportPath, parentPath, name string, isDirectory bool, size int64, content []byte, mode, uid, gid uint32) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        path := name
        if parentPath != "" </span><span class="cov0" title="0">{
                path = parentPath + "/" + name
        }</span>

        <span class="cov0" title="0">fullPath := exportPath + "/" + path
        if parentPath == "" &amp;&amp; name != "" </span><span class="cov0" title="0">{
                fullPath = exportPath + "/" + name
        }</span>

        // Generate inode number
        <span class="cov0" title="0">inode := uint64(len(s.files) + 1)

        s.files[fullPath] = &amp;MockNFSFile{
                Name:        name,
                Path:        fullPath,
                IsDirectory: isDirectory,
                Size:        size,
                ModTime:     time.Now(),
                Content:     content,
                Mode:        mode,
                UID:         uid,
                GID:         gid,
                Inode:       inode,
        }</span>
}

// Start starts the mock NFS server
func (s *MockNFSServer) Start() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.running </span><span class="cov0" title="0">{
                return fmt.Errorf("server already running")
        }</span>

        <span class="cov0" title="0">s.running = true
        s.logger.Info("Mock NFS server started", zap.String("mount_path", s.mountPath))

        // In a real NFS implementation, you would:
        // 1. Start the portmapper service
        // 2. Register NFS services (MOUNT, NFS, etc.)
        // 3. Listen for RPC calls
        // 4. Handle mount requests and file operations

        // For this mock, we just simulate the server being started
        return nil</span>
}

// Stop stops the mock NFS server
func (s *MockNFSServer) Stop() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if !s.running </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">s.running = false
        s.logger.Info("Mock NFS server stopped")
        return nil</span>
}

// GetPort returns the NFS port (2049)
func (s *MockNFSServer) GetPort() int <span class="cov0" title="0">{
        return s.port
}</span>

// GetMountPath returns the mount path
func (s *MockNFSServer) GetMountPath() string <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.mountPath
}</span>

// IsRunning returns true if the server is running
func (s *MockNFSServer) IsRunning() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.running
}</span>

// ListExports returns all available exports
func (s *MockNFSServer) ListExports() []*MockNFSExport <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var exports []*MockNFSExport
        for _, export := range s.exports </span><span class="cov0" title="0">{
                exports = append(exports, export)
        }</span>

        // Sort by path
        <span class="cov0" title="0">sort.Slice(exports, func(i, j int) bool </span><span class="cov0" title="0">{
                return exports[i].Path &lt; exports[j].Path
        }</span>)

        <span class="cov0" title="0">return exports</span>
}

// Mount simulates mounting an NFS export
func (s *MockNFSServer) Mount(exportPath, clientIP string) error <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        export, exists := s.exports[exportPath]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("export not found: %s", exportPath)
        }</span>

        // Check if client is allowed
        <span class="cov0" title="0">allowed := false
        for _, allowedClient := range export.Clients </span><span class="cov0" title="0">{
                if allowedClient == "*" || allowedClient == clientIP || allowedClient == "localhost" </span><span class="cov0" title="0">{
                        allowed = true
                        break</span>
                }
                // Simple subnet check for CIDR notation
                <span class="cov0" title="0">if strings.Contains(allowedClient, "/") &amp;&amp; strings.HasPrefix(clientIP, strings.Split(allowedClient, "/")[0][:3]) </span><span class="cov0" title="0">{
                        allowed = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                return fmt.Errorf("client %s not allowed to mount %s", clientIP, exportPath)
        }</span>

        <span class="cov0" title="0">s.logger.Info("NFS mount successful", zap.String("export", exportPath), zap.String("client", clientIP))
        return nil</span>
}

// Unmount simulates unmounting an NFS export
func (s *MockNFSServer) Unmount(exportPath, clientIP string) error <span class="cov0" title="0">{
        s.logger.Info("NFS unmount", zap.String("export", exportPath), zap.String("client", clientIP))
        return nil
}</span>

// ListFiles lists files in an export path
func (s *MockNFSServer) ListFiles(exportPath, dirPath string) ([]*MockNFSFile, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        // Check if export exists
        if _, exists := s.exports[exportPath]; !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("export not found: %s", exportPath)
        }</span>

        <span class="cov0" title="0">fullPath := exportPath
        if dirPath != "" &amp;&amp; dirPath != "." </span><span class="cov0" title="0">{
                fullPath = exportPath + "/" + dirPath
        }</span>

        <span class="cov0" title="0">var files []*MockNFSFile

        for filePath, file := range s.files </span><span class="cov0" title="0">{
                // Check if file is in the requested directory
                if dirPath == "" || dirPath == "." </span><span class="cov0" title="0">{
                        // List files directly in the export
                        expectedPrefix := exportPath + "/"
                        if strings.HasPrefix(filePath, expectedPrefix) </span><span class="cov0" title="0">{
                                relativePath := strings.TrimPrefix(filePath, expectedPrefix)
                                if !strings.Contains(relativePath, "/") &amp;&amp; relativePath != "" </span><span class="cov0" title="0">{
                                        files = append(files, file)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // List files in a specific subdirectory
                        expectedPrefix := fullPath + "/"
                        if strings.HasPrefix(filePath, expectedPrefix) </span><span class="cov0" title="0">{
                                relativePath := strings.TrimPrefix(filePath, expectedPrefix)
                                if !strings.Contains(relativePath, "/") &amp;&amp; relativePath != "" </span><span class="cov0" title="0">{
                                        files = append(files, file)
                                }</span>
                        }
                }
        }

        // Sort files by name
        <span class="cov0" title="0">sort.Slice(files, func(i, j int) bool </span><span class="cov0" title="0">{
                return files[i].Name &lt; files[j].Name
        }</span>)

        <span class="cov0" title="0">return files, nil</span>
}

// GetFile retrieves a specific file
func (s *MockNFSServer) GetFile(exportPath, filePath string) (*MockNFSFile, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        // Check if export exists
        if _, exists := s.exports[exportPath]; !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("export not found: %s", exportPath)
        }</span>

        <span class="cov0" title="0">fullPath := exportPath + "/" + filePath
        if filePath == "" || filePath == "." </span><span class="cov0" title="0">{
                fullPath = exportPath
        }</span>

        <span class="cov0" title="0">file, exists := s.files[fullPath]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file not found: %s", fullPath)
        }</span>

        <span class="cov0" title="0">return file, nil</span>
}

// WriteFile writes content to a file (if export allows writing)
func (s *MockNFSServer) WriteFile(exportPath, filePath string, content []byte, mode, uid, gid uint32) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if export exists and is writable
        export, exists := s.exports[exportPath]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("export not found: %s", exportPath)
        }</span>

        <span class="cov0" title="0">if !strings.Contains(export.Options, "rw") </span><span class="cov0" title="0">{
                return fmt.Errorf("export is read-only: %s", exportPath)
        }</span>

        <span class="cov0" title="0">fullPath := exportPath + "/" + filePath
        fileName := filepath.Base(filePath)

        // Generate inode number
        inode := uint64(len(s.files) + 1)

        s.files[fullPath] = &amp;MockNFSFile{
                Name:        fileName,
                Path:        fullPath,
                IsDirectory: false,
                Size:        int64(len(content)),
                ModTime:     time.Now(),
                Content:     content,
                Mode:        mode,
                UID:         uid,
                GID:         gid,
                Inode:       inode,
        }

        return nil</span>
}

// DeleteFile deletes a file (if export allows writing)
func (s *MockNFSServer) DeleteFile(exportPath, filePath string) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if export exists and is writable
        export, exists := s.exports[exportPath]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("export not found: %s", exportPath)
        }</span>

        <span class="cov0" title="0">if !strings.Contains(export.Options, "rw") </span><span class="cov0" title="0">{
                return fmt.Errorf("export is read-only: %s", exportPath)
        }</span>

        <span class="cov0" title="0">fullPath := exportPath + "/" + filePath
        if _, exists := s.files[fullPath]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("file not found: %s", fullPath)
        }</span>

        <span class="cov0" title="0">delete(s.files, fullPath)
        return nil</span>
}

// CreateDirectory creates a directory (if export allows writing)
func (s *MockNFSServer) CreateDirectory(exportPath, dirPath string, mode, uid, gid uint32) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if export exists and is writable
        export, exists := s.exports[exportPath]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("export not found: %s", exportPath)
        }</span>

        <span class="cov0" title="0">if !strings.Contains(export.Options, "rw") </span><span class="cov0" title="0">{
                return fmt.Errorf("export is read-only: %s", exportPath)
        }</span>

        <span class="cov0" title="0">fullPath := exportPath + "/" + dirPath
        dirName := filepath.Base(dirPath)

        // Generate inode number
        inode := uint64(len(s.files) + 1)

        s.files[fullPath] = &amp;MockNFSFile{
                Name:        dirName,
                Path:        fullPath,
                IsDirectory: true,
                Size:        0,
                ModTime:     time.Now(),
                Content:     []byte{},
                Mode:        mode,
                UID:         uid,
                GID:         gid,
                Inode:       inode,
        }

        return nil</span>
}

// GetFileCount returns the number of files/directories
func (s *MockNFSServer) GetFileCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.files)
}</span>

// GetExportCount returns the number of exports
func (s *MockNFSServer) GetExportCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.exports)
}</span>

// GetExportNames returns list of export paths
func (s *MockNFSServer) GetExportNames() []string <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var names []string
        for path := range s.exports </span><span class="cov0" title="0">{
                names = append(names, path)
        }</span>

        <span class="cov0" title="0">sort.Strings(names)
        return names</span>
}

// TestConnection tests if a client can connect to an export
func (s *MockNFSServer) TestConnection(exportPath, clientIP string) error <span class="cov0" title="0">{
        return s.Mount(exportPath, clientIP)
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">package mocks

import (
        "fmt"
        "net"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"
)

// MockSMBServer provides a mock SMB server for testing
type MockSMBServer struct {
        logger   *zap.Logger
        listener net.Listener
        port     int
        shares   map[string]*MockSMBShare
        users    map[string]string // username -&gt; password
        running  bool
        wg       sync.WaitGroup
        mu       sync.RWMutex
}

// MockSMBShare represents a mock SMB share
type MockSMBShare struct {
        Name        string
        Description string
        Files       map[string]*MockSMBFile
        Writable    bool
}

// MockSMBFile represents a mock file or directory
type MockSMBFile struct {
        Name        string
        IsDirectory bool
        Size        int64
        ModTime     time.Time
        Content     []byte
}

// NewMockSMBServer creates a new mock SMB server
func NewMockSMBServer(logger *zap.Logger) *MockSMBServer <span class="cov0" title="0">{
        server := &amp;MockSMBServer{
                logger: logger,
                shares: make(map[string]*MockSMBShare),
                users:  make(map[string]string),
        }

        // Add default shares and users
        server.setupDefaultData()

        return server
}</span>

// setupDefaultData adds default shares, users, and files for testing
func (s *MockSMBServer) setupDefaultData() <span class="cov0" title="0">{
        // Add default users
        s.users["guest"] = ""
        s.users["testuser"] = "testpass"
        s.users["admin"] = "adminpass"

        // Add default shares
        s.AddShare("shared", "Shared folder", true)
        s.AddShare("public", "Public folder", false)
        s.AddShare("media", "Media files", true)
        s.AddShare("backup", "Backup files", false)

        // Add sample files to shares
        s.AddFile("shared", "", "documents", true, 0, []byte{})
        s.AddFile("shared", "", "readme.txt", false, 1024, []byte("Welcome to the shared folder!"))
        s.AddFile("shared", "documents", "report.doc", false, 2048, []byte("Sample document content"))

        s.AddFile("media", "", "videos", true, 0, []byte{})
        s.AddFile("media", "", "music", true, 0, []byte{})
        s.AddFile("media", "videos", "sample.mp4", false, 1048576, []byte("Mock video content"))
        s.AddFile("media", "music", "song.mp3", false, 524288, []byte("Mock audio content"))

        s.AddFile("public", "", "info.txt", false, 512, []byte("Public information"))
        s.AddFile("public", "", "downloads", true, 0, []byte{})

        s.AddFile("backup", "", "backup_2024.zip", false, 10485760, []byte("Mock backup data"))
}</span>

// AddShare adds a share to the mock server
func (s *MockSMBServer) AddShare(name, description string, writable bool) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.shares[name] = &amp;MockSMBShare{
                Name:        name,
                Description: description,
                Files:       make(map[string]*MockSMBFile),
                Writable:    writable,
        }
}</span>

// AddFile adds a file or directory to a share
func (s *MockSMBServer) AddFile(shareName, parentPath, fileName string, isDirectory bool, size int64, content []byte) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        share, exists := s.shares[shareName]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">path := fileName
        if parentPath != "" </span><span class="cov0" title="0">{
                path = parentPath + "/" + fileName
        }</span>

        <span class="cov0" title="0">share.Files[path] = &amp;MockSMBFile{
                Name:        fileName,
                IsDirectory: isDirectory,
                Size:        size,
                ModTime:     time.Now(),
                Content:     content,
        }</span>
}

// AddUser adds a user with password
func (s *MockSMBServer) AddUser(username, password string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.users[username] = password
}</span>

// Start starts the mock SMB server
func (s *MockSMBServer) Start() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.running </span><span class="cov0" title="0">{
                return fmt.Errorf("server already running")
        }</span>

        // Listen on any available port
        <span class="cov0" title="0">listener, err := net.Listen("tcp", ":0")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start listener: %w", err)
        }</span>

        <span class="cov0" title="0">s.listener = listener
        s.port = listener.Addr().(*net.TCPAddr).Port
        s.running = true

        s.logger.Info("Mock SMB server started", zap.Int("port", s.port))

        // Start accepting connections
        s.wg.Add(1)
        go s.acceptConnections()

        return nil</span>
}

// Stop stops the mock SMB server
func (s *MockSMBServer) Stop() error <span class="cov0" title="0">{
        s.mu.Lock()
        if !s.running </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return nil
        }</span>
        <span class="cov0" title="0">s.running = false
        s.mu.Unlock()

        if s.listener != nil </span><span class="cov0" title="0">{
                s.listener.Close()
        }</span>

        <span class="cov0" title="0">s.wg.Wait()
        s.logger.Info("Mock SMB server stopped")
        return nil</span>
}

// GetPort returns the port the server is listening on
func (s *MockSMBServer) GetPort() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.port
}</span>

// GetAddress returns the server address
func (s *MockSMBServer) GetAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("localhost:%d", s.GetPort())
}</span>

// acceptConnections handles incoming connections
func (s *MockSMBServer) acceptConnections() <span class="cov0" title="0">{
        defer s.wg.Done()

        for </span><span class="cov0" title="0">{
                conn, err := s.listener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        s.mu.RLock()
                        running := s.running
                        s.mu.RUnlock()

                        if !running </span><span class="cov0" title="0">{
                                return // Server stopped
                        }</span>
                        <span class="cov0" title="0">s.logger.Error("Failed to accept connection", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">s.wg.Add(1)
                go s.handleConnection(conn)</span>
        }
}

// handleConnection handles a single SMB connection
func (s *MockSMBServer) handleConnection(conn net.Conn) <span class="cov0" title="0">{
        defer s.wg.Done()
        defer conn.Close()

        s.logger.Debug("New SMB connection", zap.String("remote", conn.RemoteAddr().String()))

        // This is a simplified mock implementation
        // In a real scenario, you'd implement the full SMB protocol

        // For testing purposes, we'll simulate basic SMB responses
        // This allows the go-smb2 client to connect and get mock data

        // Read initial request
        buffer := make([]byte, 4096)
        n, err := conn.Read(buffer)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to read from connection", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">request := buffer[:n]
        s.logger.Debug("Received SMB request", zap.Int("bytes", n))

        // Send mock response (simplified)
        response := s.generateMockResponse(request)
        _, err = conn.Write(response)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Failed to write response", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Sent SMB response", zap.Int("bytes", len(response)))</span>
}

// generateMockResponse generates a mock SMB response
func (s *MockSMBServer) generateMockResponse(request []byte) []byte <span class="cov0" title="0">{
        // This is a simplified mock response
        // In practice, you'd need to implement proper SMB protocol handling

        // For testing, return a basic success response
        response := make([]byte, 64)
        copy(response[0:4], []byte{0xFE, 0x53, 0x4D, 0x42}) // SMB2 signature
        return response
}</span>

// AuthenticateUser checks if user credentials are valid
func (s *MockSMBServer) AuthenticateUser(username, password string) bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        expectedPassword, exists := s.users[username]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return expectedPassword == password</span>
}

// ListShares returns available shares
func (s *MockSMBServer) ListShares() []MockSMBShare <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var shares []MockSMBShare
        for _, share := range s.shares </span><span class="cov0" title="0">{
                shares = append(shares, *share)
        }</span>
        <span class="cov0" title="0">return shares</span>
}

// ListFiles returns files in a share path
func (s *MockSMBServer) ListFiles(shareName, path string) ([]*MockSMBFile, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        share, exists := s.shares[shareName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("share not found: %s", shareName)
        }</span>

        <span class="cov0" title="0">var files []*MockSMBFile

        // List files in the specified path
        for filePath, file := range share.Files </span><span class="cov0" title="0">{
                // Check if file is in the requested path
                if path == "" || path == "." </span><span class="cov0" title="0">{
                        // Root path - include files with no parent path
                        if !strings.Contains(filePath, "/") </span><span class="cov0" title="0">{
                                files = append(files, file)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Specific path - include files that start with the path
                        if strings.HasPrefix(filePath, path+"/") </span><span class="cov0" title="0">{
                                relativePath := strings.TrimPrefix(filePath, path+"/")
                                if !strings.Contains(relativePath, "/") </span><span class="cov0" title="0">{
                                        // Direct child of the path
                                        files = append(files, file)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return files, nil</span>
}

// GetFile returns file content
func (s *MockSMBServer) GetFile(shareName, filePath string) (*MockSMBFile, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        share, exists := s.shares[shareName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("share not found: %s", shareName)
        }</span>

        <span class="cov0" title="0">file, exists := share.Files[filePath]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file not found: %s", filePath)
        }</span>

        <span class="cov0" title="0">return file, nil</span>
}

// WriteFile writes content to a file (if share is writable)
func (s *MockSMBServer) WriteFile(shareName, filePath string, content []byte) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        share, exists := s.shares[shareName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("share not found: %s", shareName)
        }</span>

        <span class="cov0" title="0">if !share.Writable </span><span class="cov0" title="0">{
                return fmt.Errorf("share is read-only: %s", shareName)
        }</span>

        // Extract filename from path
        <span class="cov0" title="0">fileName := filePath
        if strings.Contains(filePath, "/") </span><span class="cov0" title="0">{
                parts := strings.Split(filePath, "/")
                fileName = parts[len(parts)-1]
        }</span>

        <span class="cov0" title="0">share.Files[filePath] = &amp;MockSMBFile{
                Name:        fileName,
                IsDirectory: false,
                Size:        int64(len(content)),
                ModTime:     time.Now(),
                Content:     content,
        }

        return nil</span>
}

// DeleteFile deletes a file (if share is writable)
func (s *MockSMBServer) DeleteFile(shareName, filePath string) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        share, exists := s.shares[shareName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("share not found: %s", shareName)
        }</span>

        <span class="cov0" title="0">if !share.Writable </span><span class="cov0" title="0">{
                return fmt.Errorf("share is read-only: %s", shareName)
        }</span>

        <span class="cov0" title="0">delete(share.Files, filePath)
        return nil</span>
}

// GetShareNames returns list of share names
func (s *MockSMBServer) GetShareNames() []string <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var names []string
        for name := range s.shares </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// IsRunning returns true if the server is running
func (s *MockSMBServer) IsRunning() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.running
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package mocks

import (
        "fmt"
        "io"
        "net"
        "net/http"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"
)

// MockWebDAVServer provides a mock WebDAV server for testing
type MockWebDAVServer struct {
        logger   *zap.Logger
        server   *http.Server
        port     int
        users    map[string]string // username -&gt; password
        files    map[string]*MockWebDAVFile
        running  bool
        mu       sync.RWMutex
        basePath string
}

// MockWebDAVFile represents a mock WebDAV file or collection
type MockWebDAVFile struct {
        Name        string
        Path        string
        IsDirectory bool
        Size        int64
        ModTime     time.Time
        Content     []byte
        ETag        string
        ContentType string
}

// NewMockWebDAVServer creates a new mock WebDAV server
func NewMockWebDAVServer(logger *zap.Logger) *MockWebDAVServer <span class="cov0" title="0">{
        server := &amp;MockWebDAVServer{
                logger:   logger,
                users:    make(map[string]string),
                files:    make(map[string]*MockWebDAVFile),
                basePath: "/dav",
        }

        server.setupDefaultData()
        return server
}</span>

// setupDefaultData adds default users and files for testing
func (s *MockWebDAVServer) setupDefaultData() <span class="cov0" title="0">{
        // Add default users
        s.users["webdavuser"] = "webdavpass"
        s.users["testuser"] = "testpass"
        s.users["admin"] = "adminpass"

        // Add default directory structure
        s.AddFile("/", "documents", true, 0, []byte{}, "text/html")
        s.AddFile("/", "media", true, 0, []byte{}, "text/html")
        s.AddFile("/", "public", true, 0, []byte{}, "text/html")
        s.AddFile("/", "welcome.txt", false, 1024, []byte("Welcome to WebDAV server!"), "text/plain")

        s.AddFile("/documents", "reports", true, 0, []byte{}, "text/html")
        s.AddFile("/documents", "templates", true, 0, []byte{}, "text/html")
        s.AddFile("/documents", "readme.md", false, 2048, []byte("# Document Repository\n\nThis is the document repository."), "text/markdown")

        s.AddFile("/documents/reports", "quarterly.pdf", false, 512000, []byte("Mock PDF content"), "application/pdf")
        s.AddFile("/documents/reports", "monthly.xlsx", false, 256000, []byte("Mock Excel content"), "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

        s.AddFile("/documents/templates", "letter.docx", false, 128000, []byte("Mock Word template"), "application/vnd.openxmlformats-officedocument.wordprocessingml.document")
        s.AddFile("/documents/templates", "invoice.html", false, 8192, []byte("&lt;html&gt;&lt;body&gt;Invoice Template&lt;/body&gt;&lt;/html&gt;"), "text/html")

        s.AddFile("/media", "images", true, 0, []byte{}, "text/html")
        s.AddFile("/media", "videos", true, 0, []byte{}, "text/html")
        s.AddFile("/media", "audio", true, 0, []byte{}, "text/html")

        s.AddFile("/media/images", "logo.png", false, 32768, []byte("Mock PNG content"), "image/png")
        s.AddFile("/media/images", "banner.jpg", false, 65536, []byte("Mock JPEG content"), "image/jpeg")

        s.AddFile("/media/videos", "demo.mp4", false, 10485760, []byte("Mock video content"), "video/mp4")
        s.AddFile("/media/audio", "background.mp3", false, 5242880, []byte("Mock audio content"), "audio/mpeg")

        s.AddFile("/public", "info.html", false, 4096, []byte("&lt;html&gt;&lt;body&gt;&lt;h1&gt;Public Information&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"), "text/html")
        s.AddFile("/public", "downloads", true, 0, []byte{}, "text/html")
}</span>

// AddFile adds a file or collection to the server
func (s *MockWebDAVServer) AddFile(parentPath, name string, isDirectory bool, size int64, content []byte, contentType string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        path := filepath.Join(parentPath, name)
        if parentPath == "/" </span><span class="cov0" title="0">{
                path = "/" + name
        }</span>

        // Generate ETag
        <span class="cov0" title="0">etag := fmt.Sprintf(`"%x-%d"`, time.Now().Unix(), size)

        s.files[path] = &amp;MockWebDAVFile{
                Name:        name,
                Path:        path,
                IsDirectory: isDirectory,
                Size:        size,
                ModTime:     time.Now(),
                Content:     content,
                ETag:        etag,
                ContentType: contentType,
        }</span>
}

// AddUser adds a user with password
func (s *MockWebDAVServer) AddUser(username, password string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.users[username] = password
}</span>

// Start starts the mock WebDAV server
func (s *MockWebDAVServer) Start() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.running </span><span class="cov0" title="0">{
                return fmt.Errorf("server already running")
        }</span>

        <span class="cov0" title="0">mux := http.NewServeMux()
        mux.HandleFunc("/", s.handleRequest)

        s.server = &amp;http.Server{
                Addr:    ":0",
                Handler: mux,
        }

        // Start server in a goroutine to get the port
        listener, err := net.Listen("tcp", ":0")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start listener: %w", err)
        }</span>

        <span class="cov0" title="0">s.port = listener.Addr().(*net.TCPAddr).Port
        s.running = true

        go func() </span><span class="cov0" title="0">{
                err := s.server.Serve(listener)
                if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.Error("WebDAV server error", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">s.logger.Info("Mock WebDAV server started", zap.Int("port", s.port))
        return nil</span>
}

// Stop stops the mock WebDAV server
func (s *MockWebDAVServer) Stop() error <span class="cov0" title="0">{
        s.mu.Lock()
        if !s.running </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return nil
        }</span>
        <span class="cov0" title="0">s.running = false
        s.mu.Unlock()

        if s.server != nil </span><span class="cov0" title="0">{
                err := s.server.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">s.logger.Info("Mock WebDAV server stopped")
        return nil</span>
}

// GetPort returns the port the server is listening on
func (s *MockWebDAVServer) GetPort() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.port
}</span>

// GetAddress returns the server address
func (s *MockWebDAVServer) GetAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("http://localhost:%d%s", s.GetPort(), s.basePath)
}</span>

// handleRequest handles HTTP requests
func (s *MockWebDAVServer) handleRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        s.logger.Debug("WebDAV request", zap.String("method", r.Method), zap.String("path", r.URL.Path))

        // Basic authentication
        if !s.authenticate(r) </span><span class="cov0" title="0">{
                w.Header().Set("WWW-Authenticate", `Basic realm="WebDAV"`)
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        // Remove base path prefix
        <span class="cov0" title="0">path := strings.TrimPrefix(r.URL.Path, s.basePath)
        if path == "" </span><span class="cov0" title="0">{
                path = "/"
        }</span>

        <span class="cov0" title="0">switch r.Method </span>{
        case "OPTIONS":<span class="cov0" title="0">
                s.handleOptions(w, r, path)</span>
        case "GET":<span class="cov0" title="0">
                s.handleGet(w, r, path)</span>
        case "HEAD":<span class="cov0" title="0">
                s.handleHead(w, r, path)</span>
        case "PROPFIND":<span class="cov0" title="0">
                s.handlePropfind(w, r, path)</span>
        case "PUT":<span class="cov0" title="0">
                s.handlePut(w, r, path)</span>
        case "DELETE":<span class="cov0" title="0">
                s.handleDelete(w, r, path)</span>
        case "MKCOL":<span class="cov0" title="0">
                s.handleMkcol(w, r, path)</span>
        case "COPY":<span class="cov0" title="0">
                s.handleCopy(w, r, path)</span>
        case "MOVE":<span class="cov0" title="0">
                s.handleMove(w, r, path)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// authenticate performs basic authentication
func (s *MockWebDAVServer) authenticate(r *http.Request) bool <span class="cov0" title="0">{
        username, password, ok := r.BasicAuth()
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">s.mu.RLock()
        defer s.mu.RUnlock()

        expectedPassword, exists := s.users[username]
        return exists &amp;&amp; expectedPassword == password</span>
}

// handleOptions handles OPTIONS requests
func (s *MockWebDAVServer) handleOptions(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        w.Header().Set("Allow", "OPTIONS, GET, HEAD, POST, PUT, DELETE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE")
        w.Header().Set("DAV", "1, 2")
        w.WriteHeader(http.StatusOK)
}</span>

// handleGet handles GET requests
func (s *MockWebDAVServer) handleGet(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        s.mu.RLock()
        file, exists := s.files[path]
        s.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">if file.IsDirectory </span><span class="cov0" title="0">{
                // Generate HTML listing for directories
                s.handleDirectoryListing(w, r, path)
                return
        }</span>

        // Serve file content
        <span class="cov0" title="0">w.Header().Set("Content-Type", file.ContentType)
        w.Header().Set("Content-Length", fmt.Sprintf("%d", file.Size))
        w.Header().Set("ETag", file.ETag)
        w.Header().Set("Last-Modified", file.ModTime.Format(time.RFC1123))

        w.WriteHeader(http.StatusOK)
        w.Write(file.Content)</span>
}

// handleHead handles HEAD requests
func (s *MockWebDAVServer) handleHead(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        s.mu.RLock()
        file, exists := s.files[path]
        s.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", file.ContentType)
        w.Header().Set("Content-Length", fmt.Sprintf("%d", file.Size))
        w.Header().Set("ETag", file.ETag)
        w.Header().Set("Last-Modified", file.ModTime.Format(time.RFC1123))

        w.WriteHeader(http.StatusOK)</span>
}

// handleDirectoryListing generates HTML directory listing
func (s *MockWebDAVServer) handleDirectoryListing(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        files := s.listFiles(path)

        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.WriteHeader(http.StatusOK)

        fmt.Fprintf(w, "&lt;html&gt;&lt;head&gt;&lt;title&gt;Directory: %s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;", path)
        fmt.Fprintf(w, "&lt;h1&gt;Directory: %s&lt;/h1&gt;&lt;ul&gt;", path)

        if path != "/" </span><span class="cov0" title="0">{
                fmt.Fprintf(w, `&lt;li&gt;&lt;a href="../"&gt;../&lt;/a&gt;&lt;/li&gt;`)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                name := file.Name
                if file.IsDirectory </span><span class="cov0" title="0">{
                        name += "/"
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(w, `&lt;li&gt;&lt;a href="%s"&gt;%s&lt;/a&gt; (%d bytes)&lt;/li&gt;`, name, name, file.Size)</span>
        }

        <span class="cov0" title="0">fmt.Fprintf(w, "&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;")</span>
}

// handlePropfind handles PROPFIND requests
func (s *MockWebDAVServer) handlePropfind(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        depth := r.Header.Get("Depth")
        if depth == "" </span><span class="cov0" title="0">{
                depth = "1"
        }</span>

        <span class="cov0" title="0">s.mu.RLock()
        file, exists := s.files[path]
        s.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/xml; charset=utf-8")
        w.WriteHeader(http.StatusMultiStatus)

        // Generate WebDAV XML response
        fmt.Fprintf(w, `&lt;?xml version="1.0" encoding="utf-8"?&gt;`)
        fmt.Fprintf(w, `&lt;D:multistatus xmlns:D="DAV:"&gt;`)

        // Add current resource
        s.writePropfindResponse(w, file)

        // Add children if depth &gt; 0 and it's a directory
        if depth != "0" &amp;&amp; file.IsDirectory </span><span class="cov0" title="0">{
                children := s.listFiles(path)
                for _, child := range children </span><span class="cov0" title="0">{
                        s.writePropfindResponse(w, child)
                }</span>
        }

        <span class="cov0" title="0">fmt.Fprintf(w, `&lt;/D:multistatus&gt;`)</span>
}

// writePropfindResponse writes a single resource response
func (s *MockWebDAVServer) writePropfindResponse(w http.ResponseWriter, file *MockWebDAVFile) <span class="cov0" title="0">{
        href := s.basePath + file.Path
        if file.IsDirectory &amp;&amp; !strings.HasSuffix(href, "/") </span><span class="cov0" title="0">{
                href += "/"
        }</span>

        <span class="cov0" title="0">resourceType := ""
        if file.IsDirectory </span><span class="cov0" title="0">{
                resourceType = "&lt;D:collection/&gt;"
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(w, `&lt;D:response&gt;`)
        fmt.Fprintf(w, `&lt;D:href&gt;%s&lt;/D:href&gt;`, href)
        fmt.Fprintf(w, `&lt;D:propstat&gt;`)
        fmt.Fprintf(w, `&lt;D:prop&gt;`)
        fmt.Fprintf(w, `&lt;D:displayname&gt;%s&lt;/D:displayname&gt;`, file.Name)
        fmt.Fprintf(w, `&lt;D:getcontentlength&gt;%d&lt;/D:getcontentlength&gt;`, file.Size)
        fmt.Fprintf(w, `&lt;D:getcontenttype&gt;%s&lt;/D:getcontenttype&gt;`, file.ContentType)
        fmt.Fprintf(w, `&lt;D:getetag&gt;%s&lt;/D:getetag&gt;`, file.ETag)
        fmt.Fprintf(w, `&lt;D:getlastmodified&gt;%s&lt;/D:getlastmodified&gt;`, file.ModTime.Format(time.RFC1123))
        fmt.Fprintf(w, `&lt;D:resourcetype&gt;%s&lt;/D:resourcetype&gt;`, resourceType)
        fmt.Fprintf(w, `&lt;/D:prop&gt;`)
        fmt.Fprintf(w, `&lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt;`)
        fmt.Fprintf(w, `&lt;/D:propstat&gt;`)
        fmt.Fprintf(w, `&lt;/D:response&gt;`)</span>
}

// handlePut handles PUT requests
func (s *MockWebDAVServer) handlePut(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        content, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to read body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">contentType := r.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov0" title="0">{
                contentType = "application/octet-stream"
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        // Extract filename from path
        fileName := filepath.Base(path)

        s.files[path] = &amp;MockWebDAVFile{
                Name:        fileName,
                Path:        path,
                IsDirectory: false,
                Size:        int64(len(content)),
                ModTime:     time.Now(),
                Content:     content,
                ETag:        fmt.Sprintf(`"%x-%d"`, time.Now().Unix(), len(content)),
                ContentType: contentType,
        }

        w.WriteHeader(http.StatusCreated)</span>
}

// handleDelete handles DELETE requests
func (s *MockWebDAVServer) handleDelete(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if _, exists := s.files[path]; !exists </span><span class="cov0" title="0">{
                http.Error(w, "Not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">delete(s.files, path)
        w.WriteHeader(http.StatusNoContent)</span>
}

// handleMkcol handles MKCOL requests
func (s *MockWebDAVServer) handleMkcol(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if _, exists := s.files[path]; exists </span><span class="cov0" title="0">{
                http.Error(w, "Collection already exists", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">fileName := filepath.Base(path)

        s.files[path] = &amp;MockWebDAVFile{
                Name:        fileName,
                Path:        path,
                IsDirectory: true,
                Size:        0,
                ModTime:     time.Now(),
                Content:     []byte{},
                ETag:        fmt.Sprintf(`"%x-0"`, time.Now().Unix()),
                ContentType: "text/html",
        }

        w.WriteHeader(http.StatusCreated)</span>
}

// handleCopy handles COPY requests
func (s *MockWebDAVServer) handleCopy(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        destination := r.Header.Get("Destination")
        if destination == "" </span><span class="cov0" title="0">{
                http.Error(w, "Destination header required", http.StatusBadRequest)
                return
        }</span>

        // Parse destination URL to get path
        <span class="cov0" title="0">destPath := strings.TrimPrefix(destination, s.GetAddress())

        s.mu.Lock()
        defer s.mu.Unlock()

        sourceFile, exists := s.files[path]
        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Source not found", http.StatusNotFound)
                return
        }</span>

        // Create copy
        <span class="cov0" title="0">s.files[destPath] = &amp;MockWebDAVFile{
                Name:        filepath.Base(destPath),
                Path:        destPath,
                IsDirectory: sourceFile.IsDirectory,
                Size:        sourceFile.Size,
                ModTime:     time.Now(),
                Content:     append([]byte(nil), sourceFile.Content...),
                ETag:        fmt.Sprintf(`"%x-%d"`, time.Now().Unix(), sourceFile.Size),
                ContentType: sourceFile.ContentType,
        }

        w.WriteHeader(http.StatusCreated)</span>
}

// handleMove handles MOVE requests
func (s *MockWebDAVServer) handleMove(w http.ResponseWriter, r *http.Request, path string) <span class="cov0" title="0">{
        destination := r.Header.Get("Destination")
        if destination == "" </span><span class="cov0" title="0">{
                http.Error(w, "Destination header required", http.StatusBadRequest)
                return
        }</span>

        // Parse destination URL to get path
        <span class="cov0" title="0">destPath := strings.TrimPrefix(destination, s.GetAddress())

        s.mu.Lock()
        defer s.mu.Unlock()

        sourceFile, exists := s.files[path]
        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Source not found", http.StatusNotFound)
                return
        }</span>

        // Move file
        <span class="cov0" title="0">sourceFile.Path = destPath
        sourceFile.Name = filepath.Base(destPath)
        s.files[destPath] = sourceFile
        delete(s.files, path)

        w.WriteHeader(http.StatusCreated)</span>
}

// listFiles returns files in a directory
func (s *MockWebDAVServer) listFiles(path string) []*MockWebDAVFile <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var files []*MockWebDAVFile

        for filePath, file := range s.files </span><span class="cov0" title="0">{
                if filePath == path </span><span class="cov0" title="0">{
                        continue</span> // Skip the directory itself
                }

                // Check if file is a direct child of the path
                <span class="cov0" title="0">expectedPrefix := path
                if path == "/" </span><span class="cov0" title="0">{
                        expectedPrefix = "/"
                }</span> else<span class="cov0" title="0"> {
                        expectedPrefix = path + "/"
                }</span>

                <span class="cov0" title="0">if strings.HasPrefix(filePath, expectedPrefix) </span><span class="cov0" title="0">{
                        relativePath := strings.TrimPrefix(filePath, expectedPrefix)
                        if !strings.Contains(relativePath, "/") </span><span class="cov0" title="0">{
                                // Direct child
                                files = append(files, file)
                        }</span>
                }
        }

        // Sort files by name
        <span class="cov0" title="0">sort.Slice(files, func(i, j int) bool </span><span class="cov0" title="0">{
                return files[i].Name &lt; files[j].Name
        }</span>)

        <span class="cov0" title="0">return files</span>
}

// IsRunning returns true if the server is running
func (s *MockWebDAVServer) IsRunning() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.running
}</span>

// GetFileCount returns the number of files/directories
func (s *MockWebDAVServer) GetFileCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.files)
}</span>

// GetUserCount returns the number of users
func (s *MockWebDAVServer) GetUserCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.users)
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package tests

import (
        "fmt"
        "io"
        "log"
        "os"
        "testing"
)

// TestMain is the entry point for all tests
func TestMain(m *testing.M) <span class="cov0" title="0">{
        // Setup
        fmt.Println("Starting Catalogizer v3.0 Test Suite...")

        // Disable logging during tests for cleaner output
        log.SetOutput(io.Discard)

        // Run tests
        code := m.Run()

        // Cleanup
        fmt.Println("Test Suite Completed")

        os.Exit(code)
}</span>
</pre>
		
		<pre class="file" id="file114" style="display: none">package tests

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "net/http/httptest"
        "os"
        "path/filepath"
        "strings"
        "testing"
        "time"

        "catalogizer/models"
        "catalogizer/repository"
        "catalogizer/services"

        _ "github.com/mattn/go-sqlite3"
)

// TestDatabase represents a test database instance
type TestDatabase struct {
        DB   *sql.DB
        Path string
}

// TestSuite represents a complete test suite with all dependencies
type TestSuite struct {
        DB                    *TestDatabase
        UserRepo              *repository.UserRepository
        AuthService           *services.AuthService
        AnalyticsRepo         *repository.AnalyticsRepository
        FavoritesRepo         *repository.FavoritesRepository
        ConversionRepo        *repository.ConversionRepository
        SyncRepo              *repository.SyncRepository
        StressTestRepo        *repository.StressTestRepository
        ErrorRepo             *repository.ErrorReportingRepository
        CrashRepo             *repository.CrashReportingRepository
        LogRepo               *repository.LogManagementRepository
        ConfigRepo            *repository.ConfigurationRepository
        AnalyticsService      *services.AnalyticsService
        FavoritesService      *services.FavoritesService
        ConversionService     *services.ConversionService
        SyncService           *services.SyncService
        StressTestService     *services.StressTestService
        ErrorReportingService *services.ErrorReportingService
        LogManagementService  *services.LogManagementService
        ConfigurationService  *services.ConfigurationService
}

// SetupTestDatabase creates a test database with all required tables
func SetupTestDatabase(t *testing.T) *TestDatabase <span class="cov4" title="7">{
        // Create temporary database file
        tempDir := t.TempDir()
        dbPath := filepath.Join(tempDir, "test.db")

        db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to open test database: %v", err)
        }</span>

        // Create all required tables
        <span class="cov4" title="7">if err := createTestTables(db); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test tables: %v", err)
        }</span>

        <span class="cov4" title="7">return &amp;TestDatabase{
                DB:   db,
                Path: dbPath,
        }</span>
}

// CleanupTestDatabase closes and removes the test database
func (td *TestDatabase) Cleanup() <span class="cov4" title="7">{
        if td.DB != nil </span><span class="cov4" title="7">{
                td.DB.Close()
        }</span>
        <span class="cov4" title="7">if td.Path != "" </span><span class="cov4" title="7">{
                os.Remove(td.Path)
        }</span>
}

// SetupTestSuite creates a complete test suite with all services and repositories
func SetupTestSuite(t *testing.T) *TestSuite <span class="cov4" title="7">{
        // Create test database
        testDB := SetupTestDatabase(t)

        // Create repositories
        userRepo := repository.NewUserRepository(testDB.DB)
        analyticsRepo := repository.NewAnalyticsRepository(testDB.DB)
        favoritesRepo := repository.NewFavoritesRepository(testDB.DB)
        conversionRepo := repository.NewConversionRepository(testDB.DB)
        syncRepo := repository.NewSyncRepository(testDB.DB)
        stressTestRepo := repository.NewStressTestRepository(testDB.DB)
        errorRepo := repository.NewErrorReportingRepository(testDB.DB)
        crashRepo := repository.NewCrashReportingRepository(testDB.DB)
        logRepo := repository.NewLogManagementRepository(testDB.DB)
        configRepo := repository.NewConfigurationRepository(testDB.DB)

        // Create auth service
        authService := services.NewAuthService(userRepo, "test-jwt-secret")

        // Create services
        analyticsService := services.NewAnalyticsService(analyticsRepo)
        favoritesService := services.NewFavoritesService(favoritesRepo, authService)
        conversionService := services.NewConversionService(conversionRepo, userRepo, authService)
        syncService := services.NewSyncService(syncRepo, userRepo, authService)
        stressTestService := services.NewStressTestService(stressTestRepo, authService)
        errorReportingService := services.NewErrorReportingService(errorRepo, crashRepo)
        logManagementService := services.NewLogManagementService(logRepo)
        configurationService := services.NewConfigurationService(configRepo, "/tmp/test_config.json")

        return &amp;TestSuite{
                DB:                    testDB,
                UserRepo:              userRepo,
                AuthService:           authService,
                AnalyticsRepo:         analyticsRepo,
                FavoritesRepo:         favoritesRepo,
                ConversionRepo:        conversionRepo,
                SyncRepo:              syncRepo,
                StressTestRepo:        stressTestRepo,
                ErrorRepo:             errorRepo,
                CrashRepo:             crashRepo,
                LogRepo:               logRepo,
                ConfigRepo:            configRepo,
                AnalyticsService:      analyticsService,
                FavoritesService:      favoritesService,
                ConversionService:     conversionService,
                SyncService:           syncService,
                StressTestService:     stressTestService,
                ErrorReportingService: errorReportingService,
                LogManagementService:  logManagementService,
                ConfigurationService:  configurationService,
        }
}</span>

// Cleanup cleans up the test suite
func (ts *TestSuite) Cleanup() <span class="cov4" title="7">{
        if ts.DB != nil </span><span class="cov4" title="7">{
                ts.DB.Cleanup()
        }</span>
}

// CreateTestUser creates a test user for testing
func CreateTestUser(t *testing.T, db *sql.DB, userID int) *models.User <span class="cov4" title="6">{
        user := &amp;models.User{
                ID:       userID,
                Username: fmt.Sprintf("testuser%d", userID),
                Email:    fmt.Sprintf("test%d@example.com", userID),
                RoleID:   1,
                IsActive: true,
        }

        query := `INSERT INTO users (id, username, email, role_id, is_active, created_at) VALUES (?, ?, ?, ?, ?, ?)`
        _, err := db.Exec(query, user.ID, user.Username, user.Email, user.RoleID, user.IsActive, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test user: %v", err)
        }</span>

        <span class="cov4" title="6">return user</span>
}

// CreateTestMediaItem creates a test media item for testing
func CreateTestMediaItem(t *testing.T, db *sql.DB, itemID int, userID int) *models.MediaItem <span class="cov0" title="0">{
        item := &amp;models.MediaItem{
                ID:     itemID,
                UserID: userID,
                Title:  fmt.Sprintf("Test Media %d", itemID),
                Type:   "video",
                Path:   fmt.Sprintf("/test/media/%d.mp4", itemID),
                Size:   1024 * 1024,
        }

        query := `INSERT INTO media_items (id, user_id, title, type, path, size, created_at, updated_at)
                          VALUES (?, ?, ?, ?, ?, ?, ?, ?)`
        _, err := db.Exec(query, item.ID, item.UserID, item.Title, item.Type, item.Path, item.Size, time.Now(), time.Now())
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test media item: %v", err)
        }</span>

        <span class="cov0" title="0">return item</span>
}

// AssertEqual checks if two values are equal
func AssertEqual(t *testing.T, expected, actual interface{}, message string) <span class="cov4" title="6">{
        if expected != actual </span><span class="cov0" title="0">{
                t.Errorf("%s: expected %v, got %v", message, expected, actual)
        }</span>
}

// AssertNotNil checks if a value is not nil
func AssertNotNil(t *testing.T, value interface{}, message string) <span class="cov4" title="6">{
        if value == nil </span><span class="cov0" title="0">{
                t.Errorf("%s: expected non-nil value", message)
        }</span>
}

// AssertNil checks if a value is nil
func AssertNil(t *testing.T, value interface{}, message string) <span class="cov0" title="0">{
        if value != nil </span><span class="cov0" title="0">{
                t.Errorf("%s: expected nil value, got %v", message, value)
        }</span>
}

// AssertError checks if an error occurred
func AssertError(t *testing.T, err error, message string) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                t.Errorf("%s: expected error but got none", message)
        }</span>
}

// AssertNoError checks if no error occurred
func AssertNoError(t *testing.T, err error, message string) <span class="cov5" title="14">{
        if err != nil </span><span class="cov0" title="0">{
                t.Errorf("%s: unexpected error: %v", message, err)
        }</span>
}

// AssertContains checks if a string contains a substring
func AssertContains(t *testing.T, str, substr, message string) <span class="cov0" title="0">{
        if !strings.Contains(str, substr) </span><span class="cov0" title="0">{
                t.Errorf("%s: expected '%s' to contain '%s'", message, str, substr)
        }</span>
}

// AssertHTTPStatus checks HTTP response status
func AssertHTTPStatus(t *testing.T, expected int, response *httptest.ResponseRecorder, message string) <span class="cov0" title="0">{
        if response.Code != expected </span><span class="cov0" title="0">{
                t.Errorf("%s: expected status %d, got %d", message, expected, response.Code)
        }</span>
}

// AssertJSONResponse checks JSON response structure
func AssertJSONResponse(t *testing.T, response *httptest.ResponseRecorder, expected interface{}, message string) <span class="cov0" title="0">{
        var actual interface{}
        err := json.Unmarshal(response.Body.Bytes(), &amp;actual)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("%s: failed to parse JSON response: %v", message, err)
        }</span>

        <span class="cov0" title="0">expectedJSON, _ := json.Marshal(expected)
        actualJSON, _ := json.Marshal(actual)

        if string(expectedJSON) != string(actualJSON) </span><span class="cov0" title="0">{
                t.Errorf("%s: JSON mismatch\nExpected: %s\nActual: %s", message, expectedJSON, actualJSON)
        }</span>
}

// MockHTTPServer creates a mock HTTP server for testing
func MockHTTPServer(handler http.HandlerFunc) *httptest.Server <span class="cov0" title="0">{
        return httptest.NewServer(handler)
}</span>

// WaitForCondition waits for a condition to be true with timeout
func WaitForCondition(t *testing.T, condition func() bool, timeout time.Duration, message string) <span class="cov0" title="0">{
        start := time.Now()
        for time.Since(start) &lt; timeout </span><span class="cov0" title="0">{
                if condition() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">time.Sleep(10 * time.Millisecond)</span>
        }
        <span class="cov0" title="0">t.Errorf("%s: condition not met within timeout", message)</span>
}

// GenerateTestData generates test data for various scenarios
type TestDataGenerator struct {
        UserID  int
        ItemID  int
        EventID int
}

func NewTestDataGenerator() *TestDataGenerator <span class="cov0" title="0">{
        return &amp;TestDataGenerator{
                UserID:  1000,
                ItemID:  2000,
                EventID: 3000,
        }
}</span>

func (g *TestDataGenerator) NextUserID() int <span class="cov0" title="0">{
        g.UserID++
        return g.UserID
}</span>

func (g *TestDataGenerator) NextItemID() int <span class="cov0" title="0">{
        g.ItemID++
        return g.ItemID
}</span>

func (g *TestDataGenerator) NextEventID() int <span class="cov0" title="0">{
        g.EventID++
        return g.EventID
}</span>

// createTestTables creates all required tables for testing
func createTestTables(db *sql.DB) error <span class="cov4" title="7">{
        tables := []string{
                // Users table
                `CREATE TABLE IF NOT EXISTS users (
                        id INTEGER PRIMARY KEY,
                        username TEXT UNIQUE NOT NULL,
                        email TEXT UNIQUE NOT NULL,
                        password_hash TEXT,
                        salt TEXT,
                        role_id INTEGER NOT NULL DEFAULT 1,
                        first_name TEXT,
                        last_name TEXT,
                        display_name TEXT,
                        avatar_url TEXT,
                        time_zone TEXT,
                        language TEXT,
                        settings TEXT DEFAULT '{}',
                        is_active BOOLEAN DEFAULT 1,
                        is_locked BOOLEAN DEFAULT 0,
                        locked_until DATETIME,
                        failed_login_attempts INTEGER DEFAULT 0,
                        last_login_at DATETIME,
                        last_login_ip TEXT,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,

                // Media items table
                `CREATE TABLE IF NOT EXISTS media_items (
                        id INTEGER PRIMARY KEY,
                        user_id INTEGER NOT NULL,
                        title TEXT NOT NULL,
                        type TEXT NOT NULL,
                        path TEXT NOT NULL,
                        size INTEGER,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Analytics events table
                `CREATE TABLE IF NOT EXISTS analytics_events (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER,
                        event_type TEXT NOT NULL,
                        event_category TEXT,
                        entity_type TEXT,
                        entity_id INTEGER,
                        data TEXT,
                        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                        session_id TEXT,
                        ip_address TEXT,
                        user_agent TEXT,
                        device_info TEXT,
                        location TEXT
                )`,

                // Favorites table
                `CREATE TABLE IF NOT EXISTS favorites (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        entity_type TEXT NOT NULL,
                        entity_id INTEGER NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        UNIQUE(user_id, entity_type, entity_id),
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Conversion jobs table
                `CREATE TABLE IF NOT EXISTS conversion_jobs (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        source_path TEXT NOT NULL,
                        target_path TEXT NOT NULL,
                        source_format TEXT NOT NULL,
                        target_format TEXT NOT NULL,
                        status TEXT NOT NULL DEFAULT 'pending',
                        progress INTEGER DEFAULT 0,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        started_at DATETIME,
                        completed_at DATETIME,
                        error_message TEXT,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Sync endpoints table
                `CREATE TABLE IF NOT EXISTS sync_endpoints (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        name TEXT NOT NULL,
                        type TEXT NOT NULL,
                        url TEXT NOT NULL,
                        username TEXT,
                        password TEXT,
                        settings TEXT,
                        status TEXT NOT NULL DEFAULT 'inactive',
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Sync sessions table
                `CREATE TABLE IF NOT EXISTS sync_sessions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        endpoint_id INTEGER NOT NULL,
                        status TEXT NOT NULL DEFAULT 'pending',
                        direction TEXT NOT NULL,
                        started_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        completed_at DATETIME,
                        files_processed INTEGER DEFAULT 0,
                        bytes_transferred INTEGER DEFAULT 0,
                        error_message TEXT,
                        FOREIGN KEY (endpoint_id) REFERENCES sync_endpoints(id)
                )`,

                // Stress tests table
                `CREATE TABLE IF NOT EXISTS stress_tests (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL,
                        description TEXT,
                        type TEXT NOT NULL,
                        status TEXT NOT NULL DEFAULT 'created',
                        scenarios TEXT,
                        configuration TEXT,
                        concurrent_users INTEGER NOT NULL,
                        duration_seconds INTEGER NOT NULL,
                        ramp_up_time INTEGER DEFAULT 0,
                        created_by INTEGER NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        started_at DATETIME,
                        completed_at DATETIME,
                        FOREIGN KEY (created_by) REFERENCES users(id)
                )`,

                // Stress test executions table
                `CREATE TABLE IF NOT EXISTS stress_test_executions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        stress_test_id INTEGER NOT NULL,
                        status TEXT NOT NULL DEFAULT 'pending',
                        started_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        completed_at DATETIME,
                        metrics TEXT,
                        results TEXT,
                        error_message TEXT,
                        FOREIGN KEY (stress_test_id) REFERENCES stress_tests(id)
                )`,

                // Error reports table
                `CREATE TABLE IF NOT EXISTS error_reports (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        level TEXT NOT NULL,
                        message TEXT NOT NULL,
                        error_code TEXT,
                        component TEXT,
                        stack_trace TEXT,
                        context TEXT,
                        system_info TEXT,
                        user_agent TEXT,
                        url TEXT,
                        fingerprint TEXT,
                        status TEXT NOT NULL DEFAULT 'new',
                        reported_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        resolved_at DATETIME,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Crash reports table
                `CREATE TABLE IF NOT EXISTS crash_reports (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        signal TEXT NOT NULL,
                        message TEXT NOT NULL,
                        stack_trace TEXT,
                        context TEXT,
                        system_info TEXT,
                        fingerprint TEXT,
                        status TEXT NOT NULL DEFAULT 'new',
                        reported_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        resolved_at DATETIME,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Log collections table
                `CREATE TABLE IF NOT EXISTS log_collections (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        name TEXT NOT NULL,
                        description TEXT,
                        components TEXT,
                        log_level TEXT,
                        start_time DATETIME,
                        end_time DATETIME,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        completed_at DATETIME,
                        status TEXT NOT NULL DEFAULT 'pending',
                        entry_count INTEGER DEFAULT 0,
                        filters TEXT,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Log entries table
                `CREATE TABLE IF NOT EXISTS log_entries (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        collection_id INTEGER NOT NULL,
                        timestamp DATETIME NOT NULL,
                        level TEXT NOT NULL,
                        component TEXT NOT NULL,
                        message TEXT NOT NULL,
                        context TEXT,
                        FOREIGN KEY (collection_id) REFERENCES log_collections(id)
                )`,

                // Log shares table
                `CREATE TABLE IF NOT EXISTS log_shares (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        collection_id INTEGER NOT NULL,
                        user_id INTEGER NOT NULL,
                        share_token TEXT UNIQUE NOT NULL,
                        share_type TEXT NOT NULL,
                        expires_at DATETIME NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        accessed_at DATETIME,
                        is_active BOOLEAN NOT NULL DEFAULT 1,
                        permissions TEXT,
                        recipients TEXT,
                        FOREIGN KEY (collection_id) REFERENCES log_collections(id),
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // System configuration table
                `CREATE TABLE IF NOT EXISTS system_configuration (
                        id INTEGER PRIMARY KEY DEFAULT 1,
                        version TEXT NOT NULL,
                        configuration TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,

                // Wizard progress table
                `CREATE TABLE IF NOT EXISTS wizard_progress (
                        user_id INTEGER PRIMARY KEY,
                        current_step TEXT NOT NULL,
                        step_data TEXT,
                        all_data TEXT,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Wizard completion table
                `CREATE TABLE IF NOT EXISTS wizard_completion (
                        user_id INTEGER PRIMARY KEY,
                        completed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users(id)
                )`,

                // Configuration history table
                `CREATE TABLE IF NOT EXISTS system_configuration_history (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        version TEXT NOT NULL,
                        configuration TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,

                // Configuration backups table
                `CREATE TABLE IF NOT EXISTS configuration_backups (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL,
                        version TEXT NOT NULL,
                        configuration TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,

                // Configuration templates table
                `CREATE TABLE IF NOT EXISTS configuration_templates (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL,
                        description TEXT,
                        category TEXT NOT NULL,
                        configuration TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`,
        }

        for _, table := range tables </span><span class="cov10" title="140">{
                if _, err := db.Exec(table); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create table: %w", err)
                }</span>
        }

        <span class="cov4" title="7">return nil</span>
}

// Benchmark helper functions
func BenchmarkSetup(b *testing.B) *TestSuite <span class="cov0" title="0">{
        // Disable logging during benchmarks
        log.SetOutput(io.Discard)

        // Create a temporary database
        tempDir := b.TempDir()
        dbPath := filepath.Join(tempDir, "benchmark.db")

        db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                b.Fatalf("Failed to open benchmark database: %v", err)
        }</span>

        <span class="cov0" title="0">if err := createTestTables(db); err != nil </span><span class="cov0" title="0">{
                b.Fatalf("Failed to create benchmark tables: %v", err)
        }</span>

        <span class="cov0" title="0">testDB := &amp;TestDatabase{DB: db, Path: dbPath}

        // Create repositories
        userRepo := repository.NewUserRepository(testDB.DB)
        analyticsRepo := repository.NewAnalyticsRepository(testDB.DB)
        favoritesRepo := repository.NewFavoritesRepository(testDB.DB)
        conversionRepo := repository.NewConversionRepository(testDB.DB)
        syncRepo := repository.NewSyncRepository(testDB.DB)
        stressTestRepo := repository.NewStressTestRepository(testDB.DB)
        errorRepo := repository.NewErrorReportingRepository(testDB.DB)
        crashRepo := repository.NewCrashReportingRepository(testDB.DB)
        logRepo := repository.NewLogManagementRepository(testDB.DB)
        configRepo := repository.NewConfigurationRepository(testDB.DB)

        // Create auth service
        authService := services.NewAuthService(userRepo, "test-jwt-secret")

        // Create services
        analyticsService := services.NewAnalyticsService(analyticsRepo)
        favoritesService := services.NewFavoritesService(favoritesRepo, authService)
        conversionService := services.NewConversionService(conversionRepo, userRepo, authService)
        syncService := services.NewSyncService(syncRepo, userRepo, authService)
        stressTestService := services.NewStressTestService(stressTestRepo, authService)
        errorReportingService := services.NewErrorReportingService(errorRepo, crashRepo)
        logManagementService := services.NewLogManagementService(logRepo)
        configurationService := services.NewConfigurationService(configRepo, "/tmp/benchmark_config.json")

        return &amp;TestSuite{
                DB:                    testDB,
                UserRepo:              userRepo,
                AuthService:           authService,
                AnalyticsRepo:         analyticsRepo,
                FavoritesRepo:         favoritesRepo,
                ConversionRepo:        conversionRepo,
                SyncRepo:              syncRepo,
                StressTestRepo:        stressTestRepo,
                ErrorRepo:             errorRepo,
                CrashRepo:             crashRepo,
                LogRepo:               logRepo,
                ConfigRepo:            configRepo,
                AnalyticsService:      analyticsService,
                FavoritesService:      favoritesService,
                ConversionService:     conversionService,
                SyncService:           syncService,
                StressTestService:     stressTestService,
                ErrorReportingService: errorReportingService,
                LogManagementService:  logManagementService,
                ConfigurationService:  configurationService,
        }</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package utils

import (
        "log"

        "github.com/gin-gonic/gin"
)

// ErrorResponse represents an error response
type ErrorResponse struct {
        Success bool   `json:"success"`
        Error   string `json:"error"`
        Details string `json:"details,omitempty"`
}

// SuccessResponse represents a success response
type SuccessResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Message string      `json:"message,omitempty"`
}

// SendErrorResponse sends an error response
func SendErrorResponse(c *gin.Context, statusCode int, message string, err error) <span class="cov0" title="0">{
        response := ErrorResponse{
                Success: false,
                Error:   message,
        }

        if err != nil </span><span class="cov0" title="0">{
                response.Details = err.Error()
                log.Printf("Error: %s - %v", message, err)
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, response)</span>
}

// SendSuccessResponse sends a success response
func SendSuccessResponse(c *gin.Context, statusCode int, data interface{}, message string) <span class="cov0" title="0">{
        response := SuccessResponse{
                Success: true,
                Data:    data,
                Message: message,
        }

        c.JSON(statusCode, response)
}</span>

// StringPtr returns a pointer to the given string
func StringPtr(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
