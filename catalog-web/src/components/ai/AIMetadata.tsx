import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Brain, Zap, Search, TrendingUp, Settings, Sparkles, FileText, Image, Video, Music, Download, Share } from 'lucide-react';
import { debounce } from 'lodash';

// Types for AI metadata extraction and automation
interface ExtractedMetadata {
  id: string;
  title: string;
  description: string;
  tags: string[];
  categories: string[];
  confidence: number;
  source: 'ai' | 'manual' | 'hybrid';
  extractedFields: {
    [key: string]: {
      value: any;
      confidence: number;
      source: string;
    };
  };
}

interface AutomationRule {
  id: string;
  name: string;
  description: string;
  trigger: {
    type: 'content_added' | 'schedule' | 'manual' | 'content_updated';
    conditions: {
      field: string;
      operator: 'equals' | 'contains' | 'starts_with' | 'regex';
      value: any;
    }[];
  };
  actions: {
    type: 'categorize' | 'tag' | 'move_to_collection' | 'send_notification' | 'transform';
    parameters: any;
  }[];
  enabled: boolean;
  priority: 'low' | 'medium' | 'high';
  executionCount: number;
  lastExecuted?: string;
}

interface ContentQuality {
  score: number;
  factors: {
    completeness: number;
    accuracy: number;
    engagement: number;
    relevance: number;
  };
  recommendations: string[];
  improvements: {
    type: 'add_metadata' | 'improve_description' | 'add_tags' | 'enhance_content';
    description: string;
    impact: 'high' | 'medium' | 'low';
  }[];
}

interface SmartContent {
  id: string;
  type: 'video' | 'image' | 'document' | 'audio' | 'mixed';
  qualityScore: number;
  autoGenerated: {
    title: string;
    description: string;
    tags: string[];
    thumbnail?: string;
    preview?: string;
  };
  metadata: ExtractedMetadata;
  processing: {
    status: 'pending' | 'processing' | 'completed' | 'failed';
    stage: string;
    progress: number;
  };
}

// Mock AI service for metadata extraction and automation
class AIMetadataService {
  private static delay(ms: number = 600): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // Extract metadata from content using AI
  static async extractMetadata(content: {
    title?: string;
    description?: string;
    fileType?: string;
    size?: number;
    duration?: number;
    url?: string;
  }): Promise<ExtractedMetadata> {
    await this.delay(1200);

    const title = content.title || 'Untitled Content';
    const description = content.description || '';
    
    // Simulate AI analysis based on content properties
    const contentType = this.detectContentType(content.fileType);
    const confidence = 0.75 + Math.random() * 0.2;
    
    // Extract relevant tags based on content
    const tags = this.extractTags(title, description, contentType);
    
    // Determine categories
    const categories = this.determineCategories(title, description, contentType);

    return {
      id: `metadata-${Date.now()}`,
      title: this.generateSmartTitle(title, contentType),
      description: this.generateSmartDescription(title, description, contentType),
      tags,
      categories,
      confidence,
      source: 'ai',
      extractedFields: {
        contentType: { value: contentType, confidence: 0.95, source: 'file_analysis' },
        quality: { value: this.assessQuality(content), confidence: 0.80, source: 'ai_analysis' },
        engagement: { value: this.predictEngagement(content), confidence: 0.70, source: 'ml_model' },
        duration: content.duration ? { value: content.duration, confidence: 0.90, source: 'metadata' } : undefined,
        size: content.size ? { value: content.size, confidence: 0.95, source: 'file_system' } : undefined
      }.filter(Boolean) as any
    };
  }

  // Analyze content quality
  static async analyzeContentQuality(content: any): Promise<ContentQuality> {
    await this.delay(800);

    const completeness = Math.random() * 0.4 + 0.6; // 60-100%
    const accuracy = Math.random() * 0.3 + 0.7; // 70-100%
    const engagement = Math.random() * 0.4 + 0.5; // 50-90%
    const relevance = Math.random() * 0.3 + 0.6; // 60-90%

    const score = (completeness + accuracy + engagement + relevance) / 4;

    return {
      score,
      factors: { completeness, accuracy, engagement, relevance },
      recommendations: this.generateRecommendations(score, content),
      improvements: this.generateImprovements(content, score)
    };
  }

  // Generate automation rules based on patterns
  static async generateAutomationRules(userBehavior: any): Promise<AutomationRule[]> {
    await this.delay(1000);

    return [
      {
        id: 'auto-1',
        name: 'Auto-Categorize Entertainment Content',
        description: 'Automatically categorize entertainment content and add relevant tags',
        trigger: {
          type: 'content_added',
          conditions: [
            { field: 'contentType', operator: 'contains', value: 'video' },
            { field: 'title', operator: 'regex', value: '(movie|film|series|show)' }
          ]
        },
        actions: [
          {
            type: 'categorize',
            parameters: { category: 'Entertainment', subcategory: 'Movies' }
          },
          {
            type: 'tag',
            parameters: { tags: ['entertainment', 'video', 'auto-categorized'] }
          }
        ],
        enabled: true,
        priority: 'medium',
        executionCount: 47,
        lastExecuted: new Date(Date.now() - 1000 * 60 * 30).toISOString()
      },
      {
        id: 'auto-2',
        name: 'Weekly Content Organization',
        description: 'Review and organize content collections weekly',
        trigger: {
          type: 'schedule',
          conditions: [
            { field: 'frequency', operator: 'equals', value: 'weekly' }
          ]
        },
        actions: [
          {
            type: 'move_to_collection',
            parameters: { organizeBy: 'category', mergeSimilar: true }
          }
        ],
        enabled: true,
        priority: 'low',
        executionCount: 12,
        lastExecuted: new Date(Date.now() - 1000 * 60 * 60 * 24 * 3).toISOString()
      }
    ];
  }

  // Process content with AI
  static async processContent(content: any): Promise<SmartContent> {
    await this.delay(1500);

    const contentType = this.detectContentType(content.fileType);
    const qualityScore = Math.random() * 0.3 + 0.7; // 70-100%

    return {
      id: `smart-content-${Date.now()}`,
      type: contentType,
      qualityScore,
      autoGenerated: {
        title: this.generateSmartTitle(content.title, contentType),
        description: this.generateSmartDescription(content.title, content.description, contentType),
        tags: this.extractTags(content.title, content.description, contentType),
        thumbnail: Math.random() > 0.5 ? 'auto-generated-thumbnail.jpg' : undefined,
        preview: Math.random() > 0.7 ? 'auto-generated-preview.mp4' : undefined
      },
      metadata: await this.extractMetadata(content),
      processing: {
        status: 'completed',
        stage: 'metadata_extraction',
        progress: 100
      }
    };
  }

  // Helper methods
  private static detectContentType(fileType?: string): SmartContent['type'] {
    if (!fileType) return 'mixed';
    
    const type = fileType.toLowerCase();
    if (type.includes('video')) return 'video';
    if (type.includes('image')) return 'image';
    if (type.includes('audio') || type.includes('music')) return 'audio';
    if (type.includes('document') || type.includes('pdf') || type.includes('text')) return 'document';
    return 'mixed';
  }

  private static generateSmartTitle(title: string, contentType: string): string {
    if (title && title.length > 10) return title;
    
    const prefixes = {
      video: ['Video:', 'Movie:', 'Documentary:'],
      image: ['Image:', 'Photo:', 'Graphic:'],
      audio: ['Audio:', 'Music:', 'Podcast:'],
      document: ['Document:', 'Article:', 'Report:'],
      mixed: ['Content:', 'Media:', 'File:']
    };

    const prefixList = prefixes[contentType as keyof typeof prefixes] || prefixes.mixed;
    const prefix = prefixList[Math.floor(Math.random() * prefixList.length)];
    
    return title ? `${prefix} ${title}` : `${prefix} Untitled ${contentType}`;
  }

  private static generateSmartDescription(title: string, description: string, contentType: string): string {
    if (description && description.length > 20) return description;
    
    const templates = {
      video: `High-quality video content titled "${title}". Great for entertainment and educational purposes.`,
      image: `Professional image titled "${title}". Perfect for visual content and creative projects.`,
      audio: `Audio content titled "${title}". Ideal for listening and audio experiences.`,
      document: `Document titled "${title}". Contains valuable information and insights.`,
      mixed: `Content titled "${title}". Versatile media with multiple applications.`
    };

    return templates[contentType as keyof typeof templates] || templates.mixed;
  }

  private static extractTags(title: string, description: string, contentType: string): string[] {
    const tags = [contentType, 'ai-generated'];
    
    // Extract keywords from title
    const titleWords = title.toLowerCase().split(' ').filter(word => word.length > 3);
    tags.push(...titleWords.slice(0, 3));
    
    // Extract keywords from description
    if (description) {
      const descWords = description.toLowerCase().split(' ').filter(word => word.length > 3);
      tags.push(...descWords.slice(0, 2));
    }
    
    // Add content type specific tags
    const typeTags = {
      video: ['video', 'multimedia', 'visual'],
      image: ['image', 'photo', 'visual'],
      audio: ['audio', 'sound', 'listening'],
      document: ['document', 'text', 'reading'],
      mixed: ['content', 'media', 'versatile']
    };
    
    tags.push(...typeTags[contentType as keyof typeof typeTags]);
    
    // Remove duplicates and limit to 10 tags
    return [...new Set(tags)].slice(0, 10);
  }

  private static determineCategories(title: string, description: string, contentType: string): string[] {
    const categories = [contentType];
    
    // Simple keyword-based categorization
    const keywords = (title + ' ' + description).toLowerCase();
    
    if (keywords.includes('work') || keywords.includes('business') || keywords.includes('professional')) {
      categories.push('Work');
    }
    if (keywords.includes('entertainment') || keywords.includes('fun') || keywords.includes('leisure')) {
      categories.push('Entertainment');
    }
    if (keywords.includes('education') || keywords.includes('learn') || keywords.includes('tutorial')) {
      categories.push('Education');
    }
    if (keywords.includes('personal') || keywords.includes('family') || keywords.includes('home')) {
      categories.push('Personal');
    }
    
    return categories;
  }

  private static assessQuality(content: any): number {
    let score = 0.5; // Base score
    
    if (content.size && content.size > 1000000) score += 0.2; // Larger files often better quality
    if (content.title && content.title.length > 10) score += 0.1;
    if (content.description && content.description.length > 50) score += 0.1;
    if (content.duration && content.duration > 30) score += 0.1; // Longer content
    
    return Math.min(score, 1.0);
  }

  private static predictEngagement(content: any): number {
    let prediction = 0.3; // Base prediction
    
    if (content.title && content.title.length > 15) prediction += 0.1;
    if (content.description && content.description.length > 100) prediction += 0.1;
    if (content.tags && content.tags.length > 5) prediction += 0.1;
    if (content.categories && content.categories.length > 2) prediction += 0.1;
    
    // Add some randomness
    prediction += Math.random() * 0.3;
    
    return Math.min(prediction, 1.0);
  }

  private static generateRecommendations(score: number, content: any): string[] {
    const recommendations = [];
    
    if (score < 0.7) {
      recommendations.push('Improve content metadata for better discoverability');
      recommendations.push('Add more descriptive tags and categories');
    }
    if (score < 0.8) {
      recommendations.push('Enhance description with more details');
    }
    if (!content.thumbnail) {
      recommendations.push('Add thumbnail for visual appeal');
    }
    
    return recommendations;
  }

  private static generateImprovements(content: any, score: number): ContentQuality['improvements'] {
    const improvements: ContentQuality['improvements'] = [];
    
    if (!content.description || content.description.length < 50) {
      improvements.push({
        type: 'improve_description',
        description: 'Add a more detailed description (minimum 50 characters)',
        impact: 'medium'
      });
    }
    
    if (!content.tags || content.tags.length < 5) {
      improvements.push({
        type: 'add_tags',
        description: 'Add more relevant tags (minimum 5 recommended)',
        impact: 'high'
      });
    }
    
    if (!content.categories || content.categories.length < 2) {
      improvements.push({
        type: 'add_metadata',
        description: 'Categorize content for better organization',
        impact: 'high'
      });
    }
    
    return improvements;
  }
}

// AI Metadata Extractor Component
interface AIMetadataExtractorProps {
  content: any;
  onMetadataExtracted: (metadata: ExtractedMetadata) => void;
}

export const AIMetadataExtractor: React.FC<AIMetadataExtractorProps> = ({
  content,
  onMetadataExtracted
}) => {
  const [metadata, setMetadata] = useState<ExtractedMetadata | null>(null);
  const [loading, setLoading] = useState(false);
  const [extracting, setExtracting] = useState(false);

  const extractMetadata = async () => {
    setExtracting(true);
    try {
      const result = await AIMetadataService.extractMetadata(content);
      setMetadata(result);
      onMetadataExtracted(result);
    } catch (err) {
      console.error('Failed to extract metadata:', err);
    } finally {
      setExtracting(false);
    }
  };

  if (extracting) {
    return (
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
        <div className="text-center py-4">
          <Brain className="w-8 h-8 text-indigo-600 mx-auto mb-3 animate-pulse" />
          <p className="text-gray-600">AI is extracting metadata...</p>
        </div>
      </div>
    );
  }

  if (!metadata) {
    return (
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
        <div className="flex items-center space-x-3 mb-4">
          <FileText className="w-5 h-5 text-indigo-600" />
          <h3 className="font-semibold text-gray-900">AI Metadata Extraction</h3>
        </div>
        <div className="text-center py-4">
          <p className="text-gray-600 mb-4">Extract rich metadata using AI analysis</p>
          <button
            onClick={extractMetadata}
            className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors flex items-center space-x-2 mx-auto"
          >
            <Zap className="w-4 h-4" />
            <span>Extract Metadata</span>
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
      <div className="flex items-center space-x-3 mb-4">
        <FileText className="w-5 h-5 text-indigo-600" />
        <h3 className="font-semibold text-gray-900">Extracted Metadata</h3>
        <div className="ml-auto flex items-center space-x-2">
          <div className="w-2 h-2 rounded-full bg-green-500"></div>
          <span className="text-sm text-gray-600">AI-Generated</span>
        </div>
      </div>

      <div className="space-y-4">
        <div>
          <label className="text-sm font-medium text-gray-700">Title</label>
          <p className="text-gray-900">{metadata.title}</p>
        </div>

        <div>
          <label className="text-sm font-medium text-gray-700">Description</label>
          <p className="text-gray-600 text-sm">{metadata.description}</p>
        </div>

        <div>
          <label className="text-sm font-medium text-gray-700">Tags</label>
          <div className="flex flex-wrap gap-2 mt-1">
            {metadata.tags.map(tag => (
              <span key={tag} className="px-2 py-1 bg-indigo-100 text-indigo-700 rounded-full text-xs">
                {tag}
              </span>
            ))}
          </div>
        </div>

        <div>
          <label className="text-sm font-medium text-gray-700">Categories</label>
          <div className="flex flex-wrap gap-2 mt-1">
            {metadata.categories.map(category => (
              <span key={category} className="px-2 py-1 bg-green-100 text-green-700 rounded-full text-xs">
                {category}
              </span>
            ))}
          </div>
        </div>

        <div className="pt-3 border-t border-gray-100">
          <div className="flex items-center justify-between mb-2">
            <span className="text-sm font-medium text-gray-700">Confidence</span>
            <span className="text-sm text-gray-600">{Math.round(metadata.confidence * 100)}%</span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-2">
            <div 
              className="bg-indigo-600 h-2 rounded-full"
              style={{ width: `${metadata.confidence * 100}%` }}
            ></div>
          </div>
        </div>

        <button
          onClick={extractMetadata}
          className="text-sm text-indigo-600 hover:text-indigo-800 transition-colors"
        >
          Re-extract Metadata
        </button>
      </div>
    </div>
  );
};

// AI Automation Rules Component
interface AIAutomationRulesProps {
  onRuleToggle: (ruleId: string, enabled: boolean) => void;
  onRuleExecute: (ruleId: string) => void;
}

export const AIAutomationRules: React.FC<AIAutomationRulesProps> = ({
  onRuleToggle,
  onRuleExecute
}) => {
  const [rules, setRules] = useState<AutomationRule[]>([]);
  const [loading, setLoading] = useState(false);
  const [expandedRule, setExpandedRule] = useState<string | null>(null);

  const loadRules = useCallback(async () => {
    setLoading(true);
    try {
      const result = await AIMetadataService.generateAutomationRules({});
      setRules(result);
    } catch (err) {
      console.error('Failed to load automation rules:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    loadRules();
  }, [loadRules]);

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'high': return 'text-red-600 bg-red-50';
      case 'medium': return 'text-yellow-600 bg-yellow-50';
      case 'low': return 'text-green-600 bg-green-50';
      default: return 'text-gray-600 bg-gray-50';
    }
  };

  if (loading) {
    return (
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
        <div className="flex items-center space-x-3 mb-4">
          <Settings className="w-5 h-5 text-indigo-600" />
          <h3 className="font-semibold text-gray-900">AI Automation Rules</h3>
          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-indigo-600 ml-auto"></div>
        </div>
        <div className="space-y-3">
          {[1, 2].map(i => (
            <div key={i} className="animate-pulse">
              <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
              <div className="h-3 bg-gray-200 rounded w-full"></div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
      <div className="flex items-center space-x-3 mb-4">
        <Settings className="w-5 h-5 text-indigo-600" />
        <h3 className="font-semibold text-gray-900">AI Automation Rules</h3>
        <Sparkles className="w-4 h-4 text-yellow-500 ml-auto" />
      </div>

      {rules.length === 0 ? (
        <p className="text-gray-500 text-sm">No automation rules available.</p>
      ) : (
        <div className="space-y-3">
          {rules.map(rule => (
            <div key={rule.id} className="border border-gray-100 rounded-lg p-3">
              <div 
                className="flex items-start justify-between cursor-pointer"
                onClick={() => setExpandedRule(
                  expandedRule === rule.id ? null : rule.id
                )}
              >
                <div className="flex-1">
                  <div className="flex items-center space-x-2">
                    <h4 className="font-medium text-gray-900">{rule.name}</h4>
                    <span className={`text-xs px-2 py-1 rounded ${getPriorityColor(rule.priority)}`}>
                      {rule.priority}
                    </span>
                  </div>
                  <p className="text-sm text-gray-600 mt-1">{rule.description}</p>
                  <div className="flex items-center space-x-4 mt-2 text-xs text-gray-500">
                    <span>Executed {rule.executionCount} times</span>
                    {rule.lastExecuted && (
                      <span>Last: {new Date(rule.lastExecuted).toLocaleDateString()}</span>
                    )}
                  </div>
                </div>
                <div className="flex items-center space-x-2">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      onRuleToggle(rule.id, !rule.enabled);
                    }}
                    className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                      rule.enabled ? 'bg-indigo-600' : 'bg-gray-200'
                    }`}
                  >
                    <span
                      className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                        rule.enabled ? 'translate-x-6' : 'translate-x-1'
                      }`}
                    />
                  </button>
                </div>
              </div>

              {expandedRule === rule.id && (
                <div className="mt-4 pt-3 border-t border-gray-100 space-y-3">
                  <div>
                    <h5 className="text-sm font-medium text-gray-700 mb-2">Trigger</h5>
                    <div className="text-sm text-gray-600">
                      <span className="font-medium">Type:</span> {rule.trigger.type}
                    </div>
                    {rule.trigger.conditions.length > 0 && (
                      <div className="mt-1">
                        <span className="font-medium">Conditions:</span>
                        <ul className="list-disc list-inside text-xs text-gray-600 mt-1">
                          {rule.trigger.conditions.map((condition, index) => (
                            <li key={index}>
                              {condition.field} {condition.operator} {condition.value}
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>

                  <div>
                    <h5 className="text-sm font-medium text-gray-700 mb-2">Actions</h5>
                    <ul className="space-y-1">
                      {rule.actions.map((action, index) => (
                        <li key={index} className="text-sm text-gray-600">
                          <span className="font-medium">{action.type}:</span> {JSON.stringify(action.parameters)}
                        </li>
                      ))}
                    </ul>
                  </div>

                  <button
                    onClick={() => onRuleExecute(rule.id)}
                    className="w-full px-3 py-2 bg-indigo-600 text-white text-sm rounded-lg hover:bg-indigo-700 transition-colors"
                  >
                    Execute Rule Now
                  </button>
                </div>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

// AI Content Quality Analyzer Component
interface AIContentQualityAnalyzerProps {
  content: any;
  onQualityImprovement: (improvement: string) => void;
}

export const AIContentQualityAnalyzer: React.FC<AIContentQualityAnalyzerProps> = ({
  content,
  onQualityImprovement
}) => {
  const [quality, setQuality] = useState<ContentQuality | null>(null);
  const [loading, setLoading] = useState(false);
  const [analyzing, setAnalyzing] = useState(false);

  const analyzeQuality = async () => {
    setAnalyzing(true);
    try {
      const result = await AIMetadataService.analyzeContentQuality(content);
      setQuality(result);
    } catch (err) {
      console.error('Failed to analyze content quality:', err);
    } finally {
      setAnalyzing(false);
    }
  };

  if (analyzing) {
    return (
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
        <div className="text-center py-4">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mx-auto mb-3"></div>
          <p className="text-gray-600">AI is analyzing content quality...</p>
        </div>
      </div>
    );
  }

  if (!quality) {
    return (
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
        <div className="flex items-center space-x-3 mb-4">
          <TrendingUp className="w-5 h-5 text-indigo-600" />
          <h3 className="font-semibold text-gray-900">AI Quality Analysis</h3>
        </div>
        <div className="text-center py-4">
          <p className="text-gray-600 mb-4">Analyze content quality and get improvement suggestions</p>
          <button
            onClick={analyzeQuality}
            className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors flex items-center space-x-2 mx-auto"
          >
            <Brain className="w-4 h-4" />
            <span>Analyze Quality</span>
          </button>
        </div>
      </div>
    );
  }

  const getScoreColor = (score: number) => {
    if (score >= 0.8) return 'text-green-600';
    if (score >= 0.6) return 'text-yellow-600';
    return 'text-red-600';
  };

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4">
      <div className="flex items-center space-x-3 mb-4">
        <TrendingUp className="w-5 h-5 text-indigo-600" />
        <h3 className="font-semibold text-gray-900">Content Quality Analysis</h3>
        <div className="ml-auto flex items-center space-x-2">
          <div className={`text-2xl font-bold ${getScoreColor(quality.score)}`}>
            {Math.round(quality.score * 100)}%
          </div>
        </div>
      </div>

      <div className="space-y-4">
        <div>
          <h4 className="text-sm font-medium text-gray-700 mb-2">Quality Factors</h4>
          <div className="space-y-2">
            {Object.entries(quality.factors).map(([factor, score]) => (
              <div key={factor} className="flex items-center justify-between">
                <span className="text-sm text-gray-600 capitalize">{factor}</span>
                <div className="flex items-center space-x-2">
                  <div className="w-20 bg-gray-200 rounded-full h-2">
                    <div 
                      className={`h-2 rounded-full ${getScoreColor(score)}`}
                      style={{ width: `${score * 100}%` }}
                    ></div>
                  </div>
                  <span className="text-sm text-gray-600">{Math.round(score * 100)}%</span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {quality.recommendations.length > 0 && (
          <div>
            <h4 className="text-sm font-medium text-gray-700 mb-2">Recommendations</h4>
            <ul className="space-y-1">
              {quality.recommendations.map((rec, index) => (
                <li key={index} className="text-sm text-gray-600 flex items-start space-x-2">
                  <Sparkles className="w-3 h-3 text-yellow-500 mt-0.5 flex-shrink-0" />
                  <span>{rec}</span>
                </li>
              ))}
            </ul>
          </div>
        )}

        {quality.improvements.length > 0 && (
          <div>
            <h4 className="text-sm font-medium text-gray-700 mb-2">Improvement Actions</h4>
            <div className="space-y-2">
              {quality.improvements.map((improvement, index) => (
                <div key={index} className="flex items-start justify-between p-2 bg-gray-50 rounded">
                  <div>
                    <div className="flex items-center space-x-2">
                      <span className="text-sm font-medium text-gray-900">{improvement.type}</span>
                      <span className={`text-xs px-2 py-1 rounded ${
                        improvement.impact === 'high' ? 'bg-red-100 text-red-700' :
                        improvement.impact === 'medium' ? 'bg-yellow-100 text-yellow-700' :
                        'bg-green-100 text-green-700'
                      }`}>
                        {improvement.impact} impact
                      </span>
                    </div>
                    <p className="text-xs text-gray-600 mt-1">{improvement.description}</p>
                  </div>
                  <button
                    onClick={() => onQualityImprovement(improvement.description)}
                    className="text-xs text-indigo-600 hover:text-indigo-800 transition-colors"
                  >
                    Apply
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}

        <button
          onClick={analyzeQuality}
          className="text-sm text-indigo-600 hover:text-indigo-800 transition-colors"
        >
          Re-analyze Quality
        </button>
      </div>
    </div>
  );
};

// Export AI metadata service for external use
export { AIMetadataService };
export type { ExtractedMetadata, AutomationRule, ContentQuality, SmartContent };